the reorganization of the slides is completed and the blockchain holding the slides has been finalized let's resume so this is a stack that we provide at the very base we have our own modular smart contract implementation this is our own implementation that is very minimal by Design and we have implementations for modules like session Keys batch transactions pass keys and obviously the normal ecdsa validation module so whenever a user deploys a wallet they have of the ability to choose how transactions are validated by default the the implementation of the modular smart contract wallet by itself doesn't really make any assumptions about how the move wallet is controlled and then on top of this it's not pictured in the slide but we have a client facing typescript SDK which the apps are able to integrate into their front end and that is responsible for setting up the smart contract wallet on behalf of the user handling deployments talking to various Services negotiating with the bundler negotiating with the paymaster services and stuff like that and then on the in front level we provide two major Services one is the pay Master service so we have our own implementations of a token pay Master through which users are able to pay in any token of that they choose like an erc20 token and we have a verifying pay Master which allows that developers to customize the conditions under which they might want to sponsor a transaction like for example a dab might want to sponsor a transaction when it it it lines on their specified app or contract so we run services for that and then we run our own bundler our bundler is a typescript implementation that essentially captures the stack that we provide and yeah I mentioned that one of the primary focus for bike on me these days is to take multi-step interactions from the user and figure out a way to compress them to like take it down to as low of the steps as possible and these days I would say a major path that we are trying to take to achieve that is through modules so as you saw in the erc6900 standard there can be multiple types of modules there can be modules that that uh that change the way transactions are validated like through a normal eoa uh using the Segway 256 K1 curve or through a pass key which is stored on your Hardware on your phone in a secure Hardware Enclave or even something like a multi-sip and then there are other modules which I'm going to talk about and then there are execution modules which change the way or modify the way in which a smart contract wallet can do execution like a custom execution function to find out tokens or something like that so the way we do this is we combine these modules and our modules are composable in the sense that multiple modules can be used with each other and that is how we kind of ah reduce the number of steps by by looking at a use case and then figuring out okay what are the interactions and then figuring out what module can act as a ux Improvement layer for that so before talking about some of our modules I would like to give a brief overview about how our smart contract wallets are implemented and that is the modular account architecture so this is the second version of our smart contract implementation in in the first version we always had an implicit assumption that a smart contract wallet would be always controlled by an EOS but we found out that this is not necessarily the case because in future it could be the case that there's a smart contract wallet but there is no notion of EOS it could be the case that it's just controlled by a hardware wallet private key using the R1 curve or it could just be the case that there is not there is there isn't a single year that's controlling the wallet it's just that uh it's controlled by in a multi-stick fashion or through or something like that so by default our smart contract implementation doesn't really make any assumption about how the transactions are violated this also means that the smart contract wallet does not store any state at all except the fact that which modules are currently implemented are currently enabled on that particular smart contract wallet so the way you create a smart contract wallet is that when you ask the SDK to deploy it the user is allowed to specify the way in which they want validation to be done so for the very basic use case the user is just able to specify that okay this is an EOS which I own and please use the default ecdsa K1 a validation module so that my uoa can sign the user operations that I create and then all of the validation for those Europe user operations would be run through this module it could also be the case that the the user just specifies a different module and then this K1 verification never happens inside the smart contract wallet and then this is not a strict requirement for us but what we've kind of found through practice is that it's better to keep our modules Singleton and multi-tenant what I mean by this is that uh let's say that I create a module to do pass unification using the R1 curve right I won't really deploy multiple uh the the this module multiple times for every user all of the users would essentially be pointing to the same instance of the smart contract which contains this module implementation and then during the smart contract initialization this particular module would just store the details for every user using something like a mapping or any storage pattern that it wants to use uh by itself but essentially there is going to be one contract and all of the smart contract wallets which want to use that particular module are just going to reference to it instead of deploying another copy uh the the benefit for the of this is mostly that it saves on deployment costs and we haven't really found a need to have like multiple deployments uh I I don't really think that enables another use case but obviously uh would be interested in knowing if you have something in mind that would benefit from that kind of pattern and uh yeah this is just a diagram that shows how the smart contract initialization works during deployment so there is a smart contact Factory which can be called independently but is normally called using the entry point during the when the user operation contains the unit code that unit code is essentially a call to the smart contract Factory which is going to deploy the smart contract wallet and that init code is going to contain a reference to this Singleton multi-tenant module and once the smart contract has stored in its storage that okay this is the module that I want to use as a default validation module it's just going to do a call to the module in in this case just called setup for essay and this then this module is going to store whatever information it wants and in the case of let's say a basic ecdsa K1 okay for this particular smart account at this address this is the owner so it's just a mapping from the smart account address to the owner address and yeah so for this particular presentation I would like to focus on validation modules our current smart contract architecture supports validation and execution modules by default and we are in the process of adding support for ERC 6900 so we would be support we would be able to support Hooks and uh I guess yeah I mean I believe there are two more classes of modules the one of them is books and uh there is one more type of model we'll have support for that so essentially a validation module is a module that modifies the rules for validating a user operation by the CW and examples are session Keys pass keys and on-chain automation I believe the automation use case is interesting because you can essentially create a validation module which delegates the access of an account to certain parties like an option service which manages automations for users so for example let's say there is a user which wants to do DCA to the smart contract wallet right so what they could do is they could just install a module which verifies that a user operation has been signed by a particular let's say eoa and this eoa is owned by an option service and that option service is then essentially allowed to sign user operations on behalf of the user but then this module is also doing some validations in the validation phase of the user operation which could be that this particular user operation must be executed at a certain point of time and the call rate of the user operation should exactly be something like Dex dot call with a certain amount of tokens and a particular address of token or or an array of tokens and there could be as many validations as required inside the automation validation module obviously subject to the the rules of the public mempool imposed by the bundlers and how do you create a validation module for our smart contract model so it's pretty simple this is the interface which is very similar to the interface of the smart contract wallet itself as defined by erc4337 and what you do is you just Define a function called validate user op which takes the user operation struct and the user operation hash this is generally calculated by the entry point itself and it just Returns the validation data in case of 4337 this validation data is essentially a concatenation of three Fields a Boolean representing whether the user operation is valid or not and then a time frame essentially valid until and valid after the two uh boundaries for the time in which the user operation is valid so you can build a module which controls like within what time duration is uh user operation actually valid right and if you want to store some data for the user when the module is being initialized like some module specific configuration for the smart contract wallet you can also Implement a function like setup or set up an uh setup module or you can essentially name it anything there is no restriction on that because as you are able to essentially pass arbitrary call data during any initialization which would be called on this model and then that called Data would essentially get executed on this module during initialization so it's pretty simple for anybody to create a validation module on our smart contract wallet and this is how the validation flow looks like when the actual execution is being done for a user operation so the entry point is going to call the smart code this is the this is the validation phase of the execution of of of the transaction in which a user operation is executed so the entry point is going to call validate user operation on the smart contract or the smart account and the smart account is going to then look at the user operation and it will figure out which uh smart contract which module is essentially responsible for validating this authorization module now how is this done the way it's done is that we essentially use the signature field of the user operation this signature field is something which we Define as the place where you can put custom validation data for your module so in the very simple case where your user operations are being validated by an eoa the signature is going to be an actual ecdss signature of of the use of operation hash with that particular private key but if you want to design a custom module what you can do is you can put some arbitrary data inside that signature so and that signature is just going to be uh that signature is going to correspond to a particular the format of that signature is going to correspond to a particular validation module and also the signature in itself contains the address of the module that should be used to validate this user operation so what happens is that the smart account internally is going to look at the signature field it's going to extract the mod the address of the validation module it's going to verify whether the validation module is actually something which has been enabled before or not once it has verified that it's going to pass in the rest of the data in that signature whatever that arbitrary data is to the module at the at the address which it extracted before and call this function called wired user off and then the authorization module is free to do whatever validation it wants and then it will return the validation data which is a concatenation of the three Fields the the like a Boolean representing whether the op is valid or not and the time frame in which it should be considered as valid this is all the execution model yeah like where are the executions model uh no this is only for the validation flow the execution flow is completely different yeah okay so now this is like the Highlight in my opinion of this particular presentation we've been working on a module which is able to provide single signature and multi execution module because this module a multi-chain validator module and what it essentially allows you to do is once this module has been enabled on let's say you you essentially have three smart contract Wallets on three chains right once this multigen my validator module has been enabled on three different chains what this allows you to do is to execute three different user operations arbitrarily uh on the smart contract wallets of these three different chains with just one signature without this module what would have to do is you have to create three different uh user operations individually sign each of them with whatever validation module you're using if you're using a normal eoa based validation model you'll have to do a metamask sign for each of those user operations Thrive and then you'd have to submit all of them uh separately right but what this module allows you to do is that you create three user operations but then the user has to sign only once and that same signature can be used to validate the user operation on all three chains without any loss of security or replay production so how do we do that uh so this is the internal working of the multi chain validator module but I'll show you a diagram instead and I think that's going to make it much more understandable so what we do is let's say that the user has a wallet on four chains right on ethereum polygon Avalanche and base now for whatever reason they want to execute four independent operations on these wallets right they create a partial user of a partial user of essentially a user of with all of the fields like call data and whatever is required to figure out what's being executed without the signature and stuff like gas and also a partial user representative just tells you that uh like what is actually being executed and where it should go right you create those user operations you calculate their hash the the user operation hash and then you also specify the validity for this user operation the valid until and valid after this is again something which can be the same for all of the four chains or it could also be different and then you arrive at the actual Leaf hashes of these corresponding operations now what we do is we just grow a Merkel Tree on top of these four hashes and then we end up with a Merkel root on the top now this Merkel root is the actual data that the user is going to sign with their private key now what happens during execution is okay do I have a slide for that okay no worries yeah so what happens during execution is that let's say now now that I have the signature the multi-chain validator module is just going to accept as a part of its custom signature format the Merkel root the signature and then for whichever user operation needs to be executed the Merkel proof of that particular user operation so what it's going to do is that the first thing that is going sorry okay novice the first thing is going to check is whether the multi-chain validator module has been enabled or not uh that's the base case assuming that has been done it's then going to verify whether this this Merkel route has been signed with a known private key or a known address or not once it has established the authenticity of this marker route then it will verify whether the user operation is actually a part of this Merkel tree or Not by verifying the provided Miracle proof and once all of this is verified now the smart contact wallet knows that the user actually did sign over n number of user operations and it is safe to actually execute this user operation on behalf of the user and this can happen on all four chains in any possible order and there is no restriction or assumption on the contents of these user operations all of them can be completely independent in terms of their data I would say the only uh constraint here is that you need to know the next nons for the user operations on all of the chains for all of the wallet for all of the wallets so if let's say your ethereum uh your ethereum wallet has that has already executed for user operations you need to keep a nouns of five year and similarly you'd have to know the next nonsense for each of the user operations but this is something that we've been thinking about and uh the semi-abstracted non-functionality of the use of the entry point is something that we are thinking about like we could probably leverage it to create uh to solve this like it's still something we are actively thinking about but yeah this is how the multi-chain validator module Works in practice now you might have realized that the validations the validation algorithm for this module doesn't actually uh place a constraint on the user operations being actually from different chains so in theory yes it is actually possible to sign multiple user operations for the same chain with this model but uh we feel that it's it actually doesn't make sense to do this in a lot of scenarios because uh every smart contact wallet has an intrinsic batching functionality right like you have a function called execute batch on every on more smart contract model implementations so it's just better to if you want to create multiple user operations of the for the same chain to do that I think it's just better to use the intrinsic batching functionality and like do multiple operations within a single user operation sorry do multiple executions within a single user operation itself uh yep now what are the security considerations along around this module right so notice that from the user's perspective they are actually signing a Merkel route right which is an arbitrary bytes 32. for a user there is nowhere to actually look at this bytes 32 hash and figure out okay what is actually happening inside this Merkel tree like what are the contents of this Merkel tree unless that app actually specifically shows it to them it's difficult right but this is actually a concern for normal user Ops right now as well because when the user signs a user operation a single user operation for the normal case even then they're actually just signing on the hash of the user operation which is a similar uh it's a similar interest assumption right although this is also something that we've been thinking around how to solve and like yeah I would really love to hear your thoughts around if you have anything on how this can be improved and yeah lastly I would just like to explain a potential use case that we found for the multi-chain validator module and this involves composibility or essentially using multiple modules for a single use case now what was the problem right so just to give some context rate is essentially a Perpetual protocol and this is not the problem the the that's a that's a really good thing the the actual problem is that so what these guys wanted was they wanted to create a they are creating a multi-chain perpetuals protocol and they wanted to allow a way to provide fund allegation on all of the chains that they support So essentially a user comes to the platform they have assets on five different chains now when you're actually staking on a Perpetual platform right like latency is the key like you want to click a button and you want your funds to like go inside the protocol immediately right now if the if they wait for the user to sign it might actually be too late so they wanted to have a way where users actually give them permission to use a certain amount of tokens uh in whatever way that they want and then this should also be possible for all of the change that support right so what are the options option one is that on let's say there are five chains right let's say that the user deploys the smart contract wallet on five chains and now what race track does is they just ask the users to give them approval on five different chains and that technically works right but what's the problem with is the problem is that you give an approval but then you never know how long that approval is going to last like how like you have to manually revoke the approval later if you want it to be revoked right unless you actually use whatever tokens you have approved this approver is going to stay so it's not a very clean solution a slightly more cleaner solution is using scws plus session keys so session keys are essentially another type of validation module that we created and they're very widely known in the community uh session Keys allow you to essentially program any functionality which once enabled the delegated entity is able to perform on your smart contract wallet on behalf of the user but only for a very limited time so by principles session keys are supposed to be a formal and very short-lived like it's like you gave an approval but only for five minutes and the way we implement it is that we just create a module which allows you to which does some validations but then it essentially returns a very strict time in which it is supposed to use but while this also works the issue here is still that the user would have to enable these session key modules on all five chains separately right so even though this works it's still going to be five different interactions from the user's perspective so what's the final solution we use scw plus session case plus multi-chain validator modules the flow looks like this a user who has never used registered comes to the platform they essentially deploy five different smart contract wallets through bicones SDK integrated into registered but during the during deployment they enable the multi-chain validator module as the default validation module right now once this has been done what registered can do is they can use the multi-chain Violator module create five user operations for each of the chains and these user operations are what are going to enable the session keys so on step two race trade is able to ask the user for one signal single signature and then execute five different user operations on all five chains the session keys are now enabled and now rage trade has access to a certain amount of tokens on the user's wallet for a limited amount of time and now whenever the user wants to use their protocol they just click a button and then internally reach trades servers are used to are able to use the session keys to do the transaction without a signature yep that's how this particular use case works finally taking a step back what's in the pipeline for us so yeah 6900 compatibility is something that we've been focusing heavily on and it's something that we'll have something on soon uh this obviously includes the features that come with 6900 like hooks and we are looking at different modules like on the security side we are looking to leverage stuff like 2fa uh there are multiple ways of that we have thought about for implementing 2fa like there is stuff around the CK like we could essentially generate some otps and then later prove uh create a proof that proves the ownership of this particular OTP but there are other uh patterns that we've been looking into for implementing it and intense yes I had to include it uh but yeah I believe like on a more serious note erc4337 is something I feel is going to be a part of the wider intense picture and the reason for that is when I think about intents right it could be a very generic thing like like I say that I have five tokens and I want them to be ah I want them to be converted to let's say an nft right now in my opinion this could be a collaboration between the way of solving this could be a collaboration between a solver who knows how to convert a particular token to an nft like whatever Pathways or algorithms that they want to use and a collaboration between a solver that knows how to how to deal with erc4337 wallets specifically so there are two solvers one is providing the information around how to actually efficiently do an nft transfer and another is providing the the knowledge on how to do this in a single interaction right so 437 I feel is going to be one of the key one of the components to make sure that the intent execution happens in as little user interactions as possible and then on lastly on the registry and so with all of our modules we've been looking into how to uh how to make sure that there is visibility on them so we've been looking at rhinestones uh registry standard and yeah we will be looking forward to integrate our modules into that uh yeah and this is our Forum feel free to post your thoughts any discussions any any way you feel our contracts can be improved or any criticism or any discussions happy to uh discuss on anything on that [Applause] just one question thanks for the presentation curious to hear about like how many user operations have been powered by it by commonly do you have any I believe you just crossed 100K right we just crossed 100K that's awesome so with regards to our execution modules it's essentially a way where we so we enable the module and then it does that there is a con the the execution pathway such that the smart contract is going to call a module and the module is just going to do a call back to the smart contract and the smart contract is just going to listen to whatever the module has to say so say for example uh there is a swap module there's a swipe execution module right what's going to happen is that the user is going to request that the smart contract wallet use this particular swap execution data for whatever it wants to do in whatever fashion it wants to and then the swap execution model is going to do a callback to the smart contract wallet so that this particular quality is executed from the context of the smart contract wallet and this can happen any number of times inside a single user operation yeah okay I can change I can add new callbacks to that array that listen or callbacks later hmm I'm gonna have to think about that yeah okay it makes sense it seems important to uh tile these different countries together yep we try to measure like from like SLA perspective was there going to be like downside under like pick a big demand under like uh how many request per second per second those kinds of metrics so this is something that we have pain looking at uh the concrete numbers is something that I don't I haven't looked at in a while but I should be able to provide it to you offline I believe we are going to publish the numbers sooner our documentation as well so yeah I'm wondering like how scalable is this like if I want and then just one more question on how come is the system can you like a princess if I want to see you and I'll give me can I do this together you can you can so across all of our products there is no assumption being made around like which bundler should be used with the smart contract wallet or which or whether the paymaster should be used the particular bundle implementation or not all of our services are independent in the sense that you can just use the paymaster or just use the wallet implementation or just use the bundler yep you go to the gassy Market let's say that's your model sort of you cut into the gassy Market yeah yeah okay export some Ninja the gas yeah that makes sense cool thank you so much thank you [Applause] 