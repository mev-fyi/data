I'm going to talk about like private searching or private transactions this um like stuff I've been working on during the recent weeks um here so let's jump right into it um what do I mean by private searching on private transactions um I assume that users want to receive Kickbacks on the Meb to generate um but they still want to keep the transaction Secret and at the same time Searchers want to keep their intellectual property secret right they don't want to reveal their searching strategies to competitors um so the question is can we have both can we is this possible can Searchers generate front running and background and or backgrounding transactions under these conditions um since we're in the area of private Computing here like an obvious um first sgx and when I say sjx here like um I use it synonymously for a trusted um execution environment so I'm just using sjx so a very simple setting here user the user's input is a transaction the input to an enclave the Searcher inputs a program the within the sgx Enclave to run the program that takes the Searcher program and executes it upon the transaction and it outputs the outputs a sign transaction signed background that is sent to the Builder so that sounds great but there is a catch to that right it's the catch is like covert channels and quickly explain what code channels are because it's it's a very Niche topic and hardly anyone knows about it um so copper handles are ways to secretly convey information like in order to do that they piggyback on on so-called over channels and if you're coming from like a telecommunications background you can also think of covert channels um as a way to secretly modulate information on an existing carrier signal it's a bit of abstract most people understand it when you conqu compare covert channels to side channels because people are usually aware of what side channels are it's just a difference in an attacker model so with side channels the attackers extracts aims to extract information um but the attacker does that by observing the observing let's say for example and from from outside the system for example there's an algorithm running um and the attacker can observe the power consumption I think that's a very classic example but with covert channels that has the same goal so to instruct extract the information but it additionally has support from inside the system so there's basically a colluder right so you can also see why it's a um a stronger attack here how does that um relate to the sjx thing well if you think about it um what are like potential orbit channels here um click the design background right this is the output can the can the Searcher program um manipulate the designed background well obviously obviously yes the program could be as simple as saying well take this take the user input and this is this is the output so in order in order to protect again instead we could encrypt another over channel would be network communication there's the such a program could be as simple as saying well open a network connection to a host take the user transaction and send it over to the network so we need to filter that um but it gets tricky if you think what channels in terms of CPU and memory of the host system I think uh Andrew Miller um had a similar Point here so how can we ensure that the Searcher program does not encode secret information in um CPU or memory access or usage patterns you can think of let's say um encoding information in how much CPU is used let's say you're using CPU for one second to code one or for two seconds to code a zero and leak information that way and that is that is very hard to protect against foreign so there's different ways on how to how to go about this well with this seems to be a trade-off right like how expressive should the Searcher program be versus like the existence of information leakage or covert channels we can start with a fully expressive program search a program um then check is the recovered Channel yes restricted let's say we don't allow network communication unless they're still covered Channel yes okay we I don't know we we prevent for Loops let's say but there's always the question is there any leakage left we could go the other way around say um we start um like a fully restrictive program um and ask the question is it useful right so if the Searcher program can't do anything it's obviously useless so we say okay let's um allow editions for example is it useful well probably not the question is at what point is it useful enough it's also hard to say um or we could start start somewhere in the middle between in the expressiveness level um the question is then like where should we go from there um what we decided to do is like to start with um NPC because NPC um interestingly um like guarantees that the parties cannot learn um anything but the output of the function so there are no cover channels there like as a general statement like for this NPC it allows multiple parties to try and compute the public function while keeping the inputs secret so this is a good start to explore the design space going back to the original question like secrets searching on secret transactions how would this look within PC um so instead of using sgx um we now have like an NPC backgrounding protocol right we don't know yet what this would look like um and again we have like the user input transaction search input a program um and the output is a signed back running transaction we just don't know like the question is like what is the back running protocol or like how does it work and what is the Searcher program um and we started experimenting in the MP speeds framework it's a general um NPC framework and I'm gonna quickly present um the the current state of the proof of concept all right so first thing what is the this what does the Searcher program look like and turns out like a search language can be pretty simple so the Searcher program can just consist of like a list of constants a list of computing instructions and Computing instructions are very simple so it's additional subtraction multiplication if a square root that's not a not super simple but still it's um relatively simple instruction but note that there are no loops and there is no branching we cannot allow that um there's a couple of comparison instructions and the list of references for the populating the the background in transaction so what is the what is the backgrounding protocol right here this this middle thing what is the back does the background protocol look like um turns out it's also like this is um like simplified um python-like code but it's just to highlight how it how it works on a high level um we have like a protocol internal storage um if you think about what the transaction is it's just rlp encoded data so the first thing is to decode the data make it a um and populate the storage with that second step is take the constants from the Searcher populate the storage with that Next Step take the searches computations execute the computations one by one on the storage um and then run the comparisons so the Searcher provides a couple of comparisons and note here that there is a success variable and all of the comparisons must be true in order for the success variable to remain true um then in the end like the back running transaction gets populated I think the interesting part here is that um in the end the backgrounding transaction is sent to the Builder if and only if all of the comparisons were true so this is a very abstract introduction of how the proof of concept works we can um work for an example I guess this makes it a bit easier to understand so this is a an example with a real world transaction from last month a user sold 3.75 if for usdt on the units for P2 pool so first step for the protocol would be the decode transaction and populate the storage so you can see here the non-scale limit whatever so it's the the entire transaction in the Second Step um the protocol loads the constants from this provided by the searcher um there's a couple of um going into all the details but constants for the comparison for the backgrounding amount uh and for the background transaction uh what is important to note here is that the Searcher also provides on-chain information right for example here it's the the w e the number of weave tokens in the pool at that point in time or the number of USD tokens at that point in time and I think it's a fair assumption because the Searcher already knows for this for its strategy like what on-chain information is needed and we can expect the Searcher to provide exactly that information so there's no need for the backgrounding protocol to query um the the evm or the if you're in P2P Network for additional information we can just assume the Searcher to provide that information so but um what is the strategy now for the for the search the right the Searcher wants to background a uni swap trade um the the Searcher kind of knows that uh in this particular trade the user sold um uh if to to the to the pool so the size of the pool increased and took out usdt from the pool so the this slightly affected the price obviously in Search and Allstate so that um the price of Eve went down slightly so the question for the Searcher is like how much should I put it like how much what is the amount I can put in in order to um move the price up again to a certain Target price um and you can use the formula like I'm not going to go into the details of the formula but it's um important to note here it's just like a couple of simple computations you have a couple of um multiplications and additions like a division of the square root and all the information is either provided by the searcher right so the fee of the unit spot Market the Target price um the Precision is like the number of decimals for the for the WWE token um or it can be computed um from the info on training in the information provided by the Searcher and the user's transaction for example the why is the amount of Eve in the unit swap with two pool after the user's trade and then that can be computed by the amount of Eve in the pool before the trade plus the plus the amount that the user put in minus the fee so all of this can be computed obviously like they're very important for their searches also like is the background profitable all right so this is also part of the strategy so this is like on a high level the strategy like I've implemented in the proof of concept how does this look like in this search language so this is not nice to read and it's just a snippet I'm only going to explain the first line here so this is like a 4 to 29 so it's this reference is just the the fourth item in the storage two references and multiplication and 29 is the 29th item in the storage so fourth item is the amount the value and the user transaction multiplied multiplied by the in this case Searcher provided constant fee and this is like step by step um the backgrounding protocol can execute the computations provided by the searcher um obviously like it's important that the Searcher wants to um send the background and transaction if and only if um the user transaction actually is um um selling e for ustt because the strategy um the computations provided is really targeted for that and if the background is profitable so there's a couple of comparisons like it works similar way if you look at the first line it's 3 4 23 is um forward storage item this is the two address of the of the user transaction for in this case is the equal operator and 23 is the unit spot V2 router address that was provided by the Searcher as a constant um so it's a couple of comparisons probably the last line is the also an important one is the background profit so I'm greater than zero um so if all those transactions are all those comparisons are true then the background in transactions is created the creating the background in transaction is actually the simplest part of simplest part of that it is just a list of references to storage so let's say that like it's 40 this is the the fourtest element in the storage this is nons and you have the gas limit gas price um and so on and these items are like the values are taken from this from Storage rlp encoded um this is the background in transaction so so this is the the proof of concept um there's a couple of open questions with that um first of all is the search language expressive enough to be useful my gut feeling is yes but it's I'm also not a Searcher so um input on that is highly appreciated you could also see like the the search language like this is very low level and this is very cumbersome and error prone to to work with um so what would uh what what should a high level language look like that compiles down to this low level language um and also like how can we make this practical I mean this proof of concept implemented in the MP speeds framework um like on the single transaction a single um Searcher strategy takes uh like in the strongest security model takes like 40 hours to compute and a couple of hundred gigabytes of back and forth communication so this is nowhere practical so [Music] um so how to make this how to make this practical right I mean we could recall like we started experimenting with NPC because um we needed to restrict the expressiveness of the Searchers program and now we we arrived at the design that we could um uh that is like um restricted and hopefully expressive enough so can we use that and now it now implement it um using sgx and create a practical solution um probably we also need to emulate some npc-like Behavior like execute all branches um have constant time functions but but maybe that's a Way Forward um another way would be to go for uh application specific NPC or um with homomorphic encryption um why is that if you if you zoom out a bit um and the proof of concept design basically has three phases right this extractor data from the user transaction this could happen like on the user machine so this is this is easy the user could use that and encrypt it send it over to the Searcher then the Searcher does a couple of computations on the extracted data in the sub some constants um that sounds exactly like homomorphic encryption and if you think about it like the um we only need to support like very limited um operations so maybe partially homomorphic encryption is sufficient um and if if it is then we have like a reasonably um like uh partially homomorphic encryption schemes with reasonable performance that exist already today um for me like a big open question is like we also need to enforce certain conditions under which the back running transaction is revealed and um I have no clue how to do that in a in a practical way so if you have ideas like go ahead share it um [Music] um yeah so so that's it click the takeaways from this talk if it's if it's just the two takeaways cover channels um I'm afraid to sjx deployments and they should be considered and private searching on private transactions um may be possible even even though they are not obviously not practically at the moment any questions well thank you Robert for this talk uh very interesting for me I didn't appreciate the covered channels for sgx I don't I guess I don't completely understand the how covered channels are addressed in the in the MPC case like yeah um for me like before I started with like playing around with NPC I had like the same issue like same question um the the fun thing is or for me to the inside was like um they're just not an issue with NPC they just don't occur they're all um already by the [Music] um um because you by Design you cannot leak information that's the well a very simple NPC is just the constant function that returns all the inputs uh you know without any doing any operation and that leaks everything leads to whole inputs so that would have oh okay okay sorry like it doesn't leak any information apart from the output the when writing an MP speech program you still kind of have the problem that you have to do if you have an array and you want to do an index into that array that depends on some data like an input dependent lookup you're forced to either do a linear scan through the whole array which costs a lot uh or leaks something by you know publishing which value in the index you want to do and doing some kind of interaction like that so you either need to take this performance penalty or try to you could use an Oram within an MPC that's like one of the things that the you know cryptography Theory relies on sometimes um except the same problem seems to show up anyway right but this is how the proof of concept works so it uses like a the storage is like an o-ram and it works on on that I think if um can you also do any distinction between like covert Channel and um a side Channel like I think that they're they're different and to me that the difference is kind of addressed by um uh remote attestation at least in the sgx setting because um you know if uh if a covert channel would be built into the code it should be visible to you know Auditors looking at the source code to be able to check and at least with remote attestation you know you have that option and and then if you um if you check that the code only does linear scans in sgx just like you would have to with MPC you'd be getting the same guarantee that it's not leaking a channel because it is on doing a data independent uh access I think that the tricky question is like can the the input to your program right that runs within sgx can the input to the program um change the program execution flow in such a way that it leaks information um and sure you can like if you analyze the program and you make sure that this is not the case I totally agree I just think it's it's very hard it's an analysis that's very hard to conduct I I guess my question on the NPC was um like how can you guarantee that the program will output something which is ex you know expected let's say the program is a builder program which builds a block What If instead of building a block it just outputs just the input transactions or maybe in some cases it like let's say a 99 of the case it outputs a block like the expected output but then if Mev is over let's say a thousand if it just leaks all the transactions and then the attacker can just uh I can just front run I I guess that's a it's an issue just um maybe I want um should it clarify it like the the scope for the proof of concept it's just a user search interface right so the output is sent to the Builder and the Builder could see everything in clear text in this case like I don't bother with that like the builders seem to be trusted so let's say the the search leaks the user transaction um it just it can leak to the Builder and the Builder is trusted in this setting so I didn't go any further than Beyond this user search interface strategy remains private among the user in searchroom um but not among like the output is then shared with the Builder and people look and see everything well you can see the output okay so you're writing the the Searcher does not get access to the output only the Builder in the content yeah yeah aha I see but the Builder is trusted right the Builder could act upon the information okay 