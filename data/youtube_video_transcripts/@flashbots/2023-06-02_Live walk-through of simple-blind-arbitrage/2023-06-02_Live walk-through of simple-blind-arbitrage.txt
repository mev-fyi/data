all right um thanks everybody for joining really excited for you all to be here today we're going to be talking about MAV share flash buttons protocol for users and Searchers to collaborate and for users to get paid the nav that they generate uh we're going to be starting off with a high level overview of Med share what it is how it is designed and how it works and then we're going to walk through an open source code Base called Simple blind Arbitrage that the flashbot scheme created in open sourced as an example of how you might write a Searcher that interacts with webshare and uses some of its unique qualities we're going to be walking through this open source code base but you know keep in mind you should really understand this thing and you should understand it's it's smart contracts how to interact with it what it is doing if you want to run this thing yourself or put any money to it into it so without further Ado I'm going to turn it over to the legendary uh Scott I've asked to give us an intro to not sure Scott cool uh awesome thanks bro okay okay so we're going to do a really quick overview of what basically why flashbots made and maybe share by kind of outlining some of the problems that Mev share is solving uh to talk about those we're going to first discuss what ethereum was like how since the beginning we've always had this mempool of transactions right we've had transactions that before they land in blocks they're shared with absolutely everybody and very very shortly after this we had Searchers that came along and realized that they could see transactions in the mempool before they were confirmed and they can take actions on these transactions one of the things you can do when you see a transaction before it lands in a block is that you can take this transaction and put your transaction right after it in order to take advantage of whatever this transaction was doing as an example the transaction could be making a very large swap order on say uniswap and that large order has created an Arbitrage opportunity and if you come right after them you are going to be the first one that is able to collect the Mev that was created by this first transaction we went with the Advent of flashbots we were able to take these transactions and put them into a bundle which get delivered to you know a relay that can bring these two transactions together at the same time uh the problem comes along when Searchers see these transactions and are able to instead of putting their transaction after the user transaction they put their transactions before and when they do this they can influence the behavior of the user transaction they can say let's say that this user was trying to buy an nft this this you know they could have seen this transaction in the mempool where somebody else wanted to buy the nft and they buy it first and in that example we don't even require any sort of bundling right so that all that the Searcher needed to do was to see this user transaction in the mempool and say like oh you know what I'm going to do this first and they don't even care how this transaction lands so we don't even need a bundle for this right this doesn't require flashbots or bundling or anything this just requires seeing a transaction and taking an action before they do so the problem with the mempool is that Searchers and everybody in the entire world sees it it provides full details of all the transaction you can see everything that transaction is trying to do and simulate it on a node and see what it's going to do on the Chain when it lands there and it means that Searchers can front run these transactions either by doing this action first or by including it in a bundle and influencing the behavior of that transaction because that transaction is going to come second and so it's led to users using private mempools you've probably heard about some of these we have like flashbots protect we have you know a numbers I remember one inch ran one for a while there's a large number of these where users instead of putting their transaction in the mempool that everyone can see there is this other pool where no details are leaked to anybody only to the miners originally and and now to the builders and validators such that nobody else can see these transactions before they land uh in a block um and so users have started to give their flow here they've given their transactions to these private mempools because no details go here but it's kind of been a regression because now we have what we call top of block guess Wars what that means is that this user transaction lands in one block there is now a race in the very next block for all of these other Searchers all trying to take advantage of that Mev and fighting with each other this usually involves a large number of of competitive transactions that are trying to to out-compete each other and to use higher fees and it kind of it creates a worse experience for ethereum all around there's a lot of wasted block space there's high gas prices and so the question is I'm coming back here you know how do we create a system that enables this right because in this circumstance where the Searcher transaction comes after the user transaction this user transaction is not affected in any way the user doesn't really know or care that somebody did something after so how do we enable this while at the same time avoiding this scenario or this scenario right or the where the the Searcher can influence the transaction or just do whatever they wanted to do first preventing them from doing it and the answer to this question is that there's something in between a mempool and a private pool we're calling this service and maybe share and the idea behind Mev share is that users will give transactions to the Meb sharp pool just like you might give it to a private pool but it's going to share some of the data not all the data but a very small subset of the data with a Searcher and enable the Searcher to look at this subset of data in this case as an example the subset of data is the unit swap B2 each Pepe they're saying that this transaction the user has provided has interacted with this uniswap liquidity pool in some way we're not saying what they're doing they could be adding liquidity they could be buying Pepe there could be selling Pepe we don't know but the Searcher can take that limited amount of information and say okay well maybe if you're interacting with this uniswap pool maybe we can Arbitrage and buy on Sushi and sell on uni for this exact for you know for Pepe specifically but you know and then you can you can give this back to the Mev share pool in order to see if that is is a reasonable bundle to provide but we also don't know if they're buying or selling so maybe we need to try this transaction the other way it's for that exact same transaction we'll send another Mev share bundle back to the nav sharp pool uh we also might try other liquidity pools hey maybe you know maybe they're doing this on uniswap V2 and there's unisot B3 liquidity and this transaction has bought so much Pepe that there is now a price discrepancy between V2 and V3 and we can use that price discrepancy in this transaction but the Searcher does not have enough information to either prevent them doing what they're trying to do they don't even know if they're trying to buy or sell so they can't get in front of them in line and this system will not allow them to give a bundle of transactions back that puts the user transaction second the user transaction always has to come first in the bundle that comes back to the Meb share pool and so this is great for the Searcher right the Searcher now has an ability to be the next transaction after a potentially interesting transaction um is about is about to land on chain but the question is why would the user do this why would the user use an Mev share pool instead of a private mempool what's in it for them right their transaction lands first and it's unaffected in the same way and the reason is because this Meb share system when it lands this bundle here let's say that this is the one that ended up being profitable because they were you know say buying Pepe here and so we were able to um you know to sell Pepe and buy it and kind of create an Arbitrage loop with this particular route that we just guessed might be available the the fees that are generated from this transaction here which are often very very high are split inside the Meb share system and a large portion of the fees that went into this transaction become a new transaction that is injected by Meb share that lands on chain and rewards the user by just sending them eth on-chain directly after this bundle Landing as an example of this I have a the system is live right now it's it's been live for a little while and we've seen some adoption of Searchers doing this and also order flow and here's an example on chain we can go look at it in a second but what we're seeing here remember these things are it's ether scan so things are kind of ordered backwards this is the first transaction this user interacted with a swap router and performed a swap this transaction here is the Mev extraction transaction where they took advantage of the new price that was created based on the swap happening this created a Arbitrage opportunity that paid the Builder a pretty decent amount of of eth and in this transaction here this is the last transaction in the bundle you can see that the Builder paid this user back in this case 0.038 eth as a um for for providing that bundle flow in the first place right that's the reward for giving the system the transaction as opposed to just privately relying it so their transaction landed without being copied by someone else without having its execution Changed by another transaction coming through it and they also got a kickback on chain that is Theirs to keep if we look at these transactions really quick I'm opening this up in a new tab here we'll go down to filter here are those three transactions here um I think it's worth looking at each one of them real quick this first transaction we see this is them interacting with this swap router they're interacting on this refund token looks like they are selling this token for eth so I'm going to close this I'm going to open up the next one this is the this is the Searcher right this is somebody who could have been running simple blind Arbitrage or maybe a version of it they modified or just something that operates in the same way the simple blind Arbitrage does but we can see that um they they were able to get 0.088 eth in Mev out of that Arbitrage opportunity of which they gave 0.044 to the Builder as a reward for including their this bundle and 0.044 they kept for themselves right this is this you know b820 ba20 so they paid themselves 0.044 eth as a reward for landing and they only had to pay 0.01 in order to uh in transaction fees and so keep the thumb in mind 0.044 if we go back to that final transaction that pays out the user and we'll bring this up in a new tab so of that 0.044 the Builder kept a small portion for themselves and paid 0.038 eth to the originator of that transaction that created the Mev um I think that's a good time to stop and maybe ask for questions or see if um Bert or Brock want to chime in here on anything uh we had somebody asking for slides in the chat if you don't mind sharing that of course of course um how should I show them um so I'll give them to you I'll give them to you and and uh I'll write that right yeah yeah and then I got it yeah let me see if I can get that okay it looks like they're free okay yeah so the question about the average rebate so this is a very very new system we are we are we have just um oh that doesn't work no it worked for me yeah but you might be I think that's because you're flashbots oh that should work uh I think no I opened it on uh okay so um yeah the question is it's a good question what is the average rebate um the average rebate is still kind of being determined right now this is this is a brand new system and it's it's been live for you know some number of weeks uh we've had um several uh I think probably on the order of what 40 or 50 Kickbacks so far um land on chain some somewhere in that neighborhood um so it's a very very new system we're still uh attracting order flow we're still attracting Searchers and building this Marketplace of um of of people providing order flow and Searchers that know how to operate on that order flow to um to extract Mev that has a majority of it going back to the user um I will say that there's there's recently been a um uh a 1.2 eth Kickback that occurred several days ago um it was like an or there's an oracle update in one of the transactions that Oracle update went through our order flow system and the person who updated the Oracle got 1.2 if back as a reward for one Searcher who wanted to put a transaction immediately after it if everyone is using the service the service was a semi-public I mean it is semi-public right that um actually that's a really good question semi-public let's talk about what semi-public means um and to do that uh you know we talked about this component here right this um this stream of transaction hashes with hints about what is happening in those transaction hashes we can actually pull that up in our browser very very easily it's one of the kind of the coolest things about mebshare so I'll pull that up right now just go to mvshare.flashbots.net this is a an endpoint that will stream the transaction flow to anybody who asks for it so if we just sit here and wait for a second there we go we have we have the transaction hash and then we have logs here so the MVB share system well actually let me let me do the file size here a lot um we have the media system simulated the transaction that was sent to it grab the address grab one of the log topics and sent that along in this in this endpoint that others could look at that decide if they wanted to try to background it with several several transactions that could extract Mev and and feed it back to the system so here we can see another transaction that all that it shares is the hash so when we say programmable privacy we mean that whoever submits the transaction is the one that is allowed to determine how much the transaction is leaked in this case right here they said nothing like the only thing you can leak is is my transaction hash and from that searches would have a really hard time Landing Landing opportunities but if a if a Searcher knows the time frame of an oracle update which was the case um a couple days ago by just by knowing the time frame I said hey you know in this 10 minute window just knowing the hash I will try to background everything in this 10 minute window and and in order to strike they may be and it ended up being being successful for them so they were able to back run something without knowing anything about it except for the general time frame of it being released um yeah so here we see all of this data that is being streamed that is partially anonymized here we have let's see is there anything more we have anything that does selectors yeah we haven't seen there's um there's other things that can get shared besides logs there's the the contract address you interact with there's the function selectors of of the call data and I think that's it right I should have the uh actually can you post a links um brockerbert to the uh that maybe shared documentation pretty sure there's one more that I'm forgetting yeah I get it cool here we go so here's here's somebody who sent a transaction that was willing to share oh yeah I'm gonna go full call data so they were able that they were willing to share who they were what they were sending it to what the function selector was but not what contract address it was interesting for yeah that's pretty interesting right so they get to choose what gets shared and it can be up to the wallet that might be making these discriminations it could be up to the user but the idea is that the user gets to control instead of being stuck with this um this kind of dilemma that we had before of are you going to go to the mempool or you're going to go to the private pool the users now have more control over what gets shared ahead of their transaction Landing completely Unchained Reese says like we spoke my transaction hash and potentially get a kickback if someone extracts my Mev someone extracts Mev post my TX but since it will be harder for them to do so I also have a higher chance claiming any postmind well yeah I made a significant if I mean mbb extraction is is a bit of a um it's kind of a bit of a specialty right I mean there's it's it's fairly difficult to do but I mean mbb is created by the way by let's say that you are making a large order for eth Pepe and you go straight to One uniswap Market to do so let's say you only do unit swap B2 even though there's like three other very good markets out there to choose from I mean mbb is really created because that transaction really should have gone to all the sources and bought enough that it kind of kept the price you've got the best price for the user so a lot of times that the reason that semb has created is because the user didn't create the right transaction in the first place that could have um that could have kept all of these pools more in a like price parody and so yeah it's if you extract your own Mev you probably just create a different transaction in the first place it is more difficult the less you share it the more difficult it is for Searchers and so the like the less Kickback you get and you might not get any Kickback right because eventually because maybe shares will also just bring your transaction to the chain on its own without any sort of a kickback if if nobody is has bid on your transaction which is probably the normal operation of the system um right because if you're just saying Hey I want to send my I'm going to send my friend three Eve you're not creating any Mev there's nothing that anybody can do right after that that they couldn't have done before and so you know there's there's a set of transactions that can that can extract Mev and yeah if one of them users don't generally extract their own Mev they would have created a new transaction in the first place I think is really the um is really the answer there okay so now that we understand kind of this component here right so this basically this component that reads this stream of transactions looks at them and then dreams up bundles and their own transactions that could go after the target transaction that may or may not make money based on the limited information they have I want to introduce you to a a simple repo this actually to it in GitHub first uh we're calling this so the first thing we created a long time ago is called Simple Arbitrage there was one of the first um before the Meb share like when when flashbots first launched so this is simple blind Arbitrage because this uses Mev share and using limited information such as what address did this interact with without even knowing if it bought or sold is able to make arbitrages by just sending a large number of them back to the mbb share system right just like looks like here right so this is basically what the system does symbol bind Arbitrage reads creates two bundles looking for like hey do I sell this way or hey do I sell this way and provides them back to Mev share okay so I already have cloned this and pulled this up in an IDE and um rocker Bert if you have if you want to chime in here I'd be I'd be more than happy to to have some backup here but um the whole system let me just kind of just like walk through the code really quick just to show you like how little of it there really is so there's this this index what was that yeah here here to chime in okay wherever awesome yeah please feel free to interrupt me um but the first thing that I really wanted to to draw your attention to is just like how little there really is to to this code so there's there's this index which just sort of like you know looks at some looks at some options sets up a few network connections um and then has this little Loop here where it kind of does some evaluation um it's there's a little bit of code over here kind of for for how to like look at you know swap pools um and the bundle executor which formulates the request like those little like two you know two transaction bundles and sends them off to the um off to the Matchmaker as a potentially profitable bundle to include um you can see like this thing's like half you know half comments like there's there's really not a lot to it this isn't an overly complex system um I I do want to take a moment here before we get started to say that running this in its current form is almost certainly not profitable because there are many people who do this and there's only a limited amount of Mev out there like the real reason that I wanted to go through this isn't to convince you to just clone this and run it this is a really good place to build from and apply other ideas that you have for Alpha about um you know hey maybe if I look at this way hey maybe if I instrument this this pool over here or maybe I you know buy the tokens and take on some liquidity risk and sell them in the next block like this is really a framework to build off of and that's why it's so simple is because it really wanted to be easy to understand and extend without being profitable in its current um in its current state because it's too easy for for everyone to run it and just you know use the same logic in every all the Mev kind of competes with each other and everything that's been down to to no profit whatsoever so this is not a this is definitely not a get rich quick presentation this is a um something I wanted to show to help you build your version of what this might be or to adapt this to some some other um you know some other strategy I did add a branch if you're interested that uses a flash loan for liquidity it needs a little bit of changes to the index.js file in order to make this work but if you're watching this and you don't want to get started with your own Capital um you may be able to use the flashlight on in this uh with us as well so you're not putting any error funds at risk you can just deploy a contract get started yes yep but still getting started is is not a decision to be taken lightly because well for instance one of the first things you need to do when you are interacting with the system is you need to come over to this environment file right so we are in you know this is the zoom in there I don't know if I can zoom in uh so this is the the file structure of the system and under execute which is where all of these scripts live um there are a bunch of files here one of them is EnV so in this case we need to um you know we need to you know have an RPC connected to you might using Fiora most people who are searching have their own high performance servers that they that they use that they they operate um this private key is not valid there's just some bunch of data that I that I found but you know you need to literally go get a private key that has money in it and copy and paste it and put it in here and so that is a very kind of dangerous thing to do right this is you know a hotkey that you're running in here you could be accidentally committing things you could go to get you know get push something to GitHub on accidents and all of a sudden your private key is compromised to be very careful with that um and we also need to deploy a contract that is included in this repository that I think we should probably go through first um that uh and then and then put that contract address here so these are some fairly technical steps that um that are needed in order to set this up I think it's worth talking about the contract first actually um did you wanna did you want to kind of go over the contracts or did you want me to do that I have to go over the contract in yeah you want to pull it up yep we're there yeah yeah um so I was a bit lazy in my fortunate appointments and there are a couple different contracts here but in the simple blind Arbitrage uh uh root repo you go to source and then blind background.soul in order to find the the relevant code and the main there's another one for debugging and and testing which is useful if you want to run the forage scripts or do any sort of deal bugging um I'll just continue around and if you look through the code the main path that matters here is this one function um execute Arbitrage it takes in two pair addresses and a percentage to pay coinbase of um which comes up later and you know remember the context in which you're calling this function is that you have partial information that has been leaked by the Matchmaker about a user's transaction so the Matchmaker will tell you hey a user is swapping on the ethoscc pool and unisoc V2 or unisot V3 um but it won't tell you how much they are are swapping and just with this information of the pair that a user is swapping you can go and find you know uh another pair of the the same type ethusdc on Sushi swap if the user is trading on uniswot V2 and look for an Arbitrage between these two different pairs all on chain uh so that's what we're trying to do here we take in two pair addresses and we're looking for an Arbitrage between them doing all those calculations on chain um we started by setting up some structures you gotta tell uh solidity that these things are Pairs and we get some data from them uh if you go to the get pair data function Scott we can see what data we're returning here um so we give it a pair and what we get back from it are the reserves of that pair so the amount of tokens you know of eth or usdc to keep on using this example we log whether a token is weft or not uh so you want to know which token either the the first or the second in in the pool or the pair is with because this is helpful in calculating the Arbitrage and knowing which direction to trade and we calculate a price which is just uh the um we calculate a price which is the reserves divided by each other and then doing some stuff to handle decimals in the token um so we have this information we return it back uh and we start calculating our Arbitrage further in where a lot of the magic happens in calculating the Arbitrage is this function called get amount in uh long story short unisot V2 since it is a relatively simple mathematical formula for x on chain you can actually calculate an optimal trade given the state of two unisot V2 pools uh and down to the single way with the optimal amount I won't run you through the exact code here but know that this get amount in function um you know uses that optimal trade calculation and calculates it all within solidity it's like fairly complicated math there's a numerator part in the denominator part one of the complicated parts of it is handling tokens because your tokens may have different decimals and you need to make sure that they don't overflow or underflow at some point but this get amount in again takes the state of the pairs that we had just gotten a moment ago and it calculates what the optimal trade is on on chain using this somewhat simple mathematical formula which is complicated to look at written in solidity um okay so we have the optimal amount in of course we need to know more than that we need to you know figure out how much am I going to get out for this given what we sent in and then how much am I going to get out on the other side but first in order to make swaps on Union swap V2 pairs you actually have this interesting um interesting thing where you need to optimistically send the tokens before you call the swap function so this line that Scott has highlighted is US sending the amount into the first pair address that we are trading on uh before we call swap on it um Okay so we have our amount in we transfer it we calculate um below depending on uh so then depending on whether the pair the first token in the pair is with uh or the second token is with we change sort of which token we are trading and buying on first that's the if statement there we've sent in our uh width to the first pair we calculate how much we're going to get out from the first pair given that amount in West that's first pair amount out given how much of the token interest pair amount out that we're getting we then calculate the final amount out which is the weft that we get on the other side completing the Arbitrage and then first pair dot Swap and second pair dot swap are us actually executing these trades on chain if that makes sense again note that there is this interesting like thing about how even swap pairs work in their swaps where you need to send tokens to them first and then call the swap function so we first send West to the first pair on the first pair when we make that swap we set the recipient address of the tokens we're swapping out of the first pair to equal the second pair and then we call swap on the second pair setting the recipient address to be our contract for execution all right so to you know recap here we have this smart contract it takes in two unit swap V2 pairs as inputs it gets some data from both of them and then uses fancy calculus advancing math to get the optimal amounts in we then handle execution of that depending on um you know whether the first token in a pool or a pair rather is with or whether the second one that's the if statement and we handle kind of all of the trading amounts based off of what the optimal amount in is so the first Paramount is equivalent to how much you how much of whatever token you're swapping to you're getting in return for your eth and final amount is the amount of each that you're getting in return for the token that you're swapping to in Theory final amount out should be larger than um amount in and you check that with these require balance after is greater than balanced before requirement here um then the last bit you can you can read over everybody is it's just making sure that we made some or if we made profit paying some amount of it to block coinbase.transfer which is the fee recipient the block builder in this case yeah one thing that I will note here is is that this this contract just enforces the narrow condition that your balance after is greater than your balance before but it is possible that you made a super small weft ARB you made like one width at the limit worth of profit and uh the the gas fee that you're paying for the overall transaction is larger than your last profit and so a smarter way to do this would be to require that your balance afterwards is larger than um uh you know the amount of profit you made plus the transaction fee that you're paying um for your overall transaction a very simple way to do this is is that you're making like the profit that you have is greater than 0.01 E3 or something like that um yeah so that's the the smart contract fairly simple we just calculate an optimal R1 chain uh anything that ends go out or Brock no I think that the most important part here is this when you require that the balance after is greater than balance before this is a very important line just because the matchmaker is constantly evaluating whether your transaction is profitable and succeeds and it's really important that you fail right your failure here is how you tell the Matchmaker that you don't want to do this because this is still a valid transaction but you're telling you're indicating that it's it's not going to make you money and therefore please don't include it um yeah and just the amount of math we have to do on chain is an is because of the Mev share system not sharing the direction of the trade with you ahead of time normally this is something that you would do off chain and pass into your um into your into your contract right so you wouldn't have to do all this math and um you know on chain but because you don't know anything about the size or Direction you need to calculate on chain so there is a little bit of difference in how your um your contracts operate yeah I think this is a good time to mention too uh the differences between off chain and on-chain uh Rich calculations you can or should do on or off uh so like one one thing that stuck out to me when I was reviewing this code was uh can you go back up to I think it's line 76 um it's the line that checks the wrapped ether balance um so like one way to make this more efficient would be like if you know if you're on uni V2 you can deterministically calculate how many tokens you're getting out right so you don't actually have to check your balance uh and that would be an optimization for gas but um if you have say like a poison token uh where it could lie about your balance um but then then uh then you're kind of stuck with the same problem so like here checking the balance works because we have wrapped ether hard coded and so we know that that the contract isn't going to lie to us but there are still you know vectors on on chain where ticking the balance might not be the only assertion that you need to make to know that you actually made a profit um so yeah yeah it's important it's important to consider the data that you have access to in the context yeah yeah right there could be malicious things that come through in this um you know in here right it could be somebody like made up a token that that looks like there's an Arbitrage opportunity when you try to take it it lies about it and you know it's very um I I believe that simple blind Arbitrage has good Protections in there based on that West balance but yeah like is saying if it's if you think oh I'm gonna grab you know some like Pepe 4 token and as long as I have more of it at the end I feel like I made money I mean you don't know anything like about whether that's tokens valuable about whether the balance is can't just be taken from you later so be careful like what you accrue your Searcher balances into okay yeah yeah and another thing is like you could you could have uh I think it would probably be wise to have a cache of valid tokens um maybe do some off-chain investigation and uh you know make sure that you're you're not just anything into uh scam coins yeah um okay so now let's do do you want to hop over to the uh the actual executor now this is like the client-side version that's going to create the transactions and bundles that go to that go to the Matchmaker after subscribing so is that a good time actually should we check on the uh is there anything you guys there's a troll box yeah I'm in the I'm in the troll box you can trust me on that all right Okay so this this code here really just like looks at arguments you pass in this is kind of you know boilerplate stuff um we need to have a connection to ethereum we're gonna need an RPC URL in order to look up things to look up like the pairs right we saw a lot of the we're gonna be passing in pair uh information you know swap here information like which tokens on one side or the other is this is it weth that so that's going to be important here um signers are what we use for reputation in in flashbots uh well actually this is this is actually the real one isn't it um right so this is going to be the the wallet that signs your transactions that um that pay for the gas right so in in this scenario over here you know you need these are real sign transactions and you need to sign them with an account that actually has some either pay for gas and so we need to provide that to the simple blind Arbitrage um yeah the the bundle provider actually I don't think this is actually used in this uh this repository um I think we just ripped that up yeah yeah I think I added it there and I actually couldn't ever use it so yeah um and the pool manager is just a bit of code to look up various bits of information about the uniswap pool right so like I said like figuring out is this a width based pair because if it started with paste air pair we can just move on we don't need to do any further evaluation connect to whether you want to connect to mainnet or Gourley both of them are supported by the Matchmaker these are all configured in this this config.json where you can find all their URLs and you know the the factory addresses for for uniswap in order to perform some of these verifications of of these pairs but this this all comes down you don't need to type this in this is in in the Repository um yeah and so all if you wanted to also there's probably just a little bit of profit extra domain you might find a few more arbs if you added the other unisot V2 Forks yeah um there are a few more that's in the OG simple Arbitrage repo that are not in the simple line Arbitrage I forget what they are but it's like Zeus or something like yeah remember that one yeah this is a bunch of one usually they get a little similar quality at first but every so often there's one of these uniswap clones that becomes like the place that you exchange one type of token yeah anybody attracts a lot of liquidity just for a small number so yeah I mean really that's where that's where you can take this and turn it into your own and say you know you could add a bunch more you could add unit swap V3 which is going to be very complicated with the way that unit swap B3 is different from B2 but again the the harder it is the more likely it is that somebody else didn't do it and the the more likely you are to um to be finding like novel Mev that you're not sitting there and having to bid 100 to to get included on chain because you're competing with others who are doing the same thing um so yeah we we create an Event Source this is really just connecting to that that endpoint that I pulled up in the browser that was streaming that data to us and again this just comes right out of that config knowing knowing where the URL is and when you attach an on message call back to it this just gets called every time a new message comes down the pipe from that um that that endpoint that we were looking at uh one thing that I think is I like to do what I'm evaluating this kind of code is I'm going to delete all this code literally just delete okay in this case all we're going to do is really log the data that's coming in so we we look at the data in there we make sure that logs are present because without logs we can't really know whether something is a unit swap transaction or not which we're just going to skip everything it doesn't even have any logs we're in debug mode and so we we've paused execution here and now we can evaluate this data structure that got parsed from everything that came here and so let's pull that up sorry I don't think I can increase the font size in this window or down here um so sorry this is a little bit on the small side but but here you can see this is really just a structured representation of the data message that we were getting from that stream and from here we can you know look at the um you know look at look at the logs right this is the log this is the first log in it and we can see that this log topic is you know 0x d78ad and so we actually got kind of lucky here because remember that so I'm actually going to copy this value because when I undelete this code just going back to the way it was before the first thing we do is we say hey is is that first log this and if you look at it it's that right so we got lucky in that we actually the first message we processed was one that we would be interested in it is a log message that gets emitted when a swap occurs on a uniswap um pair right so that this is the way that we use that partial data to conditionally move forward or not move forward with with processing um so you know just like before so we're going to look at data logs I address you know we can see this address here again you probably can't say it very well but that is a uniswot pair address right saying oh this this address emitted a a log right so let me see if I can actually copy that I'm gonna go look it up right so this is how you would kind of create your own custom search your logic so I'm going to copy that value I'm going to come over to my browser look at it yeah so here we have a uniswap B2 pair and remember that I saw that d78 remember I said that Xerox d78 topic that maps to this swap function so it's like this is what we are targeting we're targeting a swap having occurred on um you know in inside of that transaction and but if we go back here and look at the rest of it's like oh well we don't know how much see it kind of hit it zeroed all these values so you don't know how much is being swapped here you just know that swap is being called these have been anonymized right so we have the address of the pair we're interested in the token good question you know it's not a has a decent amount of uh oh Benito just kidding I have no idea what that is but yeah so it's like you know we know this is the Bonito token and so you know as we check the pool we can now query it for you know what its tokens are is one of the is one of the tokens with well come over here we know that's true one of them is worth right it maps to these this contract like these these contract addresses over here these contract values over here uh right token zero took a one that's West um right so we're gonna we're gonna fall to the next part where we return the tokens that we extracted and we say hey you know what if this this was uniswap right if we if we if we see that uniswap is what this token is in case it will be right because the factory that created it again which is a function call over here um my dysfunction call that maps to the the unit swap Factory um then you know what here's the tokens you're interested in by the way go check go check Sushi go find the sushi address for this so we can pass it in so that we're back in index now okay right this is that we're actually paused and execution right here so yeah we know the tokens we know one of the uh we know the other side of the Arbitrage that we should check we go and find the pair address for in this case it will be sushi for these two tokens once we have that first parent second pair all this left is taking these and bundling them up into two different bundles that go to the um they go to the Matchmaker and the reason it's two is the way that we structure this is when we saw one transaction like hey let's try to go Sushi to UNI and let's try to go uni to Sushi we made those two different bundles you you could make them the same transaction but you kind of have an advantage here where you can kind of save cash you only need to check one thing or the other because the entire transaction will be excluded and you'll have used less gas in the one that succeeds yep I think this is another good time to point out um like the logic behind uh gas optimization and uh separation of of information here uh so like on you know to get the most gas efficient execution I mean ideally you just want to be doing the least amount of computation so I think the best way to design your contract in this case is you want to have one function for each sort of logical path so you would have uh like one optimization I can think of is if you know the token is uh like if you know on the pair wrapped ether is token zero then you can have in your in your smart contract like one function for when the token is uh zero and one for when weep is token one and that way you're you're cutting out an if statement in your execute function because you can get that data off chain so like in any case where you can get that data off chain you want to do that um yeah yeah exactly right so there's there's extra gas that's a system like maybe sharing curves because you need to do more calculations on change on chain but you can combat that with the the gas savings that systems like maybe share can this can give you because you can just give a whole bunch of bad transactions to it and one good one and you don't need to have all this if logic in the transaction actually lands on chain right you don't pay gas for anything that doesn't land on chain and so you can do all your all your checks and fail and then not pay for any of that gas and only have the one that landed on chain that didn't even check anything because it knew it was going to succeed because it ended up succeeding um so at this point we have the the pair addresses right so this is going to be like the unit swap hair and and the sushi swap pair and then the transaction hash that is the user Target transaction right so this is like it's passing in this transaction hash here not the actual transaction details because we don't have it but the hash that we use as an identifier when we feed this data back into MV share and if we if we look at this there's really not much to it right it just it it figures out it just creates these using the the standard ether's library right it's just this contract populate transaction is just the way that you um you know create the call data for a for a call without sending it to the the mempool so this is how you kind of just create your transactions and keep them in memory and all that it does is you know creates one transaction where it tries to our first pair to second pair and a second where it does second pair to first pair creates these two bundles right remember hash and then an actual signed transactions that's what this looks like over here right we have the hash and the signed transaction it formulates those in the format that the Mev share Matchmaker expects um yeah and then it just puts them into the format this is just the protocol formats that the Matchmaker wants the mbb share Matchmaker wants right so we'd say like hey you know I want you to start include you know I want you to include this up until this block you eventually want to you know stop right you don't want to sit there and try to have this included for a thousand blocks there's some limits there anyway and and this this body bundle is that um set of of transactions that we wanted to pass in right the hash and then the real sign transaction and so really this is all just kind of like under the hood stuff for how you get your bundles to the Matchmaker in a way that it understands um I'm kind of going back here right so we're back at the index right so all that this really is is saying hey create those two bundles and send them to the Matchmaker to see if one of them is profitable targeting the transaction that I discovered that had that log in it and that's all does this is this that's the end of the loop right that's the end of what you do when you find a message coming from this message source that has a was it d70 yeah without that has this on there you sit there you take that and another pair that has the same tokens on it and you see if there's an Arbitrage opportunity afterwards if there is view land you pay the Builder the Builder pays most of it to the user but the amount that you pay the Builder doesn't have to be 100 of the profits that's like in in the example we had over here where this user landed a transaction this is just like we're talking about here this is one of the transactions that was signed using a system like simple blind Arbitrage they sent this to the Builder they could push themselves when you take out the transaction fee they made 0.034 and that in this bundle and the user made 0.038 so like everybody wins right this guy you have somebody asking if we can show the code uh that read TX is from webshare again quickly yeah of course yeah I mean the thing is there's so little kosher like it's like it's like here right so this event um here let me actually let me let me pause this let me think about a breakpoint here so the code that reads it is just creating an Event Source this just knows how to read an HTTP stream like we have over here that's all it is like remember the stream over here new event Source on that right we're on Ron mainnet this see this value is just our URL that I'm looking at and then you just say hey Event Source whenever you get a message right this is kind of a built-in um a built-in like node function whenever you get a message through that endpoint I call this function and then it's going to end up here so in this case all that we're doing is okay we've got a debug Point here so the event that came in is this yeah right here see that this this one came in this is one of the ones that doesn't actually share anything but it still came in as a Json message we parse that step over the step over that look at now you just pass it into a message and now we can evaluate it so I mean the whole thing is with this really set it up get a call back parse the data that comes back now you can do whatever you want see if this one has more right so I'm just I'm hitting play again nothing yeah it's a pretty common um pretty common path that people just don't share anything but from when they do they share here you go here's one I shared a little ton of stuff yeah so this one shared a whole bunch of logs it's probably a big swap yeah that's uh that's that's die right there I don't know all this diet that's usdc oh yeah yeah I think that's tethered uh let's see each other's DIC Ed yeah but anyway yeah so that's how you parse it you just parse it with really these these three lines and then how you react to it and the data you extract out of the logs or the function signature or the call data whatever it is that's present and the ideas you have for what to pass in afterwards back to the Matchmaker um is is really what what these Searchers are all about and kind of like where if you have new ideas for how to do this or better ways for how to do these like that's where that's where your Edge comes from What's um somebody asks in uh in the chat please asks in the chat what are some special cases of Meb that you guys have imagined would occur from A system that have not occurred yet I mean I think the Oracle update that happened a couple days ago that's one we've been talking about a lot because Oracle updates historically have generated like a ton of enemy B that people fight for for blocks right this used to be like liquidations on maker where hey guess what the new price of of Eve is now 1 000 all of these um all these maker positions are now underwater and now they're just a race to liquidate them because there's like a large Mev there but the thing that happened two days ago was it was a an oracle update for like um like like a token uh I think it was like a token kind of becoming like available for transfer and so um yeah that was that was a cool one to see and especially since it did just like we expected it was a large one I don't know do you have any ideas for other Mev that we expect to see from the system oh this is a good one I think an interesting thing is there's lots of mean coins that are launching right now and oftentimes they get sniped by token snipers that are willing to pay you know huge bribes in order to be the first person um to Skype a token that's launched and you could have a team that launches the token through meth share instead and Searchers are bidding for the right to background it but the profit of backgrounding token launch goes to the um you know the user is actually launching the thing instead of just the Builder or a Searcher so you can actually internalize the the value of the back running War a few things you need a background anyway and then can help you you know more fairly price what your uh your token launch should be since you can take those each profits from the auction and kick it back to your LLP I think that is very interesting um and that's not really something you can do in the usual and pool or the the usual way that anything works like totally novel um yeah what else is really interesting I'm trying to think I think one of the the largest you know there's a lot of Mev in nfts but nfts are are kind of difficult to operate in in systems where you're kind of blind because you know you know it's like hey somebody is buying or selling you know a board eight but like which one like you know is there is there a way that you can you know operate on that information I think that's that'll it'll be interesting to see what people do with partial information um for for nfts or whether nft wallets want to make sure their users get more Kickback for their transactions maybe then maybe the wallets when they interact with nfts was like oh you know we're doing an nft like I'll I'll leak a little bit more right I'll I'll tell you I'll tell the Matchmaker that hey yeah why don't you leak my function signature so you at least know that I'm buying or selling or um you know there might I think that the ecosystem that kind of evolves around how the decisions are made for what to share I think that's going to be interesting and kind of as users get these Kickbacks right like they usually got 1.2 Kickback or this 0.038 so I think that's going to start to get users thinking about I used to keep these away for free and and I don't have to anymore and then services that can figure out should you be leaking this data or not and and how that gets automated I think it's going to be a cool development yep we also haven't talked about uh bundle nesting search researcher collabs but we haven't as far as I know we haven't seen that actually happen yet but I think that one is going to be probably the most interesting is it live about our minute yeah yeah bundle nesting works yeah do you want to talk about it Brock sure yeah um essentially I I'd say it pretty much looks just like a transaction when you see it from the from the SSC stream it'll just have you know hash and whatever else you decide to include what's interesting is the like say you say you leak logs the the logs will come from your entire bundle but they also inherit the privacy settings from from whatever transactions are uh in the bundle right so like if if you're uh like if you pick up somebody else's transaction and back run it and their transaction was fully private then you won't be able to leak uh their data out of the system you could see like an attack Vector on this right like if if we didn't inherit the privacy settings um then you could just you know take every transaction and and leak all the call data and logs and then just leak that as a bundle then read it yourself again and then operate with full information so we need to like take the intersection of the privacy's uh but given that um you know searchers uh say you like don't have the most efficient bot right like maybe you're doing a uni V3 V2 uh ARB and you're just using uh like some crude estimation so you might be leaving a little money on the table um somebody else you could decide to share that bundle with me if you share or the Matchmaker and somebody else could come in and see that and maybe they have a more efficient bot or maybe they're taking a bunch of orders and aggregating them into into larger bundles well or or if I can chime in here I think that one of the things we're saying a lot is that there are some people who are willing to buy a token and then sell it on a centralized exchange then other people don't want to do that right other people can't get an account in the exchange they don't want to deal with centralized exchange and so sometimes the background of like you know that that that Searcher operated perfectly it left this one pool out of sync and did somebody else would love to buy those tokens to go sell them in a centralized exchange that isn't available to the person who created that first bundle uh on top of that you know it's like we talk about decentralized block building and this is kind of like bundle nesting is sort of uh like a first step in that direction I mean if you have if you have somebody who's really good at aggregating orders uh and they can do it at scale like that's essentially block building yeah the question is like how do you do that with imperfect information there's kind of a balancing act so I think we've got to cover from the user standpoint what you how you would end up sending to the Matchmaker in a way that leaks more or less information and the way you do it is just to use flashboss protect but with hints on your url right the the when you add a URL for flashboss protect to metamask you'll include you know no one looks like this but you can include these arguments here that say like yeah you know I want to leak my call data I want to leak my logs and um like this is this is how those systems end up getting in here with this data that is um that is partially shared foreign I think in the future wallets will start making this call like that's going to be like one of the um one of the benefits of like wallets or ipcs they can kind of look at a transaction be like I know what kind this is I I kind of figure out what they're going to want I don't think users are going to want to make that determination every time but I think that there's going to be part of the service related to sending transactions is going to be figuring out automatically what the right privacy level is for these transactions uh we got time we'll do five or ten more minutes of questions of any money as any anything they wanna want to say or talk about in the chat Juan sunogo I think so you pronounce your name um says any plans for a golang library for Matchmaker Rock any plans for golang Library we didn't even talk about Matchmaker by the way oh Matchmaker PS oh yeah and um yeah goaling Library uh yeah why not um we don't have any plans like set in stone but um we have this typescript Library I know a couple people are writing one for rust already um I imagine it will probably come out of the community before we have time to do it ourselves yeah yeah that's what we saw before with the the original flashbots ether's provider um yeah there's a there's a little bit of code that goes into this I think it's worth I mean it's um so one thing to mention is that this this thing we just looked at here this is the simple blind Arbitrage strangely doesn't actually use this Matchmaker Library um you know if you look at this uh even though it's called another weeper yeah even though it's called Matchmaker as a variable all it is is a raw Event Source and then remember when I was like oh yeah look at all this magic happening over here in bundle executor if you if you use that Matchmaker TS you don't need to write any of this stuff right all this like oh you know I want this thing needs to do a Json RPC require like that's the kind of stuff they attended by Matchmaker or um Matchmaker TS I mean yeah I think go Library would be awesome um and yeah we saw people from the community make those for the um the thing but it's not that hard to do without a library either right if you're if you're just using go and there's no Library I mean it's probably about I don't know 20 extra minutes of work and most of that is just I think reading the um the format that goes into um yeah kind of just like reading how this uh the the matchmaking accepts the Json RPC but there's not much to it I honestly just did not want to handle integrating and typescript Library into the JavaScript file or running line shouldn't type script I don't I don't know text quickly follows I know JavaScript so I'm sorry you did not use your library Brock that's why that's good I think it's uh it's valuable to see just how simple this yeah SSE stream is just by you know by implementing it yourself like yeah it's it's really not complicated and and the uh the RPC uh formatter that's just the you could just copy that out of like the I mean any one of the libraries it's just our standard uh signature scheme so we got a couple questions in chat simda says payment to user prioritize the repayment to builder for remote share uh yes so at the Builder in theory they choose the the bundle that pays the user the most and uh the incentives are aligned here because uh when we send match our bundles to builders there's a field that says uh refund 90 of the value or X percent of the value to this address and the rest of it goes to the Builder um so in theory if you have a more valuable bundle both the user and the Builder get more value um if their refund is set to be the same thing ran away asks can you leak fake information and pollute the Stream uh you cannot landline so you set your hints at your RPC or directly if you're directly interacting with the um Matchmaker and the Matchmaker derives the information into leak itself so unless the Matchmaker was uh you know behaving maliciously yeah you are trusting the amount to make marvelous to say what the hints are yeah um right exactly yeah you don't you don't say what the call data is you just say like hey tell people what the call data is and then when those transactions come in it looks at the call data and sends that out yeah so I responded to this in chat um I guess it depends on what you mean by fake information uh because like if you if you expose some logs yeah well I don't know how would you really fake that I mean if you can check the contract address and you can check the logs or you have to do some stuff so okay we're getting into some nitty groups want to give people information on how to fix stuff [Laughter] it's in the interest of transparency yeah yeah um you should probably check on chain to make sure that your your transaction is actually profitable that's what I would say yeah exactly the the manager will not lie about logs that it sees but um you know if someone's smart contract that they're interacting with might that's what I would say yeah yeah but if you're checking profitability on chain I mean and you revert your transaction I mean even if the Matchmaker tried to bring it to the chain it wouldn't do it wouldn't execute the code right your revert rolls everything back so you know you have because your transaction comes afterward you know you have final say in whether your transaction executes or not right and so I think that was the worst thing that's going to happen is you send these bundles to the you know to the to the Navy share pool like the Matchmaker that's what we're calling the Matchmaker right you send these there and they just don't execute but that's like what's probably going to happen most of the time right so it's not something that much of a trolling Vector you're used to sending transactions that don't land because you're just you're just kind of like guessing what might work that's very common let's see what else we got here um what are the possibilities to reduce search or spam on the Matchmaker sidestep thanks for your question what do you guys think is Spam I mean I I probably the probably the best way to reduce spam is to find a way to charge for um simulation time right to make it like a you know it's like hey you know this if you're incurring you know a millionth of a cent of of of CPU cost to simulate it just if you can just find a way to I think push that out to the users then it's like oh yeah go ahead and spam right there's there's a way to um to do that we've seen that with other pools as well I'm not sure if that's been considered for our product but that was that's not something else on the roadmap though I think one thing that's interesting is if you send us a transaction and uh this isn't a feature that we have right now but we could have a feature where you send us a transaction and you tell us hey put this behind Oracle updates for uh you know the compound um whatever Oracle that like compound uses or something or put this you know only behind curve uh usdt usdc trades something like that it's more like a standing order as opposed to like just getting it all the time yeah exactly well actually there is a deal with Spam hold on we do have a Spam mechanism and that is reputation right we we do reputation which is you sign all the payloads you send with another private key and as you land bundles you end up going into different priority queues and if you are landing lots of bundles you are going to get evaluated potentially you know sooner right or faster just based on on on on how your prior history has has been normally they were it only matters in um period of the high I load I think yeah all right other questions let's see Bree says how do you plan on mainstreaming the system what do you mean Breeze for our users for our searchers I mean I think it's it's like a marketplace right the marketplace like kind of becomes like self -promoting or or you know it's our job to make sure to get software right the more order flow you have the more searches you have the more profit I think that becomes kind of this um recursive thing and so like we're for everyone yeah I just think all we need to do is make sure that it has enough volume on on everything on the searching side and on the um you know on on the the order Flow side to to make it profitable for all the parties right because all the all the interests are aligned yeah there is there is an API endpoint to check your reputation let's get users that's right do we yeah have we finished uh integrating reputation from left share into that I think that might still be in progress Aiden Khan asks can you please shed some lights on how to protect the private keys no Aiden I'm sorry I mean I will say those probably I I have some like I'd like to shed um you know it should really just be gas you know don't you only need to sign transactions that can like operate on on gas and because of the protections on the contract you could have the owner be a much more secure account the one that might actually own funds that are that are on that contract and you should only need to keep enough on there for you know for a very small amount of gas which normally is a pretty small amount of eth and um yeah I think they're just finding like a tiered system like that means that even if you even in the worst case you could be out like a very small amount you know if you were constantly refilling it and I mean make it so that anybody who calls it calls your contract can't drain any money unless they have like the more secure account right it's like calling it with like first pair second pair if it's not profitable reverts you're not going to do anything except for you know potentially waste all that gas yeah environment variables yeah but you know it's it's hot right it's hot in memory somewhere so it's not I do not have there should be a separate account that it's only used for gas not for withdrawals what else we got here maybe we'll take two more questions good picture how do you know if you get outbidded on your bundle um you don't right now we're working on some apis to help yeah we do have a little bit here um we could talk about this this is probably one of the cooler that sounds a cool function um uh where is it Matchmaker so in the Matchmaker TS we have the simulate bundle and the funny thing about simulate bundle is that you can't do it right so cement bundle basically you know kind of takes these two transactions and says hey run this transaction then run this transaction and tell me what would have happened the problem is you don't have the transaction of this transaction hash and so this is a function that we wrote that will actually wait for that transaction to potentially land on chain it will just return pull forward every block and once it finds out what that transaction is then you can run the stimuli function or a little for that promise will return and you'll be able to say oh not a transaction is let me grab it and then simulate these two transactions in a row and then you could see what happened and if you discover that that transaction that you are targeting landed in somebody else's bundle instead and you're succeeded with it and would have paid a certain amount you could figure out like oh well you know they paid a certain amount I paid a certain amount was I paying more and something went wrong or was I paying less or not enough or you know it gives you a chance to evaluate the actual on-chain Landing behaviors if you just wait for this this transaction to eventually become public which is very likely right these these things normally become public eventually right because even if they don't land with a Searcher they're gonna they also go to the more conventional just like Landing without so you can eventually simulate and then he's asking um how do I know if I got outbid um so yeah like we we want to we like in Mev boost we have uh function called get conflicting bundle it's in the ethers provider bundle uh Library and and that will look uh it'll look for the Target transaction uh it's sort of the same way wait waits till it's included on chain uh and then it'll look up uh all the bundles in the blocks API which are also on chain now and it will just run through and simulate against uh each bundle until there's a conflict found so like we want something similar for this um but some upgrades I think need to happen on the back yeah the apis aren't there actually we have a pull request that we're looking at right now that's going to expose bundles so when you you know we have blocks API right that you use to uh um yeah so we have this blocks API that you can query for bundle information from our our Builder um that'll be enough right so you can get bundle information from Rebuilder this currently does not include the um the Matchmaker bundles but it will very very shortly right we have the code written for we just need to check it and deploy it but pretty soon what you can do is like hey you know the bundle the the transaction that I wanted to land landed in this block you can go and check the blocks API for was it a part of a bundle or did it just land naturally because that's those are kind of two different paths you would need to evaluate separately to see why that happened but that you know there is information that gets exposed about how these things actually landed on chain and it'll be added to that shortly you all can uh feel free to stay on and unfortunately go to drop um so thanks everybody for tuning in at least to listen to me talk um thanks Brock and Scott for joining us today feel free to stay on if you want cheers cheers I'm gonna do a couple more questions sure sure and now we can wrap it up yeah uh let's see okay here okay I like this this question here um transactions that hint only TX hash are essentially private since you can't act upon them right so in that in that case um I think I mentioned this at the top of the the talk but there was a large the largest payout we had actually was from a transaction that only shared TX hash and it was from a an oracle update but the the Searcher knew the approximate time frame that it was coming out and so it just took its bundle let's come over here right it's it's you know every time it got something regardless of having nothing here it said this um do the thing I want right new transaction do the thing I want and so it just kept every time I got something for that that small period of time which I think was probably just about maybe 10 minutes it tried the bundle and it eventually it eventually landed eventually it got to background the transaction that it wanted um and it paid a um you know a good like a good feed of the Builder and a good fee to the the originator of that transaction so you know it is with current volumes it's not it's somewhat feasible to do every transaction but pretty soon I mean this kind of comes back to the other questions we had about um you know like a denial service and reputation of how we um and then how we deal with those going forward in a scalable way uh currently the rate I mean there are rate limits based on um a bunch of sources right uh for for any Searcher doing normal things I mean you can see that right now the the volume of this let's go back to our IMB share right I mean the volume of this isn't crazy right this isn't that bad um you know this is only brand new transactions that are coming in through and they're on these only ones that are coming in through the Matchmaker you know this is order flow that we are working to um working to improve you know but there are you know probably you know tens of thousands a day something along those lines but not uh she's not such a large amount that's I think we need to be crazy worried unless you're doing like 10 000 transactions but you know if this list of three is ten thousand then yes I think we have a problem but we haven't seen that yet and we'll address that when we get there okay uh we pick the Builder fee at runtime in the smart contracts or do we need to specify the fee when we send the transaction yeah great question uh yeah um so you could you could do it in your smart contract um this is just block.coinbase dot uh transfer or whatever method you prefer um so yeah like in the bot right now like in the smart contract you'll see that there's a calculation for like we find how much profit we have by checking the before and after balance and then you do some math to calculate uh how much the validator or the Builder gets uh as a coinbase payment yep so yeah if you if if you want to specify off chain that uh you can but you know you have no way of knowing exactly how much profit you're getting out outside of that context so um yeah depending on your strategy you may or may not want to do that yeah yeah right here you like it you can execute evm code and you kind of decide based on how much comes in is how much the coinbase gets so yeah this is and normally when you do this you submit your transactions with a zero priority fee so you're not paying the mine or anything you're going to pay your base fee but you don't pay the minor anything except for this and that is still a valid transaction and that's kind of a common way to do it especially when you don't know how much profit there's going to be until you're at runtime um I I and I know I mentioned this before but it's important to compare this profits against how much gas you spent you know how much gas you've spent is available inside of um inside the evm and that code's not here right now um again that's an exercise for the reader but make sure you know there should be a a line here that says hey make sure that the profit is more than I spent on the base fee to get this transaction included otherwise you have lost money you have gained weft but lost more than that amount of weft and eth on the executor account on this um now the signer right this this yeah and then you know you could like say if you wrote the contract you have a pretty good idea of how much gas it's going to consume for you know one ARB can have sort of pretty accurate estimation there um so you could pass this in as a function argument uh if you know like I'm only gonna if like say if it's like really long tail and you know that you're only you're the only one searching on that um then it might be better to pass your gas or your tip as an argument um save some gas but if it's I don't know if it's that rare I guess in this case it doesn't really matter if you're gonna save a couple bucks or not but yeah depending on the strategy uh we had one question about an aggregator for relaying bundles to multiple relays so yeah like we don't have an end point that does that right now but I mean we're doing something like that with the the dog didn't talk about the the dog at all the dog yeah I don't know a whole lot about the dog I know it's the the the the the order working group but is there any more to talk to you I don't know it's the decentralized order flow working group uh so yeah the idea is like uh in this group uh order flow is shared between parties uh and that'll increase inclusion rates but this is still very like fledgling uh idea uh and something that we're building currently uh by the way I've been saying the wrong number this whole time I forgot it's not it's not 1.2 it's 10.8 that was the E that was the refund that the user got 1.2 was the build with the builders 