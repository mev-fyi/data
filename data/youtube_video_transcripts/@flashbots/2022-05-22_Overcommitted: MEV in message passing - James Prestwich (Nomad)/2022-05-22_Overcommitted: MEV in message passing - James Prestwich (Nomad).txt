[Music] my name is james prestwich i'm currently the cto at nomad which works on arbitrary cross chain messaging we build governance protocols token bridges that sort of thing that touch multiple different chains uh we're live on a bunch of different networks and just adding new networks all the time i've been working in the cross chain space for about five years now i started off working on atomic swaps back in 2017 um you know before we had all of these nice things like ibcs and relays and before the whole cross chain space devolved into multi-sigs um so my my talk today is called over committed and it's about uh why mev is so shitty in cross-chain environments and why we can't really do anything about that practically speaking um so i want to talk about the cross-chain message life cycle real quick anytime you're communicating between two blockchains it goes in three phases you have to commit on the first chain on the origin or the sending chain some off-chain actor needs to see that message decide to relay it sign a transaction on the destination chain and submit that for processing over there so throughout this there are two different transactions on different blockchains with an off chain section in the middle obviously this all takes a bunch of time and a little bit of a like blockchain rube goldberg to work this is how all bridges work every time there's a token bridge this is how it works okay so this talk is called over committed because it's about commitment i have over committed and given too many talks this week and uh when you go through a cross-chain message cycle you are over committing to what you want to do so we have in this process a bunch of different commitments what's a commitment it's when you make an irrevocable statement about what you want or what you're going to do or what the message is so when the uh on the origin chain we kind of neglected a step it's like the chain has to run the transaction for it to be sent to the application and to be dispatched to the other chain and in order for the chain to run sorry uh one sec let me move this there we go uh in order for the chain to run the transaction the user has to send it in the first place the user has to sign and send an ethereum transaction before ethereum does anything so the user has to commit to their intention they're signing this transaction it calls a specific contract with some data and the contract is going to do stuff after the transaction is executed but that doesn't happen until after the user commits to their action and broadcasts it to the network so the user commits first and then the chain commits that transaction the chain actually like puts that transaction into the blockchain includes it in a block miner runs the whole thing outputs the new state route and that transaction includes a commitment to the cross chain message so the user is committed and now the chain has committed so we have two commitments here now off chain what's going to happen is that some relayer some third party is going to see that commitment on chain and say oh i need to dispatch a message to the other chain i need to sign a transaction on avalanche or on moonbeam or wherever so the off chain actor sees it decides to forward it and signs a new commitment containing that message uh you know signs a transaction on the other chain that commits to the message that's supposed to be processed so we're up to three commitments in this process so far and then the other chain needs to finally commit the transaction containing the commitment to the commitment to the user's original commitment uh so you have to go like four deep here um when you are processing cross-chain transactions you know you're making multiple commitments over a long period of time uh you know usually minutes or hours so finally after four commitments the user's intent to send tokens to moonbeam has been realized they've gone through the ethereum process they signed their ethereum transaction they submitted it to ethereum it was included in the chain it was seen by the octane actor it was dispatched to the other chain and then it was included in the other chain uh it's actually a lot of work and these things fall apart quite often so that's a lot right like we go through a lot of steps there's a lot of commitments there's a lot of signatures there's a lot of people involved uh so this is what it looks like for a cross-chain message what do you think it looks like for a single chain message you see how we just uh you know like cross chain single chain cross chain single chain like it's completely different uh you know we go from this to this it's just like five times easier to process a message on a single chain uh we don't even think about it that's how much we do like so i don't remember how many loops i did on that slide uh okay so in a single chain transaction where are the commitments there's two like the user signs like we talked about earlier and then the transactions submitted to the chain and is committed by the chain when it's included in a block and then you're done like that's all you have to do the user's intent was realized after just two commitments and one transaction so what does this uh how does this compare to the cross chain thing is it's you know half as many commitments and it takes significantly less time uh and like like just look at this like look at the difference here yeah it's ridiculous so you might be thinking what does all of this have to do with mev this is mev day right why are we just talking about commitment issues and uh uh how many talks i'm giving this week excuse me uh mev happens here like between the time the user has signed the transaction and between the time the chain runs the transaction that's when miners or block producers can insert reorder sensor do whatever it is they do to extract mav it happens uh you know because there is a gap between signing and processing so wait a second like signing and processing haven't we been talking about that the whole time uh yeah like if you choose one thing from this talk to remember this should be it is mev is what happens when there is a time gap between commitments anytime you have two commitments and there's a gap between them of any sort mev is what happens because you have committed to your intent you know irrev irrevocably committed to what you're going to do but you haven't done it yet your intent hasn't been realized so let's go let's go back and look for a second uh let's look at our cross chain message again so there's mev between the time the user signs the initial transaction and the time it's included and then there's mev after the transaction has been committed to ethereum and committed the cross chain message that's supposed to go off to polygon and the time that that message is actually dispatched to polygon and then there's mev between the time that the relayer dispatches that message to polygon and the time that it's committed so you might expect that there would be two mev like opportunities in cross chain messaging because there's two transactions but there's actually three uh so crosstrain mev is worse than anybody expects when they start getting into this so mev is created for each transaction in this process two transactions on two chains and for the gap between those transactions after ethereum has committed the message to its state and before that message has been dispatched to polygon uh so you know technically this wouldn't be mev it would be like relayer extracted value but you know making up new acronyms just kind of sucks and mev works great and everyone knows what you mean so mev in cross chain messaging is three times as bad at least as mev in single chain transacting so that's why and this is the spicy part of my talk and then i'm going to end for questions uh that's why cross chain dexes won't work because when you submit your cross chain dex transaction there are three different parties who can interfere with it as opposed to just one on a single chain decks and three different opportunities for them to do so and because all of these commitments happen sequentially there is like more than three times as much time gap in which these parties can interfere with you and more than three times as much time gap in which the market can move against you if you say i want to swap my usdc on ethereum for matic on polygon there is three times as much mev as if you just swapped that usdc formatic on ethereum using uniswap or whatever uh and so that's why crosschain dexes aren't going to be a thing people are going to bridge and then dex or vice versa they're not going to do them both at once uh and if you're doing silly things like hop where you dex and then bridge and then decks again well that's just five times as bad because now you're generating extra mev on each end of the bridge uh so that's my talk i would love to open it up for discussion or questions i think i have a bit more time because i like rushing through my slides and talking really quickly hi man uh so e what is like um why don't why don't can we just use atomic swaps like what is is there some hidden constraint to this approach like have you ever done an atomic swap uh no can you just explain it um okay well i i mean like i get the fundamentals like you build like basically a trusted system to to swap like assets um but like what are the fundamental like limits to that and why do we do this like um like uh right so an atomic swap is actually a four phase protocol uh it requires four transactions two on each chain uh for like the simplest version the easiest to implement uh it requires two confirmation cycles on each chain before it's committed uh before it's fully over and the user has to be online for that entire process so the user has to be online and personally observing two different chains for the entire usually like hour plus period to execute an atomic swap if you're going through bitcoin which does support atomic swaps and is the origin of the construction you actually end up spending like six hours with a safety margin because of the high variance of bitcoin's proof of work block time um for like further discussion of this i would look up dan robinson's talk at stanford in 2018 maybe it's called htlc's considered harmful htlc stands for hash timelock contract which is the primitive used to build atomic swaps in most cases uh we did propose and implement an alternative to the atomic swap called the spv swap which used a bitcoin header relay to verify bitcoin proof of work uh in order to execute swaps between bitcoin and ethereum um we you know used it for about 10 eth and could never get anyone uh interested in it but it's generally speaking like faster and a bit safer than an atomic swap because there's no user synchrony requirement um but nobody likes doing bespoke cross chain protocols because wallets don't support it and everything's terrible about the user experience do you think the fundamental limit to atomic swap is that nobody wants to fund it because you can't make money from it well you know you do have like the free option problem is the first funder is writing a free option for the second funder in atomic swaps so you're always incentivized to be the second funder and then to after seeing the first person's transaction confirmed decide whether to complete the trade this also leads to a denial of money i guess attack denial of service attack where the second funder can costlessly cause the first funder to lose access to their funds for the duration of the time lock on the atomic swap um essentially like when we built all of the atomic swap stuff back in 2017 2018 we decided that the ux issues were the main blocker and the uh financial issues were secondary but also significant nice thank you sorry i know there was a big information dump i can explain more of it if you find me afterwards this is one of the downsides of being in a specific niche for so long like you just pick up all of the useless information and want to talk about it hi uh thank you for the talk uh so you just described uh like multiple problems with the mvv in bridging and uh i was wondering if there are any like existing solutions or any like uh like in progress ones um so there's two general approaches to mev resistance uh or to you know like fixing mev for an application uh the first is what thing uh protocols like anoma are doing where you actually uh conceal the contents of the commitment until certain events have happened so you can seal the contents of the transaction until it's confirmed on chain and then you conceal the contents of the cross chain message until it reaches the other chain and then you conceal what it's doing until it's included in the other chain so those are in relatively early stages of development but are very interesting and uh anoma is doing most of the like research and development work in the space on that right now um the other approach that i would recommend for bridges like crosstrain messaging specifically is uh just don't swap assets don't do things that generate mev on a single chain instead of swapping assets bridge first then swap or swap first then bridge uh if you are just moving something and you're not like trying to get a profit from it there's much much less mev and much less likelihood that someone will interfere with what you're trying to do hi there i think for the presentation was great uh i'm curious about something because i see a general pattern to try to improve the ux for users especially in cross-chain domains that is just uh integrating more functionality in a single transaction so that the user doesn't need to reason about the flow that goes very much into contrast with what you're saying right that is the user should themselves actually separate these units of interaction to minimize mav oppose the preferable ux right at least i prefer that ux in which a trigger wants something and then the chain of like things that i want to happen actually happen it's a bit abstract but i think you get what i mean right yeah is you would love to be able to you know issue the bridging instruction and the swap instruction for when it reaches the eventual domain at the same time and then as the user walk away and close your laptop and go outside uh i think that that is a very important use case and we do work to enable it uh what we think is important is that these actions are sequential and not concurrent um in any time when we're doing an asynchronous operation across different blockchains uh any component of that can fail so the bridging can fail where you don't end up crossing the bridge at all and the decks can fail where you end up with you know the wrong asset where you end up with what you started with instead of what you wanted we prefer not to tightly couple those so that they fail independently and we feel that that gives the user more ability to express what they want so we support use cases like couple a dex transaction with a bridge transaction or a couple of bridge transaction with a subsequent dex transaction uh we don't support or believe in use cases like the bridge transaction and the dex transaction are the same transaction i said the word transaction an awful lot there but i hope like makes sense just one quick question um as you mentioned i mean getting more uh well gaps between commits of course creates more me opportunities but is this more a matter of opportunities or is it a matter of magnitude that is do actually the individual mue actually compete for muv to be extractable uh that's not necessarily true because they are happening sequentially and there is a time lag when you are doing something like a cross chain decks you can actually give mev away to all three of those opportunities because the assets fair price will move uh potentially multiple directions while your trade is occurring so there's usually not a huge increase in magnitude but there's an increase in opportunities and there is some increase in magnitude caused by the additional time taken for your trade to fully complete thank you [Music] 