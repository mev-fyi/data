[Music] and i want to talk about mev and l2 so here's the tl dr from my talk l2s work differently from ethereum in some important respects and unless you're careful your assumptions from ethereum may steer you wrong in thinking about l2 uh mev on l2s so what i want to do to sort of flesh this out is i'm going to talk a little bit about how arbitrarum works and the things i talk about will be common across the deployed l2s as far as i know then i will talk some about how this affects how these differences affect the mev landscape and then finally i'll talk some about what we at arbitram how we approach it what our principles and uh uh are about this and uh and what we're actually doing okay let me start by talking about how arbitram as at this level a typical l2 works and if you've seen one of my other talks this week you may have seen this diagram before i'll go through the parts that are relevant for this talk the key component here is the sequencer in the upper left so in under normal conditions users send to the sequencer all of their transactions directly by rpc the sequencer gets those transactions and what it is supposed to do is post those transactions uh put those transactions into a sequence that the sequencer decides but it is supposed to put them into an arbitrary first come first served order so the sequencer is responsible for putting transactions into sequence order and for nothing else it's not trusted for any other purpose anything else it does that it might do wrong is checked for and corrected for by the rest of the system so that's all it does is sequencing and i'll talk a little bit about how this works and so on the sequencer might be a centralized element or it might be a distributed system uh more on that later okay the sequencer then does two things with the sequence um thing one is it publishes a sequencer feed very quickly and in a second or less after your transaction has arrived at the sequencer your transaction will have been put into the sequence and the sequencer will have published it as part of the sequencer feed that's a feed a real-time feed that anyone can subscribe to and if the sequencer is honest then that will be the order in which transactions occur in uh in the l2 chain now over here on the right we have the state transition function this is basically a function that eats one transaction at a time processes that transaction possibly updates the state and then possibly and then possibly emits an l2 block this func state transition function is fully deterministic so the outcome at any time will depend only on the genesis state and on the sequence of transactions that it is processed up to now and on nothing else what that means is that the sequencer sequence output fully determines the eventual state of the chain okay so the sequencer publishes its sequencer feed very quickly this allows users who decide to trust the sequencer for this for its sequence on its sequence to get a very low latency response to their transactions users love this this is a huge user experience advantage and that's the reason why the sequencer feed exists and indeed why the sequencer exists at all but then the other thing the sequencer does is once it has built up a large enough batch of of unrecorded transactions it it makes a big batch of transactions compresses it using a general purpose compression algorithm and then writes it onto the l1 chain and this is the final and permanent record of what the transaction sequence is and because of the determinism of the state transition function it determines completely what the eventual hist what the history of the chain will be up through that part of the transaction sequence so from that point on the wheels inevitably grind to cause those transactions to eventually be settled back to l1 okay so there are two interactions that this process has with the l1 chain one to store the compressed batches and the other to settle the transactions to l1 now what's interesting about this is these these transactions to l1 don't really care about ordering if the sequencer is honest then the batch and compress and record transaction is only recording information that's already known it's simply recording and notarizing information that everyone already knows and so if it gets delayed a little bit or advanced a little bit that doesn't affect anything it doesn't affect the history of the l2 chain it only affects when the l1 chain learns of that history similarly over on the right when you settle the transactions to l1 the result of that is inevitable fully determined by what already happened and so again it doesn't matter that much whether it happens earlier or later everyone knows it's going to happen the only question is when and so there's not much opportunity or these things are not very sensitive to mev considerations i put an asterisk on the one on the left because if the sequencer is lying which could happen occasionally it might lie for a little while before it gets fired and replaced by another sequencer if the sequencer lies then you might care how quickly it gets caught in the lie okay but for the most part there's not a lot of mev sensitivity in these transactions but of course what you're maybe really interested in is what happens uh regarding mev on layer two okay um let me stop and talk about who runs the sequencer because i think this is important in thinking about how all of this works because the sequencer is really the only party who has opportunity to extract who is the only party who is definitely sitting on the path that a transaction must go through and potentially has power to extract mev so currently the sequencer is centralized it's run by us the arbitrary team and so if you trust us to run the sequencer honestly and if you believe we're running the code that we published then uh you're good to go um over time though we will move to a distributed sequencer the sequencer will become a distributed system now importantly we are not following the paradigm that some decentralized sequencing systems use where you have a rotating sequencer which is basically a rotating centralization system where each step or round or block is centralized and you rotate who gets to do those things instead this is a fully distributed system i'll talk in a minute about how it works but the guarantee we give is that as long as k out of n of those participants are honest for suitable values think more than two-thirds honest um then the result will be honest it will it will meet the specification i'll talk in a minute about what that is um it's also worth noting that in this scheme dishonest behavior by individual sequencer nodes will usually be detectable not provable to a third party but because it's detectable that means if a sequencer consistently cheats then that then then that will become common knowledge that that's a cheating sequencer and so a social mechanism or a governance mechanism can kick in to replace that that lying sequencer okay so uh in a distributed sequencer world you provide a distributed first come first served type of of policy and here's what that means in particular the the story of a transaction basically is that the user multicast their transaction to all of the sequencer instances think 15 to 20 of them user multicast their transaction to all of them or almost all of them each sequencer then publishes its own ordering of the order in which it received the transactions or so it claims um and then there's a fair sequence merging algorithm that takes those individual claimed sequences from all of the sequencers and merges them to produce a consensus sequencer sequence and the guarantee is something that you might informally call majority first come first served which is roughly that if a super majority of the sequencers are honest then if your transaction arrived before mine at a super majority of the sequencers yours will be before mine in the order there's some technical nuances here and a big shout out to the research team at cornell tech um uh mihin mckelcar and ari jules and other collaborators who produced the work that makes this possible basically they showed exactly what properties could and could not be achieved and a good algorithms for achieving them but in any case this is the guarantee that if a super majority are honest that the result will be first come first served in sort of the natural sense that you can define that in a distributed system with asynchronous clocks okay now you can also combine with this the use of in public key encryption of the transaction and threshold decryption by the sequencer committee members uh that seem that sort of knits together in a really cool way so that uh people in the middle including the sequencers themselves don't know exac the contents of the transactions until it's too late for them to uh to modify the order okay so that's sort of the technical background let me now turn to how we and the arbitrary team think about mev i'm going to give you two principles an observation and then tell you what our policy is principle number one is to reduce users costs reduce users total costs right that's one of the big reasons people come to an l2 they want lower cost and we want to reduce total cost so that includes the cost of any slippage or other loss that a user suffers because someone reordered on them so to the extent that someone is a victim of mev extraction then um that implies that we should reduce mev extraction where we can there can be some pro-social mev extraction we're fine if users can opt into it i'll talk about that later but we don't want to force people into a world where someone can extract mev from them because that is a cost and our goal is to minimize cost but also the second principle regarding cost and fees is we try to make users costs incentive compatible and in particular that means we want to incent behavior on users behalf which reduces the use of scarce resources in the system and which preferentially reduces the use of the scarcest resources so to the extent that a user's costs are perfectly aligned with their usage of scarce resources then users have the incentives we want them to have and our chain and our users will use those resources efficiently to the extent that there's some other element of cost which doesn't correlate with that use of scarce resources and users are optimizing some combination of those things say some combination of resource usage and mev resistance then you're going to get a worse result for re resource use and our chain will be less efficient so that user may be saving their cost by making themselves mev resistant but using more resource but by doing so they're transferring cost onto other users because those resources become marginally more expensive alright so this is why we would prefer to keep mev considerations mostly out of the cost equation of our users unless the users have some reason that they think mev will will benefit them all right observation number three users really love the one second transaction latency you can't really appreciate this until you ship a system that does it and you hear from your users um and they love it for two reasons one is from a use from a you know it's basic it's basic doctrine in the user experience world that there's kind of a boundary around one second the things that take more than one second feel like they take a long time and you're tempted to go get a cup of coffee things that take one second you notice the lag but but that's pretty good people want to have not only a low mean latency but also a low low variance in the latency and that is important it's something we want to preserve notice the consequences of this for mev extraction which is that if we were to build up a big mempool and let an mev extractor choose from that big mempool that would necessarily increase the mean and variance of the of the latency that users experience and that would be bad for users okay so what is our policy our policy is the sequencer provides a first come first served ordering of transactions that gives the um that's best from the standpoint of uh latency mean and variance um it's simple to implement it's simple to explain to users okay let me talk about the implications of these things for uh for mev more generally across l2s uh the first one is that the mean and variance of latency on these systems is much lower than on ethereum and that the mean is important because it's sort of a measure of how much of a mempool you can build up and reorder before you're starting to increase the the time very much and the variance is also really important um that um ethereum already has a high variance in the latency to get your uh your transaction recorded and so if you add some more variance because of mev extraction users don't notice it that much but on a system with both very low mean and very low variance users notice a lot and it degrades the user experience that means that there's only probably a fraction of a second of mempool that you can build up and reorder in an mev extractor before you start to degrade the overall user experience of the system um right so here an mmv extracting sequencer would either significantly increase latency for many transactions or be able to only manipulate sort of the timing of individual transactions by a fraction of a second so much less opportunity for mev extraction without paying a price in other areas that are really important to us okay some other topics to discuss um one of the things that has been proposed is the idea of putting an mev extractor in front of the sequencer on a kind of opt-in basis the idea anybody could do this of course um our sequencer or distributed sequencer is a set of nodes that are uh trusted or collectively k of n trusted by um by our community and of course our community isn't going to be involved in uh in the in the deliberations about how to select them um so but anyone who wants to whether users or we like it or not can put an external mev extractor in front of the sequencer and users can choose to use that as a proxy for submitting their transactions so that is the thing that can happen those user if you're a user for example who's doing a defy transaction and you recognize that you're creating an arbitrage opportunity behind your transaction and you'd like to be able to sell that opportunity um you you could choose to route through an intermediary and of course there can be multiple of those and they will compete with each other on on user value that's a thing that a we can't stop and b is probably a good thing as long as it's not mandatory for users which it won't be users can go directly to our sequencer or sequencers or they can go through this intermediary go through an intermediary you'll get slightly slower response because of the intermediary but maybe you can extract some value the other thing of course the other piece here is because our sequencer is currently sitting geographically somewhere and because the members of the distributed sequencer set will be sitting geographically in a bunch of places probably around the world people may compete to get geographically close or network latency close to those sequencers in order to get faster response time and that could and that will probably exist we have we don't have hard evidence but we strongly suspect people are already doing this um um that could be exist for private use or it could be sold as a service and in general anything that has value for private use probably um has could be sold um as a service as a business we expect that as things mature and develop that that might well happen um the consequences of the geographically distributed sequencer committee here are interesting um because if you have a point of presence if there are 20 sequencers scattered around the world and you have a point of presence at each one and what you need is to get your transaction to a super majority of them before somebody else that means you may not have time to coordinate between your different points of presence in order to coordinate on what you're going to do so there is some limit on your ability to actually use geographic proximity in this distributed system sense simply because if alice is sitting in one place and multicasts her transaction out across the world to everywhere then if you see it over here and then try to inform your uh your friend over there of what to do that alice's transaction will probably beat you right because you have to pay the triangle penalty um for your path and so there is some resistance to to the geographic proximity methods essentially someone would need to have a deterministic method of reacting to the transactions they see which is a little tricky because if you have only local information about the order in which your sequencer saw the information that's not a guarantee about what the majority will see so there's some complexity here and arguably it's a bit more difficult to try to get geographically near so that's basically where we stand i've given you a little flavor i think the biggest difference you see in just to summarize between l1 ethereum and l2 is in the response time of the sequencer it's in the fact that ordering is done by transactions blocks are not built in the normal sense it's a per transaction ordering process and that has implications as well so i'd be happy to answer any questions or engage in any discussion or civilized debate um and i think we have about 10 minutes for that i'll repeat the question if not fan you're um great work um just because you're talking is there a possibility perhaps might be a good idea might be a good idea to continue to run your centralized sequencer in parallel to a distributed version thank you um would it be a good idea to run a centralized sequencer in parallel to a distributed sequencer almost like a kind of first of all to give an alternative to users and secondly almost like a kind of economic incentive to the distributed actors to behave you know you've got this kind of threats that if they start messing with the sequencer people get to see it and they've got this alternative they can quickly go to of uh you know the sort of reputation based yeah centralized is that something that's occurred to you do you think that might be a good idea so i think there are some difficulties with this i think it may be the case that when we roll out a distributed sequencer our centralized sequencer will become one of the parties in that uh in that's in that system that seems pretty likely you can have different sequencers who um who publish their opinions about event ordering right there is a core problem though that different sequencers if every user is multicasting their transactions and every sequencer is honestly reporting its order of res of receiving them um they will report different orders right just because of you know of how network latency and delivery works um so there's a sense in which there is only a sequencer who sits in one place is really the only party who knows what truth it should have reported right um at least um it's sort of in detail it's difficult in a single instance to figure out who's telling the truth or who's lying the other thing is that people could of course if we had a parallel reporting system that like got the transaction separately and reported what it saw a user could manipulate that by multicasting to the sequencer committee now and then waiting a while and sending to us or the other way around so the fact of differences between arrival time at different places is not necessarily evidence that could be shown to a third party about what went wrong now if you and your friend now if you and uh and you wearing a different hat at a different ip address send transactions to the same sequencer and you in fact can know that a arrived before b but it puts b before a or if you detect that your transactions consistently see longer latency than that other person's than your friends right that's some indication that that sequencer may be manipulating um order so in a kind of um in a kind of collective and cumulative way a dishonest sequencer's dishonesty is likely to become evident but you can't detect it with an automated mechanism at least not that i can see and so you have to rely on social response yeah one thing i was just going to add there is uh i just come clean i'm i'm founding an organization called xero mev that that attempts to quantify um on chain mev in different layers and specifically kind of tends to differentiate between toxic and neutral so one way you can do that is you can try and quantify the amount of toxic mvv that's happening so for example sandwich attacks a great way of seeing very quickly and very clearly where the users are being exploited on a certain chain so if you have some reporting of you know the kind of relatively how many sandwich attacks you're getting on a distributed chain versus the the centralized that could be quite a powerful incentive for that not to happen on the distributed chain i mean on a centralized chain of course the centralized sequencer has the power to do a sandwich attack to people in a distributed sequencer it would require a a majori a suitable super majority to all coordinate their sandwich attacks right which you know you can't rule out technically but which the trust requirement um would rule out and if an organization were to report that that was happening then um you know then we and our community would take notice and you could expect the sequencer committee members to be changed and of course it's really important in the distributed sequencer model that each sequencer publishes their claimed sequence and so you have the evidence of if one sequencer seems to be sandwiching a lot you you actually have the evidence that you can point to um and say look this sequencer is set these sequencers are sandwiching and the other ones are not something must be happening hi you've spoken briefly now about how it's possible to detect dishonest sequencing but what actual incentive is there to be an honor sequencer well you won't be fired you won't lose your job as a sequencer that seems like uh a small incentive there because if i can just spin up another sequencer i'll just keep creating more and more decisions right so the set of sequencers is permissioned um and is chosen through is chosen through a process that involves deliberation by our community um and so you don't automatically get to be a sequencer just because you want to sure coming back to the to the roadmap towards distributed sequencer if you think of things like cross-domain mev and the risk of some of those sequences are colluding with other sequencers from other l2s to extract maybe there's a there's a trade-off that is becomes quite complicated between a centralized sequencer that is operated by a company that people can trust is honest operating honestly versus a distributed set of sequencers that might collude in a way that is quite unpredictable yeah so how do you think about the timeline and the moment when the trade-off towards this distributed sequencer becomes a positive outcome for the user sure uh yeah let me say a couple things about that the first is that if a small minority of the sequencers in this scheme are colluding with outsiders that has no effect because the honest super majority will still provide the uh distributed first-come first-served guarantee regardless of what a small minority does the second piece of that is yes it's really important how these sequencers are chosen they're likely to be parties who are trusted by our community to be reputable and have reason to be honest and if they misbehave um and parties who uh would suffer a reputational hit for uh for misbehaving i think you know if you think about the process for how you would choose those parties you would want ones who have a reputation as trustworthy in the community who have reputation to lose who have a stake in the success of the community and so on um and so um you know i think you end up um i think the considerations that you suggest are would play a big role in choosing the sequencers and should we have time thank you everyone [Music] you 