[Music] thank you all for coming today we're going to talk about symbolic mvv extraction or map extraction my name is georgios i'm ceo and partner at paradigm we're a venture capital firm with our hands deep in crypto um so i'm not a searcher this might be impractical and this is more so to stir up a discussion rather than say you know this is the best way to extract math and take it as you wish the whole talk is centered around this question of we have very solid techniques on proving software security and how well can we apply this to the domain of mav extraction to actually make money and uh maybe just to give some background which i'm sure many people in this group are familiar with um the state of mov searching more or less the main categories are these we have arbitrage of various kinds we have backgrounding and sandwiching have liquidations and then the so-called long tail which turns out to be really really long and there's like a lot of categories of have to be extracted and the software stack of a searcher roughly looks like a bunch of nodes to be able to access the state and to be able to access the mempool about for each integration that you want to have typically that both has full knowledge of the app that it's extracting and we'll call that white box simulation for this conversation and then it has stuff like getting your your transaction on chain either via fpga or via flashbots or blocks route or whatever else and finally observability so we're focusing here which is like only a very small part of the broader stack so this ties back to my original point now looking at the black white gray box analogy we can see that on black box you have no knowledge of what's going on in your system on grey box you have some on white box you know everything and how this manifests in mavic traction techniques when your white box mave extracting you know fully how an app works maybe sometimes you rewrite the native code event for performance a lot of people do that for example for uniswap instead of going through the avm they take the reserve values and they just they take the reserve values and the trade data from the call data and they run it from their own rust implementation or whatever but that requires a lot of maintenance however it is very reliable and fast now black box we can think of it as that you define some properties and you throw things at it and maybe like gives you something back that works maybe doesn't so it's unclear how reliable it is and the black box black box techniques are for example fuzzing where you throw data at the binary until it crashes you don't know anything about the binary you just throw information at it and the father gives you back something that says you know this input crashed the binary now gray box is similar to black box but with the with an extra feedback loop that as it's executing things it's gaining some information about how the system works and fits that in back to your solving system so going from the very white box style um mav extraction where you know everything like arbitrage and liquidations we can then go to somewhat black box style mavex action which is in the generalized front runners domain and don robinson and i wrote an article about this called ethereum's dark forest which kind of talks about this beast in the mempool which the moment there is a transaction that can make money anywhere where the transaction exists in the sub-traces of a call the bot goes in it copies that sub-trees and goes and executes it so now this is a very dangerous kind of front-runner because it means that anytime you need to execute a white hat for example because you found the vulnerability like my colleague sam says the sun finds every day um and you know if you get front run and you're going to save a lot of money and that money goes to a bot that didn't even know that this was attack obviously it's a problem so these boats can cover along a lot a lot of categories and typically how they work is that they have defined some conditions in the client where they say was the storage slot change from value a to value b if this this and that happened then copy this subtrace and maybe replace the message.sender with my address or something that area but it's all rough permutations of that technique and usually or really any time they don't discover new mv opportunities they're literally a copy trader a very very smart copy trader and so the question now that we have some context is that can we not know what we're digging for sort of like how mining in proof of work works where you just keep hashing and hashing and hashing and you don't really know what you're doing you just do a dumb problem so is there some mapping of this problem to mav extraction and you know mav extraction starts to look a lot more like mining if it becomes independent of what the problem is so to do that let's talk a bit about property based testing so there's two kinds of testing roughly there's integration tests too but not relevant for this conversation um unit testing we say okay this my scenario let my input be x equals five run to multiply by x you get some output and you check it against what you would expect multiplication to do so here would be 10. whereas property based testing you never define your input you say this is what i want to hold you know inputs x y z and many many many inputs are going to be chosen and for every one of these inputs this property must hold so let's say you're testing the commutative property it will throw a bunch of x values and y values and z values and check that parenthesis you know commutative property obviously holds um and there's two ways to use property-based testing and you see this like the first usage you see used a lot by developers the second usage you see used a lot by auditors so when developers are making their code they're writing property tests at least some developers do to ensure that the code is working as expected beyond trivial scenarios and you know an obvious example of when this would be useful is like division by zero so you've written a test where you've written some code where it's undefined over zero or there's some rounding error and you're you just didn't have a good input for it and you couldn't observe the rounding error and then it hits you in pro then you have a problem so that's the defensive use aggressively and you will see this a lot by trail of bits with their tool echidna whenever they do an audit they will say okay this is how i want my math to look like they write the math they translate the mathematical properties that are supposed to be there and then they run it over a property based tool called the kinna and what it does is that it finds you a counter argument the minimal counter argument to be clear which breaks that property now things start to make a bit more sense we have a property the property here is about security but maybe we can transform this property on can i make money so let's start to make this more interesting so instead of saying that the property is is this commutative or division works which it's obvious what about saying let's say that we define the property called is the contract solvent or does the contract have a never decreasing if balance and that's your property so think that if you want to make money you want to find the condition so that the contract does not lose money so you want to break the property that the contract is secure so you whenever you want to do something you have to write the invert the inversion of it and how you would do med extraction for that is that you would monitor every new smart contract gets deployed you would get the contract you would parse the byte code you would get all so you never have access to solidity or the api or the source tree or whatever this industry just have byte code and it's very important because we're talking about zero knowledge about the the the the shape of the application in a way so you can get all of its function signatures from the jump table and what you can do is that you will start throwing random function calls edit and random with an asterisk which i will refine in a bit so i take a contract i call function a with some argument i check the property the property says has the contract lost money if it has lost money return me the input or the sequence of calls that cause the contract to lose money and i don't do this one or ten times you do this hundreds of thousands of times over multiple depth calls so not only do i do one call i do one two three four five consecutive calls because obviously the vulnerability all the mav opportunity it might not be on a single function gold might be on a series of function calls and so you do that and ideally you can find some argument that breaks the property and then you submit the transactions and you make money sounds great now how are we going to choose the inputs the design they clearly the input space is gigantic many functions many arguments many iterations what do so here's where we get to the topic of the discussion which is symbolic execution so in symbolic execution you take a concrete problem instead of solving it for the values that were given to it instead you translate it into a bunch of constraints some restrictions some rules that need to be followed and then you will use some smt solver which i always forget whether some smt sold stands for to be honest and you use the smt solver to find inputs which satisfy or not satisfy these constraints and in security you use that to prove formally prove that the program is secure but if it's not secure the solver will spit out the inputs that broke it and just to give a bit more of a visual example and i appreciate the patience because the slides are very heavy on text imagine that you have this kind of function over on the left which says you know i have a function it takes x and y um so i have a function for which always doubles and then i also have a test which makes assigns z to four has a conditional check and has another conditional check and if both branches are taken it errors so in the concrete case the test that we would write would be test me over inputs x 2 y equal to 3 or whatever you would run it you would pass and you would say i'm good obviously that does not cover everything um if you're doing fuzzing or property based testing instead of x and 2 x equals 2 and y equals 3 it would say x equals random y equals random run it execute it and run it 100 000 times and ideally the property always holds now on the symbolic case what you have is that you have the state and the constraints and there's various ways to call this in which might be more accurate but again this is not like 100 percent makes but it is so bear with me in this case the the state are the state variables which in this in this case would be x y and z and z you will see that is always defined as two multiplied by y in this case because z equals four and then the constraints that you get is that anytime you hit a conditional statement reality splits into two it's almost like a tree of all possible states and in the one case the branch was taken in the other case the branch was not taken so the inputs they're not concrete they're symbolic they're abstract they do not exist until a later point in time and this means that you can simultaneously explore multiple future realities without collapsing it into one and you know if tyrone was here he would say this is like quantum computing um so once you have translated the program to the constraints then you feed it to z3 or ccv3 or whatever other solver you're using and the solver will output true or false along with the inputs required now this is great obviously this is a trivial example for more complex examples it takes more time that's why it gets back to my original point around is it theoretical is it practical and now staging it on the avm context and on the right side here you can see what i mean about all the possible futures that it never collapses it just keeps them all simultaneously in reality until it feeds them the solver which does the collapse so you use a symbolic vm to you feed it some byte code and anytime it encounters some kind of op code or some input that it can do abstractly symbolically it will split reality so let's say there's an if condition it will split into two now there's restrictions for example in for loops you cannot do that you cannot symbolically execute the for loop because it does infinite state explosion so you need to constrain it in some way and as a coder here a lot of the problems that we see in translating concrete to abstract representations for symbolic execution you see them in snarks when you try to translate a normal program to a constraint program for usage in the proof examples of this kind of software are many my personal favorites are hvm and paccala but there's also material by consensus manticore by trail of bits and probably others so now we have all the pieces like containing how we can use this to make money so basically to take the property property-based symbolic and the property-based med extraction we take it and we lift it from simple randomness to something that's actual more structured so you monitor your contracts you symbolically execute multiple evm transactions same thing as before you take many transactions you take many functions many different but but this time you don't take many arguments because the arguments they get chosen by the solver at the end you send the solver hopefully the solver returns and you're good now the insight here is that the solver effectively learns the structure of the problem as it starts to as it receives the constraints like the constraints express the structure of the problem so intuitively you can think that the random fuzzing it doesn't know what the hell it's doing it's just throwing inputs whereas this it translates the program into constraints and the constraints guide the solver on where to go extra context here z3 and the other solvers they use multiple heuristics under the hood to effectively explore all the possible states so here what we've seen in production with this is that found the zero day in etherscan rip and he built a ctf puzzle which he called pinball now the pinball game it was used to illustrate the zero day so it had the back door which you would insta win but it had the literal pink pinball game with controls in solidity where you feed it by streams and depending on what bitestream you feed it you play pinball and you gain points now some people tried to solve it manually but this guy um said all right let me express it in properties uh so he literally said and i'm not gonna go through the code but you can go the link and see it yourself he literally said require score less than five thousand and when you say to the approver require score less than five thousand it will find you an input which gives you score over five thousand so you can keep doing that until you get more high scores now obviously the more complex the state the more deep the state of the program that you want to get the more time the solver takes to solve and maybe doesn't terminate ever so you need to thread that threaten me another thing that leo who is probably the smartest formal notification guy i talked to right now he wrote in symbolic execution engine limited granted but in solidity so it's a good testament of solely that you can do really great things if you give it the love it deserves now i don't know if the slide is okay but like uh yeah like basically there's a big like yeah i don't know but i like the meme what's what's next um we have symbolic math extraction can we do fast symbolic math extraction so i'm building a tool called foundry which is a testing framework um it does not have symbolic execution yet inspired by dab tools which had hevm which lets you do what the guy did on pinball ideally we're building a new symbolic rust engine which can be used or will ideally be used in foundry to be able to do symbolic execution now because it would be built in a modular way if you're a searcher you could probably import the library and try doing it yourself we'll let you know um david terry uh dot hub engineer he's building an evm specific smt solver basically the thesis being that yes z3 good but the same time z3 generic so what if we made a specific solver like an application specific solver we don't know if this will work but it's an interesting venue again research open ended etc now another crazy idea which i have no idea if it's also possible is that because solvers are very heuristic based maybe we could train an rnn to the other via reinforcement learning to learn all the heuristics from the solver so the process would be feed program the solver feed program to the to the neural net neural net losses solver wins neural net adjusts over time neural net has learned all the heuristics and because the neuron light ideal with high dimensionality it can generalize to a few more cases than than the solver and because the neural net uses only linear operations and it's like fully parallelizable over gpus and whatever it would probably yield us non like significant performance improvements dvd if anyone wants to do this please come talk to me um and the final idea which might be larp is that like if if the problem ends up indeed being very structured and you can literally you're effectively doing like mev mining by literally like crunching through the solvers maybe it makes sense to eventually move on to hardware specialization fpgas a6 whatever it's also likely that this is just like a bad rabbit hole and it's a bad idea and it's a waste of time um that's about it i don't know if i have time for questions but happy to take any if i do [Applause] hi yeah can you go back one slide please yeah i mean this is yeah so this kind of work obviously has happened some of it in the set world i i build a set server they're called set modulo theories actually that's a smt since you had trouble with that thank you thank you yeah um and training uh models to um to um to um to help the heuristics of uh sat solvers or smt solvers is i mean i personally spent maybe wasted three years of my life on that but uh yeah so it's possible and yeah there are works out there partially by me and others um and the asic part i mean what you so usually what they do is they start at fpga right so you want to do an fpga first and there have been tries but it's extremely difficult to change the um the computational model to you know to fit this new thing so there's actually a new work by one of the masters of the south field called the army beer on gpus so which is also different you know computational architecture um and it is interesting but it and it is to some extent competitive but i wouldn't say it's extremely competitive but you know it's not being used right now and i also personally worked on lifting some of the things to gpu and uh yeah fpga is really hard so but it's possible it's just you have to throw a lot of money in it because it's complicated yeah and another point would be i haven't studied at all how the memory access patterns look like so whenever you want to use hardware you cannot have frequent like random access memory random memory accesses because you get a lot of the speed up by loading all the data on the gpu on the fpga card and then just using the high bandwidth memory there whereas if you go on to puff chip you waste a lot of time yeah yeah so that's what i meant by computational like that's yeah the memory access patterns are so different and caching is very different and yeah i'm not going to go there yeah anyone else all right there nobody understood anything or everybody understood everything victor hey great presentation um so my channel is that it's really like arbitrary in terms of which contracts you can go after but when you think about it from a perspective like would this be more applicable towards like d5 or nfts or it doesn't really matter the whole idea of this is that you can extract the longest of the longest tails without knowing what what it is so i would say that's where it finds great application whereas structured problems like defy applications they benefit a lot from the white box approach so i would i would consider it like this is how you explore more of the map rather than how you dig very deep on one part of the map if i can ask a follow on um like is it possible to structure the system such a way that there is like because here it kind of like tries to find the answer so it's not just like exploring it's like digging holes and essentially i'm like you know pulling out treasure is there a way to structure this so that it does a better job of like predicting without doing as much work like which areas to focus on so you can do like the white box thing versus like actually doing for treasure so there is a so you can provide advice to the solver as a consumer as a user of it so you know you have a very abstract problem so as you discover it you can do mixes of the technique so in specific cases like in d5 for example you can say symbolically execute this but when you see this condition do that and it shortcuts a lot of the effort it's effectively like if the solver has this many heuristics you add a couple more yourself and this is called concolic execution do you have time for one more i can see quite clearly how this lends itself to the study of one single contract but what do you guys do when or have you thought about how to go across contract calls with this technique you do not symbolically execute the cross-contract call the the external address is always concrete you could but you know there's state so the problem here is that there's state blow up because if reality splits every time you can imagine that like if you give an arbitrary address with an arbitrary function selector you immediately are in like infinite future realities so all right oh i see a hand yeah hi uh thanks is there any way to like protect from this um if you are like yeah i don't know i mean what are you protecting from i mean design applications with that expose let's maybe is it like if i submit like a like a long tail alpha like strategy like will you guys just like uh immediately extract that or um in principle i don't know thanks it's okay to say i don't know i hope i had a question uh does this work with only static opportunities where you're like just there's a contract that's vulnerable to some kind of interaction that will waste money and uh if you want to do islamic arbitrage it's harder to find no i think you can do it for arbitrage yeah you can say what does that i mean you could do it for arbiters but there is no point because you do you run a closed you run a closed form algorithm for arbitrage like again it's a very structured problem arbitrage which benefits a lot from like white box approaches so you know like i think that you have you're an engineer you have a toolkit right like code is a is a tool so for specific use case you have specific tools and in this use case if you're going for the long tail which seems to be getting more popular as searchers are getting like out competed by the few overlords of mev so maybe the thesis would be that this gets more popular as more people get squeezed out right thank you all great questions [Music] you 