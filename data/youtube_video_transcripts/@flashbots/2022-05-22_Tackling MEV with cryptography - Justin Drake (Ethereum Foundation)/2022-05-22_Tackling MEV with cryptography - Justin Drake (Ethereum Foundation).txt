[Music] great so tackling mev with cryptography i'm very optimistic that we're going to lean towards the utopia rather than dystopia so two part talk uh the first part is going to focus on um consensus mev basically muv leaks that stem from inefficiencies of the consensus layer and then also talk about uh how transaction encryption can really help potentially with uh application uh layer mav okay so uh for consensus mev a few months ago i just realized it's all mev and it always has been and i've kind of put on my mev goggles and i kind of want to give you the tools to to see how a lot of the problems we have in consensus are actually just me problems so um one of the things that we we're working on is a secret single leader election and the problem with public proposers when you do public elections is that you um you can do ddosing so you have these two slots and they both have mev one units of mmv and another union term having me and if you're the proposer in slot two and you're an attacker you can go uh ddos the proposal at one if that proposes ip address is public which it currently is on the beacon chain which is bad um and then basically the attacker can get twice as much mev so you know i'm expecting roughly a thousand dollars worth of mev at every single block post merge and so if you can do like a one dollar denial of service attack on the proposal before you you make a you know a thousand times your money and i expect some people to uh some extractors to try and do that and you can try and even do that with with with several slots in advance and make you even basically steal even more uh mev so that's dos based uh mev and then another component of a single lead secret single leader election is this the single and i just want to explain why this is important in the context of maybe because imagine that you have um two proposers proposer one and proposer two that kind of have this precedence list so proposer one has presence of a proposal two et cetera so if proposal one doesn't propose a block then proposer two can can come in well this is problematic because let's assume that the same person an attacker controls both proposal one and proposer two and this is how the attack goes proposer two publishes a block you know at uh at the expected time well enough in advance for audio testers to be able to see the to see the block but then a few seconds later proposer one publishes another block this time with more mev but with a but because it was published kind of late uh it's possible that the pro the attesters won't see it on time um and uh therefore it might not make it unchained but in the case where it does make it on chain then basically the the attacker has these few seconds of edge um to get to extract more movie because the the more you the more time you have um then the more transactions come in and you can have blocks with with more image so that's called a time buying attack uh where you buy a few seconds worth so you know chains like like dfinity and um it's kind of got it wrong at least in hindsight in my opinion okay so secretly the election how does it work because i did have the word cryptography in the title so very very briefly we have these these trackers which are basically ways for validators to have a commitment on chain and this commitment to get shuffled around in such a way that they can track the commitment but no one else can track the commitment and then we use these commitments to select uh the the next proposal so we have this this stirring function where we can uh every uh proposer can kind of stir and add some some entropy um and then we do a bunch of stairs and if one of the stairs is kind of honest um then we have um we have you know plenty of entropy um and uh you see the the the blue block here is is basically the the commitment of the the validator and you have this the validator one can track his commitment over time and the way that this is implemented concretely is you have um basically a pair of points uh this is an elliptic curve point uh the generator and basically you have the secret which is embedded and then you just multiply uh the tracker with some with a random scalar and that's how you add in the entropy okay that's most of the cryptography for this talk um okay so what about randomness how does mev come into play with um with randomness so the way that we have we do randomness today is with randolph the way it works is that we have an epoch which is made of 32 slots slot 0 to slot 31 and at each slot the proposer is invited to reveal a secret they've committed to at the time of registration um so this kind of secret zero all the way up to secret 31 and because they have the option to basically they can not reveal so it could be kind of the the empty reveal the empty dmt set there so everyone um every proposer either reveals or does not reveal their secret you hash everything and then you get the randomness for the for the next epochs to sample the the the next uh proposes but the problem here is that the very last uh proposer can either um basically can choose between two two um random outputs randall outputs it cannot you can have a reveal and get the green output or not reveal and get the blue output and this is bad because it means that they could choose um which random number they want which gives them the most mev now how can changing the the randomness give you more mev well one reason is that you know you just might have more validator slots you know if you choose green as opposed to blue it's possible that you haven't the knowledge for example that there's going to be um you know an nft airdrop at a specific slot uh which is going to be extremely valuable from an mep standpoint and it might be that the blue randomness will give you access to this really valuable slot or it could or it could be for example that one of the randomness will give you access to these these latest slots in an epoch because basically the latest locks are more valuable than the the prior slots because they give you more control over the randomness so you can use control over randomness to get even more control over randomness um and the way that we solve this oh and but yeah one thing to mention here is that um it's not necessarily the last uh proposer who just voluntarily chooses to not reveal because he's malicious but the it could be that the the last proposer is honest and intends to reveal but is being ddosed by the um by someone else who who likes the randomness at this point in time so basically by an attacker who likes the blue randomness um and so here this is a kind of a good example where mev is the systemic issue is not very well contained you have different mev leaks which interact with each other in very subtle ways and kind of compound on each other in some cases okay so we have this this delay function and the idea of the delay function is that it's a function which takes time to compute and we're actually going to use the the output of the delay function as the source of randomness not the input and the reason is that by the time the output is is made public is known to the world it was too late for these validators these proposers to reveal or not reveal okay another uh uh problem with layer one mev is chain re-orgs so this is very simple um you know we have some mev s.1 represented by the the cache icon here and the guy the the proposer at slot 2 says you know i want this mav for myself what i'm going to try and do is build on the parent kind of rewriting history and this is called a time-banded attack right now one um one of the things that we want to do on the beacon chain is completely remove time-banded attacks um from from from the equation and here's kind of how we'll get that so the idea is to use a bls aggregation so what we have today is a per epoch finality so we have you know hundreds of thousands of validators we have so many validators that we kind of split them up into in you know across the whole epoch from slot 0 to 31 so we have roughly right now 11 000 validators per slot and each validator will make an attestation or make a vote um you know for for for the for the block uh in in the slot um and the question that we can ask ourselves and basically once we once we've reached the end of the epoch everyone's had an opportunity to vote and everyone having the opportunity to vote is what allows finality so we need at least two thirds of the validators to to be doing these attestations to get finality now the question we can ask ourselves is what can we get a per slot finality also known as single slot finality and what we would need to do that is basically um have all validators um sign at the same time and kind of aggregate them all at the same time and the the the power of um aggregateable bls signatures is that it you can take hundreds of thousands of signatures you can aggregate them all very very quickly and the cost of verifying them on chain is is very is fairly small and we actually believe that we can get to this single slot finality point where we just completely remove time-banded attacks like small detail here there's actually two slots right so in order to get finality there's these two steps step number one is justification second step is finality so kind of under the hood there's there's two kind of beacon chain slots beacon slots but these would correspond to only one evm slot so only one state transition change at the evm level okay what is another source of um mev that comes from layer one and basically it's the fact that the layer one is is not scaling and so there's a lot of overflow which means that there's kind of this demand for these um these other layer ones and then you you need to build bridges and these bridges kind of inherently uh bring a lot of friction and and mev so what are some of the kind of the the constraints uh fundamental limits of of bridging with between layer one and there and layer one is you don't have this nice synchrony so you don't have the same slot durations the same slot boundaries the same settlement times you know like this nice atomicity but the other problem is that you don't have shared security um and so you know you have different social governance you have independent 51 attack vectors and there's some things that are fundamental you fundamentally can't do like data availability sampling you can't have one layer one and do data available sampling on another layer one um and all of these inefficiencies kind of lead to cross layer 1 mev and so the question is can we remove cross layer 1 mmv and my thesis that yes we can remove it and the way that we remove it is with rollups and shared security so the idea of shared security is that you have this very large layer one data availability and then on on top of it you just put a bunch of roll ups and in order to achieve this um this dream of security you have to do quite a bit of work cryptographically you have to look at polynomial commitments snarks and all so um here the way that the the what we want is not just shared security but we want this this really scalable shared security and here again this is kind of my um my um my my my belief that we're basically going to go from um the current tps of of of of well the current situation of 10 tps to 10 uh 10 million to tps and the the way that we get there is that we have three 100x opportunities to scale you know largely with um to a large extent with thanks to cryptography so we have roll ups which give us 100x sharding gives us another 100x and nielsen's law which is basically just most law for bandwidth uh which gives us another 100x okay i only have four minutes left and i i really do want to talk about this this second part um because it might be more relevant for for those who are not so much interested in the layer one so here my thesis is that um to a very large degree we can mitigate application layer mav with encryption and you know in in the history of cryptography it kind of it kind of started with encryption and for a long time blockchains have ignored encryption now we've been using hashing we've been using new signatures we've been using zero knowledge proofs and all sorts of stuff but we have kind of ignored encryption and i think it's going to be the big return of encryption so the the the the thesis that i have is that um in the in the medium-term future most transactions are going to go through this this this like this life cycle so transactions will be encrypted off chain and then on chain they will be included decrypted and executed and by having these transactions be encrypted prior to inclusion on-chain will make it basically hard very hard or impossible to front-run because the front-runner does not have the information that they need to do the front running but one of the key problems here is is the decryption step that is the kind of the most complicated one and specifically what we need is we need some sort of some form of guaranteed decryption we somehow need the decryption to auto magically decrypt itself once it's been included on chain and you can't have commit reveal because that gives you like a free option and so what are the forms of of of guaranteed decryption that exists in cryptography so one is threshold decryption where you're basically trusting a committee to do the decryption of the transactions there's this other thing called you know delay decryption where fancy cryptography allows you to um to automatically decrypt uh transactions after let's say you know 10 seconds or a minute and then there's the the most powerful tool of all which is called kind of witness decryption where you provide some sort of cryptographic proof it can be any proof any snark and that will allow you to to to decrypt your transaction um and one of the the exciting things here is that from a user experience standpoint all of this encryption stuff won't change at least in theory it could not change um the user experience everything could be done in a single evm slot and so this is how i kind of see the the the end game um of of at the consensus layer in terms of infrastructure that could be provided so there's this this single evm slot which is kind of what we're used to today and then kind of behind the scenes there's stuff happening with multiple beacon beacon slots and basically we can we can shove a lot of ideas that that that help with mev we can shove proposal builder separation so that there's these two stages where we have proposer blocks and builder blocks and we also have here the two stages of finality so we first we finalize proposal blocks then we finalize builder blocks all of that takes four slots and then in this final beacon slot we have auto magic decryption for example with witness decryption triggered by the finality of the builder block and we execute and from the from from a ux standpoint you don't realize that there's multiple blocks or additional latency now there's a lot of devil into the detail to actually pulling that off uh one of the complications is that you need to encrypt the metadata um you also need to you know potentially do other things and here you need to bring in the big guns like like homomorphic encryption or fully homomorphic encryption i don't have time today but there is a one hour and a half talk where i go into the details on youtube that's it thank you [Applause] [Music] you 