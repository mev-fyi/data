great all right um so i'll give a short introduction of a view justin uh before we before we get started uh so justin is a researcher at the ethereum foundation um we had interacted um a while um for for a while already before but we met quite recently in in palo alto in the end of january um and justin then gave a great presentation on mev and cryptography together and outline a lot of amazing topics and so i thought it would be really cool to one record it because it was not recorded and two to have that presentation with all of you at the theme foundation um justin has been there for the last three or four years i'm not mistaken justin and has um worked on like a wide variety of topics including applied cryptography which is why it's awesome to get his insight because he's also been working in the last year arguably since he's joined the ethereum foundation on mev as well and so having those two things together is super interesting and i think to us is very relevant um justin is there anything you'd like to add before you get started no no this is great all right yep awesome people will trigger a little bit more but i think we should get started because we only have an hour um and yeah okay fantastic thank you alex um so i bought this whiteboard today i'm not sure how i was gonna work but let's see so basically like the talk that i gave um you know a few weeks ago was split into two parts one is um you know looking at the intersection of mev and cryptography at the consensus layer and this is kind of the nature that i focus the most in the context of ethereum and then kind of the second part is kind of this this thesis that i have that um at the application layer we're gonna see uh encryption as as playing a very a very important role um like in consensus we we don't really have encryption you know we have hashes we have signatures we have zero knowledge proofs all sorts of stuff but but no encryption and so um you know it's kind of interesting because in a way cryptography was was started with encryption and so we're kind of going back to it to its roots um now one of the reasons why i want to talk about consensus is because um one of the things that's that's happened to me is that um i've tried to to rephrase everything in the language of muv uh because i think that's uh kind of uh this this this new kind of hidden force which is now no longer so hidden which is really affecting the way we we think within the film foundation um and so here i've listed kind of uh five pieces of of of cryptography that interact with mev at the consensus layer so we have we have ssle so the that stands for single secret leader election and the idea here is that um when we sample a a proposer in in the future um we want only that proposal to know that they're a proposer we don't want the the whole world to to know uh so that's where the the the secret comes in um and and this is important because if you're a home validator and you don't have like a really sophisticated networking setup then it's actually fairly easy if not extremely easy to to diagonalize your your ip address meaning that we can map validator identities which are validated pub keys to your ip address we know which validators will be publishing blocks in in the future and then we can just go go ddos them and the reason why this this interacts with mev is because if you have if you have two slots um so you have slot 1 which is 12 seconds in the beacon chain and then you have you have stop 2 which is also 12 seconds and they're next to each other and the attacker controls this slot slot 2. then there's actually a very easy way for the attacker to effectively double the mev how do they do it they can ddos the proposer at in stop one so this is going to be an empty slot and so the at the end of the day they're gonna end up with a slot which is twice the length which is 24 seconds and um you know eip1559 kind of gives you this this dynamic block size which means that you know mev in in in in these two blocks for interior in these two slots should be able to fit in in in this down here um and actually you can you can extend this attack to three slots so if there's a slot zero here which is on the left of slot one then you can just d does that and now you have three slots worth of mev and so previously the way that we used to think about um the the security of of blockchains is in the context of like purely honest or purely malicious actors um and we would try to reason and say okay well the beacon chain has you know sufficient liveness and sufficient security let's say less than half of the validators and malicious but here you know we have this kind of this this more subtle thing going on where we need to take into account you know rational validators and and and even even though they're not kind of outright breaking the the safety and likeness of the beacon chain that they're doing bad things here because they're you know disrupting the beacon chain and and also kind of griefing other validators now one one interesting uh thing to to to note um is that the this the single the very first s is also important in the context of mev and the reason is that let's let's imagine that um there's so can can i erase this was it was it was it clear okay can you can you guys see is it yes you can see and it's clear i have i have a question for you though go ahead would you prefer questions at the end of the presentation or throughout or no throughout is perfect okay great and are you are you able to see when we raise hands on google me would you rather we just shout um you can you can shout or roll racehand whatever you prefer okay cool uh please also feel free to not answer a question if uh you know to make sure you get to the end of your presentation but yeah sure okay so i'll go ahead and erase that um so the the single being relevant in the context of mev is something we discovered only very recently but basically you have your slot here um and let's say that there could be some sort of fallback mechanism like some blockchains like dfinity for example or algorand you can have multiple proposals and the idea is that if kind of proposer kind of number one doesn't show up that kind of there's someone else who is who's invited um and and there's kind of a a list there's a precedence list so you know one validator might have precedence over another validator now let's say that an attacker controls two proposes um what they can do is they can submit two proposals but they're not gonna submit them at the same time they're gonna submit the first one kind of let's say halfway through the slot when they're supposed to to do and then they're going to submit the second one which will take precedence over the first one a little bit later now there's there's kind of two scenarios scenario number one is that this block was published so late um that you know most attesters don't get to see it and what that means is that the the block kind of gets gets discarded so there's no change here but there is a small probability a non-zero probability um that this block will actually be seen in time by sufficiently many validators by testers and that this proposal will not make it on chain and so what we've seen what we have basically is um in that in that scenario the the attacker is able to get you know a little bit more of mev because they they've conducted what we call a time buying attack they've managed to buy let's say you know two seconds worth of time and so during these two seconds they've been able to to receive more transactions and therefore create a block with with more md and so it's kind of lucky that you know we chose the the single leader per per slot uh for for the beacon chain and in hindsight of other blockchains kind of got got down wrong okay great so the other place where cryptography comes in and it intersects with mev is is vdfs so just a a real you know quick quick recap we have basically a commit reveal scheme for for randomness that you know if you all know this please please tell me and then i can skip but basically you have 32 slots these slots form an an epoch and during each epoch the proposer is invited to reveal a secret that they've committed to and then you you take all these secrets that are revealed you know s1 up to s s 32 some of them might be missing because they didn't reveal they didn't create a block and then you just hash all of these secrets and that's going to generate randomness for for for future epochs we're going to generate randomness r for future epochs and the problem here is that if you're the very last um proposer here then you actually have the option do i reveal s32 or do i not reveal s32 and that's going to influence the the future um and so one of the things that that we do here basically is that we we introduce vdfs which gives us a time delay so that um the the value r is only known way way way after the decision to reveal on reveal s32 is based so if you if you wanted to bias the randomness you you you can't meaningfully do that because any action that you take here you will only know its consequences well after your your slot where where you can take the action and so basically that that that removes uh the the bias but right now the beacon chain doesn't have vdfs it does and it doesn't have ssle and so um you know what the attacker can do is bias the randomness in such a way that they have more more slots in the future so um you know they it's possible for example that um if they were to reveal they they get zero slots in the next epoch but if they don't reveal they they get two and so that that's to their advantage they may also want to try and buy the randomness so that they get um more profitable slots so for example they might know that at some point in the future there's kind of an nft auction starting at a very specific slot and so they might want to to bias the randomness in such a way that they will they will be the proposer for that slot or type you know as you can see here like these these the the last few slots in an epoch are more valuable than the first few slots and so they might buy the randomness in order to get more final slots in order to bias the randomness even more um it's kind of interesting where there's kind of an interplay here between vdfs makes doing the these two attacks where um a an attacker could could could ddos um the last few proposers if if he's happy with the randomness so far okay great so basically what we what we're trying to do here is is is hardened the protocol in such a way that we have these these well defined and segregated modules where all the incentives are kind of very well understood and so here you know we're we have this this randomness module it's super super super hard and there's no like where dependency with with other parts of the protocol once we have the the the vdfs so we've addressed dos-based mev randomness bias-based mev another form of mev that we have on the beacon chain is re-org-based mev and so what we've what we've done here is basically use bls signatures which allow us to have many many votes in parallel so if you look at bitcoin for example it's an extremely slow kind of voting process you have one vote every 10 minutes and you know in order to get a reasonable notion of finality you know people say that you have to to wait the six blocks basically six six confirmations and we with bls the idea here is that let's try and get as many validators to vote in parallel as opposed to voting sequentially um but the problem here is that if you get many many validators working in parallel that's many many signatures that you want to try and verify and just to give you kind of an order of magnitude um i believe that ethereum right now is verifying something like 800 signatures every single every second and if and so what bls gives us is this idea that we can take all these signatures aggregate them and only verify a a tiny one and so what that means is that we have we have almost no reals and the reason is that we have this extremely fast uh con confirmation mechanism and we actually want to to push that to the next level uh something that we call single slot finality the idea of single slot finality is that you know as the name suggests for every single slot you get finality and so there's there's there's no possible reorgs even of of of depth one and so again this kind of simplifies the problem of mvv right because now you've removed for example multi-block i mean um you know mev and so we're in a position where we can we can analyze things on on a slot by slot basis the challenge here is that we need to potentially be aggregating hundreds of thousands of of signatures in a single in a single slot and so there's kind of a engineering challenges to just doing all of that work um off chain in a very small amount of time question question can you elaborate on i don't know if this gets too technical but why is it that a signature aggregation is possible with vls signature as opposed to the current scheme right so the the reason is basically that we're working with electric curves with with pairings and the pairing is an additional algebraic structure which um which means that you know we can construct signatures which which have more algebraic structures with them and the way that it it works actually the aggregation is super super simple it's just um point point addition so if you have two signatures the way that you aggregate them is by adding them and if you have two pup keys the way that you get the aggregated pup key is by by adding them um if you take for example two schnauz languages or whatever you don't have this this this nice additive property because you're doing all sorts of other things you know you're taking you're taking hashes you're getting randomness it's an interactive protocol blah blah blah um whereas with with bls signatures um you know you you're just taking these these these points and and doing almost nothing to them and so you can have this this additive property to them amazing thanks okay great so we've addressed dos based mev you know that should completely go away with ssle randomness buyers should completely go away real base mev should completely go away and then this is other thing cross domain mev you know that might be a little bit of a stretch but i'm basically arguing here that all the scalability effort that we're doing on ethereum you know could be seen as a way to to to reduce cross-domain med and the reason is that we want to try and build a domain which is large enough for the whole world and the back of the envelope calculation is you know we will get to a point where we're doing 10 million transactions a second and that's enough for the whole world um and you know part of the reason why we'll get those you know right now let's say we're doing 10 transactions in the second um roll ups will give us uh you know 100x and then shouting will give us another 100x and then if you if you look at basically the the the the the computational bottlenecks in in scaling there's several of them you know there's things like compute storage disk io bandwidth and it turns out that the the only fundamental limit to to scaling blockchains is is bandwidth everything else you know you can we can have like very fancy cryptographic magic to solve it so for example compute right we can have a snark where the the validators they only need to verify this knock and so compute doesn't doesn't really become a bottleneck for for the chain and then you know for for state and for disk io you can do things like statelessness where again you know the validators they don't have to to store anything and they don't have to do any disk io because whenever they read and write to state they're given the the the merkle paths you know of on on the wire you know from from from there from the internet and so they don't need to go fetch that from desk and it's actually you know cheap cheaper to to go ahead and do that um and so here are you know i've added data availability sampling and proof of custody which involved you know semi-fancy um cryptography but wait what why are you saying that why are you saying that uh bandwidth so i know like how how you can like yeah with cryptography sort of reduce your requirements on state and compute but why are you saying that you cannot do the same for bandwidth eventually with some new cryptography or whatever why is it fundamental um good question so i mean i don't have like an impossibility proof but uh kind of in like in in intuitively like um you know we need to come to consensus on on on on data and you know the the the data can be just like random noise you know very high entropy you know way way there's no kind of cryptographic compression that that you can do um and if you try if you try and do data availability off chain well suddenly you know you lose the shared security with the rest of the system and so in order to do to have shared security data availability you really need the validators to go ahead and actually download the data you know there's just no way around it like someone some subset of validators needs to go download the data and you know one trick that you can do is you can say oh well we don't need everyone to go download all the data instead we can just have committees download the data but that's that's shouting and so that's kind of the limit of the state of the art is like we we ask people a small set of validators to go actually down download the data um [Music] um i hope do you have a follow-up question can i ask you no that makes sense yeah go ahead uh why does this uh uh solve a cross domain name i didn't follow is it just because the domain is big enough that there's no cross domain yeah all right thank you i mean there will be other forms of domains you know within ethereum potentially exactly you know like roll-ups and whatnot but you you've mitigated the problem in the sense that you've you removed a little bit of friction of you know having to deal cross chain for example um and having to deal with you know different security domains having to deal with different block times and all sorts of complications thank you and then kind of a final piece of of crypto is just commit reveal which we're using in the context of of of pbs and i guess you guys are very familiar with with this um and it's it's it's interesting because it kind of ties in a little bit with what we're trying to do here right so the the idea of using encryption here um is that you know you basically prevent front running um and mev stealing and this is what pbs is all about it's about preventing uh any v stealing um but um the the the problem is that here we want to try and work at the you know very low granularity we're going to be working at the transaction granularity or the bundle granularity and it turns out that climate reveal doesn't really work very well at locally like it has to be high granularity and the reason is that you're kind of doing you're doing a couple of things one is that you you need to have some sort of incentive mechanism sort of collateral to to punish whenever someone doesn't reveal um unless this becomes especially problematic when you have these these kind of free options um that that could be worth much more than than than the collateral um well options that are worth more than the collateral because you know some some people reveal and then you know your decision to reveal is based on what other people do but then the the other a big problem with pbs is that you need sort of data availability oracle you need a way for the chain to know whether or not the information has been revealed and this goes back to the bls thing where the way that the only way that we know how to do data available the oracles is for to ask a committee to go ahead try and download the data and vote on the fact as to whether or not this data is available and the bls aggregation only works if everyone is voting for the same thing um if if it's if it's a different signing of a different message then suddenly the bls aggregation is it is broken um and so uh you know we we don't have basically the data availability oracle is very low bandwidth and you can't go vote for it like high granularity things like transactions so if you want to prevent uh kind of front running and and um stealing then you need some some form of of encryption at the application here um and you know as i mentioned kind of my thesis is that we're going to move move to world with more and more uh encryption and you know these encrypted uh mempools and kind of one one of one of the reason is that from from from a user standpoint you want to know that your transaction has been has been published has been has has been gossiped so that you have of high guarantees that it will be included in the next block if it pays sufficient fees you know if you if you go ahead and give your transaction to a a trusted third party who said okay i'm going to try and include your transaction in one on one of your blocks well you don't have this kind of this nice ux guarantee of of fast on chain inclusion another problem of you know having to trust a third party is that you know they may they may front run you you there's a trust assumption here's um and so that's that that's not ideal and then kind of a third problem is that if you if you're sending your transactions to a trusted third party well you you're potentially you know what creating creating centralization and the reason is that if if you have one party who has this privileged access to lots and lots of all the flow you know such as flash bots potentially um then they they could potentially win every single pbs auction and so you you're in a position where you you have a very very centralized builder because they have this this privileged order flow and they win every single auction so really you know just for the health of the of of the ecosystem we also want to push for for the for encryption um what sorry one question there like perhaps stepping back a little if i if i understood correctly you're saying you cannot do encryption at the transaction level but you would have enough bandwidth to do uh encryption at the block level so you could personally do some commit reveal at the block level right and the question is like why is that not enough is that like a ux thing that you don't wanna if you say you encrypted everything and it will be like one block reveal is that a ux thing that you want to have people wait for one block until they know what happened or or is it something that i'm missing so um so what the problem that we're trying to solve here is just the the whole process of of of building a building a block or you know sequencing the the the transaction and my claim is that we can't use commit reveal for individual individual transaction and the reason is because otherwise you need to have kind of a data availability oracle you need to know for very high granularity which transactions that were that were committed have actually been uh you know revealed yeah sorry i get that my question is why would uh commit reveal at a block level not being enough i would guess oh it is it is enough it is commit reveal at the block level that's that's all pbs is doing there's no there's no encryption here uh [Music] so so why can't you encrypt uh okay um then i i'm not getting why like why is that okay so basically the problem is is before you have the block like in at the memphis transit or from the user standpoint you know i'm i i have my ledger wallet of my meta watch wallet i cr i create a transaction what do i do with it you know what we're doing today is we just broadcast it publicly and you get sandwiched um and so what you want to do is you you don't want to get sandwiched and so what you know option one is to give your transaction to flash block protect but then flash block has they can rug you because they confront from you potentially because you have to trust them um they there's a problem of of centralization because now flashback protect might be in a position where they win every single auction and then the third problem is that you know it's possible that the next block will be created by you know the eden network uh and it won't include flashback transactions and so if you have published your transaction publicly then you have better guarantees about on training fusion yeah you know i get it now thanks yeah justin i have a um a question on your your concern around order flow to me it feels like if you have encryption of transactions the order for problem is still very much there uh it would just be at the source so say i'm a wallet say there's like encryption in the whole network but i'm a wallet and for every transaction that user submits i'm going to add my little like backgrounding transaction after it and submit that as an encrypted payload to the network so there's still order flow there right right so basically what i'm assuming is that um the process of creating a transaction will be done locally on your computer without necessarily needing a service provider so you know if you take for example i don't know uni swap like you you sign a unit of transaction uni swap has no knowledge of what transaction you're creating because you have you've downloaded all the information required to locally make make a decision as to what your transaction will be but you you you're right like if you go through an exchange for example the exchange can you know gossip an encrypted transaction on your behalf but they they also know what the plaintext is because they actually crafted the transaction on your behalf what if what if more than that there's like an incentive where like unit swap tells users hey if you can submit your transaction without anything or you can like click like an opt-in to a system or like you'll pay a lower fee because like we'll background you if you like allow us to do that i mean like even themselves or such that like as economically rational actor you might want to do something with your order flow right um so i guess a couple of thoughts here like the first one is if you use a service that kind of refunds your dmv that actually not too bad right because you haven't leaked so much value um and then the other thought is that i think we're gonna see tools that you know empower individuals that make them sovereign individuals and where the tool will basically try and and create transactions that are close to optimal and so you know one one possible example is you know you could have a a browser-based uh you know aggregator like one inch or matcha you know it takes the top three dexes you know uni-swap sushi swap and whatever curve and then based on the liquidity there it just does a small calculation in your browser and then creates a transaction so you don't really need to to use a a service provider um thank you okay great so let's let's assume that uh the you know this thesis is correct um and we want uh encryption well one of the things we want which you know climate reveal doesn't provide is this our idea of guaranteed decryption or guaranteed output delivery um and there's basically three flavors that i know of of encryption with guaranteed decryption one is um threshold decryption where basically a committee can can force decryption of a cypher text delay the decryption i mean it's actually called delay encryption but like you know it might make more sense to call it delay decryption because the act you know of decryption can only happen once delay has happened and then there's something so this is by delay i mean you know sequential computation very similar to vdf and then this witnessed encryption or maybe better called witness description where in order to decrypt a message you need to provide a a witness um basically proving that some statement is true and this could be any statement and and that you know you can think of it as basically um it will decrypt the message if if some some if you give it some snark basically a short proof that some statement is valid um and so one one of the things you can do for example with witness decryption is that you can build a hybrid of threshold decryption and delay encryption um so the problem one of the problems with with threshold decryption is that you kind of need to trust the committee to not decrypt too early um and so what if instead we had um we kind of had the n n out of n uh committee where the only way where you could have this this early decryption is where every single committee member is is dishonest you know if you have even one single honest community member then then you can't have this this early decryption and this this this mav front running but the problem with this kind of and out of m committee is that you have very bad likeness right you just need one single you know committee member to be offline and you get no decryption whatsoever and so you know the statement that you could use in the witness decryption could be kind of an or statement either the committee kind of um all came together and and agreed on the decryption or kind of as a fallback mechanism if at least one of them is offline then you have the the delay so the problem with the delay is that it introduces latency you know it might introduce a few a few seconds of latency and so basically you kind of have this this whole peacetime wartime mechanism where in the in the default um scenario you kind of have like this optimal user experience where you know you can kind of get instant confirmations of things um and and you you have a very very weak trust assumption you have what's called an honest minority assumption you just need to trust that one entity in your committee is honest and then um if if that doesn't if for some reason um you know one of them is is offline then you have a fallback mechanism and you have to wait a few seconds you know it's a little bit reminiscent to the the arbitrary design uh that was released uh i think yesterday um you know for roll-ups and and and they have this for this validium or they fall back to your roll-up when when the community loses liveness but but can you call like arbitrary functions in the witness could you say like and yes and out of n but less like minus one per second or something so that like after n seconds it's automatically with one validator surprises something like that yeah you can have other trade statements um and like one of the use cases for example of witness encryption is um you could have two blockchain so in the context of cross domain mev um you know you might want a message to be decrypted if two blockchains are both have both finalized and then you know you do some sort of atomic you know swap or whatever um and the statement could be you know blockchain a has finalized and blockchain b has finalized um i'm curious how how the how the delay conditions enter the the witness so my understanding was weakness it's like you have to solve an mp complete problem right and you so you encode it you encrypt to uh one instance of the problem uh so how does the time play apparently like the the threshold how it could relate to that because you could just distribute the like the statement in bits and pieces in all the uh committee members but how does the delay get encoded in in in a witness that's that makes sense right right um so you know what what happens in what's going to happen in practice for for witness encryption is that it's not going to be verifying an arbitrary statement is actually going to be verifying a snark for that statement like it's going to be you know you're going to compress the statements as as much as possible and so in the context of of of threshold uh you you know threshold encrypted what you could do for example the statement could be i know n out of n or k out of n signatures and i'm going to make a snark out of that and that's going to be able to decrypt my thing now for delay encryption what you can do is you can use a vdf so you you do the sequential computation and that's a very expensive thing and then at the end of your computation you have a short proof and then you take that short proof and you you wrap it into a snark and you make it even shorter and then you feed it to your to your ciphertext and that and it will automatically decrypt nicely thanks and then if you want you know your statement to be like ands and ors and complicated things then you do the same thing you just have a snark which encapsulates this more complicated statement um and someone who wrote an if research post recently where they they use the witness encryption to build a trustless two-way bridge between bitcoin and ethereum we used to think that you need um io you know obfuscation which is a very very fancy primitive witness encryption is still very fancy but like nowhere near as fancy as obfuscation and there's actually an implementation of of of witness encryption with you know potentially you know very large performance penalties and also potentially you know shaky assumptions like cryptographic assumptions that may be maybe broken but my my my my best guess is that in 10 20 years you know we will all be using witness witness encryption and that's you can kind of think of it as as the pinnacle of guaranteed decryption like any form of grantee decryption will you know can be implemented with this encryption like these are special cases of of this thanks okay great so we have we have this this this idea where we want to we want to somehow encrypt the the the transactions as a user these encrypted transactions they just get packed in a block and you don't have front running because you don't know what the content of the transactions is and then you have some sort of process of you know automatically decrypting the content uh and then you know executing it on the transactions on the blockchain but there's there's like a bunch of complications that that kind of arise from this high level idea and one one problem is what about all the metadata like the metadata could could leak you know information that's one problem and another problem is that the metadata could be useful for things like anti-spam where you kind of need the metadata in order to to protect yourself against against spam so let's look at four pieces of metadata that i've highlighted here like the first one is the ip address of the the the sender and so here i'm kind of assuming that people are using um you know services like tor that will shield their ip address another really important piece of of metadata is the the sender and and the nonce and so the reason why we we need this is because we at the peer-to-peer network level we we need to know whether or not the transaction is valid and in particular we need to know whether the sender has enough balance to cover the the gas costs and so you know the naive solution is saying oh well you know we just reveal the sender and the dancing the clear but hold on like the sender is like a really critical piece of information that you don't want to to reveal and so it turns out that's a very easy trick which is that you use a you know you use zk snarks you need zero knowledge and basically what you do is you prove in zero knowledge that you have that the the encrypt the sender which is encrypted and the nonce which is encrypted has enough balance and the way that you do that is you you you refer to a a state route in in the past and you provide a merkle path that you know from from this the sender's uh you know balance to the route and you prove that the the balance is is is at least that's you know some minimum in order to even like start interpreting the transaction let's say 21 enough to pay for 21 000 000 gas and but that doesn't quite solve the problem and the reason is that you know what if you you create many transactions for the exact same sender and and not so what you need to do is you need to provide in the clear as a public input kind of the the hash of the sender the nonce and the private key now the reason why you introduce the private key is because it's something that only the sender knows so um and and and and the reason why you include the the sender and the non-sender address and the not is so that if you were to create two transactions with the exact same nonce and the exact same sender then that that piece of public information um you know some sort of hash would would collide and so you'd know that you're you're under a spam attack and you can just drop drop the connection to whoever spamming you okay great another kind of um interesting piece of metadata is the gas limit so kind of naively you'd think that you know the gas limit needs to be in the clear um but there's actually a small a small change to the evm which means that we can we can just simply encrypt the the gas limit and the the the reason is that you what one thing that you need to guarantee is that if a transaction gets included on chain the the sender has to pay something right it has to pay the minimum let's say to to just deserialize the transaction check that there's enough balance and and and just do you know check the signature and do like the routine basics so that will cost 21 000 guests and so you you want to have a rule which says the transaction always the sender always has to pay this 21 000 gas and then there's kind of the normal execution of the transaction where you look at the gas limit and then you you say okay does the sender have have enough balance for the full guest limit if yes then you know run the transaction and then issue a refund at the end if no then immediately i bought and that's a failed transaction but it's not exactly a fair transaction in the sense that you know the sender has lost the 21 000 gas okay great and then there's this final piece of metadata which we need to take care of which was the the size of the transaction and one very easy thing that you can do here is just pad with zeros and then encrypt um so that every transaction has the same size or maybe you know you could pad to the closest power of two so that you have you know very reasonable um shielding here i mean one one piece of research that i'd like to do and i haven't done yet is to look at the the distribution of the the size of the transactions just to try and understand what kind of privacy do you get if you round to the closest power of two and how about bandwidth there would you like incur bandwidth cost by padding okay yeah that's a good great question so the the downside of padding is that you have to pay for more data availability and data ability is expensive right and so if you if you're rounding up to the closest power of two then you know potentially your transaction is twice as expensive than than than you need it to be which brings me to like three kind of more complicated problems that arise like these metadata stuff you know they they can be solved with just very basic cryptography or and paying paying a little bit more but there's there's kind of these more serious problems in a way that appear where we need heavier cryptography in order to solve them and this is where kind of the frontier lies from a research standpoint so one one of the things that you've identified is is just the added cost of paying for front-running you know protection ideally we don't want to pay this cost and so one of the things you want to do is what i call transaction clipping where you just clip away the the the padding and so there is a way to to to remove the the the padding um and it basically involves fully homomorphic encryption so you know you can have fully homomorphic encryption with all all three flavors so you can have threshold for the homomorphic encryption delay for the homophobic encryption witness for the homophobic encryption but the important thing is that you can operate on the ciphertext and you can do computation on these ciphertexts um this is a functionality that could be simulated with trusted hardware you know like sgx but you you know ideally you want to do it with with pure math and you know with sdx the idea here is that sgx receives encrypted transactions it decrypts them kind of within its its trusted enclave or whatever and now that it has them in the clear it can it can clip the the padding and then you know pack pack as densely as it can kind of a block with with no padding and encrypt that and then have some sort of mechanism threshold delay or witness to force force the decryption afterwards so the way that you use fully encrypted fully homomorphic encryption is just to have basically a a circuit which which takes as input the padded and encrypted transactions and as output it removes the padding that that's basically all it does um one of the things that's important is that the output is always fixed size and the reason is that if it's not fixed size then you can you can basically try multiple different inputs and depending on the size of the output kind of try and guess the side of the transaction kind of reverse engineer and so it needs to be fixed size and the way that you achieve that is if all your transactions don't fit within your fixed size then you just discard some of the transactions and if the fixed size is is larger than all the transactions that you have you just pad with zeros at the end okay great um any any questions so far okay great so an an even more extreme problem than transaction clipping is state stiffing and and this is something i'm very excited about in the context of zk roll ups so one of the in my opinion huge advantages of zk roll ups over optimistic roll-ups is that the trend the the data availability cost will be significantly lower on zk roll-ups versus optimistic roll-ups and the reason is that on an optimistic roll-up um you need to include the the as input the the transactions all the transaction data needs to go on chain because that's required for the dispute process to to to happen with the fork proofs but with zk roll ups you have this this trick up your sleeve where it suffices to put on chain the state diff so let me give you an example let's say that we have a thousand people that are all donating funds to the ukrainian donation address right and so they're all kind of incrementing the same address over and over again and so you you know option option one is to have you know ten thousand increments of let's say one each each or you can have like one single state diff which says you know for this for this whole block the the balance has increased by by 1000 if without having to detail all the intermediate kind of uh incremental steps and so in in in this case you kind of get like a it's an extreme example but you get kind of a 1000x compression of the of the data um and so you know it's hard to tell exactly how much how much cheaper it will be but you know it could might be two three four five x you know maybe even 10x in some cases uh cheaper to use a zk roller versus an optimistic roll-up and so the question then then the question then becomes how do we get this trustless front-running protection with encryption and the state diffing and the the only answer that i know is basically to to use fully homomorphic encryption but here it's much much worse than the transaction clipping because the transaction clipping is a very simple circuit it just looks at zeros and then packs things there's almost nothing happening it's a very shallow circuit and and with fully homomorphic encryption you basically pay for the depth of the circuit the second depth basically the the the number of gates in the in the longest path um and and here in order to do the state different you kind of need to run the evm within in the context of probably for your homomorphic encryption now we've only just started doing zk evm right zkvm might have a 1000x overhead or 10000x overhead over the the evm and for the homomorphic encryption kind of is even is even more expensive than than zk um you know by i don't know maybe a couple of orders of magnitude and so you know it will take it will take maybe 10 years in order for us to have you know fully homomorphic evm um but you know i think i think that is that is the the the end game but in in the meantime you know maybe in a couple years two three years we might be able to do the transaction clipping no problem uh that's a much much easier problem to to solve okay great so i mean a fully homophobic encryption can do these two things and another thing that it can do is basically the the the problem of of bundle selection so the way that i envision the end game of of of of block building is that there's kind of two parts to every single block there's the the the priority transactions at the top and those are kind of the mev-rich transactions like like arbitrage and whatnot and those will will consume a small portion of the gas let's say five percent and then there's going to be all the other transactions that don't really care they're not they're not not competitive transactions they're not competing with other transactions instead they they just want to be on chain and that will represent let's say 95 of the transactions now this this 95 is the is the easy part and the reason is because you have this flow of encryption transactions you can't distinguish them it just looks like random noise coming to you and so there's not there's not much you can do as someone who wants to try and extract an ev and maybe maybe the arbitrary model is going to be you know good enough in the sense that you just take first come first serve um and um and and you know call it a day and then and you do the decryption but unfortunately first come first serve doesn't work for the priority transactions and the reason is that now you're introducing a latency game um because there's this competitive aspect and so you're you're reintroducing centralization for this this top five percent of of of of gas usage and so um what i'm hoping we can do is is come up with a a way to do decentralized block building for these for these bundles and you know the the brute force way which i think we will be able to do in ten years or so is to to run fully homomorphic encryption in you know for for the edm but that's very expensive but it turns out there's a there's the shortcut which i think gives us you know most of the value and the shortcut involves looking at access lists so you can have a bundle which says i'm willing to pay x amount of if for accessing this part of the state now the access list is encrypted so no one can can can can can see them and no one can use that information to front run um and it's it's like perfectly granular it tells you exactly what it what it's reading and exactly what it's writing and the job of the the circuit that is going to select the bundles and pack them into a block is just to basically take the optimal bundle selection such that any two bundles have disjoint access lists so you're never in a position where you know you have two bundles of writing to the exact piece of state now this is this is a little bit limiting in in your way of in your ability to create optimal blocks and the reason is that it's possible you could have you know two bundles that both write the same thing and they're both valid but my intuition is that you can build blocks that are near optimal purely by looking at access lists and actually that's a question i have for you guys maybe an interesting research question is just looking back at all the historical data and seeing whether or not you can come up with a strategy which only looks at access lists and give us blocks that are optimal within i don't know one percent or something yeah i actually did some some data analysis on that so not coming up with a strategy but yes looking at clashes in a relay of different bundles and clashing like i look at clashing at different levels are they clashing at like using the same target transaction including the bundle or are they clashing more deeply in like i look at the traces and see so where they were like accessing and uh yeah that was like an old analysis it was a while back but yeah definitely i agree with you like i would expect what you're saying that uh not much uh would be lost if we could do that i was surprised that we were expecting more classes intuitively than what we have okay that's that's really good news um because the the circuit for doing kind of set comparison and making sure that these are disjoint sets is sounds very doable um i'm one oh sorry though um why why is fully more mormon morphic encryption so far away what needs to happen during those 10 years in your in your eyes and can any of it be accelerated i mean we have a strong incentive for this to happen sooner um is is it a like yeah what needs to happen i don't know if it's too technical or if we get into like very detailed stuff no no there's like a high level answer which is that we need a very similar kind of development to zero knowledge proofs so 30 years ago zero knowledge proofs were possible in theory but if you wanted to create one you know you'd like i don't know exactly if that's like a true representation but you need to spend you know on the order of all the energy in the universe in order to go create one because that's how inefficient it was um and then people just came up with these these huge optimizations like several orders of magnitude and you know every single year and now you know we're at the point where we've we we've squeezed out you know a ton and and things have become practical and we're starting to do hardware acceleration you know that's the kind of optimizations we're looking at and you know i i think um that that fully homophobic encryption is the same as zero knowledge proofs but just shifted by 10 years so 10 with just 10 years uh later than than zero knowledge proofs and there's this kind of most law for fully homophobic encryption um where roughly speaking fully homo encryption is being sped up by 10x every single year which is kind of insane um you know this has slowed down in like the last year or two but this trend has held true for for a long time one of the things that that darpa is doing is it it it spent something like i forget exactly but something like 15 million dollars to actually go build an asic to accelerate fully homomorphic encryption so that it can be uh practical so i think the hardware you know which will give us two or three orders of magnitude um acceleration plus like a few more kind of theoretical kind of mathematical tricks that have been happening for the last decade or so and then we'll be will be in a good position to to to use it um why why does starboard want to accelerate this like to back to it or like i think they they want to be able to like the way that you usually sell for homophobic encryption is like it's like the cloud like google cloud or whatever uh digital ocean or aws but you don't have to trust aws and so if you're running like mission critical like a military stuff then you want to do it well do you want to do secure computation where you offload the the you know the actual computation and then you get this result without having to trust anyone yeah but it seems like it would be them yielding power right uh that seemed contrary to most of their interests right because it empowers individual ultimately like if this is like an actor free technology this is ultimately yeah powerful it's like short-term thinking where you know like tour for example tor was invented by the us ministry as i understand the u.s government um and you know it gives them more power in the short term because as the military they don't have to go translate or us and whatnot but you're right in the long term it empowers individuals um we we are over time so if anyone has to leave please do i mean phil already has left he thanked you justin um i if could you could you stay a few more minutes justin would you have to go no i can stay i can stay no worries okay um does anyone have i have questions because i definitely have more questions but hello and i have been monopolizing that well i do have a question um i i didn't get like um why exactly would you need to to hide the metadata aha i see um like one one piece of metadata that you that i think is important to hide for example is the sender like let's say that the sender is just uh you know an nft enthusiast let's say it's dcinvestor.if and you know every time he makes a transaction he's probably buying an nft now if you combine the metadata that you know you're seeing a transaction from dc investor if it just happens to to match with a new nft kind of auction you know that's public information when the nfc auction happens then you can make an informed guess that dc investor is going to be buying nfcs in that auction and so what you can go and do is you can go front run him by just buying up nfts ahead of him and then making him pay a higher price for for his purchase okay so so it's just that okay i thought there's maybe more reasoning behind it okay um but the pro the complication is that if you if you do encrypt it because you know the naive solution just encrypt everything but then then you you have a problem where you can't guarantee the anti-spam property uh that ethereum today provides which is you just look at the sender address and the signature and that's enough to determine whether or not they have enough balance to pay for the transaction if they and if they don't then that's kind of a discarded transaction without even having to execute it um there's another unrelated basic thing that that i didn't quite understand like um with regards to commit and re reveal schemes um why wouldn't like a simple um hash based commit and reveal scheme for every transaction why wouldn't that work right so so i think that one of the bigger problems is like in in order for it to be incentive compatible you need to have some sort of penalty if you don't reveal but you know but the problem is that knowing whether or not someone revealed is is a very difficult problem it's like a subjective thing because for some people they might see a piece of data as being revealed some other people might see it as not revealed you know someone could publish their data right at the boundary which is considered kind of the the deadline for publishing and then half half will see it half will not see it and so that's that's basically consensus over data ability which is very expensive and the way that we know how to do consensus over data availability is basically you have a committee that votes as to whether this one hash is available yes or no and because everyone's voting on the same thing the way that you vote is just by signing a message with one bit you can do the aggregation so what happens is that we aggregate all the signatures that have a bit one and we aggregate all the signatures that have a bit zero meaning that they think that the the data is not available and so basically what you end up doing is that the blockchain verifies two signatures but if if you're voting over n n messages and individual transactions then you have an exponential blower blow up and the reason is that you have two to the n possible combinations of votes that you could be making and so the blockchain needs to go verify two to the end signatures which is extremely expensive i'm not sure like let's give me um let's a very simple example let's first before i can commit the transaction i just commit to the hash of the transaction and that and that hash is um um gets into the blockchain and at some later point in time i just revealed the actual transaction yes well why is there more than i mean that they're just two signatures that need to be checked right two times the transaction signature okay so so one of the problems is that you can just put lots and lots of commitments you can say i'm you know you can commit for example to say i'm going to buy um i'm going to buy you know one if i'm going to buy 10 if i'm going to buy a hundred each i'm going to buy a thousand eve and so basically you have the option to buy you know some combination of these of these transactions and you also have the option to not buy anything and so what you can do is you can look at what other people reveal and if if what they revealed for example is a juicy you know unison transactions that can be sandwiched then you can just reveal transactions around that that juicy transaction to make the sandwich so basically you're in a position where you can you you can grief people and so what what you need really is you need to have some form of of collateral which is which is fairly high because it needs to compensate for the for the the attack that you you you're gonna do and you need a way for the protocol to know when to actually um you know um you know liquidate the the the collateral um now one way to do it without the data available to oracle's is just as you said to just put everything on chain and if it doesn't go on chain within a certain period of time then then then then you destroy the the collateral um but i guess like yeah i guess i guess you need the no you're right you can't do that but i guess you know you need the collateral to be very very high to compensate for the the potential loss that you that you're inflicting to to to others i mean in in my naive view it would just be like a commit and a reveal transaction like a pair would only be valid if a page on all the gas on upfront in the commit transaction yeah but the problem is that it's not it's not just the gas and the reason is that the option value could be much much higher than the gas the option value could be you know 100 if and the gas could be just a tiny fraction i mean that's maybe like the simplest way to explain it is that you need a way to quantify the the option value and even if you do quantify the option value perfectly you also need a way to to kind of compensate those that you've grieved and now you need to measure the griefing it just becomes very very ugly very quickly but if you're doing on a kind of one block at a time and you have single start finality then there's you know there's only two cases and you know you can't just reveal based on on other external information because all the information has already been incorporated in the blog that you that you built as one big monolithic thing um and you've already perfectly priced you know like how valuable this this this this block is is to you and so here you can just just charge up front as you said which is exactly what pbs is doing it just charges up front for the the the tip um and the and the base fee um for all the transactions in in in the block but here there's you can't really agree grief anyone other than yourself by not by not revealing okay cool thank you maybe one one question what do you think uh um we should be working on at flashbacks related to this right so i'd actually ask for a spicy take i guess my spicy take here is that if if you don't have a crypto team and you're in mev you're not going to make it and so you know maybe just strategically speaking it's good to start investing because it might not be you know the short-term game i mean we are starting to see it so for example for threshold decryption we have three different projects we have shutter we have osmosis and then we have d-rand that all have kind of this this threshold decryption um [Music] but uh you know i think incrementally over the over the years we're gonna we're gonna slowly kind of go from what this flavor to this flavor to this flavor um and more and more transactions will be will be encrypted and the thing the way that i think it will happen is that uh you know first it will be on the per roll lab basis um where you have this this encryption and the reason is that you know the roll ups can define their own consensus rules and and uh and whatnot so for example you know the perfect example might be arbitrary arbitrary is planning to have encryption with this this first you know ordering and fair sequencing service from from chain link um and then what i foresee happening is that there's going to be a bunch of you know experimentation and competition and then standardization and then eventually maybe even the layer one ethereum itself will will implement some sort of encryption as well why don't you do that today partly because um you know the the there's other things that we need to to work on you know we need to work on scalability for example that that's that's a huge thing and there's there's also you know various security upgrades that we need to do you know all of all of this stuff um but i guess another reason is that we're in this luxurious position where we can delegate right like the whole roll-up centric roadmap maybe means that uh we we might never need to go ahead and and and have this encryption because all the transaction flow will be at the roll-up level um anyway um but yeah one of the things that i'm predicting is that there will be a notion of of enshrined roll-up um where basically you you know the community will say you know in 10 years time we clearly know what the best roll-up is you know it's a zkvm and and you know we we basically want to uh to provide the same functionality but at layer one and so what some of the there's a bunch of advantages you get from that like one of them is that you you no longer need any form of con of of consensus and so you don't need another token uh because the re the reason why rollups need consensus at the minimum is because they they need to upgrade the rules of their own rollup so for example a lot of rollups they want evm compatibility but the evm you know changes over time you know we're adding new upcodes and stuff like that and so in order to maintain evm equivalence you need to have governance and that's an attack vector and so if we were to have an enshrined roll-up where the rules of the roll-up upgrade at the same time as as the layer one um then then you have you know you have you have a better roll up and there's there's like a handful of other ways in which enshrined roll-ups are just better than kind of application level roll-ups but that's that's kind of thinking you know 10 years into the future got it do we have any other questions all right oh i can have like two minor remarks i think with with regards to the metadata i think one point that is missing is time um yes yeah i mean i mean this is nothing you can encrypt or something but something that needs to be considered yes and absolutely and the other thing is like i'm not sure i can agree with your statement on the on bandwidth is expensive i think if you think about um the last decades let's say that the bandwidth is just um getting cheaper and cheaper sorry when i said bandwidth i mean metaphorically i don't mean the actual bandwidth in like bytes per second i mean the the if you think of the the data availability oracle as being you know you give it a hash and it tells you true false is it available is the data under this hash available yes no this oracle has low bandwidth as in you can give it a hash every every slot but you can't give it 10 000 hashes every second if you would you know if you had 10 000 transactions second it just just wouldn't work amazing justin i learned so much today i think we should have you every week man [Laughter] thank you so much for this presentation it was great this was awesome i'm so glad this was recorded as well uh for the members of flashballs that weren't there fm were gonna carry that knowledge over there's like a lot of things that you said that are very important in my opinion um cool before we leave justin do you have anything you want to share with flashback anything else sorry you want to share with flashbacks or any questions you want you wanted to ask i don't know maybe um hmm i i mean i i still want to see that presentation from alejo you know like the diving into the numbers and quantifying all sorts of things um [Music] you know you know you know how i asked you know what what percentage of bundles you know are conflicting and like i have i have maybe 10 or so very similar questions about kind of the nature of mvv that yeah you're seeing uh but maybe that's for another discussion yeah i think alex posted there we can resend that uh or telegram the like i have a summary of that so you can check it out it's an old analysis so i take that with tweezers but yeah i think it's something i've been like pushing for us to look into again i think it's it's an important important question for us it's directly relevant because it touches upon like the optimal uh algorithm for merging right that's that's what's the initial motivation to to do it but definitely i would share that and happy to continue the conversation amazing all right well justin thank you for staying 24 minutes over and for um an amazing presentation as well with uh logistical with this physical board it feels great it's the physical board um yeah thank you so much have a great rest of your day thank you for sharing all of this with us i think we might have like uh additional questions etc so no we have communication channels we'll be sending all of those um yeah thank you thank you so much guys thank you so much 