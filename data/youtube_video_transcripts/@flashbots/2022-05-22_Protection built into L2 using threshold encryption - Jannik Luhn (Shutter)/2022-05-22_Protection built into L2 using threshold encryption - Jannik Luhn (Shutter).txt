[Music] i am yannick i work on shutter network and our mission is kind of to oh there they are nice yes yeah to prevent users from malicious mv extraction in particular on l2s and rollups because that's what everyone using now and the approach we're taking is using threshold encryption so a cryptographic approach want to start with kind of defining what we mean with mab protection because we're not protecting against all mev that doesn't make sense um but since we're on on this light mode state i want to start with a positive definition so what we allow users to do what they normally wouldn't be able to do um instead of just saying what we prevent them from um and this is what we came up with we want to enable users to safely reveal private information to the chain so let's dissect this a little bit the important part here is private information the user knows for example a secret that it wants to send to the chain maybe it knows the solution to a puzzle that only they know or maybe um it's it could also be the intent of um of trading so if they want to send a transaction in the future this could also be a piece of private information revealing to the chain meaning sending a transaction and then keyword safely there's a bunch of things that can go wrong there the obvious one is that transaction could never end up in the chain so this would be censorship the sequencer of the roller for example refuses to include the transaction or um they could be front run so the information that used to be private before they send their transaction is not private anymore um and someone else used that information and um get in got in the chain first yeah what we're not talking about when we mean muv protection is things like arbitrage and liquidations uh those often at least those that don't have a clear um victim maybe they have victims maybe they're good or bad but it's not very easy to define so but we don't worry about this we mostly care about these types of censorship and front-running attacks why roll-ups uh basically so the technique we're using can be applied in different layers it can be applied in l1 so it can be applied a choosing it can be applied in the application layer but we focus on rollups because we think that the majority of mav will be there simply because the majority of users will be there in the future and the majority of applications that's one reason the second reason is that roller protocols are still new and still relatively easy to modify so there's many many of them and they're willing to experiment and they try to find different focuses so it's it's it's a great situation to be in if you want to suggest a rather big change to how these protocols work this would be much more difficult in at once so um proposing a change to how ethereum works is more difficult because they have to be much more conservative they're already established they already have lots of users so they have to be careful and the third point is that most draw labs today have a single sequencer this might change in the future we just heard about this there might be decentralized or distributed sequences but for now that most of them are single yeah a single sequencer centralized sequences and this um has two effects on us first is it's relatively easy to implement our protocol and that it makes it easier to reason about we'll see why later and also a big issue with having a single sequence is censorship and we think that our approach can help there too so it can alleviate the need to decentralize potentially so therefore we've decided to build this thing what that we call rolling shutter it's kind of a plug-in that we can integrate into any roll-up that that wants to to use it pretty much so how does it work essentially it's a commit reveal mechanism so a user who wants to send a transaction does not send the transaction directly because then they would leak all the private information but they only send a commitment to that that private information then the sequencer will pick up these commitments and order them since they don't see what the transactions actually do so front running is difficult they can't extract the private information it's not there um so everything is safe and only once the sequencing step is finished once this ordering is final only then the commitment will be revealed now the naive approach to do a commit reveal scheme is using for example a hash commitment the problem there is then that the user would have to commit it in the uh have to reveal it in the end and it gives them the option to not reveal and then we have a big problem because either we have to hold the chain we don't know what to do with that or we have to ignore it and lots of applications would break in in that instance because for economic reasons um so the solution we and and another reason is that ux would be horrible so whenever you send a transaction you would have to send two transactions with some time in between that would be very annoying so what we do instead we have a committee that performs the revelation the user only has to send the commitment and then the committee does the reveal how does it work essentially by yeah threshold threshold encryption the commitment is an encrypted message that the committee has the power to reveal um yes and the diagram shows kind of how it will look like the sequencer produces patches of these encrypted transactions and whenever a batch is closed it's final then the committee will rebuild the key and then the process starts again so how do these committees look like we call them keeper committees because their job is to produce keys they generate these encryption keys and decryption keys a lot of them in sequences it's managed by a dao so there's a the dao's job is to pick keepers who are likely to be honest who who are likely to do a good job and the list is then defined in a smart contract on chains everyone knows who who those people are and we assume that a threshold so a certain number of these members of this committee are honest and online and do their job well and this threshold is a parameter that we can pick could can be one half could be two thirds something like that and ideally it's large enough so that the threshold assumption is justified these keepers now run a distributed key generation protocol um unfortunately these protocols tend to be very inefficient they have quadratic overhead basically every node um in that network needs to send er to send one message to every other node so as you can imagine there's going to be lots of messages if the committee gets large we want to have committees of like 200 nodes maybe and that would be not very feasible in that case especially because we want to repeat that process also rapidly we want to have batches in rapid such successions like five to ten seconds so this would be within a standard dkg protocol this would be infeasible so therefore what we came up with some collaboration with cryptographers is we found a much nicer protocol that still has this quadratic overhead but it only has it once in the setup phase so you only have to run it once in advance and then for every batch for every decryption key that you generate you only have linear overhead so you only need to collect one message per off of these members which is pretty much optimal i guess okay so how do the transactions look like the transactions of the system are basically ethereum transactions they have all the same fields just that they are encrypted unfortunately we can't encrypt all the fields um we can't encrypt basically the sequencer who has has to select those transactions and they have to be enough they need to have enough information that they know that they will they will get paid so that the sender can pay the transaction fee so the gas amount the gas price and the signature needs to be plain text but this is usually fine because in these fields there's not a lot of private information usually the more important private information is the receiver of the transaction um and the contract you or the function you call in a contract or yeah because that's actually what the transaction does and this these parts are encrypted in the future we could think of encrypting everything and then attaching a zero knowledge proof so that the sequencer knows that the transaction will pay a fee without seeing the fields directly but for now this is too complicated for us and not really worth it so we took the easy way that's also more feasible at the moment the sequencing step i.e the batch production step is performed by the collater we call it the collater it's run by the same entity as the sequence of the roller but and sequencer would actually be a better name because their job is to order the transactions but unfortunately that name is already taken and it's a different piece of software so we call it the collater yeah and their job is to produce these batches define the list of transactions that are in there the order of those transactions and they also um commit on the execution context so the block number times and and things like that everything that can affect the execution of transactions and eventually once once they're done once they um sign this and once they close the batch they will send it to the sequencer so you might wonder why they need to commit on the execution context why does that matter and the reason for that is that there's a potential attack that we call optimistic sandwiching so even if the sequencer does not know the transaction this green victim transaction they don't see what it does but they guess that there might be a potential attack and they just do the attack anyways so they sandwich budget they put a front-running transaction in front a backgrounding transaction um in the back and then and they just wait until um they see what the transa like then they commit wait until the decryption key is present they decrypt and then they see what the victim does and then they kind of switch on this front running and backgrounding transaction or don't switch it on depending on the timestamp so for example they say if the timestamp is even the front-running transaction only will run if it's even and then they set the timestamp to even if they want to run it in the attack or they set it to odd if they don't want to run the attack so the message here is basically that you can that defining the order of transactions is not enough in general you also need to find basically every input that can change the execution path of a transaction but yeah the solution to that is simple we just make this sequence i commit to all these fields it's not too many it's like a couple of block numbers and the timestamp this is the architecture of how our system looks like we have two parts we have this kind of shutter system with a rollup and the shutter system is the software that we provide it's the keeper client it's the correlator we also have a tendermint chain here it's kind of a private chain that is run by this by the keepers only and that the keepers use to coordinate generating these running the set of phase of the dkg so but no one else basically has to care about that um and then on the other side of the roll-up we have the sequencer and the state transition logic these we have to modify a little bit so we have to provide an interface that the collateral can use to push batches to the sequencer and we need to modify the state transition logic so that it execute these patches so the normal state transition logic executes transactions ethereum transactions and now we have to do this additional step of decrypting transactions first and then executing them but these the point i'm trying to make here is that most of the complexity of the system is enclosed in the shutter part on the left part that we write and then this the changes we have to make to the rollup are very um trivial almost very minimal at least so it can be without a lot of effort integrated into most roll-up designs we should talk a little bit about what can go wrong so what happens if people don't be hacked as behave as we want them to and how we can discourage or encourage honest behavior and there's basically two classes of attacks here uh one is cryptographically provable and one is non cryptographically provable cryptographic cryptographically provable is an attack by the collateral they can create two competing batches so they can first create one batch uh wait for the decryption key and once they see the decryption key created create another batch um basically reordering transactions in a way that suits them so this would allow them them to extract med which they weren't um able to do before um but fortunately this is very easy to uh to prevent but at least it's very easy to punish so since these commitments with the collateral sense are signed or the batches assigned we can simply slash them if anyone provides proof of two batches that assigned by the same collateral from the same block item so this is easy to discourage what's more difficult is like misbehavior by the keepers so things that the keepers can do is they can decrypt transactions early they can not wait for the commitment by the collater they can decrypt it immediately or they can decide to not decrypt at all both of these attacks only work if with some collusion so for the first attack you need at least the threshold number so half or two thirds or whatever we chose the parameter on these this number of keepers have to collude so it kind of breaks already our honesty assumption but it's still important to consider and for not decrypting you need basically n minus the threshold so so that not threshold keepers are available available to produce wiki um so unfortunately these are as i said not cryptographically provable for example the first attack collusion decryption oily can be done completely in secret so no one would actually know that or at least have clear proof of that but fortunately there's evidence so often you you you don't have proof but you have evidence so you see some weird things going on you see sand when sandwiching attacks which shouldn't be possible normally so in those cases we can use the dao to punish the the keepers they can do what we could call subjective slashing so even though they don't have proof they just make that our vote on these people probably colluded so we we slash them or at least pull them out of the set and the other solution is to simply long incentivize them long term so give them long term contracts so that they um can probably earn more money by being honest yes that's pretty much all of it to summarize basically i want to say that running shutter is like this front-running protection plug-in that can be integrated into almost all rollups it's based on threshold and cryptography and ready to be released soon we hope thanks a lot we have time for questions apparently two questions hi uh thanks for the talk um do you have an idea of the size of the nodes of the keepers and and also my second question follow-up question is uh do they have to decrypt something each time for each transaction or is it linear in the number of transaction so um our goal is to have like 200 nodes in that set i think that's a good size and feasible the bigger the the master queue of course so it's always nice to be have a greater number there and for the decryption yes every transaction has to be decrypted but this is not part of the job of the keepers actually what the keepers do is they just provide the key and then everyone can execute while they follow this transition function basically um is it an atomic decryptions in terms of like the entire batch of a transaction or otherwise is there an a possibility that i committed a transaction but then i never decrypt no that's not possible because um [Music] it's not your job to decrypt the transaction it's the job of the keepers to provide the key and then everyone in the network will perform the decryption so this incentive for every transaction to be decrypted by the other knocked operator basically yes gotcha one more uh thank you for the talk so one question that i have is regarding the threshold signature scheme so it's a dynamic network disk keepers so every time there is a new keeper or uh one keeper like exiting the network you need to update the stressful signature right yes that's correct so like how do you do this like uh in a safe way so you don't lose track so um as i said earlier the um it's the job of the dow to manage the keeper set and they will probably not do changes every week they will just collect uh changes for for maybe a month or longer and then only um change them like in kind of batches so that we don't have to generate keys or perform this quadratic dkg setup phase and very often yes so for now we just if that happens we just generate a like perform a new key generation process in theory you could update the protocol to um i'm not a cryptographer so i don't know how it works but you can uh kind of update the protocol so that new keys keepers can join without changing everything on the um all the key material that the other nodes have so that wouldn't make it more efficient but we don't do that yet cool thanks a lot [Applause] [Music] you 