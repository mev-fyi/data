[Music] hi everyone my name is theo i'm one of guillermo and jairus's many alts i'm a phd student optimization at mit and do research for bain capps crypto fund um and i'm going to talk about how to optimally route through decentralized exchanges so this is executing trades like swaps arbitrage etc over networks of decentralized exchanges and the main point to take away from this is that the routing problem so that includes things like arbitrage swaps and so on is a convex optimization problem and the reason we care about that is it can be efficiently solved to global optimality you'll note that it's convex when we ignore gas i'm happy to talk about this at the end it's actually pretty minor as a detail so with this we'll get into the math so first i want to review constant function market makers this is going to be similar to tarou's talk if you were there next we're going to kind of formalize what this routing problem is so how we can actually write it down in a very nice way then talk how we use this to look at things like swaps arbitrage and so on i promised an efficient algorithm because it's convex we'll talk about a sketch of that algorithm and then wrap up um so first most decentralized exchanges or at least a lot of the big ones are implemented as constant function market makers and so these are defined by their trading function which we'll call phi which map the reserves to some real number and phi in like all cases that we really see is concave and increasing and it accepts the trade where we input some basket of tokens delta and receive some basket of tokens lambda if essentially when we look at the new reserves discounted by some fee which is gamma here the trading function evaluated on the new reserves is greater than or equal to the trading function evaluated in the old reserves and so we can look at a lot of uh the current decentralized exchanges through this lens so for example balancer and uniswap fall into this general class of things called geometric mean market makers where the trading function is just a weighted geometric mean for example unit swap is uh r is a two vector and the weights are going to be equal even some of the more complicated trading functions like curve again are can be looked at through the cfm paradigm so with that we're going to actually use this to formalize what the routing problem is and when we look at networks of cfms a lot of times these are represented by a graph so one common thing that i've seen a lot is using the tokens as the nodes and then putting the edges as basically the exchange rates between these two one issue with this is it's hard to handle things like three pools and also a lot of times we have multiple cfms that uh where i can exchange one token for another so for example for die to eat i can go to unit swap for that go to balancer and so on so i think a more natural representation of this is a hypergraph and this is just a generalization of a graph where edges can connect more than two vertices so here for example you see that the curve pool um has dieth and usd t in it or sorry diethan usdc in it another way to look at a hyper graph is essentially you have this bipartite graph where your cfms are on one side your tokens are on another side and each cfmm is associated with some number of tokens similarly you can trade each token and some number of cfms essentially this just increases the complexity a lot from the first case we saw and good bookkeeping is essential so to do that we are going to kind of take a global view and label all the tokens in the universe that we care about as one through n label all the cfms as one through m one thing to note here is usually m is going to be way larger and this was alluded to by some of the other speakers where even if we have a modest number of tokens if we have a ton of swap pools between all these tokens m might be on the order of n squared so it can blow up quite fast each cfmm which we're going to call i is going to have ni tokens so for example swap pool the local indices would be one to ni so it'd be one and two in a swap pool and we're going to trade this local basket delta i lambda i with cfmi and again this trade is only accepted if when we evaluate the trading function on the basket of or on the new reserves discounted by some fee it's greater than equal to the trading function evaluated on the old reserves to bookkeep the network component of this we are going to introduce this matrix ai which maps from the local index of the cfmm to the global index so for example we might have a dieth swat pool where the local indices are one and two but perhaps the global index of dyes3 and the global index of eth is one so all that would do is when we multiply ai by our like local vector we would take the first entry put it in the third position take the second entry put it in the first position everything else would be zero and that would be a vector of size n which is our global universe of tokens so using all this formalism we can actually write out what this overall net trade with the network is so for each cfmm i gain lambda the vector lambda of tokens i input the vector delta so our net trade is lambda minus delta and then we map that from the local index to the global index and we sum all these up so i promise all this formalism is going somewhere and before i introduce the model i'm going to talk about a few simplifying assumptions again we ignore gas fees i'm happy to talk about this at the end but just for the purpose of showing this as a convex problem we're going to ignore that for now in addition we're not going to worry about transaction execution ordering uh there are a lot of people in this room that are way more qualified to talk about this than i am i'm not a searcher i'm only a researcher so just want to throw that out there as a disclaimer and like i said we can kind of return to these at the end if people are interested so the routing problem the final piece of it that we need is we need some utility of the net trade so we need some way to say like when a net trade is good and when a net trade is bad and with that we can actually write down exactly what the optimal routing problem is and so it's to maximize that utility function of the net trade uh the net trade being this thing that we just constructed kind of with the notation i introduced and then of course we have the trading constraints introduced by each individual cfmm so we can use this routing problem here to talk about things like swap arbitrage etc by encoding those in that utility function u and this is again what gives our satisfaction for the net trade that we make so for example for arbitrage we have some external prices say from an infinitely liquid reference market or our own internal prices or maybe we just want only eth out of the arbitrage so we set everything to zero except for the price of eth which we set to one but essentially optimal arbitrage is finding kind of the best net trade subject to that net trade being entirely positive so we don't actually put any money into that net trade it's only extracted and so you can see here we can write that out as essentially just the dot product of our price vector with our net trade minus this indicator function and so all that indicator function is doing is it's making it so our utility is negative infinity if um our net trade isn't non-negative and otherwise it's just zero so this just encodes that constraint in addition we can use this to talk about things like swaps so this is not a swap with an individual cfmm instead it's a swap with the entire network so essentially if we have some fixed input of token i how much of token j can we take out of the entire network of all the cfms that we have available to us and so a lot of routers or like dex aggregators do something like this um and so again we're going to maximize the amount we get out subject to putting a certain amount in and then just that the net trade for everything else should be zero so if we route from let's say like di to eat to usdc and we want kind of just the route from die to usdc we don't want the net amount of eth to be positive or negative we want it to be zero and more generally this can be used to optimally purchase or liquidate a basket took a basket of tokens or trade one basket of tokens for another and you can almost think of this as capturing arbitrage opportunities as part of the swap because like i said earlier if it makes sense to trade instead of trading from token i to token j trading from token i to token k to token j and then maybe trading some directly from i to j that will be captured in this formulation so now that we've kind of introduced like why one should care about this type of problem and how it can be used to encode a lot of the things that we're actually interested in i'm going to talk about an efficient algorithm for actually doing so and this is really where we are going to rely on using convex optimization and convex duality so what i introduced earlier is the primal problem and so that's given all the constraints we have and given what we want to do how do we find the optimal trades there's actually a dual problem here and that can be think of as finding the optimal prices and it's not really prices in the traditional sense the idea is if you give me a utility function you say this is my how i value the net trade i could essentially give you a vector of let's call them shadow prices at which you value each token and that means if you have this vector of shadow prices you can go to all the individual decentralized exchanges and arbitrage them independently from each other and additionally this can be executed in parallel so you can see how this kind of has the underpinnings of what would we we would need for an efficient algorithm because all we do is we iteratively update these prices where convexity comes in is because we have strong duality we can instead of solving the primal problem we can solve the dual problem and that gives us the solution to the primal problem i'll very briefly go over what this actually looks like so the dual problem is this expression here so it's minimizing the essentially the conjugate function of our utility plus the individual arbitrage with each cfmm the conjugate function is something that you don't really need to worry about it's typically easily easy to evaluate actually it's for swaps and for arbitrage it's essentially a closed form thing so it's not that bad and in addition the arb i is just the optimal arbitrage on cfmmi with some known global token prices so these can be done completely in parallel from each other and that optimal our problem is just this thing down here where we're maximizing the amount that we get out of the cfm subject to our token prices and the trading constraints because this is an unconstrained convex problem and in addition this variable is only a vector of size n it's quite fast to solve we're handling all the cfm parts which is on order n squared in parallel and we're only looking at kind of this variable that size n to actually iterate this and more importantly to add a decentralized exchange to this formulation all you need to do is define the arbitrage function so if you know how to arbitrage given some externally liq or external infinitely liquid reference market so your you know god gives you the prices and you have to arbitrage if you can do that you can add the decentralized exchange to this formulation and of course there are a lot of details that i didn't like kind of glossed over for this algorithm and so i'd encourage you we actually have an open source implementation of this so to check out this package and the associated documentation which go through uh the basically what this algorithm looks like in a little bit more detail all right so to wrap up routing with no gas fees is a convex optimization problem this means the reason we care about this is it can be quickly solved to global optimality using convexity we can construct an efficient algorithm so it's another reason that we care about this and this is implemented in cfm router.jl which also has the documentation has a little bit more of a detailed explanation of what this algorithm looks like and like i said there's a lot of future work to be done here so right now we did not include gas fees in the formulation nor in the implementation and for that you need some good heuristics luckily this is a problem that's very similar to things that people have studied in other fields like sparse regression so there are very good techniques that people know right now to how to do this in addition you could include things like liquidations in this framework um so like gas this is kind of a discrete thing and this is a thing something that we're thinking about extending the framework to finally probabilistic constraints are important when you have transactions that might fail and we'd like to add some of these additional features in addition in the open source package i will give a warning it's not super optimized it's more intended to be used as a reference implementation but we do hope it's quite fast regardless so thank you very much um if you want to check more things out the associated papers optimal routing for constant function market makers package like i already said at cfm.jl and feel free to contact me on twitter thank you any questions yes uh the gas v so i guess with gas fees you are there there's several ways to formulate it so if i formulate it's like a cardinality actually i can i wasn't sure how much time i would have but i do have actually some slides for gas fees so we can go over that real quick but but essentially you're introducing you can model this in the constraints with some constraint that basically says do i use this decentralized exchange in the trade or not and if i do use that in the trade then this this uh adai is one and my gas fee is qi so i just add this to the objective um that might not be the best way of going about it so this is a mixed integer convex program there are some efficient solvers especially if you're dealing with like pretty small sizes of this problem however there's also good heuristics for this type of thing so one thing that kind of you can pull from i mean this has been invented by like seven different fields who all claim to invent it but essentially so i won't name any fields but the l1 norm tends to be a really good heuristic for cardinality and so you can basically think of gas as like the cardinality of the trade vectors so if your trade vector has cardinality zero you're not using that cfmm and if it has cardinality one you are using it and so we can write essentially what the approximate gas would be which would be for each of these it would be whatever the gas cost is times the cardinality or something that kind of looks like the cardinality and then we're going to normalize it by the size of whatever this is so like ni would be 2 for a swap pool and then what this is like what i would do at least is i would solve something like this so this problem is actually convex if you kind of use the same type of machinery that we did to come up with the efficient algorithm you can also write a very very fast algorithm for this and then of course there's fancier things that you can do with like re-weighting the l1 norm iteratively and solving a few convex problems but so gatsbys do fit into this it's just a little bit more complicated because then you have i guess some freedom of expression in terms of how you formulate that problem heuristically so it's a little bit of room for creative expression there are no they're usually so concave and increasing essentially so um for example like uniswap is going to be so for unit swap if you have reserves like r1 and r2 it's a two vector it would be like square root of r1 r2 so the geometric mean of those two um and then most of these things are going to be concave increasing functions any other questions and sorry that would be uniswap v2 just to clarify well as a follow-up question like you mentioned it's just v2 what do you do for v3 is going uh well so yeah the the actually this formulation is like a tiny bit of a lie um so there's i'm glad you asked i i swear he wasn't a plant but but so there's like two things here i think uh one is that you actually only need to define so in the algorithm i presented you only need to define the arbitrage function and this can be done pretty efficiently for uniswap v3 as well the other like i said the formulation is a tiny bit of a lie you actually basically only need a convex reachable set so you just need that your updated reserves with kind of the basket discounted for fees is in some convex reachable set um actually this is also a little bit of a lie you only in fact need that delta lambda is in a convex trading set just the the ability to write this down in the form with phi actually makes this quite a bit easier to kind of talk about and so that's why that was the presentation that i that i used and of course if you want to implement this in practice if i give you some arbitrary convex set that can be very very hard to actually implement oh yes yeah just a quick question so how do you define the arbitrage function for like an lp position um so you don't so as the basically as the uh arbitrager let me find it you only i guess you don't care what the lps are doing right the you can see what the state of kind of the exchange is so you can see kind of what you know the prices are quoted or the reserves whatever so all you care about is you have some prices you have to make some trade you know how this is going to affect the reserves so basically you know kind of what trade you can make and so all this is saying is given my external prices make the best trade out of the trades that i can make so you don't really care what the lps are doing in this case as kind of as as somebody just executing a trade across a bunch of markets yes what's the performance um so i can talk about our performance like we so we implemented this and i think with um ten thousand uh with ten thousand like swap pools it was like a hundred mil like a hundred milliseconds or so to do it and i think it was around a second if you like it scaled linearly essentially which is the other nice thing about something like this is kind of when you add you're only adding kind of some in a very very rough sense linear complexity as you add additional pools and then it was about a second when we did this with a hundred thousand um that said we like i think you probably could get like two to five x speed up pretty easily on our implementation um we were super optimized code is always harder to read so we wanted to make sure that you know it was uh performant but still pretty easy to read and good to use as a reference implementation [Music] anything else great thank you very much [Music] you 