[Music] okay good afternoon everyone i guess it's time to i guess it's time to start so i'm here to talk about exploring mbv in the modular blockchain stack a little bit about me my name is john uh unfortunately irl i am not a cute anime girl i am one of the co-founders of celestia labs which is building celestia the first modular blockchain network and i'm also one of the co-founders of fuel labs which is building fuel the fastest modular execution layer uh and today i'm going to talk a bit about modular blockchains and how mev in a modular blockchain stack context might look like and why would we even want this was the motivation for this for those of you who have been following this last year project this notion of modular blockchains has been increasing in popularity not just on celestia but also with uh alternatives such as polygons avail and eth2 thanks charting and so on uh there's a big push in the industry to work to move towards this modular architecture which is fundamentally different than the monolithic architecture and we would like to know how mev might look in this new world okay so first a quick recap of the difference between monolithic and modular blockchain architectures for those of you who may not be familiar with this uh this is kind of how a monolithic blockchain looks it's a single model effect for lack of a better word atomic layer that does consensus so ordering of zeros and ones availability so this means making sure that data has been published to the world settlement optionally and also execution so a blockchain like ethereum or bitcoin or celina or literally every blockchain prior to celestia was a monolithic blockchain uh and it does all four of these components all in a single single atomic layer why is this not particularly the best model well because to resolve the double spending problem if you read satoshi's design paper carefully you don't actually need to exclude conflicting transactions to resolve double spending you only need to provide a total ordering on transactions in other words on zeros and ones ultimately and as long as you have a total ordering anyone can exclude themselves later on invalid transactions that attempt to double spend that come later so timestamping in other words consensus and data availability is sufficient you don't actually need to do execution of the transactions at the basis layer in order to solve the double spending problem and this is good because what is the current bottleneck for ethereum well it's execution right it's not consensus it's changing the consensus protocol does not make the evm faster the bottleneck is ultimately the evm and state growth and disk io and such that result from the particular virtual machine choice in other words execution okay so the start of moving in the direction of modularism uh is when rollups kind of started getting steam where you would have execution happening at a higher layer uh the roll-up layer and you would have your base layer still performing things like ordering of transactions data availability settlement but also execution so this looks like roll-ups on ethereum today this isn't exactly modular because the base layer is still performing all the four tasks and therefore still bottlenecked fundamentally by this execution can we go further and the answer is yes so an actual proper model a modular blockchain architecture would look something like this so you have the base basis consensus layer at the bottom that order transactions makes them available and then on top of that you can have completely separate layers that perform settlement and then execution on top of this and this is not the only configuration of a modular blockchain stack it's only one possible one and this is the nice thing about modular blockchain stacks is they can be configured in many different ways for example you could have multiple settlement layers connecting uh sorry multiple execution layers connecting to a single settlement there which then posts data to the data layer you could also have execution layers that directly post their data to a consensus layer and you could have one or two or thousands or a million of them all running on top of a single consensus layer that provides shared security to every single one of these layers on top of it okay so uh now we're going to talk about now that we know what you know the modular architecture looks like we can start exploring a little bit about how mev would look in there so we're going to keep two things in mind the first is the law of conservation of meb this is kind of a tongue-in-cheek observation that isn't like any hard law or anything that simply moving things from one layer to another like say moving execution from the base layer up to an execution layer does not on its own with no further changes it does not change the total amount of meb in the system now the nice thing about separating things and layers it allows exploration uh and it allows you to kind of tailor each individual layer with different ways blocks are produced and so on so that the total mev of the system can be reduced in ways that might be very difficult to do if everything was on single layer the second thing to keep in mind is that minor extractable value is approximately leader extractable value in the sense that in order to extract value the person who is best positioned to do so is the person who is the leader and other is the person who produces blocks uh as a side as a small side note you know there are certain protocols like avalanche which claim to be leaderless and therefore have no mev uh maybe this is true maybe it's not uh that being said avalanche is actually not leaderless their c chain does in fact have a leader after a recent upgrade due to the fact that leaderless c chain doesn't actually work uh so the fact that you know they you know if someone comes to you and says well you know you have to think about things differently in a leader's leaderless protocol no such protocol actually exists today every single every single blockchain that does you know turing complete smart contract execution all has a leader so we're going to approximate it to leader extractable value uh yeah so uh before we start kind of diving into uh you know how leaders are selected and stuff we'll take a little blast from the past here i was talking to uh georgios back in august 2019 about some work that i was doing on this design paradigm that was later called optimistic roll-ups and the the the back and forth here is essentially a discussion on uh how blocks are produced in this roll-up right uh because a lot of the classical thinking around plasma researchers at the time were around things like exits you have a single permissioned leader or sequencer if you want to call that and so on one of the primary innovations of this design technique that is now known as optimistic rollups is that producing a block must be permissionless and it's not sufficient to simply say okay i can force an exit through something i don't know an inbox or something because there are certain things on the roll-up that cannot be exited something like a uni swap liquidity pool right that does not that's not owned by anyone you can't exactly exit it right or if you want to unwind your position uh you know some defect protocol you want you want to unwind your position you can't exit that you actually have to force a state transition into the chain and not only that users if their only recourse is forcing a single transaction into the chain that's not exactly very good because it means if the operator goes down or the sequence or whatever you want to call it goes down then that means every single user now has to make a main chain transaction to get their transactions in the property you really want is it must be permissionless for users to post an entire batch of transactions to update the roll-up state and there's a word for that well it's called producing a block right so if your scheme is isomorphic to producing a block then you're good if it's not then there's issues somewhere those issues could be good there could be bad but there are issues okay so at the end here in my last uh you know my last tweet over here uh you know i get asked you know how exactly would you make this block production permissionless right this way of selecting a leader who can produce a block and i kind of say well it'll be an implementation detail and cue people getting triggered because you know the the researchers and the designers and stuff you know we leave the implantation detail all the hard stuff to the implementers uh it turns out there's a lot of nuances in the implantation details uh that you know gets that get skipped over that have ramifications in that maybe space even though from a design perspective of the security of the optimistic rollup as long as it's permissionless then you have your security guarantees okay so now we're going to explore different layered architectures and we're going to point out where is the leader and we're going to see because again minor extractable value is analogous or it's very close to leader extractable value so we want to see where is the leader to know if this mev is on the layer two if it's on the layer one if it's on the data layer if it's on the execution layer and see if there's nice things we can do to move mev in one place or a different device okay so maybe in the monolithic stack right you're doing everything all on a single layer uh there aren't exactly many places that meb could you know where the leader could be uh because you know i mean there's only one layer here but you know the meb mostly comes from this execution part this execution model module of this layer right there's you know there's arbitrage there's reorg uh you know reorganizing transactions in a block and reordering rather transactions in a block so the leader is going to be on the base layer okay good we give it a crown here now uh another model let's imagine we have a roll up with a single sequencer so this is what a lot of roll-ups look like on ethereum today right where you have your roll-up execution there and it settles to the base layer uh which in our example i guess it could be ethereum right uh now if you have a single sequencer that's you know proof of authority sequencer let's say right uh where where would the leader b would it be on the base layer or would it be entirely self-contained within the layer two and not leak down into the layer one who here thinks it'll be on the execution layer please raise your hand okay i see like two hands good i see three hands good the three hands are correct okay so if you have a proof of authority you know leader selection protocol then the layer one the base consensus layer can't actually like do anything to stop that person from being the leader right so all the all the bad things around leader extractable bad or good things around leader extractable value are in this model entirely pushed to the execution layer potential is good because now it means that this mvv is not leaking down and it's not bleeding down into the base layer and this is very similar in some ways to this notion of like proposer builder separation right where the proposers essentially are in a network outside the base layer and all this mv and stuff is contained into into the into that layer okay so uh let's examine a different leader selection protocol rather than something like a single sequencer let's do something more chaotic like first come first serve where literally the first person who submits a block a roller block that is you know that's valid and that builds upon another valid block and stuff that they're the ones who are implicitly the leader after the fact so there's no like slots where people are decided to be the leader just like first come first serve this case is different uh because the miners or the you know the block producers producers at the base layer can actually choose which order people go in right so in this case a lot of the mev will actually leak down into the base consensus layer because those miners can actually decide who goes first and not only that they can actually insert their own transactions so they themselves can go first right so this is an example where this implementation detail which doesn't really change the fundamental security of the rollup actually changes something which is the change is where is that maybe extractable in this case it would be the consensus layer obviously this isn't particularly desirable okay let's do something else we can think of a tendermint style leader selection protocol right so this is uh something like imagine you have some tokens you have some stake weighted thing and i thought you just kind of rotate around the leaders and different slots right uh in this case the actual deciding on who is a leader runs in a smart contract but beyond that the base layer doesn't have the ability to for instance reorder transactions to insert themselves to be the leader it's more like they need to have stake which is completely independent of their ability to reorder transactions so in this case the mevu would essentially be extractable and in the execution layer and would be done through this leader selection process in a tendermint style leader selection process okay so that was kind of like modular slash semi mono semi mod or sorry monolithic semi monolithic if you want to call it that uh designs let's think about how it would look like in a modular world uh so imagine you have what's known as a sovereign execution layer or sovereign roll-up so this one here is one that posts its data directly to a data layer and essentially self-settles it doesn't have to post its data and post its fraud or validity proofs to something like an evm it essentially will execute those fraud or related proofs entirely client-side entirely locally so it self-settles now you can think of this largely like a layer one in terms of the fact that it can hard fork or soft fork to upgrade its consensus rules which is good because off-chain governance and all that but it also shares security with the base layer because to reorg the execution layer you must reorg the base layer so essentially the best of both worlds and this is one of the reasons why these modular systems are essentially you know the future so uh we have this you know sovereign execution there imagine you have a single sequencer so again something some like poa style thing or a tendermint style leader selection process well this will look a lot like what we saw previously right where essentially the the leader selection process is not dictated by the underlying consensus there but rather is done entirely within the execution layers consensus rules so there's nothing that the base layer can really gain by reordering transactions right now the base consensus layer if it could completely reorg the chain and do a time bandwidth attack then yes the mbb might bleed down into the base layer this is of course why most proof of stake systems which everyone's moving towards provides a notion of finality right tendermint is very good in this it provides immediate finalities you know as soon as you have a block you know 10 seconds 30 seconds whatever your number is your immediate finality gasper is a little bit worse of this right it has something like six minutes to finality in the best case in the happy case it could be forever but that's another story uh okay let's consider a different example where you have a sovereign execution there and again you have a first come first serve where literally the first person to post a block to the data layer is implicitly the leader in this case just like before the data layer can in fact change the outcome of what is what is the canonical roll-up chain by reordering transactions on the base layer purely so the mbb essentially has leaked down into the base layer if you choose this mechanism for leader selection okay now we can consider uh non-sovereign execution layer so this one is one that i don't want i don't want to call these like layer twos or layer threes because this notion doesn't really exist in the modular blockchain world but imagine you have an execution there that posts its proofs fraud of validity to a settlement layer and the settlement layer then posts all the data to the data layer right this is a pretty good architecture because it allows things like rollups that exist on ethereum today to very easily just kind of plug in and become execution layers in this in this model so where would the leader selection be well it could be over here if you make your settlement layer do first come first serve block production right or it could also be here if you make the leader selection process uh be first come first serve within the settlement layer but the settlement layer then had a tendermint style leader selection process to post blocks to the data layer or it could be anywhere here depending on the implementation details tm so this is an example where the even though the security guarantees of the protocol itself don't change fundamentally depending on which leader selection protocol you use it does have very significant effects on where across the stack mbv is actually extractable from from and i think we would hope that we want to push mev up the stack as much as possible although that's not exactly my place to sell that's probably more of a question for the mev researchers here okay so if you want to find out more about what we're doing our website is celestia.org our github is celestia.org and our twitter is also at celestia.org or you can also follow me on twitter at jaddler0 and with that i guess it's time for questions so i have two questions one is very basic about just how to understand what modular blockchains are and then one that's more specific to meb the emmyv one is why do you say we should like push it up um like what's your intuitive thinking around like moving it upwards rather than downwards the intuitive thinking is that well it's the same reason that people want to have block proposal builder separation in e2 is that if you move it upwards into the stack then failures are contained to there while if it's lower in the stack failures or increases in cost and so on and disruptions from the mev actually affect everything above which if you just have like a single if you have a single layer of you know okay you know data layer then settlement layer then execution layers it's not exactly very important but we expect in the future to have many many execution layers and many supplement layers you don't want the any view of like one solution layer to bleed down to the data layer and then affect everything else gotcha gotcha and then probably a really basic question but could you explain again why the roll-up model doesn't actually solve for what the truly modular structure does you had mentioned that like when it's a roll-up they're still like it doesn't solve very much that what from what a monolithic blockchain would do yeah uh so the issue with a rollup on top of a monolithic chain is that in order to use the monolithic chain which does you know data availability consensus execution and settlement altogether to use it you actually have to make sure that it's valid which means you have to do a whole bunch of work like if you try to run an ethereum full node it takes somewhere like 650 gigabytes just to run an ethereum full node today and that you know if you keep it running it's going to quickly grow to one terabyte then you have to turn it off and prune it and stuff and it requires a fairly powerful computer to run an ethereum full mode so this is where like yes it's partially modular in the sense that you're offloading some execution but if you don't remove execution from the base layer then every single rollup must also for instance run a ethereal like if you're doing this in ethereum every single rollup must run an ethereum full node to have any security guarantees which is obviously not great you would want that base layer to be as minimal as possible to be able and to be usable as a shared security layer thank you i think we have the discussion now thank you [Applause] [Music] you 