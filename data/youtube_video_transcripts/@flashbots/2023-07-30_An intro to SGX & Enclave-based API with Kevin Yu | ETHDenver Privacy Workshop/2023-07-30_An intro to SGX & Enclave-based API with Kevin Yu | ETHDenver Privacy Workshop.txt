yeah so today I'll be just giving a quick intro to sgx and then what we're building here at the new oracles that are in a way like we're having a solution that's has this like heavy Reliance on science Jacks but yeah uh let's get started so what is sgx this is a very philosophical question as well so sgx is a form of trusted execution environment for Tes right basically these are just like you have this kind of like secure area your main processors right and then it can guarantee that the code and data are being loaded into your processor is protected again say like a malicious host that competition you have like you know administrative privileges right so for example for your operating systems for your hypervisors right for your bios or firmware for your smms and then for any form of remote attacks right even there for like a lot of these like a malicious Administration want to do potential attacks against like whatever program you're running on enclaves right at least this is what the Intel is promising right you're having a much much smaller attack surface here right you have some side channels here you have this like interface towards Hardware but then you're basically relieving from the potential attack Services you can have for dos and the weaps and now of course right for whatever code you're running in the enclaves right you you have confidentiality and the Integrity both being guaranteed right this is also kind of like the two core features That's the basis of Andrew and Phil's talks right like when you're running your Enclave based auctions or your private contracts right you need to make sure that the programs are being executed with integrity and then of course there's like a privacy element to that as well so the core components of sgx we're listening for here there's much more than this but then you know due to the time constraints we have so TCP or trusted Computing base you can think of this as a measurement basically that's made on all the security parameters of the underlying Hardware right so this is used for a lot of like key generation and then like annotation creation as well yeah and then so Hardware secrets we have the root provisioning key and then the root ceiling key the production key is so basically Intel has this like huge registry of all these rpks that they would use to basically verify say a particular Enclave is um being produced or manufactured by them or not the rsk they're claiming that this is something that they do not know right so this has been hard-coded in the hardware when it's being produced but then Intel has basically eliminated all the trades all the traces for production for the rskis so this is used more in the actual production for like a key generation and then like for the ceiling process that Andrew was telling about as well remote attestation this is kind of like a core component of sgx that makes it very powerful and there's also like the differentiation with asymptusto and then the icv for MD there as well but it's basically what it allows is that say a third-party like software is trying to access a service that's running in a non-clip right remote adaptation basically allows them to verify that whether this program is actually being run in in the National Enclave that's been verified by Intel right but then you can also have your custom like dcap pipelines which I will get into later as well steel storage this is when you're basically say like your program is running sgx right and you have some like intermediate results right and then you want to save that into a untrusted environment say to your computer's own own storage like on disk for example and then you basically use the assuming Keys here to kind of like make sure that the data has been offloaded right into the underlying disk is actually being price reserved this is a really simple kind of like description right of how a usual program would work when you're running this we're running it in a non-cliff right so e-calls which are you used to enter the enclave and the O cause which are used to call outside right the input of equal and the output of ocar are usually not trusted but then for an application design here right you can you can see that you have this very nice partition where you have a untrusted part of the app right and then you do this Enclave creation process which basically you just run these four or I mean The Enclave would run these four commands right to create the enclave and then yeah you do the decal for entrance and then there's like whenever you're interacting with like something that's outside of your enclave right you use the we'll have a much kind of like concrete example of how this would actually work in production with what we're building later I'll go through this slide real quick but then these are just some of the core components so if you are of your enclaves right so your PRM or processor reserved memory is being carved out your normal dram right and they also have like a Enclave page cache that's been put in here right there's like some mappings for your cash here at the linear address range here it's also used to basically manage your address tables with all of your pages and then the the control structure is there TCS here is basically means that it's a piece of software within Enclave that can support like body threaded execution from our programs so yeah there's a I think there's a huge design space potentially I mean there's a huge design space of like whatever you can run within the enclaves and then there are also very robust developer tooling right now that allow you to do that now in the attestation part right so on a high level the sgx auto decisions are just you're just cryptographically proving application Integrity based on some of your like your Hardware information right one of the core components of that would be the TCB or trusted Computing base that we're talking about where you it's basically establishes an identity for The Enclave there are two types of attestations that are most commonly used right one is local ad Association which happens usually when you're running like two different enclaves on the same piece of Hardware right and then you want them to to establish a secure Channel between the two and then do some kind of communication or like or whatever I say you're running an NPC or collaborative or whatever remote annotation is as I was describing where basically you have the you have a third party say like a software or whatever right trying to access the code that's being run within the sjx and then they want to make sure that the code is actually being executed in the secure Enclave yeah but these are usually when you're having the auto saving results which you have here right so this is the TCP information right this is reported uh this is more relevant to a challenge process that we'll get into later but then there's like some Hardware info there as well okay so this is what you're having for local attestation but then before we get into that so this is a I don't know if everyone can see this picture very clearly right but this is the root provisioning key where the rpk what we were talking about this is the root seal root ceiling key or the rsk that we're talking about right this one but you can see that it's used both for but generating the key that's used for like adaptations for provisioning uh some Intel call it and then it's also used for like the ceiling process here right with when you're trying to also the data to like some underlying Hardware there's a few like Transformations and then derivation algorithms that they run into basically just yeah kdfs through that they run into get out these keys that can be used for annotation but then for local adaptation what you're usually having is this like really neat like a challenge process where I say a is trying to prove to B without the program here right it's running in The Enclave right B would send send over the MRI Enclave here your report is basically a command that allows a to generate a report or response right to the particular challenge that he is sending over and the challenge itself is not being described here but then you can think of that as a whatever challenges you may use for example you're not easy help and exchange protocol and then the response is being sent back here has been being verified by by B which who also gets a key using the egad key command and then yeah like he does the processing rewards right where basically at this point you'd have a secure Communication channel being established between these two applications this is for remote allocation obviously this is like much more complicated compared to localization but in the high level idea is very similar one of the major differences here is that first of all I mean this entire process is being run in the thing called provisioning Enclave or PVE where you're basically provisioning against Intel servers with this particular so whenever you're doing the other station against Intel servers you'd use this epid or like enhance privacy ID thing which is basically used by Intel to kind of like verified that you're actually an enclave that has you know previously registered with them before right so you have Epi groups that are created based on processor types and then there's like a Anonymous signing process here to make sure that whenever people are are testing here the admin information is not directly being leaked and then so epid is usually generated when you're first kind of like registering with intel if you haven't done this before right they would just like do it in the first time when you're trying to perform this process but then I think they do have once you have done this already right they have like like that they're basically putting like like basically the idea is that you don't have to do this every time when you're trying to perform like remote manalization your epid is being generated in the first time when you're trying to perform remote adaptation but this is actually so this is actually what is causing a lot of the I think um a lot of the attacks that for example the one that Andrew was previously working on right so Intel the thing when you're verifying your Hardware against Intel like their out of station service or is here is that Intel is usually slow in terms of like enforcing a lot of the patches for the recent hacks or side Channel researchers have discovered for sgx so this basically means that even if like patches have been released outside uh Hardware that haven't enforced these patches can still successfully verify against IAS right which basically means that I mean you do have like a little bit of client diversity there right you're not enforcing this upon everyone but then this definitely like increases the uh attack surface for your application and then so here here we're having a different set of um pipelines here through EC DNC signatures so here you're naturally verifying against intels out of station servers anymore you're you're basically testing against the Custom Security pipelines that's being set up by say for example your cloud provider right in this case it can be Azure you can even if you're running like some servers yourself right you can set up like a blacklist for example for the list of Hardware who haven't like implemented like particular purchase but here's a really neat the demo of I mean it's not a demo it's just a gif of how this usually works right but this it's very much the same as as it's just that instead instead of interacting with is you're interacting with the TCAP pipelines that you're setting up yourself and then I always I always forget this but then I think the full name for dcap is data center other station Primitives yeah this is one of the things that people ran about sdx as well right you know like uh for the I think the nine slides we've cleaned through there's like way too many you know acronyms and then all this kind of like whatever uh when you're getting to the developer tooling staff it's even it's it's a nightmare but yeah still storage so this is what Andrew was talking about right you have the ceiling with MRI enclave and then you have the ceiling with some Mr signer right so Mr Cliff is where like you're basically ceiling to the exact piece of Hardware there so whenever you're doing like an upgrade right you need to like do like whatever manager was describing there you have to there's a bit of overhead there so like I think in web 2 people in general prefer to use The Enclave the second approach but then definitely like under a blockchain setting this is not ideal uh some Andrew was describing but yeah this is a seal process you like you have some really you know just like words right you have you have you have some really like interesting we're like not interesting not so interesting comments here but yeah so for the development tooling right now we're having four natural extracts this is the Intel official SDK there's a C plus plus SDK there's a Ross SDK this is what we've been using T Club is more of a high level Computing platform in that aside from sgx they also supports like I think mdscv and the arm trust Zone but yeah like it's kind of like just like wrapping everything together right in this kind of like past model I guess or passwords like uh sorry infrastructure as a service where like people can just like run applications on top right a liberal like SOS or if like this is usually if you want to run something more complicated within an enclave right this is what you would use we also have a more concrete concrete example for this later but then the more like commonly used one is a grammar sgx yeah there's a few other like oculum you know graphing Etc sdx step this is very helpful for debugging Andrew just recommended this to me the other day but yeah like a lot of you can simulate a lot of like side Channel attacks here in research yeah so very very helpful tooling these are just like some of the common attacks against sgx here right for cash diming pages of brand shadowing and the speculative execution obviously I would say actually all five right they're very common you're like just like normal such an attacks against like normal CPUs right so Azure X is that just that I think one of the reasons is that because they're trying to have this like protection against you know your your OAS or like your wemms with like administrative privileges right so whenever these happen like the results are oftentimes even just even worse than you know you do like a speculative execution attack on a normal piece of Hardware but yeah I think we're a bit over time here so getting quick to what we're building at a new Workhorse fundamentally is bridging data from one a new layer to another like the first item layer here usually is some you know off-chain requesting data sources right it can be like your behaviors on Twitter Instagram Spotify Etc can be your bank account information can be your you know like your behaviors say for example you're trying to prove your behaviors on ethereum to like some optimism contact or whatever and then another here like the other end of the pipeline for our course is basically any custom like data Vehicles that's being used to host these information right it can be like Unchained like nfts spds or normal action trigger Oracle contracts it can be where firework credentials within the did system right can you can be like a centralized admin system like for example with some Singaporean government they have this like centralized education pass right so these are all like interesting experiments we're running there but then for this design problem itself right you have four steps first of all you need to authenticate someone's identity and then this is like usually downstairs like for example parsing someone's like probably credential like OAS and then you retrieve the data from like that third-party server right or whatever third-party server or like for example in the case of blockchain it would you'll just be like fetching that data launch on chain but this is usually where you need to access like establish a TLS session to sound my third party server and do your normal like https request and then you perform some computation and finally you feed that into like different launching vehicles um some of the primary design challenges here right so first of all we have the Privacy versus Integrity issue which is what exactly Andrew was talking about for ckp Generation as well right because you need like wallet Witnesses whenever you're generating these proofs and then when your Witnesses are basically private user information where user information that can only be authenticated in a private way it basically means that you know like you run into this like a price problem right if you just allow users to do this proof generation directly in their front front end then the user might tamper with data right I can change something before like I can even change my HTML copy for generating the proof image in my browser right so you need to guarantee the Integrity here as well but then if you do this a proof generation process through like say through a centralized server right you're just like losing your privacy there as well right so but that's why we have and then there's the decentralization problem there as well right if like you're using a centralized server to guarantee Integrity obviously you can't have a permit permissionless or trusted setup for anyone to run these nodes right because like uh everyone would be able to see like the user power information but that's why we have designed this like modular privacy layer here right so on top we have two types of zero large groups that are being enabled to protect user anonymity and then user data confidentiality right so like for set membership proofs or your normal like inclusion process rights whether you can do that through a network route accumulator where you can do that through like a RSA accumulator right you have different different implementation for this but in the high level ideas to decouple users like off chain and option abilities range tools are just used for basic like data decentralization right instead of having the exact number you're having like a wrench there but then to solve this problem right so we have two different kind of types of solutions one is based in tes this is the one I'm going to dive deeper into later so Andrew also mentioned this old paper but my professor at Duke a fan which is called tongue choir tongue choir is kind of like a more genuine purpose like authenticated smart contracted data fee problem it's there we do share like similar designs there but then for us here is more about like generating our truths within a secure environment where you can have both privacy and then Integrity guarantee and then the final solution there is a TOS level NPC this is where you can run it in a front-end directly right with a browser extension do some you know wasn't based proof generation there's a paper behind a paper behind this as well called deco but yeah we won't be getting too deep into that day so sibo sibo is what we are naming our T based like I don't know where condos but then the overall architecture here right you can see this is like the clients right so someone is trying to fetch data from a confidential data provider right this usually can be you know just like some a third-party server here and then you're establishing basically a RTX connection here always a server that's been run within a Enclave you establish the connections here there are like some additional steps for you to like fetch the data here do some computations here and then like send the data back we have a local attestation enabled here as well right so this is for remote allocation right because whenever your client is trying to interact with the Oracle node that's being run in The Enclave I mean we're gonna we're the TRS server at the ti server that's been run in the enclave in The Enclave you need to ensure that it's an actual Enclave but then we also have this a local attestation thing where basically we're running a library OS within the second Enclave to do the proof generation because right now we're doing dkp generation with circum and start.js so to run efficiently run JS within sgx we're using a second long-class but then you can also abstract this layer out and then put that into you know another another like uh server rather than you just do like Remote application instead of localization we support both ecd essay and epidid other sessions right so this would allow us to have like more custom easy AP rules against like the Intel station service over um which is something that Andrew and dummy Ling are are especially obsessive about it's not super super yeah it sounds like extremely relevant to our use case but then because we're running a https server here right there after like certificates that we need to protect and then ideally for for to achieve like forward secrecy right there's there are some like some of these private Keys you want to rotate whenever you're doing a new session right but then right now we're being lazy so like their stuff I mean there are keys that we're using for like two days or three days so that's why we also have like a really simple layer of over and there it's just like the uh most I think basic square root or Ram which is a paper proposed like in back in like 19 1980s or something yeah like 20 years before I was born so it might not be super super robots in details but yeah like this is like the proof generation has been done here right with within the level s and then we also have like the server setup with some non-blocking aisles this is a really cool rust Library Mio I was used to it like enable yeah just like in general not blocking those but yeah so I know we're running out of time so a brief kind of a rundown of how the handshake process works right so the clients this is just a normal TLS connection but then there are elements for remote accession that's been integrated here through the swag interaction with the server which generally keep here for Signature the quote that's being produced here from the coding Enclave this is basically what Intel is calling their reports whenever they're doing like remote accessions rather than YouTube like IAS or like your tests are like is or like dcap right to make sure that all the server is actually you know running in an enclave right and the report is being concatenated into the certificates that's being sent back to our client and then the client would verify basically Intel Roots Roots CA where I will verify that as a student report and then yeah I would also get the public key for the student report and then this is where you when the client like basically you're done with the handshake page right this is like you know normal like TR session you you first go through the handshake phase and then you do the you do the actual query right so here you're just like for example here we're just like trying to query whether uh a user has a balance in a bank that's for example within this particular range right because we're doing like a TK Rand proof here right so send the query request here right and then the the server like The Enclave would come check the query in the contract the full request body you know and then send their relevant credentials here right it's responded and then yeah we would have the CK rental being generated here and then a code is being produced from The Enclave alongside the for for the report data that's going to be sent back to the client as a part of The annotation and then share like you need to do the finalization generation and finally yeah it just goes back to the to the client I also have a really short demo here as well let me quickly show that yeah so how can you scroll yeah this is the query we're constructing here and you can see this these are resolver the other stations there's a few like different signing Keys here right this is this is the sending Keys that's corresponding to the certificate for the for the for the uh Enclave for the server that's running in The Enclave running the enclave and the other signature is created by the private key that's generated the procession rather one I was talking about to to like we ideally we need to rotate that per session for for secrecy but yeah this is pretty much it for the entire presentation I know there's a lot of things that we're talking to here let me get this here so slice you can scan this right and then on Twitter yeah I mean just like showing our company for like 30 seconds Andrew please but yeah yeah so on Twitter I'm a dolphin this is my Twitter click we recently we're the second we have the second second highest of the Au optimism check our company out as well we're doing some cool stuff uh and then yeah and slide you can scan over here there's much more information that's plugging the speaker notes that I didn't have the chance the time to go through and this is my paragraph repo um [Music] I feel like it's more it's more the former compared to the yeah yeah but I mean if you're running on Azure it's easier because they have their like I think DC V3 and DC V2 like they have like different I think so one of the two only supports IAS but then the other like you have the actually it's not as is one of them only support the d-cap data in Asia sort of Microsoft is running the other where you can have like more customizability where you can set up your own decaf Blues as well yeah but I mean right now we're just using that to like you know have a blacklist of like Hardware so good questions 