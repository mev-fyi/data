cool thank you for having me this is a really cool discussion um I'm going to talk about ta based smart contracts um my viewpoint here is a little bit different than on uh I finally understand now what this point of suave was how you're viewing a flashbots on uh sgx as a way of having an encrypted mempool to you know do the Mev but this is still like going to then produce bundles of blocks that get published on ethereum in plain text when they're finally committed um what I'm the perspective I'm coming from is how to make privacy preserving smart contracts um so those who don't know me I'm from ic3 and a researcher at UIUC and I work with zcash Foundation I'm also starting a new Venture called honey badger cooperation labs and something we're doing is building a zero knowledge credit Network application on top of te based smart contracts I'm putting out that there just so that you know off the bat you're not trying to guess where I end up at the end of this uh I'm in sgx anti-e Optimist um but you'll see the the nuances and what it takes to get there even a little more background on the perspective that I come from my research directions for the past decade have all been about privacy and functionality added to Smart contract programming smart contract programming is what I care the most about but I've kind of followed this progression of doing everything we can with the simplest Technologies like just the plain text world just commit and reveal and then zero knowledge proofs I viewed this as like progressing you know down a more and more complicated stack and um of course what's been so interesting in the past few years and it's still you know booming now is just how pervasive zero knowledge proofs are through the like developers mindset on zero knowledge proof tools everyone's working on it all the big brains are doing um zero knowledge work improvements it's kind of diffused through the developer mindset smart contracts know that they're there what I've been working on though for the past several years and I'm basically all focusing on now are applications that need a more complicated platform for which the zero knowledge proofs and commitments stack are not enough and for those you need some form of threshold assumption or multi-party computation those are the same thing to me or you need trusted Hardware enclaves or possibly both and really my best frame of reference is the akitan research paper from 2018 I had a small role on that you know this was mainly the work of fan and Raymond and a bunch of other authors and this paper is the basis for the Oasis project although um uh ideas from here relate to a whole bunch of the other projects too so I'll kind of make some references to that as well um I'll say just a little bit because this is kind of clear from some of the talks that have come before and um I think Henry has a good way of explaining this I'll mention and maybe it'll come back later so I don't want to spend I want to get into the weeds a little bit about the details of uh sgx uh smart contracts but um I do think that there's a missing point to Smart contract developers where maybe some people get this some don't but then the line isn't so clear when is zero knowledge proofs appropriate for your application versus when do you need to make the jump to either enclaves or this NPC threshold the motivating example that I have for this is the issue of residual bids I think you could call this something like rev it's like more than multi-plot Mev but it is is kind of of that flavor you can build with commit and reveal an auction where at the end of the auction you know what the winning price was um but there's a lot of people that didn't win the auction and whatever their bids are that basically is forecasting their um you know unmet demand that might be a good predictor of their bidding strategies in the future so maybe the minimal information disclosure from an auction is just the winning price um if you build a commit and reveal auction then you're also disclosing these bids that were not met and that is you know strategic information being leaked and no way that you build a smart contract on uh for like Fair ordering or anti-mev techniques is going to touch this issue at all because it's inherently about it's not even about like Fair versus causal ordering because later bids may have depended on the the previous bids inherently um but still this like unmet demand is leaking to someone like to a manager or an aggregator if you use a zero knowledge proof based uh roll up um to make this kind of application and hide this issue of residual bids you have to build your application your auction application using MPC or some threshold encryption uh or or Tes and in general um I have a bunch of other ways of making this point uh let me go to this one so in general I view this as like a framework where you know you maybe use the simplest tools that you can only move your way up to you know enclaves and multi-party computation if you really need to but from the Viewpoint of prototyping it's really the other way once you get the idea of how you can do smart contract programming on tees it gives you so much more flexibility to Define your privacy and disclosure policies that I can't even imagine going back to being stuck programming you know in the framework that doesn't provide that kind of a fine-grained control um I I think that this point kind of needs better you know explaining to where smart contract developers really see where that limit is uh I think that the way that it's explained in the penumbra protocol is pretty clear um I think I'll move on though I have kind of like a spicy comparison table that places um the te based contracts what they're capable of along with all of the other Alternatives a couple of these are worth like going into describing but maybe only in the panel or if I get questions on it um I want to really move on to basically talking about you know where we're at with development of te based smart contracts and um you know the the kind of really palpable thing is everyone's concerned about sgx attacks we'll talk a little bit about that in a moment that's a legitimate concern of course um but my view is that we have swung kind of the other way it's like humorous how you know more people know that sgx is bad than they know any other details of it and so even though um you know this kind of like developer discourse that you see between consensus protocol involves variants of proof of stake and all of that and even now the zero knowledge proofs really detailed technical discussions that are carried out throughout our developer ecosystem for sgx it's not at all yet we're basically still just scratching the surface of even um you know repeating mistakes that we already know how to deal with from my perspective a bunch of mitigations and good ideas were already presented in that 2018 akiden paper and they just aren't yet even um you know have made it to implementation and they're even the onlookers who are trying to watch these projects aren't really spotting the you know critical features that are missing so my hope is really to basically Advance this uh developer discussion so we understand some of the details of what it means to have an sgx design not just getting lost on kind of the high-level trust model of sgx so to start with I'm going to talk at the kind of high level view of what the te based smart contracts are about and this is meant to be kind of you know Broad and vague such that it captures kind of all of them you know it doesn't have exactly the details and there are differences in details from them but this should give you the idea um in a nutshell smart contract tee just means you take the contract execution and that takes place in these uh secure sgx enclaves um practically what this means is that there's some secret key material that never leaves the enclaves but there's a public key that you can use to send encrypted messages to the enclaves so if you want to make a transaction in a te based smart contract system you send a transaction encrypted under the public key that corresponds to the secret key that only enclaves have um just The Enclave kind of exists you know on the processor it doesn't have that much memory available um so practically there's an untrusted storage that's sitting next to the enclave and The Enclave interacts to you know get and set values um to this untrusted uh database on the side and so this untrusted database on the side well the point of it is to be an encrypted database so all the keys in the key Value Store are encrypted all the values and the encrypted Value Store are encrypted that's the basic idea um besides just sending encrypted transactions you need some way to get you know some users are authorized to access their own account balance for example some outputs of contracts are published for everyone to see um so there's either events that get sent to you encrypted under your own address as an encryption public key or you make a query directly with um you know some interaction either way what you get back is the response from that query that would also be encrypted under your address that's the basic idea I guess the last component that that shows up at this high level is you also need some way of adding new nodes to the network and tolerating nodes that crash so it can't just be there's one you know Central Enclave node you need a network of Enclave nodes they have to have some mechanism that the new enclaves nodes that join those enclaves can get access to the secret key by some mechanism okay so that's the very high level View and that's really the only high level view of the um you know a diagram of this um that we'll get to but what I'll talk about kind of next on pitfalls you know uh uh pokes a little bit below this and I'll come back and you know refer to this um before getting to those I'll just point out a couple of details about you know what it is that the inner you know this is the the blockchain platform interface described but this is built on top of what The sgx Primitives themselves give you so you know understanding these two views is really what you need to have in mind in order to start um you know picking apart issues so um there is The Enclave um The Enclave has not the entire you know system memory available to it but um what it does is it can access more memory you know the processor has like at most 100 megabytes of memory on chip to do more than that you need to access Ram sgx has like a ram handling system so it'll do virtual memory with pages but all of the data on the page pages are encrypted there's also Integrity checks that are sort of built in by sgx so your enclave programs look like they have you know a big virtual address space you interact with an enclave by making e-calls these go from the untrusted operating system into the enclave and run some programs so for example you might have an e-call for processing a block of encrypted transactions you typically will have to have an e-call that starts up a new node by generating keys to communicate with just that node and begin on bootstrapping and getting access to other key material from the the network as a whole um in order to e-calls can't just generally be processed on their own they need to request further services from the untrusted uh operating system host to access a key value store for example so those are done through oh calls those are calls out to the untrusted operating system that's typically how you interface with the disk from an enclave um the last two concepts that it's useful to know are that um uh the memory is lost if the process restarts like there's no way to load the memory from a prior process if the Enclave process crashes so for persistence even just on one node restarting you use a thing called sealed files these have like CPU specific keys and basically you can write to the file store some secret data there you can read it back but only the CPU that wrote that file is the one that can read it this gives you kind of a persistence ability and then the last component That's essential to using these for disintermediation you know to make it so that you don't have to trust the validators or you don't have to trust the Mev um you know flashbot operator is remote attestation so this is where one of your enclave e-calls outputs a report this report gets signed by Intel and then the signed report basically has output from your e-call whatever it chose to put in the report data field and the hash of the program binary that generated it so this attestation report is kind of where the you know magic happens this is where you get a guarantee that this output was produced by some Enclave running exactly this program and that's basically the you know source of your root of trust so I want to talk about um some specific pitfalls and explain them in terms of the you know high level thing that I've set there and you know these will follow along with some um uh you know posts you can read more data um about these so the first one is the issue of you know what it is that you do when an sgx vulnerability occurs so sgx vulnerabilities have occurred in the past um over years there's been you know dozens of them they range in terms of you know how catastrophic they are to like all of the Intel trips or just some Intel trips and whether you can just get like the attestation keys out of a chip that's like the worst case scenario or something more mild um what happened with secret Network and apic leak was that um so Apec leak was the you know absolute worst case scenario for an sgx vulnerability this sum was publicly announced in August of last year but it had been brewing for nine months like the first disclosure from the people who found it to Intel was like in January um earlier in 2022 um so like a nine month period had had occurred um during which mainly like motherboard developers lenovo's hp's you know got kind of private uh advanced notice to be able to build on you know patches against it and um cloud services were able to you know try to to make their plan in advance for um you know what to do when this disclosure would be announced when the disclosure is announced it basically means okay anyone using a remote attestation system is um you know at risk of having fake nodes that aren't even enclaves generate fake attestations and show up um really the the what's called TCB recovery is what Intel calls you know what do you do when an sgx vulnerability is found and it involves you know releasing patches that you can patch to upgrade your own processor the problem with remote attestation is that your threat model or other people on the network who have not upgraded their processor um the best response for TCP recovery is something like shutting down all new node registrations um until you can enforce that everyone has updated their uh patched code in order not to be vulnerable to this what happened with um secret network is that they had judged that none of the nodes that could join the secret Network were specifically vulnerable to apic leak um but this turned out not to be true so when we went to basically look into this like two months later um it still hadn't been um shut off it was easy to join new vulnerable nodes to the network um and then so we were able to get some secret data uh out of it another detail about this is that um the akitan paper had a bunch of Concepts on it one of which was compartmentalization and rotation these are both hardening you know at the time the akitan paper was made this had already been after the first you know handful of sgx attacks so the need to prepare for a potential sgx vulnerability was already clear to us then the basic idea of compartmentalization is that there's not just one master key that everyone has instead there's a small number of nodes that together share master keys ideally even those uh should only share them in a threshold multi-party computation threshold encryption way and then worker nodes maybe get a contract specific keys on a need to know basis uh the result of that would be that if there were this break there would be a much smaller attack surface of nodes that could leak the master key and perhaps a larger number of nodes that might have a portion of data threatened but not the whole network secret chose not to have any compartmentalization for other you know trade-off reasons sure but the result was that you know this attack enabled us to get the master key to the entire network we're still showing on this sgx.fail site you know more details about how this works and like a demonstration like we can still decrypt on their test net transactions today um part of the response is you want to rotate your keys when a vulnerability is announced because you don't know for sure whether or not the prior data uh we'll you know tomorrow turn out to someone could decrypt all of it and goes and publishes on the black market so you should at least rotate your keys so that um new people using the network ongoing transactions aren't vulnerable if the old key is compromised uh so this is something that secret uh but all is developing as part of their rapid you know response to the disclosure that we made um Oasis is is um still uh developing this too and plans to launch their mainnet without that feature in um there's more to say about this also Tom my students one of the authors of this um and there will be more presentations about sgx fail so I don't want to go more into that I'm also running out of time so I want to say a couple of other things but there's a lot more detail on the yesterday fail website I'll go really quick through the summer signer because I want to make a couple of other points but I've eaten up a lot of time here um another thing that we had wrote about it and you can read about it on this on a post on the ic3 site but um there's a centralized developer backdoor that's built into some of the code bases and that includes obscuro and secret Network at the time although they're both um uh fixing this and it relates to how the ceiling data works so sgx Nitty Gritty details there's two options I mean they're not that Nitty Gritty they show up on kind of the you know learn to use sgx 101 website ceiling has two modes Enclave mode and signer mode Enclave mode says that only the exact same program binary that generated the sealed file can read the sealed file Mr signer says that any program signed by the code Developers can read the sealed file so that means if you seal the data with mrsiner which is what secret did and what obscuro did I mean they haven't launched but I looked in their code base and that's what they had when I looked at it that means that the code signers the developers have a master decryption key themselves they could just code sign a malicious program that dumps the consensus seed they have you know the key that they need to get it that way so this is like a foot gun cell phone kind of unnecessary mistake um maybe I will end after after this next one just because I want to say it on briefly but um uh in this picture I mentioned that the Enclave boundary sort of ends where the memory begins and the uh you know disk access through ocals begins well this means that these you need to be concerned about access pattern leakage so um you know the the secret developer documentation says that when you access the key Value Store from a smart contract okay it's a key value store so the key is encrypted and um the value is also encrypted um so that's great but that doesn't reveal the contents of the key but it'll still be apparent to the untrusted operating system if the same key is being accessed uh or not so if you write to an account balance this is something that like you know snip 20 tokens have to do what you want is that you can't tell which account is being written to but what the interface gives you is that um the access pattern is revealing that the same account is being used from one track transaction to another or not that's a problem and the only solution to this problem or the only solid solution to this problem is to implement an oblivious Ram algorithm this is something that could be added but it's something that um none of the different smart contract based systems um you know currently feature at this point um in principle you need to do this not just for your disk storage but clearly for that you do need to do it for your disk based storage but you also need to do it for your memory accesses because the untrusted operating system gets to see which pages in memory are being accessed so you could learn if smart contracts are stored in different spots in memory and you're just using the virtual memory system that uh sgx offers you're leaking an access pattern that very well may you know lead to the difference of telling which account just received a transaction or not um what else did I want to say I might cut it there so that I have five minutes for questions I have a couple of um other you know ideas that are about things that could even be um I I basically I mean let me just kind of do the summarize for this right so I mean I think that we're basically at the extremely early stage of um kind of developers awareness and understanding of the the details that go into sgx I'm sure we'll talk about the panel about the high level you know trust issues you have to trust Intel you have to be aware of the potential for further attacks but there's a lot of other kind of you know um defenses and good ideas that could be built into this um I'm really a fan of this idea but I won't be able to explain it in this talk but that is that you should be able to have applications defend their privacy rules even against the code signers and even the majority of validators shouldn't be able to make a hard for it to change the rules like the Dow hard Fork was obviously the rule change in order to cause a change to the application functionality with Tes you have the ability to make applications that can defends them themselves even against the tyranny of the majority of the chain that they're running on hard forking um so yeah I'll end it there and see if we have any questions thank you Andrew um very interesting technical uh Deep dive into sgx I mean one one thing that I've been wondering about sgx is um why why do remote assistations have to you know go through go through Intel like why does Intel have to sign the transcript the the report like wouldn't it be so much easier if uh basically transcripts or reports are signed by the The Enclave key that's unique to this this one CPU um and and then Intel just tells you what the list of valid Pub Keys um are uh those that that are trusted basically at any given point in time I mean that that's nearly how how it works I mean so a slightly more detail about how remote attestation works is it's split up into what's called a provisioning phase which kind of necessary necessarily involves Intel but you do that once per chip you don't have to do it for the different applications that you run then there's the attestation step which in the default setting that secret and Oasis currently and I think that that's the case currently used it does every attestation goes through Intel again as well through the Intel attestation service there's an alternative called Decap where Intel is still involved in the provisioning process but um you know someone else can do the the second step of it I think that that can be made in a decentralized way but I don't know the details of dcap so well um the important thing is that um you will have Intel still be required as a kind of point of trust for at least the provisioning phase but there's no reason why Intel needs to be able to um uh say you know block some applications or block other applications or not and that's something that using the Decap alternative almost certainly um you know avoids the need for so even with sgx today you're not necessarily as reliant on Intel as the current software projects and make it seem okay great decentralized D cap sounds interesting any other questions from the audience good question uh do you have any opinion on the just recently released TDX system from Intel which is kind of like uh a separate but similar system to sgx yeah I I've heard about it I don't have any um thoughts on it yet my first question so one thing that I've noticed is that there's a a kind of huge uh gap between what I want from remote attestation and ntes what we want for these decentralized applications and what the kind of bread and butter use of sgx is so the the standard cases it's a two-party versus three-party thing like the standard case is there's a developer and there's an untrue the cloud provider and you don't trust the cloud provider but you the developer are the one who puts the program there and gets the result and that's it there's just the two of you so very simple remote attestation can work for that and I think that TDX is a good fit for that what I care about is this three-party disintermediation world where there's a service provider in the cloud sure but there's a developer as well and the developer is also not trusted there's clients who you know don't want to trust the developer they only want to trust that the enclaves work the remote attestation that sgx provides fits that kind because you you don't have to be the developer you get these like portable signed reports that you can use to know that you're you're talking to an enclave on the network running the right program I couldn't tell from my first look at TDX whether it supports that or not but my sense was that it doesn't if it does then maybe that would be a good fit I had a similar kind of concern in working with Sev this may I only know sgx as well I mean and even that only so well so it may be that it's possible to use Sev to do this but my understanding was that you could not get a attestation report that's sufficient from Sev to provide the kind of guarantees that uh uh we want out of this for the smart contract setting so that's my view now but I'm not very knowledgeable about TDX or Sev so that might be wrong there's a there's a question in the chat maybe Jonathan if you want to ask sorry Justin yeah I'm sorry I have a second oldest Mev Rose participant here next to me so I apologies if someone is crying um I was wondering about the the diagram you showed in the beginning remember um on the using Tes for smart contract execution but do I have to send my or um encrypt my transaction with the public key of a specific validator or is it uh say a um the same secret key public key pair for all tees in the in the Wildlife network so it's a little more different than that but only by a little and it's um uh there is a little bit of difference between the different systems um and I've just said these different systems but I have on my mind like a secret Network already has launched their main net Oasis Sapphire is an evm based smart contract chain that I believe has not yet launched their mainnet but you can use Oasis Sapphire on a public test Network and obscuro also is meant to be an L2 for ethereum um that has this weird policy where like all privacy is canceled after one year so it's only like a temporary privacy just the policy that they have that also has a public test Network and so that's you know running adjacent to ethereum so I kind of say like those as like the the whole industry of these so with secret Network there's really only one master key that all of the enclaves share at a slightly lower level detail there's like per contract derived arrived keys but you can derive all of them from the master public key and so you send your encrypted transaction to the public key associated with that contract but there's one master key for everything that everyone has so it's kind of you know the same as this diagram effectively and then an oasis not only do you send your transactions to the key associated with the particular contract but the worker node that is you know proposing the block or whatever carrying out the execution for that only gets the key from the key manager knows they only get the workers only get the key for the contract that they have to process at that point so um it kind of limits the attack surface and you know the amount of contracts that would be spoiled if uh uh you know one of the worker nodes is able to break inside its own Enclave 