excited about today's program yeah well shall we start sunny all right so alex maybe let's wait like two two three minutes just for late uh late commerce i don't know what i mean maybe i have the wrong time on my computer it's 31. oh no it's 33 on my phone maybe at 35 we start in like two minutes yeah it sounds good cool awesome well um while we start uh while we wait uh we're going to go over some housekeeping so for today's session um the roastmaster is sunny the reason why you call it a roast is to make it rowdy and controversial doesn't mean you have to be loud just means that please feel free to ask your questions um or raise your challenges any time and you could um do it in the site chat also this um everything presented in the uh uh rose today will be public uh it is public in fact so if you need the site link uh the the link to the slide deck alex if you don't mind we can um share it with the folks here so uh just a bit of a background uh mavi rose is a tradition from flashbots and we are a research and development organization formed to mitigate negative externalities and no longer just existential risks posed by meb to smart contract blockchains and you can find out more by reading our medium post where we does uh introduction to mev and articulate value of our organization and um in in first half of this um and in the rose today our roastmaster has proposed three key questions for us to cover one how is privacy relevant in reducing mev two what are the trade-offs between privacy solutions at the memphis layer and three what is the optimal privacy solution to create a seal-bit mev option for l1 and l2 architecture and so i guess we're at time so we shall start the question today will be split into two parts first um it will focus on privacy to minimize mev and we'll start with a presentation from sunny that surveys um the existing private solutions and where privacy meets meb and then followed by three presentations by um potentially two depends on i guess whether sunny wants to share the bit about threshold description up front um right after your first presentation and um the second part of the project of the mev roast will be very dynamic and interactive um our navigator phil diane will share a brainstorming deck and kind of walk through our discussion in um how to um achieve full privacy in creating a 0bit mv auction so let's start sunny do you want to present your screen yep give me a second um alright can people see my screen yep sweet alrighty um so i'm just going to go ahead and talk a bit about uh you know the focus of the conversation today is on um you know how we can use privacy techniques to help reduce mev um that's an old thing uh so you know why one of the things you know this talk is gonna be mostly focused on mev minimization uh and then i think later in this in the you know discussions we'll we'll talk about how we can use some of these techniques for like the mev auctions but you know why is mev minimization a like desirable goal well you know mev has a number of side effects to it um and i think mev auctions help mitigate some of the side like externalities but if we really want to like attack all the problems at once we really have to figure out how to like reduce the total addressable muv altogether and so you know what is mev i think that i think the way you know um i'm sure a lot of people in this call are already pretty familiar with it but you know just as a quick recap basically what we mean is any sort of edge that an individual minor or block proposer can get that does not need coordination with other proposers so you know water and you can think about to think about this you can think about it in terms of what are like the sort of powers that a block proposer can single-handedly do uh these include things like you know reading transactions from the mempool they can choose which transactions get included they can choose how to reorder transactions um you know uh you can do like consensus vote censorship this include in the proof of work this takes the form of things like selfish mining in proof of stake and or bft things it can take the form of like uh vote censorship um and you could do uh time tracking style attacks and so because today we're focusing primarily on the privacy focus we're gonna talk specifically about what are the mev attacks that can be done with the ability to read transactions from the mempool and how we can and then three solutions for how to mitigate them so the two large main classes of attacks that can be done using the power of reading transactions from the mempool i'd call them censorship attacks and ordering attacks uh censorship has that you know asterix is not all censorship attacks would fall under this um same with ordering attacks not all ordering attacks as well but by censorship attack we mean things like you know uh the ability to censor someone from making payments or but also like you know the ability to censor someone from doing a challenge on a payment channel close for example and so you know this has like monetary value because you could you know steal value from someone if you can prevent them from uh being able to challenge uh certain things um then ordering attacks you know we have the front thing like front running uh you know i'm going to skip this section because i think most people here are probably familiar with like what front running is basically you know a proposer can go ahead and add their own transactions into a block uh in before uh alice's transaction in order to somehow profit off of it um then on top of that we have things like dark forest attacks which is you know something dan robinson and georgios uh uh coined but essentially the idea is you know you can think of it as a basically an on-chain puzzle which it will give you know five dollars to whoever's the first person to show the solution to this puzzle and alice can go ahead and you know she's clever and has figured out the solution to the prop to the problem and goes ahead and sends a transaction with her solution to the block proposer the thing is the block proposer can always just look at that uh copy it and then put her solution in their own transaction and because they have the ability to choose ordering they can also make sure that they're always going to be the first one in the block and they're going to win the money and you know here it's kind of like a simplistic thing where i just said you know a puzzle but you know you could think about this as like you know any sort of arbitrage opportunity and you know this is sort of where the whole nav state space searching comes in which is i think the topic for the next uh roast but you know simplifying it and just calling these all puzzles where um yeah and so basically if we can mitigate both of these attacks basically rely on the ability to read uh the user's uh transaction data in the mempool and if we can stop this that then you know we solve this problem all we were able to mitigate both these ordering attacks as well as the you know censorship attacks we mentioned before and the best solution that i know of is encrypted transactions some way of encrypting transactions in the mempool so essentially you want a way for alice to go ahead and submit a encrypted transaction uh that's unreadable to the block proposer the block proposer and all the you know ideally all the transactions in the empool are encrypted the block proposer would have to put together a block with the encrypted transactions have have the system come to consensus on the encrypted transactions and then only once the order and you know inclusion of transactions are committed to we do some sort of magic in order to decrypt the transactions so then they can be executed um now the question is how do the what is this magic what are the options for doing this magic so there's basically three main methods that i'm familiar with um which i what i would broadly categorize as trusted hardware time lock encryption and threshold encryption so you know and we want to kind of lay out some of the trade-offs uh between each of these uh solutions so and these are sort of the uh categories that we're gonna use to like uh compare and contrast this different solutions so what is the security of the model uh what kind of delays it causes on execution what kind of delays it causes on consensus and then just this catch-all other thing to you know catch other things um so trusted hardware well trusted hardware you know the simplest way to put it is you know what happens is you have all these encrypted transactions you go ahead and come to consensus on them and then the uh you know ceo of intel comes in and does some sort of like black magic that no one knows how it works but you know you just trust them because it's intel and then it gets decrypted and it all magically works um you know this um so the idea would be that like you know every miner or validator would have an sgx and they have a protocol for sharing an encryption key uh that's only accessible in the sgx and then all users will uh encrypt their transactions to that shared key the sgx can then verify uh certain properties about the transaction they can make sure that the fees are correct you can make sure the signatures are correct they can make sure that like you know they could they can do the nice thing about the sgx is you can do all sorts of more uh stateful checks you know uh that might not be possible some of the other solutions um and then you can output the block cache uh for validators to come to consensus on so in this in this one i kind of uh was focused more on bfp consensus but in the proof of work situation oh actually i have it right here in the preferred situation uh what would happen is they would basically submit a all the encrypted transactions to a miners sgx the miner can then and the sdx will just spit out a block hash uh for the uh miners to start doing their proof of work on um and then once the miner has found a valid proof of work they can submit it to the uh sgx and the scx will give will give the miner the unencrypted block data so that they can uh broadcast it now yes the miner if they wanted to they could um go ahead and like you know once they get the unencrypted data from the uh the sgx they could choose to ignore to start rehashing it and like you know insert their own transactions but you know they'd basically be having to do twice the amount of work because you know they had already won the previous block and could they're basically foregoing that block reward in order to try to get the mev and so um if the mev starts to exceed the block reward this could uh turn into a bit of a problem um but you know yeah uh so pros here one of the nice things is is it can be easily done as an opt-in feature uh it doesn't need any sort of protocol changes like you know individual miners or individual validators can basically offer this as a feature to people who send transactions to their mempool um the cons though is you know it's not a great security trade-off you know breaking the sgx has like you can you you need to think of it in terms of economic costs and you know the rate at which sgx bugs are being found and like being like sex like security bottles are being broken you know you could probably throw a million to 10 million dollars at it um and probably be able to find some vulnerability and like be able to break the privacy and if the value of you know the profit to be made off of breaking the privacy model of the sgx like is worth it we can expect that uh people will start doing it um and so you know this is something i will get into the discussion uh afterwards about like you know how we can start to think about this security model um so some of the tradeoff so the trade-off summary here you know cost to break the sgx not that great uh but you know what's nice is it has no execution delay you can uh go ahead and start you know executing in the same block uh as because that because you can actually do sgf uh execution within the sgx which is nice um and then consensus time it slightly delays the minor uh which could you know lead to more um you know a little bit more forking and stuff but it's not that big of a deal uh the and finally the nice thing is that there's no protocol changes required next up we have time lock encryption timer time block encryption basically is constructing a cryptographic primitive that basically says okay we have something encrypted piece of data anyone can spend enough time like doing some operation that on this data and once you do enough of that operation then it like kind of breaks open the encrypt unlocks the encryption and now you have the decrypted data and how you can use this is uh to to minimize nav uh is basically what would happen is people submit transactions encrypted to miners mempools the miners would include the transactions in blocks and then on the side they take out the transactions and start running the process to uh decrypt them now time will go past and you know a couple of blocks will go by and then finally you know after a certain uh period of time the uh transaction will be decrypted and then you can take that decrypted data and submit it in a transaction and then it gets executed so the key is the what's happening here is the um there's a quite a high noticeable delay for transaction execution so whatever the uh time lock uh period is you can't actually execute the transaction until uh that is over and and this delay actually has to be quite significant because um yeah so the the delay has to be quite significant because you want to avoid the situation where you know it's impossible basically to like guarantee that this time lock thing takes a certain amount of time because you don't know what kind of hardware or like asics that uh individual miners may have developed so you need to make it have a sufficiently long time so there's enough buffer uh to give you the security guarantees um on top of this all transactions have to use uh the time lock encryption so it's not an opt-in feature so like with the scx for example you know some transactions can say i want to go through privacy and other you know payments for example you know maybe you sometimes actually might not care about the about like the front running resistance but in the time lock encryption you kind of don't have that choice everyone has to use it uh which and you know has to bear that uh execution delay which could make for some pretty poor ux um and then finally you know if you can prevent the transaction from being included in uh the encrypted transaction from being included in a block for long enough you can decrypt start decrypting the transaction um while it's in the mempool and so you know there's nothing to say that hey the the time lock can only start once it makes it into the block and so if a group of miners are able to keep the transaction out of a block for a while they can actually start the time lock process and perhaps even decrypt it before it gets included into a block um so yeah so mab security uh it's kind of like a yellow because it basically is a trade-off against the time delay so you know if you want to say that like you know there's only a minute of time lock delay you're going to lose a lot of security but if you're saying hey the time lock delay you know we're putting it at sale a couple hours then you know maybe it's a higher uh trip uh security and so it's really the sliding uh trade-off uh the execution delay is quite high as we talked about uh it has very little uh impact on consensus time itself uh but then once again the con is that it's not opt-in um finally the third solution that we want to talk about is threshold encryption um which is uh so how it works is let's take a normal bft consensus system so what's happening here is you know you have all these uh you know the block proposer has created a block proposal sent it to all the validators and then all the validators would normally do some sort of vote send it back and then you know you use all these votes in order to lock the block and you know commit the block well how threshold decryption would work is you'd basically say here's all these encrypted transactions um each validator would have a decryption share and you what would happen is you know you use special cryptography to basically say any you know two-thirds or whatever fraction you want of the validators can come together to decrypt uh all the transactions and so what happened is along with their vote you would also include a decryption share and their vote would be invalid if they don't also include a valid decryption share so what's nice is um then you could do this and you know you can use the uh votes to come to you know commit the block and now but because the votes are only valid with a decryption share you must by definition have the decryption shares that you can then use to uh decrypt the transactions and so what's nice here is with the threshold decryption it guarantees that the decryption transactions happens atomically with the committing of a block and with the executability of the transactions um and so the med security is actually the security is quite high it basically gives you close to equivalent security as consensus there's like you know there's a little bit of a shade of yellow there just because um you know there are some asterisks is there you need to like add in additional things to make sure uh make sure that you know validators don't share the decryption shares out of out of band without sharing the boat so that uh but you know there's ways of mitigating that um finally the execution delay um you basically get a one block delay uh because you can't execute the transactions until the very next block they have to be at you know so that that is one uh but you know it's not that big of a uh execution delay compared to something like time lock encryption um you get quite a bit of increased bandwidth uh because you know some these decryption shares could potentially grow to be pretty large and so it'll have some impact on the consensus speed and the biggest con here though is it really only makes a lot of sense in my opinion with classical bfg consensus like you'd need for threshold decryption you need some committee that basically is the one who decides whether a transaction you know gets decrypted or not and the most logical place committee to use is the validator set because you can use that you know if you design your threshold decryption system well you can make it so it's atomic such that uh decryption happens atomically with transaction execution which is something you can't do with time lock encryption um but you can do with scx which is nice so yeah that's basically uh a nice sort of overview summary of the trade-offs of the different the three the three main schemes for how to get uh privacy at the mempool layer um and yeah so i'd like to open it up for like questions and whatnot uh and just open and just general discussion you know are there any additional trade-offs that you know maybe i didn't talk about or anything like that doesn't do you want to answer questions or make a comment i see you um commented on the side chat oh yeah so i just i think sonny actually mentioned this so i i just feel like the comparison between time lock and threshold inscription feels like the in the blp when you have synchronous protocol versus partial or asynchronous protocol are you whether you wait for some time versus whether you will vote for wait for a quorum uh and but i just think that the latter the strategic aspect of the uh of the latter seems to still still be an open question this is my top so so can you can you explain a little bit about what you mean like how what do you what the analogy is here with synchronous versus asynchronous bfd because in a asynchronous uh bft right so like you wait for some time well like for example like so so because like i wait for 10 minutes after 10 minutes like if i don't receive that message that means that you didn't send it then i can do my consensus based on that but then it goes in those partial synchronous protocols right so you wait for two-thirds of the vote it's like i feel like there's like the threshold encryption so that's the analogy i'm thinking about so it might be a bit maybe more like synchronous versus like partial synchrony yeah yeah yeah yeah yeah exactly yeah yeah still i can't be sure how many agreed on the threshold signature so it's uh yeah there is some asynchrony in that as well um so i guess again start looking at some of the questions in the chat box i have one one one question on um the the time delay that you would have with time lock encryption what would be you know implications of that in terms of you know looking at some of the applications we have today on ethereum for example and how would that interact with for example you know i'm thinking of price delay and how they would interact with like centralized exchanges price as well right because like their notion of time would be would be different than this new notion of time so like right what would be some of the implications there yeah i mean that that's definitely uh something yeah that's something i didn't think about i was thinking about it mostly in terms of ux where it's like you know all transactions are delayed by like i don't know let's say 10 minutes uh and this would be a poor ux because uh yeah yeah you know because you know one of the nice things about using ethereum is you you have the potential to have like much faster execution as opposed to something like bitcoin but yeah this could actually be a big problem where if the time delay is like on the scale of hours then you know any a lot of d5 things that depend on price oracles and the like would like you know basically always be lagging somewhat from the uh real the real prices um one thing that might be one thing with the timelock you know maybe some caveat i didn't mention was or maybe i should clarify is you know if your system if your protocol has a little bit smarter knowledge of like different types of transactions you can make it so some types of transactions are opt-in or or like or don't have to use uh time lock encryption basically you know you could say that maybe price oracle updates don't have to be timelock encrypted um but meanwhile uh you know all trades or something have to be timelock encrypted and so you know if you do have some smarter way of like segmenting transaction types then uh you could do that um and so it really depends on like the transaction types that don't have to follow timelock encryption you could you know it depends on if they suffer from any sort of you know the if if they're vulnerable to any of the attacks that i meant at the beginning if if if price oracle updates aren't really uh subject to being front run um well it's not that it's basically anything that can be used to front run has to be has to be uh subject to time to the time lock delays so if the price oracle update itself is not can't be used to subject something to uh front running then you can make that instant but i don't know if that's true there's probably a lot of cases where you can use price oracle updates to like front-run things it's also not clear like what's the impact on defy if uh you know you have the price oracle updates come in later to get the live price oracle at the at the given block but all the transactions were executing there came from an hour ago like how does this impact finance system if all transactions are executing an hour in the future but with the price an hour in the future i mean if it feels like if there was one unique notion of time then it would be okay right it would just be like everything is delayed and the price just works that way it's just that because you have like centralized exchanges as well and like price is there that's where it gets you know more more more messy because it's like being on different time zones kind of um yeah that's so that's cool thank you um i see stefan asked about uh what does threshold without bfp look like uh can it happen on l2 plus ethereum so uh dave doing maybe answer that one yeah sure uh so yeah you can uh totally do threshold encryption on like l2 plus ethereum uh it's just slightly unclear what's your uh so the security assumption threshold encryption is that a given threshold of them does not collude so it's like why do you believe this given threshold for this l2 committee in proof of stake you kind of have this easy answer i already assumed this for security uh so you're always making additional assumptions if you are using a different committee and you just have to have a compelling reason for why a threshold security assumption makes sense in that setting yeah and a lot of the slashing conditions that we built in you know to like prevent uh sharing of threshold shares like uh out of protocol in order to slash people they can also be done on like you know in the l2 system as well um really like you know as long as you can use like some sort of bft system with your l2 then it should be fine and most l2 systems should be able to you know work on some sort of bft way well oh sorry one thing that's kind of annoying about special encryption that is that uh you actually can't have flash conditions against a sufficiently advanced uh adversary or adversarial set because they could always like condition's basically like you want this way of preventing a cabal by saying that uh i can if you suppose you give me a subscription share when you shouldn't have i can report this and then get you slashed but we can do all of our intestinal description sharing in an sgx so this like prevents me from ever sharing it publicly yeah and so you could have this validator set like basically adversarially decrypt early in an sgx and front run together so if you assume this highly advanced start model of i don't know just how advanced it is you see the start model of like your threshold special that's colluding with uh using spx's then we actually can't slash impression description which could be a problem uh it depends on like how good is the threshold like how sensible threshold assumption in the setting i guess uh one question i have is like how do you view these techniques interacting with mev as a metric like is the goal to reduce mev to zero or is there still going to be some with each of these techniques and like how does it compare in its effect on like the empirical mev quantity uh yeah so i think you know like i mentioned there's i think mev comes from like you know all sorts of powers that the miners or block composers have and this these privacy techniques are really meant to just solve uh that first power which is the ability to read transactions from mempools and so you know i think that will i mean i don't know any numbers off top my head uh but like you know i think that that will actually probably solve a large percentage of the mev but definitely not going to push it to zero and you need you do need to solve um all these other uh powers and as well as any other powers i may not have listed here um and i think like i think uh you know the ones that are probably most related are probably the ability to stop the ability uh ability to like control inclusion of transaction the block proposal and the ordering of transactions the block proposal so you know you can use like randomness techniques uh to like prevent the reordering of transactions and you could uh choose you know there's other techniques we have for how to like you know make it so one block proposal can't have full control over which transactions make it into a block or not um so yeah these solutions alone don't put meb to zero but they're part of a larger toolkit of solutions that can bring it probably not to zero ever but as low as possible yeah i guess two other very quick uh like meta comments on the properties you chose since you asked for feedback on those i think two i would also think about is like the cost to generate the proof so like if that's super expensive for like the user or not might make a difference in some apps and also the backwards compatibility with uh like or universality i guess like can you use it on existing l1 uh existing l2s does it work on both will it need to be tweaked as it's like applied or is like i don't know what the cleanest way to express this but basically like how flexible is the the actual deployment yeah that's i was trying to kind of get at that with the you know with the other category at least with the sgx and the threshold i think one of the nicest things is the sgx is probably the most universal it can be it's like the most backwards compatible uh while the threshold is sort of maybe you want to go less backwards compatible where it it does make pretty strong assumptions about your like consensus protocol for example um and so this is yeah that's one and then yeah definitely the impact of like you know users like you know yeah there's a lot of you know oftentimes there's things that we don't consider like you know z hatch you know it has great privacy but then you know sometimes we forget to think about oh what impact does it have to like like clients for example um so yeah i think that's definitely a good um additional category to think about as well i think one question i really have for flashbots and for l1 mev is like is sgx the only universal solution and that's kind of what i'm gonna i guess cover in my part of things but i think it's a cool thing brainstorm like can we have other solutions that have some of the nicer properties of like time lock or threshold but and don't need sgx but also have the same backwards compatibility um right i think the open open research question i guess yeah oh on the question of like you know how long does it take to actually threshold encrypt as a user that's still that's pretty comparable to uh like signing time i don't know about time-lapse encryption though uh there's another thing that uh you know an interesting thing to think about on impacts to users is um oh i mean this slide has it incorrectly but you know earlier i said uh there's a zero block delay for scx execution but you know there's a one block delay for threshold encryption and like a you know longer delay for time lock encryption the fact that there's a zero block delay until execution a lot you know and currently in ethereum you get charged for gas used not gas requested but if you have a one block delay on execution now it does complicate your gas model because you need to sort of start charging for gas asked for so like you know whatever the gas limit you put into uh not just on gas executed you know you can potentially combine this with things like eip1559 and then like you know give partial gas refunds so you can basically say like okay we're willing to refund up to you know 25 of your gas asks for uh if but you know it that is definitely something that will be have like a user facing impacts we have two more presentations and then uh we have a interactive workshop that i feel um that dives deeper but feel free to have more questions leave them on the slide chat and we will have discussions in between the presentations so uh dale would you like to hi eli hello hi um okay hello everyone can you see my presentation yes yes now yes great okay uh great so uh hi everyone i'm yael i'm a product manager and researcher at starkware and today i'm going to present a video timelock uh which will uh hopefully rescue us from all the this mev unfairness okay so uh first of all why time lock can be a measure to eliminate mvp so actually sunny summarized it very good in the mempool transactions are public and there are some entities like miners that are in powerful position and they can decide if to include transactions in the block and how to order them so uh the the fact that the transactions are public let them do that and exploit some revenue opportunities but once the transactions will be locked uh time locked and at the moment of the ordering of of the block these entities won't know what what to do in order to profit from mev uh this can uh the the mev will be uh an extra extractable so what is video a video time lock is based on a delay function f which is very long to compute it is sequential computation and its inverse is fast to compute and besides that everything is also a vdf for randomness but in in this talk i i will only talk about time lock how can we uh generate a time log commitment using vid so if i want to commit to a value v i need to apply the inverse of and the delay function f on the value v and generate my commitment to reveal the value one has to compute the delay function f and you will get the value v that i committed to anyone can verify the computation of the of this delay function of the reveal one option is to compute the inverse function and just to see that you get back from c to v i mean from v to c and the other option is to generate a star proof that attests to the validity of this computation and the start proof anyone can verify it very fast in in logarithmic time and a smart contract on ethereum can also verify it and register it for future queries so how can video video rescue us and improve the the mev problems i will now present two approaches for possible design using vidu the first approach is time locks is part of the protocol layer which means that it requires some changes to the protocol and the second approach is based on smart contracts on ethereum and is fully supported today so i will describe the first approach and then probably i will cover some of the second approach okay so uh the first uh step is uh a user that wants to commit to a value sends her time locked commitment to the mempool okay so here you can see a few users alice vocaron and bob that committed to a time locked value obviously the the commitment has an expiration time because we wanted to appear on blockchain before the time locked expired and then a minor comes and it includes these uh time locked values on the blockchain notice that uh these transactions are now time locked so the miner cannot use any muv opportunity because it doesn't have any way to compute the the value that he can extract okay now comes uh an operator that uh for any for each of the time locked values he performs the the computation the delay function and reveals the value and next the operator submits a computation proof that he did the computation correctly and these values uh xyz were computed as they should have been computed the operator also submits again these transactions but now they are revealed and they are all also conditioned on the fact that the verifier on chain approved them that they were computed correctly now a miner can query the verifier and see that the condition is is valid for each one of them and then he can include them on the blockchain note that this the the the reveal transactions must be in the same order as they were uh in the in the previous block or a few blocks ago when they were time locked otherwise the miner could have performed some front running or uh to extract mvv by uh adding his own transactions or change the order so in this case the miner has to store the the order of these time locked transactions okay so so if we um if we think about uh the second approach uh this this uh responsibility that the miner had to store uh the order of the time locked transactions can move to an unchained smart contract okay so so here we have a sequencer that submits the the the locked time log transactions to a sequencer smart contract and to be economic he submits only the hash of this list and not the the entire list an operator again like in the previous approach computes the time locks and then submits the proof on chain to the verifier the verifier can now check another condition that the list of commitments were revealed at the same order that they were committed to so the sequencer smart contract um has this uh list commitment the hash and it can be compared to uh to the list of revealed values okay um i want you to add that there is also a can the time locked values can be uh for one specific applications it it doesn't have to be a transaction it can be input for a specific application like uni swap or some game and it can use the the the operator can submit these node these uh revealed values to some logic smart contract that operates [Music] with some logic and this logic smart contract can query the verify to see that these are valid okay so to summarize privacy can reduce mev a video timelock offers a solution from for privacy in this very critical phase of sequencing of the transactions and there are multiple schemes to use video to minimize mev which uh some of them i presented here okay that's it yeah now you can ask any question yeah thanks for presenting i think out of uh a consideration of time we would uh let's take uh two or three questions and then we'll move on to the next presentation um so how do you guys think about like what sort of time delay to do like you know given that like you know mentioned in the top class talk like there's this trade-off sort of between ux with uh security when you're choosing the time delay parameter so how do you guys think about choosing that yeah okay so uh yeah it should be a time lock which is uh long enough to for the transaction to get in the blockchain but um not too long not to hurt the the ux of course but in the second solution where the full list of commitments um is submitted at once to the sequencer smart contract in that case the delay can be shorter because it's only one submission to the blockchain per uh a list of transactions so this can improve the delay actually right so that the that list can be submitted before the time log actually finishes executing yes first um first the the the the commitment for the list only the hash of the list is submitted on chain and then this is a commitment for the order of the transactions that would and then later the after the time locks are revealed the entire content is unchained so um my question is how do you choose that time lock length i can i can try to uh to answer um if that's okay um like there are two ways to think uh about it one is to sort of um you know take the um economic cost of uh a reorg and you know use that as a metric versus how much uh extractable value you want to measure you know measure by that so just to throw some numbers which may be completely off suppose uh reorg is ten thousand dollars for whatever for five blocks and the value is more than ten thousand dollars then it's not good okay so you want more or you know or less depending on that a different way to think about it is that if you have um you know there's sort of uh this is to re rely on uh let's call it macroeconomic considerations which means that attackers i mean there's a sort of the normal reorg rate that you see which i don't know what it is but let's suppose it's two or three blocks whatever um that's the natural thing so as long as you go over that it means that if someone's gonna do a reorg you know based on extracting value everyone's gonna notice it and you know maybe the value of the underlying blockchain goes down so maybe you're safe just above that even if your total economic value is more than that i mean those are two ways of thinking about it and it's a parameter that you need to set a second question i have is like how concerned are you about uh alternate bdf hardware that computes it faster than the honest operators are uh like how do you price or account for that risk is this something that's uh and i'm generally worrisome or i guys i don't know much about it ellie maybe you can answer that okay i i see that also a viewer's your view do you want to answer it or should i uh yeah i think the question was about like accelerating the speed of computing the pdf yes um we spent a lot of time in conversation about that and measures and i think the main advantage that we have right now is that our video function is pretty simple and it's already something that is pretty close to optimized even if you run it on a cpu so it's not to say well i can't improve it if i built a specific asic for that but it's also not uh crazy off from that so if you do it for like i would say like um it's also some kind of economical um reasoning you have to think about but for any practical or not very high energy i think running it on a cpu and assuming a small multiplicative factor would be probably fine um and we can provide more accurate numbers there just as like the small like mean like i don't know two or three or does it mean like i don't know like tens uh i guess i i think i think that two or three will pre will be probably very safe or pretty safe okay um but even if you do like eight i think that's fine okay is is there an issue with the data availability if you only submit the hashes and the order of the hashes then is there some reasoning that needs to be done about actually providing the data once there is the the commitment has been achieved yeah you should answer yeah okay um the the smart contract should enforce that the transactions are revealed in the right order according to this hash so uh if if the operator tries to submit um something that was not um [Music] it's not included there um it will be very hard uh very easy to to to see that it's not uh no doesn't correspond to this hash yes so so there is a besides this uh mechanism there should be like entire an entire application layer of incentives how do you enforce the proper execution besides the existence of the smart contract and the video i mean basically i think that like instead of including just the hash originally you should be including all the encrypted data in the proposal so that way anyone can start the decryption process not just the original operator yes you can include it as a call data also which would be uh because left yes yeah i mean it has to be done otherwise you know otherwise then that proposer could just never show anyone else exactly just censor it unless a kind of similar to a zero knowledge and optimistic roll-ups either punish them or have the data unchanged except that there is not really a state here so censoring here will lead to not executing all transactions but yeah but maybe not executing it is exactly what you want yeah absolutely the account i'm not saying that it's uh it's something the solution i think that it's just that's what it implies and it's a little bit different than in roll-ups in this on this specific point um maybe it's worth just as the last question to pick up pintails um question uh in the chat can the operator be anyone and how easy are the stock proofs to produce yeah i mean uh yeah the operator can be anyone and how easy the stock proofs are to produce you know it's code and in the end uh i mean it's uh it's it's very close to the east stark uh code base that we open source so it's actually much simpler than it because uh the e star codebase does something a little bit more complicated than than we do so it's uh it's quite simple um i mean right now we have a service that we're operating but uh definitely over time you know the part of startnet will be opening uh provers for a whole bunch of things including for uh vdfs if there's a need for them you know if programs are going to be going to be written around them so yeah but by the way it's a terrific project if someone wants to modify the eve stark open source approver to uh um to do video proofing proving that that's a terrific uh project it's not very yeah yeah i wanted to say it's already very efficient and the air that is um implemented there is very close like kelly said so it's actually uh someone wants to play with uh with stark's constraints then i think it's a very nice project to do cool well thanks for um the presentation and the discussion let's move on to secret network hey everyone let me share my screen real quick [Music] can you see can you see my screen yeah yep yep perfect hi there uh this is john cassagan i'm um one of the co-founders of enigma and uh we're building secret network which is uh a privacy preserving smart contracting platform uh based on the use of sgx and um today i'm gonna talk about secret contracts and how that can be used to mitigate mev [Music] some high-level information about the network it is a cosmos sdk-based chain um so even though uh like i think sunny gave a good overview but even though um computations are run uh privately inside the sjx or of each validator the hashes are compared on chain and and correctness is guaranteed by consensus um there is um a native token like atom used for staking delegation governance and fees this is not private but uh but everything about the contracts are privates um i think it's important because uh people get to see what uh gas is being paid for different transactions even though the inputs are not uh available um yeah as i mentioned it's a it's a rust-based contracting language compiling the web assembly and uh we have uh the contracts have encrypted inputs encrypted state and inhibit output and the way we do that is through a use of enclaves some key management and encryption protocols um very very high level the way it works is there is a single network uh private key that's uh generated inside the uh the trusted execution environment and it's shared between the validators and um if interesting we can get into more details there um when a user is submitting inputs to the network they do a semitic encryption where they encrypt the inputs using uh so alice use her private key and the network public key to encrypt the inputs send them to the states then each node can take that input and decrypt it inside the enclave where the private the network private key remains uh do the computation uh compare hashes and uh update state uh in an encrypted way on chain and each user can access the encrypted outputs of the of the contract that they're interacting with if they choose to or these outputs can be made public depending on the application uh i'm gonna pass these ones for now uh but would be happy to go over them if uh you guys have questions um we have two contracts that have been um um on the network live for uh four or five months now one is this concept of snip 20. um it's uh similar to erc20 it's a smart contract based uh token issuance but since the contracts are encrypted um every token you you meant is is a privacy token basically uh we have around 40 million uh dollars worth of eth assets uh on our platform right now used as uh privacy tokens uh but what i want to show you here primarily is like um this is what what you see uh when someone interacts with this contract um also this is like what what a minor with more or less see uh you see alice's address you see the contract that alice is interacting with um in this transaction alice is sending the secret tokens a certain amount to someone we don't know what the amount is we don't know who the recipient is we just know that alice is interacting with this contract and uh like while you know you probably don't really have too much to gain from front-running a simple transaction any contract that's built on secret network is designed and encouraged to be working with these snip 20s so you know if this was a like a uni swap kind of swap where there actually is value in reordering a transaction you know that would uh that would not be possible or similarly like a dark force attack thing um one thing to note though um you know um the there is a way to kind of see what's going on uh because of the metadata that's being uh submitted to the to the network like if you have a contract that has two different functions and like one function takes uh very large inputs or it's very expensive to compute compared to the other one uh someone can um estimate like which function is being called based on just the gas uh fees that somebody on chain but again the inputs to the transaction will not be known by anyone um we also have an auction contract that's live right now um the goal is to build uh a dark pool like product around it but um i think this is interesting and this could be interesting for also the auction um implementations that you guys are looking into um the auction contract uh accepts all tokens to it and um so if alice is creating an auction um and she wants to sell 100 eat she needs to send her secret e to the contract and if bob is bidding like you know however much uh die uh bob charlie all them have to submit their tokens to the contract uh because these privacy tokens cannot be observed on chain we have you know privacy on uh what assets are flowing into the contract and and uh when the contract executes you know there's guaranteed settlements while keeping privacy um and our goal is to have any application that's that's built on our network to be depending on this snip 20 standards um so kind of like where like does this put us uh with relationship to mev uh as i mentioned uh inputs are encrypted uh so values can see the transactions they can't really reorder or insert transaction um solving two of the problems that sunny touched upon one like the dark force and the other uh ordering uh for for front running indexes uh as i said though it is possible to observe uh encrypted inputs outputs the functions that are being called to infer what's going on and that would potentially create some vulnerabilities around censorships like so if someone's trying to close a position a cdp kind of situation um someone can see that you know uh this specific function is being called if the function has is leaking some data so one thing that we do is we we encourage uh secret contract developers to kind of think through these uh side channel attack and and do their own due diligence around it um so that's uh kind of it and in terms of like the way uh that that uh potentially with the mev auctions that you do um one interesting option can be to you know have um a smart contract uh have the code to calculate this this profi profitability calculation for the transaction bundles the transaction bundle itself can be an encrypted input and you know um we could just have the the secret contract give the miner um you know the ordered pair at that point yeah the miner would still need to submit a loan change so there is um a potential uh surface uh of attack but that's like you know that's something that um we could do very easily um and like you know if a couple of miners want to implement this um you know we could uh spin up a version of what we do or just like you know implement this this fairly quickly for other networks who which do not run with uh private smart contracts so that's me uh for now um my colleague assaf is also on the call so if you have any questions i'd be happy to go through things in more detail yeah dev can you explain your last question oh i sure the question is you said i mentioned earlier that some metadata is leaked because of the fact that anyone can execute the transaction in sdx and the metadata is uh i guess database accesses yeah database access is the size of inputs and outputs stuff like that for example if you know that a contact has two functions and one of them receives large inputs usually then by looking at the encrypted input you you may guess that if the input is large that what function will be called right so i should be able to get the order of all uh database reads and writes and the size of the data communicated yes the question i have then is in order to get mav security or are you nice optimal do i need that all contracts and network are essentially equivalent or are data oblivious to one another like is that the right permit yeah for better security yes you need it but i think you can you can only know this in hindsight what you're referring to uh well i mean without that your your anonymity set is just a set of contracts of data oblivious with so i guess for ideal security maybe you could fix a data oblivious communication pattern yeah yeah that's one that is one area of improvement we can do yeah i guess i kind of worry if you know developers are the ones if it's permissionless like what's the probability that two given contracts are equivalent are data oblivious equivalent uh because then yeah but you know which contract is being executed you just don't know what's going on inside oh right that's not being hidden okay i guess right so you i guess okay that makes sense you only need uh date obliviousness within a contract which then a single developer could do or yeah okay thanks that makes sense there's a there's a question from stefan as well above what challenges did you encounter with running cosmos sdk and sgf i don't know how to answer this we don't run the sgx the sdk itself within sgx we only run the smart contracting module inside sjx and it wasn't very hard you know you just call it a an external library cool well um i hope that answers stefan's question we can also continue to the chat on the site let's move on to the last and the fun part about the brainstorming session phil do you want to present cool yeah thank you guys uh so much for that presentation that's super interesting and uh i think everyone who's presented so far will also probably have some good inputs into this next part if you want to stay on uh i would encourage that so i will share my screen now oh my browser can't apparently one sec um let me rejoin in firefox sorry about that i think this is the most exciting roast so far we've had we've said that every single roast but this one has been the best but go ahead phil can you show the screen no perfect i feel we can i think see your screen but can't hear you at least we see something black but oh yeah yeah i didn't see a black screen you just see a black screen only yeah yeah with a mouse okay great one sec i'm gonna present all right we'll just have to do it this way can you guys see this yeah all right i might have to okay do you see the slides or do you see something different i can see great um all right so let's get started i'm going to rant for just a few minutes and then i would like to open up to some open discussion for the amount of time we have left in the roast um so hopefully i'm just going to really summarize all the content we've seen now uh we've seen like several strategies for using secrets to reduce mev um maybe we can contextualize this and and talk about how we think about this in the engineering side of the flashbots organization and where there's space for i think r d improvement across projects collaborations uh but the first thing i want to say is that um i will also accept just talking about gamestop for the entire discussion session and if you're really disappointed by my slides and you're like phil these slides don't look as good as your usual slides it's because i was on twitter all day yesterday so i'm sorry about that the other disclaimer i have is that these are not necessarily binding plans in any way or necessarily a roadmap for our organization these are just uh my kind of shower thoughts on different architecture trade-offs for l1 mev um so i would encourage people to be very vocal and interrupt me um i can't see the chat right now so you'll have to do it audibly um but yeah don't take these things too seriously or think they're in a final form i would love to kind of discuss and uh and here's some reactions okay so real quick what is privacy um so the type of privacy we're talking about here is privacy of transactions as they're being mined from the miners so normally when you have a miner that's creating some sort of block either in a or a validator either in a proof of worker proof of stake or a layer two system they can see the full contents of the block they're mining and as we covered here we want to be able to enable at least for some transactions them to be able to mine this block while being blinded into this kind of set of transactions that's inside the block so that's the goal why do we want this at flash bots specifically for layer one mev um well actually i think the miners are the ones who should really want this and you might be asking like why would miners want to blind themselves um well the reason is because by blinding themselves they enable a more efficient marketplace between themselves and the people who are specialized in writing uh these training strategies and these bot strategies that we've seen on the network so by allowing new types of orders because there's a clear trust relationship between validators and bots that increases the overall revenue that a validator would see versus having to spend engineering effort kind of running all the bots themselves and it also enables specialization between kind of validation and mev extraction which i think is a very important ecosystem property for fairness so that kind of goes to the next bullet point which is that it maintains uh incentives uh for permissionless innovation and efficient bot ecosystem so if we don't end up having minor transaction privacy what's going to happen is that in order to extract large amounts of mev especially with opportunities like exploits or on new arbitrage types that haven't been imagined or flash loan kind of uh arbitrage um it's going to be very hard for bots in the end game to extract these things without having either a very specialized infrastructure to deal with the dark forest uh kind of meme or the pga meme um or to partner with miners directly so we think that requiring that kind of partnership makes that ecosystem less efficient and causes all sorts of systemic stability problems et cetera i also think that miners have like trust or regulatory based issues where they don't necessarily want to be discriminating based on transaction contents and having this system where they probably can't while they're still extracting mev solved a lot of those concerns for them so overall i think we increase system efficiency and fairness for miners as well as bots why the bot operators would kind of want this is obvious they get clearer guarantees on execution and efficiency they don't need to specialize on gas auctions the way they currently do which removes a barrier to entry and should democratize that marketplace um specifically they'll be kind of using a more advantageous and efficient auction mechanism that will be easier to both set up and reason about the economic properties of and what that'll do is that'll let them specialize on strategies so what we've heard in a lot of our previous rows and brainstorming calls from people who are running these bots is that right now the bot specializations are really on the pga games and on mempool dynamics and that's like a significant kind of monopolistic force in the industry right now um and it's it's my hypothesis that all this pga effort is is kind of being wasted and is not making the system more efficient so uh let me just check my time real quick okay great uh whoops this is the downside of this janky linux screen sharing all right um so what are the properties we want for this system um um so i guess it's basically the same as the three properties we laid out in the flashbots uh initial blog post which is permissionless so we don't want to require any setup for either miners or bots to join the system and no trust overhead over the current eth model so no need to trust certain miners to behave better or certain network tools to work or anything like that so that's the ideal is no trust overhead to today's network um we wanted to be fair so we wanted to align uh incentives between these different parties we've seen emerge in the ecosystem and i think part of that is having as little barrier to entry and competition as possible so right now pgas and back running bots and spam these are all significant barriers to entry and competition that we want to remove um and we want transparency for whatever privacy solution uh so that the custody guarantees for the data like where the data goes and who processes it and how it's released is very clear to everyone um and also minimal impact on current networks so one of the differences i think in flashbots and the presentations we've seen is that a lot of the presentations we've seen are able to kind of reinvent the whole system and say like this is the ideal clean slate solution so while i think there's a there's a place for all of that in this ecosystem and we need that too we also need things that work with current networks to prevent those networks from devolving into these trust space kind of systems so i want to propose this informal primitive and this is what i want people to kind of go away from this roast and brainstorm and maybe follow up with eventually and this kind of unifies a lot of the things people have been talking about in previous presentations here stated very informally um so this is a proof of a private transaction basically or private bundle if you want to think about the flashbots context and in this proof basically approver proves to a verifier that it has a valid set of transactions um for some eth block h so this is the new block hash and some transactions are in a public input list and others are kept private as input to this proof so that's stated very informally but the definition can kind of follow from uh from other uh interactive proof definitions um so you can have soundness and completeness and zero knowledge kind of standard properties layered on top of this um properties we specifically want for a flashbots capable network would be that they're not withholdable so this is the data availability that we were talking about earlier state rich would also be nice so in addition to having this proof that the private transactions will still cause valid state transitions um having proofs on the final state that results so proofs about things like the coinbase of the miner would also be useful and i'll get to why in a second um cheap to compute locally to create and to verify and uh portable and non-interactive again we'll get to why that's useful on the next slide because we have this peer-to-peer network so we want to kind of reuse these proofs as things travel through the peer-to-peer network and again this one's very flash bot specific and kind of will will impact a lot of how these solutions work and that's backwards compatibility with existing ethernet existing layered two solutions um so let's say we have this magical primitive this magical proof of private transaction how would we use this to build minor privacy and accomplish the goals we set out well it would be simple so basically the trader the bot operator when they are submitting a bid to a miner to include their bundle or their private transaction they would generate such a proof that the transaction is valid um and they would kind of forward that to the relay network and that proof of the valid transaction and the valid fee payment essentially because you have state proof would be used for spam control in this relay network in the same way fee payments are and would also be checked by the miner so that the miner knows that even though they have these blinders on they won't lose revenue by including the private data because both data can't be withheld from them and that the data is all valid in the first place and another layer here could be possibly combining these multiple transactions and these multiple bundles um so that's what uh i think was mentioned in the secret network presentation as one possible great application of sgx is that you can efficiently run combiners uh and keep data private while you do that um and so if you have that you can you can enter the situation where you have the miner mine these bundles and blinded way and you remove the blinders only after this block is is produced so we've seen many techniques for achieving secrecy and this use case is no different so one solution is sgx i think it's pretty clear at this point what that would look like you'd basically have some subset of an ethereum client inside your enclave it would attest that you have a valid blocked state transition on some public input hash and a correct encryption of the secret contents that you're you're withholding um you can also add to the output another uh binary which is like a time lock encryption or a committee encryption or an encryption to sgx keys to ensure data withholding doesn't occur using these as defense strategies um uh for the committee based solution um like it would be nice if we could remove sgx here um that's kind of the open question that i want people to brainstorm when they when they leave here is it possible to have all the properties we have if with sgx um but without sgx and i imagine many of the the kind of enigma folks and the star queer folks and other people who are working on these solutions already have got answers and have tried many things in terms of removing sjx and these kinds of protocols my guess is that the validity proofs are going to be somewhat prohibitive especially with our requirement of them being cheap but let's say we have a magical committee mpc protocol that could also generate these proofs if it was efficient and could run kind of a whole eth client in this mpc um can we approximate that with threshold encryption and cryptoeconomic kind of properties maybe using a bond or something like that would that erode our properties of fairness that we're trying to achieve and even if we don't use this for the full system can we layer these committees and these time log encryptions on top of an sgx solution to achieve defense in depth uh if sgx breaks the other thing i didn't mention here is that the burden of who generates the proof um right like you could have the trader just encrypt the transactions to the miners sgx and the miner um the proof is really just the encrypted transaction data um there's a question here of like how the system behaves when sgx breaks and by putting that uh kind of bonus on the trader it gives the miners the roles of kind of falsifying the sgx guarantees and noticing when sgx breaks because the miner will see that they get kind of invalid proofs that later no longer hold up when they're unblinded so for the miner in this system these guarantees are kind of falsifiable and they can notice when they break and kind of stop running flashbots if we instead put the onus on the miner to run sgx there are issues with miners reselling order flow and having advantages to kind of try to cut the line like we mentioned earlier um so those are all just things to think about uh here's some open questions to discuss i'm happy to discuss gamestop instead we really only have five minutes so maybe uh if anyone wants to hang out for a few extra minutes that would also be fun but uh is this kind of proof of transaction the right way of thinking about what we need to build um is sgx a palatable solution for this for the community um does our strawman system that we've posited here uh using sgx and using the the potx in the relay network actually achieve the goals that we have um what qualities do these things share on layer one and layer two too so for example can we use all these solutions we've just seen for reducing mev with consensus changes or on layer two on each today my guess is there will be some difference here but it's not clear how much infrastructure can be reused especially in terms of mitigating nav and in terms of the best auction mechanism is the best auction mechanism on layer two and layer one the same or not um and what other cryptographic primitives are useful for uh creating proofs of transactions that we haven't thought about and what are the limitations of for example new mpc techniques or new proof types so if these are questions you're interested in and we don't get to answers on this call also welcome to reach out to info at flashbots to talk about these things um i'm gonna split my screen a little bit here so i can see the chat um so yeah that's that's all i all i really had uh it's really just open questions and challenges i don't know the answers to these i wish i did uh but that's kind of how we're thinking about it here at flash for boss and where we see current solutions as lagging questions comments me so i think that'd be kind of interesting is uh can we get like the miners to be a threshold encryption committee and then they uh do threshold encryption sort of on their own and then uh you have this protocol where essentially origins sort of standard built between them where if one of them doesn't follow protocol correctly eg they take special decrypted transactions and include their own transactions like some transactions that aren't threshold encrypted like weren't from this uh process then everyone else soft forks them out like they just basically reject that block so essentially uh many soft forks in order to simulate like industrial decorations it's like an interesting meta economic question which is that like if the goal of flash deposits is to build an mbv extraction i guess i don't want to use the word cartel um but uh if an mav extraction incentivized system of cooperation um then should the system punish defection um or not and i think that's that's a an interesting open question especially once kind of a higher hash power threshold is read i don't think i can get around punishing defection with threshold encryption maybe uh with sjx there's no committee so it's okay i guess that's fair um well i guess the way to get around is just to assume your committee always works and uh if it doesn't then you just stop using the system but uh yeah that's not that doesn't seem quite as satisfying i think that's one of the one of the the other dimensions maybe it's worth adding to sunny's uh and and and your like other kind of section on the presentation um which is like falsifiability of like uh if if trust guarantees fail what is the recovery path and can people tell so i think uh that there's like obvious differences even in just the sgx designs that i've thought about of like who runs the sgi x will affect whose job it is to monitor this and whether they can falsify or whether they can like uh determine uh deterministically and like uh accurately detect falsifications i guess so yeah i think it's another dimension to think i guess i'm not dimensioning a lot of different design choices like i guess also for a threshold description in each like environment you can have a committee where uh they accept some pipeline delay and block inclusion like uh this committee is going to decide on a run consensus out of band essentially decide what block they want to propose next what are the transactions and then uh if the the hash of free transactions is included in block n then they'll decrypt it in parallel and then mine on that for block n plus one or you know n plus two depending on how pipeline delays work here so that's another alternative which i guess gets rid of some of the uh fears of invalid or you know malicious committees but has other costs namely pipeline delays yeah i think there's also like probably like a falsifiability backwards compatibility trade-off i don't know maybe not but it seems like the current let's say eath protocol for example uh because it's not designed to have such a system layered on it like uh there may be less falsifiability in some parts of the stack that's just a hypothesis but maybe that's the case you um if these are questions or remarks or maybe some obvious uh obvious things but as i see it the main point or the main differentiator is to prevent the miners from playing unfairly and taking the all the led for themselves you've mentioned that [Music] as it is as it stands now frontrunners are optimizing on the wrong thing they're optimizing on the a cat 4 games and back running etc but i guess the end result is that either they optimize on that or extracting possibilities eventually in both cases they can choose to give the miner everything besides the last dollar of profit minus their margin of operation is so a the the secrecy or the way you hide this transaction mainly achieves fairness that yes you can optimize on whatever you want but you can be sure that your optimization will not be front-runned eventually by the miners who have the the ultimate power uh unless uh there is some other edge that that they you think is a also important in in this privacy scheme yeah i mean i think ideally that would be like i guess my hypothesis is that things would be more there's like an infinitely deep rabbit pull in the state-based search of like finding the best and most profitable strategy so i do expect that like for very simple strategies uh like unit swap sandwiching or something like that probably you're right that it will be somewhat of a race to the bottom and the miners will extract the bulk of that because that's just how the auction will play out and there will be some specialization there also in the auction um uh at the frontiers of like more obscure or complicated arbs i expect there will be you know more lag so like market leaders who can kind of uh do a little bit better because their algorithms are a little bit more sophisticated and they have an edge for a little while and they use that edge to kind of profit until things uh the edge disappears um so i i guess um i think for for everyone that's almost the best case scenario because for miners um like they don't have to infinitely specialize to constantly keep up with this frontier um they can be comfortable that they'll extract kind of the bulk of the the stuff that's been around for a while and they'll basically pay some r d out to um kind of more sophisticated actors who are like exploring these things that there aren't mainstream tools for yet so like i i personally my hypothesis is that that world is better for for everyone also because right now like these searchers are somewhat searching just spending less time thinking about arbs because they're specializing on pga so much and i think like a lot of these pga dynamic details that people are spending a lot of time on are like very arbitrary and like kind of silly like consequences of ethereum design that like nobody ever intended to form the basis of like this massive economy that was like tens of thousands of hours optimizing around like how guest stimulation code works or whatever but that that actually is what we've seen um so yeah i think that that my hypothesis is that that world is better for everyone but i think it's that's a good open question too if i think the short time until the better for everyone and i guess maybe the way the way i see it in the long term it converges to kind of the same thing but on the other hand yeah i guess the more projects they pop up they the pool of possibilities also rises exponentially so where's that yeah i also expect there's going to be some pushback in the people who have substantial um code bases but i also think they're the most flexible in terms of like being happy they've had their edge for as long as they've had it and moving on to something else um so yeah i hope that that's how things would play out but uh i don't know yeah i guess you'll be optimizing on whatever the your devs salary instead of your gas your gas cost yeah exactly i see syria also had a question about whether this is just making things more efficient because it removes pg gas or it removes pjs just because it removes like visibility which i think is part of it but i also think part of it is that like it allows us to clean slate design an auction mechanism um which i guess is what you're working on so i think it's a little bit of both cool any other questions comments thoughts i guess if not we are we are a little bit overtime so thank you guys for staying late and uh i think uh yeah i think it's gonna be a really interesting um kind of uh thing to keep thinking about and try to think about i guess whether we can achieve these goals without sgx or whether it's worth compromising on these goals or whether sgx kind of really is the the obvious answer here um so yeah i look forward to hearing what people think async on that too i just can't see like any other way any non-sgx way of doing it efficiently like every other option just seems to be just seems to require a lot more work that i don't that i think especially miners would rather just take sgx and be okay with it right i mean like i never i don't think they care as much about you know sgx being sort of not you know a very clean security solution in the sense that it's not you know it's not it's not very pretty looking in terms of you know maybe thresholding encryption i think you know their priority is something they can plug in right now start working with and it's and it's super fast right so there's a point here i guess that the worst case is whatever we have right now so how bad could it be would it be detectable if sjx is used and broken no that would be non-detectable fault as far as i'm aware because you can just front run and claim the whatever order you got was from an sgx so i think so then it creates a false illusion of safety which is actually worse than what we have yeah i also think that you know the point about its miners may not care well it's like not the security property isn't for miners like mav is a security property for users so it's like uh i don't know i guess it doesn't matter what the miners think but it's like uh it should be the users who demand high scores that's all true um i think so i think there it is possible to make it in a way that if sgx breaks the worst thing that happens is that you can spam the flash spots network and dos it um and dos temporarily any minors that are using flashbots until they turn it off and the reason is that so if you have the if you have the trader um kind of generate this proof with private transactions here let's say the trader never sends these private transactions um and the output of this is also a committee encrypted kind of blob of these private transactions um then as this proof gets passed along if any of these guys break sgx they don't learn anything because the proof has no data about these private transactions um so these guys can break sgx all day long and they have no advantage um if this guy breaks sgx who made the proof he can send fake crap across the network and get miners to mine in valid blocks basically um but if you're a miner you can also monitor for that and you can know when someone has broken sjx because they promise to let's say pay you to eat for this block and then when you mine it it's not valid um so that kind of becomes obvious i think it is possible if you're like somewhat careful around your failure modes design something that's uh degrades somewhat gracefully um still not fully graceful like still having sgx as like a solution for not having the miners crash it's not completely optimal um but i think if you had let's say the miner run the sgx then the consequences of them breaking it is much worse because there's no one that can check that they did that and they can front run you at will um so yeah i think there's a there's a kind of security continuum here and a lot of like subtleties in designs um i think my hypothesis is that like in this way sgx is a little more acceptable because it's not relying network is not relying on it for anything but security of dos security of the miners that are using flashbots um and you can also probably as a normal client watch for massive hashrate drops to have like a more decentralized metric on uh did the flashbots network fdos also so just some thoughts well one interesting thought from our current learning um with flashbacks alpha is whether how miners or the existing incumbent miners uh perceive true stupid auction and also how the incumbent traders in uh um or bot operators perceive the super stupid auction it's a bit uh scope creeping beyond the current discussion but is um originally we thought the uh the adoption adoption hurdle would come at running sgx but it seems to be that both sides are fishing for more information for an edge and that is something that at the current stage is something that we're curious to see how whether there are creative ways to get around that per se because if there uh if the current version of md guests become the dominant um way for um essentially uh for for this kind of inclusion they the miners still have more control so um whether they would like to give up that control in exchange for the additional order flow potentially because of a system that could be more um essentially that the traders the searchers will feel more comfortable with i think that's going to be um another side question that's there now we've experienced a lot of challenges around why seal bid is still a bit really better uh and the ux with seal bit how do i even price without knowing where everyone else is pricing yeah i mean uh yeah that's that's a great point i think it'd be super interesting to like gather all their thoughts on sealed bids just as a way to see how people react to that proposal um i think we can also do like not sealed stuff like i think our advantage is that we can really design the flashbots auction however is best from first principles because we have like a very good infrastructure to do that on with youth plus sgx and also a clean slate um possibility so we could potentially have multiple auctions and have some be partially open where like you leak some bit of information on purpose um i don't know i i know sealed bid has like some substantial limitations also around collusion that syria is uh uh kind of formalizing now um so yeah i think that that that is very much an open economic question well cool anyone has any closing thoughts if not i am really impressed that um we still have half of our folks still on beyond essentially like 100 minutes into our roast so uh to uh not to set the president for rose to become a day-long event which i don't mind um i i think we should uh lead more to uh async as well as so um sunny has proposed that we should have a couple more essentially one privacy focus and another one is transaction ordering focused uh sessions uh right sunny are growth master any thoughts for our future sessions yeah i think like um you know like i said we were focused mostly on that like first proposer power but i think it'll be good to talk about mav reduction techniques to start dealing with some of the other proposal powers and ordering and choosing transaction ordering and inclusion is one of those um as well so yeah i think we think that would make for a good discussion there's a number of different solutions of how you can do it yeah definitely i think that sets the stage for uh for more for more of these fun jamming sessions um so for um yeah so let's uh that's it for uh today's uh content and we will post recordings similarly on the get up and um our next next session um either next thursday or the thursday after um we will have a session specifically focusing on state space search so really how large is the mev space and how much has been really capturing and can be captured through what means so um yep thanks for joining everyone thanks everyone thanks okay wow one last question will this be recorded oh yes yep everything is recorded um so uh oh uh uh and you can go on flashbacks github uh slash pm and where all of the uh rose sessions are recorded could you post a link in the chat yes i will do that thank you want me to do it yeah i'm also trying to to find it um and also uh if anyone is not on our discord uh that's probably the best way to to continue async discussion um and uh yeah because we're all there and it's 24 7. so um if you would like to be part of uh any of these open question research um or propose um essentially questions or want to present on the future roast uh just uh shoot us a note uh in the discord channel which uh if you are not in it i will also post here one moment thanks everyone thanks so much everyone thanks great to see you you 