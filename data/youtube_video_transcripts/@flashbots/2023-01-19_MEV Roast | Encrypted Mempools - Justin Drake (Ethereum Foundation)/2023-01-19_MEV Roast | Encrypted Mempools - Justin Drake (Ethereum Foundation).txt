okay so the the talk will be in in three parts um first I'll describe you know just the basics of of what is an encrypted mempool and and the the design space I'll talk about the the motivation in part two and and then kind of the the fun part part three uh the more technical part where we talk about uh metadata because it's it's all well and good to encrypt the payload of a transaction but really all the metadata that comes with it also needs to be encrypted okay so what what is what is the the simple framework of an encrypted mempool um really the key idea is that you want to encrypt your transaction off chain uh before it it it it it it it goes on chain um and you want to have some sort of of commitment to to the inclusion to The Ordering of that of that encrypted transaction before you decrypt so you have encrypt commit decrypt and then execute um and you know one of the questions you might ask is does this kind of add latency to the whole user experience and the answer is not necessarily like you can do all these three steps uh in one slot all in one go behind the scenes so one of the uh important things that you need for the encrypted man pool is some sort of encryption scheme that guarantees that the the ciphertext will eventually be decrypted um like commit reveal doesn't work um as quintus alluded to and there's basically five different uh families of of encryption that I've I've identified with this property so you can have basically a private end-to-end encryption where you have a a a centralized entity that um maintaining this this encrypted man pool so that would be a flashbot protect you can have enclaves-based encryption where you're you're trusting you know the Integrity uh of sgx um there's a threshold-based encryption which seems to be the uh the the most popular approach with with orbit firm shutter and and various others there's delay encryption uh that uh stockware is is looking into um and then there's witness encryption with this encryption if you're not familiar with it it's a very very powerful primitive which allows you to have arbitrarily um you know complex and flexible uh decryption predicates so you could say decrypt if something happens like for example you can you can have a snock of an arbitrary statement be a decryption so one one example could be if the chain has finalized the chain that includes the encrypted transaction has finalized then decrypt and so you can think of witness encryption as being a generalization of all these other uh decryption mechanisms now in terms of Readiness um you know we already have things like flashbot protect and I believe you know that we're you know where the technology is like fundamentally ready sgx is there to have things like Enclave based encrypted mempools and and threshold encryption is is is is also um you know pretty much there um delay encryption one of the hard bits there is that you you need a vdf Asic um we actually by we I mean different foundation and protocol Labs actually went through the effort of of designing an Asic and we have samples so we've we've manufactured samples um and they're going through the process of being packaged right now and they'll be tested in a few uh in a few weeks and the witness encryption is basically this this Moon math um kind of piece of cryptography which which is not at already right now now one of the important things that I want to highlight here and this is where I kind of disagree a little bit with with Phil and quintus is that um you can have perfect encryption basically as a user you can link no information but you can still be um not blind to user outcomes so basically the the encryption system itself can be aware um of of the transactions that it's manipulating and it does not have to randomly you know include the cipher texts or blindly include them on chain it can actually kind of look under the cover of the encryption in such a way that the user doesn't have to to leak any information so that's called like like homomorphism where basically you're you you're given um ciphertext encryptions of messages and one and M2 and you can compute functions on on these on these functions on these encryption uh on the ciphertexts and it's actually trivial to do um you know homomorphisms in the in the trusted context right so if you have a a an encrypted mempool like like flashbot protect they get to decrypt privately um the the transactions and they can run the functions on on that and it's the same thing for sgx right sgx you have the in-flight um encryption between the user and The Enclave but then the Enclave will have plain text access uh to to the message um but then you know as as you as you become more and more sophisticated in your encryption mechanism the the homomorphisms become more and more uh complicated okay so uh motivation on why why do we want uh encrypted man pools I think there's basically uh two right two reasons one is is front running and the other one is is a censorship so front running is is easy is this idea that uh you know if you if you can't see uh the payload of a transaction and you and you can't see the metadata then you you can't kind of meaningfully uh front run transactions so for example you know a sandwich if you want a sandwich or transaction you need to know which pair is being um hit you need to know that it you know it is a trade in the first place um you need to know the the size of the transaction etc etc um but a kind of a related aspect is centralization so one of the one of the the bad things of Mev is the centralization force and we can ask ourselves um you know why is that centralization and basically this the centralization because some sophisticated entities can have an edge in in in in producing in producing blocks and being part of this this Mev pipeline and if we can remove sandwiches as as an edge then basically we we we we reduce the the surface area to be sophisticated and we reduce the the surface area to uh for for centralization so in in this slide basically I distinguish multiple types of Mev this kind of the the positive Mev which you know Arbitrage and liquidations and basically things that uh the designers of the application actually want me the extraction to happen because it leads to to outcomes for the decentralized application like prices being um being arbitraged but there's the the bad stuff which is which is moving so it's kind of a a great coincidence that um you know encryption kind of removes the bad stuff and and keeps the keeps the the good stuff and also helps with centralization now and the other um thing I want to highlight is around uh censorship so one of the counter arguments that you might have around encrypted mentors helping with censorship is you could say that some entities in this Mev pipeline will say I will just not include any encrypted transactions or at least I won't include them unless you tell me that um that they don't have certain addresses so you can imagine for example a block Builder saying I will only include your encrypted transaction if there's an accompanying snark saying that it it's ofac compliant and the one of the things that we want to try and do is basically make make encryption the the default in such a way that um the if if you if you want if you want to have this very naive strategy of saying I will I will not include um uh you know a certain type of transactions then you need to not include all the encrypted transactions and uh the the the the reason here is that if you include an encrypted transaction you don't know whether or not it it passes your your your filters so you have to you have to remove everything and so you have a massive handicap as as a as a sensoring builder like the only thing that you can and see in the clear and you can you you you you can really um have an edge on this these Arbitrage transactions but you lose basically the the the the tips uh for uh for for for for transactions okay so now the the the final part on the the metadata so one of the things to realize is that when you make a transaction there's all sorts of metadata um that that is being that is being leaked so there's IP address uh of the sender there's the size of the transaction there's who the sender is the the tip the the amount that's being paid um there's the gas price uh for the tip there's the the the the gas limit that's the nonce that's the signature and there's there's even like more subtle things like the the timestamp the moment in time at which you post a transaction and my claim which is maybe a rather strong claim is that you can you can prevent uh all all leakage like you you can basically um have have no no privacy leakage whatsoever for any of these things and really it's a matter of going through them one by one and and for each trying to find a an appropriate solution to not leak the the piece of metadata so for IP address we have tor that's kind of a an easy one um for for for for for the signature well one of the complications here is that um I mean usually signatures don't really leak information it is there are some significant schemes that do leak information but here it's more um about uh transaction validity so you you want to somehow convince that your transaction is is is is is valid um your encrypted transaction is added to to the Builder who will include it in in the blog and one of the things that we can do here is basically use uses a snock and a snock has you know several parts to it so it has a public input it has a private witness and it has a statement that's being proved in zero knowledge and so um for the signature what is the the public input basically the the user is saying here's my transaction ciphertext it's part of the public input and here is the state route of of the of the ethereum blockchain which is which is also public and then the what the user wants to do is try and convince them that the encrypted ciphertext has has a has a valid signature and so what they'll do is that what does it mean to verify a signature it means that you go fetch the associated Pub Key you validate it against the state route with a macro proof and then you prove in zero knowledge within your snark that your your your your your Merkel your Merkel proof is valid and that the signature is valid and then basically you can do you can do the same thing for every single piece of metadata um so for the for the Gas payment it's a very similar thing right you um every account on ethereum has um has a balance and you want to go authenticate this balance against the the state route and prove that the the macro proof uh is added and then what's specific to the balance is basically you want to prove an inequality you want to show that the sender balance is is is is is is is is sufficient uh to pay to pay for the uh for for the gas costs for example the the four the full gas limit uh given the the the the the the base uh gas price again same thing for the knots right like every account um not only has a Pub Key Associated and the balance but it also has a nonce same story here and there's a there's a there's a little um subtlety here um around the replay tag so one one of the the reasons that we have done says is basically as a anti uh dos mechanism um we basically don't want uh one uh one address to be spamming you know millions of transactions we only want basically one address to be able to broadcast only one one transaction and the way we do that is with with the nons we basically will only broadcast in the in in the peer-to-peer Network a single a single transaction for a given address and the given nonce you know per unit of time for example so you can only uh you know increase your gas price for example once every second and that provides the anti DDOS mechanism and you can get the exact same entity DDOS mechanism with a so-called replay tag and one way to do it is to basically take the have like an encrypted nonsense in a way where basically you you hash the nonsender private key and so that's going to be a unique piece of information a tag for the for your your for your address and nons Tuple in such a way that you um if you if you were to try and spam uh the the PHP Network then people would realize that that the same non the same replay tag is coming over and over again um great um now one one of the the kind of the the cool things is is thinking about uh obfuscating the the size of the the transaction so one one idea here is to to pad to the closest power of two you have transactions of various sizes and you know just by looking at the size you might think okay this is a Unison transaction and this is some some a transfer for example because it's smaller um and so what if we just um pad to the to the closest power of two and I think this is a great solution that gets you you know 80 of the of the way there but there's there's a couple um kind of deficiencies of this solution the the first one is that you get um you get imperfect packing and the reason is that you have to pay for these padding bytes these zero bytes that you that you that you have you have to put them on chain and you have to pay for the data availability so there's these little white squares that you have to pay for uh which is a bit sub-optimal and the other thing is that you have imperfect privacy because you know you even though you're padding to the closest power of two there's still going to be um different uh transaction sizes and so the the one of the suggested Solutions is basically to use homomorphism um something which is you know trivial to do with sgx and you know harder to do in with other types of encrypted man pools but let's go um let's let's see how homomorphism can help us well basically what we're going to do is we're going to apply a function which is the tight packing function the function just um takes the the the the plain text and just packs them as close as possible and then outputs a full block of the maximum size so if your the maximum size of your blocks let's say 100 kilobytes which corresponds to I don't know a gas limit of of 30 minutes well you you you're just going to pack everything no but within that and the the one of the nice things here is that you you get both the optimal uh packing and and the optimal uh privacy um now I don't have much time so I'm just gonna skip uh skip ahead but basically you can do the same thing um when you're packing you can also take into account the the the the the the the gas price and you can you can do prioritization based on that or based on access lists [Music] um and I guess one one of one of the things that I I only realized recently is that you we might actually be able to even hide um something a little counterfeit counter-intuitive which is the timestamp of the transaction like you know one might think that when you broadcast a transaction it's kind of fundamental to leak the timestamp but maybe maybe it's not and um basically the the idea here is that the the the peer-to-peer gossip Network can can handle a maximum number of transactions let's say you can handle a thousand transactions per second being gossiped around and so what we can do is that if at any point in time we're under this maximum capacity for the peer-to-peer Network we can broadcast dummy transactions that look exactly like real transactions because they're encrypted you can't distinguish them but um you have this kind of this magic homomorphic function that operates on on the plain text that is able to filter out the dummy transactions so as an observer of the mempool you're just observing a constantly saturated mempool um you know that's processing a thousand transactions a second but at the end of the day when you produce a block all these dummy transactions are are filtered out so you don't have to to to leak information on on when users are broadcasting the the transactions and that's it happy to take questions hey could I jump in and ask you to um say more about uh the homomorphic encryption plan you had in mind there I mean the main question I had is um who is it that has the secret key for the homomorphic encryption in your setup okay great question so here one thing you could do for example is you could give every validator and there's about half a million of those but let's let's say there's a million validators which I expect will happen each validator is allowed to make one dummy transaction every Epoch let's say um and so the the validators would be observing the mempool and they would be um signing with the validator private key and they will be able to set the flag you know the dummy flag to true and basically the stock that they would publish along with the encrypted ciphertext would say I'm a validator and so I'm I'm allowed to produce these these dummy transactions and um I and I know that they will get filtered out because the function that operates on on the plain text can just read the flag see that it's a dummy transaction and then filter it out so basically we're making use of the validator honest kind of majority like if we have sufficiently many owners validates as producing these W transactions then the the mempool just looks like a white noise okay so it's like a threshold it's a threshold homomorphic encryption that you have in mind where the secret key for the encryption is like a quorum threshold thing held by the validator nodes and then that means that the majority of the validator nodes have the ability to decrypt every transaction but if they follow the rules then they will only decrypt the you know added up homomorphic operation transaction after the fact is that the right way to think of it um so not quite I guess this this two separate questions that you can ask so I guess the question that you're really asking is what is the the the flavor of of homomorphism and it turns out the answer is that it doesn't matter it could be anything it could be it could be Enclave you know sgx based it could be threshold based it could be delay encryption it could be witness so each each of these five flavors of encryption comes in the vanilla plane mode or it comes in the advanced kind of homomorphic mode so you can think of it as a five by two Matrix where you have well this is exactly the five bedroom Matrix um where uh basically some some of these are already and some of these are not ready for homographic encryption so my my uh yeah my claim for example is that let's say you have an sgx based solution you can you can trivially do these home movies and now the question that I was answering previously was around kind of who's feeding these dummy transactions um to to the encrypted mempool um and and and here is the validators but uh uh yeah the validators don't have to to participate in in in in the in the decryption process at all and if you take something like delay encryption um then really doesn't there's there's no party to trust you're just trusting physics um you know here you're trusting Intel with The Enclave here you're trusting you know flashbots maybe for Flash boss protect here addressing a committee but here with the encryption you uh you don't have to trust anyone so just to make it a little bit more concrete you know you have a thousand transactions a second that are coming in and they have the property that in 10 seconds you know they're all automatically decrypt so that's the delay part but they also have in addition a homomorphism property where you can take these transactions and kind of do operations on them in such a way that you go actually build the block while you're you're going through the process of of uh of decrypting them with the with the sequential computation um sorry I raised my hand um I'll just um ask I've been wanting to ask this since I um so on um which dimension um or which Dimensions do you think are actually meaningful uh when we evaluate um privacy Solutions in the context of um uh Meb um mitigation or Meb Solutions um you labeled um I think one of the acts as sophistication um and um and multiple other dimensions but I guess can you sum it up for us um technical properties economics um how do you think about this right so I mean I I would take a pragmatic approach and basically exactly as you said just follow the sophistication uh Frontier so just do whatever is we can do today um you know we've started with flashback protect I think it's you know an interesting start but it has you know obvious downsides because it's controlled by one entity um I think the the next you know obvious thing is is actually sgx and we have a whole panel to to discuss that I think sgx is like ready uh to to to to be deployed in production I think the the next front you know move after that is is threshold encryption um now the one of the reasons why I kind of put soon for homomorphic threshold encryption is because of um basically fhc so you can take an fhc scheme and you know you can just threshold thresholdize it uh by uh by by splitting the the private key basically um now the the you know one might say Okay FHA is just you know still years away and that and and that might be true but it turns out that for for very specific use cases um fhu might might be perfectly fine and like the the one thing that I'm especially kind of excited about is this idea of looking at access lists so I have a little um why is it yeah so here I have this uh the the this optional access list comment which basically says each transaction can come with an encrypted access list which will be readable in plain text by the the homomorphic decryption mechanism and what you can do is you can try and just pack your transactions in such a way that you have disjoint access lists and it it it might turn out that this is kind of good enough in practice you don't have to run the the whole evm in within fhe you only have to compare access lists and it turns out that comparing access lists is a so-called low depth um you know circuit so when when you're designing these circuits a little bit like snox you want to make sure that they're small but for fhe specifically you want them to be load depth um and and and you can do that for for Access list comparison um which which might mean that fhc is is kind of uh will be ready for the purpose of building you know optimally enough blocks uh you know sooner than people might expect and then if we talk about the long term you know are we going to have an encrypted mempool within uh you know the layer one if ethereum and I think this will only happen uh if we have delay encryption because that's the one thing that's like really trustless you're not you're not relying on on the committee you know we've been trying to to get rid of committees obviously the first two are not applicable for layer one ethereum because you're trusting companies uh but uh yeah delay encryption is the thing that that could be enshrined in layer one but I think that's we're talking maybe half a decade away uh before things are awfully mature 