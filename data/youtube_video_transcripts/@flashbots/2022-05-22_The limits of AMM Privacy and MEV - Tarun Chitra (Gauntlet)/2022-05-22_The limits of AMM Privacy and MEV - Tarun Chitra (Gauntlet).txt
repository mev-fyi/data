[Music] we're gonna talk i think the next segment of talks are all about batching in different shapes and forms um and this talk is going to be about sort of like the sort of theoretical limits of what you can get with batching um in and and sort of like what privacy looks like in amms whether it can exist or not uh this joint work with  who's in here alex and guillermo who are both here somewhere in the audience cool so both people here probably already know a lot about uh dexes that they've used or sandwiched people on whatever uh so you know maybe we'll start with a little history of the automated mark maker actually goes back to 1971 uh with this scoring rule from savage and uh you know it was popularized by robin hansen 2002 with the logarithmic market scoring rule but the idea is that people are able to pull their assets into a contract say two assets a and b uh those are reserves and the uh arbitragers trade between kind of this pool and external markets the price is too low uh relative to an external market someone will buy and sell externally vice versa buy low sell high nothing special um you know and one question you might have is hey is there an invariant is there some sort of function of the reserves asked to be held constant which is what we're going to talk about but the two simplest versions are one that's a fixed asset price at all amounts so i will always sell you five guillermo coins for one dollar uh and then the other is sort of uh which you know most people are familiar with is uniswap um but we should actually think a little bit more generally mathematically about what the sort of space of these mark makers looks like and uh to do that we'll we'll basically formalize this somewhat um oh i i i know the i see guillermo's face for my one typo on this slide but a constant function market maker is a contract that has n coins each of them has a reserve ri liquidity providers supply these reserves and traders can add and remove the coins provided they keep sort of this invariant constant really greater than or equal to constant um the super level set of this function is called trading set and it turns out to have some nice properties uh and the simplest version of this invariant is the constant product which is unison so let's actually think about this geometrically because i think it makes it a lot clearer uh the trading set is the thing shaded in blue the dark blue is the boundary this is this x y equals k all the points on the boundary are sort of the sort of feasible points those are the the trades you can do that sort of keep you at no arbitrage but you could you could trade inside uh but then basically you would be giving away free money to someone uh and so in this case you know we have the set it turns out that there's a lot of sort of mathematical properties about it namely convexity of it that's quite important and uh you know you might say well why do i need convexity well suppose we have a non-convex trading set like this uh draw a supporting hyperplane that uh you know intersects two points you get basically the same price for two different reserves uh so you might as well fill it in it might as well be flat across that region okay that's that's the high level kind of like you know 101 into cons function market makers now we're going to talk a little bit more about how different constant function market makers have sort of a notion of price impact so you know when you go into a unislop pool that has no liquidity you look at the price you're quoted you're often times unhappy you you go to one that has a lot more you're oftentimes happy but one question is how do we generalize that notion uh to other types of market makers say curve balancer uh any functional form that satisfies this sort of convexity property so uh it you know kind of a natural thing you might think of from from calculus is curvature uh curvature is usually represented by like second derivatives of functions a little bit different here because there's an implicit function from the constraint uh but what we do is we actually can can define something that's called the price impact function price impact function tells you if i you know i make a trade of size delta uh how much does that change sort of the function in asset 1 versus asset 2 that ratio that slope is the price so if we go back here the slope of this line is the price at the point the slope of the tangent line and so this is a way of sort of generalizing that and we define two constants that are important to think about called mu and kappa which are sort of upper bounds on how much that slope changes and that's sort of this notion of price impact uh that you see so let's look at in pictures because you know i think it's sort of you know i i i've certainly forgot the statement of the implicit function theorem because i i learned it 15 years ago but like you know it's it's it's not like that interesting to kind of understand where that ratio comes from as much as it is to see what it looks like in pictures so suppose we have two amm curves uh we have uniswap in blue in the upper left we have balancer in green underneath and uh suppose they're basically at different prices so the dashed line the dashed blue line is the price that uniswap is quoting the slope of that and the dashed green line is the price of balancers quoting and so now there's an arbitrage they're two different slopes so an arbitrager goes in makes some money and what happens afterwards well we see that the two slopes are equal but more importantly we see that the green line the slope changed more and that's sort of this notion of curvature the the more it changes when you kind of have to do these types of retraction and similarly with curve we see something flatter than uniswap right we we basically have the same same sort of thing uh and so this this sort of gives you an idea of like what this notion of curvature is it really captures slippage and price impact in a more mathematically formal way then hey i'm just going to keep plugging in terms into the invariant and like looking on the ui if i'm causing a lot of slippage so one question that's actually kind of dogged people since the invention of constant function market makers is can you ever make them private and they have this sort of inherent problem that you can't really hide uh your trades in these systems i mean that's sort of the reason that you can sandwich people so you know there was there was certainly in the 2017 boom there was there were tons of icos that raised money on the premise of hey we're just going to add zk proofs to dex and boom it's going to work and your trade no one's going to know your trades no one's going to front run you unfortunately it turns out you know a short note we wrote you can prove that for all constant function mark makers you can basically never preserve privacy because you can always invert the trade sizes if you know the liquidity at one point in time and the price changes and the idea very intuitively is that well this is a convex set and i'm looking at how the convex set is changing under each iteration well it's naturally going to have sort of a minimum point or a supporting point and you can sort of invert uh kind of the prices invert the trade sizes so that's bad that means that everyone can kind of even if you try to use some zk proof to be like i'm going to like hide the reserves the fact that you're quoting prices publicly like people have to see the price in order for them to decide to trade means that they can figure out from the price changes exactly your trade size and then they can do all sorts of other things with that so there's only really two options to avoid this number one is batching so that's the next series of talks i think that this is batching hour um not bitching hour uh and randomizing so randomizing is adding noise to the prices so that people when they invert it they don't invert the correct trade size they invert some something that's wrong um blockchains are great for the latter of course because we have verifiable randomness we have provable randomness you can i can't with the randomness but the problem is how you randomize the prices actually can affect your privacy quite dramatically so suppose for simplicity i say okay i'm just going to draw some iid random variables ci i'm just going to to each person's price i'm gonna add that noise in the quoted price well this is bad the central limit theorem says like actually either you're adding a huge amount of variance from these ci's or you're basically you can make you can filter and and figure out what the the real prices were so now it's time to talk about adversaries um and uh given that this was done in beamer and latex i didn't have very good uh emojis so uh this is my emoji for adversary i i don't even know what it is it's like a it's like a vampire and the joker had a baby uh so uh basically there's this concept and this is a concept that's actually quite common in the machine learning and privacy literature of privacy utility trade-offs so you know i can start hiding your data i can start kind of like obfuscating the data but i also make the machine learning algorithm worse like the moment i start adding noise your netflix recommendations start getting worse right and there's this inherent trade-off between how much i am able to hide your data and and preserve it from an adversary trying to invert it versus how much am i distracting how much am i reducing your utility what you're actually getting out of the algorithm and you could view an automated market maker as a similar type of thing it's an algorithm that gives you a price impact uh as a function of something and if i'm adding some type of noise that's maybe increasing your privacy i'm also inherently giving you a worse price and so there's a natural way to measure this privacy versus utility trade-off is price impact versus privacy price impact how much more money do i have to pay to get privacy and then privacy is what is the number of bits sort of how much precision can an adversary estimate my trade size with so batching great for privacy bad for price impact in the worst case so the worst case for batching is i have let's say a trade vector size where there's t trades and one trade is of size t and t minus one trades are of size one well in the kind of earlier thing i talked about like if the curvature is sort of lower bounded well you actually now cause omega of t so lower bounded by t price impact um which means that the the trades are of size one they got screwed by the big whale trade right they basically have to pay they're basically subsidizing that trade in some sense so these constant function market makers bad for privacy but very good for for price impact and that you can kind of understand what's happening so how do we parametrize something in the middle so that the user can kind of choose what they want so the model of the adversary adversary just has a couple sort of simple simple state has reserves it knows what the liquidity of the market maker is it has a marginal price calculation it can compute the current price and it can take a trade and compute is valid is this trade in the trading set and we don't assume they know any identifying information which could be hidden by zero knowledge proof so one way of thinking about privacy is from the perspective of the user who's losing their privacy and getting sandwiched another way of thinking about privacy is from the perspective of the adversary how efficiently can the adversary learn the trade size given the data how fast can they invert it and so in uh you know statistical learning theory you may have learned of things like vc dimension or sort of notions of complexity um so this is sort of related to that so you have an adversary they want to front run the whale trade so you have a bunch of trades of size one this huge trade of size t you could think of an adaptive adversary and so in in like layer one security proofs you also see these notions of adaptive adversaries your adaptive adversary wants to learn a bunch of boolean functions where if the wales trade is the i trade uh then it says true and if it isn't says false and if it turns out the adversary can find any advantage they can they can basically do a tiny bit better than a coin flip they're sort of classical statistical bounds that say the adversary can start imputing the actual true trade size with very high probability so in some sense how much noise you add controls how well the adversary can invert can construct a learning algorithm that can learn your trades so uh probably one of what i consider the top theoretical computer science results of the last five years is something that shows that online learnability so like whether you can learn something you get a sequence of of data and you're trying to learn some property of it that online learning is equivalent to something called differential privacy and differential privacy is is is uh the notion of privacy that if you have an apple phone for instance that's what face id uses so apple doesn't get your local data for your face uh because they use sort of they add some noise to it so they can't recover it perfectly and so the cool thing is that uh basically people showed from a complexity standpoint algorithms that can online learn so i give you a sequence of things and i learned some property of them just like learning this these trade sizes are the same as the differentially private ones and so this suggests that if we want to try to analyze how well an adversary can do we should actually try to look at what differential privacy guarantees we can get so what is differential privacy so differential privacy is effectively uh you know if there's someone who gets a data set and i randomly remove one element of the data set they basically don't have a very high probability of being able to tell whether that person was added or removed so let's say we took everyone in this room's height we made a data set and someone rolls a dice and we randomly pick one one person's height out if i compute the average height and well that one person is like nine foot tall or as well price uh you know uh basically like you can tell right the average may have moved by like five inches uh so what you have to do is you you have to add some noise so that someone can actually tell to that precision formally it's this definition not that important kind of boring but it's sort of a bound on the kl divergence with some additive correction all right so absolutely no proofs just only going to explain the high level result which is if you have a constant function market maker you can achieve differential privacy by basically splitting up trades randomly permuting the order of the trades and then chopping up whale trades that's what these three things and adding some noise uh to the the trade quantities and the way you reason about this and the way you should reason about mev often is you have to construct combinatorial objects that sort of represent the dependencies between different transactions and it turns out for trades you happen to get a very simple dependency graph it's this thing that we call the trade tree and it's made of the partial sums of permuting the trades um and so you know here's what it looks like in pictures if it's balanced and the main thing to know about this is that if you remember from sort of if you're taking a algorithms class you'll learn that quick sort has you know this like expected login runtime well that's because you construct this sort of heap of your uh kind of sorting algorithm and the heap on average has login height which basically is is is how you get complexity uh it turns out this this kind of uh expected run time thing is also extremely highly concentrated so uh you know quick sort actually works a lot better than you might think because it actually they're very few bad instances and the bad instances shrink really fast as the number of samples goes into me so long story short we we basically construct this tree we're able to bound this and then basically use a bunch of things where we add noise split trades and show that you can get differential privacy so what this says is in this most general adversarial model where you want to sort of thwart mev or sandwiching you force the user to pay this cost either they pay this price impact to get this privacy uh or or they kind of you know basically either they get perfect utility or they get perfect privacy and this sort of interleaves between the two so what does this really say kind of in the long run about mev this is more technical stuff well we should actually be thinking a little bit about like what strategic behavior in automated market makers look like um these sort of differential privacy bounds are sort of they assume the arbitrary adversaries and that's why they have sort of like not so great price impact like you're you have to pay a lot of money for privacy and at some level if your utility is how much you're paying you know there's there's just some natural trade-off at which you're like i don't care sandwich me right um so what really hap what happens on the other hand if agents are strategic they they choose their slippage limits based on what they think everyone else is choosing their slippage limits at and they choose their slip legitimates based on their estimates of sam uh you know searcher behavior and searchers similarly uh are strategic and they try to choose their behavior in response to what they think other searcher's best behavior as we saw on some of the panels earlier that is actually true and you know you may say okay what's sort of the stable state what are the equilibria that come out of these kinds of economic systems with at least with automated market makers where we can study them and uh there's sort of this concept in algorithmic game theory called the price of anarchy and the price of anarchy measures sort of let's say i have a social equilibria that's sort of the best outcome for everyone in an economy and i have an equilibria where everyone acts selfishly uh and just tries to optimize their own profit uh the price of anarchy is just the ratio of those two how much worse is the economy when everyone is selfish versus trying to find the minimum which requires coordinating or cooperating and uh it turns out you can sort of write out what that looks like for for these amms and basically show in some scenarios uh it's actually not that much worse with sandwichers than without them so end of the day we all know constant function mark makers are powerful right there's billions of dollars traded on them every day we also know there's billions of dollars of lifetime extractable value from them but in some ways we can kind of mitigate this by providing users something in the middle and there's also sort of this natural question of how stable these equilibria are and we're you know effectively i think we're at the point where we can actually study those and have data for it and i'm done [Applause] uh i guess we've five minutes for questions any questions none fine also you see you have 3.3 way to fix like the the privacy house yeah yeah so so the first thing is randomly permuting orders so like if you if you look at like the literature um of what people call like fair ordering solutions and in blockchains a lot of them end up basically trying to do this where they randomly permute the set of orders in a block so that you can't really predict you know where a certain transaction will be and so if you try to like sandwich it or submit a bundle you can't do it of course fair ordering requires a lot more extra work and so uh it's harder but in the amm case it's actually a little bit easier you can just randomly permute the trades within the contract a lot of proof-of-stake networks have randomness as a first-class citizen in contracts and so it it actually ends up being real too easy the second thing i remember how i had this example of we have a whale trading size t and then people trading sizes one like t minus one people so one of the reasons the random permutation doesn't work there is there's t factorial permutations but if i apply all the permit this i look at sort of the orbit set of like applying every permutation to that thing i only have t t elements i've lost a lot of entropy i went from n log n bits of entropy to log or log t t log t bits of entropy to log t bits of entropy right and so that makes it much easier to invert so you need to add some noise to recover that sort of amount of entropy in the or in the orbit sets um and so that comes from splitting up the big trades and adding noise uh and there's sort of the math around that is like there's some concentration equality is on sort of randomly permuted sums so cool thanks for your talk turn how fast have you seen the price of anarchy change that's a good question so we we we've only like written up how to calculate it um basically what you can show is it's like lower bounded by a constant which means like you know let's say the constant was one-third just uh for here's for for example that means that the market with searchers and selfish behavior is 33 as efficient as if the market was trying to find the total optimum optimizing everyone's utility um so effectively you know most of the results theoretically are all lower bounds but you can use those to calculate what the true observed thing is in production and that's like future thanks for talking um i had a question regarding specifically like ordering for dex chains with private mempools so when you talk about the size of how large these systems can get i'm assuming that for most public blockchains you have essentially an infinite size for the amount of liquidity that you're anticipating is there an upper bound on the privacy that can be enabled via prime impulse on these dex chains that is not comparable to what we see on ethereum or other chains relative to that i don't think it's strictly just the private mental piece i think it's also just like how do you guarantee like order that the ordering is also sort of executed randomly and if we look say it like flashbots auction right now right it's a it's a sort of greedy combinatorial auction uh and you know greedy auctions for instance are you can measure the price of anarchy of those and those also are quite quite low um so we're not even close to efficient in like how we order bundles or like choose this these kind of like ordering constraints um and i think the private mempool piece doesn't provide you that much privacy if if you're if people are like you know depending on the number of people who have access to it relative to the total number of users so uh i i do agree that there's probably some benefit but it's not at least theoretically i don't think you could really say much mathematically cool thanks [Music] you 