uh all right so here we are um hello everyone uh my name is Henry uh this is my talk show the transactions or Roll-Ups so if you're already convinced then you know great um otherwise uh let me kind of go through what I mean so uh I work on a project called penumbra what it is is a private proof of stake L1 that has an interchange shielded pool so you can record any kind of asset from any IBC compatible chain and what can you do with those assets once you move them into the shielded pool you have a DEX that allows people to do private on-chain strategies so this talk isn't primarily a talk about you know what penumbra is as a product and so on but we've been focused on how do we solve this one really specific use case and then from trying to solve that one specific use case what are the kind of common features that we can generalize uh to you know more more varied kinds of computation so to start off the talk about sort of how do we view shielded transactions as being like a weird kind of roll up um why don't we say what is a roll-up in general and I think um a lot of the time people have this idea of oh a roll-up is a way to have like more copies of ethereum right and I think that that's a pretty limited uh perspective of of what we could do in general I would say a roll-up is when you have like one part of a system that we'll call the base and there's another part of the system that we call the roll up and there's this kind of like flow within the system where the base offloads execution onto the roll up and then the roll up sends back some kind of a state route as well as some kind of reason why people should trust in that state route maybe that's there's a ZK proof maybe there's some kind of economic model with a you know an optimistic roll up but fundamentally it's about having a flow of execution moving out onto the roll up and certification and kind of summary of the results coming back so there's a super super enormous flexible design space here um and in this talk what I want to do is is look at a shielded chain from this perspective of like thinking of things as as Roll-Ups so to start off um in order to have a shielded chain you need to have some kind of composable state so you need to have uh the the state of the chain split up into all these little fragments and each frac each transaction is going to consume certain existing state fragments and then produce new ones as outputs so this is kind of like a utxo model although I personally am a little hesitant to use the word because it has a lot of like Bitcoin related baggage really what's happening here is that the state is split up into fragments and transactions only operate on certain transaction certain fragments of the state why do we need this it's so that we can replace all of those on-chain State fragments with just commitments to those States and that way instead of having to have the transaction actually work on all those things directly we can just do a ZK proof and hide the details of the state from the public chain but when you do that it's not really just that oh we add in a ZK proof fundamentally what's happening is that the execution of the state transition is moving off chain and so effectively you can think of each individual transaction as being its own little sort of micro personal roll up and a lot of the problems that arise in trying to build practical shielded chains you can kind of see from this perspective as we'll see so one big problem that comes up is uh oh oh uh I guess never mind um so yeah before doing that we'll we'll give a little more detail on on his perspective right so what do I mean exactly when I say the that a shielded transaction is is a kind of a micro roll-up let's look at some uh transaction on a shielded chain in general what are the pieces of this we have some kind of ZK proof that's going to provide trust that everything that the transaction is doing was done correctly um we're going to have some commitments to new output states that this transaction has created and then we're also going to reveal some nullifiers that consume the input States so you can prove in zero knowledge hey I know about this state that was previously included in the chain it's valid um but you now have a problem of how do you prevent uh double spends and the the general technique to do that is you assign each sort of piece of State a unique serial number or nullifier that's only derivable by the user that controls that chunk of state and that way they can reveal this random value and kind of remove that that piece of state from the the kind of active set without revealing exactly which which state they're they're nullifying finally a shielded transaction generally is going to have some kind of encrypted payload in it and the reason is that in order for me to you know use this chain I need to know like not just the the chain needs to be convinced that my transaction is valid but as a user I care about you know being able to learn what exactly my transaction is if I go on another device if I'm trying to sync how do I recover my own state so you can think of an existing shielded chain like for instance zcash that's kind of bundling in this like data retrieval mechanism into a like monolithic chain design so what's kind of the the problem here this is what I was about to get to is why haven't we seen this be you know particularly useful or or receive a lot of adoption and I think the problem is that when you do this change what you lose is the ability to do late binding what I mean by that is we have this picture of okay here's a transaction it has these inputs it has these outputs and this whole state transition is this kind of sealed pre-computed thing but when you look at what people actually like to do with blockchains they like to interact with the chain and so that means that they need to have some kind of late binding capability you want to say I want to do a swap and when I do my swap I'm going to commit to these are the inputs that I want to swap but I'm not going to sign over like here's the exact state of the unit swap reserves and here's therefore the exact amount of output that I'm going to get I don't know that because at the time that I'm making my transaction I don't have access to that state and I can't ask the entire world to just like stop and do nothing while I submit my transaction because I'm important so the way that this is usually done is that on a transparent chain is that when the transaction is executed it can access the chain State and so the chain can kind of fill in the gaps and then determine what the outputs are and naively when you do this sort of shielded transaction uh uh rearrangement you lose this ability this is one of the things that we really focused on in in trying to you know build a DEX this problem of how do I know what the price is before it gets executed just shows up very very clearly at the start and the answer that we came to is that you know in a sense this is a kind of like a similar problem as doing like cross roll up communication if every user is doing their own little independent uh State transitions on their own end user device then somehow those need to be able to communicate with each other and they're all going to be executing asynchronously so we need to have some model to do asynchronous ZK execution via message passing and a kind of schematic diagram of how this can work is I'm going to make an initial transaction that kind of sets off the action that I want to do it's going to consume my private inputs but because I don't know what I'm going to be sort of filling in the gaps with yet I can't finish the computation immediately so instead I'm going to send a message to whatever public contract I'm interacting with maybe that's on some other Shard of the state and my output for my initial transaction is actually going to be a commitment to some future in the programming language sense of an asynchronous computation that's waiting for some fields to get filled in and resumed if you've done async await programming you can imagine sort of each await point where you're waiting for some message to come in as turning into a point where you need to pause the computation you need to commit to all of the intermediate execution State at that moment and the reason that you do that is so that later once you get the message from the contract coming back maybe that's like hey your swap was executed with this price now we know what the price is now you can mint your outputs um the the user who had created that uh commitment to their intermediate execution State can now resume execution by spending their commitment and uh slotting in the public inputs from the contract into the appropriate places and minting their private outputs so when we do this on penumbra for swaps right the the public input that's coming in from the the contract is what was the batch price for that block and the private outputs are then you know that user's Pro rata share of of the the batch so what I think is really interesting about this perspective is that it means that you can kind of generalize right you start with this idea of oh we have a multi-asset shielded pool we can record any asset but since those assets you know can be anything they can also be assets that represent you know arbitrary intermediate execution States and so now in the shielded pool the the invariant that I can't double spend funds that I can't just like print tokens is saying that I'm not allowed to just kind of restart execution I can't clone my program I need to sort of only act you know advancing my computation in the allowable way but the shielded pool can be recording anything that I want and so this I think is is what kind of um gives me this this sense that right now there's kind of this split in the the ecosystem where there's a bunch of efforts that are working on ZK for scaling there's another uh collection of efforts penumbra included that are working on ZK for privacy but I think we're actually going to see a kind of convergent evolution of these things into some sort of you know glorious future this is the the show portion of the talk um and the the perspective there is that what privacy enables is a kind of edge compute for blockchains so in the current world right all of the uh execution is happening you know sequentially one after the other everybody is doing a transaction taking a lock on the entire state of the world everybody else has to stop everything well I run my transaction and in this private world where we do computation asynchronously we can push the computation off of the base layer and out to the edges of the network but that's not necessarily saying like oh let's just like make you know a second copy of the exact same state model but we can go much much further and have this sort of like fractal like pushing all the way out until the end user device possibly over multiple Hops and then those users are going to send back their transactions that have only their proofs and data and those things can get summarized as they move toward the core of the the network so in this picture right we have uh you know the reason that it's sort of like grayed out right is is that there's no actual computation happening there it's just certification of the the data and these are all you know users with their own wallets uh doing their own computation locally um with this perspective there's there's another kind of neat thing that this uh enables which is that there's new possibilities that come out for State Management I think this is one of the hardest problems with blockchains and with scaling blockchains um having every single person in the world just use one world computer doesn't quite scale and if we go back to this picture of like okay what is actually in this shielded transaction we can look at it and say like what's really the expensive part here right so we've got this proof let's say it costs like two milliseconds to verify that's not a big deal we have uh the commitments to the output States those are 32 byte values clients might have to feed those into a tree that they're using locally for proving but they can filter like hey these ones I don't really care about because they don't relate to me the nullifiers are also 32 bytes um really only full nodes have to be processing those and although there's you know discussion of like hey there's this nullifier bloat problem where the nullifier set grows forever I mean realistically you can have a lot of 32 byte values before you really run into problems and so I don't think that that's a pretty significant part either the real problem is this encrypted payload right it's not 32 bytes it's going to be bigger than that because you need to have the the full transaction data and unless you can build some other kind of system for allowing users to identify which states are related to them a priori would have to be scanned by every client and most critically if you lose this payload it's actually equivalent to losing your funds right because the chain doesn't have it has perfect privacy there's no way to know what all of these State commitments are and so if you don't know like hey what what was the note that recorded my funds that I control there's no way that you could possibly spend it and if we look back over the last like 10 years of uh doing blockchains managing State managing Keys is very very difficult even if you have you know fully deterministic derivation of all the key you know seed phrases are basically a technology that was invented to solve the key loss problem like let's just figure out how we can derive everything from one secret that we can somehow get a handle on these payload data it's equivalent to a key but um it's created dynamically and and so putting it on chain is not just oh this is a convenient way to like schlep the data around but it's also a kind of a security feature right if you want to move that off chain you have to have a really really robust story of how does a user ensure that they have backups of all their data so this has led us to thinking about a sub-project that we call narsal and the idea of narsal is to try to create a personal roll up so using the same diagram that I had before of okay well we have our our base chain it's just mostly going to be focused on doing certification and we're moving the compute out to the edges well we can have this fractal perspective where those edges maybe some of them are you know a web extension that's syncing your client State maybe there's an app on your phone or maybe one of those edges is actually its own chain right so we started actually thinking about this because we wanted to have a story about how to do threshold custody where multiple keyshard holders can collaborate to produce a signature on a particular transaction this way you can do like you know multi-sig transaction authorization flows but when you start thinking about that you get into questions like okay well if we're not using the chain to coordinate how do the signers who are participating like know what all the the signing requests are like how would we make those signers have a consistent View of what transactions have been requested um and we're already using tenderman Comet bfts so like sounds great we know how to do that why don't we just have the shards communicate with their own code BFD Network they can run it in in proof of authority mode and what that means is that you actually not only get strong consistency of like hey what are these people signing between the custodians but it also means that every custodian has a fault tolerantly replicated audit log of everything that has ever been signed by this threshold key and that's exactly what you need in order to be able to have assurance that I can safely move my user State off chain I can skip posting those encrypted payloads and keep that only for myself and I know that I'm going to be relatively secure and resilient because I'm already replicating that across my own uh internal Network right so you could imagine say like a market maker who is going to be updating quotes on chain reasonably frequently right why should every user have to be scanning that market Maker's State updates if we could have that market maker just run their own personal roll up replicate their state internally and get you know less gas fees so that's uh hopefully sounds interesting um the plug is if you want to play with any of the stuff that we're building um cure a bunch of links everything we do is totally in the open we have test Nets you can play with them we have a Discord if anybody has any questions or wants to talk about it with us at any point just like you know show up and we're always happy to chat [Applause] 