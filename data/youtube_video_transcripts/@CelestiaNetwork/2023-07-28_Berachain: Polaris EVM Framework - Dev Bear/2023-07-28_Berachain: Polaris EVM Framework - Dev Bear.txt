so today I'm gonna be talking about player CVM Frameworks um and kind of give a high level overview of bear chain as well um so a little context of myself Devar um CTO bear chain um and bear chain is a evm compatible L1 built on the cosmos SDK and what we did is we replace the traditional proof of stake system with what we call proof of liquidity which allows for re-utilizing staked assets to provide liquidity and making validators validators sorry validators take weight associated with how much liquidity they're providing so before we get started just want to give a little intro of our team our team comes from a wide variety of Team comes from a wide variety of backgrounds including web 2 web 3 all over the place and wouldn't be able to to build anything without them Clicker EDM um you know this being a cosmos adjacent con conference a lot of people ask us like why you know why EDM and the simple answer is there's the developer tooling and just the access to to utilizing the technology is so much simpler um you know there's millions and millions of JavaScript developers and we see the EDM as kind of the JavaScript of of blockchain and we think that by utilizing these type of Technologies and making it really easy for for people to build applications that we can onboard more users into into blockchain in general and the next question is why Polaris and when we sought out to build bear chain we had a lot of complicated logic that we had to add to the base layer and we saw that just like simply forking death we're taking another evm framework made it extremely extremely difficult to do this we looked into kind of some other app chain Frameworks and we realized that the commonality between them was that a lot of the time that they would get to something that was evm-ish and the problem with evm ish is that it's different than what developers assume it's different than what people assume and then you end up with compatibility issues like we've seen with like zksync and some of the other other l1s where it's just not close enough and it can lead to problems in just poor developer experience and the idea here is that we want to introduce an easy way for app chains to create an evm equivalent EDM that allows for them to just plug it in drop it in and create easy and a nice environment for extensions Etc and the idea of this is that we wanted it to be modular so we wanted a way to completely break apart all of the different aspects of the stack very similarly to the concept taken from the cosmos SDK so you know being built on Cosmos we have the networking layer the consensus layer and then the cosmos layer as our traditional application layer and we propose adding a new runtime layer on top of it which allows for the VM to be completely separated from the cosmos runtime which allows for it to be running a fully native standard UVM like you would see on ethereum mainnet and how we accomplish this right now given the limitations of comment in the SDK is we actually are able to build evm blocks from the data that's provided from comet um so we take things like the just the block header in general block height block time stamp Etc aggregate all the transactions out of it and are able to construct an evm block that is equivalent to to how you would see on on mainnet then what we do is we apply all the evm state Transitions and then we essentially post that block back up to the comment chain or the cosmos chain and store it State Route in the ivl tree so how how do we do this when we went when we went to start out to build an evm that's interactable with Cosmos and ABCI in general we wanted to come up with like what is the simplest easiest way to build a blockchain and at the end of the day we see it as pretty much three main processes so the first is that you need a way to like build the block and assemble the block so you're taking effectively a list of transactions ordering them in some way you need it then once you have that list of transactions you need a way to process them you know apply the VM State transition store the data Etc and then lastly you need a way to actually commit the block and make that part of the canonical chain so in ABCI this is prepare proposal process proposal and finalize block and in guess this is your you know your Geth Miner your gas State processor and then your store is your state DB or your blockchain so we realized that a lot of common blockchain Frameworks other than just Geth and Cosmos kind of follow the same general pattern so we realize that in Polaris what we could do is we can go and actually generalize this into basically three main interfaces or three main kind of constructs a block Builder a block processor and then a storage provider so what we do in Polaris is we essentially bifurcate the actual block building and processing and storage from the execution itself so in order to maintain that perfect kind of Json RPC compatibility with evm you know mempool block building et cetera is we actually run all of the all of the thunderblock building and storage on the cosmo side and effectively just use message passing to allow the evm execution client to do all the things it needs to do so for instance here we have an example here if I will just submit a transaction for for executing an evm I would actually do that directly to the ethereum side Json RPC and that will get inserted into my pool from there that gets passed over basically a message system which allows for ABCI to pick it up so then the Builder is able to pick it up and then that's how the proposal is made so all of that is done on the cosmo side but the actual user was interacting with the EDM side secondly from there we processed that proposal that basically again is taking that list of transactions that was built processing it through the system that's talking to storage that's talking to the actual evm interpreter et cetera and it's all done through this message passing Channel and then lastly we need a way to store what we did so simply in finalize block we're able to go and just write it to disk and say this now Buck is in the chain this also kind of allows us for queries as well so we not only to be able to support like native EDM transactions but also full Json RPC compatibility for queries Etc and we do it through a similar model the message dispatcher is able to get the request from the RPC talk to the cosmo storage and handle it that way this also works for you know transaction simulation for you know if you're running a Searcher that's trying to build a block you could do do it this way so the if call goes to Json RPC goes to the dispatcher and is able to touch not only the storage but can touch the processor which touches The evm Interpreter et cetera et cetera what this also allows us to do is it allows us to make all these components really really pluggable so in in the traditional kind of if you were to compile it all together you'd have to kind of choose an evm and you're stuck with what you kind of choose with um but what we're working on is making it so that you can plug in kind of different components from different clients and make it so you can really increase the client diversity so this example here you could take you know the transaction pool from ref the mempool from ref you could use airguns RPC which is notably very very well done and then if you just wanted to use like the standard Gap VM you could totally do that at the same time you could just choose to use all of them which is you know if you really like rust for instance you can do it this way lastly we also engineered something what we call the pre-compiled development kit which allows people to write these extensions to the evm or these pre-compiles in a way that's like really really friendly traditionally if you look at this like pre-compile example from Death you have to like write these really convoluted simple kind of structs that are really kind of hard to use right you take input bytes the return type is bytes and overall it's just a very kind of raw experience which makes it really difficult for developers to add functionality to their to their app chain or to their to their layer one or two um but what we did is we made it so that you are trying to get towards the concept of writing a pre-compile it should be as familiar as possible to someone who is um solidity or Viper native so if you look on the left here this is for the cosmo staking module we have like a staking.sol which is effectively you know getting your validators delegating et cetera et cetera and we're actually able to map those types directly to ghost trucks using reflection Etc so if you look here you know comma.address is the address which adheres to kind of what we see in solidity you know return types being big int is like a un256 etc et cetera um and then what we do is we utilize that same cost concept of the message patching so when we kind of see a pre-compile and we call it we're able to use the the message dispatcher to pass that over to the pre-compile manager which can call the corresponding Cosmos module which is really really nice from that developer user experience perspective so at the end of the day we can have all this cool Tech but what do the advancements actually enable so the first thing that I think is really cool is it allows for in the first time in Cosmos to have genuine client diversity on bear chain for instance we wrote all of our transactions through the evm and by proxy all of them will be utilizing different clients depending on what you know what execution client that validator or node is running this is really good for exploits it's just generally a good practice to have and overall it is the first time in Cosmos that we've seen this which we think is a really really exciting addition um lastly it allows for some really interesting uh things to happen at the base layer you've created a nice way to not only you know write application logic but also introduce that application logic into the base layer and create really cool things it allowed us to write some of our defy logic that we use in our proof of liquidity system on bear chain and tie that into ABCI in a really native way and it allowed us to kind of start building some of these interesting products like flash Bara Slinky which is the Oracle that I mentioned during the panel and then things like integrating roll kit into Polaris IBC into Polaris Etc so earlier today I did a workshop with Diego and Josh from Celestia that was basically showing some of the modularity of Polaris and really showcasing how truly evm equivalent is so we had a dyslexia da devnet running that's being used for data availability and consensus then we had a Polaris SDK chain that was integrated with role get that was rolling up to the DA and then lastly to really show off that evm compatibility we were able to deploy an OP stack chain that's utilizing that Polaris chain for its settlement which really goes to show how we truly have like an evm equivalent chain not only from an execution perspective but rpcs and everything all the way down as the op stack deployment stuff is notoriously a little finicky and is a really good test to see where we are and that's everything I have thank you guys for coming [Applause] right so it would be for any Polaris chain so it would be enabling like a chain that is running in players that has you know 100 validators to create client diversity within their chain themselves so it would allow for you know for for like the evm yeah for the EDM right okay is is Polaris a a like a consensus middle layer so the way you think about it is it allows for any Cosmo chain to integrate an evm really really easily so because it's completely separated all you have to do is kind of import the this module and it's allowed allows it to talk oh the module yeah allows it to talk to an execution client so like 100 oh cool that's useful thanks thank you hey um is the idea behind something like a flash Bearer to essentially have like per poster Builder separation for Polaris chains or is it more like the current uh version of like Meb boost kind of thing yeah so right now the current implementation of Ashbury is built on top of Skip's pob um so it's basically taking skips qrb all of their very cosmos-specific logic and adaptering it over to integrate into flashbots so it'll be all not flashbots as in what we see on Main net but the flashbots interfaces and what that allows us to do is it allows for Searchers that are running their bots on mainnet or allows them to integrate their existing code into a Polaris chain again with the concept of reducing friction for bringing ethereum ecosystem devs into Cosmos because they don't have to go rewrite all their tooling Etc nice thank you sweet awesome thank you [Applause] 