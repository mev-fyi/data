so thank you all for coming and for not coming um um there's been a very exhausting week and also a week where we've made great progress on a lot of the concrete Parts about where the industry is going in this talk I would like to give a few questions for the audience to think about given that now we're entering the layer two part of the day and Layer Two part of the layer of two part of the day many people here that you're gonna hear next are working on it full time I'm no longer spending as much time on this but I'm gonna try to offer a zoomed out View and some questions for the audience to think as people do their talks and for hopefully to reach some deeper insights my name is georgius and this is the old faradam so we'll start with what is nl2 I see John in the audience and Togo in the audience as well we'll see how that will go we'll talk about shortly what the differentiators between layer twos can be and what are net new exciting features that can be introduced then I will post some interesting hypotheticals for shared sequencers and then I will have a one slide for proverb proposal Builders operation or whatever the canonical name ends up which our next speaker will also tell us about so we will talk about layer 2 just from the context of um not bridging because there's been many debates and I have no interest in engaging in any of them um the main thing about the layer twos that we care about right now is that you have some off-chain state some of them said in another place in another place and then that option of chain state gets posted to layer one which is called the data availability layer and that ensures that anybody that wants to recreate the state of the layer 2 they can go and look in the layer one and you can very easily derive it typically there is a deterministic derivation function different in each system which allows you to do that beyond that layer 2 is an L1 it's a chain it has a database has a runtime it has an RPC has a peer-to-peer layer it has a bunch of cryptography maybe it's a standard distributed system we know how to optimize them these systems the bottleneck on i o and state growth if the thing that matters to you is decentralization and the ability for individuals to verify these are the two things that matter IO bottlenecks how fast you can sing a chain State growth bottlenecks how big your chain can be and if you want to scale ethereum or anything else how you do it is by launching many of these layer tools and the roll-up Centric roadmap is all about that now some problems for people to think about are one how are we going to do composability across the same flavor of a layer two so if I have two op stack chains and they want to talk to each other how are they going to communicate without necessarily going through the layer one if I have op stack and arbit room or ZK stock or Stark stock or you know I don't know um is there some extra difficulty in making this to communicate are these systems even compatible or whatever runtime they need to support or are they just looking like it on the outside and things on the inside look a lot different and the natural follow-up question to that is what does change in the internals and how does that impact the externals how did the implementation detail make its way to the interface and one example could be that people maybe have optimized for MAV extraction on get because they understand okay these are the bottlenecks but maybe for example on the polygons we gave him maybe it's different I don't know now let's talk a bit about what are the unique things that you can get from a layer 2. first and foremost from the side chains paper from 2015 by blockchain experimentation experimentation experimentation we can try new things without braiding the base layer and then I will pose um bullets with some questions about them so when we have faster block times and or soft confirmations what does that mean about the Mev extracted in these blocks does it really mean that more frequent blocks means less or more Mev what happens outside of that system and how does the synchronization time between these two systems change which directly of course affects them have extracted The Proposal said in Roll-Ups can be less decentralized without losing safety with some cost to liveness but not total degradation naturally having a distributed system means it's more it's higher SLA which is good if the system allows a custom transaction pool it also allows for custom ordering fcfs will hear Patrick McCory talk about that in a bit I also don't know but all of these are levers that one can pull depending on the Mev profile that they want the layer tube to have or if you don't have a transaction pool and people just Hammer the sequencer what are you gonna do proof of work are you gonna add identity how are you going to prevent this spam what happens on the wire that comes from the client to the server and the obvious thing which is not I'm realizing the last bullet is off topic but I'll roll with it is that we have the bundle a bundled role a sequencer is both a proposal and a builder and naturally you want to keep the sequencer lean to allow for in the future as many of them to be around so the same this is for PBS on layer 1 applies to L2 separation of concerns how you build optimized systems I will not talk about the centralized sequencing I think it's kind of again an implementation detail in a centralized system you can replace it with a BFD version of it put it on tournament put it on some other consensus protocol and that gives you redundancy and some A's or B's here are do you enshrine the shared sequencer in your system for example um the op Stacks super chain is it the thing and is it something that gets you better performance than having something like an espresso sequencer on top of it I would think that like anyone anytime that you have a core protocol operation and you leave the metal that means that it becomes more expensive one or many shared sequencers do you aggregate them how does that go we saw the fractal aggregation of proofs that the vitalik showed earlier the aggregation Theory can play in any layer L2 specific or close flavor again same thing and the thing I want to drive home shared sequencers are not magic you know they don't actually solve all the world's problems they give you Atomic top of block inclusion the most topical classic example being the best roll up what is a room for differentiation I also don't know um but I know that like nobody else either knows so what do um and these are two other questions around the bridge and the atomic success which I still have only seen strongman answers to and I think we should do better one concrete proposal on how to get to crushing composability and I realize this is kind of dense and low context so I'm happy to expand later but we don't have enough time because that maybe you can have a shared sequencer that indeed only got this inclusion without execution but then you can have a bunch of Builders where they cross chain simulate and vitality kind of alluded to that that you can close chain simulate the broke the builders are indeed going to be running nodes and simulation engines for every chain that they support and the Builder is going to land a bundle that's going to be landing transactions for all up one two and three together and the Insight here is that we take the math Builder role and we just bundle more functionality of it like make it heavier and basically the shared sequencer is funny enough the map Builder poetic um this is my final slide um I want to talk a bit about this because the topic I deeply care about on ZK proofs and how the market will evolve um the proverb right now is again Ron Colo with the sequencer and the sequencer as we said is also a builder we really need to unbundle these two and there's many many ways that we could do it my favorite work was a paper by a good friend of mine Nike scottis I was called the proof of necessary work and describe the way where you can introduce nonce grinding I'll approve of work in the snag generation process and that'll let you have a leaderless system or rather a system where the leader is not known ahead of time um for proof uh generation for proof proposal naturally anything else like proof of work ask it has a lot of wasted effort but maybe it's like very egalitarian um so maybe like the next step from that is should we do a consensus protocol for the leader election um you know let's select the proposal let's agree let's put up some stake or something we elect the leader the leader does it standard techniques that we have seen used in consensus Protocols are going to be used for prover selection and the other thing that I don't think I've seen anywhere so far um and I just added it as a Stroman and I realized that it's probably broken and there's probably things to do but I wanted to say it is that as a ZK proof is generated you can actually observe that parts of the proof are generated in a pipelined sense the most trivial example I have a block with 10 transactions transaction one is executed it generates some witness data that witness data is supposed to get fed to a snark but while it's getting executed and it's getting proven another transaction is also getting executed and getting proven in another and another and another do the provers need to be the same thing can there not be a market for proof aggregation the things that Italy was talking about can there not be something where proof one goes to John proof two goes to Nick proof two three goes to Josh you know and you can keep doing that it seems like we can come up with collaborative proof generation protocols that abuse this pipelined structure of like proof generation but if somebody is interested in talking to me about it please find me after the talk and the final question is how do you distribute the fees again The Perennial question in the Mev supply chain or compositional game theory is the new term I hear um how do you put the fees where does value accrue you know um I also don't know but it's something interesting to think about um I have three minutes and uh it would be good if we can do some questions perhaps thank you anyone has any questions from the audience oh I see uh can you elaborate a bit more on how cross chain or cross-el2 interaction can be facilitated by this shared sequence a model for those of us who are unfamiliar with the literature yeah of course can we get the slides back up so the shared sequencer is an entity that is ordering things and doesn't really know how to execute them or if it were to know how to execute them it would need to have execution nodes for every chain it is ordering for because otherwise it would be ordering invalid things and ordering in wild things might be okay if your chain can support no Ops you know you just say anything that's invalid just like skip it there's a junk this live jungle and chain but maybe it's fine um so perhaps um what to do is that you have the shared sequencer which is basically a privileged entity for submitting um data to the chain and how does the data get ordered to get into that privileged entity you could have Builder one and Builder two but basically or Builder one for Simplicity who is running nodes for chain one and chain two and what they will do is that it will publish a bundle or a full blog template to the layer one where the first transactions in that bundle are going to be all the roller paid transactions and the next transaction with that bundle are going to build a role of B transactions and because that person is a builder and is has run the simulations on every chain they can guarantee that by being a top of the block they can guarantee that the transactions are going to be valid so by doing that you can hack your way into shared sequencing in a very clean way I realize this is a bit dense and I don't know if it answered the question sufficiently this also goes back to what vitalik says about aggregation I'm just wondering how this helps cross-chain interaction oh um well I don't think that you can do callbacks you know callbacks I don't know who has said that like you can do you know control a called contract B and then it called back it's a bit uh unclear because people are doing like right now the way the Roll-Ups work is that they submit one transaction one big bundle per block if we could interleave bundles if we could say top of block part A is like bundle for roll up a and then roll a b and then roll up a again maybe we could do something where I can call chain a and then chain B chain a and then it calls me back um the main things that we support in this design are crochet message forcing passing and maybe cross chain bridging um I'm saying a timeout so I don't know if I have time for more sure I think the person on the back was first the person in the back foreign so um I just have a follow-up question uh regarding the shared sequencing and also PBS for the L2 like if we have sort of these share sequencer actually two questions the first one that if it's really like sort of share sequencer do you think it will overwhelm that machine I mean if the sequencer used for multiple relapse yeah um like that's the first question second question that I um like three two one let's give it one oh sorry um so is the question that the shared sequencer can be very heavy I'm not sure I understood that like if that is the case the way that you do shared sequencers you basically need to make them like cross chain da aggregators before you land the chain before you land the bundle to layer one but you do not want them to be running the execution of these chains so by doing that you can keep the sequencer as a light da consensus protocol effectively which is what espresso is for example um and then you land your data to the real da protocol um sorry Joe quick one but in that case like for example if we really pass the message across the road Labs right where the sequencing but do we need to wait for the confirmation from one roll up um before like we really execute another message uh dependent on the for sure yeah yeah yeah obviously of course any transaction needs confirmations zero conf one confidence insecure I see so in that case it's like sequencing plus execution and da right 