let's see if I can answer any of those questions all right so if you read this schedule I think I started with an initially a slightly different title which was something like privacy preserving runtime Roll-Ups for efficient da sampling um but I've been sometimes told that I use too many words so I tried to simplify it and now it's just in 10 Centric Roll-Ups uh I'm Christopher uh thanks for coming wow this is a beautiful venue you may know me is the co-founder of the Noma project I also worked on IBC before but really I'm just an armchair philosopher in denial so this talk started by a little bit of a meditation of mine on what exactly is a roll-up and someone you know uh maybe adjacent to but not always part of the modular ecosystem this has not been entirely clear to me so on Monday I went to the celestia.org glossary which seemed like a good canonical place to look this up and found this definition quote a roll-up is a type of blockchain that offloads some work to a layer one like Celestia good marketing Rolex host applications and process user transactions once those transactions get processed they are then published to layer one it's layer one's job to order those transactions and check that they are available at minimum it's a good definition but there are three words here that that I think we might come back to later in this talk and those three words are type of blockchain so I ask you now just to meditate what exactly is a type of blockchain but for now let's move on to a term that uh you know uh is even more criminally underdefined which is intent so what is an intent uh anoma has been using this word for a while we've been perhaps criminally vague about what exactly it means you know we wrote it down in some ways but it recently became popular honestly I think it has very little to do with us because a lot of people are using it in a lot of ways that are not perhaps exactly the ways that we went but they seem to be seem to be sort of correlated so here are a few takes on intents there's there's Uma from succinct talking about intents for cross-chain bridging ux very important at research day in New York uh here's penumbra talking about intents for uh user basically user wallets intents for users thinking about how to declare what they want a transaction to do or not do then of course we have the radical takes tucks intense turn your front upside down get your kids to call you back intense our Girl's Best Friend okay okay so maybe back off a little bit and if we languages it's like OG decentralized coordination scheme right um and we don't really get to pick you know individually what exactly terms mean uh to me the interesting question is when you zoom out and look at how people are using words there's some commonality here right there's a reason the word intent became popular so quickly so fast and that people can use it with each other and they all seem to understand like roughly what they mean and I think what they mean is that an intent is if you put it in kind of slightly more mathematical terms and intent is a commitment to a preference function over the state space of a given system right so as opposed to a transaction which specifies a specific imperative execution path do a then B then C and intent says I want an execution path that satisfies these constraints right I have these preferences over what gets executed in the state space of a given system this is what varies right so when Uma is talking about cross chain Bridging the system is like the change that you're interested in bridging between when you know anoma is talking about who knows what as we'll get into a little bit later the system is like the information flow right so the bounds of what the system is that the intent refers to can change but in all cases intents are these sort of like commitments credible commitments to preference functions so I want to zoom out a little bit and kind of just analyze like okay so here on one side for the modular ecosystem there's this concept of Roll-Ups and everything is kind of organized around Roll-Ups and from from our land we come from the concept of intense and everything is organized around intense and I think these are two interesting Concepts because they come at the problem from different directions to me Roll-Ups are kind of bottom up like you start with this modular thesis you start with data availability as the base layer and then you sort of build rollups on top of that and then we see a kind of proliferation of different execution environments different approaches to sharding as was covered in the last talk stuff like this so roll ups common things bottom up to me at least intense come at things you know quote unquote top down or like users down like users have intents right they're always going to start with intents and the system had better figure out how to do something reasonable uh you know in some senses as system Architects we actually don't get to choose users are going to have their intentions their intents when using the system and we just have to try to build something that uh can satisfy those as credibly and fairly as possible right so in particular I want to ask the question of can intent sort of help out the modular ecosystem so Mustafa in his talk earlier brought up a bunch of challenges um at the end and kind of open problems um and I have a slightly slightly different list but I think it shares several components so three challenges for modular as I see it at the moment just kind of an architectural Paradigm are these inefficient charting application lock-in and user-facing complexity and by challenges I don't mean like flaws I want to be clear I just mean as the ecosystem is sort of moving at the moment if we try and foresee what might happen and try and avoid some potential problems while we still have a chance to steer things here a few things I think we should just sort of be cognizant of and I bring them up here because maybe I think intense can help but let's let's just go over what they are first so challenge number one is inefficient charting the most expensive thing in the world of distributed systems is atomicity because atomicity requires that you send messages to one place and you order them there um and that you know always implies that least some kind of N squared because that's this communication and it just means that you have to be processing things in like one location right it's the typical problem of uh you know a sequential uh behavior in concurrent systems um users of course want everything in particular they seem to want cross roll up transactions applications interactions uh you know token transfer stuff like this so users are not going to be thinking about like oh I should put all my state on roll up once that it's most efficient no no no no users are going to say I have asset here I want asset there do something make it work and it's our job to try and make it work in one you know in making it work we want to kind of give as much Freedom as possible when it's properly constrained to The Operators of the system to make it more efficient so in particular if we envision a world of Roll-Ups and all of the Roll-Ups have different applications right and the applications are like bound to specific rollups and users want to do lots of cross application interactions then we've added this weird constraint where it's like there's a sort of demand for atomicity right like users want to interact with application a on roll up one and application B on roll up two and they want that interaction to happen you know atomically there's a bunch of shared State and if we tie applications to Roll-Ups and kind of have separate sequencers then we get the sort of static sharding system where we can't change the topology of which different Roll-Ups are settled atomically right it's static and if we View kind of the demand for atomicity is varying over time perhaps dynamically this seems to me like it's inefficient we've sort of added this constraint so that's challenge number one Challenge number two is application lock-in one of the great things about the modular stack is that you can build heterogeneous execution layers very cheaply because it doesn't require deploying a whole layer one but one challenge with heterogeneous so heterogeneous protocol execution layers is that they make applications less portable so you know the evm for example is a interesting VM of course it changes quite slowly one thing that I would like very selfishly often is for the evm to add new pre-compiles for new curves so we can do more efficient cryptography and it would be easy to launch a roll-up that Forks the evm and has a new precapile for a curve right but one disadvantage if you sort of look at this from the application sort of whole ecosystem perspective is that then if other Roll-Ups don't also adopt this new opcode you know the app is kind of locked in like if the sequencer of that roll up starts charging higher fees if users can't easily switch if there's a bunch of application state that gets tied to this like very specific different execution system the application can get kind of locked in uh and this means that apps may be paying you know really for more more kind of atomicity uh than than strictly speaking necessary and the third challenge I see is user-facing complexity so one you know modular component selection and certainly modular component construction adds a lot of clarity to the design process of blockchains and allows different teams to work on different parts which I think is very helpful from a coordination perspective but it's especially if these different parts are operated by different sequencers different validator sets uh it tends to entail some complex security assumptions so if we think about this from the perspective of a user uh and what the user has to reason about in order to know whether their interaction is safe right something like this if there are different parties for solving execution data availability all of these components of the modular stack that's a lot for the user to think about right different interactions require different safety levels the user is not going to you know every time they send an intense under transaction the user is not going to reason through all of the sort of crypto economic calculus of is this thing in fact safe right given all of these specifics so I think user facing complexity can be a challenge uh sort of one that requires that we come up with good standards for describing what these security assumptions are and also we want to always maintain the ability you know as Mustafa mentioned kind of sovereignty to me sovereignty also includes the ability for users to easily switch if something goes wrong right communities like own the system they give it value by bringing their applications bringing their intents to the blockchain and they should have the ability to switch away and in particular to kind of credibly threaten to switch so that they don't have to actually do it because it's cheaper right so I'm going to postulate a kind of thought experiment here and see if it might help with some of these challenges and that thought experiment is what if at the moment applications are as I understand and you know I could be slightly wrong but as I understand applications are kind of defined on top of Roll-Ups in the modular stack right there's a data availability layer some execution or particular Roll-Ups those roll ups have you know State formats they have instruction sets they have VM stuff like this then applications are defined on top of the rollups right and I propose a different way of defining applications which is to Define applications as intents so in anoma an intent uh is kind of opinionated about some things and unapinated about other things so in particular intense specify which parts of State they must modify atomically right if we think about the whole system as having a sharded state where the state is sharded by concurrency domains and different security domains intense you know specify sort of in an include explicitly include fashion which parts of State they must modify the state can be held on different domains you know not you know if you require Atomic settlement between two completely different validator sets that's not possible right but you can specify in the intents which things you need to be Atomic and the kind of custodians or the validator sequencers in charge of that state must sign right and I think uh one uh way of kind of understanding the relation of this to Roll-Ups so we we have a concept we call partial solving and partial solving is like if you have some intents let's just describe the intense abstract claims let's say one intent this is the one on the top uh top left here uh is Alice and Alice wants to trade uh star for Dolphin right we have another intent that's Bob Bob wants to trade dolphin for tree then we have the third intent Charlie Charlie wants to trade tree for Star right okay we have something we call solving solving basically means matching intents and solving can be done fully when you take a bunch of intents you match the completely you get a fully balanced transaction or it can be done partially in this particular diagram gives an example of partial solving so in this example we take Alice's intent in Bob's intent um and Bob already has something Alice wants right Bob already has a dolphin so we take spot we take Bob's dolphin and we send it to Alice and then we craft a new intent that now requires uh that we get a tree and give a star right so we can do this kind of partial solving by combining two intents doing some kind of simplification and creating a new intent that we then self send elsewhere to do some more solving later so if you think about it abstractly if we have like an a for B intent to B for C intent partial solving just takes those two intents combines them and makes an a for C intent right then in this particular example uh in the second stage of solving we have this partially solved intent and we match it then with Charlie's intent and then we get a fully balanced transaction where everyone's assets got swapped just a three-party partner so what is partial solving I postulate that partial solving is a Roll-Up so if we think about type of blockchain what does type of blockchain mean I mean I think there's some hash linking involved there's like some history we need to be able to verify this later in partial solving satisfies all of those properties it's just kind of On Demand right we look at the intents we do some kind of partial State change sending in this case Alice's um oh no sorry sending Bob's dolphin to Alice we have some State changes that we still need to do we commit to those we can perhaps in in noma's case we can make them private we can even roll them up and as he can proof so we have zero knowledge and computational compression so that's like a ZK roll up um and then we send it onwards right now what is not fixed in this particular design is that we don't fix what has to happen afterwards right so we just take these two intents we see that we can do some simplification we like make a roll up like this is what you know sometimes we've been calling runtime Roll-Ups or on-demand roll-up and then we can send that partially solved you know partially rolled up intent onwards we can do some more rolling up and then as soon as it's fully balanced it's like a transaction and can be settled somewhere right so in a kind of intense Centric view of Roll-Ups partial solving and roll-up creation are just the same thing uh so maybe the difference in the kind of with some of the current modular stack is just that Roll-Ups are created On Demand right and I think that this has some advantages um it allows for this kind of global compositionality in determining the actual topology of sharding at runtime right just like when you're processing intents around the network it preserves local liveness it does require standardizing on a state format this is you know perhaps controversial but I think that we can do this in a way that doesn't really constrain choices um the one nice thing about the way intents work is that intense specify verification conditions not the execution method which means that you could have different instruction sets so you could preserve basically heterogeneity of execution systems as long as you have the ability to verify right so like think about it like if everything is a ZK roll-up then intense specify conditions for verifying like the other guy ZK roll up if the other guy uses some other op codes internally uh you out you don't care as long as the condition is eventually satisfied so in some sense it's a standard which allows you to agree on as little as possible which is always good in distributed systems right um so intense Senator qualups enable Dynamic charting choosing charts at runtime intents can specify which consensus providers they're okay with they can specify like more options so it doesn't you don't need to fix like sending your transaction to one specific roll-up you can say Okay I want like the cheapest settlement subject to these conditions and here are the security assumptions I'm okay with this enables the network to dynamically sort into independent Atomic bundles so it should end up being cheaper for users defining applications by intent formats if done well in kind of standardized should help a lot with application portability because applications then are not they're not tied to a specific roll-up they can sort of move freely across Roll-Ups and maybe heterogeneous instruction sets become more like specialized solving algorithms for different domains the same application can Shard its state according to what users want right so you can move code and data across chain and application portability in particular gives you that gives you as a community or as an application user a credible threat to Fork out extractive operators right because it's easy to move your application code and logic somewhere else everything is kind of standardized to a division degree then if someone is charging if they're like extracting a lot of Mev if they're charging High fees to withdraw your assets over Bridges or something like this then you have a credible threat that you can just leave and I think you need this in order to constrain the kind of operator extraction and these systems uh then specifically in anoma we've been spending a lot of time trying to craft a good framework for describing declaratively what information flow users want to allow in intense uh so this looks basically like declarative constraints intents can say that you know in in the in conjunction with this Atomic settlement uh this you know this value acts must be revealed to A and B so X could be a note could be a key uh they could say this value y must be revealed to some other party C at block one two three in the future and these kind of declarative information flow constraints enable things like cross-roller private bridging new auction designs privacy preserving governments programmatic disclosure of aggregate data yeah a lot information flow control if done properly I think can be quite General so what is blockchain I'm back to this question uh and you know personally I mean I think a blockchain is a data structure like if you take a piece of data and you hash another piece of data and you include it you just get you've just gotten a kind of partial ordering relation and this is the essential thing uh and everything else perhaps can be separated uh within 10 Center collapse we just create blockchains on demand they live very ephemeral lives you know a blockchain exists for a second when two intents are matched and then it's kind of rolled up and then then you know you can verify it later but you need stores that if somewhere there's still data availability but the blockchains are really quite ephemeral and whether something is an L1 and L2 or L3 is just an observer dependent finality choice so shout out to John charb from DBA this is kind of my my meme summary of this talk roll ups or l2s roll ups or just tell ones roll ups aren't real blockchains are real okay so finally a few a few kind of um grab bag slides of just interesting interesting points that I think come up when you look at things in this way so if we if we conceive of a world of like what do uh with the economics of these different systems look like in a world that's modular with intents um and shout out to Zaki who who I think had a tweet that says something roughly like this um you know I see a kind of kind of two classes of uh you know maybe a value capture or like two classes of things people will want in an intense sensor modular world and the first class and this is like maybe maybe this will be controversial to call it a Dao but the first class I'm going to call service provider daus and the reason I call them Dows is because there's like a group of validators or operators who are working together and are providing Services as a collective and they're like coordinating to provide that service efficiently and reliably but users or sort of applications see it as a service provided as a whole right so I would say that uh one kind of Dao you can have been in an intent Centric modular world is a data availability dial which provides data availability and ordering and there's some slight differences here but you know at the moment Celestia and ethereum and the kind of roll-up Centric roadmap the availability host layer model are providing this kind of service right then you could have some kind of execution dials maybe current Roll-Ups are like this you could have solver Dows you know Suave as I understand it is like this and these service provider Dows are competing on the basis of liquidity and sort of role specific optimizations right they're like providing really efficient data availability sampling they're providing you know extreme like uh more private solvers in the case of suave using sgx right they're providing some like a specific specific service that they think people want right uh then they're just assets people want you know people still want Bitcoin they want eth somehow they still want the almighty American Empire bucks um on the blockchain um and those assets are competing you know independently of protocols right they're competing on the basis of distributions and how good they are at public goods funding so three concluding thoughts here uh one I think you know intense and modular are like a match made in heaven they come with the problem from opposite directions they can kind of help solve each other's problems you know an intense Centric architecture I didn't have time to go over all of it in this talk but one challenge we've had building a Noma is simply that we don't have specialized Primitives right like we don't have efficient da sampling we don't have these like individually optimized things so I think there's a very nice Synergy there one thing I also really like about about the modular blockchain world and kind of some of the conversations we're having here is that it seems like it's sort of a fusion of ethereum and Cosmos of the polycentric or self-sovereign political ideology with the kind of clear architectural thinking of the ethereum ecosystem this also Maps like Celestia andoma many of these teams um in the modular world came from Cosmos or worked on Cosmos and we're now kind of converging with ethereum and finally I have a kind of shout out uh similar to something Mustafa mentioned which is that let's please please please not remake the mistake sake of building a lot of transparent blockchains that are not going to work like if you're trying to launch a transparent roll up and it's not for like some cute game maybe this is okay but if you're trying to launch a transparent roll up for financial settlement and you are going to spend years on this and you're going to spend a marketing budget and you're going to spend go to market effort and you're going to like convince a lot of people to use it make it private don't make it public it's not going to work that's it thank you [Applause] 