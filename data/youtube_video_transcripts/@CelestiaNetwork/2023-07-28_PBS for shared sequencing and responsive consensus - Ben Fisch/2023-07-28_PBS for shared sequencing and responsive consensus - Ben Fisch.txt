uh PB espresso this is not my idea this is quintus's idea I stole it from him he has all the creative ideas uh so I'll be talking about pves for shared sequencing and uh responsive consensus protocols um these are sort of two unrelated topics well maybe not completely unrelated because responsive consensus is the espresso's consensus protocol for shared sequencing but the talk will be split into these two uh two different subjects on PBS so first just to quickly introduce what is a shared sequencing so Roll-Ups are horizontally scaling the application layer of ethereum uh the idea is that when you add new applications then you can have those applications add new servers that execute some of those applications are Roll-Ups that support other applications but I view Roll-Ups as basically applications that support other applications and the the layer one is now not doing any execution they are just verifying frauders UK proofs um it's also leveraging this heterogeneity so you can have powerful servers on the application layer you can keep the servers on the layer one very weak they just they just verify proofs they don't need to do any extreme execution um the problem is Roll-Ups control a lot and that is uh that leads to um the need to either decentralize the Roll-Ups themselves and add some kind of decentralized process for each roll up to decide on The Ordering of its own transactions or it um it moves us towards a different model where they share the L1 so the other problem which remains if each roll up just runs its own consensus protocol for its own transactions is that they remain very isolated from each other and so the currently even though we're sharding the application space of ethereum we're sort of ruining this amazing property that ethereum has which is the interoperability of contracts one contract that you deploy can easily make function calls to another contract and they share liquidity with each other so roll ups don't scale ethereum without changing its fundamental properties and that's not really scaling that scaling and changing the target so how can we regain the functionality of ethereum as it is today while still scaling ethereum so one idea that has come out is uh for Roll-Ups to share a consensus protocol for ordering transactions um so this is this is this idea of separating ordering from execution where the L1 doesn't build or execute uh write the rollups do that but the L1 can provide finality on transaction ordering availability of data verification of State proofs and transactions submit their Trend they're directly to the L1 and the Roll-Ups just read from the L1 and and execute so there's a question of would does this give us interoperability it's also good to note that this layer that's shared by the rollups for ordering doesn't need to be ethereum itself it could be some layer 1.5 that sits in between and the main reason for that is protocol modularity perhaps we would introduce a new protocol that has the ability to provide faster pre-confirmations than ethereum does ethereum has slow confirmations time um so this is a reason to to design shared sequencing layers that are not ethereum itself but some other protocol that sits on top as whose sole purpose is to provide a different property to Roll-Ups like higher throughput and faster finality the concept is though the same users are submitting their transactions to the consensus protocol that is independent from the Roll-Ups Roll-Ups read from this consensus protocol and only execute and Report State results so does sharing an ordering layer help interoperability if the ordering layer is not doing execution that is the main question of the first part of this talk today so I'll say there are three advantages but I'll focus on one that has to do with PBS proposer Builder separation right there are also advantages such as simplifying Crossroad bridging mitigating systemic security risks for Bridges we've written about this in in blogs from espresso systems but I will focus on this topic today of supporting cross-roll-up building with economic bonding and what is this so first um you've been hearing about proposer Builder separation all day but maybe everyone has a slightly different way of describing it so I'll just do a quick review and present sort of my view so the proposer is is a fundamental part of the consensus protocol because all consensus protocols today have are base basically on leader election if we use consensus protocols that are not based on leader election then we might end up with something different but consensus protocols like ethereum and like the consensus protocol used in espresso or tenderment or any of these systems have a leader that is elected to propose transactions that then get ratified or signed by others so if um there's always a proposer if someone says that uh that we can remove the proposal what it really means is that you can only you can just use the layer 1 proposer and you don't need to introduce new proposers in the layer too but there's always a proposer from the system that finalizes the ordering of transactions so um Builders today can compete and then produce a block the proposer doesn't need to build a block it can it can play this passive role of accepting a block from Builders and if we design this if we leave it up the proposer to do this and don't design anything into this building layer then what ends up happening is a first priced auction where the proposer will just accept the most valuable block that comes out of the Builder Network uh and so that's a reason to take a different design approach where either we might do this in terms of implementing some smart contract that uh in introduces some rules that we hope proposers will follow or it can be some kind of other ideal functionality uh similar to what Suave is designing that implements some kind of order flow auction among users and Searchers if we can design something that is not just maximizing the profit for the proposer but is stable and better for users and users are only submitting their transactions to this ideal functionality whether it's a smart contract or a protocol like Suave then the um the proposer will have no choice but to accept the block of transactions from this ideal functionality because there's no transactions going anywhere else and this only works because the consensus protocol is decentralized right if the if the consensus protocol was not decentralized then a proposer could say I'm going to ignore this smart contract this isn't good for me I'm going to ignore this ideal functionality I want people to submit to me the most valuable block I want to extract all the Mev because I'm a monopoly right the decentralization of blockchains breaks this Monopoly so that a proposer is a monopoly for only one slot and that is why if we design an ideal functionality stable for users the proposer cannot influence what happens the proposer can either take it or leave it if it leaves it the next proposal will pick it up the most it can do is delay so that's why extreme decentralization is so important from an economic perspective this is one of the most fundamental properties of blockchains from an economic perspective so proposer Builder separation over shared sequencers looks the same as over ethereum today because ethereum is a shared sequencing layer so if we introduce a layer 1.5 it's just introducing a new modular layer on top of ethereum which runs an order finalization protocol but still has some proposer as part of the consensus protocol that will accept blocks from a builder Network and we can design that Builder Network to be smart and do things in a in a way that's good for users like Suave or or some kind of smart contract design um so one of the things that let's we're I'm not going to really focus on Mev as much as how this problem of regaining interoperability and atomicity among um among app Roll-Ups that are sharing an ordering layer is that through PBS Builders can actually uh can actually make promises to users about atomicity and they can be slashed if they violate those promises so a very simple example is the following a builder can say I will process your trade on optimism and your trade on ZK sync which may be taking advantage of some Arbitrage opportunity to two amms on the different Roll-Ups and I promise that I will only execute them I will only include them I'm building a super block for both Roll-Ups and I will only include these transactions together if they both succeed if one of them fails I won't include either and this statement can be cryptographically signed so it can be used as evidence against the Builder if it violates This Promise so it can be slash it can build up a very large collateral that gives the user confidence uh it will it will respect its promise and the builder then provides this to the proposer of a consensus protocol that's not executing at all but is basically auctioning off wholesale a super block that produces a sub block for every roll up simultaneously to the Builder Network okay very simple um without a shared sequencer this would not work at least it would not work as well the Builder would have extremely high risk that if it tries to make this promise to the user it's possible that the independent sequencer or consensus protocol for ZK sync will accept the transaction but the independent sequencer or proposer consensus protocol for optimism will reject it right it is not now there is now two independent auctions and it doesn't have a guarantee it will win both whereas with a shared sequencer and a single proposer that is elected there's one option for both together so the Builder could be slashed and lose its high collateral even if it doesn't do anything wrong so um that's why sharing a sequencer allows reduces the risk of Builders allows for more Builders who can make these atomicity guarantees so the builders sit on this layer on top of the shared consensus this is how it looks in espresso um a slightly more complicated example would be a flash loan so let's say a user wants to get a loan from a from Ave on one roll-up of one million usdc deposited into a smart into an amm trading usdc against die um so now I can't immediately Bridge its funds over and just deposit it directly into this curve contract on roll up B so we'll introduce a bank contract and we'll exp the bank contract is going to have a branch on both roll ups okay so there's a branch on roll up a there's a branch on roll-up B um we'll explain how this how the Builder can ensure this atomicity of these two of these two events but basically the user will send die to the bank contract and roll up a and it will get die from the bank contract on roller B then it will deposit into the curve get back is usdc and do the reverse right deposit into the bank contract and roll up B get it on roll a pay I haven't explained how we ensure that those can happen atomically I will in a moment and then return the usdc to Ave on roll up a and keep the profit right all of this needs to happen in a single transaction that's a flash loan um so how does a builder enable this well the Builder who's building the block for both Roll-Ups simultaneously can provide a signature right again backed by some collateral uh and that just gives an instruction to this Bank contract on roll it B that says this action happened on roll-up a all right so you can release the funds on roll-up B and uh the the Builder creates a super block the bank contract will be just trust the collateralized Builder signature if the Builder lies it's accountable and loses the collateral and roll up B is not the is not absorbing the risk all the risk is absorbed into the bank contract so it can become a business to design these contracts um and uh and specify your requirements for what Builders need to put up in terms of collateral and other possible conditions and it's uh it it's assuming some risk but it can also be taking a fee so this is an example of something that's enabled by shared sequencing which would not work without shared sequencing right of course it's not exactly the same as what you can do on a shared execution environment but it opens up a wide design space and really this is just a straw man simple construction I encourage people to come up with with more creative ideas um the Builder signature would do the same for roll up a bank contract as well it's symmetric there are some concerns that having Builders execute for all Roll-Ups uh may lead to Builder centralization um the reality is that executing for all uh smart contracts sorry for all roll ups is is not actually that high a barrier to entry right in fact compared with ZK proving it's not that high barrier of Entry ZK proving is extremely expensive it can be like 10 000 times or more expensive than executing um and the requirements of the Builder Market don't need to be the same exact requirements in terms of decentralization as the consensus protocol we need many many nodes participating in consensus so that proposers act passively and don't monopolize um but we don't necessarily need 12 000 competing Builders to have a competitive market that takes care of um of monopolistic forces um so it can just be sufficiently permissive and open and free entry and have low enough barriers to entry such that it's sufficiently competitive in fact the barrier to entry for Builders is much higher without shared consensus because Builders take on more risk as I Illustrated a slide earlier Builders would require more Capital to win simultaneous auctions they would absorb more risk they can't promise user atomicity without the risk of being flashed so uh well there's a where there's a will there's a way um it's better to have shared sequencing we will lower the barrier of entry for Builders rather than increase so um Now for Something Completely Different I will talk a little bit about um PBS for responsive consensus protocols uh so ethereum's consensus protocol the um doesn't is not responsive meaning it has a fixed block time um if that is 12 seconds ethereum's finality is not actually 12 seconds it's um it's much longer than that because the transaction needs to be several blocks deep to be confirmed so it takes about 15 minutes to finalize in ethereum a responsive protocol um does uh doesn't it does not maintain the the extreme availability uh that ethereum has these two properties are incompatible but what a responsive protocol can do is it can it can it can give finality as fast as the network will allow um fundamentally it will stall if the network is not doing so well whereas ethereum can continue even if only 10 of the network is live so due to the cap theorem these two properties are essentially incompatible um but uh optimistic responsiveness is a property that can get you as close as possible to the performance of a Sandfly sequencer in a decentralized way and the nice thing is you can compose them together because you could run optimistic responsiveness on top of a dynamically available protocol so consensus protocols that can return an answer immediately under optimistic Network conditions are called responsive okay there's no block time in is in in responsive protocols so how does this affect uh PBS so let's look a little bit at the round structure of Hotshot which is a based on pbft and is a responsive protocol in the first round the leader proposes a block collects back signatures then it will aggregate these signatures form something called a quorum certificate it will broadcast it again aggregate them and um and collect signatures on that um so again this can happen if if the network is very well connected or maybe there's even a Content delivery Network that assists this to proceed very at very at very high rates then as soon as the signatures are collected the protocol doesn't need to wait it can just move on finality has been achieved so under optimistic conditions we we can finalize blocks as fast as the network will allow the problem is with PBS if a leader has only one proposal before the next leader comes up uh then it's incentivized to delay because in order to run an awk it could it could for example run the auction for longer and obtain a more valuable block from builders um so one solution is not to rotate leaders based on uh on blocks but rather to rotate leaders based on some time window okay so we can allow the leader to propose and obtain finality on as many blocks as it wants consecutively until this time window expires I'm not going to go into the details of how you do that in the consensus protocol but that's the main idea it doesn't completely get rid of all incentives to delay but it goes very far to to mitigating this this primary concern um when is it safe for a builder to release data so in PBS for ethereum today the Builder releases data after receiving a block hash and then it races with the with the the uh the the proposer to relay that uh that that uh that block hash in order to get that block accepted and at this time it releases the data because ethereum nodes won't accept the and vote for the block without receiving the data now if the proposer proposes a conflicting block hash it could get slash but sometimes that slashing amount is low compared to the amount of profit it could make from stealing the Mev from the Builder so they really do engage in this race and it's even possible for the next proposal to Fork the block and steal the Mev so the protection for Builders today and ethereum is not actually that high and I'll argue that it becomes a little bit better when we when we were looking at a responsive protocol with a responsive protocol once a builder has received the signed proposal it can ensure the network reaches strong finality within a certain time window and under good Network conditions of course it's possible for the network to experience a fault but it it has it can gain confidence given its observation of the network that it has a and again a much higher confidence that it will be able to succeed in getting this finalized and not allowing the proposer to steal the Mev and do something else for even stronger protection the Builder may only release the data after seeing the first Quorum certificate on the original proposal remember there's two rounds this just brings it closer to the finalization gate and it doesn't really need to release the data until the second part um there are some caveats of that now we only have one round to broadcast the data instead of two um that's easily solved by broadcasting an encryption of the data starting at round one and then releasing only the decryption key starting at round two uh the decryption key is small and can be broadcasted faster so that solves that problem it's harder to pipeline proposals though with this idea so one of the nice things about protocols like Hotshot is it allows for overlapping rounds but if we hold on to the data and we're already proposing a new Block in the second round then this gives the builder of the previous block an advantage for building the next block since it's the only one who really knows that information ahead of time this might be addressed by order flow auctions right these ideal functionalities might be able to take care of that they essentially create one Builder abstractly that is the ideal functionality and have all the real Builders just participating in it as a multi-party computation so thank you very much um that's what I had to tell you about today and next up we have Evan Forbes who is going to tell us something exciting about uh ending the proposer Monopoly foreign 