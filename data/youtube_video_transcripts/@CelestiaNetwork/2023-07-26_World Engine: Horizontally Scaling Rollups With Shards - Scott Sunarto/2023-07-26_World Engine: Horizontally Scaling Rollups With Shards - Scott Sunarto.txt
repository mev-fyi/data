hello everyone and thanks for coming today to kind of like uh modern Summit and today I want to talk about a little bit of something that we've spent the past almost three quarter of a year working on but the story as you will see is much longer than it currently uh has seems like so yeah cool all right so quick introduction about myself uh before I started Argus I was one of the co-creators of dark force uh dark force for those of you who might not have known that is the First full yanchen game on ethereum built using zika snarks um well that started with a simple question of like what if we create a game where every single game action is an on-chain transaction back then in 2020 this was an absurd thesis a lot of people um was like wondering like why would you make a fully launched in games um and how is this even possible with blockchain being as slow as it is but regardless driven by our curiosity driven are just like you know our kind of culture of just walking around and finding out we decided to build uh dark force and so this is like what dark force looks like uh back in 2019 2020 um and yeah it's basically space exploration game where um thousands of players were fighting on chain to expand their empire and within the first week of launch we had more than 10 000 players or wallets and trillions of guests spent in the ethereum test Nets um attracting a large number of players and eventually we had to move on from test Nets because other developers want to test their applications were not able to and eventually move to the sidechain and even in a side chain is supposed to be more scalable it turns out that it is not as scalable as we think it is we quickly filled up the entire block space driving up gas costs and practically making side chains unusable with only a single application um and so now begs the question right so with all of that limitations why are people still so excited about on-chain games well after dark forests we've seen many people investors Founders Builders hackers alike building on top of the legacy of dark force with things like lattice building mud a library and framework to build launching games easier and also content companies like primordium building a fully Unchained games and also things in Auto ecosystem beyond the AVM like Dojo on starknet um the key thing here is that we realize that the limitations that we have with existing blockchain comes down to the fact that we are sharing a chain with everyone else we are sharing this like very small room where there's not a lot of space with other applications that also want to use that and so if you see on the chart there you can quickly realize that if there's a another game like Dark Forest living on that same chain then there could not possibly you know be a functioning chain and so the question is like what now right do we just give up do we just like you know kind of like just like throw away the concept of like on-chained games and so we decided that no we want to actually explore how we can build better auction games and we want to make sure like how that the game that we're going to build next is going to be scalable and so we embark on our journey that starting with a one big key realization that we currently took blockchain architecture for granted we have all these little ones and l2s and yet they all look the same they all will tell you very very similar things they'll tell you that our consensus is better we have like you know better trade-offs than the other blockchain they'll tell you that their VM is faster they'll tell you their VM is like paralyzable or they'll tell you that maybe if they're an L2 they're fraud prover is better or how the other competitors you know fraud prover doesn't exist or like their other Roll Up is fake news some people will claim that their proving system is better like our ZK approvers are faster although we never see the benchmark [Music] but all this war um to what end to create yet another Decks that you can deploy to on any other chain like doesn't matter what VM it is it's all just looks the same or to Min yet another nft that again you can deploy on any other chain we decided to take a step back and think differently think how we can actually see blockchain architecture from a different lens we asked the question of like what have you escaped the classical blockchain architecture every blockchain that we've seen until now it all looks similar to bitcoin all looks similar to ethereum behaves the same way you have the concept of guess you have the concept like transactions like people some transactions they submitted to blockchain and that causes uh like you know a state transition it all looks identical to each other and another key thing that we realize is that other people and other blockchains Let It Be L1 or L2 they're all trying to build a blockchain for everyone and I'm not saying this from like a wholesome way it's more of the fact that like they don't really take into consideration a specific kind of like you know use case or a specific kind of like you know user Persona and instead they just try to build something that everyone will just like assume is compatible with their product in mind we took a different distraction we choose to build the best blockchain for a very very specific user in mind in our case being players and game developers and so again we asked this question and it comes down to really understanding how games are vastly different than your typical applications so for example like application that you might use a lot is things like social media like Twitter um and like and like the other kind of things would be like you know games like Minecraft on the other hand and so here we can see that like you know with Twitter um Twitter acts in this like very straightforward way where if you write a tweet and then you click a button then you will have like you know your Tweet posted one thing to note here is that every time you click a button there is a user input event and this this is what triggers the state transition um this is like what I typically like to refer to as an event driven runtime as you can see this is very much similar to like how your typical blockchain would look like a user would want to trigger an event and they would click like you know send a transaction and the transaction with it inflicted but if you see games on the other hand games doesn't behave the same way as like a web application even without user embed even if you're AFK if you're just like you know going away with your brother State transition still happens like you know fire will continue to cause damage water will continue to flow wheat will continue to grow and day and night time will continue to move and this is like what we like to call the loop-driven runtime key thing here is that no user input is needed to cause a state transition and so drawing an example back you will notice that the web app is again very similar to like smart contracts let's say an UDA swap a user wants to take to trade token a and token B you would submit a transaction and that trade is executed again event driven runtime we realized very quickly this event-driven runtime nature of a classical blockchains are just not compatible to run a game State machine and so we kind of explore deeper the loop-driven runtime that game has and again all game engine is specifically built to support this loop-driven runtime the key thing with the loop-driven runtimes is game progressions and like you know how times are like you know organized within the games is referred to as a ticks or the atomic unit of time each game Loop is going to be executed in a single tick and the higher tick rate that a game has the more the game feels more responsive if you played game like you know Counter-Strike or Varan you'll notice that these games have like you know 20 like tick rates or like 6 rates for the modern game servers while games that are more old they'll typically have like lower tick rates and often you feel sluggish doesn't feel responsive right in blockchain you can treat like you know these texts to something that's analogous to a block it's basically a single unit of time where State transition happens if a thick or a block feels slate you visually and feel luck in the game and if you've built games before or even you've played game you know how suck it feel when uh like you know your game move flag and you die and you get killed and like they would rage on to like the enemy or like you know the game developers it's not a pleasant experience and so as you know today we believe that games are Loop driven in nature and because a lot of the game of State transitions are not triggered by external input for example a gravity doesn't rely on the user pressing the W button to move forward gravity will continue to exist regardless of user input there's also a case for that like like deterministic transaction ordering let's say if you want to inflict um like a damage to your user should the game kill the like like apply a regeneration to the HP of the user first or should it inflict damage first with a traditional ordering of like just like this random Builders of like a typical execution layer like you know let's say the AVM you can't predict or you can't like deterministically control which state transitions are getting applied first and as a result you have this deterministic transaction ordering problem that causes reliable issue in the game Loop itself on top of that you can also allow for more aggressive parallelization by using like data oriented system design in this loop-driven runtimes last but not least is that while some people might talk about it retrofitting event driven runtimes like DVM into a loop-driven runtime we've seen that this like leads to a lot of issues because the nature of like how you do gas metering like how do you do accounts that is not as simple as just like calling a loop or calling the like a single smart contract function again and again at every block and so if you have a layer two or roll up with a little driven blockchain for a game so what unbox do we get the first thing is of course we want to maintain a composibility making the the blockchain from inventor and the loop driven doesn't mean you have to sacrifice composibility and that's actually the reason why we want to use blockchain as a runtime for you know these games in the first place on top of that with the loop-driven game Run time you can have real-time gameplay where you can now start to blur the line between a blockchain and a traditional game server and eliminating the concerns of building a game on top of these roll ups with the idiomatic runtime like with the like in like the loop driven runtime you can also build more complex games than you can before in like in our blockchain there's a reason why most quote-unquote games that you see on the blockchains are mostly just people minting nfts because that's really what you know like the easiest you can do when like you can only have even driven runtimes and last but not least the more that you can emulate a traditional game engine runtime the more that you can just treat the user experience much like playing another game but with all those good things in mind we still are missing one key ingredient to build a scalable game server blockchain and the key thing there is is the fact that we also need horizontal scalability when you're playing a game you are not only playing it on a single server if you play MMOs MMOs are comprised of many many servers if you're playing Counter-Strike these Counter Strike games are you know spread out across different sessions that is run across different computers but if you realize at the end of the day a roller runs on like a computer and so they are bound to the physical limitation and of like you know computation itself and say games and like most large-scale applications scales using multiple computers but if that is the case then like why don't we just like spin on our roll up then if we do a knife approach of just spinning up another roll up we can lead to like composable fragmentation smart contracts would stop talking to each other and while there are kind of different construction of shared sequencers a lot of the constructions are less than ideal for gaming use cases for instance you might lose you might rely have to depend on crypto iconic security to prevent things like you know locks dos factor and doing like an atomic shared sequencer Construction can also lead to constraints on execution layer as a result we need a new strategy to sequence rule of transaction and do in the search for that we had a give from the pass again we'll look into how traditional Game servers especially those with intensive performance excitation um like massively multiple or online game like world Warcraft RuneScape ultimate online whatsoever through the concept of sharding nope with shorting like some of you might have known this concept from like you know databases like mongodb but the reality here is like there's this conceptuality theory that the concept starting itself comes from Game servers first instead of the database first and so how does sharding work in game The key thing here is that there's no one-size-fits-all problem again at the end of the day shards are just tool in a toolbox not a prescription of how you should build your game so for example in the first starting construction you can use location-based sharding where you can split let's say a Cartesian coordinate into four diagrams and like when a player went across from one shot to another you simply send a message to other shark and then the player would be teleported to the the to the other shark the second construction is by using something that we call multiple sharding if you've played MMO games before you might have seen that like when you log in you have multiple servers that you can choose this is the same construction that you can do where you can have distinct States or distinct game worlds that people the players can designed to join so now we have all the ingredients here right we have the loop-driven runtime we have a horizontal scalability and we also want the awesome composability all this sounds great but how do we achieve this in a ruler right this looks like things that on the server seemingly looks like beyond the reality of like we couldn't get from a blockchain but this is like why we created roll engine we realized that we can't just use a normal roll-up and expect that it will run the way that we want it we took it to our own like hands to actually build the solution that we need the same way that back in the 1990s when you want to build a 3D game there's no 3D game engines available out there you have to build them by yourselves and so the world engine is again divided into two two key Parts the first one being the core which is comprised of two key elements which is the evm Bayshore which is a hybrid execution layer and sequencer with sharding support and the second part is a game shark which is a high performance game engine plus execution layer and on top of that you have peripheral components like you know the transaction relay and net code to do the client server communication and also things like ZK Cloud prover for you to have ZK games like dark force and so the world engine core really comes down to our very specific design of our sequencer while other sequence like shared sequence reconstruction would optimize for having Atomic composibility we decide that like Atomic composibility are extremely overrated especially when you're operating on the context of games and that's why we went full asynchronous and so we don't have to put locks under runtime an AVM base chart we have a global AVM chain where players can deploy smart contracts to compose with games create marketplaces dexes we built this on top of Polaris which is uh Cosmos SDK compatible like evm module that allows us to customize the AVM to much greater extent than what we could by let's say just like dribbly for a lively 4 can get under that we have the game short which is running on top of the evm Bayshore sequencers which is a high tech rate mini blockchain designed to serve as a high performance game server the game chart is also designed to be State machine and VM agnostic we built an abstraction layer much similar to like Cosmos SDK ebci so so that you can customize the chart your liking or build your own by implementing a standard set of interface we've also built the first game chart implementation to provide an example and we use an entity component system that is commonly used by like you know game engines and with construction that prioritize entity component system as a first-class citizen so every single objects or every single um you know primitive on the state machine itself is treated like an entity so things like accounts are a part of ECS transaction is a part of DCs system it also has configurable tick rate so you can customize your game to be as fast sticking as possible or you wanted to slow it down to prioritize more number of entities and like the best part of this is that you don't need to rely on indexers you can have fast reads on a blockchain without having to have this like lack of eventual consistency in textures like like what we currently have with Mod dojo and whatsoever and my very power of all is that you can write your code and go so you don't have to wrestle with you know smart contract languages that can be very limiting sometimes and so the key thing again as I mentioned shards are agnostic in nature to our abstraction layer so you can build other shards construction like a solid game Shard um to complement your like you know Cardinal game chart you can also build nfting chart that have custom rules um by like let's say custom mempool and like ordering construction to solve the basic minting Noisy Neighbor problem you can also create a game identity shot to use ift to present your game identity allow you to trade your game identity as well and again we don't use slux and as a result we don't have to block a main thread and making the game Run game chart runtime as reliable as possible and not causing any lacks and we don't have to rely on crypto economics construction anymore on top of that we also have many interesting sharp properties like how each shark can have different da batching compression strategy and you can also geologize shards to reduce gameplay latency and last but not least you can also Run game shards as an independent game server onto its own so you don't have to worry about roll-up deployments on day Zero and so we've built many various games on top of the game charts we've built like an ant fully on chain agario which have traditionally not been possible using our full world engine sequencer stack GameShark nakama and so on and so forth we've also worked with a hybrid model where you would use existing game engine Frameworks on solidity and combining that with a world engine and the future is for you to decide you're going to use our Cardinal stock you can do hybrid you can build your own game chart it's basically kubernetes for on-chain games it's mix and match Lego for your games and so now you're able to try out the world engine uh it's now open source on our GitHub we are welcoming new contributors for people who are interested feel free to reach out afterwards um and if you're interested in building your first world engine game we are having a workshop later today at 11 30 a.m at the Kaji stage and then tomorrow we're also going to be hosting the gaming track we have a panel and we also have a talk about unchain games at the Fourier stage and and last but not least the key takeaway from iTalk would be that let's build cooler rollups we're right now at the roll-up Renaissance and what we already know is that we of course roll ups allow you to scale blockchain of course robs will allow you to tap into the security of the underling L1 but right now we're still living this like on this very evm Centric conception of roll-up architecture this is the starting line and not the end what you want to go towards is a user and application-centric roll-up instruction where people can build cool and yeah that wraps my talk and thank you for listening [Applause] 