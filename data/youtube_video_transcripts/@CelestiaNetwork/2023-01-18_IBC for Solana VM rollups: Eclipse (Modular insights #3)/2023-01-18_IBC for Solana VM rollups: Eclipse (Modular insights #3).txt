so first off what is Eclipse so eclipse is uh eclipse is building scalable modular application specific Roll-Ups using the slavia um so what this means is that uh currently for most L1 chains uh all application devs share the same chain and so like in times where there's like a lot of demand for the chain uh if you get really contested gas fees can get really high in the case of Solana sometimes like people spam like thousands or tens of thousands of transactions a second which really bottlenecks the network so what we're doing in the eclipse is essentially building Roll-Ups for every specific app so every app will have its own dedicated uh app chain that all settles to a single Eclipse element chain and app chains can choose what data availability providers to actually store their blocks in and Celestia is one of the main data available providers that we are supporting and our initial like uh devnet releases that are targeting early next year so what is IVC so IVC stands for the inner blockchain protocol and uh it's essentially a protocol for very basically sending messages across chains uh why might you want to do this well the easiest example is if you want to bridge assets across chains or do trades across periods you can like take your value from one chain move it to another chain uh we need like some sort of secure way to make sure that those messages are sent across correctly that people aren't doing things like double fed transactions and so IVC provides a framework to enable this to happen so here are some of the key components of IBC um so when you talk about IVC typically we're talking about two chains that are communicating with each other and so uh both of the chains need to have some things like built on top of it uh they need uh the core protocol of IBC which is just like which I will talk about in the upcoming site this is the actual like language of the messages that need to be sent like across Che um so that both change and the real layers in the middle will be able to understand the messages both chairs need a client for the other kids talk about this a little bit more basically what this means is that every change should be able to read the upstate from the other chain and verify that that state that they received is actually correct um the third part is so for apps that are building on each chain they need to like integrate into what they're called modules these modules sort of plug into the core IBC logic and are able to like make IBC messages and essentially when we talk about sending messages through IBC what we're really talking about are apps that write modules and these modules talk to each other um and finally uh there's a relayer that needs to sit in between these two chains this is like an off chain program that listens to messages on both chains and then fairies messages across to the opposite chain whenever it sees like a message online or like I said name chain so I'm gonna walk through the IBC core protocol to give you a sense of what this looks like so ics2 as I mentioned is so its is a is the series of official IBC standards that that designate like how the protocol Works um so ics2 talks about clients and usually these are light clients because it's sort of infeasible to run like an actual full client online change a bit so this client must do two main things the first thing is actually being able to parse the other change data so given like this blob of binary data the client must be able to like deserialize this based on whatever format that's stored it and then the other thing is that it must be able to verify that this state has consensus so um all Cosmos FDA SDK checks um use tendermint as the built-in consensus mechanism um so since IBC was designed with Cosmos in mind it has built-in support for tenement uh if you are going to connect to a chain that doesn't use tenement say ethereum um then you would need to write logic that like understands for the signatures of the validators um maybe like the structure of like the Merkle tree that the data is stored in and be able to sort of verify that all those signatures were assigned correctly that they were as you expected and that the data is actually present in this like a creative on like base state yeah so now that we have like clients we can we can now be able to like start creating connections between two different chains so it can actually just represents like an open link between two chains so every connection needs to use a specific client so that the connection is able to like understand what the other chain is saying and be able to like establish this handshake to start a connection um of course like the same client can be used with multiple connections so if we are connecting to multiple Cosmos SDK chains well the protocols that they speak are the exactly the same so we can use reuse the same like Cosmos SDK tenurement client to talk to you both of those things so here is a diagram of what starting a connection looks like so as you can see here there's two chains and they want to communicate across each other so a connection is initiated when something on chain a okay I'm just referring to as like the starting chain uh something on chain a stands a continent message to the IBC core module uh it just says like okay I want to start a connection with this other chain using this client if that caught in the accessible then in the middle here but it isn't labeled as like this whole section is what the relay is doing so the relayer is listening to messages on chain a it sees a continent that was successful and it says okay King a wants to talk to chain B I'm going to send a con open try message on behalf of chain a to chain B if that is successful it'll read the chain B State and it's like okay chain B accepted that connection and I'm going to tell chain a call on open at we're going to act the fact that chain B opened the connection and once that's successful send the card up and confirm so if you're familiar with uh TCP for instance this looks pretty similar to um a synagic and effectively serves the same purpose um it's just telling both chains making sure they both have like the correct state of both chains in mind and making sure that both trades are aware that this connection is open uh next so if you've been paying attention I actually skipped from ics3 to ics5 I think this is just because the way they're organized is a little bit weird um so ics5 talks about ports so um so in IBC as I mentioned there are modules which represent apps uh modules to end up talking to each other these could be things like smart contracts or costing those modules and modules buy into a port to identify themselves IBC and this works like sort of similar to ports on your local machine and module can actually buy it to multiple ports but um for our purposes this is super important and so once a module uh is bound to report uh it can establish uh channels of communication between a port on like their chain and then like a port on like a remote chain that they've already connected to um so channels have like a few different properties they can be unidirectional versus bi-directional that just means uh messages are going one way or messages can go both ways and then they can be ordered versus unordered this just means like packets must arrive in order versus Hackensack out of order but then like something has to sort of like wait until all the packets arrive in order afterwards so here's a diagram of Channel establishment if you saw the last diagram this is basically exactly the same thing it's just like one level up so instead of establishing a channel we're just establishing a connection otherwise the messages roughly works the same way so I'm not gonna go into this too much again and then channels can be teared torn down this is pretty straightforward one side says I want it towards the channel and then it just gets relayed to the other chain using a relayer as well foreign channels are established candles that you deliver packets back and forth these packets again are very inspired by TCP they contain a source ported Channel a destination pointer Channel a sequence number saying like which pack number it is and then the actual like binary blob of data that they have so uh packet delivery is pretty straightforward this is sort of the core of what the relayers do so after uh connection is established in the channel established it really its main job is to sort of Ferry these tactics over so whenever it sees a send packet on any chain it needs to take that and then send a corresponding receipt packet onto the chain that needs to be delivered to and this is the primary way that data actually gets across between different chains um there's some timeout mechanisms on the packet itself so if the packet doesn't get delivered for like 10 or 20 um block types this is like configurable when you send the packet um chain a conducive timeout a packet and then that timeout also needs to be delivered over to the other key but yeah so these are the basic building blocks that you need to send messages across IBC there's a few other specs that I did not mention but this is like these are the main components so with these sort of like layers of building blocks you're now like able to send packets across um one thing I do want to point out is that the relays in the middle here are untrusted so um IVC security does not rely on the relay here um being trustworthy um the relayers can send whatever messages across between chains um so going back to the very beginning of this this presentation um both chains have a light client for the other chain and then it's within these light clients that's the validation of all the messages happen so the security of IBC depends on the light client implementations of both came Beyond chain a and chain a on chain B like being correct because if the relayer is uh being malicious the light client can just reject the message that the relayer tried the second cross because it wasn't actually on chain a um so that's what the security of IVC kind of depends on is the security of like these messages so what are some applications that you can use IBC for um so these apps are actually sort of like apps defined within like other spec numbers so uh there are two categories that ibc's certainly focusing on Cross chain activity and transfers um so uh for cross street activity there's this idea of interchange accounts so you have an account on one like post chain and then you can sort of maybe use the same private key or use like the same account address and use that same account on other teams and except instead of having like local accounts and those chains what you do is you just send IVC messages and then that lets you interact on behalf of that account okay um cross-chain data queries is the idea of like be able to query information about different chains say you're on Solana and you want to query a clip but not a clip sorry uh ethereum price data uh in a very cheap way you can use ics31 to sort of establish that and then cross chain transfer so these are mostly named after the ERC number so ics20 is like the pledgeable token transfer ICS 721 and actually transferred across kids Okay cool so I want to jump a little bit into IBC and eclipse and some of its unique challenges there so um Eclipse as I mentioned at the beginning is a Solana VM uh not a cosmos SDK chain um so unfortunately because we're not built on the cosmos SDK we don't get the IBC module for free like we don't like we can't really use the module because it's designed with Cosmos SDK in mind so a lot of the initial works is just re-implementing the core protocol on Solana which is written in rut and uh building that up so that was like one of the first things that I was working on and the second thing we need to do is uh build like client support uh so for eclipse on any Cosmos chain that we're trying to connect to and for Cosmos chains on the clips um the louder mostly exists already Cosmos chains on Eclipse uh because there's an implementation in Rust so the main uh big hassle is uh supporting eclipses as a light client so this means both understanding the data format of the solar VM as well as like verifying our sort of unique consensus mechanism um so we have sort of a unique settlement system given that we are a Roll-Up on so that's been like um a larger like a bit of work and also an interesting point is that relayers also kind of need like client support so the reason why relayers need this I need a light cut is that if it's trying to receive messages from both trades it needs to be able to like look through the stream of messages be able to filter out which ones are IBC messages uh probably check that the messages are correct because uh sometimes the relayer needs to deliver messages to another chain and if that message was actually invalid the relay could be wasting gas sending um a message to a different chain uh when like a real IBC message didn't actually get sent um so the realers like those want to validate that the message is correct so that's that's what I've been working on right now um and then another challenge is that eclipse is an optimistic role-up so I don't want to dive too deep into this but an optimistic roll up uh essentially assumes that the transactions that are produced by the execution uh nodes is correct um but if there is a problem uh if like someone decides someone realizes oh one of the transactions is incorrect it can submit what's called a fault proof and the protocol has a built-in way to deal with fault proofs and if the fault proof is correct the chain will be rolled back to your previous known correct date um so some other optimistic Roll-Ups include names like optimism um I mean this is a challenge for Eclipse as well because um like IVC kind of assumes that if the message got delivered across K that it was just successful um so there's not an easy way inside IBC to say like okay this message was delivered but now it's incorrect now so can you drop it from the state like uh so we have we have to like work around this a little bit um one way is actually to just uh work with IDC to like add this like into their spec as a way like as like a part of their core protocol that's one thing we're investigating another way might be um so like this challenge period could be like a week so like one simple way is we a lot of people that start sending messages but the messages don't get delivered to the receiving chain until that entire one week period has passed because after that one week we know for sure that those transactions are final um this is create four to do but uxy's might not be the best for users because we have to waste this whole challenge period um a third way might be to uh deliver messages using a bridge instead of using IBC um so a bridge that like were working on integrating is hyperly um so uh the way like hyperlane could work is that it actually runs a full node of eclipse um so that it can know for sure that the messages on IBC uh the messages on the clips are correct and so it doesn't actually need to wait the entire two weeks uh or one week before the message like gets over so that's like another way or maybe something like this could also be built into IBC if we work with uh updating the spec for this and then there's about interesting challenges around like uh paying fees for relays because relays have to pay gas um to actually deliver these messages back and forth so ICS 29 News working on this there's no pain right now that actually has support for this but that's something that is interesting for Eclipse as well given that we have these app specific chains that might all have their own tokens so this might be uniquely challenging for us and relayers uh cool and then yeah so that's mostly what we have so um so in terms of eclipse uh so we're uh aiming for a definite launch early next year sometime around January or February um so yeah keep an eye out for that and that's basically it yeah I want to leave some time for questions if anyone had anything yeah awesome thank you Kevin uh if anyone has questions feel free to ask yeah you can also feel free to just send messages in the chat if you yeah Kevin um I thought that was a great rundown and summary of IBC um in terms of the specific challenges for eclipse is it true that there just there aren't really like clients in um Solana there's there isn't like a state route for example um and like how do you how do you get around that um because doesn't IBC kind of like assume both of those things right I think there are um yeah so I guess like uh I believe that like Solana has like some unique challenges like you're mentioning um one like design that we're pursuing for eclipse is like stopping this modular chain where the data availability is separate from um the like execution part of Solana and so like since we are settling to say Celestia we have like some flexibility over how we represent the state so we do plan on like having a Merkel tree we represent both Beyond chain State as well as like some off-chain IBC related like message like logs that we don't actually want to like store on chain permanently because they're expensive um so you know we like we're still like working out the exact details of like what the actual data format on Celestia will look like uh but we have some flexibility over like adjusting this and then within the like clients that we build for the cosmos chains as well as the relayer we can have it know about like the specific Eclipse um data structure so that it can actually parse these treats uh but yeah Solana doesn't give us some of this stuff like for free another challenge that Solana has is that it doesn't actually store all of its history in States like similar to ethereum where like you can sort of retrieve anything from any time in the past like Salon doesn't have that as well so that's also something that we have to work with too because IBC might want to request messages maybe like five or ten blocks in the past got it so this the fact that you guys are kind of ripping out this on a virtual machine that you can like rewrite like a lot of this is not dependent on like this actual Solana layer one implementation because you guys are kind of gonna adapt things to your own implementation yeah so I think some of the on-chain smart contracts work can be reused with the Solana L1 but we're not actually uh depending on the salon L1 we do plan on using like filona as one data availability Source if apps prefer that um but they're definitely not locked into using that okay so like how far are you with like um so you said anything like four proofs to IDC like how far are you along with it or like what's like what's your thinking there um so we I'm still I'm so sort of working on like a draft of like what main what changes we could make to the protocol I think we're gonna start with the simpler um like wait the entire uh uh challenge period before delivering messages because that helps us get like an MVP like ready uh but I think that isn't ideal so still trying to address the like exact details of how that could look within the protocol like maybe maybe like we maybe tag all the messages with like some bit saying like it's we're delivering the message but it's not yet settled and then we deliver like another bit like further down the line um where we say like this message has actually passed the entire challenge period um something like that uh still trying to work out the exact details of that right now okay modular Joe's action okay uh modulator is asking so you're planning to commit to the svm state every block uh by using your Mercury yep that's correct um and actually IVC like has some built like a built-in spec for these things called Vector uh Vector proof so what they're essentially like doing is you can commit to sort of the Merkel route and then a specific specific member of this Merkel tree with like a much more sparse representation of all the nodes I believe it's like the the entire path of nodes from the Merkel Root Down to the specific node that you care about so like it typically only requires log of at space um so yeah we are planning to do that I think it's pretty standard for like other chains as well so like 