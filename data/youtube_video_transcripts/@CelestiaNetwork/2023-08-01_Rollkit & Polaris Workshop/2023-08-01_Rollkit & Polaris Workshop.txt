thank you everyone for coming today today we're going to be doing a little demonstration and workshop regarding flares which is the evm framework that we've created in order to get all the evm goodness on bearishing for a little bit of context spare change the evm compatible L1 built using the cosmos SDK we replaced kind of the traditional proof of stake model with something we call proof of liquidity which incentivizes validators and node operators to provide liquidity as part of securing the network and as part of this we felt that evm compatibility was something that was really important to us the background of kind of my co-founders in a large part of the core team was from the evm ecosystem and despite liking Cosmos we love Cosmos but we really wanted to make sure that our friends and builders in that ecosystem were able to participate in our chain and felt that you know we wanted to provide them an evm experience that was equivalent and you know made sense so that's how we we ended up where we are today along along that Journey we became really good friends with the guys over at Celestia a huge fan again appreciate them for for running this conference and they do for us Diego and I have spent a lot of time getting not only not only players working but players working with roll kit and and some other uh some other evm Frameworks as well so that's what we're going to be demoing today is showing how you can build your own Polaris chain which is again Cosmos fully evm equivalent but have it post data to Celestia's da yep um everyone hi uh um Diego I work at Celestial apps I do a lot of stuff with real kid but also with other Frameworks and like uh he mentioned we worked together on uh well multiple times on integrating Polaris which is the cosmos uh SDK like evm library and roll kit which is a drop in replacement for tendermint that allows us to take their software and combine it with ours to make evm Roll-Ups on top of Celestia so to give to give a little overview of kind of the the architecture of what we're going to be doing today or part of the architecture what we're going to be doing today is that as part of kind of the test of ensuring that Polaris was a fully evm equivalent chain you know the RPC was working correctly you know all the op codes and everything were working correctly we thought that you know if we can deploy an OB stack roll-up that settles on a Polaris chain that's a really good kind of real world test to make sure that you know are all the rpcs responding correctly you know is everything working you know can contracts deploy can hard hat you know deploy work and Foundry deploy work all these things um so we were fortunately able able to do that and you know not only were we able to do that on a player's chain it's operating as nl1 but in addition one that's actually settling on Celestia as well utilizing real kit um so if we go over to where's Chrome here oh it's here perfect so if you guys want to go over to github.complayers you'll see this is our core our core repo so it contains a wide variety of packages regarding our web ready modules I should say that are used in order to make up kind of the core core Polaris framework one of the core distinctions that we made as part of this was we really wanted to bifurcate all of the things that are happening in the cosmos runtime versus the things that are happening in the evm runtime so what we did is we have like an actual full kind of eth module that has all of our our common ethereum logic so this is kind of what's interacting with the state machine this is handling all of kind of the rpcs just all of the State Processing Etc and then our actual Cosmo side of things really just is a communication layer that allows the cosmos client to communicate with the eve client and that's a big part of what allowed us to get that like true raw evm compatibility is we weren't Reinventing the wheel we weren't you know trying to take tender man rpcs or take something about Cosmos and make it look like ethereum we were like okay how do we take ethereum and make it so that Cosmos can communicate with it um so secondly um if you go to here it's a good pair chain slash modulars this modular Summit Workshop 2023 with all the dashes and stuff um so this is basically what we're going to be doing today so we're going to be the first thing we're going to do is we're going to spin up a local Celestia devnet then from there we're going to configure uh Polaris repo to be able to post to that devnet that we're that we're running and then basically we can go from there we can you know make sure we have Foundry installed in order to deploy contracts do the setup et cetera and then we can start the chain and start to interact with it like like any other evm chain so if you look if we look over here basically we have Polaris repo here what you want to do is you want to check out this specific roll kit Branch if you go on Twitter and see any memes or no no Scott scenario you'll uh you'll know that Diego Works tirelessly and effortlessly every night putting together new new roll kit branches um yeah Chief Branch JavaScript fortunately though due to um due to some some creativity we'll say setting up uh setting up a Polaris chain to utilize roll kit over uh in lieu of comment or tenement it's simple right now all you have to do is just you have to do a simple replace statement of the SDK just and get the roll key compatibility and then this uh protobuf replace that if you've been in Cosmos for a very long time you will know how much we love this this replace here one day one day we'll get rid of this in in the roll kit version but for now for now it's here um so yeah kind of going back and following uh following our instructions here you know if you just copy this guy here you'll be able to spin up the local Celestia da should boot up takes usually a minute or so now once this boots up the one thing we'll have to do is we'll have to copy this authentication key this off key is basically to prevent anyone who isn't EQ from basically spamming um spamming your full node or or like client but you have to you have to copy it over which is something that you know we discovered setting this up can be a bit of a cumbersome process so it will be the role because guys will hopefully be sorting that one out soon but soon soon coming soon but there should be an auth token that comes up here right so you'll see this little message here and then you'll get this this big this big awesome guy here if you go back into Polaris here and go into just this basic init script all you have to do is scroll down to the bottom this is probably really small I just realized you just need to go down to the bottom here and basically there's this auth token place you'll just want to go replace this guy here and this is just for the workshop usually if you were running this on a testament or live um you wouldn't like it wouldn't print the auth token you would have to get it from like a file yeah yeah once that's set up we can just run major start for anyone who doesn't know Mage it's like a really cool alternative to make files that allows you to write your logic in an actual ghostcript so it's kind of nice for doing complex things um Let me give it a second here and it should start producing Bots validation ignored but Diego assures us that's okay yeah yeah that's um that should be a warning okay fixing the next Branch release next week good good give it give it a second here I've been assured by Diego that this works so it doesn't work it's you know do we ran it like five hours ago so there we go we can see that we've successfully submitted a roll kit block to the DA layer which is which is super awesome um and then from there we can we have a fully you know we have a fully evm compatible chain right so we can go and we can you know in the Polaris repo there's some example contracts so if we go into uh like where's an example here if we're going to like Source what do we got like maybe some testing contracts so you know consume gas is one of the contracts we have so we could do like a quick uh you know Forge create consume gas and then if we uh if you look over here we have a few uh we have a few um private keys and stuff that are funded so we can do uh Fork create consume gas um and then what do we also we need to do here because we got to go back a couple a couple here whoops here we do like Forge create consume gas and we could do like Dash as private key equals this and then you could do Dash RPC URL and this is just going to be your your traditional localhost 8545 that anyone you know in the ethereum communities familiar with give that a second or in the case of of this guy maybe maybe a few seconds so maybe Diego if you want to elaborate on some of the updates that are coming that'll allow a lot of the block time to be a little a little shorter uh yeah so um currently roll kit is set to um make blocks uh no no more faster than the underlying like L1 or the a layer um so in the current local devnet uh the Celestia can turn is going at like 15 seconds uh per block which means that roll kit can not safely go faster than that at the moment however we are working on this thing called block sync which essentially allows a roll kit to give users soft confirmations meaning next time we run something like this it would be um very fast it's it's essentially the same concept behind um l2s like optimism or orbitrum and how their sequencer gives users a soft confirmation when in reality like the finality of those transactions takes longer than a second sweet so yeah as you can see now now that the Block's gone through we have you know deployed deployed smart contract this was the deployer address you know deployed to here Etc you know we have full you know full cast RPC compatibility so we can do like cast receipt here right sorry cascode my bad so cast code we can see that like all the code was deployed so that's our little consumed gas contract it's just a for Loop that I think like does hashes or something um you know we can do you know cast TX you can see all the uh all the information about the transaction went through you know the gas price how much gas it consumed you know who the sender was what block it was included in and we can do this for the receipts as well and this just kind of shows like we wanted to make sure that even though it's it's technically running on uh oops I think I copied it wrong yeah I did all right yeah cast uh cast receipt here right that even though it's running on on Cosmos and this is a fully you know Cosmos chain we want to make sure that like all the tooling hard hat Foundry all these things work perfect and again right we can do we can do like cast block we can see here that that was our transaction that was included you know there was some gas use because we had the transaction in there et cetera um and yeah so that's that's Basics the the basics of running a Polaris chain and running it on rule kit and using the celestada for uh well for data availability so I hope um I hope this looked pretty simple and uh if anyone has any questions or anything or wants to run through it we'll be hanging out here for a bit and uh yeah there you go anything you just want to add or um I don't think so um awesome we we have uh evidence of the like op stack roll up running on Rocket running on Celestia um and we can show that you can show that guy as well here yep um so here's actually running whoops here's actually an example of it running all three so if we kind of step back here so we can see that we have the The Da up and running then over here we have the Polaris chain yeah Polaris World kitchen and um soon this video should show the uh OB stack chain that's running on top of the Polaris chain there it is um I believe that is the op Batcher uh op node Etc um essentially showing um the architecture of that diagram that we had in the slides um it's not a like a regular op stack roll-up uh because it's directly connected to Celestia for da um maybe we can show the diagram real quick um so yeah so that video essentially is like proof that we were able to run this uh sometime before this Workshop um but uh essentially um it was a good test of uh how good Polaris is at being the evm um because if you try and deploy even a regular obstac roll up on some quote-unquote evm compatible framework or chain you're gonna find that it doesn't work most of the times um so it was a very pleasant surprise that it works with uh Polaris and especially rocket and um yeah can't wait to see people I don't know deploying l3s and l4s and Beyond with Polaris and obstac sweet thank you everyone thank you thank you any questions do a little quick q a before you move on would you use this architecture Diego maybe you want to elaborate more on on the benefits of of breaking up the the settlement in the DA for the L3 um I mean the somebody would probably want to do this uh if let's say you already uh okay so let me Trace back um assume there's already like a Polaris roll kit L2 on Celestia right um and uh for some reason we uh um we see that like that's not enough in that single instance um and we want to be able to uh essentially um scale more we can have l3s on top of this instance um I think realistically it would be more for the purpose of having more dedicated like space like maybe um the Polaris uh roll up on top of Celestia is more of a general purpose roll-up for people to deploy applications uh D5 Stuff nfts Etc but people want to deploy app specific Roll-Ups on top of this general purpose role um there's also other benefits like assuming you're like assuming that this op stack will roll up on top of the um Polaris rollup is not the only one you do get um some form of uh uh well not some form you get very strong guarantees for essentially cross roller transactions right like you would have um the one of the op stack Roll-Ups on top of Polaris like make a transaction to the underlying Polaris roll kit and then the other roller because it shares the same settlement layer can can read this transaction and essentially you can have like the same benefits that you get from having l2s and ethereum right you get the same form of synchrony guarantees essentially um and yeah the the I guess the to to finalize the other reason why we would have this OB stack chain post uh the transaction route uh directly to Celestia instead of putting them to Polaris um could be because the uh let's say the block size of the Polaris rollup is not um the same size uh like as the Celestia block right um like assume the celestial block is like I don't know like 10 megabytes and that the Polaris roll up uh it runs at the same speed as the DNA layer right and has a maximum size of like uh two megabytes right um that that's like very small that's a very small amount of data that you have to share with like other people on that same roll up when it will be cheaper to just post it on Celestia directly yeah I mean like you know the the nomenclature around l1l203 and all that stuff gets confusing to be honest yeah uh yeah it's a suburb roll correct yeah yeah where does your thought process I need from the solidity yeah it's kind of it's kind of both and we can we can probably I can share some examples um as well because it's I know a topic that a lot of people are interested in um for some of like the standard Cosmos modules that we basically take a consequence module and then we build like a pre-compile interface around it um it's you sometimes have to kind of juggle both where it's like okay like what's a solidity interface that makes sense for for users and then also like how do we like adapt or pattern that to a cosmos module and we've done a lot of like work into making that developer experience like really really clean um and kind of kind of I guess unrelated to this talk but I can show some some examples as well and basically how we how it works um in in Polaris is to first try to pre-compile you have to actually go in and you define like a solidity interface here so like we'll use like the staking module as an example that I always like to use um so you know Ice taking module delegate you have all these events right delegate redelegate and create validator very standard in Cosmos and then you have all of these read methods we'll use just for again an example um and they're pretty they're pretty simple right you know like get validators get active validators you know get a specific delegation et cetera and we make sure to handle it in a way that is very like solidity and evm developer focused right so you know this is going to be a hex address something again like we don't really worry about back 32 we don't really worry about any of that stuff and then as part of the actual like compilation process of the node what actually happens is this will get compiled in Big Air quotes to basically map to an actual pre-compile itself so if we open the staking pre-compile and there's a bunch of abstractions that are here that are doing it all under the hood as part of the build process but basically you'll look at you know you'll look at this here and it looks very very similar right like maybe I should pull them up side by side it might make a little more sense here now that I now that I do this Source Cosmos pre-compile sticking um let me back here so if you look like staking.go right we have a get validator which takes we'll use get validated example right so it takes an argument which is a common dot address um you know validator helper is just some function that does a bunch of stuff it doesn't do that much it's just like data parsing right so get active validator right common.address return is a validator type and then if we go over back to the solidity interface right get act or get validator right takes a uh takes an address returns a validator struct so basically what it allows you to do is it allows you to write pre-compile it's a kind of like look like contracts right like it's very much familiar typing right like address address return a thing or like let's use like an example here right like delegate right takes an address takes an amount returns a pool and if we look at delegate here all right same thing right takes an address takes an amount returns a bull and we're always kind of iterating on these types of things as well one of the things that we want to build next um is kind of like a a stronger type system for like numbers so right now you can see that like this amount is just a big in but it would be cool one of the things we're kind of scoping is like how do we make like an actual like un-256 and go here and then do things kind of like what the SDK does with like SDK math right like have like a Polaris math library that allows us to do things that kind of like sold I don't know if you know soulmate in in solidity land right it's like a live yeah yeah like have like nice like fixed Point math libraries around it and really get the pre-compile experience as close as possible to writing solidity um because that's kind of that's what I would say is like the end goal um and like for instance here like you see that like context that's passed in right one of the first things we've done here I can you know show another example um for the pre-compiles is we have this I think it's in here wherever it is I'm trying to remember where it is it's like polar context or something um I'm trying to remember it's been a while since I've looked at this yeah so here VM context so this is what we pass in for the pre-compile so every pre-compile function gets this context right the base context is going to be that SDK context like unwrapping here but then we also have like nice things that allow for again like very simple um experience that's familiar to solidity devs right like message sender is like who the caller was you know message values how much ether was passed in um you know block is like chain dot block right so we're trying to make it like really really easy for people who are really experienced with writing solidities smart contracts to translate that experience by using familiar terminology familiar kind of code structure use patterns Etc and make it easy for them to to build pre-compiles as well yeah no there's some really interesting use cases um not to plug Scott again but one of the like I absolutely love the way that the guys at Argus are using Creek bios they're not really using them for state in a way but what they do is they use a pre-compile that allows them to send over a um to send over grpc to all the different shards so they actually use the pre-compile as like a Gateway as opposed to it being like oh we're like storing State on the actual like Cosmos node so I think those type of use cases are what like personally I'm really excited for because it allows the evm to kind of break out of its shell and be like oh like I have an evm but I want to make a network call like now I have the ability to do that because it pre-compiles and it you know getting that Dev experience on the pre-compiles as good as possible is what allows for those use cases um so that's what I'm super excited about those calling it afterwards like is this uh are they generated from like looking into solidity definition yeah exactly so one of the beautiful things that Geth provides us is it provides us this thing called abigen which is a binary that effectively allows for generating these types so again as part of this like build process we generate these like API gens so if we look at like staking module for instance we have like a like a go generate that will automatically go and go and generate these types so we have here right like Cosmos coin you know commission description you know module validator right and has all this information that we generate from the solidity interfaces itself so the next thing we're kind of doing some work is finding a way to like map the grpc cosmos types to these in a really clean way using like reflection and stuff so we're getting to the point where getting the dev experience like as clean as possible and reduce the barrier to entry for for people writing frequent models we think that my personal opinion is like pre-compiles it's not like a race at the bottom in the sense of like who can get the bed get the best WX but it also kind of is you know I think like if you have a if you're a company or a protocol or a chain that needs pre-compiles for some reason the solution that you're going to go with is the one that allows you to have the best WX and to like fulfill the need so that's why I you know make sure that our team spends a lot of time you know playing around with this testing the WX you know I have them you know playing around with like Ava lab stuff playing around with you know op stack stuff and seeing you know getting feedback playing with it see how it feels because I think that you know in our case right especially once you get into topics of like cross chain stuff um you know I'm not really talking about it today but like IBC as well if you want a way to like talk over IBC if you want a way to talk to other chains getting this pre-compiled WX to the point where you can write like secure scalable code that is like easy to audit easy to make sure it's secure but also is able to talk to other chains you know make grpc calls et cetera is going to be really killer about freaking files and I know I'm not an expert serious is like how does like GM this is like like how do you price the way to price it and like what are the network holes how would you change yeah so that comes down to kind of how I assume you're using like if I'm writing a pre-compile that like makes a network called to like some you know we use Scott again an example Like A Shard or something like a grpc call um so that's something where it's kind of you can do multiple things um you know if you have a three second block time and you have a 30 million gas limit you could just do the math to figure out like oh if it's a 50 millisecond delay we should add you know whatever whatever the gas would work out to be for that like that hard something naive like that would work um generally we have just timeouts so like you say like oh it takes more than 100 milliseconds or more than 50 milliseconds then just like kill it and just revert the transaction um yeah yeah things like that so um right now I I don't know what the exact limit is right now there may even not be a limit um but it's something we thought about where um because we have that context we can just have it we can just set a deadline on it from when it enters the pre-compile and then just have it um yeah it's just evm the the Geth type would be evm execution reverted in in all of our case yeah so the other thing that um and I believe this is the way the Argus guys do it but don't don't hold me to this I'd have to ask Scott um is that you can basically have a sort of pre-compiled triggers the job but it yeah it makes the network call asynchronously so you can make it so the pre-compile is gonna like when you call it it fires off the job but it doesn't return anything it's just like oh like return pool success job activated and then another transaction later can go back and like pull the result much like how you know chain links like vrf works for instance right where you have to like make the one call wait for it to come back and then get it um something like that I think is the from a developer perspective or like if you're a builder perspective probably the way to architect that um just so that you know that it's you know you don't have to worry about it stalling or causing a transaction to fail for for some reason yeah no worries so right now bear chain is a full full all one so we're not actually using Celestia for da right now um but what we want to do is for Polaris we want players to get on as many chains as possible um and part of that is making sure that it's compatible with um with Frameworks like rocket and we see kind of Celestia as a really good partner in that regard to make sure that people who are building evm chains don't necessarily have to worry about bootstrapping a validator set because it is a difficult thing to do right it's not it's not easy especially if you want to build applications that are scaling to millions of dollars it's a responsibility to make sure that your validator set is good so if you can offload that security while also getting the benefits of the nmt and the da layer then it's 100 worth it in a lot of a lot of use cases yeah you can also like um like we showed in the video and at the slides like if you can deploy an OP stack roll up on top of Polaris that means that you should be able to in the future deploy Roll-Ups on top of a bearer chain right um so then you could use Bearer chain as a settlement layer um which I think comes with like multiple advantages given the way the uh like liquid staking uh sorry not liquid taking uh like proof of liquidity stuff works um because ultimately has a roll up like um one of the main reasons you want to have a validating Bridge uh is to essentially gain access to the like liquidity of the underlying like layer right um so yeah yeah so how it works basically is for exactly that so the fee Market exists in the evm right now we just use the literally it's the Geth uh eip359 code like it's literally just part of the block generation process which is like okay what's the parent hash or what's the parent header and then just run the the symbol pi controller or PD control I can't remember what it is um yes there's nothing really really fancy in that regard um we have a thesis that like the more code we can borrow from Geth and the execution client side the better and I'm giving a talk later today about how we want to move to a model that's like fully kind of execution client consensus client and utilizing kind of the cosmo side for more just for consensus and pre-compiles and stuff while using like a fully minimal Fork of you know Geth or Aragon or wreath or whatever just to minimize dependencies and make it kind of um you know if you want to build some crazy Cosmos thing you don't have to worry about that like breaking the evm and kind of vice versa in otherwise what is the alternative you write like fee Market code and the custom of cck and then you have to hook it up to the evm and then it starts getting very messy very quick right yeah the big thing with Polaris is we wanted to like Simplicity first so there's definitely some things that are really opinionated in the way we do things um because of the fact that we want to try to like minimize complexity um because we see that as like a big part of why a lot of these evm Frameworks end up not being evm equivalent or have problems just because they're kind of spaghetti code and don't have clean dependency paths in architecture et cetera I would never name a cosmos evm framework that's full of spaghetti code and has problems never I would never I would never do that team like that exactly they know who they are say that they know it's okay we love them for providing inspiration to build this oh oh you're doing that I thought you're gonna ask your question Josh um oh one more at the back uh for which which piece exactly like the foreign you can just think about it as a sovereign roll-up that's running Polaris right so it's like an evm roll-up um and because Polaris is good and it's really good at essentially being it um it almost acts like a pure um evm roller but that is almost like if you took Geth and just made it a roll up it's almost like a very similar philosophy to what the folks said op Labs Hub right um the the op stack chain essentially works in the same way that an OB stack chain settled on ethereum would work right like ultimately The Ordering of the blocks and all that stuff is down to like the sequencer for the op stack chain and then stuff gets posted to Polaris and in this case in our diagram right like um and for the video that we showed the da gets closer to Celestia but that doesn't have to be the case you could build like a pure like vanilla op stock roll up on top of Polaris uh using roll kit or on top of Polaris on Vera chain right like um I hope that like answers the question like there's nothing different in this setup that you would see somewhere else it's almost like you could you could almost like cover the Celestia part and I can just tell you that that is like ethereum and that that's optimism right it's all like this diagram that we've built is just like one there's hundreds if there's literally infinite ways to glue this all together right yeah it's just one we chose where um we thought it was kind of an interesting use case that that shows that shows off kind of the work that these guys have done with op and then also roll kit us Etc so we thought it was kind of comprehensive in that regard yeah there's many ways to put a set of Legos together I guess speed awesome thank you thank you everyone for coming I hope uh I hope not only it was good for Rocket stuff but also pre-compiles if you guys have any questions um about pre-compiles come grab me um after this as well I'd love to chat about it okay thank you thank you 