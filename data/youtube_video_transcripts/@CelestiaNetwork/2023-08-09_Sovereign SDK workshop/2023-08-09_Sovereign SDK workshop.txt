yeah so welcome everyone um my name is Rohan I'm one of the senior research engineers at Sovereign I work with Chan um and yeah welcome to the workshop so a little bit about the agenda um I'll spend a little bit of time talking about Sovereign and some general stuff that a lot of people might be familiar with but it's still worth reiterating uh we'll go through uh like the bulk of the demo would we actually be um building like a very simple module using the Sovereign SDK and after that we'll also cover other aspects of the SDK that I'm not able to cover in the demo because you know it's uh relatively time bound and then we'll spend a little bit of time talking about some of the current and future work that we're looking at so um yeah sovereign's Mission if we if I had to summarize it in like the most succinct way possible it's to make it as simple as possible for developers to build powerful blockchain based applications so what does it mean right like when we say simple it's both uh in terms of effort and time we want to be able to make it easier for developers to build and by powerful um sure you can deploy a smart contract anywhere you can deploy applications in several places but uh we want to be we want to give developers as much flexibility and their applications to be as powerful as possible so let's look at what the problem statement is right um yeah building blockchain applications is hard like most of us here know it and uh what are some of the common approaches so you have you can deploy your application as a smart contract on a layer one uh but you know what are the problems with that there's no dedicated throughput uh your state transition function is rigid that means your um the abstract State transition function is already coded into the layer one and you can't really change or customize consensus or anything that you want to and there's also a problem with value accrual because most of the value is approved to the infra layer or the layer one and not your application so that's the issue with smart contract Roll-Ups you have application change uh they do solve some of the problems above but there are new problems now so you need to spend developer resources on non-application logic because now if you have to build your own uh app chain you need to look at blockchain logic there are some sdks but you still have to consider networking consensus storage these are all choices you need to make and you also need to recruit a validator set that's like a very prominent problem because now you still have to be decentralized you need to satisfy like you know Byzantine fault tolerance and your coefficient needs to be high enough to prevent any sort of reorg attacks so standard problems so what about Roll-Ups yeah they solve so some of the above problems they eliminate the need to recruit a validator set because now you're real you're using the underlying ba layer you have dedicated throughput something that your smart contract chains don't have because now all the resources are you have resources for your application the value approves to the application which is pretty great because you're capturing all the value and not some other layer one and the stf is customizable so that is like beneficial like similar to application chains you have like you have full control over the logic that you encode around the state transition function uh but what this is the core of the problem right even building Roll-Ups is actually hard it's not it solves a lot of the problems but the effort involved in building a roll-up is not trivial like you have to make a choice about the proof system like okay do I am I going to be an optimistic roll up or am I going to like how is my finality determined am I going like how are nodes going to consider something final like is it optimistic or are they going to wait for proofs and the second problem is censorship resistance so now um this is a commonly brought a problem that your application roll up can censor or they can prevent users from interacting with the chain so that's one other problem and then obviously even in a roll-up there is slightly less protocol engineering but you do need to write code that interacts with the da layer or whatever layer one that you're using and that includes like things like rpcs like uh you know your Google an application developer is to build the application but now you're doing all of these things like you're writing code to submit blocks to the dla or consume them and then build like an RTC server to let other people interact with it and by tooling I mean even like wallets and everything like there's a lot of additional stuff you're doing as an application developer and there's protocol development like I made it separate because even if you use an SDK you still need to debug networking issues and like for testing you need to be able to launch multiple machines so there is a lot of work that you're doing so the direct consequence of this is that there are very few future complete Roll-Ups like I think if you went by the actual definition of a roll up inheriting security from the underlying layer there's there's this one that actually does that everyone else probably makes like some of some compromises usually because they're like okay we'll decentralized later or we'll add in fraud groups later or only this specific uh address can submit fraud groups there so they're trade-offs like that right so this is basically where Sovereign SDK comes in the goal is to address each of these problems so what is Sovereign SDK it's a free and open source toolkit that we can use to build Roll-Ups so uh Sovereign lets you seamlessly plug in either an optimistic or a ZK proof system so by seamless we make use of like the sovereigners built in Rust and a lot of it is actually uh we provide abstractions around having like uh the right traits that a developer needs to implement so you have a lot of scaffolding and boilerplate already built in and auto-generated so the end result is you can seamlessly change the proof system you don't particularly need to give too much thought to it not not even just ZK but even multiple types of ZK proving systems and then censorship resistance yeah we have a single sequencer but we also support base sequencing so those other kinds of sequencing algorithms are also plugable and the code to interface with the da layer there are already some built-in adapters that we already provide Celestia and Avail and there are more uh da adapters that are in development and we also Auto generate a lot of the tooling and other infra that you need and even the protocol development part which is uh you know like like I mentioned like the storage is abstracted the networking is abstracted uh when typically when you have a chain you also what happens when a new node joins right it has to start syncing and capture there's like Conflict Management so all of these are handled by Sovereign SDK and how to use it yeah like you focus purely on the application logic and the rest of it is mostly like Plug and Play like you can plug in existing the air adapters you can also customize them if you really want to it's the same for prover systems and for the SDK once you implement the necessary traits the SDK Auto generates like the RPC for you we're also working on generating an open API specification so you can have any client like lots of languages have tools to Auto generate a client if you have an open API spec so the CLI tooling and then the prover and you also get the node implementation which is the full node and the light node you don't really need to particularly care about uh yeah yeah the ultimate goal is that you focus purely on the application logic whereas and if you implement the right set of traits or you plug in adapters that are already implemented that does the job for you and uh one of the reasons we use rust is you know performant and the type system is actually pretty expressive so a lot we try to encode as much as possible into the type system so that when you're running something it fails at compile time rather than hey you plug in this protobuf or something you start running and then the only way you know something is wrong is when you actually send a message and it breaks in production right so yeah yeah that being said we can probably step into the demo which is like a simple coin module um I will it's it's a live coding I'll try to live put it but I do have the changes on a branch in case we start seeing like weird compilation errors or something I hope the font is readable for everyone okay yeah yeah so a small overview of the repository itself uh there's a folder called examples and this is actually one of the best places to start if you really want to look at Sovereign like get into Sovereign there's like a demo roll up and a demo prover and will mostly be in the demo roll-up area uh but yeah if you want to create a new module or a new like in our case it's a coin module right so it's typically the same as starting like a new crate or something so if we go into simple uh I'm calling it simple token and at this point it's just a standard rust grade there is nothing in it just the test code so I will import import some dependencies I'm mostly copy pasting a lot of this stuff because typing it will take like uh much longer uh but if we look at what we imported yeah like it's just some standard serialization libraries and everything but we're also importing like the module API and a few other things that are relevant to when you create a new module so uh yeah so what do you primarily need when you create a new module um so I have three files here or you know let's make it a little bigger yeah yeah so uh when you create a new module you need to be able to submit transactions to it you need to be able to read from it which is uh you know like what is the state what is the value of a certain like account or what like you need to be able to query State you need to be able to modify State and there's Genesis which means when the when your module is first deployed what is the initial state right so for each of these we can create like uh three uh files we'll call them like call dot RS uh Genesis dot RS no and query dot RS so those are the three files and uh yeah so before we even look into that let's look at what the structure of our module is right so what we really want is like this is the core structure when you create a new module it's like creating a new contract essentially so let's look at what I did here I'm Auto deriving module which is like part of the documentation you can see that but ultimately I'm creating a struct and I'm annotating a few things I'm saying that okay there is an address for the module itself which is mandatory if you don't do that you get a compilation error and there are two pieces of State one of them is the supply which is uh u64 value the other one is balances which if you're familiar with ethereum it's literally just a hash map that stores an address to the balance so this is a very simplified version of the module because for the purpose of demo desktop understand the core aspects of it right and then you have the standard Imports that I just want to add here and there is something called like the config which I can explain in a little bit it's basically this this is what determines what the initial Supply is so yeah you created your struct which represents your state but after this now you actually need to implement the module trade as I mentioned like a lot of sovereign is actually implementing traits that are defined in the SDK because the rest of the engine or the runner makes use of these trades to run so as long as you satisfy the constraints of a certain trait you're fine like you can write anything that satisfies those straight bonds so yeah so if I do this uh who's looking at my auto completers and showing up once again Yeah so basically if I try to uh do a cargo check or something at this point it will say that some of these three oh yeah so I need to one of the things you need to do is like all of it is based on like a workspace so I do need to add it into the main uh yeah so we created a new module so I'll just add it into the workspace here so this is uh the simple token module so now it should be able to tell me if something is broken yeah so it basically highlights the error saying that hey you are saying that you want to implement the module trade but you're missing a whole bunch of things right so let's just say Implement members and all the mandatory members for now we can just leave this as unimplemented which is pretty cool with rust you can add that in later as long as it type checks uh so for context we already have a like a value C I'll just use that the config represents the initial State and we just created a struct here that says what do what do I need in order to initialize my Genesis State I just need a supply of the token and I need an address of the token and actually you can make this more complicated and say that I also want to have a name for the token or whatever those fields are as long as they satisfy certain traits it's fine like they need to be serializable because you're storing it and your rocks DB or whatever storage right so at this point I'll just say okay my config type is actually this and it's generic so and my call message so the call message is uh what is your what what's the call message that you using for the transaction at this point I don't have like we didn't Define the call message yet so once we Define this we can just see if it type checks or not uh it should yeah and it did because that's actually one of the cool things about rust uh you even though you didn't implement it you're not using it so you can leave unimplemented for now and as long as the types are correct it's still okay so yeah so now that we have our basic uh struct let's look at what uh what the Genesis looks like right so in Genesis what I'm doing is let's see okay so all we're doing here is we're implementing a trade for our uh yeah this is actually pretty simple as far as logic goes I I have my struct and I'm implementing like a function for it this is just a private function um this is not really enforced by the trade or anything but all I'm doing here is I'm saying okay I'm taking the config object which is of the type that we defined and I'm just setting the supply to whatever Supply is part of the config and I'm setting the balance of the Creator to the supply so just to explain this part What's Happening Here is uh when I create my new token the Genesis state will specify what the supply of simple token is so I need to provide like a supply and a Creator the address of the Creator those are the only two things that are needed for Genesis and uh now in in Genesis we can actually write the specific code for calling that which is uh let's see yeah all we're doing here in this place in like the the implementation for Genesis is basically just call init module the function that we just defined here with whatever config is passed into Genesis so naturally these variables are used now so it will complain and uh yeah for these mod for these things to be usable you don't need to add them as like you know this is a standard rust thing so mod Genesis mod call and mod query is not really needed but I'll just add it anyway at this point so let's see yeah so this is the init module function that's being called when I actually uh when the module is initialized and if there are any issues it will say Genesis failure which is fine because when you're starting up your new chain you want it to break immediately if you misconfigure it right so let's get to the more interesting partner which is how are we going to Define what a transaction is for our call module for our simple coin module right so the most basic thing you want to do a more complicated module for tokens would have things like mint burn uh freeze like there are a lot of additional features but for purpose of Simplicity we're already fixing the supplier Genesis so the only real call that we would need is actually just uh transfer so this is kind of what it looks like uh let me just have this here so what we have here is uh a call message so this is an enum type which is if you're familiar with rust it's like uh the the sum type so what are the types of messages that my system can accept so here it's just a transfer and what does a transfer need to specify who am I transferring the tokens to and how many tokens do I want to transfer right so that's basically the only message that is supported but if you want to look at a more feature complete uh implementation of this in module implementation Sovereign does provide like the bank module which is if you look at the call there it'll have like a create token or transfer and then a burn there is like a mint functionality and a freeze functionality as I mentioned and this entire thing is an enum so you as long as you send the right like the serialized enum to the application it will accept it like all of that is auto generated we'll see that in a little bit but uh yeah so now I need to actually encode what happens when I get a transfer message so for that uh you just need this function like you can write this is the core of the business logic right what am I doing when I need to try like how how do I transfer things so we can look at the function it's basically you're getting the sender so there's a context object that has information like who signed the transaction and everything which is available to all modules so you can get who this sender is and the signer is so I have some very simple logic here without checking math or anything so that we can focus on the core part of it so all I'm doing is I'm getting the sender I'm getting the balance of the sender I'm checking if what the sender wants to transfer if it's less than the amount I'm just going to bail with okay not enough funds and then the rest of it is just some basic check math like okay what's the balance of the person you're transferring to I'll just increment that that that's it actually so uh in a production implementation you would have have like checked math if you're familiar with solidity which is like check that check subtract prevent overflows and things like that but the code logic is still the same if you're writing any module this is where you put your like you define what the type of messages which is an enum uh different types of different variants of the enum would be the actual messages that you want to pass to the system to update the state and then you encode the logic on how to handle it but these two are not connected yet like we have a call message and we just have a function right so how do I connect this to the actual module so that's where this call comes in so in Genesis you like when you implement a module you need to tell Sovereign SDK requires you to specify Genesis and specify how to handle a call so in Genesis we wrote the logic we're like okay there is a config that is always part of Genesis once it's passed in you initialize the module with that and for the call this is actually quite uh basically you need to this is like the routing mechanism when you get a message you need to decide which function to call so let me just see yeah so this is all it really is like what you're doing here is uh one you're basically matching the message and you're deciding like uh okay uh what is my type so here the call message so this is one of the nice things about rust as well because you have type checking at this level if you're trying to handle the wrong kind of like an enum that doesn't exist or something it will just fail to compile right at the beginning so I'm just saying that if the message that you got is a transfer message then just call the transfer function by extracting these elements from the enum so that's basically all that's actually happening here so at this point we have uh yeah let me just quickly cargo check it and make sure it works or doesn't break ah yeah so this happened because when we autofill the trait it set call message to blank right but now we actually have an implementation for call message so I'll just set it to that so all of these are things that you need to specify oh it's a yeah it's a genetic so now we specify what the context is what the config is for the Genesis and we're specifying what the call message type is so at this point uh it should type check without any issues but yeah so now we have now what did we do we filled out the Genesis we filled out what kind of messages the system handles so now we can also do like the query part of it which is the RTC like how do you read so we looked at initialization right now we're looking at read which is also fairly uh see yeah so some standard Imports that you need to use and uh by the way like I I wanted to cover this later but I can actually do it now uh the thing is I'm creating the module from scratch just to illustrate how it's done but the in in the modules there is like a module template that you can also use which has like a very simple example with a lot of documentation around how like you can fill out all of these right and in like going a little bit I think we're already currently working on like a cargo template so you can just generate the scaffolding directly so yeah so let's get to the query there are some imports and uh yeah this is the part where we're using macros to Auto generate a lot of this code so what we're actually doing here is I just defined a response type and for the response all that the RPC requires is that it's serializable right so we have okay we're defining we're deriving some trades that rust provides which is serialize and deserialized and then uh what we're doing is we're defining a simple function that says okay if somebody passes you an account then query the balances like if you look at our original struct it had these uh address Supply and balances right so we're just querying balances and getting the account so how does the actual RPC infrastructure come in that's where these macros come in so like Sovereign has a pretty rich set of macros where we Auto generate a lot of code um so if you say that you want to RPC generate you just provide the namespace and what the name of the method is and this is very similar to Json RTC like there is a rust crate called Json RPC which is how you define RTC servers and we use the exact same annotation scheme so all we're doing here is these are the two annotations that we added uh you know this RPC is in the simple token namespace and this function's name is get balance that's it and all we're doing here is I'm querying the balance from rocksdb and I'm returning this serializable struct that's all the RPC macro cares about and if you do something wrong here it will fail with a compilation error yeah okay this is fine so at this point uh our module is actually completed like we have the query we have the Genesis and we have the library right so now how do you plug in this module into an existing roll up like you can like like I said you can customize a lot of logic including the state transition function and everything but we do have a simple like a demo roll up implementation uh when you build your own roll up completely from scratch there are a lot of things you might want to consider like what is my address type is it 32 bytes 20 bytes or what is my signature scheme like am I going to use set p256 K1 or ed25519 or BLS so all of those there are pre-built adapters that you can just use the demo roll up uses Ed 25519 it has like standard 32 byte addresses it uses rocksdb for storage and it uses Celestia for the DL layer so all we're doing now is we're basically just saying okay I have a new module I want to plug this module into my roll up right so what you actually need to do is there is uh the state the logic of your state transition function is defined in the runtime so this runtime is basically just a struct that says what are the modules that are loaded so demo roll up comes pre-loaded with the bank module the election module and a few others so we just want to import our module here and uh yeah so to import it first we have to just add it into this uh thing here let me just see if I have yeah so into the demo SDF I'm just saying uh hey I created a new module called Simple token and I just want to import it so once I do that I can add Sim like you know I can import the other things that I need here so I'll just say uh we called it like once written to do this um yeah so query and so these are Auto generated actually so there is an RPC implementation and an RPC server so if you notice we didn't have to write anything related to RPC directly so we're just saying like a simple token and I'll just call it like uh foreign you can actually see why it's complaining about it laughs okay yeah this had to be like a public module and I just made it like a private module which is fine it's a very simple fix thank you yeah you just made them public so now it shouldn't complain anymore okay so now we have the RPC implementation and we need to plug in the module here right so let's uh put it right after accounts we'll call it uh simple token and that will be simple token and it's not accounts it's basically the simple to construct um you might notice there are a few places where we have like CFG feature experimental so what we do is when we write new modules that are not that we're actually experimenting on uh we feature gated with experimentals so that you know people who are using it know that it's actually experimental it's part of our release process and you might also see like feature native so the reason you have featured native is because um there are certain things that you only need in your native code and certain things you don't need in the ZK approver system so that's basically what distinguishes your uh you know non-zk approvable code from your native code and it's fine like most of this is abstracted so you wouldn't need to directly delve into it unless you're modifying it but uh yeah so there is like the simple token here and I will add it here as well uh the thing is uh this actually derives Genesis so if I try to compile it now it should complain that my I'm not actually uh you know yeah basically it's saying that hey you gave me a new module but you didn't really tell me how to you know how to initialize it or how to do the Genesis right so it tells you exactly where you need to add it which is pretty nice so there is a Genesis config and this is where When the Roll Up is starting you're like configuring all so all the modules that we defined in the code uh or all the other modules have Genesis so we'll just end up adding the Genesis here as well so for Genesis it's basically let me see and we just need to import that as well foreign yeah it says that hey I need this Genesis so the simple token config should be part of this and okay I have a clone here but I don't have a clone here yeah so we'll just see if this checks okay yeah so at this point we've basically completed our new coin module so we can actually let me just check if I missed something because okay okay implemented it all return okay I think we're good because it's checking at this point so uh one of the things we provide as part of sovereign Celestia so that you don't need to connect to the network live if you're doing something so we have a make file that is pretty comprehensive in terms of starting the docker container and everything so let me see if Docker is running it drains battery so usually good okay so I'm just doing make clean which cleans up the docker container so at this point if I start like a new uh if I do make start it starts Celestia locally for me and yeah it's just waiting for the container to start up how are we on time okay good on time yeah perfect so now the container is started and you can actually uh see Celestia actually generating these blocks right so now we start our roll up so just cargo run in demo roll up and it should actually just uh start picking up blocks yeah so whatever blocks are being generated by Celestia are being picked up here uh the good thing is we just did a Genesis so we can check if our new token actually exists right because in Genesis we basically let's look at what we said in Genesis I said okay create a token with a supply of 1000 using the sequencer address I just use that because I didn't want to generate a new key and if I do like this is just a curl command it hits the RPC and if you notice the namespace and the function are basically what we specified in uh inquiry so in in the query part we said this is the namespace and this is the method right so that's basically what we're using here simple token underscore get balance and for the parameters I'm passing in the address so yeah let me just see if this yeah so there's a token of balance 1000 against this address so now we can also try to do a simple transfer so in order to do the transfer what you need is uh what is our call we Define call right let's look at call so we need an enum of the type transfer with a 2 and an amount so we automatically provide Json 30 from your enum so as long as you have a Json that can be deserialized into this enum you're good which is basically what I ended up doing here let me quickly see where it is yeah so in the requests there is a simple transfer.json and if you see it's pretty identical in structure to the enum that we have the transferinum I'm transferring it to a specific address and I'll transfer like 100 tokens from uh and so now I need to create the transaction right how do I do it um yeah so we have like The Sovereign CLI which handles a lot of these things so I can quickly show you what it looks like so if I do cargo run that actually it shows you the functions that are by the way let me know if any level you can see font is visible right okay yeah so at this point I can just uh like there's there's a couple of uh so this is evolving we're trying to make it significantly easier as well but once you have your Json message you want to serialize it to pass it to the server right so that's actually what we're doing here so when I see realize I tell it what the private key that it needs to use is so the private key in this case is the sequencer private key so let me see so keys and yeah so it's this key and then the module name so that's also Auto generated so we don't need to uh the module name is basically simple token that's what we generated just now the call data is the Json that I just created with the 100 tokens so test data and uh yeah requests and you have the simple transfer.json and then you need to provide the nons we didn't do any transactions from here so the nonce is zero so once I do this it's essentially serialized this transaction Celestia accepts blobs right so we need to bundle the transaction into a blob uh but by the way I'm just doing all of this manually just to illustrate how it works to give people an idea it's much simpler like uh we already have something like we already have a PR where the CLI gets the complete uh command line tooling for the module directly so there's something like if you do SUB CLI submit Dash H now the module will turn up as an option so yeah so so we serialize the call now we'll just bundle it into like uh yeah we have something called make blob which bundles the transaction into a Celestia blob you can bundle multiple transactions but we only have one transaction here so yeah so there's like a simple transfer dot DAC yeah so it prints out hex which is the API that Celestia accepts I'll just put it into like a blob and submit it to the dlar right we also have the RPC there's also a sequencer module so there's something called a published batch and a submit call so the sequencer does all of this but just to illustrate it I'm trying to run it manually so yeah so once we have a blob in order to submit it we just uh let me see make subnet and then okay yeah so it's make submit transaction and uh all of this is in the documentation so it's not uh sorry yeah so this is the blob and we can see our rollup is running here right because it's still fetching blobs um I'll just submit this and see if it's okay it's submitted it and we just have to see wait for it to go through the Celestia and for the roll up to pick it up okay yeah so the sequence or outcome is like rewarded and it applied to the state transition so if we check the balance I mean we can check the balance of the new address but we can just check the old one because that was uh 1000 tokens so now it should be uh yeah 900 tokens because 100 tokens have been transferred to the new address um but uh yeah so that's like uh we have 12 minutes more um but yeah that's basically what an end-to-end flow looks like you define your module and then you plug in your module into the roller that that just requires like two lines of code as you saw there's an existing demo roll up and you just uh whatever rust create native code that you created as long as it satisfies the necessary traits you just plug it in and you write some Logic for Genesis and then you're good to go and if you make any mistakes along this process you get a compilation error which is pretty nice and yeah so yeah so that's the demo part of it and uh I think we have some time to go over like some internals of The Sovereign SDK as well which is uh we have like the demo approver it works in a very similar way to demo roll up except that when it's running it's picking blobs and also proving them so I don't we don't have enough time to like demo the prover itself but uh it's completely compatible with the roll up like you get the like if you put something into the roll up you get the approver for free so if a machine is running the proverb whatever is part of the roll up it's all like as long as you're able to generate valid risk 5 code it ends up like like generating proofs for it and the prover is also capable like um so your light clients can validate the proofs before accepting the accepting the blocks so so that's the prover part and uh let me see I'm seeing if there's yeah so regarding like work in progress we have an ebm module that's already checked into main with the experimental feature as I mentioned the goal of the evm module is right now the example that I showed you is native rust code for business logic but this one would let you this one encodes the entire evm as a sovereign module so you can actually like deploy contracts and submit contracts and everything and interact with it as you would with a regular evm roll up sorry regular evm chain our goal is to make it like fully compatible and RPC compatible with metamask as well it's a work in progress and I think it's pretty close to be honest and there's the open API spec generation as well so those are these are two of the most immediate things we're working on but we're also working on a lot of other stuff again as I said it's like fully open source so anybody can like be absolutely welcome anyone to to you know visit take a look and we also like pride ourselves a good amount on like the documentation so if there's anything uh wrong with the documents or anything or if anything is not clear you can always ask in Discord and we'll be more than happy to answer so everything that I explained is a small part of the tutorial and all of that is here actually so when you get started how do you run like a local da instance and what does the make file do there are like it's it's pretty comprehensive and we want it to be you know anybody like we said the goal for Sovereign is to let you focus on application logic like you shouldn't have to worry about anything to do with the prover networking storage consensus like just plug and play start focusing on your business logic so yeah we have 10 minutes for like questions or yeah anything yeah go ahead oh thank you um so because we are like because it's a sovereign roll up you don't really uh the consensus is actually left to the base layer what you care about is sequencing because the ordering is done by the base layer so we support Celestia and Avail right now and like any DL layer that fits our adapter model can support it so the consensus like that's actually one of the beautiful things about Roll-Ups or Sovereign Roll-Ups you don't really need full BFD consensus in the application layer the sequencing and the ordering and the reork protection is actually from the base layer so whatever Celestia uses that's tenderment Avail might use something slightly different but I think I'm not sure if we put it there okay yeah that's fine yeah so so on the roll up what we care about in terms of protocol is decentralizing the sequencing yeah as well yes um it's similar actually so like you bundle your transactions into blobs the blobs go into a Celestia namespace and your Roll Up full nodes all of them uh let me actually see if I have the diagram that would be cool if I did you know um so when you have a page we're creating a Hardware concept imagine and the transactions only services um not depends on which node because full nodes execute the transactions on their own so they don't need to verify proofs they can if they want to but okay you have your blobs going to the DL layer right you also have the proofs going to the DL layer the full nodes are going to take the blobs from the namespace and directly execute the transaction from their own the light nodes will wait for groups because so that way I mean full nodes don't really so yeah um in terms of uh for the user uh if you're a light node naturally you need to wait until it's proven if you're a full node uh if you're a full node it'll be bound completely by the DL layer so as long as soon as the dlar sequences the block you're ready you can apply State transition I mean there are optimistic models that you can use where you can actually take the blobs from the sequencer directly as well and you know if you have some assurance that they will be sequenced in a specific order like degrees of finality right you can have like a soft finality where it's faster so in in the case of a centralized sequencer you can directly take the take the blobs from the centralized sequencer because you know the order in case of Base sequencing it's a little harder because the DL layer could reorganize it if you have a more complex sequencing algorithm where they have a leader election process that becomes slightly better but you know there can be a reorg if something happens and the algorithm isn't yeah it down okay that's the second position no because you just keep posting blobs at network speed the sequence keeps posting so the sequencer technically doesn't need to execute it just needs to check there are some validity checks that we actually do so I I don't think uh so there's a sequencer logic here which handles the reward system But to answer your question the sequencer's job is not to execute it's mainly to sequence blobs and force them to the DL layer so you're only Bound by the speed at the scalability of the DL air and how many blobs it can accept so you can keep submitting transactions they keep going to the DA layer and as long as you have a full node that is accept like reading blocks as soon as they're sequenced they're executed in order of what they're being sequenced as the full nodes execute the raw logic they don't but they don't need to care about proofs but yeah together module uh but uh yeah it's basically currently what we have is so in in the CLI I have an example actually so let me quickly uh SDF so there's actually two calls here one that says submit call and publish batch this is more like when you keep submitting it the sequencer keeps holding them when you trigger published batch it sends the blob so this is in case you manually want to play with it but you can tune it however you like like you can like I said the base sequencing model is more like as soon as you get the blob you throw it into the DL layer uh but uh yeah there is some batching like uh by the default logic we have it based on both time and number of transactions yeah is we are actually looking at IBC compatibility right now bridging for Sovereign Roll-Ups is more based on like clients because the one of the reasons why uh we like for us actually provers are like first class citizens like we didn't want to go live saying We'll add this later so like if all the work we're doing with the prover system is completely concurrent to the full node and light node so any any other roll up that that can run a light client can actually validate it on another roll up so we're looking at IBC compatibility Champion probably talk a bit more about that yes to account and we're also going to build basically an IPC connection because there will have a nice connections yeah sorry I'm just trying to find the diagram oh yeah here it is full screen it or yeah basically this is what the architecture would look like you have do I need to zoom in maybe a little bit yeah so basically you have the The Da layer it's stuck for some reason but yeah you have the da layer you have the sequencer the user submits the transaction to the sequencer the blobs are posted to the DA layer and they get sequenced in a specific namespace and in terms of what is interacting with the DL layer you have both the full node deprover and the light node the full node's job is let me just pick the blocks let me extract the blobs that are relevant to my namespace I will validate them I will execute them and I will modify the state the prover on the other hand is like a superset of the full node in addition to executing it it also creates completeness and correctness proofs for each of the blobs generates the proofs and those proofs get posted back to the SQL like the DL layer so what you have here is the light nodes on the other hand they'd sync only the headers of the dhn and they sync the proofs from from a different name space so this is basically what the very raw minimal architecture looks like hmm oh that is completely uh because like that's basically what the roll up was doing here when I ran it which is uh yeah like this is part like typically what you would actually do is every dlar also has a light client right because the light client already syncs the headers and fetches the data so you would actually use the logic of the like client to do that you can write custom logic and interact with the API as well but the good thing is most da layers come with like clients and nodes that also do some validation for you right because you don't like you like you can fetch a block but now you need to validate whether the block is correct or not it's better to leave that to the DL layer so is um so we actually use uh the default implementation uses jnp like the jellyfish Market tree because it's easier to prove uh I I'm not sure I understood your question about indexing but uh yeah currently there is no State pruning if that's what you're asking but we have discussed on like State expiration or something to prevent like State bloat but uh yeah like the full node implementation is basically that as you keep getting blocks you keep building your JMT and it keeps growing yeah well I guess pulse article State and State changes would be on the da layer the blocks would so so when you say State there are two things right there is the actual state tree there is the ledger so The Ledger can be pruned very easily because you only might need to maintain the last 1000 blocks or last two or three epochs or something but your uh the state tree itself is maintained and full but also one of the reasons why we went with risk zero initially is there's recursive proofs so we're we're looking at a model where in your Ledger as you add new blocks you recursively prove so that at any point in time you can sync the entire state tree and know what the Merkel root of that is and there is a proof of that as well so so in order to get the state of the rollout one year ago you have to solve it you have to re-read it from the um there are like I said it's recursive proofs but the intermediate proofs are also submitted on chain so two options right one is if you if you want let's let's look at it in terms of blocks if you want this like let's say currently we're at block 10 000 and you want the state at block four thousand one option is you play from Genesis the other option is if you have snapshots because we have recursive proofs if somebody says the state at block 800 is X and this is the proof for that if you can just download the state snapshot you already have proof that that's the correct State because the proof is also published on the chain and you only need to play the remaining 200 blocks to get from block 800 to block 1000. yeah so that that's actually one reason why we're very interested in recursive groups sorry yeah I think okay yeah we're already five minutes above um but we'll be around for questions so 