um all right so um why don't we start with a brief intro of ourselves and um i'd like to also hear an short elevator pitch of uh what you're working on your project i'm sure many are familiar but it would be nice to have your own definition of it so i'll start with myself i'm john from delphi digital we provide cutting edge crypto research and we are strong uh supporters of this modular paradigm hello uh i'm proud of lambda i work at optimism as a researcher with optimism we're working on a new upgrade called bedrock and this simplifies the protocol by merger realizing by taking apart the rollup logic from the execution logic the vinod's guth and as part of this we also have this new thought proof deck that will basically secure the withdrawals from the roll-up to the later one all right hi i'm josh i'm an engineer at celestia labs where i lead the sevmost team so i'm not participating on the l1 data layer of celestia i'm working on um if you recall back to most office slides or eric slides the sevmos section which is a sovereign roll-up focused um for settlement so for roll-ups to actually settle onto and as part of that we're using fraud proofs to actually kind of guarantee the security of that software roll-up i'm emily i work at fuel labs and we're building fuel which is the fastest modular execution layer and we're building that using three different principles that's utxo based parallel transaction execution the fuel virtual machine and then a really superior software development experience thank you guys um and emily um so yeah so i think um like the the now that we're in the role of paradigm the difference between fraud proof and validity proofs those are kind of overplayed and well known by a lot of people but i think what's under discussed is how dispute resolution mechanisms fraud proofs and particular implementations of those differ from each other so i'd like to start with that and have your opinions on like what are some design choices you made when building these dispute resolutions mechanisms and if you may uh if any uh can you point out to some like unique aspects of your implementations of uh dispute resolution right so if you think of the early rollup design approached it starting with the fraud proof and then later looking like what can we fit in into the execution i think this really hurts ux over time you've learned that users want some like they want on ethereum at least they want their hearing features so they they're looking for an evm or they're looking for some specific execution environment without workarounds and so to get rid of these workarounds you have to approach it differently you approach it with this this type of vm that can run arbitrary code maybe it can run something else than optimism and then do a fraud proof over this this more generic binary of instructions yeah so i kind of view fraud proof it's a relatively more limited design space i think even than like zk roll ups um because you really have two ways of doing a fraud proof you're either going to have re-executing a transaction or you're going to have this like bisection interactive verification game um for us we're just using re um you know re-execution of a transaction and that's you know our kind of first attempt here and that's for purely practical reasons you know we're building fraud proofs into the cosmos sdk the modular software architecture that cosmos sdk provides that you can have consensus on one layer and then you have your state machine on another layer and so it's a relatively clean software design to just add that execution layer that state machine cosmos sdk layer and say okay now light clients just have to have the ability to take your fraud proof set up the state the pre-state that you give them right from your state witnesses and then actually re-execute the transaction just as any other cosmos sdk-based um execution layer would do it so from it's just an engineering practicality question here at fuel we use a hybrid approach so on one hand we use a utxo based fraud proofs and then on the other hand we also use interactive verification game fraud proofs that are at the vm level and we combine both of these to produce an outcome that works for our execution model and we feel that this offers benefits because it means that we only need to necessarily rely on say a specification and other designs might rely on different technologies like interpreting to wasm and then doing fraud proofs with wasm and those technologies would then rely on the limitations of what the wasm team wants to implement for the language and at fuel because we take this hybrid approach we're just relying on the specification and that gives us some freedom interesting i didn't know that about fuel um so just to like move on that um how far are do you think uh the as an industry we are in like a fraud proof um design space do you think like in near future do you think like many of the problems are figured out and these like implementations are going to like converge on on one design get more commoditized or do you think we will see more and more like some different implementations getting divergent like some different flavors of uh of solutions here so in terms of research i think we're getting there but in terms of products there can be so much more so when you think about all this new tech that enables fraud proof offer some arbitrary execution you could do a lot more than just an evm or just some specific type of smart contract vm and so think of indexing services or other types of things that take layer one data and do this very expensive like huge computations and then just prove that the execution is correct this can be very meaningful to say adding an indexer to to a chain that wouldn't otherwise be possible with a smart contract yeah from my view i think we're pretty far along in research and like what i mentioned before right we have these two modes and you can kind of figure out how to implement those modes from an actual like implementation perspective i think it's a wider range because if you want to re-execute transactions right you just pick that mode of fraud proof then it's completely depend on what execution environment you're using here right if you're going to use an evm execution environment you're going to have to have the ability to re-execute evm transactions same for cosmo awesome same for fuel i'm assuming right where you're boxed in by what your execution environment is and so in that space we're actually pretty narrow in what we've researched because quite frankly you know um blockchains right now we have a pretty minimal number of general purpose execution environments i mean look we have like solana we have causa wasm we have fuel we have evm right those are kind of the big four that cover most of these things and then we have cairo right but you know even cairo team right is working on an evm transpiler so we're very small number of execution environments and that's going to actually drive what kind of fraud proof you need to be able to generate right right yeah i think um we're going to see some general theoretical ideas shake out and become more standardized but then in terms of the actual implementations i feel like those will be specialized to the tech particular technology stack um got it yeah so we basically cannot like consider fraud proofs in isolation from the execution models uh i i i think you everyone would agree with this um so i'd like to hear your experiences and like get more familiar on like what kind of constraints um each pose on each other so you're fraught proof posing on on your choice of execution model and vice versa some what are some like constraints that you witnessed um if you could share your experiences here um yeah right so we started with the wrong approach we have a lot of constraints and over time we like kind of freed ourselves going for more and more generic fraud proof and so we're not being really a fraud proof over the evm but rather we're doing a fraud proof of our mips execution you can target a go program to different instruction sets most commonly as x86 that maps is this simple instruction set that you can do a fault proof offer and using this approach you can compile the evm implementation from gaf to these types of this type of binary but it doesn't mean that you cannot compile another type of golang program to a binary to do a fraud proof offer so over time i really do think that we like we'll think and we'll start thinking outside of the box something that's not in regular smart contract vm and do fraud proofs are for more interesting things would you would you think mips could become a standard here um well so unfortunately at the time of developments we didn't have the ability to target risk fi with go but by now in recent updates in go this risk fire instruction set is now supported so there is this more elegant instruction set that we could support and the differences are not that large it's the same kind of family of instruction sets very interesting yeah so in that vein right you know i mentioned like we're limited by like the execution environment we have to re-implement the execution environment and the kind of elegant solutions the optimism team has gone with you know and as i understand the nitro vm is somewhat similar that where they essentially take the the evm which is somewhat hard to understand virtual machine it's somewhat complex right and they compile it to you know this reduced instruction set computer right you know which is mips and then risk five would obviously be like the ideal more modern one but it's just not quite kind of ready yet from like an infrastructure perspective right um and that simplifies our problem we still need to be able to have the ability to deterministically like execute this thing but then you're reduced to kind of a simpler problem because really what you're trying to figure out with a fraud proof right is how do i execute the minimal amount of state transitions and give essentially the smallest amount of state to i'll say my like client right and then allow them to do the smallest amount of work to prove that i gave them an input and an output and they did an execution on that input and they got a different output right um and i think we'll see this general purpose fraud proving hopefully kind of become the standard and then what we have to see is you know this kind of software architecture on light clients being able to execute these you know general purpose things right where right now you have to run a light client for you know your optimistic roll-up that has to be able to run this mips vm right and it has to tie into that execution for us you know like clients in a cosmos chain normally don't have any execution part in them they don't have a state machine we have to attach a state machine to them and have an ability to start up this state so i think we'll see it at this engineering level of how can you easily tie into these optimistic roll-up chains um to actually do more general purpose execution of a risk you know risk five or a mips based uh you know fraud proof i see i see yeah so i touched on this a little bit earlier but because at fuel we have this hybrid approach it allows us to be based on specifications instead of being based on running fraud proofs based on say wasm or something like that so i feel like in general the fraud proof schemes that we'll see are going to be tied uh to execution right yeah and so so in your hybrid model would you say that it relates to your like data model like the utxo model and and like would that be relate like your choice of a hybrid fraud proof would that be related to your choice of like utxo model or those irrespective of themselves um i would say that our choice of doing a utxo model is what helped us choose to do the hybrid approach okay yeah i see so [Music] um and so a lot of focus on on the roll-up space is and rightfully so is focused on um um reducing this l1 footprint right when we like move from uh single single round uh fraud proof to to a bisection game we try to like simplify the the basically the problem to a single instruction set that should go on chain so this reduces the l1 footprint but when we think about scaling as a holistic thing um really the the l1 footprint is a part of it and and arguably it's not the it won't be the biggest part of it in the future um with solutions like uh like bank charting like with celestia and like um so um a part of scaling is obviously the data model and execution model so what i'd like to know what are some optimizations that you do uh in this respect in your particular implementations right so i do think optimistic roll-ups are in favor here of seeker roll-ups where if data does get very cheap then we reduce our costs by basically 100 this this is our primary cost execution only happens during the fall proof in the the unhappy case so in the happy case you'll get very very cheap transactions and like in the best world you would combine seeker roll-ups and optimistic roll-ups if we had like a zika proof for arbitrary computation like we can do from the throat proofs they can lag behind the optimistic roll-up and reduce the dispute period by showing a validity proof to basically confirm the execution short term i think the optimistic rules are more powerful here with better arbitrary execution and uh so i'll have to deal with the dispute period for now yes i think answering your specific question of like what are we doing to kind of specifically optimize our thing outside of the data layer you know as you know a project inside of celestia we're not really focused on that right now you know we're taking a somewhat naive approach to these roll-ups to these optimistic roles in the fraud proof where we're just trying to generate a fraud proof and we're assuming that the size will come in at such that we can post it on um our data availability layer and we're assuming our data availability there gives us cheap enough data that we're not too worried about that i think one of the interesting things is as data becomes cheaper right um you know as proto mentioned like optimistic roll-ups start becoming more favorable because they have a higher cost of you know a quantity of data that needs to be posted on the l1 as an optimistic roll-up right um and when that kind of problem becomes better like the actual cost of generating a fraud proof also or the complexity of that can become simpler because in this generic you know execution you know the the nitro vm is somewhat complicated to understand the bisection game it's much easier to explain to someone oh i'm just going to give you a pre-state you're going to do an execution you're going to get a post state the reason you might want this you know interactive verification game is because you can get a small or fraud proof and if your data is expensive you know you could touch a lot of state in this fraudulent transaction you could have with a very very large fraud proof theoretically too large to even post in one block right and that's kind of an unacceptable um situation you know that's what the arbitrary people were talking about right they can cover fraud proof for transactions that are essentially larger than the total block space of ethereum but if we start having larger blocks on a data layer or really really cheap data you can kind of remove some of the optimizations actually in the fraud proofs because the assumption is you're not frequently posting fraud press if we're posting fraud proofs like once a day once a week once a year something is kind of wrong with the economic incentive system here right so we can actually get simpler things and less optimized systems that are then easier to understand easier to audit and verify if we get cheaper data right yeah so in terms of optimizations there's really two things that come to mind for fuel and that's one we have the utxo based model that allows us to eliminate the need for a global state merkle tree and this allows us to scale quite generously and the second thing is in the actual implementation every contract has a corresponding address and then to refer to these contracts you refer to them using an address and this allows us to take advantage of some of the properties that having a global state mergle tree would allow you while still maintaining the utxo based system where we don't actually need it thanks for these um yeah i'll have one final question and then i'll open it the panel to audience questions so um oftentimes in this crypto projects there's like misconceptions so what would be can you think of a common misconception related to your project or um optimistic execution in in general um if you have any if you don't uh feel free to pass this one well this is a spicy questionnaire everyone thinks different things about rollups i think in general like you could say there's a misconception that um non-interactive or interact develops one is better for some weird reason in the end i do think it really depends on the dispute periods like if you have this kind of dispute period then you'll see differences or if you don't have this dispute period you'll see differences so like in the sovereign roll-up model or things closer to celestia it's they'll actually matter to to be able to do a non-interactive fraud proof whereas on ethereum mainnet you always have a limited epm and having interaction is actually a good thing because if you have a week anyway to do like this anti-censorship fraud proof like if you take the time then you might as well use that to reduce the the cost on layer one so when in the case where like the the fraud proof is distributed over the p2p layer yes if you want to be off-chain you definitely want to be non-interactive right or something close to that whereas if you want to do this on-chain interactive is actually more optimal makes sense yeah so for like the celestia model if we go into like the l123 right we're deploying that settlement layer which is itself a sovereign role so in this way we're boxed into using this non-interactive fraud proof because we don't have a place where smart contract can live that would essentially mediate this interactive game um but to answer your question on like misconceptions i think there's a little bit of like this assumption that like a 14-day like latency window or whatever to like um the verification um or the trust of the um roll-up transactions like some people don't know i think that that's like a completely arbitrary number that was picked like there was not there's not good backing research on like this is what happens if you extend it to 21 days this is what happens if you shorten it to seven days like people just picked like 14 days and that got good enough that seems fine right but we haven't seen like a live network generating large quantities of fraud proofs to see like is 14 days actually long enough and if you think about the amount of transactions going through you know these networks right we're in you know we if we look at like start we're like we're in like tens to hundreds of billions of dollars of transactions the reality is you just need one honest full node in the network to be re-executing all transactions they should be able to find an invalid transaction this latency window doesn't really need to be that long you know for for you to have you know a pretty large set of people that are you know economically incentivized to check these transactions like you could probably be you know order of like days or or even hours because like these liveness failures you'd have to have the assumption of there is no honest watcher in your network executing the transactions but you're still producing transactions it's just not a real-world situation in like the modern world of how trivial it is to spin up software if right the thing that can generate a fraud proof is open source software if all of them are down on the network and you have a 24-hour window there's like 10 cloud services you can go to at any hour of the night buy a vm download the software and execute it against the chain in that period like i just don't see liveness issues being something where we need 14 days to resolve this right so i think the 14 days number or seven days for some uh it really depends on the censorship ability of the against the fraud proof so if you have a fraud proof of chain you have a very different model than if say if you have a fraud proof that depends on miners including the the challenges yeah and i guess they were biased you know in this sovereign roll-up environment right where we have a relatively easy workaround to the censorship resistance because you can pass it to the data layer and the assumption is that the data layer is not necessarily incentivized to you know sensor transactions for um you know your roll-up above it obviously that's still you know an area where you can have censorship if there's sufficient money to be gained um by censoring right yeah but good color i i i i like the angle that you bring on this emily do you have any um yeah so uh speaking particularly about fuel i feel like there's this misconception that fuel is an optimistic roll-up first when in reality it's a modular execution layer first but i don't think that this is a problem that's specific to fuel i think because modular layers and the modular block chain is this new exciting thing that's becoming more prevalent in the space that we are knowing and working with um i think it's there's uh there may be misconceptions about what the definitions mean and i think that's why days like today are very important so that we can get excited about it and bring everyone together with the community yep so um if anyone have any questions now's the time questions don't be shy no one this shows that fraud proofs are already answered we've already solved all the all the problems i think there's one oh here we go thank you for for the panel uh i have a question here i was asking fuel labs folks on the background but still question for you all let's say i have a celestial like client on the phone it's just a deliverability layer okay and there is a dax deployed on a full node basically unit swap and i want with my phone to take like to plug any execution layer and talk to that text is it do you think it is viable in this year or a year after or it's just like a real after five or six years thank you so i guess when you say a phone here it's a relatively nebulous thing because i i don't think hardware limitations of phones right now are going to be a limiting factor i mean like what the hell does like an iphone 13 have from a processing power perspective that's insufficient to do validation or or execution of transaction um i think your actual problem is going to be kind of from a software perspective like can i get my software onto ios probably not can you get your software onto android probably if you root the phone yeah then you can probably jam it into linux somehow but then actually an interest problem is you know something i don't think we talk about that much it's like cross architecture things you know you can just transpile it to like arm but you do get layers of different architectures in here but i don't see any technical limitations for that i think we're into the limitations of apple and google control you know what 98 99 of all phones and they're relatively restrictive on the kind of software you can deploy i don't know if anyone's gotten blockchain execution nodes onto a phone i don't know where that falls into an app store category well so if you have a phone obviously you might want to run a full node but this is what light clients are for to reduce the resources so if you want to submit a transaction to a dax from your phone and if you want it to be confirmed on the data layer then there will probably some be some software roll up that will try and specialize in giving you like a soft confirmation very very quickly for the decks to have like a good ux and then to show you a proof that the data is being confirmed and like i think this is really just a it should be a software problem and i think this is like a question for like maybe a software roll-up panel or like basically like the execution layer more so than the execution fraud proof tank we have time for one more question and we got one over there someone over here yellow oh there you go oh oh they did work nice um so like i often think about uh like app specific chains there's not really being like whole chains but just like a roll up that's built on top of like a celestium or or something like that and like each application will just run their own role up and etc i wonder how much like you guys have like thought about that i think especially with the people that are building more like general purpose solutions yeah so that's pretty easy for us to answer it's like like trying to do like fraud first in the cosmos sdk right like it's just a cosmos transaction and as long as you know we can generate a fraud proof based off of like you know the state tree that you know we'll get in the cosmos sdk then it should be fine for apps that have change i think that should go for kind of all of these it's just as long as you have the ability to re-execute a transaction for that app specific chain which really just involves a light client being able to load the state and execute whatever software makes up the app specific chain it shouldn't be more difficult than that all right let's uh call it there so thank you guys um that's an awesome panel thank you you 