hey hello everyone my name is mustafa and i'm the co-founder of celestia and today i want to talk to you about celestia which is a pluggable consensus layer for blockchains to enable anyone to deploy a blockchain really easily a bit of background about myself and i was previously a phd researcher at a university college london working on layer 1 blockchain scalability techniques such as sharding and i was also previously a co-founder of shanespace which was one of the first shoving projects in blockchains and um that company was actually hired by facebook but i was the only researcher there that did not go to facebook so what is celestia and celestia is a plugable consensus and data availability layer we're going to talk about what that means in this talk and why that's important but the key idea here is what we're trying to achieve is to enable anyone to really easily quickly deploy their own blockchain without the overhead of having to create their own consensus network from scratch using something like proof-of-work or proof-of-stake um whereas now it takes it would take a very long time or months to to build a consensus network to deploy a blockchain we want to really crunch that process down to a few minutes by making it really easy and providing a plugable consensus network and one of the key reasons we're doing this is because we want to create a world where global digital communities can effectively self-organize in a completely sovereign way um using decentralized networks without being burdened by existing power structures and that could also include um being beholden to the rules of another layer one network uh for example if you're playing a smart contract on an existing nail one you have to follow the follow the um rules of that specific network and we're going to talk about what why that's why that's um not good and why we're trying to change that in this in this talk um so if you look at existing blockchains today existing blockchains today are very monolithic um they try to do everything at the same time so there's several layers to the blockchain if you look on the left um existing blockchains today they provide on the base layer on layer one they provide both consensus and data availability and execution and so you for example if you look at ethereum for example you you write your smart contract and you deploy your smart contract onto ethereum and ethereum provides everything for you it provides the consensus and it provides the execution which is the ethereum virtual machine so you have to write all of your applications in such a way that the ethereum virtual machine understands it and that's quite limiting in terms of what you can do and not only from a technical perspective in terms of being limited to the technical limitations of the ethereum virtual machine but it also means that your smart contract is sharing the same execution environment um as every other smart contract which is similar to if your computer program is running on the same computer as everyone else and so that means you're bound by this kind of shared social contract of all ethereum users so if for example you wanted to to change the rules of your smart contract and let's say there was a hack or for example like the dao you have to convince the entire ethereum community to to to hard fork the entire chain and every single contract so it's not very it's not a very sovereign way of creating your own sovereign applications um because you're bound by the state by the rules of other contracts that you might not necessarily care about but what we're trying to do is trying to make the blockchain stack more modular and decouple some of those layers so what we're trying to do is decouple the consensus layer from the execution layer and what that means is that we're trying to provide a very simple base layer blockchain that only does one thing which is consensus and data availability which is just the core things that blockchain needs to do and that gives developers the flexibility to define their own execution layers on top in the form of their own blockchains and it gives them a lot more flexibility and power that hasn't been possible before um in the decentralized application space we can compare our one of our thesis is that we can compare the evolution of the blockchain space to um the web so if you look at the earlier the 90s when you know http or the web was first created and if you wanted to create a website you had to basically create have your own physical server for example in your bedroom or in your university and then um shared hosting providers came about i don't know if everyone everyone remembers services like geocities or dreamhost or um bluehost you would basically upload your code to this shared server and your website would run on the same server as everyone else and then in the modern web we have virtual machines or cl of the cloud so now anyone can easily spin up their own server and kind of like the 90s but without actually having to go through the overhead of having a physical machine you can spin up your own server on something like aws in minutes and have complete flexibility and control and sovereignty over over what over how you create or deploy your your application so we're seeing a similar evolution in the blockchain space so in in when when bitcoin came around in 2008 there was this idea of like each blockchain each application had its own blockchain so bitcoin was had its own blockchain specifically for cryptocurrency or for for the bitcoin um asset and then you had things like litecoin namecoin you know mastercoin and those were basically providing like a blockchain for each application and then ethereum came about in 2014 and provided a general purpose and blockchain for that allows people to upload any application to share the same chain um and that made it easy for people to create their own uh smart contracts and upload it but that has severe limitations similar to the limitations of uploading your website code to a shared web hosting provider like like geocities because you have very limited flexibility in how you can actually um develop your website and what it can do so what what we're seeing now is a trend towards um back to people creating their own app specific chains or their own chains for their own applications but instead of having to create their own application from scratch they can deploy their chains on existing or plugable consensus layers similar to how today you can deploy your own virtual machine on aws using using the physical servers that they have from a technical perspective um i'm going to discuss the way that celestia works so existing blockchains today in order to check if a block is valid you basically have to check two things number one you have to check if the block has consensus i.e does it i.e um if it's proof of work for example is does the chain have enough proof of work for it to be the longest chain or if it's proof of stake for example half tooth or using byzantine fault tolerance have two thirds of the validators sign the block that's the first thing and then the second thing is that you have to check if the actual transactions in the block um are valid like you can't just insert a transaction into the chain that steals everyone's money and you should reject that block and so effectively current blockchains are coupling the rules the execution rules for transactions um with the rules for the consensus and this doesn't scale because the problem with that is that in order for users to check that block is valid you have to download and process every single transaction and to check that a block is actually valid but what if you actually remove that second rule like what what if you like said like you're allowed to post invalid transactions on the chain and anyone's allowed to post anything on the chain would the chain still be secure the intuition is yes it will still be secure because what you can do is you can insert the implicit rule on the actual user's machines to say that if they see an invalid transaction they just ignore that transaction so if there's a transaction that steals people's money even though that transaction is on the blockchain you just ignore it and when you're trying to process or compute everyone's account balances so however even if you ignore the transactions that are invalid you still have to make sure that the miner or the block producer has actually published um all the transactions in that block so you don't want to end up in a situation where for example here a miner has published a block but has not actually published the transactions inside that block and then people won't know what the transactions are and therefore they won't know what the actual account balances are in the chain or what the state of the chain is and if that's the case that a minor or a malicious minor or block producer could potentially inject invalid transaction that no one will ever know about so it's important to also make sure the miner has actually made the transaction uh published available on the network so what you have to do is you have to replace the rule that transactions are valid with transactions actually being available and it turns out that checking that transaction has actually been published or is available is a lot easier and more scalable problem to solve than actually processing and computing the transactions because you can using techniques such as data availability sampling and you can actually check that the entire entire file or entire block has been published without actually downloading the entire file you can effectively check um that um the entire block is available by only downloading a very small piece of that block i'm not going to go too much into the weeds about how this technique works but the basic idea is that if you use a technique called erasure coding um which is like a redundancy technique used in lots of technologies like cd-roms or satellite communication um if you apply that technique to the way that you create the block you can you can you can make users um random sampling or probabilistic techniques such that if they just download a few pieces from that block like a few random pieces like for example these black chunks here they can have very very high probability that all of the other pieces in that block um have actually been published and therefore all the transactions in that block are actually available and therefore um that a miner can or a block producer cannot actually hide an invalid transaction in that block um and the key thing about data availability sampling or data availability proofs is that you can um the number of samples or the number of the number of chunks in a block that you have to download to check that the entire block is valid and is irrespective of how big that block is which is nice because you can increase the size of that block in the chain and therefore the number of transactions per second without increasing the cost to the end user to actually validate that chain but the caveat to that is the bigger the chains blocks are the more users you need in the network to actually be downloading these random samples in the chain because you need because you need to be sure for this technique to work that the um all the users have collectively sampled every sample in that chain or in that block so this leads to key two key properties the first property is that because you only have to check that a block's data is available to validate that to validate that chain you no longer have to actually execute all the transactions in that chain you just have to check they're being published and you can actually validate blocks and subline your time because you can evaluate the chain without downloading everything or checking everything just if you just see the few pieces from that chain secondly uh the key the other key property is the more nodes you have in the network the bigger the block size you can actually have securely because as i mentioned you need to increase the number of users if you want to increase the block size because you need to make sure that there's enough users in the network to sample the entire chain um and this is an interesting insight because if you think about what's the what's the world's most current decentralized scalable protocol it's typically peer-to-peer file sharing systems like bittorrent so like bittorrent at one point handled a quarter of the internet's traffic and you know this was back before netflix um people was pirating movies um bittorrent handled a quarter of the internet's traffic and the reason why it was so scalable is because because bittorrent doesn't do execution it just does data storage and and distribution it has this property where the more users that are on the network the more seeds and peers there are on the network um the more data the network can store and distribute and one of the key insights here is that if in a blockchain we simplify the block verification rules to just data availability verification you can potentially achieve very similar scalability properties to bittorrent so now we've discussed you know how does celestia itself work as a consensus as a basic consensus and data layer um i'm going to discuss um how do you actually deploy or build your own application on top of celestia given that there is no smart contracts like like ethereum and there is no shared execution environment so the way it would work is that um applications only use the chain to store the transactions but not process the transactions instead the applications transactions are processed locally um by the actual users of those applications um to determine like what is the state of the application like what is what are people's balances but the problem was that is like what if it's not practical for users to process the transactions themselves the solution to that is you can instead make it so that um you also post what's called a a state commitment which can be a merkle route that commits to the entire state or account balances of everyone in the application [Music] but the problem is like how do you know that medical route is valid or how do you know whoever posted that state commitment is valid and that's where roll-ups come into play so so what is a roll-up um a roll-up is basically in simple terms a blockchain that posts its data to another blockchain that serves as the layer one in a roll-up what happens is that a user submits transactions to what's called a aggregator in that roll-up which takes all the transactions in from from users wanting to post that role up and then creates a block from all the transactions and then posts on the chain and that block includes a commitment or medical route to the state of the application at that time now if the aggregate if the aggregator is malicious then what happens is that there's two cases depending on what kind of roll-up you're using if you're using an optimistic roll-up um then it's kind of a innocent until proven guilty model so you assume optimistically that the aggregator is telling you the truth but what you what you do is um you allow anyone to challenge that so if the aggregator is lying to you then anyone can challenge that and create a proof that there's a transaction or state in that in the roll-up chain that's incorrect and that would be called a fraud proof then the other category of roll-ups is a what's called a zero knowledge or zke roll up which is worked under a guilty until proven innocent model which means that when an aggregator posts the block to the chain um you assume that aggregator by default is dishonest and then you require them to also submit what's called a zero knowledge cryptographic proof to prove to you um that the block is valid and both of these techniques require a base consensus or data availability layer such as celestia because in the case of optimistic rollup you need to be sure that all the data in the roll-up chain is actually available in order for for um people to actually be able to generate food proofs because if they don't know what the transactions in the chain are then no one can no one can generate a fraud proof because they can't prove something has gone wrong if they don't know what happened in the case of a zk roll up it also requires a base consensus and this layer because if the actual data or transactions in that roll-up weren't posted that you could end up in a situation where no one will know what their balance is or what the balances or the state in the chain is and therefore that's potentially equivalent to like burning people's funds or locking people's funds um the model of celestia is that all applications have messages associated to uh with a main with a namespace so when you create an application you you you choose a namespace for that application and you can you can choose whatever namespace you want and in celestia we've organized the the block such that we're using a merkle tree that is ordered by the namespace of each transaction and what that allows you to do is users in that network in our network can query storage nodes in celestia to ask for transactions specifically relating to their application and so that basically allows it makes it possible for users to use the celestia chain for only roll-ups or applications that they're using without having to download the user that the transactions of other applications that they don't use for example and so that's why we call celestia a plugable consensus and data layer because you can build an application that uses celestia just for that without requiring your users to take an interest or download the transactions um of other applications that they're not using which is unlike existing blockchain models where because the consensus and the execution layer is coupled together you have this world computer model where every smart contract is running on the same computer um the user of any smart contract has to also take an interest or check whether transactions for every other smart contract is correct and so we sidestep that by creating a model where we separate consensus and execution so in conclusion we're trying to build a scalable um universal plugable consensus layer for developers and communities that want to create their own chains very easily without having to go through overhead of creating their own validation network if you want to learn more you can check out our website celestia the org where you'll find more resources including links to papers and videos do we have time for questions okay [Applause] what benefit do you have for posting these transaction messages in separate namespaces instead of just using separate blockchains like what does this um common uh consensus layer achieves it basically makes it so that you can create your own chain using a roll up without having to create your own um layer one content blockchain from scratch but uh do you have some uh cryptographic or some other incentives or is just like infrastructure uh uh incentive to use this instead of building another one so the main incentive is that so there's several incentives here first of all the first incentive is simplicity or um flexibility it's like right now if you want to create your own blockchain let's say use something like tendermint or substrate you have to you have to define the validator in your chain so that like by default you start with one valve later for example and that's not a very secure chain for example you might have four valve you might have four validators and that's still not very secure that's a very small data set so you have so there's this bootstrapping problem where you have to you know create your own token and you have to maybe do a token sale and distribute your token to and then you have to make sure that um there's enough validators and stickers and stickers in your network um such that your chain is consensus is actually secure that's that's a very long process and a lot of you know not only technical overhead but potentially also legal overhead and also make lots of maintenance work and actually maintaining a consensus network so this allows you to sidestep all of that by instead of having to create your own validator set you've got a plugable consensus network um that provides consensus for your chain that you can test your blocks to so you can just like immediately within seconds just uh post create a chain or define a chain using something like the cosmos sdk and then post the blocks onto the post the blocks of the chains and the celestia without having to worry about um creating your own consensus network the other point is um we're kind of trying to envision a world where there's potentially thousands or even millions of blockchains just like how today there's like millions of websites um and organizations using websites you know they're not all using you know shared servers most of them using virtual machines and all of those virtual machines talk to each other and interpret each other and if you're in a world with billions of blockchains you cannot expect all of those blockchains to have a secure validator set like ethereum and you know or like cosmos or polkadot you know it is a big monolithic chains with a lot of value laptop and therefore can have a secure con staking network but with a training with millions of blockchains you have this tail end of blockchains and that will probably have like one or two validators and we're trying to get rid of that um issue by making a plugable uh consensus network that people that that change can easily plug into and be secure i just wanted to ask is that any different from just being a layer one for other layer two solutions because as far as i understand uh like the other blockchains which get your consensus are just layer two solutions on your l1 base chain right yeah so it's so they for so they're pretty much limited because for instance in ethereum and optimistics and secure roll-ups they sometimes have limitations in what they can do so you know what so what do you mean i i don't understand what you mean i mean layered um i mean like it seems like celestia is a blockchain and uh they're just projects that launches layer two on your blockchain yeah so it depends on what you mean by layer 2 so it's not like it's not like you're creating your own layer 2 solution on top of celestia it's more like you're using existing layer 2 solutions or layer 2 execution environments for example like there's lots of people building roll up you know roll up based execution environments and you can you can plug out you can you can use different data availability layers um for those solutions and most of them right now use ethereum um and that makes sense if you're building an application that uses eth as an asset um but what we found is like most applications except for maybe some like d5 dexes maybe like uni swap and they don't inherently rely on eth as an asset so this is the question is like why why do you need to why would you build your role specifically on ethereum if it's not using eth specifically as an asset what we're trying to create is a general purpose um data availability layer so whereas ethereum is not general purpose because if you want to use ethereum as a data layer for your layer 2 then you have to effectively take an interest in the validity of the entire smart contract execution environment in ethereum and because that's where your layer 2 posts to so in order to validate the state of your 2 you also have to take the interest of every smart contract in ethereum but we're trying to remove that kind of overhead by creating an overhead minimized or general purpose uh data availability layer that is not coupled with some um you know heavy execute like a state machine like the ethereum 1.0 state and that's quite useful for you know people are just trying to build a general purpose or like in sovereign or independent roll-up applications or decentralized networks that are not not necessarily tied to the ethereum ecosystem and this is like more of a general question because um we're living in a more and more like multi-chain ecosystem where like you know most transaction volume one ethereum now is not even on ethereum it's on polygon like people just like transferring acids from ethereum to polygon and just doing the transactions there and then transferring it back to ethereum so because like we're trying we're living in a multi-chain ecosystem and solutions like this will become more and more relevant and um a general a general purpose data availability layer will become more and more important you have a follow-up or i don't mind thought one more question my mouse is not connected for some reason anyway um yes so my question has more to do with ddos protection so let's say there's an application that which stick that has a state prime position function which involves something computationally heavy like zero knowledge proof verification yeah uh and because the data availability layer is a data agnostic so it doesn't care whether the verification is going to be costly or not i can cheaply spam a lot of transactions but the client still needs to verify every single transaction that was added related to that application would the uh would the ddos protection happen on the data availability layer on the or on the application layer for that yeah so it's a good question and there's two points to that um the first point is let's assume you're using you're building an application on celestia that's not using a roll-up it's just like uh you're just posting the transactions on celestia then as you said like what if someone just spams the chain with like a million you know invalid transactions the solution to that is the same solution that bitcoin and ethereum have which is a fee market um for block size so for workspace so there'll still be a block size limit um in celestia that is should be a function of how many users there are in the network because as i mentioned the more users you are the more the greater block capacity you can have securely and so like if you want to spam the chain with too many transactions there will be a cost associated to that and that's okay because like bitcoin and ethereum have the same issue like in bitcoin you can like post you can try to post like a million transactions that move like one satoshi for example and that's that's not a problem because um like what if you paid for it it's not spam and so the the first point is that for the earth protection there's a fee market which makes which makes it expensive to post in economically infusible or chronically expensive expensive to keep spamming the chain the second point is if you implement your application as a roll-up you can sidestep the entire issue because the the the the clients or the like clients in your chain wouldn't be violating every transaction or checking every transaction instead they would be downloading the block headers for your for your application and the block headers will be given to you by um what's called the sub network of your roll up so you'll be connected to nodes specifically that um like like aggregator for example um in your roll-up and you will be downloading the block headers from them rather than scanning the celestia chain directly for the block headers and if you're connected if you unless you're connected to um a malicious block producer which you can easily blacklist if they've given you invalid block header then that makes it much more difficult to do a dearest attack against a light client to give them a lot of invalid block headed or make them process a lot of junk and that's that's exactly the same model that bitcoin and ethereum have like if you run a bitcoin nerd like your peer could send you like a lot of invalided block headers but all you would do is just you you would disconnect from that peer and and you blacklist the ip address is it okay if i ask a follow-up sure uh so i was more referring to native applications rather than roll ups okay so in ethereum for example we have certain operations that are costly and certain that are not so for example let's say in celestia i presume the fee will will depend on the amount of data stored on the layer right yeah the more the more the more demand there is the more the higher the fee would be okay uh so for example zero knowledge proof is relatively small at size but it's very costly to verify on ethereum i can't spam a lot of transactions because i'll run out of gas limit for the block whereas in here i can spam a lot of transactions because i'm just paying for the data yeah but but the key point the key point is like there's no difference between um like from my cost perspective there's no difference between a transaction that is like makes an invalid payment and a transaction that makes payment of one satoshi like both of them like both of them theoretically costs the same amount to verify like maybe you i'm not sure i'm not supposed to be sure about the z case today you're talking about but in the specific payment scenario you start to verify the signatures and so the cost of violating like a one-state transaction is the same as invalid transaction um so it's like you can do this you can do the same attack in know bitcoin and ethereum by just doing a one second transaction and make people process like a bunch of meaningless transactions but of course they still fix that with with the fee market and that that solution seems to have have worked okay i understand thank you thanks [Applause] can you help uh change the slide 