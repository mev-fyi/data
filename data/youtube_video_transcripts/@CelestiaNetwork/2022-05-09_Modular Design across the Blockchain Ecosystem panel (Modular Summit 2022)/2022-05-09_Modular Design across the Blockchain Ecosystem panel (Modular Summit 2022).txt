[Applause] hello can you guys hear me yes um so why don't we start with a brief round of introductions michael uh yeah i'm marco i work at uh interchain gambaha and i'm the current product owner of the cosmos sdk i've worked from tendermint all the way to the cosmos sdk so just having fun with it uh i'm james prestwich i'm currently cto at nomad which is a modular bridge focusing on smart contract chains and arbitrary message passing hi i'm beau i'm co-founder at polymer labs and we're working on a universal ibc interoperability hub hi i'm alex i'm an engineer at protocol labs i've spent the last three years also working on filecoin as a software and protocol engineer thank you so mustafa made this very clear distinction this morning what like a modular blockchain is and what like modular software is and where the distinction you drew a clear line so um let's let's also like briefly summarize what like modular design in general is like a modular design means that you basically break up a system into smaller parts so-called modules they can like be used in other contexts that can be changed or yeah basically can plug them into other systems as well and in modular software like modular programming you uh basically subdivide your program in modules where the modules only execute the part that that um that you care about so and yeah modular blockchains is when you basically um outsource core functionality of a blockchain i think that was made very clear throughout the day so i wanted to ask uh the panelists like where do you see like modularity emerging basically in your like in the in the fields that you work on like in the cosmos sdk i think zaki took most of it away but uh maybe you have more for us um yeah unfortunately i didn't see zaki's talk so i don't know if i'm gonna say something wrong now um but the cosmos sdk was always built or the cosmos ecosystem was always built with the mantra of like there'll be many chains in the ecosystem kind of this interchain world with ibc and so the idea of like modularity in a framework to rebuild to build new blockchains and make it faster to scale has always been at the core of cosmos and so with the cosmos sdk it's evolved over the last it's been around for like six seven years now and now at the most latest i think it's the most advanced and it's truly modular now we're seeing chains pop up in the cosmos ecosystem that go from like inception and then one month later they have they have mainnet and we really haven't seen that and building a modular software stack allows us allows people to accelerate their products thank you uh right now in bridges we're seeing a lot of modularity in the separation between communication channels and the applications that they run between how you actually pass data between chains and between what's done with that data like token bridges nft bridges governance systems uh one of the things we built at nomad that we're very excited about is a strict interface for how a communication channel connects to an application and this should let applications like bridges swap out ibc for nomad channels for anything else they want um in general we think of modularity as finding the right place to separate a concept into two smaller pieces and finding the right interface for that cons so finding the right interface for that separation and defining the contract around it how people use it and what they can rely on as a polymer we see obviously as defining those interfaces like james said in a really nice way kind of separating the like transport authentication ordering layer uh from some of the application semantics you can kind of see it in the interchange standards there's clear distinction between the two layers they have a number of specifications uh that they review by the community and across different organizations and one more thing i would like to say about what mark was talking about in terms of the cosmos sdk is that i think the cosmos sdk does a really good job of making the components so modular you can replace certain components like with what celestia did was able to do come and replace tenement core with optimum and basically do what they do and be able to innovate and that's a really important thing that i see here is that it allows different organizations that come together build together and innovate very quickly uh yeah i mean modularity of software is very core to how protocol labs tries to build things ipfs for example has a sort of strong brand as a thing but really ipfs is a collection of uh protocols and components that are that are put together uh a data model in ipld uh some network transports from lib p2p a few different ways of exchanging uh information uh and so really we don't think of there being a protocol be as ipfs but a node can participate in an ipfs network uh if it if it uses a similar network protocol and if it adopts one of the transport protocols one of the data exchange protocols uh that you know that one of our ipfs nodes will use um and then similarly those pieces can be taken by other by other projects and so other projects will usually p2p for their networking that automatically puts them a step closer to interoperating with other projects that do the same thing and the ipld data model again is not specific to ipfs and is a foundation for other applications data models thank you yeah so um in the so the cosmos sdk was mentioned several times like in the cosmos sdk and particularly in tenement do you see anything like that is currently more monolithic that should be more modular marco um thankfully no one here is from who works on tendermint core i'm very opinionated on this uh tendermint was always built as a library so kind of when jaquan and ethan buckman wrote wrote it the idea was you have um you have consensus you have p2p and all these things but it's like if someone wants to switch out consensus like from tendermint consensus to like hot stuff it's it should be easy enough to do it it was always meant as like a consensus framework a consensus library and over the years building modularity is very difficult especially at a low level because you're kind of making assumptions of how the application developers will use it how the clients will use it is somewhat easier for application developers the deeper they go the more freedom they need in developing their software and so at the lower level tendermint has kind of shifted more less from like being super modular to being a bit more opinionated because if you make too many uh opinions or you don't make that many opinions then you it's it becomes really hard to build software um but in tendermint in general like i just wanted to be more modular i wanted to be to switch out p2p with like a click of a button instead of having to fork the code and rewrite some stuff yeah that's that's what we do at celeste um so one aspect that was also mentioned several times is like ibc um is that also would you also describe it as modular or is it something specific to the cosmos ecosystem only like maybe james uh i really enjoy working with ibc it is modular in a sense that it can be applied to other ecosystems i think that the amount of effort it takes to reach other non-tendermint ecosystems right now is very high uh and so so actually it's actually a lot easier than we than we first thought okay uh i'll talk to you after that i'm interested um you know it it took a number of years to develop ibc for tendermint in the first place uh it's going to take a little while longer to productionize it outside of the tendermint ecosystem which and you know in like the eth2 model where they have a proof-of-stake system that admits some reorgs we have a lot more work to do to parameterize ibc and make it work for the casper-based consensus system which is why we focus on not just the ibc connection but what applications can we build today that can be eventually connected by ivc once it's ready and what channels can we build that can be used today that can be swapped out for something more secure or faster once it's ready uh this is one of the great parts of modular design is it allows us to go you know build scout modules that go fast break things uh colonize new ecosystems not colonize but uh explore explore that's a good word tracer tracer yeah wander around new ecosystems find what works uh and then we can bring in these heavier and you know better things like ibc in the long run once we have figured out what an application developer wants in a specific chain ecosystem modular modularity allows progressive development and upgrades over time let's talk a bit more about bridging and ivc in that sense so um modular blockchains does it make your life much harder as a bridging provider or like as someone building bridges thinking about bridges um i think so sorry you can go um i think so i think there's more considerations to make for example like when you separate consensus from or perhaps execution from the data availability and consensus layers now you have to say like well on this and we have data availability headers on on this other end we have uh state proof headers we have to somehow combine these things when we want to you know perhaps produce a fraud proof um but yeah i think there are more considerations to make and how all the pieces fit together it's not fully clear yet but i think i think we're going to be able to figure those things out yeah one of the interesting challenges is that the bridges like ibc which are kind of the ideal most secure model you can get they mix the execution and consensus layers they have to cross that boundary they can't be confined to one of the others the bridges that we work on and that can be iterated fast they stick in the execution layer they don't really touch the consensus systems uh so modularity might make this more challenging to reach you know the long-term goal of having these consensus layer bridges everywhere because there will be more consensus modules that we have again more execution modules which will also play into these kind of bridges um yeah let's let's let's take a step back and talk more about modular software as well so um one aspect so first of all do you see any like downsides of building building your software more modular maybe alex or marco yes there's always a trade-off i think to building something more modulary to build a module to be reused by others is in a sense to take on an obligation to serve others needs and you don't know who they are when you start building and they don't know who they are when you start building but eventually you'll have to uh in order to serve some needs well you'll have to optimize towards those and necessarily be less good for some other use cases and so at some point someone else coming along with a new novel application uh wanting to plug it together out of modular pieces will find that they just don't they they can't get the performance or the features that they need uh and so at the other end of the of the stack is sort of vertical integration and there is a great place in the world for vertically integrated software and vertically integrated systems um you know car manufacturing is probably a you know timely example now where for for a long time uh car manufacturers were outsourcing and modularizing and buying and putting together components from other lower level manufacturers um and there was this old joke in the auto industry that you could see the org chart of the car company from the layout of the dashboard and you could see like there was a climate control team and a radio team and a navigation team and so on um but then tesla came along with entirely new needs and so they are a vertically integrated car company and they make almost all of their own components and they use their own manufacturing processes and can produce a different thing at a you know at a price and performance uh that could not be met by stitching together the modules that existed beforehand and so um i wouldn't be at all surprised if we see a continual sort of back and forth between modularity and vertical integration in five years time maybe that we will be at the vertical integration summit uh about all these special purpose interesting to to kind of add on to that it's like when you're building modular software you're also providing a guarantee of like security and kind of the assumptions you made when building the software but in especially like you can't predict what a developer will do when they use your software and so you providing a guarantee for this software and then maybe them taking and changing a few variables kind of breaks that guarantee but for them it's like if they say we are using the cosmos sdk and we got hacked it's like no you guys are using a fork of the cosmos sdk that you guys like rewrote a bunch of stuff like this shouldn't really fall on us because cosmos sdk we provide a security guarantee of the software that's in the code base yeah you kind of have to teach developers not just about the system that you build the module itself but about the interfaces and the boundaries of that module and what they have to do to keep the module working with other modules correctly so there's a lot more developer you know mental overhead for these things yeah and like you end up talking with a bunch of users like how are you going to use the software and i think in the current blockchain space in the past year or something we've kind of run into this cycle of like we're kind of rinsing repeating many similar products and then so it's like you build this you build your modularity to like serve these products then you can also get a team that like does does something out of the box and you're like okay wow this is where we want to be going because this is like pushing the boundaries this is like something that's next this is the place that we're comfortable in right now yeah i think that brings up an interesting point that i want to connect to alex over here is uh we always like start off building bundled projects like everything's integrated in ethereum and it's because we just didn't know how to do any better at the time like we built ethereum the way we did because we had no idea what modularity was or what the right boundaries between different parts were or where the concept bitcoin is even more extreme to that like it's more monolithic like more integrated yeah we built it monolithic because we didn't know what the right module boundaries were now that we know we can build modular systems and then eventually once we have modular systems everywhere people are going to want to go back to monolithic to eke out those you know those little gains they can get by eliminating the edges between modules yeah that's a typical problem yeah exactly like uh in in web development we've seen it go from monolithic services to micro services and back to monolithic because people get frustrated with whatever the current model is yeah that's basically what what alex also said previously there will be a constant back and forth yeah we're in a great space now where they're like it's it's all about the pace of innovation and modularity is fantastic for you can quickly plug together a few things and maybe you take some trade-offs but you can learn really fast but once we really know what we're doing um james is right we didn't know what we were doing to start with you know ipfs is just the same libpeter p didn't birth as an independent project it was extracted from ipfs and so were some of the other protocols over time um and then we then we realized what we're doing and what we want to plug together and then when someone really knows what they want to do they're going to go and do it from scratch in a vertically integrated way again when they're going to sacrifice the ability to change it later yeah and we we had to do it that way because we didn't know any better totally we had to experiment with it first as a monolithic thing to figure out the right way to build modularity so something some theme kept popping on the like recurring theme that was mentioned on the panel is like the interaction with users and people using your modules potentially different in like different ways that you didn't anticipate maybe so um one thing that i wanted to ask and like i don't have an answer to it at all myself but like how do you basically uh maintain these modules from like a governance point of view like it's it's it's you you have these potentially have these like you have tenement maybe you have the cosmos sdk and its modules and you have something like lip p2p which is widely adopted across the the blockchain space or like in other non non crypto projects as well it's like how do you make sure that this is some like is it is it like in any other open source project where you you basically maintain it and you discuss things on github and this is like you you submit rfcs and you discuss and you discuss and eventually you come to an agreement and you implement this or that feature or this and that addition to the protocol is it exactly like this or are we in a space where um i feel there's like all these projects that are kind of like collaborating using the same software using the same open source software and they are at the same time collaborating but at the same time somehow also competing it's like do do we need other means of governance and do we do we need to align incentives here or is that something um that that is unnecessary i know i know it's like a tough question i could probably do a whole summit about this topic but i i just want like off the top of your head like what what what what what are your thoughts on this particularly marco and alex maybe um i'm gonna have to think for a second yeah sure as far as i don't have anything that says it's different to other open source software yet maybe it will be maybe we'll learn about something uh or perhaps some better way of doing things but i think it basically comes down to open source software development and most of my ideas here i'm like shamelessly parroting things from nadia igbal and her book working in public which i think really sets the stage for the discussion here um software the code itself once it's produced is a public good it can be taken and used by as many people as possible with with uh you know marginal cost but software development and the the software development resources the people and the time and the attention is a scarce resource that is competitive and uh so it sort of comes down to discussion about at what level do you want to do you want to be open and decentralized and permissionless it doesn't work for it doesn't scale for a team building a critical software component to accept contributions from any from everywhere to answer every question to allow anyone to have their say on how the software should be written that the team will immediately grind to a halt and be unable to make any progress on the things that are important but we can sort of add the robustness add the anti-fragility back at a higher level by agreeing perhaps on a protocol and then having multiple implementations of it so there are multiple implementations of liberty and they agree at the protocol level but then are free to make all of their implementation decisions independently and so it's robust in the sense that uh individual software libraries can fail and most open source software libraries go nowhere they're you know pet projects they don't gain traction they don't go anywhere and it's fine and that makes the ecosystem of open source software incredibly robust because individual project projects can fail on the way to us discovering uh and supporting the best most useful projects and then one day forking them when they you know when we need different different different needs from them so at least in the in the cosmos space um we're starting to get to the point where we have to put a lot of like parameters that are kind of like feature flags inside modules for things that are changing to replicate the similar behavior in the in the early days when the cosmos have first launched and there's maybe a couple other chains it was easy to coordinate like we go talk to these three chains do they want this change um some of them put it to governance some of them don't some say it's fine and we go forward with it right now there's roughly 35 chains and if we introduce like a consensus breaking change that they may not read the change log for and all of a sudden have this irregular behavior that they weren't expecting causes a huge huge problem and so it's like feature flags are kind of like the worst thing you can do in software and just adding a bunch of them just because you end up having to maintain so much extra software that you don't know how many people are using but in an environment that you don't know how many people are using your software because they may be rebranding it as their own or they may be like forking it and saying something else then it's kind of hard to be like okay we're making this consensus breaking change if you don't like it like you have to you have to go do it on your own because we want to also avoid people just forking the repo just to do little changes uh this is a little embarrassing for me because i have an unmaintained cosmic sdk module that needs to be updated for the breaking changes yeah exactly i'm feeling a little called out so but you don't think none of you think that there needs to be basically like some doll structure or something like that in in uh to to maintain but because it's like there are these there's always like in this space there's always these incentives right like you have stakeholders you have maybe like very like even competing projects that use your stack right yeah it's it's a super hard question to answer and in terms of like governance in like the cosmos sdk land and tendermint i it's unfortunate to say but there's like a finite amount of people who actually understand the protocol and there's a lot of people who use it and so you if you involve end up involving all these people who just use the software and maybe like they write applications with the cosmos sdk then never have dove into tendermint and all of a sudden you have to involve them in like tendermint discussions on like oh are we changing um to like lit p2p are we changing to this are we changing to this then the process gets dragged out like alex said like you end up hitting a wall and then the spec keeps moving and the developers kind of get burnt out because it's just kind of like you're trying to implement a moving spec and then it just becomes an infinite loop so it's like you don't like democracy basically well yeah yeah i got the point and it makes sense but like it's a it's a recurring thing and you talk about governance yeah sorry oh i was like i think we're talking about interfaces and layers and also governance and consensus over those interfaces and layers and alex made a really good point about if you define certain interfaces for example uh within the cosmos sdk you have the abci it's evolving to the abc i plus plus there's some interface changes at like the o2 client level to support the development of different light clients i think the idea is that you want to you know have some sort of consensus over these uh layers and how they're defined and then be able to have protocols come in and innovate and make trade-offs beneath between the interfaces themselves make sense do we still have time for like short a few questions maybe from the audience as well if there are any i i always asked a few questions uh before and i was like keep them for the keep them for later but uh not sure if people are asked to hear any people are running away you can introduce yourself hi i'm max um can you comment on maybe there'll be an overlap in the future where the communication mechanism the bridges overtake the actual chain uh a future where the communication layer in the bridges overtake the chain so we're looking at modularity especially like with celestia where it sort of enables cross-chain applications would you see that the bridging technology technologies become more dominant than say on chain activity that's an interesting question typically the bridging technologies can't provide what users want out of a chain users want to store their assets to you know trade them to lend them borrow against them all of these things that bridges are poorly suited for we the way we look at this future is that bridges are going to be asynchronous communication channels between applications that are honed on individual chains and i don't see that changing in the near future i do think that there will be some bridging standards that are just on every chain implement the same standard in solana rust and near rust and polka dot rust and solidity and everything else but i don't wouldn't say that they would dominate the chains uh they might just be widely deployed on chains um more questions there's another one over there hi my question is more to the interoperability rather than modularity of parts we're seeing now a lot of the cross-chain protocols are trying to build essentially similar cross-chain messaging protocols as ibc is or xcms for the substrate do you see this becoming they're becoming like a standard to allow them to interoperate or it's more of which ecosystem wins out ibc is the standard ibc is a standard tell this to the xcm people you know that's the same we've talked with the web 3 folks um and the polkadot folks about ibc uh we're working with a couple teams implementing ibc ibc on substrate via grand pro like clients and [Music] mountain there's some new consensus that they're doing and so we're working with people who are implementing both and the idea behind like cosmos and ibc and everything is just kind of like interoperates with everyone because it's like a connected ecosystem of blockchain not of a specific like smaller ecosystem just makes everyone better and so in a way we lift everyone up uh ivc includes a lot of different parts of this bridge stack as well so when we talk about ibc we have to distinguish between which icss we're talking about which touch different parts of the modular like chain stack and bridge stack so some ics's will be the standard and some of them won't make sense in specific chain environments so thinking about this a little more to answer max's question i think a little more in depth you could look at ibc as an example of the communication standard dominating the chain and that cosmos chains are designed the way they are in order to support the current set of ics's like cosmos zones are designed to participate in ibc and that is one of the defining most important elements of cosmos yeah so you can use it off the shelf without adding another ibc client that makes sense yeah there is uh i think another question over there last question yeah okay hi friends uh so basically i i think like sales like modern stuff plays out um two years from now what are your thoughts on what this like post modular world looks like what things are we going to like focus on is more like application layer stuff um yeah that's a great question to end the panel alright start i mean to step back and like look at why we're here we're trying to build the reason that blockchains and execution uh layers and so on are interesting is because we're providing a platform for applications to be built software for people to use to achieve things uh and in our case ideally things that are cooperative or collaborative in some way uh so there's a there's a big there are a lot of modules to be built out uh in this uh platform you know with a nod to mustafa's attempt to claim the definition of modularity earlier today um in a your development platform needs you know the execution layer the cpu in the computer and it needs some ram which is the state and it needs a you know i o bus which is the the data availability layer and it also needs storage which is file coin and it also needs uh networking talking to other computers which is bridges and there are lots of pieces here that need to all come together into a platform and i think we will see start to see some standard ways some standard groupings of these modules in much the same way as like the ibm pc defined a standard platform much to ibm's detriment uh but which then provided then provided you know the green field for application developers to go nuts on this platform that was well understood and widely implemented uh and so i'm hopefully in two years time from now that kind of platform is understood and we're talking much more at the application level thank you okay that was it thanks 