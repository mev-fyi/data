yes it works wonderful hello everyone so yeah I'm Zach I'm the CEO of Aztec and um I'm here to talk about uh basically if I can can I go back does this even work ah how does never mind okay we're not going backwards um yeah so I'm here to talk about uh how like how does one turn uh code um into ZK sockets specifically with the angle towards looking at privacy so privacy is hard um if you want to like the goal of what we're doing in Aztec is to enable users to write smart contracts where you can have genuinely private State variables inside of them um where they're encrypted you can still do Logic on them but only owners of those variables with the decryption keys can actually see what's inside um and so we spend a lot of time over the last few years basically trying to figure out how do you take this key foundational technology of zero loss proofs and actually present it in a way that's gives you the spec the benefits of privacy whilst making it accessible to developers without needing to require cryptographic knowledge um you know no and basically boiling down all the complexities to do with zk2 and privacy to a relatively simple set of heuristics and so the goal of this is to create rather composable modular abstraction layers that um turn like converts the code of a smart contract and and the the basically the the consensus algorithms that you're using to verify its correctness into algebra represent proofs so these are the abstraction layers um that that one that's uh we've come up with at least when it comes to how to do this um we're taking a very different approach to uh Brian and risk zero basically because of the private State model um once you want to create blockchain transactions where you have private state in the mix then you can't take a an existing like architecture like ethereum and then just wrap it as UK proof and call it a day because the um uh even if your state is encrypted the act of modifying it still leaks that basically leaks a transaction graph um so we basically had to build a lot of this from the ground up starting with what do you need to turn a slot code into a snacks you do cryptographic back end basically something some kind of printing system that will construct and verifies in order proofs you then need some low-level language that you can use to convert programs into circuits the idea here is that we have this abstract intermediate representation asir uh which is our attempt at llvm for stocks so it basically describes um generic-ish constraints that are snark friendly and the idea is you can compose a program out of these you wouldn't write a program directly in this here but the goal of us here is that you take language front ends like Nora like Circle and you can and those with which presents you know a nice programming language with clean semantics and that gets converted into um uh into into the intermediate representation a bit like how you take rust and rust is a language front and that compiles down to llvm Noir is the language frontend for ZK that compiles down into essay and the goal of this to be very modular so that uh you can swap out various proving systems um so like Halo 2 or um our Aztec stuff brettenberg or arques to basically fit your own custom needs and then also with that you actually need tuning for your language and then you need a program execution environment and a transaction execution environment basically the entire network and architecture infrastructure around sending transactions to a distributed Network so yeah that's not the bait let's start at the bottom zero numbers proofs uh yes who wants to do some math I didn't hear you who wants to do some math yeah I know end of the week we're a little bit tired um so this is this is nonsense basically it's not nonsense but but um it's like a Zero's proof is you know you have a proof of you have a verified and some kind of common state some statement with some public input secret inputs and the goal is to prove that your inputs belong to some defined relation um uh some sort of algorithm this is is is not a program this is not a smart contract this is weird messy algebra um and uh it's it's it's a pain um itself these three like three fundamental conditions completing the sound of cereal knowledge completeness is basically if you um an honest private can always make a valid proof the verify I want to reject a good proof Samus means that a verify will always reject a bad proof and zero knowledge means that effectively the verify doesn't extract any any useful information out of your proof um and so um yes um algebra is like you can't you can't write complex algorithms um in terms of algebraic equations like not not practically you know it's a bit like trying to write a computer program by flipping bits on a on a magnetic hard drive with a needle it's not going to work and so the basic abstraction layer that we have to move from ZK proving systems to snarks is the concept of an arithmetic circuit so instead of having um an imperative program you have these concept of arithmetic gates gates have wires they go into the gates they go out of the gates the gates perform basic operations like add and mole and you can use this to sort of represent a program as in if your circuit if you have an infinite number of gates you can represent any Turing complete computation therefore it's you can sort of think of it as being slightly ish too incomplete and so and we have very nice weight reductions that convert arithmetic circuits into snoc systems um and so this makes the the the abstracts away some of some of the evil complexities was UK proofs but not very much of it because you still arithmetic circuits it's still algebra at the end of the day so yeah basically zero knowledge is Annoying It's hard we want uh people who are working with ZK Tech to not have to know anything about the CK or cryptography because it's an absolute nightmare um so okay so so I've described some of the basic abstraction layers that that we can use to um construct snoc circuits but how do you turn a program into a snark circuit you know programs are these weird Complicated Love icons of code with lots of conditional branching and predicates and you know working on complex data structures how do you turn that into like additions and multiplications well you can do it with Noir so um this is a a programming language that we've that we're building from the ground up to be zika friendly um and uh support the kind of complex private State models that you that you need in in private transaction environments and so we've modeled it after rust so you know it has variables it has things like integers and booleans like you'd expect from a regular programming language um and yeah so it's a front-end basically that could that it doesn't compile circularly into constraints just composite in the essay and you can put it plug in any back end you want that supports a Sim the goal is to be a completely open architecture try and uh and uh so that for other folks can customize it to their needs um you know plug in whatever cryptography they need to get that job done uh so yeah you know you have even things like arrays and you can access the arrays with um with with non-constant values which to a programmer is like obvious to a cryptographer that's really hard um but we can do it uh and you know basic compound types that you would expect um so effectively noise like a programming language from the 1960s but with modern modern semantics wrapped around it uh you know we have even things like a module system and sub modules isn't that amazing it's better than C plus um we even have loops and if statements uh which again as a programmer of course you have a statements as a cryptographer you know you think if statements they're hard but we've got them so let's let's move on um so okay so now you have a programming language that takes your High Level Pro computer program and converts it relatively efficiently into a snock circuit you then have a cryptography backend that turns your stock second into a Zero's proving system do you have a private blockchain no no you don't uh not with a stat all you have is a programming language um what we need is an execution environment um and so basically some some system that doesn't need to be physical or real but that that will execute your program and perform actions as a result of what your program is saying um so this you know node.js is the is is a basically can be considered an execution environment for JavaScript the ethereum network can be considered an execution environment for evm programs uh so uh and so this is where Noah with smart contract functionality comes in so this is basically what we're building at Aztec it's a way it's adding the semantics around smart contracts in general so you can Define contracts you can Define functions that operates on public State private States you can Define storage slots and storage variables like you do in a you know regular smart contract language and and then on top of that is this on the next slide oh no it's not so sneak peek or contract syntax so this is the kind of the kind of stuff that we are developing internally that will be available externally hopefully next month uh that allows um so this is just some random like example transfer function but it has weird um keywords like secret and a secret balance so um yeah and you can but you so the goal is basically all the complexity around what the hell that means all of the encryption all of the like the weird stuff you have to do with Michael trees nullifier sets and you know and and witness encoding insights not accessible abstracted away and you just you get nice Easy Storage slots uh so yeah you know um basically taking it's an abstraction app that gets rid of all of the all of the ugly stuff on the right hand side uh and then we combine that with a real proper Bonafide execution environment that is the Aztec Layer Two um it is a a um a rather large collection of snark circuits that's um compose a a lighting Network or effectively the goal of the network is to uh the user will send snock proofs that represents um the um function calls two various smart contract functions and the roll-up circuit um will one of the circuits effectively will use a heck a lot a lot of recursive proof composition so proofs verifying proofs to basically emulate a cool stack um for the user so that you can basically have a functional stack of private functions and public functions and you can work your way through the cool stack by recursive regenerating these snack proofs um and then you have a roller circuit which will take these snack proofs and um uh validate their correctness perform all the State updates value there all correct do fee management do consent like all of the sequences selection consensus algorithm checking and you end up with a proof of a block but not just any block block a block with Chas an encrypted state tree so yeah that's the CKC follow-up it inherits the theory security we're leaching from ethereum's consensus like all other layers um but the the critical difference between Aztec and the other as things is the fact that we support both private and public state and you can use that to create hybrid hybrid applications something I often get asked is like what can I build with privacy right privacy is like weird abstract concept and we don't have it in web3 not really so uh how how to articulate this um one of my go-to examples is um uh werewolf sign interests or specifically things like let's say you want to sign into a web free account using Apple ID um using like FaceTime no not FaceTime face ID uh what will happen on your phone is that your phone is going to use its Hardware security module to sign a digital signature according to a message format defined by Apple and according to a public key that is also described by your Apple ID uh there's no reason why you can't verify that in a smart contract using account abstraction and that can then become the default portal to your account however without privacy that means that every time you transact on chain everyone can link those transactions to your specific Apple ID which is rather problematic um if you if you're doing uh anything with any kind of like real value associated with it um maybe you don't want people to know that your you know you're trading djen board 8 nfts um with all your life savings so um that's one example things like down governance private voting um you know one of the key problems with data governance right now is the the massive like social pressure to vote according to certain ways and For Better or Worse privacy means that people convert according to their conscience perish the thought um uh so yes maybe we in a few in a year or two we will be able to see the true dark heart of web3 and uh what what our community really thinks um so yeah that is um so those are symptoms of some of the things you can do with privacy and there's the obvious user hiding properties you can hide your identity and you can then link your cryptocurrency account to a real world identity so yes um so I'm actually at the end of my talk because I blitzed through all the last slides and uh this was supposed to be a 15-minute talk I got the timings wrong so we have a few minutes of questions um thank you very much [Applause] does anybody has a question um so you mentioned public and private applications do you have an example of like how that would work or what are the use cases for both of those at the same time yeah so the the reason why you'd want composable hyper applications is because there's there's lots there are a lot of um decentralized applications that require Global State and one of the difficulties with their private with an encrypted um stage database is that you like in a private World status owned by individuals or groups of individuals it's encrypted with that against their public key and and so consider a defy app like um like uniswap which like or any kind of automated Market maker where you have Concepts like the total Supply in your in your network your liquidity uh pools things like that that's all Global station therefore needs to be public and so then the question then the question becomes well okay well how do you get privacy guarantees with a decks well one thing you can do quite easily is you can keep the the token values public but the identity is private so the idea is that you can have token contracts which have um private like basically privacy preserving functions which allow you to Shield to to hold shielded balances and then you can directly deposit those that you can you can basically deposit those value like deposit into a amm like uniswap where um the get the value of your tokens is public but the identity is private and then you would have the the public UNICEF algorithm execute the trade um in many ways this is uh I think this is I suspect this is going to be quite a popular model in the future because it gives privacy for the user but it still means that you get transparency for the protocol so you so you still know that's you know whatever algorithms are being executed by the protocol being run correctly you don't have to there's no centers of trust and longer term you can close the circle and make the entire system private by adding in multi-party computations of that um all of the price finding algorithms that an amm uses are executed in a multi-party way so they can actually be genuinely private but that is a future product to be built I think we have one more question yeah time for one more question hey so um you had a slide there where you sort of described from ZK to snark using a circuit but then from Z case from a snark to a programmable environment I'm still like like how do you turn then a circuit into a place where you can do all of this you talked about the language but I don't like where is it you're right I did skip that so let's let's go back so the first the first kind of um system that kind of did this was the zaxi protocol from 2016 but so we have the concept of a kernel snack circuit where what a kernel circuit does is it it basically ex it verifies the correct execution of a single function call so let's imagine that you have you you want you have a smart contract your smart contract has public functions and private functions each function is converted into a snock circuit and so then what a user does is they construct one of these kernel circuit proofs where the kernel circuit takes as an input a function call stack so at the very start that function call stack will have one entry in it it'll be the function that you want to call um and what the kernel circuit will do is it'll pop that function called off the call stack it will verify a proof that you've provided assuming you're you know um one Your Everything To Succeed you provided proof that proves that your the function call has been executed correctly the kernel circuit will verify that their that the verification key belongs to a specific smart contract and then what the kernel circuit is going to do is it's going to grab the public inputs of your inner snark circuit the one that made the function call and interpret that those inputs according to a defined API and it's part of that API um that function call May spit out additional function calls to be executed so if you from you know so if you have a for example you you want to call approve and then you want to call transfer from on different contracts for example and so that's one iteration of the kernel circuit but the kennel cycle is recursive is in that it verifies a previous proof of itself um if one exists and so what you can then do is you can you can can repeatedly construct proofs of the kennel circuit so to start with you know you have one function of the cool stack um that gets popped off and verified but then more functions get pushed onto the cool stack as a result of your first function call and you just repeatedly construct proofs until your function call stack is empty and then the the output of that is well you now have a proof of a kennel circuit with an empty function call stack so no one knows what functions you've called but also spat out of that proof are basically a bunch of encrypted State changes state updates to perform as a result of those functions being executed and that's kind of sort of how you can get a quasi-execution environment out of a snoc circuit okay thank you Zach cool thank you [Applause] 