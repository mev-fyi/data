I routinely I find myself asking myself like how would I actually build a Roll-Up and a long time ago like not too long ago but I've I've sort of picked up on that people that Roll-Ups like kind of aren't decentralized we have these Roll-Ups with single sequencers and we sort of rely on them as a crutch at the moment and when I wanted to build a roll up I wouldn't want to use a single sequencer that doesn't sound like very much fun to me so I kind of thought about how would I have a decentralized sequencer and roll up in the first iteration of this was just to use tenement for a single roll-up which obviously isn't that scalable but at least you have the ability to have more than one sequencer it's already implemented we can just kind of go and use it so that was the first thing and I I named that the same name so I gave that name Metro now that probably didn't need a name I knew it didn't need a name but I already had a cute name already picked out so I used it anyway which was a mistake so originally I wasn't going to name this new architecture uh anything but then people started us when I called it a shared sequencer that's the terminology that other people have used such as flashbots with Suave and this is very different from Suave so now I'd had to like I felt like I had to give it a name so this is Metro the architecture almost like the sequel and this is covering a blog post um not a blog post a forum post that I wrote up a while ago and sort of like an idea that the the overall idea as we'll talk about in a second is extremely simple so I believe that I'm sorry if I'm not giving credit to anybody who has already thought of this I'm assuming many people have already thought of this because it's that simple of an idea and uh I remember like like Mustafa talked about pessimistic roles a while ago so that this is this is like a lazy roll-up I'll talk about lazy Roll-Ups in a second or if you've already read the blog The Forum post then um you'll you'll have an idea of what lazy Roll-Ups are those are basically just pessimistic Roll-Ups like that's where that was the first lazy roll-up was a pessimistic blower that Mustafa described and the the rest of it I think has has essentially like either already been done by like tendermint with deferred execution or inbox models or things like that they're all like extremely similar this idea really isn't that new um but again maybe I'm making a mistake again by giving it a cute name but oh well we'll go so starting off with the obvious the centralization allows for a better censorship resistance and liveness it's difficult to have censorship resistance without having multiple people being able to produce a block I'm sure maybe you can get very clever and do it but it's difficult same with liveness um liveness is even more difficult to do without having multiple different block producers uh it kind of sucks with existing Roll-Ups that only have a single sequencer if that sequencer goes down the roll-up goes down if the sequencer sensors that roll-up sensors so having more nodes being able to produce blocks is sort of a solution to this now when you combine that with Roll-Ups decentralization obviously isn't like this one-dimensional spectrum where this is more decentralized than this Roll-Ups have the ability inherently again stating the obvious that they can prove a state commitment is correct via some mechanism whether it's frog proofs validity proofs name a thing and because Roll-Ups can do that they don't it's kind of okay if you have a single sequencer because at least I can't steal your funds that's like kind of the most important thing now they can still censor they can still go down which is something that we want to solve but this is kind of where Roll-Ups it's kind of okay for them not to be decentralized but ideally we want them to be decentralized now we also want to use rollups to be able to spin up a new chain quickly and Roll-Ups if we have to have their own decentralized committee to produce blocks then that is difficult to deploy in fact organizing for such a feat just the off-chain organization like having your own Discord answering questions getting good validators to go up that's difficult enough to do and not scalable for every single roll-up team to do so not only that but now you have to incentivize all of them to stay alive and to to to produce blocks constantly and to not have this uh to not lose your key or to not make your key public because then people can forge can can be malicious on on your chain so it's difficult uh it's not scalable we need to find some solution to this if we want to have a million decentralized Roll-Ups if we want to have a million just normal solvent Roll-Ups that are single like a single sequencer no big deal if we want to have a million decentralized Roll-Ups we have to have some solution to scaling this consensus and this is what this shared sequencer architecture is sort of aiming to solve just in one way it's one way to solve this problem and we sort of save this we sort of take advantage of the fact of the previous thing that we just discussed with rollups is that they can prove that state commitment is correct so that part the calculation and comparing of the state commitment doesn't have to be decentralized the aggregation part the part with censorship resistance and liveness that part we do want to have decentralized so if we can separate them that would be great and um Celestia does this this is this is this is Celestia's gimmick not a gimmick it's it's let's just thing it's it's it's stick it's it's you you separate execution away from consensus and data availability and part of the thing that Celestia could do is it could act as an aggregator you could submit your transactions directly users could submit their transactions directly to Celestia it gets a little bit annoying because you have to wrap it and um see can I move yeah so it gets it gets a little bit annoying because you have to wrap it there's this padding it causes a state transition for gas but it is doable so it is something that we could do it's just not optimized for that fact so base layers like Celestia that do this are they're not optimized for aggregation if we think about it we can we think about like how big of a Celestial block are we going to get it's like uh 134 megabytes is is within within our our range for like the next two years or something so if we if we have 134 megabytes and that's a block every 15 seconds that's half a gigabyte a minute okay so we have half a gigabyte how many transactions can you fit in half a gigabyte okay for each one of those transactions we don't have to execute it but we do we do have to execute a small portion of it on Celestia which is just to subtract gas for that transactions if if we use the Celestia as an aggregation layer as well as a consensus and data availability layer if we do that then I mean it's not really doable it ruins the scalability of Celestia if Celestia is also an aggregation layer along with a consensus and data availability layer so if we can pull the same trick that Celestia is doing where we continue we separate execution now we we separate execution from aggregation we separate execution from consensus and data availability execution is its own happy little space aggregation is also its happy own little space run by a middleware blockchain that is completely arbitrary you could have a single sequencer like enrollment currently or roll kit currently and it could run this thing you can run tendermint you can run an arbitrary consensus doesn't matter they all have their own trade-offs but uh Roll-Ups so that's that's kind of like what this point was uh for was for Roll-Ups should be able to pick many different types of aggregation if we rely only on the base layer to do aggregation for us I think this is kind of like what tezos is doing as far as I understand um then you can only have specific properties for aggregation as we'll discuss here in a second there are lazy Roll-Ups that require specific types of aggregation and you should be able to pick between the between whatever types of properties that you want we'll talk about soft execution later um you should be able to talk with you should be able to pick between different types of soft execution so ideally ideally in this Ideal World where I have a bunch or where we have a bunch of shared sequencers we would be able to pick between a lot of different ones so before we before we talk about shared sequences a little bit more um let's let's cover like the the overall architecture and overall diagram we can see here where as I've kind of alluded to where we have users of many different Roll-Ups can submit transactions directly to a shared aggregator which is just a middleware blockchain it's it's it's a dead simple blockchain um over the course of a week like uh during during the holiday break while I was at my family's house I would I coded one up so like it's not difficult to do to just build an okay one a middleware blockchain because again all we're doing is paying for gas and coming to consensus over some things some like soft consensus and then we we sort of batch all those user transactions into one and into a single state transition on the base layer in this case Celestia and so you can kind of see uh down here we have Celestia and up here is just the shared sequencer it's sort of it takes everyone's transactions and then it deploys it to the base layer in a single um thing uh one second Josh and then and then afterwards we have these things called lazy Roll-Ups where we actually generate the header afterwards so after the data has been published or finalized on the base layer we can download those transactions and we apply them to the state and then depending on a few other things that we'll talk about you you might do a few other things and then you also generate the header but I think that's like the minimum thing yes Josh Yeah question so the transactions at the very top of this diagram are those individual transactions that get sent to the shared sequencer and yeah matches from the roll up correct no no they're they're as so you have to modif depending on the shared sequencer you might have to modify a few different things but in the in the MVP that I had you added a single field and otherwise it was a completely normal transaction as if you were signing it from metamask or Kepler sweet thank you yeah so that is this is the this is the overall diagram you can explain most of it um just by looking at this diagram I also go into more details in the Forum post but paying for gas is one thing is basically really the only thing these shared sequencers have to do from a state perspective so whenever I submit a transaction to this shared sequencer it has to be able to parse that transaction and take the existing things already required for that transaction to be valid things like a signature things like a nonce and I think that's it maybe maybe some other things and subtract gas for that account so the the shared sequences sort of keeps an account of the lazy roll-up as well so like that same address has a whenever you sign a transaction it sort of keeps track of that account information as well as like almost an identical copy as what is kept on the execution layer an identical copy is on this shared sequencer aggregation layer and that's pretty much all that's required for gas you I in my MVP there's there's multiple different ways to do it but in the MVP that I wrote I just added like a little extra ID to a chain ID so it was I called it like a secondary chain ID so this this secondary chain ID was specific to the execution layer and then the primary chain ID was uh focused purely on the sequencer layer but again that's an implementation detail we don't have to get into that the other thing that you can do with a shared sequencer layer is you can inherit the fork Choice rule so in this case in you can depending on whatever the fork Choice rule is of the sequencer layer the execution layer can inherit that so instead of having something like what rolekit uses where you have like this well I mean you could if you have if you use real kit for your shared sequencer layer you can inherit that exact same that exact same for Choice rule if you use tender mint then you can inherit that for choice for all which requires just checking a bunch of signatures and allowing like it's basically the four Choice rule is whatever the committee says is of is the fort I can pick that so so it that's depending that's like a sort of like another trade-off space that you can explore using a shared sequencer is different types of fork Choice rules and whatever different applications um can be built using using those specific four Choice rules another thing that you can do is atomic inclusion of transactions so you can provide very strong guarantees that a transaction will be included in both Roll-Ups so if I I can submit a transaction to the base layer to the aggregation layer the aggregation layer can say can can parse that transaction it actually consists of two different roll-up transactions and that I only get to include one transaction if I'm also including the other transaction so this is a rather trivial feat because the cosmos SDK already has functionality for this and you can that's like a very powerful primitive that has yet to really be explored but you can kind of think about it like you don't have you don't have guaranteed that those transactions get executed and you don't know the result of those transactions yet but you can provide guarantees that those transactions do actually get included so maybe for Mev that would be really useful I only want to do something on this chain if it also occurs on this chain or there's a good probability of it occurring on this chain in the way that I think or for bridging perhaps I don't really want to execute a transaction on this chain unless also a transaction gets executed on the other chain or is included there's also an opportunity for it to get include so again it's not quite as strong as having a guarantees about execution as if it was executed on the same chain but it's sort of a weaker guarantee that I think is also still very useful you can swap shared sequencer sets so ideally ideally I'm hoping that if this if this architecture is actually useful that we end up using it that people build a lot of different versions there's there's a huge design space I think for something like a shared sequencer we were talking about four Choice rules we were talking like later we'll talk about soft execution you can um transaction pre-processing how you wrap transactions if you have Atomic inclusion you can you can there's there's just a huge number of different things that you can change and importantly also I don't think we've discussed Mev yet but if this shared sequencer set isn't your liking in that it's taking it's extracting too much value this shared sequencer set doesn't do much they don't have a lot of state and if things that don't have a lot of state are easy to hard Fork so either week like if I'm a roll-up and some shared sequences are set it I feel like they're extracting too much value for me I could hard Fork that shared sequencer set and move to an identical different shared sequencer or I could just simply swap to a different shared sequencer assuming that there's a lot of competition which I hope that there will be considering that again shared sequences do not do much in this architecture so yeah Mev Mev you are ordering transactions now I think it's important to note that a shared sequencer is maybe slightly different from a shared aggregator depending on your definitions of course but there's nothing really that inherently says that a execution layer has to execute the transactions in the exact order that's determined by the shared sequencer so the shared sequencer takes users transactions it bundles them up and it posts them on slash chat and then they get executed after the fact and when they get executed after the fact you can just change the ordering around what you can't do is you is you can't like exclude certain well maybe you could maybe you could come up with a way that for you have a certain block validity rule where we of a transactions of a certain type we we get rid of them but but there's nothing that's stopping you from doing a sort of second round of processing on those transactions that fit your need and but you can still have if you wanted to if you wanted to and you wanted to have the fork Choice rule you wanted to inherit the four Choice Rule and you want sex soft execution which again we'll talk later about then the shared sequencers can do quite a bit of Mev because then they at that point then they are ordering transactions and this is kind of where the again like the the last slide when we were talking about how you were able to swap different shared sequencers that's very important when it comes to Mev I think uh we we talk a lot about all of these preventions with Mev like we want to have a shared sequence like we want to encrypt the mempool somehow using threshold encryption and that might very well work and be a really good solution that people like um that's another like trade-off space that you could explore with a shared sequencer you could have a shared sequencer that has a threshold encrypted mempool um but another solution is to have a lot of competition is to not just have one that can exploit everything and sort of have it as everything locked in but you have many many different shared sequences and if one shared sequencer is doing too much Mev that you feel is too extractive or is it returning enough value to you then you can just switch to another one they don't do that much another useful thing is that you have a shared mental like if you were with the call with column was that uh as we found out mimples use a lot of bandwidth and it's something that increases the resource costs for your node for all of your roll-up full nodes and it's also some engineering overhead you have to have the expertise to implement such a thing if you use a shared sequencer set that's not the case you don't have to you could have your own mental if you felt like it for your specific roll-up or you can just use the mempool of the shared sequencer which is already running for you that sounds pretty cool it's not a universal fit for all Roll-Ups that's for sure the main thing is because this uses a model that's similar to how deferred execution Works in tenement you have a lot of the same drawbacks meaning that I can't process the transactions beforehand before I'm producing a block I cannot process the transactions in a way that requires access to state for example I could not pre-execute the transactions and remove any transactions that are going to get reverted or or are invalid in any way my state machine has to have a way to handle that instead so it's possible to have invalid transactions in your block that all lazy Roll-Ups have to have that functionality where Roll-Ups that um do the normal mechanism of creating blocks with immediate execution they don't have that limitation this is very different from SWAT I've heard so many people on uh just a few people on Twitter or on telegram or something say that this is very similar to Suave it kind of is because technically they have a shared sequencer that's like basically the name and I feel like that whenever they're reading that name they're sort of just bundling the two together when actually they're very different so the architecture that I'm describing actually provides like very strong guarantees for things like transaction inclusion Mutual transaction inclusion you inherit the four Choice rule or you have at least have the option to inherit the four Choice rule of the shared sequencer that's a strong guarantee as far as I understand from Suave so it's not it's not specced out really and I haven't seen any implementation with with Suave so this is flashbot swap they they just they want to sort of have a shared sequencer across like arbitrum optimism the block producers on ethereum and things like that well as far as I understand like ethereum's not changing there for Choice rule to incorporate Suave same thing with arbitrum and optimism those are not lazy Roll-Ups those are those use immediate execution so if you don't have those properties you can't have the strong guarantees that are provided using this architecture so it's not the same you do not have the same guarantees you cannot guarantee that something gets included uh you can't do soft execution you don't have nearly the strong guarantees for execution which again I've mentioned that so many times I probably should have moved that up in the order in the slides I didn't have the most time to prepare for this for this talk but anyway anyway it's very different from Suave um so I that's why uh like I said in the first slide that's why I gave it a cute name again with Metro I didn't really doesn't need a cute game it's not that unique of an idea but it is very different from Suave okay so so before we get into lazy execution I wanted or lazy Roll-Ups I wanted to go over sort of the thinking behind them and this is deferred execution or this is extremely similar to what Mustafa has described as a pessimistic Roll-Up so a lazy roll-up very simply is or where you can cover immediate execution we we sort of touched on this a little bit earlier you sort of have your transactions you execute them and then you include the result of the execution of those transactions in the same block so you have right here you execute you include the commitment to the state in the first block and then in the second block you do the same thing but before you before you move from one block to the next whatever consensus mechanism you're using likely has some sort of comparison between the commitments uh sure okay so with deferred execution we have we don't actually generate the state route on for for that block so we have our transactions for the first block and um we have our consensus mechanism and we come to agreement on the the blocks but that's it we don't actually compare State routes this is what tinderman does and Celestia and um we we we actually wait until the second block and then in the second block we have our commitment that we we sort of generate at some arbitrary time so we come to consensus quickly and then sort of in the background in theory you can you can execute your transactions and then on the second block you have a commitment to your state I think originally this was this was implemented in tenement as a optimization so you can kind of think about this as like at a grocery store instead of queuing up at the end where you go grab your groceries then you all get in a queue and you you scan all your items and you check if you have enough money and then you stick all the groceries in your cart and then you go that is immediate execution but if you had deferred execution it's sort of leaving that queuing up part scanning everything seeing how much you owe and seeing if you have enough money for the items you do that later so this would be like I run in the grocery store I'd stick everything that I need in my cart and I just leave and sometime before I get from the grocery store to my house then the the items that I don't have enough money for sort of just evaporate Into Thin Air that's deferred execution so it's an interesting idea and if you if you take that idea but instead of actually including the state route like uh remember what we discussed with the roll-up Roll-Ups have this uh the the great property that you can actually prove that the state route is actually correct and you don't have to have like some economic crypto economic committee sign over it instead instead you you can just prove that very fraud proofs or validity improves or just execute yourself in a pessimistic role and and lazy execution will or lazy yeah lazy execution is basically just that it's it's basically extremely similar to deferred execution where we agree upon the transactions ahead of time and then we execute them later in this case we are not actually agreeing upon the transactions that's being done for us that's being done by Celestia and then it's being done at the final form by Celestia but before Celestia it's actually being done by this shared aggregator but anyway that that is a lazy lazy Roll-Ups in a single diagram is they just download block data they apply them to the states they update their state and then they create a header and then in that header when they create it when they create that header you have some sort of mechanism I you will likely have some sort of mechanism for proving the state whether that be you have a committee that signs things for an optimistic roll-up that this committee has anyone who who has enough funds is allowed in a committee and um they sign a header that says a certain State Route and if the state if you have a valid fraud proof to the state route then they get slashed you could that could be one thing for an optimistic rollout or with the ZK roll-up it's incredibly easy is uh you execute the transactions you credit not incredibly easy implementation detail um you're you have a you have a a circuit that can be approved for for all of your execution and you you create a a ZK proof and you include that in your header and and now you have a a ZK lazy robot so lazy rollups along with the shared aggregator have a very interesting value proposition I think because they have some similarities to Smart contracts that other Roll-Ups don't mainly that you can inherit that decentralize it the decentralized block production of some other committee so like in an L1 smart contract I can I post my smart contract and then now that smart contract is uh uh I have the censorship resistance and I have the liveness properties of whatever that L1 is and with the role that's not the case because with the roll-up you have a separate block producer or a separate set of block producers but with a lazy roll-up with a lazy roll-up you do inherit the censorship and liveness properties not of executing the state but of creating blocks which I think I think is an interesting an interesting trade uh trade-off space and uh you still have all the other benefits of being a roll-up you're completely Sovereign you'd have no shared state and you have completely custom execution environments you can hard Fork Etc also you don't have any aggregation logic so Mo as it turns out if you went in the cosmos SDK now and you go and look at the sort of standard modules most of them have to do with the staking module and incentivizing the staking module so you don't actually have to have that logic anymore because that's handled for you by the aggregation layer which dramatically decreases the scope of your state machine not only that is that it also makes it easier to adopt execution layers existing execution layers in theory in theory because now now the problem of taking an existing execution layer like for example Geth if I wanted to take go ethereum and and make it into a lazy pessimistic roll up I don't really have to have this aggregation logic this aggregation logic's already been done for me they're they're checking it's performing some basic checks on the transactions they're included in the block and now I now I have my blog all I have to do is download the transactions apply them to the evm and then create the header and gossip header and and everything else around that ecosystem feels a lot of the same so like in theory you could use a lot of the existing infrastructure the native implementations of this infrastructure meaning like made a mask turbo sync the Mev infrastructure all of that stuff you could use in a very native well maybe not the Mev infrastructure but a lot of other things you can use in a very in a in a very native way so again this is unproven I haven't actually tried this this is in theory might not be true take it with a grain of salt what does deploying a lazy roll-up look like so it's actually really easy it's kind of miraculous in that you just sort of pick a chain ID and you pick a Genesis State and you pick an execution layer so you just pick these things and then you also pick a shared sequencer set and now you're done like there's some there's some implementation details in there but that's essentially it is is those are the most important things and now you have a lazy Roll-Up you just have to your users just start using it they just start submitting transactions to this specific chain ID to a specific shared sequencer set and now the transactions are already like coming we already have some ordering mechanisms to come to consensus over these setups transactions they're already being made available by Celestia and then we just download them we apply them to the state and we update and we have our header and we gossip our head over do whatever the hell we want to do with that header the deployment is arguably arguably actually I won't say that um I was going to say that arguably it's easier than deploying a set of smart contracts maybe maybe that's stretching it a bit but you know it's it's still it's not it's it's definitely extremely easy it's certainly easier than spinning up your own committee to produce blocks that's for sure okay now we finally get to select execution okay so a great ux has near instant gratification I stole this light from my previous presentation extremely high confidence of finality and rare downtime you can do that um you have to have some form of consensus if you want a good ux the reason for that is if you don't and you completely rely on Celestia's consensus now if for whatever reason you don't get to update your block in Celestia there's no soft promises that have any that can guarantee order in any way shape or form you have to have some form of consensus so that you can post your roll-up blocks in batches to Celestia if you have the ability to post your roll-up blocks and batches you can have a good ux now you can post your role at blocks and batches perfectly fine if you have a single sequencer that's easy but if you want to centralize sequencing and you want a good ux now you have to have some form of consensus you don't have to have bft consensus you just have to have some form of consensus and that form of consensus that you have determines the sort of level of of promises that you can actually provide for those soft commitments so in in this shared sequencer model architecture thing you could do this really easily you just have your shared sequencer produce blocks faster than Celestia and it's almost that simple you as you produce your aggregation layer blocks so let's say you produce those once every two seconds or so every time you you essentially just download the relevant transactions each time that's a block and you apply them to the state prematurely so it's not final yet it's not final until you get down here until it gets posted on Celestia but as soon as you can check the proof that it is included in Celestia you finalize it there are other transactions are already executed you're prematurely executed them and as soon as Celestia finalizes a block you already have everything downloaded you already have everything applied you execute you down you move on and now and now you can you you sort of have like this this window of soft execution soft commitments and again depending on the four Choice World depending on the shared sequencer that sort of determines how good those soft commitments actually are the centralized sequencing and outstanding ux yes we already covered that um okay so this is this this entire this entire scheme is all plot to make blockchains cute and tiny again this entire thing because because I wanted to like like using an architecture like this lets you get rid of the aggregation logic it lets you still have decentralized sequencing it lets you have this this this like really simple thing and you can sort of isolate your state machine you can have your state machine smaller and smaller and because the overhead to deploying a decentralized roll-up is smaller and you can use this lazy mechanism you can have an even smaller State machine so that's kind of the goal here too is to have a small state machine as possible in certain use cases again this is this is a huge trade-off space this is not a universal thing that you could do but but sort of the idea is to have again I'm bad at I gave it a cute name it probably doesn't deserve a cute name it's not that unique or different of an idea but you have instance specific blockchains so instead of having an app specific chain which would be like the equivalent of GitHub or if this was a DEX this would be like osmosis where you have a single app chain with many different amms or many different order books or something like GitHub where it has many different GitHub repos on it if you had an instant specific chain you would have just have a single amm or a single order book or a single git repo and then this sort of enables for sort of like this weird arbitrary like again I haven't really thought about it that much or have like a lot of like fleshed out ideas on it but you can have like this like arbitrary sharding where you sort of just pay attention to the state that you want and again I haven't really thought about it that much it might be a terrible idea it might not even be possible um but but maybe there's something that you could do there where now now that the the state machine is extremely isolated to what you want it to to the bare minimum of what it needs to be able to do and then you can sort of have like these cool ideas where where now use in similar to like a normal database schema it's like I design a schema for a few different databases to optimize for a specific thing like if I wanted to optimize for querying like query speeds for specific things and I do that if I want to optimize for handling tons of data because I'm trying to train a machine learning algorithm then I optimize my schema for that and similar to this now you can optimize your schemas for proving so for things that could be proved with the ZK roll-up with the validity proof you you have those isolated away for example if you just wanted to have uh being able to send funds across and then you have um some more elaborate things that I have an optimistic roll-up proving mechanism and then you have other things that are just committee based and you can maybe somewhere sort of mix and match I'm not entirely sure but but who knows so I'm not sure I hope I covered some of these things like I said I didn't have the most time to prepare for this talk because we're busy with other things um but I did write a forum post which again I'm uh I didn't have the most time to write the foreign post either uh but but so my ideas might not be the most fluent and they might be a bit scatterbrained so I apologize but if you have any questions let's answer those now foreign Gabriel I have a question about optimistic rollups I I don't understand the the case where fraud happens who does the front and who am I bringing it to well in an optimistic roller case so if you had a lazy optimistic growing up let's say that you you download some transactions you apply them to the state and now you have to generate the header so this is when you have a different committee so someone in theory I mean they don't have to have a bond but you probably want them to have bond to prevent spam someone who has funds up um they sign the header and they include a state route and at this point yeah at this point it's like a normal optimistic roll-up someone signed the header and some and that person has funds and I'm aware of who's in that committee so as a light client so then I can check I can say like oh does is this person actually have funds up should I should I listen to them at all um yeah you can also get a little bit more creative with that as well that's just one one thing but this means I still have a the staking logic inside you would have different lines you would have different logic yes but but I I think it could be you don't have to have it would be similar it could be similar but um it could also be very different in that you don't necessarily have to keep track of who is whose turn it is to sign what that could be one thing or you could just have everyone sign and then you can sort of like if you want it if you if you wanted to get quite clever with it you could have multiple different people sign and then you can sort of aggregate those signatures so it's almost like a weird mix between a committee based signature thing and an optimistic Roll-Up why not um have another layer that just executes and signs the headers so we have a shared execution layer which just executes and yeah you can I think that's uh if you don't have an optimistic like you don't have fraud proofs or anything um I mean you can still enable thought Pros because no yeah yeah you can still enable fraud proofs but then then if you don't have like some sort of bonding mechanism or something then I think you can have fraud proof spam because it should cost something to sign yeah what I mean is this one execution layer would then have this staking module but all the Roll-Ups that use it don't need it exactly that's that's sort of um um referring to the cute and tiny blockchains and that you can have this arbitrary sharding like that you can have you can have an execution layer that executes this blockchain this blockchain this blockchain this blockchain they sign over it and they are accountable for fraud proofs for those blockchains yeah that could be interesting you can get really creative with it um I I'm I'm hopefully looking forward to to what people build with this and I also think that this makes it really simple and while we're talking about this with like ZK Roll-Ups of we we've talked a lot about like oh well we need to decentralize proving or we need to do this well if you have immediate execution where before the transactions are included on or the state diff is included on the base layer you have to verify SDK proof well if in this case instead of instead of posting State diffs WE Post transactions Which is less efficient from my state from this standpoint um from like a block space standpoint but at the same time we can also have anyone can generate a proof and include it in a header and gossip the header which is kind of cool hello hey um first off great presentation I love the graphics uh I have like a two-part sort of uh question first is would everything be in the same namespace like the aggregated together and I'd have different uh okay you you could you could do it either way I think doing it per like doing it per namespace is is is better because then you can have the like you're already going to have to add padding so that I can check for inclusion without downloading the whole block so you might as well just use a different namespace because that's what that does but maybe if you wanted to be denser or something you could you could not do that yeah I thought maybe it might be an optimized like the aggregate the optimizations from aggregation might be because if you make the blob size 16 shares instead of 13 shares um it all fits in and you don't have any padding and so that way you're like getting some sort of small grain um the other thing is do you think this is like software that the validators of Celestia could run yeah Services where like validators will have like opt-in like other software that they'll be running alongside their validator can you imagine this as well whether it be offering a service of like aggregating for you I hope so yeah I I hope I hope I hope we have every possible different combination of this and uh I think it is a perfect use case for using like any form of interchange security which could just be using the liquid sticking token as your bonding on four for the shared aggregators layer um like if you did that then that's the that's similar to like what uh it's like eigenalier-esque um yeah Gabriel let's talk about my question sorry okay sorry how calm did that did that answer your question yeah yeah okay cool oh yeah um what you could do to also pay for gas this may be used to solicit over yeah yeah if you if you if you have it that makes a lot simpler if you use a liquid staking derivative of Celestia as your native token pain for gas is is really trivial um because you're not you're not having to like convert between the two eigenous yeah yes let's do it yeah Jacob Jacob has a lot of good ideas around this I sort of uh have been brainstorming with Jacob on some of this stuff so I I really appreciated that Jacob had the idea that you could have you could have a shared aggregator that is an oracle as well so the the main reason being that like if you have an oracle usually you're just probably gonna have like some committee you have to you have to rely on some committee so it would be cool if this committee is also a blockchain because now you can you can hard Fork that blockchain and if social consensus deems it necessary you can hard fork and you can slash them if they are not producing an oracle as if they said that they were producing an Oracle and not only that is if you're already verifying that commit forward to verify the fork Choice rule right if you're using the fork Choice rule of a shared sequencer set that is just using something like tenement then you you are effectively also a like client to tournament all of your roll-up nodes are are to the shared sequencer set along with me and a like client to Celestia so you already have to verify this extra commit you might as well include some extra useful information there which could be an oracle so I could have a shared sequencer set then they are the Oracle for a specific price of something like the price of a hot dog and now I have a huge Myriad of Roll-Ups that depend on the price of a hot dog yes Gabriel so if there are anyone who wants to ask questions please um why couldn't uh roll up that has like a normal roll building with uh decentralized sequencer set can they also do soft execution uh commitments yeah totally yeah the the first presentation that I did with this was was just that I was using tenement to have this soft execution um and that that's actually whenever I was like like thought started but to think about this idea if you check the in that last presentation on like one of the last slides I posted that one of the things that I tried various different ways to so to post data so it was a just a normal tenderment committee and their producing blocks as happily as ever and then they post those blocks on Celestia but actually what you post can be different so are you posting the entire commit are you posting the header ahead of time or are you just posting the block data so I was thinking about what if you just posted block data and then you generate or gossip the headers afterwards okay and that's that's whenever I uh was started thinking about this idea why do you need tenderment for that you don't you don't sir I was just transactions and post the soft commitment yeah you you could do that you could do it with a single sequencer you do not need tenement tenement's just like a battle tested way to do this it's Overkill you have to do bft consensus when there's no reason to there's no reason to do bft consensus it's a complete waste it's also already implemented and I don't know like I can just go play around with it right now and it's battle tested so like that was just the that was the entire reasoning behind using tender mint um it would be cooler like you create a fork of tenement and you remove pre-votes because again you don't really need it's I think it's still bft but it's just you need a much higher percentage of the voting power in order for it to be bft um maybe you can you can lower the percentage because again you're not really relying on this committee for safety you're not relied they can't steal funds the only thing they can do is not produce a block or or or give you a bad soft commitment um which if that happens it's not the end of the world um so you really don't need bft consensus you can use all sorts of things yep um another idea that I had what I talked I was thinking about is that you could have a promise by the celestial validators where the aggregated block has a promise that it is included from The Selective validator which then like makes the guarantees of the soft commitment even bigger so the Aggregates block grows while it is constructed in a sense that you don't aggregate Aggregate and then send the big block you can aggregate have a small block which already gets gossip to the mempool and then another like the block gets bigger and you send the rest of the transactions which increase the block and just cancel the smaller block and for the first block you will get a soft commitment a promise from the validator setup yeah I think that's certainly one way to do it um I'm not I'm not entirely sh it sounds similar but you somehow are incorporating hmm yeah I'd have to think about it more it it sounds like it definitely sounds like one way to do it and there might be like a different trade-off space there there probably is um so that would that would definitely be interesting I think this was just an addition to this idea oh okay okay yeah yeah yeah just like get more like a promise that is included yeah but um as we're as we're coming to the end of this call um kind of like what I was hinting at at the beginning is is like many of us I sort of just find myself asking like how would I build a roll-up and this is basically just how I would build a robot and sort of the things that I've been thinking about to sort of go in that direction and if like I there's obviously more important things to build right now um Celestia mainnet and getting to 134 megabyte blocks but after that maybe we could maybe think about uh heading in this direction or again like like the the base implementation of this is really easy having a really it's almost like uh the analogy of or metaphor or whatever of of playing guitar it's like really easy to pick up playing a guitar but then to become like really good at playing the guitar is like the huge gap and it's very similar it's like creating an okay version of this doesn't take much work it's really simple you use existing tools but then like creating like an amazing version of this where you're like what Colin mentioned in the chat where you you just use raft consensus so you use you use something else and you use uh uh or or you use tender mitt without pre-votes or you use some other mechanism you include all this Mev architecture all these other like random stuff then that that part takes takes more time that's kind of why I was hoping for other people to build it because I didn't want to build it but I do want I do eventually like when we build Roll-Ups this is this is how I build develops 