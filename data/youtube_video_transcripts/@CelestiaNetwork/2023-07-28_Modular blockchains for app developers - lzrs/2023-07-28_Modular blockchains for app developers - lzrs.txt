hey everybody thank you for coming yeah my talk was originally called the economics of modular blockchains but I realized that that was a very broad topic and it'd have to cover a lot of breadth and not go very deep on any specific issues so I thought I'd kind of apply some of the principles I was thinking about in that original topic towards answering a very practical question that I think that the industry needs and and what I want to answer is if somebody is an app developer meaning they're building software for users that serves a purpose why should they consider to include modular blockchains in their Tech stack Choice um and before I before I answer that and go into this I do want to introduce myself I'm lzrs I'm the founder of modular Cloud we make um we have a cloud infrastructure for modular blockchains and I am on a panel in about an hour from now and I encourage you all to attend and we're going to talk more about the specifics of those services that we provide more in depth in that presentation so okay now on to why should people use modular blockchains for their apps so here's the common Narrative of why somebody would want to use or what like what how a blockchain Works essentially um there's a user and this user you know creates a transaction and they they securely send this transaction to some sort of decentralized network and once this transaction is off into the internet on this decentralized network there's this group of nodes that come to consensus and they verify that this transaction is is valid and update the state and its broadcasts and finalized and sent out to everyone in the world um now I think that this is like a common explanation but I don't think that there's some parts of this type of common conception that I don't like and the the one I want to highlight right now is that I don't like that um it when people skip when they say okay the user uses the blockchain because I think that really takes out a really important point and a part of the equation and um in doing so it kind of makes people that are building apps not really understand where they fit into the picture because the real the reality of the situation is that the user is not using the blockchain they're using a device like a phone or a computer and on that is some code that's run that's written by some sort of third party like probably like it's some sort of project which that is the app and the developers that are building that app are integrating with the apis and sdks provided by the blockchain so the app developer in a sense is the true consumer of the blockchain and I think like as we go on over time um it's gonna we're gonna transition more from everything being where we tell people like okay this is a crypto app this is a blockchain app and a lot of stuff will be going on behind the scenes once developers realize the power that blockchains can provide them just as a technology in their technology stack so okay so imagine you're an alien and you're like coming to Earth you have no context about this and you look at these two apps these are undeniably apps they're both on the Android play store so you can install these apps on your phone these are apps these are not blockchains they're not decentralized networks right there's a venmo app and and the Bitcoin mycelium Bitcoin wallet um now what's the why would ask what's the difference I mean you can say there's a different UI different name stuff like that but um by the way oh I'm sorry I thought the time was frozen but it was actually moving um never mind um anyway um so I'm trying to be mindful of my time anyway um so if you compare these apps um like they both connect to the internet um one of them you could say connects to the Bitcoin Network the other one connects to venmo's servers um but that in and of itself is not a particularly meaningful distinction um what I would say is the difference between these two is that the Bitcoin wallet is actually not only retrieving the some data from the network but it's also doing some sort of verification on that data and um so um like in the way that it does this is it connects to this very powerful API that you can call the Bitcoin node RPC and what I want to do is I want to in this talk propose an abstraction that we can use when we think about talking to rpcs and this is going to apply to all blockchains not just Bitcoin I'm starting with Bitcoin because it's a very simple case it's a it's an app it's basically an app chain for payments and over time we've modulized these and expanded the scope of the well that these protocols can do but this is going to be an easier case to explain so I have this abstraction that I'm going to present to you called a cost function and this is how I think that app developers should be conceptualizing blockchains like they shouldn't be thinking about the internals of the peer-to-peer networking and cryptography I mean it's important context you need to be aware of that but it's not the fundamental thing that you should think about when you're considering how or if you should integrate a blockchain into your app so what is a cost function a cost function is essentially um it's if you've given a statement it's the the cost that that the person making that statement would incur if they were to commit fraud so in the case of Bitcoin this is a very this has a very narrow capability so if someone says I sent you five Bitcoin and I'm going to be very much abstracting this process I'm not talking about actually how this works this is a very high level description of this process but if someone says I sent you five Bitcoin you wouldn't want to necessarily trust that that's true and like do something irreversible like sell your kidney uh just trusting that it's true they could be committing fraud in the the difference between something like the venmo and Bitcoin both are hard to commit fraud on but if you use venmo you don't actually have the information for how much it would cost to commit that fraud so probably you'd probably be fine with venomo but there are situations where having that additional information would be good so in this case this person claims to have sent five Bitcoin to this person in exchange for some some you know some service or goods and this person realizes that the cost to commit fraud in this scenario is lower than the value of the transaction and now they can make a risk assessment and they can model the risk based on their use case on how confident they are and how they want to interpret that data um between the two but I think that they're actually connected at the last modular Summit I gave a talk on the subject I encourage you to check it out if you're interested in learning more about that but I'm not going to talk about that here um so okay so how does how does the cost function work essentially um you like you start off by having this assumption that you have access to the open internet and you through accessing a peer-to-peer Network you're able to scan and get you know all the possible change or maybe not all the possible chains but among the chains that you can find when you scan the internet is the one that you are looking for which would be called the canonical chain it would be like for example the longest Bitcoin chain with the highest difficulty that would be the canonical Bitcoin chain and what happens is you retrieve data from the network and then you apply a rule set to actually determine which of these potential canonical chains is the canonical chain because you can't of course trust anything you hear on the internet just because someone says this is Bitcoin doesn't mean that it's true so the way that this works is you can break this down into two pieces first is validity and the second is a fork choice so if you think of all these things as just Rob bites like just blobs binary data you will parse that and you'll check if the structure of that data follows the rules of the protocol that would be checking the validity and then even if you have 10 chains maybe there's eight of them are valid and two of them are invalid you still have to decide which one is the canonical chain so a fork Choice rule will take two potential chains A and B and it will turn either chain a or chain B depending on which one it prefers and if you go through all possible chains that are presented to you from the network with this connectivity assumption assuming that you're connected to the internet you should have by the end of it the preferred chain out of the whole list will be the canonical chain and so how this plays into the cost function is that there's this thing I don't really know what I what we should call it but maybe we can call it like security units once you you know have this data and you are um you're able to and you know what the canonical chain is now you can actually statically analyze those that that binary and you can determine what would be the security units that it would take if someone had these security units in an abstract sense could they commit fraud into the system so let's go through a concrete example of this so in the what we're talking about Bitcoin um it's proof of work so you there's a certain hash rate and if you so that like a hash rate would be a unit perhaps and um if you had enough hash rate you could do a 51 attack and now in and of itself that's not actually that useful because how do you know like how hard it is to do that hash rate maybe you can use your laptop or something and and you know commit fraud um so you there's another assumption that goes along with um this this assumption that you have access to the open internet and that's access to Market data I mean this is not built into the Proto article so it can be kind of counter-intuitive that but but this is actually really key to properly utilizing blockchains and so with this Market data basically what you want is the cost of the hash power so in this case essentially I don't actually know how people really calculate this but I assume it's basically like the electricity costs and maybe something to do with like Hardware but there is a way that you can model the cost of getting the hash rate that you need to commit fraud and from that this is what you would have as the cost function and you can now say based on this statement that I'm verifying how expensive would it be to you know commit fraud in this case and then now I can determine based on the circumstances for my application how I want to interpret what is on the blockchain um so and then of course like who uses proof of work anymore I guess right so I mean proof of stake is exactly the same thing it's like you have your tokens that can be slashed and there's a price of a token you have access to Market data you can do the same exact thing it works the same way um and so I'm not going to go into this connectivity assumptions but I do think that this is one area that really does Chip people up because there is an assumption when you're using blockchains that you have access to the open internet and if you don't actually a lot of things break down I think when a lot of people think about it they just look internally into how the protocol works and sometimes not all the answers are there and so that might be a disconnect why some people don't understand the value prop of crypto but I'm not going to go into this because we just don't have time um but I do want to talk a little bit more about selecting the canonical change just to be a little bit more clear about how this works essentially you're getting all the chains um this is the pseudo code you're filtering out the valid one so now you have a list of valid chains and now you're just literally running a reduce of the fork Choice rule on all the valid chains um but what's interesting is you can actually collapse this down and you can combine validity into the fork truth rule itself um and it could it would look something along these lines where instead of a function that takes a and b as an input and returns either A or B depending on which one is preferred you also can return like a nil value if both chains are not valid so you're just both basically checking the validity at the same time as determining what is your preferred fork and so um this is actually I would argue like the most con the most concise abstraction on for how a blockchain like what is the blockchain like all this other stuff is implementation details like are you using proof of work or proof of stake do you have like Merkel trees like a lot of these things are like just it's it's to achieve this but this is the actual conceptual um like the essence of what we're actually working with here and the but the thing is though is again I want to reiterate that the four Choice rule by itself is not really useful because you're like okay this is the valid chain but look what's the implication of that right you need to have what I call this like broader thing which is like this cost function to understand how like what does it mean like when you when something is when you find data in this chain what is the like what kind of guarantees can you expect from and like how expensive would it be like how much can you trust this data essentially um so I want to like I want to now build up from Bitcoin to modular blockchain so we can see how this all ties together um so um okay so Bitcoin had two problems and I wanna I wanna Focus mostly on this first one and essentially the problem with Bitcoin is that it's hard to engage in Commerce with Bitcoin and one reason for that uh is of course you have to get a bunch of people to get Bitcoin wallets you have to get businesses to you know put their payroll or their point of sale system on bitcoin that's all very hard and we've made very little progress on doing that um but there's also kind of a more fundamental reason why it's hard and that's because um it's really hard to bridge on chain and off chain events um and like the people working in real world assets and like dealing with oracles and stuff they they face this all the time and I won't go into the because we just don't have time I won't go into the theoretical reasons why but I think there are some interesting things uh for why this is true but I'll give you an example to make this more concrete so like this was the example we went um so like someone was going to sell their kidney or something um and um this person claimed to send them five Bitcoin but really did not and um they were able to not trust that because they could calculate whether that it was likely that they could be profiting by committing fraud in this scenario um now this works in this narrowly defined scope of saying I sent you five Bitcoin in the the because because essentially like that's what the Bitcoin app does it's a payments app um and the um so the the cost function can let you verify that this the the cost of how much it it takes to commit fraud in this case but it can't do other things like for example if they claim to have provided the service um you wouldn't be able to verify that that actually happened you'd have to introduce some sort of Oracle and then that introduces additional risk into the system and you know all this kind of risk the more risk that you introduce in the system the more you have to have a margin of error on anything that you're calculating and eventually if you have enough error that's going to all compound and it's going to be a a useless value so you want to constrain any of those things you want to have as much to be directly verifiable by the cost function as possible and so um the way there is a way that Bitcoin could have addressed this and expanded the functionality if they wanted to and I'm not saying that they should have I'm just saying they could have and the way to do this would be to hard fork and add more op codes and increase the power of their of their scripting um to you know do the other things um to do other things that people want to do and the more things that you'd want to do the the more think the more different types of statements you'd be able to verify with this cost function and understand you know you understand the context around how expensive it would be to commit fraud in these scenarios and um so but they didn't do this and why did they not do this I think this is a really important point I actually think it's exactly what you would expect um so there's this thing called Brook's law and it talks about how you add Engineers to a project and it it makes it harder to actually complete the project because essentially as you add more people the lines of communication increase combinatorially so what this means is as you add more people to a group the communication overhead gets way more and more and more difficult and and the implication of this is at a global scale you really can't coordinate it's not possible it's prohibited and that's why you know these permissionless networks are really great because you actually don't have the coordinate and I'm not going to go into this but I do want to say like this this idea that you know Bitcoin or that blockchains you know allow people to reach consensus I think is not a good way of all of looking at about it I think blockchains allow people to verify things and calculate the probability of fraud but they actually work because you can't come to consensus like for example a 51 attack or a 66 attack like these would require consensus among the participants of the network and the fact that those don't happen because that's very hard and very expensive is the reason that this works so we're actually playing off the fact that you can't reach consensus it's kind of a it's maybe not important but I just thought it was worth mentioning um and so essentially it makes sense that Bitcoin wouldn't be able to upgrade because everyone's verifying their own thing independently for their own purpose and you'd have to get the people sending it to upgrade and the people receiving it to upgrade because you want to be sending with someone's trying to receive and receiving what someone's trying to send and it's very hard to do so um if ethereum fixed actually fixed this problem though because what they did is they modulized the application logic of Bitcoin and so um like I if you remember I'm not going to go back a bunch of slides but I had this diagram where it showed that the cost function or where the canonical chain is determined by the validity rules and the fork Choice rule um well essentially what ethereum did is they modularized the validity rules and so you're able to essentially do something like this which is where you can make a statement like I did X according to module Y and that module y would be a modular validity rule set that can be loaded all onto the same blockchain but the thing is is since this is modular you don't actually have to you know Fork the network and you reach consensus with the entire developer community and all the users that are verifying the chain so this allows people to build this stuff and use it in a modular context without the coordination overhead so allowing you to not just have a modular validity set or validity rules but also a modular Fork Choice rule so you're able to Define um so like if you think about like a roll up on Celestia for example essentially that roll-up has its own Fork Choice rule with its own validity rules and its own for choice but it also uses Celestia's for Choice rule as an input so it's not just a function that takes a or b it's a it's a higher order function that takes a b and another function which is a fork Choice Rule and so in in this kind of way you're able to get you you're able to import the the verification capabilities of other chains into your chain and that's what a roll-up essentially is in its Essence and so um like this allows you to express a greater number of um of things that can be verified and you can understand the the cost of fraud in these systems and so I'll just kind of go through this little three-dimensional diagram like initially we had like an app chain which was Bitcoin and you could just basically have different wallets and they're just verifying these very narrowly useful statements which is I sent you this many Bitcoins then we had ethereum that would allow for dapps and this had so many more use cases like nfts and D5 and stuff like this and there's a lot you can do with this but now what we're going to have is with modular blockchains we just kind of added this other dimension here since you can customize the the full Fork Choice rule you're actually able to even do more interesting types of things like for example you can customize you can like decrease the level of security and so that you can increase like performance as a result and you can verify things in you have more customizability in in actually setting the um the parameters for the use for detecting fraud in the use case that you are actually building for as an app developer um and so yeah I think that's my time so this is like a great place by the conclusion sliders here so um thank you everybody I appreciate you coming thank you Liam 