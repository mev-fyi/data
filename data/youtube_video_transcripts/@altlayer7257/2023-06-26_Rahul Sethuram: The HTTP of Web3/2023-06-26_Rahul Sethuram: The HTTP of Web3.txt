[Music] thank you [Music] hey there good morning everyone thank you all for being here and thank you guys for hosting me out there uh my name is Rahul I'm the co-founder of connects for those of you who have not experienced connects yet connects is a protocol that has been around for a really long time so the company actually started in 2017 when the crypto Market looked very different so we started out doing very different things uh always the focus was around building good secure scalable infrastructure with the end goal of onboarding more users onto web3 so really that has changed over the years to initially focus on scaling and now focus on interoperability an interesting thing is scaling and interoperability are really like two in the same thing because you know when you have scaling your offloading transactions to something else whether it's a secondary layer one or a layer two or a layer three or whatever but unless you have that interoperability the scaling actually doesn't do anything on its own so anyway the title of my talk is the HTTP of web3 and this kind of defines the future for connects as well as the interoperability space as we see it um so just to kind of take a step back here let's time travel a little bit back to the 1980s and see what the early stages of the internet looked like so back in the old days of the internet you had to do a lot of manual stuff and really like interact directly with infrastructure so you had to like know basically the subnet of some Network that you wanted to connect to use telnet to connect to a server then you had to like FTP some Storage off of it and it really was a very manual process that exposed a lot of these layers to the end user and this is because there was kind of a mishmash of different protocols and uh other kind of uh like a lot of other things that you had to kind of think about and do manually so then we fast forward to today so today it looks very different you have Rich interactions that you can do with very different pieces of infrastructure under the hood so let's say YouTube is an example YouTube uh will send Network requests to this very well-defined uh very robust networking stack and it will be able to query content from cdns and deliver that to a user it will be able to go to its storage locations uh and get data it will be able to query other servers through apis so the whole stack has been very much like abstracted well defined and uh it's very expressive and the reason for this is because of HTTP right HTTP is basically what made the web composable to some extent so bringing us to what the web 3 is like in the 2020s I don't mean to kind of pick on Ave here but if you go to something like Ave or basically any of the web 3 Taps that are pretty big right now uh have this this property where you have an app that is multi-chain deployed on many different chains Roll-Ups whatever and you have to manually interact you have to pick what kind of network you want to connect to then it's going to go to your wallet and it's going to tell your wallet you need to change to this network and you you have to kind of manage all that stuff so really this feels like you know dial up in the internet where we had to like manually turn on our internet and you know connect to some website by sshing into some server or something like that or using telnet or something so it's it's while it's very cool and there's very cool things we can do and we all love web3 this is this is definitely not the future this is not how things are going to look in the future and not to mention this case like all the liquidity is kind of fragmented you need to think about bridging funds from one chain to another chain if you want to use a product on that chain uh so then we fast forward to how things look today or sorry not how things look today about how things will look in the future um as all of us are here because of this roll up as a service day and all layers kind of uh pushing this this Vision uh I think we can all get on board with the fact that the main interaction that users will have in the future is with app specific layer threes so I I strongly I'm a believer that a lot of things will move to different siled layer threes where they can kind of control more mechanisms around things so you'll have like a swap layer three you'll have a landing layer three you know Uber and Airbnb or eventually are going to become peer-to-peer applications that live on their own layer threes and then you'll have storage and decentralized commute that compute that are also running is like decentralized services and our vision for the future is that all of these will be connected by an interoperability layer which will make these interactions extremely uh abstracted from the users themselves so then how do we get to this Vision really we need to Define this kind of interoperability layer as a modular layer that is fully specified and standardized so with this then we can really start to build the infrastructure that makes this type of stuff possible so let's go back to the internet and say how the networking stack looks in this modular Vision so the networking stack is already modular so you have a transport layer which is TCP you have a security layer which is TLS and then you have this application layer and this is important because the application layer is really what allows everything to be composable it allows developers to build new apps it allows content to kind of be linked to each other over the internet and it allows users to not have to deal with any of this they can just go into their browser and start browsing so then how do we translate this Vision back into interoperability and web3 in the blockchain so what we can do is we can kind of break the same uh the pieces down into like very similar looking pieces so what you have is you have a transport layer you have a verification layer and you have an execution mechanism built on top and let's dive in a little bit and explore what each of these layers do look like uh so the transport layer is the very base layer of this communication between different blockchains how do you bring a block header it can be any payload but let's just say it's block headers because as we'll go into later this is the most efficient way to transmit data from chain a to chain B you know this may seem easy in like an all evm world you just have some kind of relayer that's just like reading data from one chain and putting it on another chain however this will get more and more complicated one of the things I really believe is that a lot of these app specific layer 3s will end up moving away from evm into you know more highly customized different versions of VMS that are highly tuned and efficient for their own use cases so you know then you need these kind of adapters to basically bring this evm based process that we have right now to be able to be translated into any type of uh transportation so what I'm saying is we already have an extremely well specified and battle tested transport layer protocol it's called IBC so those of you who know IBC it's basically a cosmos based system for uh transporting messages and doing this whole process of Transport between different blockchains uh if you've looked into it it's extremely well specified it has multiple clients running it it's it's basically like extremely well documented and it's battle tested because it's being used across many different blockchains for a very very long time and that's what you need with these type of infrastructure projects so that's for the transport layer so then we move on to the verification layer so a verification layer works like how do you prove that something like whether it's a block header or something else is valid from chain a to chain B um so this can happen in a various number of ways uh the bottom line here is that verification mechanisms are going to be commoditized and be an Open Marketplace so this is going to be like uh basically an Open Marketplace where different actors can compete on speed cost and chain support and since basically if you if you boil us down to the fact that you're just sending block headers from one chain to another chain this is like a fixed piece of data so the cost is not going to scale with the amount of data that you're sending so it's really going to be kind of like a race to the bottom and an Open Marketplace and the the other thing to note here is that there's a lot of teams working on this right now there's a lot of really smart people who are trying to solve this problem of securely verifying data from one chain another chain using ZK proofs using light clients using message aggregation Etc and these people are very focused on the singular problem so they don't care about transport they don't care about execution all they care about is verifying that a piece of data from one chain is properly has Pro is like is valid and uh usable in other layers of the stack so then that brings us to execution so this is a very important piece of the puzzle I I do apologize because I had emojis and things that don't soon be showing up on this presentation some of these diagrams look a little weird um but you know I can I can point people to the slides later uh so anyway execution so after a block header we go through the transport process we go through the verification process now on chain B we have a block header that has been verified then how do you build Rich interactions on top of that so this is where we really get to the HTTP analogy because really like doing something with this block header and root is the hard part once you have this then you have a ton of infrastructure you need to build to actually like build apps build cross-chain interactions so truth is application developers don't want to deal with this lower level sub they don't want to submit proofs they don't want to read data things like that the the data cons yeah sorry so then like this is also where the costs in the flow are because when you're consuming this data cross chain you're actually like consuming a lot of data potentially because you're going to be sending like a big Merkel proof that needs to prove some kind of data and then building complex interactions on top so the bottom two layers do not really have much value where you know users are going to be paying a lot of fees or something like I said so that's why these are going to be really like highly commoditized and really like kind of race to the bottom but the application layer the execution layer this is where you kind of have a little more room for the flow and really execution is what brings us cross chain composability like without it you can only consume data across chains but really when you have this you can actually create applications build Rich interactions so like to bring it back to the web analogy the web is a graph of hyperlinks between content and it's independent of the links under the hood and that's really where we need to get to with this with this uh blockchain as well so what we say is this exclusion layer is global State composability on The Interchange and what connects is trying to do here is we're trying to focus in and build a really well specified generalized extensible execution layer framework so then that breaks it up here a little bit so now at the transport layer you have teams that are specifically working on this exact problem like Cosmos is doing all the work around building the the base layer for uh the the specifications around IBC polymer is a team that we're in touch with that is building IBC everywhere basically so we want to let them focus on that problem and you know eventually like build a client client that will plug into that similarly on the execution layer uh you have these really great teams some which are mentioned here which are like I said laser focused on solving this one problem they don't care about anything else like we talk to a lot of these teams they're not trying to build like full Bridge functionality they just want to build this verification mechanisms that allow you to move things from one chain to another chain and prove them very specifically on on the destination side so at the execution layer this is what we are focused on it connects we want to focus on building the ability for developers to interact with verified cross-chain uh mechanisms and you know if you look if you look at this from the big picture you'll see that a lot of bridges are trying to build this entire stack so obviously if you try to focus on too many things at once you're going to end up like compromising on things and not really being able to develop deliver the entire solution to users so that's why we're really trying to laser focus on this one part of the stack which is the execution layer so then when you have an execution layer what are the things that you can do with it so this is the most basic uh use case of an execution layer or of the execution layer is to do a write and I'll call this a slow right right now and you'll see why later so what you can do is a user can make an X call which is a call that is meant to go cross chain from chain a to chain B and this assumes that the block header has already been sent to chain B so after some time of making this x call this block header gets packaged up it gets sent to chain B through the various transport verification mechanisms and then at some point in the future you have a root a block header that has been proven on chain B so then your execution layer mechanism will do all the computation to send a proof that the user's transaction is actually within that block header and then it will execute any type of data or or call or you know funds transfer or anything so the use cases for this are around things like secure cross chain messaging uh managing governance things like that things where you really need a very secure mechanism for sending messages across chain that may or may not include value so the next part of this is uh a fast execution mechanism so the reason I call this fast is because you have this verification process and this transport process which can be actually very slow because you know when you're dealing with this type of system there are going to be a lot of things that these Protocols are going to do to reduce their own costs because you know at the end of the day these are kind of like race to the bottom protocols that won't have much margin they might be even public goods so they're going to try to like reduce the cost as much as possible uh for that reason so what that involves is a lot of batching then you have these things like ZK proofs which might be really heavy and take a lot of time to run so at the end of the day you're gonna have to this process from sending a block header from chain a to chain B is definitely not going to be an instant process but something you can do is you can have something called a fast execution layer so what this is doing is this is listening for this event on chain a and because it sees the event on chain a it has a certain guarantee that's this block header will eventually be received on chain B so it knows at some point it can prove this so then what it can do is it can actually go up front and send a transaction on behalf of a user so let's use like an any to any swap for example so what that means is a user is going to maybe swap on chain a then then send the funds to chain B and then do another swap on chain B so what this fast execution layer can do is all is it can do the swap for the user and send the user directly the output of that Swap and then you know we'll have something in this execution mechanism to understand that this is what happened and then have this uh fast execution layer be able to claim the funds back after this block header has been proven so this is kind of like the use case where you get with many like cross chain bridging right now where you want your funds immediately you don't want to wait for some uh execution mechanism to happen so this is what enables that this is this is what enables an instant like really nice clean user experience so cross chain swaps like any any swaps are a really good example of this cross chain zaps you know fun movement and then the other interesting thing is you can also do things like verify signature so you know if you have a signature that can be verified from chain a then you don't need to wait for the block header because you can already see that that's going to happen and verify that on chain B without needing to wait for a block header so then the other really interesting mechanism is a read so say you have these block headers that are coming you know they'll be coming on like various intervals uh then you want to prove some data against that on chain a itself so really all you need to do this shouldn't be an X call this should be an X read so an X read is where you're just gonna still submit the same proof for a block header that you already have and prove that something has happened on chain B so say you have an oracle that's like updating price data every 30 minutes or whatever or every minute or however much they send their thing then you have all that information in a block header that has been sent so once that block header is received here then you know you can read it immediately and you can basically read data from any chain anything that has ever happened on that chain uh so other other ways this would be useful read gas price data read token voting power as well that's a cool one right because you can basically read what your uh ve token balance or whatever is at any kind of snapshot in time after you've received the root on the chain that you have your Dow on for example so yeah I've referred to this a few times but X call is basically how connects is envisioning this uh whole execution layer process starting so this is basically a primitive to facilitate asset and or data transfer across arbitrary chains so it's designed to mimic solidity's built-in call methods so what we want to do is we want to make the process for developers around making these really expressive cross-chain interactions extremely easy to build and since it mimics cilities built-in call method they don't really have to think about much or know much beyond what they already know in solidity and here is basically a a snapshot from the code about exactly how you would do an x-call so it's it's really simple as you can see the parameters are very straightforward you have uh some kind of fee that you pay to the relayers for sending this amount you have like a destination domain and Target uh token address uh you have some some safety fallback parameters around the message sender um the amount you're sending you know slippage because uh you know Bridges will have some kind of slippage and things like that and then you have call data so this is basically the bare minimum amount of parameters that you can have to be able to make really nice uh kind of cross-chain interactions so you know one thing I'll get at here is that specification and standardization is positive sum I think a lot of people a lot of companies might view this as you know eating into their bottom line or this kind of like goes against what normal companies want to do because Normal companies they want to control everything they want to you know close their apis if you look at like Google Twitter Facebook things like that like they're all charging for API access now because they're built like companies they want to make profit but if you look at what the end user wants the end user wants truly open apis where anybody can compete use the apis like if you look at the example of Reddit this is a great example right now so Reddit had all these different like clients and user interfaces built on top of it because it had an open API but now that it's shutting down its API it's been a huge backlash because you know a lot of these apps are being forced to shut down because they can't consume the apis right now so what I'm saying is that like we want to get to a world that connects where everything is specified everything is standardized this might make our own protocol like you know less profitable I guess you could say because it allows competitors to just come in and build multiple clients but that's not what we care about we care about making it a better place for the actual end users to interact and uh you know be in this world so you know just to reiterate that connects is not a company connects is a public good because we're building web 3 infrastructure it needs to be something that is given to the public it's given deployed and it is usable by anyone so it operates on the standardized playing field where anybody can come and operate and build tooling around it so you know I like to say this a lot but you know at connects we don't want to compare ourselves to Apple Google Etc like that we would rather hold ourselves to the bar that ethereum holds themselves to like ethereum is the ultimate vision of a public good that has been realized and you know if we could all be like ethereum I think we would all be pretty happy so you know just just to wrap up and recap here these are some thoughts that I want to give here so standardization at all layers of the stack encourages competition a race to the bottom which is better for users right so obviously if all the all the companies are competing in a perfectly free market they are going to always undercut each other until they're making the minimum amount of profit that just allows them to survive and that's how web3 is built web3 is built so that there's no middlemen there's no rent Seekers there's no people trying to like take a cut there shouldn't be any of these Cuts there should be you know zero fees zero like protocol fees should really be a race to the bottom and not even exist in a lot of projects right now I think there is protocol fees but you know that is something that is getting slowly undercut um then you know we need to break things down into modular pieces so modular pieces allow standard standardization specification and they allow like I was saying they allow the best teams to focus on specific parts of the stack and really kind of compete on cost and speed and what matters to them you know they get to focus on like one really small piece of the stack and really kind of build it out the best way they can they can possibly build it then execution application layers are what make protocols composable so this is where we want to focus on at connects this is how we want to be able to interact with developers interact with users and make uh end user interactions possible and good and then to end it all you know web3 infrastructure is a public good I strongly believe that these are not companies that are being built a lot of the other teams you know some of the other teams are definitely acting like companies trying to make profits trying to figure out how they can increase the revenue as much as possible but I strongly believe that web3 infrastructure at the end of the day is a public good and it needs to be compared to ethereum like I said ethereum is the ultimate public good and all of these companies should be striving to be more like that so thank you all that was the end of it and yep I will make this presentation available everywhere [Music] foreign 