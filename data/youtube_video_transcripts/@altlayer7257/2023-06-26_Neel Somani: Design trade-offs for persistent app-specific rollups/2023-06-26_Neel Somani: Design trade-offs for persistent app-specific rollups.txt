[Music] thank you [Music] hi my name is Neil and I'm the founder of eclipse so for this presentation I'm going to just go through one slide deck which basically explains some of the technical things that we think about at eclipse and how we're approaching them and then we're also going to get into what we think are ideal use cases for app specific persistent Roll-Ups such as what we're building at eclipse so I'm going to go ahead and pull up this deck here all right so uh this is a technical explainer so it assumes some knowledge of what Roll-Ups are and things like that so this gives a little bit of context on what were the scaling solutions that historically existed one being uh you have alt l1s like Solana you have uh what was previously Tara you have a bunch of near Aptos so these are all basically new layer one blockchains that do their own consensus and they also handle execution and other functions that a blockchain typically does uh and then you have in that same vein in the sense that they're trying to find a scalability solution uh that provides a general purpose chain for everyone you also have Roll-Ups or traditional Roll-Ups that's like Arbitron which is anchored directly to ethereum they have a canonical Bridge contract and then they do a bunch of execution execution off chain and eventually commit that result back to ethereum so these are shared chains uh and I group them together because you might think that it makes more sense to group the alt-l ones with app chains which I'll get into next and then Roll-Ups would be its own category but in our opinion the way that these are grouped and the reason why we've grouped them this one is because you have share chain which is inherently non-customizable but it's highly convenient and on the other hand you have an app chain which is extremely customized but in order to spin up like a Cosmos app chain or a polka dot parachain you have to typically in the case of Cosmos you have to bootstrap security meaning that you have to get a validator set you have to put up stake and in the end of the day your fixed cost for running this chain ends up being seven figures or more as opposed to using something like Solana or one of these shirt chains where your fixed cost is basically zero you don't have to run any activity if you don't want to but now you have this marginal cost which is whenever a user runs a transaction they have to pay some amount in rent so you're basically paying rent to this shared chain or you're trying to roll at your own and be a homeowner so the question is given that app chains gives so much more customizability they give a lot of dedicated throughput why did they not take off and our answer is that it really comes down to convenience and it's really difficult to spin up an app chain as it exists right now the other part of it is that you end up with security fragmentation and we'll get into that so these are the properties of Roll-Ups that we really like and we want to borrow that so that's what we're offering with the clips uh in the same way that alt later offers these temporary Roll-Ups which are intended as burst capacity Eclipse offers a permanent roll up and this is intended to be app specific we support some chains that are not app specific such as what we're doing for injective or polygon but a lot of our chains probably the over like 90 of them are dedicated to a single app and they build in customizations that make sense for their application so this is just a thesis on what this will do to value a cruel once a bunch of apps are on their own layer threes and Layer Three is kind of a term that's a little bit fraught because typically like L2 implies that you're using ethereum for a DA and you have a bridge contract there which is not what an eclipse roll up looks like so instead we'd want to separate it a bit and we'd say its own execution layer so when you have an app that's on its own execution layer and it's free to switch a DNA layer then that basically forces the data availability layers into competition with each other whether it's ethereum or some other da layer and that's good for the app because it means that the layer one doesn't have as much pricing power so historically the fat protocol thesis was basically that if you're an app on a layer one blockchain people will speculate on the layer one blockchain if your app succeeds and therefore the layer 1 blockchain will get a lot of The Upside even if you're an app that's very successful whereas when you're on your own chain you can capture a lot of that value yourself so that's one of the big values of being on your own chain in our view so these are some of the design trade-offs because what we want to do is offer customized Roll-Ups where you can pick a virtual machine you can pick a base layer and sometimes you can pick some other features such as a customized gas token or custom block times that are suited to your type of app so how can we provide that in a way so that we don't have to do everything in a one-off manner and we don't have to do something that doesn't scale so the first question is how do you offer multiple buy codes we want to offer evm and we want to offer svm in the future we want to offer move VM by code or possibly something else so there's a few different ways we could do that one is we take an existing roll-up framework and we basically Implement an entire virtual machine within it and that's actually something we might do with Sovereign Labs where we take the Sovereign SDK and add in uh I mean Solana has the virtual machine implemented as so on our BPF of course then you lose the that's more of like a by code interpreter rather than a highly parallelized virtual machine but my point is that you basically have to take this for every bytecode you take the role up SDK you implement the new bytecode and you get it working with the rest of your systems and hopefully the settlement for whatever roll-up framework you use is built generically so that you can support arbitrary VMS like that uh hopefully your bridging doesn't need to be rebuilt substantially but this ends up not really having a lot of there's no uh like waves that you can ride there's no one else who's going to be doing this work for you you're going to basically have to re-implement all this yourself similar and that same vein as DK stink and what they did with the llvm intermediate representation where they basically compile everything down to this IR uh some so they did this with salinity with Yule with a bunch of other languages uh and that's nice because it's one General uh intermediate representation that you can build all of your infrastructure around but the downside is again you have to kind of do this all in like a one-off way you have to compile everything to this IR so what we did was we basically picked the Solana VM largely for this purpose which is that I mean one it's highly parallelized you get a lot of throughput but two it's already on the path to supporting multiple by codes and most of our chains are actually evm and we support that by using a project called neon on Solano Solana obviously supports its own by code which is sometimes called SBF Solana bytecode format and then we have other bycodes that are on the way like move VM so this is a huge advantage in the sense that we get local fee markets we get all the tooling spelled for the Solana VM it's a very powerful execution layer but the downside is it's really not built to be a roll-up so we have to do things like insert a smart Merkle tree we have to sometimes change some things about how the in the future we might have to change the mempool in order for it to work with shared sequencers so these are all things that we have to make uh like we have to roll our on our on our own all right so now the next question is how do we just thought online should we do a typical small contract roll-up which would be on ethereum and that's be that would be the smart contract that determines the canonical chain another option is you make it do Sovereign settlement so somehow you pass proofs directly to like lines and one big Advantage here is verifiability I mean the advantage of being on a smart contract on ethereum is that people say it's trust minimized in the sense that if you run an ethereum full node then you know that whatever state that ethereum flow node contains is a correct State for the roll-up as well but that only works because running a phone on an ethereum is essentially running a Lifeline for every single roll-up on ethereum because that's smart contract Bridge is a light client so alternatively you can just write uh like a settlement that you can run a roll up that directly passes those fall proofs to all my client that your community or your users run and they can directly verify the correctness of the rollout and then the last option is actually what we ended up going with which is we have everything uh deployed as a one event and Trust assumptions smart contract roll up onto a shared settlement layer so that's that's nice because you get that trust minimization with respect to the settlement layer where anyone can submit a flaw proof in the case of it being a ZK roll up then you can just validate the ZK proof within the cell the settlement layer but then the settlement layer itself is a sovereign layer passes fault proofs directly to like clients and in the future the settlement layer will be a ZK roll-up so that's the design that we ended up going with and it also gives us a lot more ways to build in convenience features for our Roll-Ups for example you can imagine a world where you don't want to move your liquidity between every single Eclipse chain so instead you just leave all your money on the eclipse settlement layer and you have you use account abstraction or something to signs transactions for these different chains and then someone relays those transactions and they get compensated on the settlement layer or you could use a settlement layer as a sequencer set so that's that's the idea behind why we have the settlement layer you don't have to use it you could theoretically run your own Eclipse chain run the sequence of yourself but then you're lacking a lot of these Network effects all right the next question is how are we going to get um from an optimistic roll-up to a ZK roll-up we built the fall proof ourselves in-house but we really didn't want to build a full ZK VM in-house because it's a lot of work and it's kind of an arms race in the sense that we'd have to continually update this virtual machine so we really didn't want to build our own in-house one so we looked at a bunch of existing ZK VMS or ZK proof systems as a service and that's things like Risk zero that's like Axiom nil Foundation ultimately we picked risk zero uh for the reason that it's highly portable risk 5 by code is pretty generic and we could probably switch to something else down the line if we really needed to but the risk of your team is also interested in working with us and we found through our cost benchmarking and it ends up costing about 10 cents to prove a non-trivial transaction and that's without any additional optimizations it's just using Straight Risk by code and what I mean by that is we take a Solana program and rather than compiling it to Berkeley packet filter by code which is the normal byte code for Solana we compile it to risk five by code instead and we run that within the risk zero virtual machine so that's the high level implementation in the future let's say we wanted to cut down that cost even more we might natively implement the BPF circuit and we can still reuse risk Zero's proof system so this is just summarizing when I just went through uh this is on decentralizing the sequencer this is enough of an open question that I won't go into and I want to start getting into the applications that uh that we're able to support so I'm going to just gloss over this uh this is stuff on wallets bridging and uh this is the application part so this is a case study on worlds uh worlds is a game that's building on eclipse and they basically use the blockchain as an open API so they write a bunch of read-only data onto the blockchain uh these guys build a Unreal Engine 5 previously so they're really hardcore game developers but they see the purpose of the blockchain as a highly composable API where players in the community can build things like financialization on top they can build their own Primitives they can build their own user generated content but you also have this like base read-only on primitive which people can use and compose on top of so that's what they're doing and if you think about it they're already conceding that to some degree this is centralized because the company themselves is acting as the Oracle they're signing off on the data that's being posted to the chain so they don't really care about the base layer of being decentralized right here I have Celestia written as the da layer but actually in practice right now we just have them out on a centralized DNA because it's a very high volume of transactions and they're very low value on average so that doesn't make a lot of sense for them to be posting and paying money to an actual decentralized da layer at least in these early stages so that's what the base layer looks like the uh the sequencer itself is centralized because they don't really need to have us a sophisticated decentralized sequencer setup and this is a very consumer oriented chain so they even take usdc for gas so that's the setup of a consumer chain on eclipse this is what we're doing for worlds we're doing this for a handful of other projects like Gridiron boulevards ether games we have social future on the social side so it's basically like a highly centralized chain that supports extremely high throughput but it can compose with a bunch of decentralized chains on the side you can build your own Primitives on top of it as a community and that's that's how they use the blockchain and this is just a way that we think about different types of applications this gaming template is more like a general consumer template at this point and as you can see the it's running the svm but it's actually running evm by code within the svm this is not actually what our D5 template looks like but we're still hammering that out with some of our defined design Partners we do a lot of svm Roll-Ups for layer one blockchains so this we're still thinking about how we're going to incorporate into our self-service offering but basically you spin up a chain that has a custom data availability layer so a post blocks somewhere and then Eclipse needs to also know how to read those blocks as well so this might require in in the future maybe teams would make a PR against the Eclipse code base they'd show how to post and read from some new ta layer and then they can spin up an eclipse chain that does that and then we do a bunch of deep in projects or decentralized physical infrastructure networks so that's like a react wave wind iotex these guys are taking real world things and they're doing some work off chain and they're able to prove that it happened on chain and then they can incentivize people to participate in the network via some tokens such as what helium did they can take that data they can optimize it so that they can save you money in the real world they can sell the data there's a bunch of different business models that you can do once you have that all on on Channel so this is just a bunch of other um more Fringe use cases and that's pretty much the stack so uh that's uh the first presentation that I wanted to get through and I think we have a little bit of extra time so I'm going to go through some more detailed case studies so I'll go ahead and pull up this case study which is just a deeper dive into Worlds and what I want to drive home here is that for a consumer chain like a game that's posted if it's fully on chain posting something on the order of hundreds of thousands or millions of transactions on chain then even if they're paying something like 10 cents a transaction that's probably prohibitively expensive for them and why would it why not even say 10 cents it's because if you look at the ethereum da cost uh which is a fee Market it ends up being about 10 cents to post 200 bytes to ethereum and then maybe you'd want to like charge a little bit of a markup on that because you have a fixed cost associated with running the sequencer for your roll up so maybe you charge like an additional two or three cents per transaction so you'd end up paying something like 15 cents per transaction so you'd have to ask well their users are really comfortable paying 15 cents per transaction and whether it's worth it for them to post millions of transactions on chain given that the value of each transactions pretty low so given that structure and given the economics of it it doesn't really make sense and we'll see what the fee Market on celestion job ends up looking like but in practice this kind of change should use some sort of centralized DNA and in the future once this is a ZK roll up it's probably not that big of a deal either it's essentially a validium construction and by centralized you could do a DAC like a data availability committee you could make it quite affordable to have data that theoretically could be withheld but at least you get guaranteed correctness by virtue of the validity proof so that's um what we have as far as how we've been thinking about gaming and why our setup makes a lot of sense for games we let people take the da solution so if you do have higher value transactions and of course you could use a decentralized da it's evm because they wanted that portability they don't mind a centralized sequencer and then they want to use something like USBC for gas so they've demoed their game in a couple of our game nights we had one over in Denver we had one over in San Francisco at GDC and if you're building a game then we'd love to chat with you because we can likely arrange some similar startups with you okay so that's world's and then let me go ahead and pull one up for injective since this is another one that we're pretty public about so injective's chain is called Cascade and this is a Solana virtual machine chain that injective runs so they're a layer one blockchain injective supports uh web assembly programs so it's rust as well but let's say a Solana program wanted to deploy to the injective ecosystem they'd basically have to rewrite a lot of their logic so by having an svm chain injective can basically promote these projects to or they can encourage them to deploy to this svm roll up they can easily deploy and they don't have to rewrite any smart contract logic and then that chain charges injectives native token for gas so that's like the high level on how the value occurs back to injective of course they also have an IBC connection back to injective we're working around some uh some other stuff they want to do with the sequencer whether it's by adjusting the block time they might want to use a shared sequencer such as espresso but this is the high level startup but these Roll-Ups for l1s typically look like it's bringing them a new execution layer uh and it's charging gas in their native token so soon we're going to be actually deploying an evm chain for injective as well because they want ebn compatibility so this startup is pretty General so um there's probably not as much to cover on this one we gave a couple of options for them uh initially because this was one of the earlier l1's that we ended up working with since then we've engaged with BNB chain polygon near uh we are spinning something up for Nibiru there's a few other Cosmos chains which uh we're still in the works with and we haven't quite uh quite finalized what that would look like but we've basically done this a handful of times so that's what um that's what we've been doing been doing Vlogs for all Ones been doing games and consumer and more recently we've been entering D5 that's the high level on what Eclipse has been doing and feel free to reach out if you have any questions [Music] thank you 