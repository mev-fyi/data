foreign hello everyone um I'm Josh I'm the CEO of Austria we're building a shared sequencer Network and my talk is shared sequencing speed running the end game so I've blatantly stole this title from John um who references in his last post um so what's a sequencer just level setting and just knowing I'm going to skip over what's the roll up I'm assuming this room knows that um but what's the sequence there so I'm gonna argue that a blockchain is structured roughly like this we have a mempool could be called a transaction pool but it's unordered transactions will get too intense later in the talk um and then it becomes ordered and you have a block and then it becomes executed and that results in a state DB and a state route the corresponds to that um when we talk about sequencing for the purpose of this talk we're just talking about the ordering bit we're not talking about the executing bit um we can cover that in another talk or it's been covered elsewhere um why do we want sequencers or like why would we have a sequencer for Roll-Ups I think um Conor's talk did a good job of showing within you know Sovereign Roll-Ups and enrolled more generally right the concept of like a based roll up how you could have different Fork Choice rules what actually determines the kind of canonical ordering of a given chain um but fundamentally why we use sequencers is for Speed um because users like speed users want these um fast commitments um to The Ordering of their data so they can kind of you know make their transaction say yes okay I clicked a button I got a response you know there's um a large depth of research um going back to like the 90s that like when users click a button they expect it to respond within one to four seconds or so over that four seconds they start to think something's broken you get to like 12 seconds they're just like all right I'm out this thing doesn't work so there is like a very strong ux reason for having speed when it comes to user this is a very simplistic design of like a roll-up sequencer we can see that the roll-up sequencer is giving a soft commitment to the user the user just submits to that sequencer gets a soft commitment the sequencer is going to batch to a DA layer that da layer is going to what give what we'll call like a firm or a hard commitment to the user the presumption here is that the data layer is going to be run slower than the sequencer um but here's the situation we found ourselves in right we gave users fast soft commitments um but we made a trade-off and we gave up decentralization for this right so you do get some guarantees from the base layer censorship resistance but fundamentally we're running you know singular nodes that are geolocated in a single place and a lot of Arbitrage is happening because people know where they are they're co-locating they're spamming them that's how we're doing kind of Mev and Arbitrage against binance right now um and our general view is like that's not fine um so this goes to what we're building which is a shared sequencer what is a shared sequencer um roughly this so we introduced this sequencing component that is in between the data layer and the Roll-Ups um and the kind of core Point here is that multiple Roll-Ups can communicate with one shared sequencer Network this shared sequencer network is implicitly decentralized in our terminology it just sounds worse if you say it's a shared decentralized sequencer Network um so we just called it a shared sequencer Network um and really this is the key thing we believe that roll up should be decentralized by default what we're seeing for road maps of existing rollups they launch they're centralized they put on their roadmap and say look we're going to do this Progressive decentralization but the reality is we're 12 to 18 months along and we're still running centralized nodes if we believe that Roll-Ups are the way we're going to scale kind of the availability of like block space for users we can't go through this cycle of 12 18 24 months of every time a new roll-up stands up they say okay great we're going to do our Progressive decentralization in 24 months we will be decentralized and we have this kind of impending queue of decentralization to come um if we're familiar from like you know to put like the Boogeyman and like talk about like regulation right Regulators are slow to move for the first time but they're usually pretty quick to send follow-up things so I think this will become prioritized a lot more the first time someone gets a letter from an agency they don't want to get a letter from um we think about Mev a lot when we're designing this um and I would consider this Mev driven design and really the thing is you know calling her to hasu here right it's all PBS all of this design really is this Pro um proposer Builder separation um so this is in kind of like a like a this is a single sequencer right but in we'll say it's like a decentralized set this is kind of what the PBS would look like right you're gonna have a user it's going to submit to an RPC this RPC is going to have a mempool that mempool is going to be looked at by Searchers those Searchers will produce bundles those bundles will be sent to builders the builders will create blocks that will go up to the roll-up proposer that's when you get your soft commitment that proposer will still send a batch to a data layer and that data layer will give you your firm commitment this is essentially how an L1 works there's really no structural difference here other than the last step of batching to a DA layer um if we look at this in like this most simple case say we have one roll up and it choose to use a shared sequencer we can argue over the terminology whether that's really a shared sequencer um it's really the same we have a shared sequence they're mempool and we have a shared sequencer proposer um but the rest of the flow is kind of the same here um where this you know we as we can compare it here right really quick right it's just we just made two of the boxes blue right um where this gets kind of interesting right is let's say we have two Roll-Ups right if we have two Roll-Ups we want to have Mev markets on both of them right we have duplicated the entire you know call it Mev supply chain right Henry would say this is just protocol design um but yeah we have to duplicate the whole supply chain whereas if we go to a shared sequencer we can have multiple Roll-Ups and we have the one mempool and we have the one shared sequencer proposer and we didn't have to duplicate everything um so going back to the question what is a shared sequencer fundamentally it's a single place where block Builders within a proposer Builder separation Market can settle and that term is like overused and like not great but they can settle multiple Roll-Ups in a single place you can think of this as a single counterparty um for settling your your blocks that are proposed by builders um you know right calling up James again right stop saying settlement layer so we're not calling it a settlement layer but it is a single place not a layer where you can settle some transactions um so going to you know John's recent good article right we have kind of a trade-off here right these shared sequencers create what is termed super Builders um let's go through the flow here right going back to we have this you know Mev supply chain design where we have multiple Roll-Ups they're talking to a shared sequence their mempool that's going through this whole flow this is a little bit oversimplified if we want to expand this into what this might actually look like in a more layered fashion the users may talk to the individual roll-up rpcs because they may only want to send a transaction to you know one given roll-up they may each have their own mempool and then Searchers may choose to look at just one of these Roll-Ups you know um they could be specialized um they could even be you know sub-specialized beyond this but we're not going to cover that in the diagram gets busy we also have this concept of a cross chain Searcher but all of these Searchers may push to a super Builder because fundamentally we have this one block that is being sent to this proposer and so the problem here or the potential problem here is that this Builder is now um assuming we have like flow across heterogeneous um Roll-Ups here they have a lot more work to right instead of saying okay I'm gonna have an evm I have one state DB right I'm going to simulate my transactions against this they say okay I'm going to have a lot of bundles coming in from different heterogeneous State machines and I want to simulate them against each other and figure out what are the profitable ways I can construct a block that just becomes something that is a higher resource problem and that this is where we end up with Ken Griffith um a citadel just being our super Builder here and we're right back to where we started um that's not really where we want to go um but we're just going to punt on that for now um we'll go back to that a little bit at the end um but what about composability right let's think about some upsides maybe of a shared sequencer is our composability a tonic um well let's again go back to this argument here right um when we look at this flow what we really want to know is what is happening within this mempool Searcher Builder shared sequencer proposer what's happening in this bundle layer um and so zooming in on this right what is a bundle in this concept where we have multiple different Roll-Ups utilizing a single Mev supply chain with a shared sequencer um we're gonna make the argument here that a bundle with a shared sequence and transaction again I'm just going to use the word transaction we're not going to get into intent yet um and so what's the bundle look like right um we're going to say we have two Roll-Ups that just happen to be blue and red with their color scheme um they would produce a single shared sequencer transaction that would consist of both of these transactions that would get ordered into a single shared sequencer block and then after the fact when these Roll-Ups actually try to pull their sub block out they would get these roll-up transactions that would be ordered this is probably the simplest case to think of about where you get this kind of atomic composability essentially this model we can think is just simulating you just get a top of block auction across two Roll-Ups using a single shared sequencer um the nice thing here is we don't have what is termed like the hotel and train problem right you are able to say you either got both of these in um or you got neither of them in and you can buy that top of block essentially for like multiple Roll-Ups if that's how you choose to construct your bundle rather than trying to do some kind of Arbitrage we say hey I want to buy on this one I want to sell on this one and you land one and you don't land the other and now you have it we'll call it inventory risk who creates the bundle so um so again going back to this thing um when we're thinking about these bundles right we have the Searchers they're going to be the people that are creating these bundles and giving them to Super builders um but really what we're thinking about here if we want to get into the kind of interesting composability um options for a shared sequencer is we're thinking about these cross chain Searchers um and then you know we can expand and we'll say okay let's just think we just have a cross chain Searcher we have a super Builder some stuff's happening on the back end with the proposer but let's just use the users we have Suave or something else you know but we have a thing there um and we also have these roll-up rpcs really what these cross chain Searchers are getting is order flow um this is them just you know whether they do a payment for order flow or whatever but the thing that the Searchers want to get is order flow and then they are going to produce these bundles um so that's kind of just the flow here and so what I will argue is that kind of the end game here is hotels trains and intents um and so when we say that is right you know the key thing that you get with a shared sequencer and the shared proposer the resolve this hotel and train problem because going back to the idea of settling you're able able to settle multiple Roll-Ups within a single proposer and so it's actually really nice that like Chris gave his talk before this right what is the fundamental thing that when we say a proposer that it has it's this supply side thing right the proposer has a monopoly on the right to order um we'll just say a block right whether it's intense whether it's transactions but a proposer has the Monopoly right on that ordering um and by sharing that right we resolve this hotel and train problem because now the the users the Searchers the builders the people that are actually producing or making a um God the words are not great um proposing a block to the block proposer right um that they have built right they only have to negotiate with a single counterparty right um and that fundamentally resolves this hotel and train problem and I'm going to try to remember do I have another slide for intents I do okay going into intense and kind of going into the end game more um we'll just simplify and let's assume that you know we have Suave or something um and we're not really worried about individual Roll-Ups having you know their individual rpcs their individual mempools right we have users and they are somehow giving an intent to Suave or something right and then we've replaced our Searchers we're going to call them solvers now um but we're still going with bundles to a super Builder we're still going to a shared sequencer proposer we'll still go into a data availability layer and here is what I think is kind of the unsolved problem I think uma's talk went into a lot more detail kind of around this but I still think it's an open question how are users figuring out an intent you know I think were a lot of kind of pretty Niche research community in this room and we still generally don't have agreement on what we mean when we say intent uh end users who are not changing the slippage on their uniswap orders on that UI are not going to figure out how to construct an intent at all like it they're just not gonna figure out there's no syntax on Earth you can come up with they're going to click a button um so really the missing piece here is that we need some kind of user interface in between the users and whatever this you know Suave place where we're sending the intense you know call it the bulletin board here um and so this really leads to um you know shout out to like like mads in his like recent post um this is where aggregation Theory I think comes in and this is what we're going to see as like a market and and from like you know an investment perspective this is probably like the largest open opportunity um what is aggregating this user intent um or this actual like user intent and presenting them an interface that they like to use whether it's you know swapping trades um whether it's buying monkey pictures whatever they want to do but who is providing this google-esque front door to multiple blockchains right because right now we have a pretty poor ux even when you're trying to use one chain you know to zucki's point right like we're not going to resolve this with just transactions and having these kind of explicit imperative saying okay I want to send a transaction to chain one and then I want to bridge from chain one to chain two to chain three and then I want to go buy a thing they're going to use intense but like my argument is they're also not going to say hey I'm going to write out some syntax that says I want some action to occur across some chains and I'm gonna set you again they're not setting they're not changing their on the UI for what fifty percent of all the flow going through all of defy they're not going to accept a more complicated UI that now has 10 different parameters in a form field that says okay well you define how you intend for your preference to be um executed um and again this goes to aggregation Theory right if we think um you know this comes from like Ben Thompson it's probably the largest or loudest kind of prom um promoter of this and Google is kind of a canonical example right it is the front door to the internet right you don't need to use Google you could write your own script and say I am going to go walk through all of the potential URLs or IP addresses and I'm going to try to find the information I want but sophisticated users they're not a house if it's scared it's not going to do that right they're going to rely on someone else who has said I have gone and found stuff and as you know tarun's talk has pointed out right they now are the front door the controls you know the information flow and they will take advantage of that um this aggregation Theory kind of acts as like a Counterpoint almost to Chris's talk right this is from the perspective of the protocol wherein the proposer has a monopoly on this ordering this is something like a user from that perspective who now has a control on the incoming information to one or more chains you know there's no reason that you couldn't have a UI that abstracts away um where a user's assets are you could even satisfy the custodial thing and still have a single kind of like pane of glass where users go to use um maybe this looks like an expanded block Builder um or something like that but this is one thing I want to highlight that I think is kind of something that like this room doesn't focus on a lot you know when I think about engineers and talent we have in crypto not a lot of front-end people um not a lot of JavaScript to devs but fundamentally that's what users are using right users are not going to get their CLI out you know um and and express their intents that way so really what I think might be the the injure thing next step that is potential to see is a single UI with multiple chains and my bias argument is potentially it's one block because that at least makes this kind of um I'm just going to call it settlement problem um dramatically easier to kind of execute um I don't know where I'm at for time that sounds like it was fast um but yeah website after you.org Twitter astra.org I'm Josh um thank you thank you 