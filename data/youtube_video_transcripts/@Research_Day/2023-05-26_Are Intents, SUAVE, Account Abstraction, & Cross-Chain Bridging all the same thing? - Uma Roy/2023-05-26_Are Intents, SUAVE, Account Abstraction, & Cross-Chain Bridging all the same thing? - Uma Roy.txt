foreign and I'm going to be talking about how cross chain bridging a kind of abstraction intense and Suave are related and I promised I didn't just throw it together for the most popular things that people are talking about right now and there's some actually interesting connections so so to start off with I want to talk about like how did we at succinct get here so succinct we're a company we think about the future of bridging and we started by thinking a lot about how current Bridges really suck they're all multi-cigs they get hacked all the time and they generally have really bad security properties and so the thing we first worked on was ZK snarks basically for improving security properties of bridges but that's not what I'm going to talk about today I'm actually going to be talking about the future of bridging ux not the future of security and so there will be no fancy ZK math so I'm sorry about that but basically the thesis is Bridge security is broken today but also bridging ux is broken today and I think a lot of people really acknowledge that and so we're going to walk through basically fixing bridging ux in four parts so part one is going to cover why does current bridging ux suck the next part is going to talk about maybe fixing bridging ux with account abstraction part three is going to be kind of a defensive intense and why having this intent language is important and why account abstraction isn't enough and then the last part is going to be about Suave lightly touch on it and basically argue that Suave is actually really important for ux so this is kind of like the outline in meme form okay so yeah let's just get into part one current bridging ux really sucks okay so say I'm a user and I go to GMX on arbitrum and I want to do some like levered long okay so I connect my wallet I realize hey I don't have enough Ethan orbitrom but I do have Ethan mainnet so then I go to the next tab I'm like okay how do I bridge to arbitrum I go to the arbitrum native bridge I connect my wallet then I realize I have to actually connect my wallet to a different network so I have to switch it and this is like very intentionally painful so I'm like drawing it out to show you guys the pain okay and then I remember oh actually someone said the native Arboretum bridge is slow I want the fastest way to bridge because I really want to do my leverage long right now and so I looked that up and okay the top results is something like synapse okay so I go to synapse protocols like a new website okay I'll trust them why not I have to connect my wallet once again I have to do all this stuff okay finally I Bridge okay and then what happens my money basically goes into a black hole it like disappears on one side okay and then I wait a really long time and then I you know I really hope I'm getting my money there's like very little transparency as to what's actually happening okay and then I finally get my money great I go back to my original tab okay now I've like disconnected and says your wallet's not connected to arbitrum so I have to switch to arbitrum once again to go back and do my original app and at this point I'm just like really annoyed right like maybe a very persistent user would you know push through but like maybe at any step of the way I've given up and this current bridging ux I think is very unacceptable I'm not going to go through all the bullets we had to go through but basically in short we spent maybe like 30 minutes we had five tabs open and we had to connect our wallet three times with two different chains and this is just like not going to scale and I think actually these problems get a lot worse in a world of a million Roll-Ups so I think a lot of people here are big fans of like Cosmos thesis Celestia thesis there's going to be an app chain everyone has to roll up and so why do these problems actually get worse basically you have to keep track of gas money and dust across all these chains and ecosystems and then you have to solve this bridge Discovery problem for each new chain and I think this is very unsustainable there's been some incremental improvements for bridging so uh there's been these bridge aggregators that kind of help solve this bridge Discovery problem so metamask now has this like in wallet swap feature we're sure yeah maybe I pay a really extractive fee but I don't have to like open a new tab but I think this is like fundamentally broken and we need something different the ideal flow is bridging should be abstracted away from the user right like they shouldn't need to worry about transporting their money and I think the ideal flow looks something like as follows a user wants to take an action on adopt then they sign one transaction for the action and also permitting any necessary money flow the money gets routed and swapped to the right destination and the desired tokens not by the user this is happening all under the hood and then the user action happens and ideally all these things happen basically instantaneously so in the GMX example I'd go to the GMX website I would connect my wallet I would just click like lever long I would send my transaction and then it would just happen okay so how do we actually accomplish an ideal flow with something like this okay so what is account abstraction so account abstraction I think a lot of people kind of like talk about it um I feel like it doesn't get that much love in the research Community because it's like very user focused um but basically what it is is it's just a spec it's erc4337 and it creates a standard for a very general smart contract wallet so the goals of account abstraction are you want to enable very complex validation and execution logic that wraps around user transactions and then you also want to decouple Gas payment from the actual user who's sending the transaction so just to like go through some concrete examples of what this gets you uh so if you have this like validation logic you can have things like social recovery or maybe if I'm a user I still have a private key but if I lose the private key I can socially recover and not all my assets are lost or maybe I can have this like more complex role in permissioning system where if I want to spend more than a certain amount of money I require like three signatures I can also have a contract whitelist Blacklist I can have rate limits and then the gas obstruction part is basically as a user I don't have to hold eth or the native gas token in my wallet I can just hold usdc or any URC erc20s and I can cover the cost of these transactions not using the native gas token so all these things sound really great an account obstruction kind of promises they have this like protocol or standard that lets people Implement stuff like this okay so how does account obstruction actually work again obstructions actually fairly complicated or like it has a lot of parts but here's like a really simplified design so before a user would just sign a transaction which would just be like the action I want to take like do this swap on uniswap now a user signs a user op so this in this isn't a signed transaction it's a signed message very similar to like how if you're using a noses say if you sign a message um and then the transaction gets pulled once all the signatures from all the users of the safe are collected and then there's an Executor which is another entity that submits the user off and then the smart contract wallet basically validates the operation using validate op so it'll check there's like the appropriate signers it'll check Access Control it'll take check rate limiting and then it actually executes off using execute op and this results in like transfer of funds executing a swap by an nft whatever the user wants to do okay and then actually what's really happening behind the scenes is you have a lot of these users who have many user Ops and they actually send them to an alternative mempool and then there's many executors and bundlers who are bundling these user Ops and sending them in like bundles to this entry point contract which then is like sending them to the smart contract wallet so this will become important later but it's just like good to keep in mind so I previously I think like this smart contract wallet the validate op and execute op kind of explains how you do things like the rate limiting and social recovery and all that stuff but I actually didn't explain like the whole gas abstraction benefit of account abstraction so there's another part of account abstraction uh called this paymaster system that allows users to stop thinking about gas so how does it work basically you have this paymaster contract which is like another entity and then when the user sends their transaction uh first the transaction goes the user op goes to the paymaster contract the paymaster contract validates that it will actually like pay for the transaction and sends a corresponding amount of native gas token back so that's like that eth refund and then the user operation actually occurs with validate op and execute op and then there's the paymaster basically has this like post user operation hook um and the actual system here is like pretty complicated like the pain master has to stake and there's all these like considerations around griefing and stuff but if we kind of like walk through the code a little better or a little more uh the flow for a user say I'm a user who wants to pay in usdc to cover the cost of my transactions because I don't want to hold eth for any reason so if I'm a user I'll withdraw usdc to my smart contract wallet and I'll send an approval for the paymaster to spend okay and then the paymaster contract kind of looks as follows it has two functions the first function is validate paymaster op and it'll just return whether or not the payments will actually pay for this transaction so for example the paymaster might not want to pay for like random transactions it's very reasonable and then it has this post operation function which is this hook that I talked about which is called after the user op is executed so the user operation happens they do their Swap and stuff and then the entry point which is this like ground truth like trusted contract that everyone's like agreed to calls this function post off and it calls it with this actual gas cost parameter which was the actual gas cost of the function and then in short what's happening here and this is like skimming over a lot of details is this paint this particular pay masters Computing the actual gas cost converting it to usdc and then doing a token.save transfer from from the user to the paymaster to take the users usdc and reimburse the paymaster for the gas that it covered okay so can we have a cross chain paymaster where basically if I'm a user I would draw usdc to a Smart contract while in ethereum and but I want my paymaster to pay for my transactions on arbitrone so now my paymaster lives on arbitrom and like can we just make this work and okay surprise surprise the answer is like no like very naively this doesn't work because in the post operation function when the paymaster goes to transfer usdc from the user to the paymaster uh the usdc is living on ethereum but my pay Master contract that's paying for stuff is actually living on arbitrum so like the usdc lives on a different chain so naively this doesn't work and the fundamental kind of like reason for this is I think account abstractions not really like across domain protocol um it's really meant for like this single domain in mind okay so you have to like kind of work your way around this and figure out a solution for even taking account abstraction and adapting it to this like cross-domain use case so okay what's a really naive solution one so the problem set up is like I'm a user I want to do a user operation or like take some action on arbitrum which is on the bottom but then my smart contract wallet actually has all my gas money and on the top and then that lives on like mainnet let's say so a very naive solution is okay if I'm a user I'll sign one user op on chain a which is the top chain to pay for gas it'll pay for the gas and send the money to the paymaster account then the paymaster will wait for finality on chain a and then I'll also assign a user operation on chain B to take like whatever action I want and then after the pay masters waited for finality then basically it'll pay for my transaction and it'll like settle within itself so it won't necessarily actually have to move the money from chain a to chain B it'll just like front me the money on the other chain and settle with itself later uh this is like not that much better than bridging the current bridging Paradigm if we think about it so let's like go back to our own evaluation criteria so here the user still has to sign true transactions right it has to assign or it's not signing transactions but it's signing two user Ops on two different chains uh the money does get routed and swapped to the right destinations so like the paymaster is kind of like doing that work of like managing its account balances on the different chains and settling with itself but also it's not instant right like the paymaster you still have to wait for finality so this nice solution like still has a lot of the original problems of current bridging okay so let's think about what like a better solution could look like so one solution that we kind of thought about and came up with is okay a user smart contract wallet on chain a has a piggy bank where basically funds can be withdrawn with a time lock let's say like six hours and if I want to take an action Y on chain B asically what happens is I sign my user up on chain B and then the paymaster off chain basically verifies that I have enough money in my piggy bank to like pay for this transaction and then it'll just front me the money instantly if it sees there's enough in the piggy bank and then when it's fronting the money then the paymaster contract will also send this cross chain message to chain a to basically say hey I paid this much this user for this transaction okay send a message that I paid 10 uscc and then when that message arrives to chain a it'll automatically like send the money from the piggy bank to the paid Master's account on chain a so why is this nice so here the user only has to sign one transaction uh which is their user op they actually want to do and then what happens is the paymaster can immediately once they've done this like check uh of the user funds on chain a and make sure the user hasn't like signaled they want to withdraw right because otherwise if the user can withdraw that's like problematic because the pay Master might not get paid because this message might arrive and then by that by that time the funds are gone so once a user does once a paymaster does these off-chain checks it can just immediately pay for this transaction front the money and then settle later so the money gets routed and swapped to the right destination with the right desired tokens and it's instant and so this is super awesome because it feels like okay this is a much better solution for the bridging Paradigm and it's like much better than bridging today so one interesting thing to note here is you can use this not just for gas but you can also do this to front like usdc or eth or really anything else for more complex actions like okay Do a Swap or buy it and like I want to buy an nft or arbitrum or I want to do swap on arbitrum actually this paymaster confronts like all the different money all the different tokens for any action this user wants to take and then it can just like be settled later by like withdrawing from the user account on their like main chain and the user doesn't have to worry about any of this all this is happening under the hood and the paymaster is like doing all these conversions like necessary stuff okay so one interesting thing to note is we were like okay this Design's cool but do we actually need account abstraction and we realized that actually you don't fully need account abstraction actually there's a clever way to do this where the user only needs to replace their RPC so what can happen as the user replace say they replace their RPC and they sign a normal transaction so it's not a user op it's just like a normal transaction and then this transaction will go to an RPC and then rrpc uh and this is like a somewhat centralized solution we'll basically see oh okay this user has basically given us has set up this like smart contract piggy bank on their main chain so I'm going to front run their transaction with enough gas money or whatever other assets they need and then I'll send a message to deduct from their piggy bank so basically you're kind of replacing this like smart contract wallet and this notion of a paymaster and our RPC is like doing a lot of the work and front front running their user actions with like the necessary transactions to send the user gas and other assets they need and to talk deducting from like the home chain users home chains wallet and so we actually implemented this so we made this our PC and you can see like okay I have my Xerox 5cb account connected on gorley and it shows I have zero Gourley eth but then if I switch to my Universal RPC in metamask we kind of hijacked the RPC and we return that you actually have 10 Gourley eth because in reality maybe you have like 10 Gourley eth on another Network that you've like permitted us to spend basically and then what happens is if I want to do a transaction so guys the text is a little small say I want to do deposit Transaction what we do when you send us your deposit transaction is we front run you with a transfer a transfer call from our wallet to yours to like have give you enough gas and enough assets and then your deposit transaction goes in after and of course like in a blockchain where there's blocks we can make this like a bundle and we can even have them in like the same Block in our test implementation of just like two different transactions so this like seems really nice right like I feel like as a user I'd personally use this like I don't have to worry about anything I just give this like entity some sort of like piggy bank and then they coordinate all my gas and all my assets on all these other chains I want to use I never have to worry about dust and things like that um so what's the problem okay the problem is actually kind of like the same problem as adoption of account abstraction so the concrete problem we ran into was dap front ends still use their own RPC they don't actually use like our special RPC so they will show that like you have zero balance and not let you do any action so here's like the uniswap screen showing insufficient usdc balance even though we know that will front you all the usdc you could ever want from your main account the DAP front end like doesn't know about this and so I actually think as account abstraction gets adopted basically there will be these like ux adaptations for this new paradigm where like a lot of the stuff subtract away from you and hiding behind the scenes um and so I think we actually do need account abstraction because you need like these dap developers and front ends to like kind of adopt to these new paradigms or instead the user manually bridging all a lot of the stuff's happening behind the scenes for you and so my kind of thesis is with account abstraction currently cross-train bridging today is very push so like the user is responsible for pushing money from the source to the destination right the user has to figure out the best path they have to choose their Bridge you know this caused us like five tabs three wallet connections 30 minute delay like it was really annoying because I as a user I had to do a lot of work and make a lot of decisions and then with account abstraction I think bridging can be much more pull where you have this pay master and the wallet and kind of this like account abstraction system figuring out the best path for you and then all these off-chain actors who are not you are pulling your money to where you want so as a user I can just have one tab I sign one user operation the funds are fronted instantly by these pay masters who are managing these like account balances and then they settle with themselves later so as a user you still have your money on like maybe one chain that you're like most on but then everything's like taking care of behind the scenes for you so I think this is like a really nice future okay so I just like talked about why account abstraction's so great and you're like wow like maybe this solves all the problems with bridging like do we really need like intents and like all this other complicated stuff okay so what even is an intent I think it's been very popular topic no one really knows what it means and I'm gonna do my best to Define like what it is and I'm not gonna give like a very precise or mathematical definition that's like more philosophical more of like a Vibe so okay let's just how do we compare an intent to a transaction so transactions are this object we know and love right if you're a user when you do a transaction you're just specifying a specific action it's like very declarative an intense instead specify like a desired outcome or goal so let's just like go through some examples so a transaction is I want to swap two 2 000 usdc for at least one eth on unisaw okay like you're saying I want to use this venue and I want to do Swap this for this an intent version of this would say like I want to swap 2000 usdc for as much eth as possible that's like your goal you're not specifying how to get there you're just saying like here's like my preferred state of the world after okay another transaction example is like I have eth and I want to lend it on compound and intent is I of eth and I want to get the highest apy and like maybe I only want to interact with like a certain white list of lending protocols that I trust and I actually think like the lines are blurred in some cases so for example like today a uniswap swap I want to do a uniswap swap with a maximum slippage of 0.5 so of course there's a transaction in there which is I want to do a swap on this particular venue for these assets but you also kind of have an intent you're saying like the maximum slippage I will tolerate is 0.5 that's like not declarative right uh unless you're getting sandwich and your max slippage is actually your actual slippage you're saying this is the maximum that I kind of want of course my preference is lower so a lot of people and I've like kind of heard this maybe not in this crowd is like okay do we really need intense like intents are just intense is just a kind of abstraction except the researchers are being pretentious again they came up with these like new names for like old Concepts okay I actually think this is not true and so here's like my defense of intents so one question to ask is like okay our user Ops and the validation logic in a smart contract wallet are they intense so okay our user Ops intense let's just like go through our definition of like intense versus transactions based on this like kind of very loose definition we previously established so I actually think user Ops are not intense usually user Ops are like very simple and declarative they're like basically a transaction and they want to say like I want to trade X for y on the venue so they're basically transactions I actually think there is some truth to account abstraction being related to intense but I actually think this comes from the validation logic in a smart contract wallet so I think the validation logic in a smart contract wallet is able to express and enforce very simple intents and what do I mean by this so basically I think statements of the form rate limit X money leaving my account this month or hey my address can only interact with uniswap and Sushi swap so like the whitelist Blacklist system or usdc in my account can be used to pay the paymaster for gas which is an intent to reimburse I think all of these things are clearly not transactions right they're kind of like stating your goals and preferences over like certain outcomes but they're not declarative in the same way saying oh I want to trade on uniswap is or I want to swap X for y on Ubisoft is and so I basically think the validation logic in your smart contract wallet expresses and also enforces intents that can involve Global reasoning about the user account but of course my smart contract wallet cannot reason globally about General State like in my smart contract wallet I can't write logic that's like give me the best price for this swap because there's no way for my smart contract wallet to know globally what the best price is and so my claim here is that account abstraction is basically this handcrafted protocol that's in service of specific intents so very simple intents so in account abstraction the user can specify and enforce really simplified intents with their smart contract wallet when the intents satisfy like very restrictive requirements like the attempts can only be single domain which is the domain your smart contract while it is deployed on it only can use and enforce information relating to the user account so I can't like you know really attest to information about like other stuff going on chain or other transactions and also like I can do some gas reimbursement stuff because it's like hand tailored into the account abstraction protocol and I think this is also why the account abstraction spec is like a little ugly and the spec is very long and contorted and it feels like the way they came about to the spec is the people who designed it they took really common user intents that they would think normal users would want like rate limiting social recovery gas abstraction and things like that and then they hand crafted a protocol to express and enforce these specific intents so they kind of like started with like what are common things users want and then like let's create a protocol to like let it happen let these intents be expressed and enforced and it's like semi-general but it's like very user focused which I think is super awesome but it's like not that General and I think there's actually many examples of like intent specific apps so for example like a lot of users have like very common desires right like I want the cheapest way to get frog coins or like I want the cheapest way to get monkey pictures and so you have these intents that look like okay I want the best swap or I want the cheapest jpeg or I want the best yield and then there's these classes of intense specific apps like Dex aggregators nft aggregators yield aggregators that help these users like Express and then actually like enforce their desires for these intents and so one question is like okay maybe account abstraction and intense specific apps are enough like do we really need this General language like maybe all intents of users are like generally pretty simple they fall into these really simple buckets like why do we need this like General abstraction and I actually think like even for really simple user use cases intense specific apps have a lot of limitations in a very multi-chain world so say my goal is really simple like I have eth and I want to buy as much broad coin as possible using the liquidity across all the roll-ups so with account extraction bridging and like the bridging solution I described before now I can really seamlessly and instantly use my favorite Dex aggregator on any roll up but one problem is I still have to find the best Dex aggregator across all the Roll-Ups myself so I have to know like which rollup has the most liquidity and then if the liquidity is like really fragmented and spread across all these Roll-Ups then I'll have to like manually go to each roll up and do the amount that I want but with intent bridging or like some form of generalized system I can just tell the mempool like I have eth and I want to buy as much frog coin as possible and then basically some like really clever Searcher who's put in a lot more work than me in this like multi-domain Dark Forest they'll just find a solution and like hopefully be like fairly optimal because they're being incentivized to do so and so I think in this like multi-chain world even if you look at really simple stuff like a DEX aggregator it's really infeasible for one company who's running a DEX aggregator to integrate with like all these new Roll-Ups all these new domains and so like these intent specific apps don't really scale that well in a multi-chain world but I think having this General flexible language for intense actually does scale really well because it's a more permissionless system like you don't need a whole company to be filling one to be writing the world's Dex aggregator that incorporates Every Chain instead you just have these like pool of Searchers and like maybe some Searchers are specialized for a certain class of Roll-Ups and other Searchers are specialized for other ones and they are they're all competing to basically serve the user and so yeah my final point is like cross-domain intense is actually really useful and it's like much more powerful than vanilla account abstraction and it's even very useful for even like pretty simple use cases so I think intents are like really needed and there's definitely like a lot of open questions like how can you show what's optimal is it even possible like what will the intent language be is it just a variant of user Ops like will most intense be similar or different where will the cross domain intents get posted like where does this all happen how did the Searchers know like what to search for which leads me to my final part of the talk which is talking a little bit about Suave so I think Suave is basically like a way to make intense happen I know there's like some other proposals out there um and yeah a smart man who I believe is in the audience once said Suave is just a global bulletin board for preferences that sophisticated actors who understand the risk can compete to execute across domains so here's like our previous account abstraction diagram but now I've like really ugly like done some really basic Photoshop and shown a bunch of users in a very multi-chain world right like you have users on arbitrum optimism mainnet they all have these user operations they're contributing them to this alternative mempool and now you have a bunch of executors and bundlers who are bundling these user operations cross domain and bundling them and basically Landing them on chain and if you squint a little bit and you see this like tradition this picture which I'm sure you guys have seen many times for like what is suave and like this picture comes up a lot you can kind of like squint and overlay those two things and you see that okay the account abstraction alternative mempool and the user operations look a lot like this preference environment then the account abstraction bundlers look a lot like this execution market and then the bundles of user obstacle a lot like bundles and then yeah so I don't have like too much you know that's like very formal to say here other than I think these ideas of like multi-chain icon obstruction and like Suave and intense are all like very interrelated so what's like my main point here and bring up Suave so I've noticed and I think a lot of you would agree that a lot of discourse about intense and Suave is like very academic it feels like there's like a lot of researchers and then they often view swab and intense through this lens of the Mev Searcher and like the power user they're like okay there'll be this user they'll really want to land their transaction across two different Roll-Ups at the exact same time and they like talk about these users quite a bit and I think I've like never really heard Suave and better ux for like the Normie user like mentioned in the same sentence and I think my thesis with all this stuff is like the normies actually really needs Suave too like cross-domain intense and SWA is critical for ux and I can act I actually think it will make a big difference for ux and is really important for the average user like not the searcher and so my final point is like account abstraction has been really excellent at thinking about end users like they how they made this protocol it's kind of like they took really common end user intents like okay my Normie user doesn't want to care about gas my normal user wants rate limiting minor muser wants white list Blacklist and then they made this like kind of complicated somewhat ugly like handcrafted protocol uh to serve these common end user intents in mind which is really great and then intense and Suave is like kind of on the other end of the spectrum like it's this very general thing it's like very flexible and basically I think a lot of those ideas are actually really useful in making something like a con abstraction more General and more powerful and also a better ux and so my kind of plea to like all the flashbots people here and all the people thinking about intense and Suave is please think about the Normie users and I think in this world where intense and Suave actually do end up thinking about the Normie users cross chain bridging can and will be like 100x better in the future and hopefully the Normie user doesn't even really need to know like what a bridge is it's all very abstract and thing it just all the money gets pulled and routed to like where they want it to be and they can just take the actions they want to take um yeah so that's my talk [Applause] 