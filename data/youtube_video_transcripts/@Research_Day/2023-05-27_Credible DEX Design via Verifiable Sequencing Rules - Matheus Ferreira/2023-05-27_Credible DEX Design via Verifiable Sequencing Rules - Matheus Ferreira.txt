foreign thank you um yeah so um I'll be talking about this work uh with joint work with David Parks uh so in this uh work we ask about uh very similar to what Tyrone was talking about is how we can think about designing uh decentralized exchanges or D5 protocols that can be audited by users where they have guaranteed their they are not being manipulated by uh or Amity has been extracted from then um and that's the concept of being verifiable so a little bit of uh the the motivation where we need to go back and understand okay why do we care about um decentralized exchanges and the the traditional a way where you think about it um is um well with the central as Central as exchange you have to have give custody to your assets uh to some centralized entity where the decentralized exchange doesn't require that so you have limitations like FTX where you might you you rely on that centralized entity to uh to provide security for your transactions but the main limitation of the decentralized Alternatives that we have as we've been talking about today is uh the problem of Mev extraction or Market manipulation that happens on this uh decentralized exchanges uh and and I think here what's uh interesting question is how we can solve the problem without uh breaking the main thing that you want with that is that we should not rely on solutions that rely us to trust in a centralized entity because otherwise why you why you bother um so uh why uh Soca here how is it the design Works um here I often give this talk to people who don't even know what Bitcoin uh is so the the the high level ideas that the user expects from this interaction with exchanges that they're they think they're going to be sending their transaction to um to the blockchain into this contract but in fact there is many many entities in between and and that's even getting more complicated right we we have uh flash Bots or we have relays and and the interactions are just getting more complicated over time uh for the users though they think they're just gonna get their transaction executed in in the exchange but in practice you have Builders they are the builders they are promising they're gonna sequence transactions in a fair and honest way um and this transactions are gonna uh execute in this particular order in the exchange and here in this particular talk I'm gonna be focused on unswap like exchanges but uh it also works for our solution for removing Mev words for or the books on all the types of exchanges but like just keep in mind that the solution I'll be thinking about is for when you swap like exchanges and what goes wrong here is that uh the problem with only swap is that the Builder if they're being strategic what they can do is that once they see for example the transaction B2 wants to buy ethereum they're gonna buy a few before the user which makes the price of go up uh and and they immediately sell so that's what we call the Mev uh or it's the profit that's being extracted by uh this strategic builders um and here just a picture of that where I'm often going to be using this uh pictures where I'm gonna use this blue arrows no transactions for users write errors transactions from uh strategic Builders but in practice the users don't see they can see what what what's a blue edge and what's a a red one and this ad is moving to the left is just buying some token and ads moving to the right is selling tokens um and the mbv that's being extracted from uh these exchanges here have a a graph showing how much has been extracted from uh in the ethereum blockchain this is just not only only swap but most of the Mev is currently on on that so what can be done what's the problem how can we have been approaching this problem so there's a few Solutions um the one of them is the this idea of batching options like call swap where the ideas that yeah we are just gonna set up transactions at the same price for everyone and intuitively that means that uh everyone is going to pay the same price then you're not going to have any fee and there's a few challenges of that there's often higher costs higher latency and you also have to design your essentially design a new exchange if you're implementing a batch auction um something that's also very common in in probably in in this in this conference is what we could encrypt transactions where if transactions are encrypted and people don't know what your transaction is and then then that's remove anything but there is a we should have seen challenging actually implementing these Solutions in practice one problem if you're encrypting a transaction you have to eventually decrypt it uh and then you have to uh to figure out what should you do if someone doesn't decrypt that transaction so there is uh it's nice in theory but there is a lot of challenge to make this work uh and what the I think the main solution that we really have is is we could use a relay service right flash Bots and but that's not auditable right you you really have to trust this centralized entity now to really not be manipulating um the execution ordering of transactions uh and that's so that solution is very efficient right we we really requiring this entity to do out the computation of chain and if you can trust it then um that that would be great so that's really what Inspire uh us to think about this problem of the Mev extraction is how could we build something like a relay that can be trusted um without relying on complicated cryptographic tools so our solution is essentially going to be a game theoretical solution and a mathematical game theoretical solution that doesn't rely on like Advanced crypto like NPC I'm not against that it's just that I don't I think there's a lot of Challenge on how when you implementing that and and again I think all the solutions that can be combined there's no reason why we can combine the Solutions in practice um and I'm going to give you a solution how can you in particular focus on building relays that can be trusted by users so the solution is as before what we're gonna have is um a sequencer which is this entity that's really promising he's not going to manipulate your your execution ordering of transactions so he's going to make a promise that's not going to do it but in part importantly he's going to give you a way for you to verify that promise that he's giving you um in the sequencer he's still gonna be able to uh include transactions in the input because the sequencer is just this and this like algorithm that picks a set of transactions he's just he can still add his own transactions there and you want to ensure that you can design a sequencer that even if it can manipulate the input he cannot be profiting by picking uh um a particular execution origin from the output so our main result here was that um we proved that there is a mice sequencer that ensures that for every transaction that is executed uh that transaction is going to get an execution price that's at least as good is that that transaction was the only one executing right so that the the setting where the transaction is the only one in the block so this is what it's saying you either get the price you begin if you're the only transaction executing or you might be getting a worse price than that price but provably no one is gaining Mev from your transaction that's the approvable guarantee or a equivalent statement here to take the converse of the statement is that if someone is extracting Mev from your transaction then the price you're going to be getting is at least as good as your transaction was the only one executing so it's a very strong like guarantee that a minimum execution price guarantee for the users that we are providing okay so a little bit the background what we mean by a verifiable uh rule uh first the model so the model we are only going to rely on our algorithm can only rely on the particular information it only rely on the fact that transaction is either buying or selling uh token one or token two so we have two tokens one or two so every transaction is either buying or selling and we're not going to rely on timestamps at all um and the row can also rely on the volume of Trades but the rule I'm going to give you actually doesn't even rely on the volume it's just going to rely on the fact if you're either buying or selling a token is not going to rely on timestamps so a formal model what we mean by a sequence row a sequence row is just a function that's mapping they State on the exchange so X is the state on Foreign Exchange which is the liquidity that's stored in the contract and and then we are going to have all the inputs is going to be the set of transactions that go into the the function uh and at sequencing room is just mapping this state and the set of transactions what we call a valid set of orderings um so it's the abstract mathematical Constructor sequencing with just a function mapping a state and a collection of transactions to valid orderings in the sequencer the person is going to be running this function right he can add or sensor transactions he can he can modify the this particular set T1 to TN and some things you you want to have for practical reasons it should be efficient to find if I give you a function it should be efficient to actually compute some ordering right someone if you want someone to run your your sequence or they should be able to compute it efficiently um and it should be verifiable and that's very important here uh that's really the catch what you want is that if someone later he posts on for example in the blockchain uh that the execution ordering is is this particular ordering T and the initially stage on the exchange was X someone should be able to check if this execution ordering you're seeing really belongs to that valid collection of orderings and that's really important here because otherwise someone could if it's not verifiable there is really no point in polynomial time because again we care about being practical so okay one what would be a girl a dream um sequencing Brew would be a sequence rule that's aim is the proof which means that no matter what how uh so given a set of transactions no matter how the person running the sequencer modifies the input there was there's no way they can obtain some risk-free profit right so that would be a definition of Mev right you should not have any Mev um so unfortunately we first shown this work that is impossible uh you cannot have a sequence Pro that's Mev proof although I show you that we can give a very strong guarantee the guarantee we give doesn't mean that there's no Mev what because what we do is that we remove bad muv we remove sandwich attacks things like that we don't remove things like Arbitrage between transactions so that's what we mean by being impossible to have a immedi approved it means that any sequence row is at least vulnerable to our Arbitrage NBC uh here a quick approve I'm not going to go in details but for those interested um or my drawings are not working but in a high level idea what we do is that and we pick a particular example with this example with free free identical buy orders or you're buying two units of token one and three identical sale orders where you're buying one in one unit of I saw your selling one unit of token one and we're essentially what you do is you show that for any particular ordering that you pick there was a way to assign some of those transactions should the sequencer the person running the algorithm and you show that if he on those transactions you would be getting a risk-free profit so that's essentially the impossibility result so you just check out possible permutations and show that there is a way to extract Mev so now I'm completely give you the uh the the rule that gives the positive results that I I mentioned and what we do is that okay initially we're going to have the initial State on for example in swap um they could be other exchanges but when swap is easier to to describe uh and we are going to have the setup transactions that we we want the sequencer to sequence uh which we call the set of buy orders and the set of outstanding sell orders uh and the output of the algorithm is the execution ordering of transactions is the order transactions are going to go to The Exchange and what the algorithm is going to do is that while you still have buy orders and sell orders that you still have to sequence um then use simulate what the state of the exchange is going to be after you sequence the the so you look on the transaction you have a red sequence and you simulate what the state of the exchange would be at that point and you look on the amount of token for the token one that was at this particular State relative to this state on the beginning of the block and if that's true that means that buy if you execute a buy order at this particular point in time that my order is going to actually be happy it's gonna get a better price um than he would be getting if he was executing in in the beginning of the block so what you do you add the constraint that the next transaction to execute must be a buy order wise you either constraint that the next order to execute should be a sell order eventually you reach a point where you don't have more outstanding buys and sells which means that you only only have buys or sales left and we say that you you can let the sequencer do whatever he wants at that point um here so an example so if you have a set of uh free buys and free cells uh from the impossibility results so what you do you um so in the beginning you can sequence a buy then you then you are forced to sequence a cell then you force to sequence a cell then you first then you can either buy a sequence a buy or sell uh and then you're forced to sequence a cell and that in this point though you don't have more uh cells left which means a sequencer can do whatever he wants but you only have a buyer order anyway so you you sequence I'm buying um so another example of why why does this remove Mev from uh for example a traditional sandwich trait so let's assembly straight you have the users buying a token uh what the the adversary is doing he buys before before the user and then he immediately uh sells um so what you do uh so this particular ordering is not valid so why is that because once the sequencer buys a token token one uh the rule says that the next order to execute must be a cell can it cannot uh it cannot be a buy because you still have outstanding buys and sales so this would be an invalid ordering that anyone can check and verify is violating the rule um what the sequencer would force the the sequence will do is to force the this the sandwich Trader to immediately sell if they if they try to sandwich a transaction so and by that it really doesn't get any profit from that so the only valid orderings are the ones on the right uh and and you can just check that any of those are you can extract any you can't extract any Mev from those uh trades so a highlight of idea of how you prove the guarantee so recall the guarantees that for any transaction uh that executes uh if m is the extra is extracted then that transaction is getting a good price the high level ideas that we divide the ordering that you see in two groups we call one we call the core uh the core are the transactions that are being sequenced when you still have buys and sells to sequence after uh and for those transactions almost by definition that they are happy um for detail are details the transactions where you only have buys or sell left uh and here essentially what you argue is that uh this sequencer he can actually lose he can only lose money if it tries to extract Mev from transactions and detail um so so for example if the sequencer the malicious sequencer has a like Buy Buy Buy it actually would rather have his buy order be the first one of any user transaction and then you only have transactions between the user after in transaction from the adversary but that that essentially means that you're not extracting me fee right because you're not executing any transaction after the user and um the sequencer is also efficient to compute is essentially just a grid algorithm and it's verifiable because you you can check if if they're I mean yeah it's kind of you look on almost by definition that's verifiable and the impossibility um so it's the same example as before um so why is this show why is this sequencer issue vulnerable to me well it it gets Mev from Arbitrage from the user trades because for example here if the sequencer owns transaction B1 and these two cell orders in Rand on average he's he's getting some profit by doing this so every every transaction is actually but but what we do okay look on the point of view of the user the user is actually happy right so this user is getting a good price this is getting uh even better price that you would be getting out your eyes this uses the last transaction is actually getting a worse price but their sequence the sequencer really doesn't profit any he's not really profiting anything from from that transaction he really doesn't care if that transaction was even there so to summarize us we give uh in this so just in this in this research agenda we're really being thinking how we can modify these interactions on this protocol so that they become more robust to these manipulations uh that happens on blockchain contracts um in and we can prove a strong guarantee on on on this particular framework um I think there's some interesting questions uh for example the impossibility result only apply for deterministic rules like again I think it's an interesting uh Direction here how you can combine other tools like Randomness or like you have like time stamping uh I think those those could be ways to go they are read the impossibility um our rules also apply for two token exchanges like one swap but not more um and and the sequencer can still get some profit it's so interesting to uh potentially if you wanna that's still Mev but it's not bad MVP but you still might be interested on how you can want to find that uh so uh so this is work again David Park um and be presenting at stock and next month I I heard was the first blockchain paper at stock so I think that is definitely a lot of interest in the research community on this questions that come out of this community uh I think there's a lot of potential like collaboration so thank you very much if you have any questions I'll be here [Applause] 