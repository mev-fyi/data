this part is about how you would implement or how you can implement smart contracts on the plasma system the plasma system is a scalability solution and it makes some trade-offs and we will see that not every smart contract will be directly usable on plasma but yeah let's just okay plasma is a scalability solution proposed by Joseph spoon and with a reboot ring I think in August this year I will start at the very beginning and explain what block chains are and what I mean when I say state and when I say transactions and we will see that block chains are a bad idea because they can only process a limited amount of transactions per time for a second and then we will see that payment channels are one way to take some load off a blockchain and we will see that the block chains only act as verifies and not as processing nodes and this is already a good start and yeah then we'll see how payment channels can be extended to be child block chains and how this can be reiterated to create trays of block chains and that's what the plasma system is about and then we'll see how we can implement or that the key to implementing scalable smart contracts on plasma is to transform global invariance we want to have but which we cannot check in such a smart contract into local invariance which we can check and we'll see examples of the source code of an example contract which implements a token on plasma ok blockchains we start with the first part of the word blockchain which is block and let's just view it as a bunch of data but and then here comes the chain part in the blockchain each block references its predecessor using a hash pointer so a block contains a cryptographic hash so a fingerprint of its direct predecessor and that's how blocks form a chain they can also form trees but we know that for now and I said blocks are just a just a bunch of data and more exactly they contain transactions and in order to explain what transactions are I have to tell you what stages and in the example of a blockchain that is used as a currency the state is usually just a list of participants a list of accounts and their respective balance at a certain point in time so Alice has ten tokens Bob has seven tokens Cindy has twelve tokens that David has eighteen tokens and then we have a transaction is that large enough so in the transaction always contains a signature here it's signed by Bob and yes since only Bob can create such a signature we know that Bob sent the transactions so Bob is the assumed sender of the transaction and the transaction has yeah basically calls a function it runs an operation and this operation is transferred to to Ellis so Bob wants to transfer two tokens to Alice and when this transaction is included in a block then its effect on the state is calculated and the effect is that Alice the the balance of Alice seen here is increased by 2 and the Palliser balance of Bob is decreased by 2 okay that's how block chains work let's take a closer look at the B transfer factor so plasma requires a smart contract in a block chain so and it doesn't work on a special-purpose block chain like Bitcoin and because of that we will always view these so this this transfer function is a function that's actually implemented in a smart contract on this blockchain smart contactor just programs running on the blockchain and here an example imitation of the transfer function it has two arguments amount and recipient and right we already used two properties that we usually assume a tokens system has we two properties that a currency has and one of these properties is that okay perhaps three so people or accounts owned amounts in this currencies are also tokens and only the owner can send these tokens somewhere so nobody can take away your tokens only you can send token somewhere and that is basically realized by this signature here and the second property which not all tokens have but most useful tokens have is that your balance can never be negative and this is the the main check here that is performed in the transfer function example so it checks that the balance of the sender is at least the amount the sender wants to send and if the check works out then we have the effect the amount is reduced from the balance of the sender removed from the spell of the sender and it's added to the balance of the recipe okay yeah as I already said the main problem here is that we only have a small number of transactions per block and thus only a small number transactions per second and yeah payment channels can help a little here and the main idea of a payment channel is that if we have two people who constantly send money back and forth then it doesn't really make too much sense sense to store this intermediate state on the blockchain it's much better I mean if you if you already know that it will send money back and forth in the future and it's much better to do that not on the blockchain but somewhere else and then just only I don't know once a day or whenever just store the current state on the blockchain so we can have a blockchain here which we call the main chain and there's a special read transaction which calls a function called open channel and the transaction is sent by Alice and it initializes the channel with an initial balance of 4 LS of 10 and the digital balance for Bob of 0 and this is a channel between Alice and Bob only Alison for participated this thing and of course the the underlying smart contract would check that Alice's balance on the main chain is at least 10 otherwise she wouldn't be able to have this issue a balance on there on the payment Channel okay and what happens now so we get this payment channel and now we can send transactions inside this payment do not reach the blockchain so they only exist on this diamond channel so we have a transaction sent by Alice here they are again signed and it caused the transfer function that's the function we already know but now it's run on the payment channel and at least once transferred three tokens to Bob and what headus also does and they actually blocking the screen for some of you all the time I'm sorry about that when as also does she denotes the the state of the payment channel that yeah it's as soon after the transfer as part of the transaction so Alice's initial balance was 10 and she sent three tokens to Bob so now she has seven and Bob has degree and Alice decides it so transactions that this whole transaction which means she confirms that in her in her opinion this is the current state of the payment she'll and she also adds a number to the to this transaction the payment channel which is a sequence number that is incremented every transaction now Bob can send a similar transaction where he transfers two tokens to Alice the increment sequence number updates the state and also science a transaction okay perhaps you might ask that this is a quite stupid example if I have two people who send money back and forth all the time why can't they just agree on how much everyone gets and that's about it the idea is that of course these transactions here they don't appear in isolation there's always something happening in the real world or in the real digital world that triggers such as act for example Alice and Bob both have data storage and they just store data for other people for example for Bob or Sohail it stores something for Bob or Bob stores some data for Alice and they request data from each other and each time and this requests 50 megabytes from Bob Bob sends one token to Alice and then at some later time Bob needs dead from Ellis so he pays for the data and so on so that's one of the purposes of such a payment I'm okay now time goes on the blockchain continues and also the State Journal continues and at the transaction number 80 Alice has four tokens about the six tokens this is confirmed by Ellis and at some point they decide okay let's let's close the connection and close the channel and what happens now is that Bob creates a transaction on the blockchain so this is this is the sec transaction that happens on the blockchain this was the first and this is a second and Bob calls the closed channel function appends the current state of the state of the channel as noted here and also the signature of alice from this transaction so this signature here is the signature of that transaction and he also signs the the full blockchain transaction so and this means we have a confirmation from Alice that this is this is the current state of the of the channel and confirmation from Bob that he wants to close the channel and he also confirms this state of data so there's one thing that could go wrong now and so Bob does have a signature from Alice but the blockchain doesn't really know whether this is the most recent signature of Elsa well that's the most recent state of the state channel of the payment channel for example pop could have taken that this signature here I mean that wasn't really wouldn't really be beneficial for Bob because here we get six here he gets only brief but yeah you get the idea I guess and so Bob can do that but then Alice has the opportunity to also send a message to the to the blockchain and so okay when I forgot to mention here is that of course we also have the sequence number here because that's also part of the transaction game so Bob also sends the sequence number of this signed transaction and what Ellis cannot do is send a transaction signed by Bob with a higher sequence number than the one specified here Alice can produce subjects and transaction then the blockchain knows who you okay there's there's actually more recent version of the state channel that was confirmed by Bob and now also confirmed by Alice and that's how the blockchain will close the channel you are not allowed to be offline during wireless tech channels open that's yeah you have to watch the blockchain all the time because the other party could try to close the channel you should close the channel before going offline and sure but someone is usually offline that could close the channel for you so if you have I mean this also depending the Alice loses at most ten tokens when she doesn't close the when she doesn't watch the blockchain and depending on how money is involved how much money is involved you can run different servers in different continents if you want to be extra secure and so I think that that should work on the question [Music] [Music] exactly this is a chapel only between two people so there's there are there are only two participants and they can send money to each other that's you mean Bob could try to close the channel with LS 10 Bob 10 step what you mean yeah yeah so the the closed channel function checks that the sum of these two balances equals the sum of the two balances here yes okay we we saw that some of the protections here in the main chain were removed that's why they are so they they removed here but the blocks are still quite full here and the reason for that is we can use payment channel pennants only between two people and if we want to allow an arbitrary number of participants we have to go to something called yeah sight trains or child trains or what have you here so these child trains are very similar to payment channels the difference is that they run a full block chaining block chain protocol instead of just this single payment channel and you usually do not close them but instead at regular intervals you just post the current state of the chain into the main chain okay let's take a look at that okay we hi we again have a block chain which we call the main chain and there is a special transaction that is called new child and when this transaction is sent to the main chain you can yeah aah I've chained is created so and this depends on your setting but usually these child chains would not be operated using proof-of-work but for example using a fixed set of valid data so they are I don't know five accounts in the world and only these accounts can create the blocks yeah they come together call this new child function on the main chain and then they start creating their child chain and the the first block here refers to this creation transaction the main chain and after that the blocks just referred to their parents in a regular blockchain and they contain for transactions they contain smart contracts whatever you would like okay and now yeah so as I said it's a full blockchain so it it also has state and the the way this reduces load from the main chain is that the state is only stored the child chain and not in the main chain yeah this is due to limited screen size that's of course a bad example because usually the balances would start with zero but yeah let's let's assume that's the current state of the child chain we have four accounts there it's open to everyone so people can just go there and create new accounts I'm currently at these four and then we have a transaction Cindy transfers two tokens to Bob it's the same times actually we had in the previous example on the main chain and the effect when the state is that Cindy's balance is reduced by two and Bob's balance increases by two and so now the interesting part is that we also have these special transactions on the main chain which call a function called store hash these these functions are caught by the people responsible for managing the charge chain and what it does is it just stores the hash of the recent Block in in the main chain it does not store the full state just the hash of the block which also includes the hash of the state but it's yeah very little information and since since these the people that are responsible for the charging could just store any hash here there is a mechanism where any user can object just as we had in the payment channel so when Bob wants to close the channel Ellis can object and then a process decides whose faculty was wrong this is a bit more complicated I will not go into detail here but there is a mechanism to object it takes some time and you have to also have to yeah provide a little time for people to react so when someone calls door half here on the main train we don't really take that for granted immediately but only after some time and [Music] these child trains also have special sections and one of these special transactions is a transaction called to parent this can be used by participants in the child train to send tokens to the main chain and here Cindy wants to send two tokens from the charge onto the main chain this effectively reduces her balance and it looks like the tokens would vanish but that's not the case because she successfully executed exactly the transaction and this means it's stored inside the history of the child chain forever and what Cindy can now do she waits until there's in the next store hash call on the main chain we have it here and now we have a a hashed arrow pointing from this main chain block backwards in time to this child chained to this chai chain block and this child chain block in turn points to the block that contains the two parent transaction from Cindy and this essentially means that the main chain at this point is aware of the fact that Cindy is successfully initiated to this token transferred to the main chain does it look like we understanding what I'm are there any questions so currently we only have this relation between the main chain and the charging if you have multiple parallel side parallel type chains you can use this mechanism to send tokens to the main chain and then a reverse operation to send to one dimension to this other Junction yeah that was a bad example as I said so the state is usually empty when you create a chain of salts with an empty state so no one has any balance there and then you can start moving tokens from the main chain into the charges this question you're asking who the sender of this transaction is this one okay it doesn't matter it depends on the objection mechanism but one way would be that this new child call would contain a list of addresses who are allowed to set the the hash at the later point of time so nice a question it depends on the setting if you also use a proof-of-work chain here and verify the proof of work in the main chain [Music] so we saw that yeah probably I should have started explaining how you send tokens from the maintained sorry about that so Sydney had ten tokens here and they disappear user with this to parent transaction so they are completely gone and okay let's perhaps that that's continued here what happens in the main train then I'll finish answering the question so we have this store hash function here which means that the main chain can look into the history of the child chain and see this two parent transaction so Cindy's tokens become available at this point and this allows Cindy to actually spend these tokens so and yeah perhaps this should not be called transfer but finished sending from childís I think that so at this point the tokens reappear here they they disappear and here they reappear in the main chain so you and in a similar way if you send tokens from the main chain to the tire chain they completely disappear in the main chain and it's impossible to spend them because they are just gone No so not at all I mean actually so this is again due to lack of space in reality Cindy has to wait for some blocks to be added here because she has to wait that someone could object to this store hopper store hash operation here and only after some time our passes nobody objected then this is assumed to be the current state of the type chain and people can use this if these are the people want to trade want to transact with her and that charge and you have to transfer it yes I mean it it depends so there could be special-purpose child chains were for example some Chow chain contains a decentralized exchange with very high volume you move the tokens there you transact there and you don't need to move it somewhere else yeah yeah sure it's always afraid of you don't get our choice to get a bit of scalability for free but so the question is already pointed into that direction how can we increase the number of charge chains here and the way you would do it is you create a tree of block chains so in this diagram there's no there's no component of time we have a main chain which would continue somewhere here and then this main chain has three charge chains each of them would continue somewhere here and then these three child chains again have three child chains and again of course if you want to move tokens around here this involves quite some jumps between chains I took at your point yes but you could also let me think you can also create a payment channel between this chain and that chain you're only so you don't have to move up and down again you only have to wait until the the state of this chain got committed here and there and then into the main chain and nobody objects then this image 2 Chainz is established okay before I get worldly to do so what happens here is that so we have this main chain and we know that through child chains and this means that this child chain regular regularly commits its current state into the main chain and and then we know this child chain we have another set of child chains could treat that parent chain as their kind of maintained and so every if every child [Music] stores their current state at regular intervals in their relative yes so there is a kind of incentive to move common parts into the same child chain yes and I guess that is something that could be done I mean of course a smart contract blockchain always has special-purpose small contracts and then it also has general or then it has contracts which provide the glue between some special-purpose contracts and these glue contracts are for example token contracts if you have a token then you want to use it with all kinds of different smart contracts in different different chains and these tokens you have to move between the chains but there's special purpose contracts eternally okay and how am i how well does it state so let's assume the main chain and also each child chain has ten transactions per second is roughly the bandwidth of etherium and Bitcoin we already told about the over hat that comes in comes with moving tokens around and also committing the state hash and probably also objections and resolving these objections and so on but since these child chains are special-purpose and since they are probably not proof of work we I think it's reasonable to have something like 100 sections per second including this overhead and so I think ten transactions per second is good so we we have four levels in this tree on the left in the diagram if we add two additional layers into that tree and we have ten transactions per second then we have two thousand four 30 transactions per second in the whole system which is already above the number of transactions the visa system is said to be currently processing and if we double the number of levels I mean it's exponential so perhaps we can't really double that then we reach 1.7 million transactions per second so then again it depends on the kind of charge when you have the transaction center but you don't use all the chains we will get to that there was another question here I mean it depends on how often you do that I mean moving moving so the the child chains very very far down are probably extremely cheap in terms of transaction costs and the main chain is the most expensive and so you kind of so moving tokens around takes a little time because if you wait for these objections but it's not too expensive and so if you have to wait ten minutes for the tokens to radically it depends I mean if you're fine with waiting I mean it's a super transfer we wait a day for that to settle with six layers we need six transactions to go up how do you move them so it has to be a built-in feature of the Aria basically it depends on the token but with a generic token that is not built for that it is just moved into a special account and it's locked there until it will be used again what do you mean by belong so each each line in this diagram means that the bottom part regularly posts its state to the other part in that sense they do belong to the chain so they can't be a second main chain that has the same time these are completely independent blockchains which run on the peer-to-peer system but are related I mean not completely independent but it's a different system with a different Genesis block but they are related to each other by regularly sending transactions meet me load will get to that okay because let's discuss how it is safe so this system only scales if I mean that the main problem of block chains is that everybody has to verify every single transaction and this system only scales if this is not the case anymore and so the idea here is that people are interested in some chains for example Ellis has tokens inside this tiny sub chain here and in order for this to be safe and safe here means nobody can steal her tokens in order for that to work she has to watch her chain verify her chain and all the parents of that chain and so because if someone tries to sneak in an invalid state transition here embedded block what Ellis can do is that she can object in the parent chain and because of that come to your question if someone creates an invalid block in in some of the trains on the way from Alice's chain to the to the main chain then this also destroys the state in all of the chains below that because that is the point where you could object so if you destroy the state here and someone attacks that chain here then you can object here anymore because this is kind of this change is already flawed anything can happen that's why you should watch I mean okay of course it's not always you have to watch you can also ask others to vote for you and so for example Bob has talked it's in these two sub chains and he has to watch these chains and here we already see the closer the chain is to the main chain the more likely it is that others are also watching actually so this in turn means the closer you are to the root chain the safer it should be because more people are watching so if alice is the only one watching this chain here and somehow our computer breaks and she gets off line then she's unprotected but if she has tokens in this chain here then Bob is still watching it and I think Charlie who will be later in the game okay now let's take a look at the specific example of a token what does it mean to commit fraud in a token system we already talked that about that little in the beginning so one of the assumptions is that so what should not be possible is that someone else moves your tokens if someone else moves your tokens this is fraud and you should be able to react to that and we assume that you watched all the chains that contain your tokens and since you can always object in the parent nobody can move your tokens except you thank you and the second thing that is perhaps not so obvious is actually more complicated to ensure and this is nobody should be able to create tokens out of thin air because if I have ten tokens and someone is is able to create 1 million tokens then my tokens are basically worthless and also that too that that person can buy stuff from you actually paper so but this is a problem you so we assume that this token smart contract is deployed in all of these chains here and let's see what the next thing is yes charlie for example uses this chain here and we assume that he's the only one using that chain so he can try to create arbitrary amount of tokens and if nobody watches then he will actually have these tokens inside that chain and the only way to prevent that is again everybody watching all chains but that's exactly what we wanted to avoid right okay there is a yeah kind of solution that does not solve this problem but it solves a similar problem and the idea is okay right the idea is that okay Charlie can create tokens here but we can't really use them because he has to move them to a chain where someone else is or he has to convince other people to come to his chain and that's the key to the to this problem to the key to the solution because yeah moving these tokens will be difficult if we do an additional thing if we track the balances of each direct sub chain so let's see how that works so in the token contract of the main chain we store that inside this left branch we have a total sum of nine tokens and this middle branch may have a token sum of eight tokens and this right branch we have a total sum of five tokens and we do that in our chains I just didn't write the numbers here because the front would have been too small so okay you see that these numbers do not sum up to nine and the reason is that some tokens are also stored directly in that chain these numbers only track the sum of the tokens stored in the charges okay but these numbers have to be that the sum of these numbers has to be small error and at least as large as the number on this line and what Charlie can do now is he can try to move his 1 million tokens up to the main chain and down again to Ellis or box chain but the problem is he won't be able to move it to the main chain so let's assume he controls this chain he also controls that chain and he also controls that trade he doesn't control the main chain and he has to invoke this transfer to a parent function and in the parent chain he has to invoke the complete transfer from child function and this complete transfer from child fund function basically he he calls it and says I want to transfer my 1 million tokens from this child chain to the parent chain but the parent chain knows that the total sum of all tokens in this chargin is only 5 so it's impossible to of 100 million possible to move 1 million tokens into the main chain because there are somehow only 5 tokens in this charge into somewhere something must have gone wrong already what your actually what you just said is just a specification of implementation of this concept so if you lock the tokens somewhere then this is basically counting the maximum of that you want to avoid that because if you okay you have one single account when you lock all the tokens or do you have one account per person to the photons because if you have one a couple person and just declare them to be lock then it doesn't scale yes but that's exactly how it works and but I mean yeah so I mean if you just use the generic token contract and deploy that that wouldn't work it has to have an additional functionality and that's what and so even that that's also something you have to realize so Charlie regardless of how you implement this mechanism Charlie if Charlie can't rank if Charlie controls these chains here then he is able to steal these five tokens from all the other persons because we assume that only this chain only the main chain is secure so if Charlie tries to move five tokens into the main chain even though he doesn't really legitimately have them he will be able to do that so he can't steal from other people but if this theft is then this in turn means that these people weren't watching their kids right because if they watch their chains then Charlie can't get that far up you can only yeah get as far up as you run blockchain time that's all it's of course it's all automatic yet these are just these terms that's out of scale Fiskars this so that's that gives it the details of the plasma system and it has to be soft with economic incentives in the end it will cost you to do such an objection and if you lose you will lose some money that's why I mean you can you can span the chain but it would cost you money [Music] but the same Macau the same we assume that they have identical code so any token contract that tracks the same token has identity hold on all these toy trains you can ensure that when you create the Train I mean as I said there are special contracts and then these glue contracts for example these tokens and probably have a native token in the whole system and at the point to create the whole tree the total contract is already there what did it was in the same so in a sense that the contracts are linked to each other why are these transfer to parent functions okay yes and what essentially happened here is that we had these two conditions nobody can steal from you and nobody can arbitrarily create money and the first one was a local condition the second one was a global condition but we were able to transform it into a condition which is similar but which is fully local or it's locally enforceable and it's similar because people can't steal money from you they only can steal up to this amount and they only can steal from you if you don't watch the chain all right now sorry people can so we were talking about the second thing so people can create arbitrary amount of tokens but only up to a certain point and only if nobody is watching okay yes and this is something that scalable smart contracts have to do they you have to if you want to write this scale it's not kind of advanced in such a plasma system you have to convert global invariants into local variants and now let's take a look at a very specific example this is how you could implement such a token contract very specifically it's specifically in the plasma system this is a slight variation of standard solidity and we have we have a token contract here it has a mapping of balances and it also has this special three integer values which attract the sums of the balances in the charges or which are where the tokens are locked and so and this first function is the regular transfer function that is present for all regular tokens so this can be used to transfer a token from one account to another account in the same chain you specify recipient and amount it checks that you have the required balance and then it removes the balance from your account and adds it to the recipients account okay now so and then we have these two functions transfer to child and transfer to parent these are special because they are marked with the edge keyword and when functions are marked with an edge keyword they are kind of executed on an edge inside this tree graph and this means they are executed both on the parent and on the child and on so this this transfer function when you run that in such a complex multi blockchain system you would specify which blockchain you send it to that has to be part of the actions otherwise people could just grab your transactions send it to another object you want to avoid it so every blockchain has a unique identifier and this has to be part of the time transaction and for an edge function you send it to a relative parent and to a relative child at the same time and what happens here is we have a a section marked parent in this code and this is the section that will be run on the parent and we have a section marked with child and that's the section that will be run on the child and they will run in sequence so they will not run in parallel and what happens on the parent part is that we again check that the balance of the sender is at least the amount we remove the balance the amount from the sender's balance and we add it to the sum of the balances in the child and that's where it stops for the parent and the parent will using using events in the register that this happened on the parent and then the system has to wait for the child to acknowledge the block where this transaction is present in the parent so it has to wait from a transfer of the state from the parent to the child and then this part can be executed on the child the the client will send exactly the same transaction that it sent to the parent it will Center the child and because the child locks in knows that it is the relative child it will skip this parent part but instead it will verify that the parent part execution happened so it will look into the into the state root of the parent blockchain and will request a local proof to verify the this that to verify this implicit event that shows that the parent part was executed now after that it will execute the child part and here yeah the the amount is just added to to the balance of the center so if you if the child blockchain would not verify the event in the parent blockchain you could increase your bands arbitrarily because it just said the transaction the parent part is skipped and this adds something to your balance but because it actually checks that the parent part was executed and the amount was reduced from your balance here this this is safe and we have a similar function that has transferred to parent here the child part executes first it checks that we have the balance it removes our balance the amount is vanishes completely but in the child chain we will have an event that stores the fact that this part has successfully executed and then at some some point in the future we have this store hash transaction that stores the current state half from the child in the child off the child chain in the parent chain and at that point the person that set the transaction can prove that the tripod was executed successfully in the child chain and that means that the executor from the execution of the transaction in the parent can skip the child verify that it was executing the child and then continue the execution in the parent part which checks that the the locked balance at the sum of the balance of the at least the required amount removes the amount from the child balance and adds the balance adds the amount to the send this balance in the parent chain so balance here and balance there are two different things so this is in the context of the tire chain and this is in the context of the parent chain but because the the contract that I'd are identical because they share the code this works between the two chains in the case you want to send token from a child very down to the maintain I mean as a single transfer from a child to a parent just requires yeah this this is period where the child chain stores its it's state has in the parent plus the objection timeout and if you do that multiple times you multiply that by the depth but you could also I mean yeah you could perhaps take some additional shortcuts and look deeper in there and go mad you look down multiple levels because you just have multiple levels of marketers like because it's suggestive we only have three big channel channels for like three children for every channel yeah I mean yeah the YouTube child the proposed specification I mean the number of children that doesn't really matter you just have to know the topology of the of the system and then I mean if he sends it to so a parent has to know who are its child children and the children have to know who is the parent but you can also have a dynamic number of children a parallel this is so the the objections are part of the of the base layer a part of the blockchain itself and a part of the of the smart contract here so so this this check that happens between these two sections that that should also include the waiting time for the section I don't know so yes that's abstracted away when we we assume that we have a blockchain system that works within with objections and transfer of information using these hashes and perhaps we have to wait for the time or perhaps there's a faster way [Music] transaction fees so I don't know that there are certain models you can have intrinsic tokens that you can just create out of thin air to pay for that service like you do in the proof-of-work block trains or in some prototype block transfer that again depends on the system I mean there's no reason why I mean that system can be implemented on a theorem right now and anyone could start touching there is a proposal by vitalik to add a certain pre-compiled that would help here but you don't really need it I mean there's no so there's just an issue that these operations might consume too much gas but you don't need a specific functionality probably not yeah polka dot charting plasma CK snarks ragin as a specific but also very different from from specific simplification of plasma okay so this system is tied to one specific main chain it's weaker in Security than sharding because it depends on these timeouts and anyone yeah but but at the same time it's also much more flexible because anyone could just create a charge and at any time for shouting that's probably not the case [Music] polka dot is not tied to a specific chain and price rather to be a mediator between different chains raven in its current state cannot be used with four smart contracts only for choking transfers there's this more general concept of state channels yeah does that answer your question yes you have to keep track itself basically executing the first part creates an event and then if you want to execute the second part you have to prove that the event has happened and then it work that it was not used yet this usage you have to use clarify more questions okay yeah thanks a lot for things like for attending the Meetup yes so we do not yet have a fixed date for the next Meetup also because there is this conference that has a lot of talks that have to prepare but perhaps we'll have the next Meetup sometime in December if you want to give a talk then please approach me and yeah I think this venue was a lot better than the the office I made also has some drawbacks but having a lot of space and a clear view of the presentation I think that's a good thing so yeah thanks a lot [Applause] 