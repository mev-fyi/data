[Music] okay I'd like to present to you a proposal for a smart contract programming language which is radically different from everything we've seen so far the main drawback is that it's still just a proposal and the the main yeah the main goal here is not necessarily to create a programming language which makes it easy to write smart contracts but more a programming language which makes it possible to write smart contracts which are easy to understand ok so let's take a look at how smart contracts are written nowadays in a language console Aditi yeah we have a as an example here a smart contract that has some kind of crowdfunding it's simplified so some some aspects are missing and so it starts with a mapping that stores the the balances of the participants so participants can send ether into this smart contract and it just registers who contributed it how much and then there is a a boolean flag called locked which can be set to true when the function lock is called so this function lock usually probably needs some more checking so that not everyone can call it but yeah there is a way so that the flag is initially set to to false and there is a way to set it to true at some point in the lifetime of the smart contract and while the smart contract is still unlocked you can send money to it using this function called funder and your contribution will be registered and still well this contract is unlocked you can also call withdraw if you change your mind and said I I don't want to contribute money there and if we just send you back everything you contribute it okay and now because this would not be useful like that there's of course more code below which is a little complicated but yeah I mean we we saw that everything works I can send my money there and I can also withdraw for some time until the point where someone locks the smart contract and then the money is there but it turns out if you take a deeper look at the stuff that does something complicated there there is a tiny line of code that says a lot equals false so it turns out there actually is a way to unlock the smart contract at a later point in time which means people could actually withdraw their money even though the contract has been locked before okay is that kind of clear so and the the problem here is of course that anywhere in the in the smart contract you can hide this tiny line that says locked equals false and then somehow yeah so if you if you want to find out whether it is possible to to only lock the smart contract once and not unlock it later you have to analyze the full thing and find every occurrence of the word locked inside the smart contract and I would I would say that this is a general problem of any text based programming language that variables can be referenced just by stating their name from anywhere I mean that's not 100 percent true for all programming languages but I guess the idea is there in all text based programming languages and the problem why this is weird is people when people deal with abstract contacts abstract concepts like programming languages they are still able to understand it because there is some kind of analogy to to the real world and I would say this this referencing kind of breaks the another analogy first so I don't know imagine walking the streets of Cancun and shouting Vitalik watering and with helicopter next to you that that's weird right that doesn't really work in the real world why should it work in programming languages so and yeah the problem is you don't see there's no visible connection between the declaration of something and the referencing something there are tools that do that so most I in most IDs when you click on a on a name it highlights where this is referenced where this is used or you can right-click and say find usages and something like that but yeah why do we need these tools why why don't we why don't we actually fix the programming languages and so other things people usually do is enforce modularity of software or encapsulation which kind of helps limit the consequences of their problem but it doesn't eliminate the problem and yeah this is one problem of text based programming languages and another problem of text based programming languages is that they always oh yeah they always have to use a certain natural language and I'm not talking about syntactic elements here like for loop you have this English word for there or function the introvert function I'm talking about the the names of identifiers so variables and functions always have to have a name and this name is always a word in a certain natural language and if you're not to provision in that language it's hard for you to understand the software and the humans all speak different languages and the way this is solved is that most people agree to use English but yeah this this kind of makes it hard for people who are not that good in English and so imagine you're you're such a person you don't just speak English very well and then software or a smart contract will look like this to you this is an actual language so bonus points for anyone who can find out which language it is and even more bonus points for someone who can tell me what the smart contract does I already heard yes it's Gaelic so and what does it do oh yeah sorry I forgot of course you can't say what it does without actually seeing some functions so here's some more code does that help yeah I guess you get the point so when when I explain a theorem to people I often use the analogy of a yeah a soda vending machine for example so imagine you have a soda vending machine that is somewhere in the public anyone can walk up to it and buy soda from it and anyone can go there and use it and even more so this soda vending machine is made out of glass and this means everyone which is common for soda machines you can see whether there are actually still drinks inside before interacting with it but even more you can also because it's fully made out of glass you can even see whether there is still change in the inside the machine so you see whether it makes sense to pay with with large coins or small coins and so on and you can even try to find out how it works because you can see it see every part that moves it's it's a little difficult probably but it's possible in principle and this is yeah this is unprecedented in software and we have a kind of similar thing with open source because you can actually see how software is written but that doesn't help you if some software runs on a server and you actually don't know whether that server was compiled from the source code but with if you know you may actually can be about that I think I'm running a little bit late so let me try to speed up and I would like to use this machine analogy and extend it into a programming language okay this is a Babbage smart contract it's very simple so you always have these dashed lines which are basically the the the casing of the machine and you can only manipulate it from outside of these dashed lines and what you can do is you can send ether inside that machine we all know it know that if there is a liquid that flows through pipes so you can pour ether inside that pipe it will follow the direction of the arrow or it will also always flow downwards and then it enters this gadget here which is a so-called splitter and it moves half of the ether that enters the gadget to the left and the other half to the right because the setting is 50/50 and then if there continues flowing in that pipe and at the end it's sent to that the the the ether that comes out of the left side is sent to this address and the ether that comes out of the right side is set to that address quite simple contracts concept doesn't do much unfortunately so let's take a look at a more complicated example we can add a lever to this splitter which allows that account here on the right to modify the splitting ratio currently it's set to 25 74 but at any point in time this person behind the account on the right side can modify this ratio okay it's still not very useful let's take a look at a little more complicated example people have been to Def Con one might recognize this again so I did a live coding session there back then and I wrote a small contract which does exactly the same thing as this Babbage machine here okay there are two sides the left side can only be used by this account and the right side can only be used by that account so there's a I call it seller and buyer I know I used the English language again but the difference here is that the fact that this address is called seller is not a inherent part of the language it's just a it's basically just a comment and you could have comments in different languages at the same time so both seller and buyer can send ether into this ether tank and both sides of the tank can hold up to ten ether and AD and they can also press this abort button which opens the valve here and let's see ether flow out of the tank and send it back to the to the person that put it in and the interesting thing now is that as soon as so these these things on the top here are floating switches they are currently off but as soon as both parties send the full ten ether into the tank the floating switch activates an open open opens the valve here at the bottom and if both valves are open at the same time which means if both seller and buyer deposit ten ether then the the combined twenty ether will flow into the bottom tank and at that point you it's visually clear I would say at that point if the ether is in the bottom tank there's no this abort button doesn't have any function anymore and this is something which is very easy to to see in this visual yeah using this visual programming language but it's probably quite hard to see in a text-based programming language another thing you can easily see in this diagram is that the upper part is fully symmetric with rigged regards to seller and buyer and only the lower part is asymmetric this is also something you can't really see in in text-based programming languages okay let's continue how how this works we have two other buttons that operate the bottom tank the the buyer can release the payment to the seller and the seller can refund the buyer which moves the her into a splitter and moves half the fed back to the seller and half of it back to the buyer okay that's how how how the smart contract works what's what's the idea behind this is an escrow smart contract so the seller sells something has to put up a deposit and when when the ether flows into the lower tank then the seller sends the item to the buyer and when the buyer receives the item she presses the release payment button which pays the seller and if the item does not arrive they have to kind of come to an agreement and one of the outcomes of the agreement might be that the seller just refunds the buyer which results in the seller retrieving the deposit again and the buyers already very good deposit again okay yeah so as I said this is for now just a common concept unfortunately there's not much more than this talk here but I welcome everyone to join the discussion we have a Google Group here and if you have any ideas about more gadgets please propose that in this in this discussion group and oh yeah of course I mean the idea is of course also to have a graphical IDE where you can select these gadgets and snap them together and connect them and but and of course you can also create smart contracts which have very complicated pipes running all across the screen this that the language doesn't prevent you from doing with that but you immediately see that it looks really really messy if you do that and so you're encouraged to create machines that look simple and are easy to explain okay that's what it thanks for your attention [Applause] [Music] 