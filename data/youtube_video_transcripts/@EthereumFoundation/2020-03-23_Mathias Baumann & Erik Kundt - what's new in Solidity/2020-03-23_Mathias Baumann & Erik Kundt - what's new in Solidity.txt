hello so yeah welcome to our talk my name is Eric my name is Matthias and yeah we are going to run you through some new features and solidity that we worked on in the past month and so we have the link to the slides on the slide itself and also this QR code we are quite curious if this works for you we tested it numerous times but you never know and every phone is special works yeah I mean at least it looks nice oh it did work apparently at least one person managed yeah so I will quickly run you through the agenda so first we want to talk about some language features the most prominent ones also we have introduced some compiler features like some changes there so and then the next point is like future development what are we like planning to do in the in the future and yeah so we will also have a Q&A session afterwards and so let's start with the language features they are quite exciting stuff going on there yeah we spend quite a lot of time on and my mic just okay a new inheritance system which definitely mean like there are no actual new features we added keywords and checks that you can program in a more safe way that the compiler does more checks so starting with override and virtual you know them probably from other languages C++ etc here you see a code written in the pre oh six oh version there's nothing special to see here you see we overriding the contract three times to the total supply function we always call the base function of the previous one and yeah nothing special here this changed in the new version to look like this basic so you see we have a virtual keyword would you need to specify if you want to override a function otherwise you can't override it and similarly have to specify override in the punch plain writing and virtual if you want it to be over aidable so it's not implicitly virtual again and and the final inheritance here we didn't specify a virtual because we don't attend intend to override again yes and so far we have multiple inheritance and 306 oh it looked like that there is again nothing especially exciting to see about this we have the RSC seven seven seven contract which implements also IRC twenty we just show the total supply function here with one implementation and in the new version you now have two yeah again hold on a second I'm slightly confused right ok so you see it's it's an interface that means you don't need to specify virtual because it's an interface it can't have an implementation and it must be overridden so no virtual required in the deriving function you need to specify all the contracts or interfaces that you want to override if you leave out one here it will be an arrow and the compiler will yell at you also if we were inheriting from two contracts with their own implementations then you still need to override it explicitly if you leave out the whole implementation the derived class it will also be in error so we want you to be explicit and to know what you're actually which based implementation you're calling or doing your own implementation then we're moving on to abstract contracts and 3:06 Oh again it simply isn't a simple example here we have total supply to find but not implemented and this well it compiles it gives you no error no code is generated for the total supply function because there's none and you will get an error if you try to new this contract but not before so you might have silently not working code in your engine compiler would not tell you and then your code dies you wouldn't notice now with after o6o we introduce the abstract keyword which you can see at the top and now you will get an error as shown here because you haven't implemented that function and you must specify abstract if you have an abstract function like without a body so it tells you here that you should either make this contract also abstract or you provide an implementation this propagates more safe code and you catch mistakes earlier in the whole process then a small new thing regarding interface inheritance you can now inherit from interfaces which wasn't possible before so you can easily show that the interface for ers b777 is also an interface for IRC 20 and yeah those are so far the inheritance features moving on to fall Bank and receive split thanks yes so in the fashion of being more explicit in your contracts or in contracts in general we also decided for a fallback and receive split so I will show you what that means so this is a pre oxo contract with a fallback function defined and this is called for both so for non-existing function signature or if there's an ether received so what's what 17 years if you send any ether the six a transaction is successful and the contract keeps the ether so we decided to split it up into the first part which is receive so we introduced a new receive keyword here the function signature of the receive function looks kind of similar but without the function keyword and receive is being called if you send any ether to the contract via sent or transfer and this contract reverts if you call if you call a non-existing function and to handle this part there is the Fulke part of it so just before the talk we talk quickly about like the proxy pattern and so I'm quite happy that we have this example here I mean it's the pre pre oh six version of it so there's the fallback function and there you have emmalin line assembly code which then has like to delegate call magic and this is called for both or what's called for both for non existing function or either any ether was received and here we introduced OQ so this contract then gives you warning because there's no receive ether or receive function implemented and the compiler yeah as I said gives you this warning and then you can just implement receive and the fallback function and then do in this functions what and just quick wrap up so you'll receive is executed if there's like a plane either transfer and Falk is executed their matching faction signature or there's an empty data field there's or pivot the next one might be a little bit controversial but I think for the sake of clarity it's a pretty nice feature so we made the dot length member of Ares read-only so it's a little bit hard to come up with a good example here but we just thought ok we will have this deck yeah it's a contract called stack and you can pass it a length via the constructor and this is the pre Dupree oh six Oh behavior and then you would have like a push and the pop function so nothing special here but it has some some pitfalls so I mean first of all you could pass like a very high number as length and this could result in two overlapping storage and also accessing that length looks cheap but if you want to delete then it's quite expensive and so what I was what I said before is making this read-only prevents multiple ways of accessing storage here and this is zero Oh 6l version so it should do the same but here in the constructor you would need to define a loop for example here's an empty push function and then push and pop are implemented implemented similarly in this code we hope that it's more explicit because you would see the cost of it instead of just exciting to the length you would use this loop for example yeah I think that's about it the next one it's something we are really excited about its try-catch support so just to give you an example how this could work so we have a Prius EXO contract here and we have the contract consumer and it has a feet and a rate function and now the thing is you want to react on the revert and in the function data but how would you do that so there was no there's no way of doing that so we decided to go for a try-catch pattern that you probably know from other programming languages and this is a oh six over j'en of the contract so again the data and the body of the data function just reverts and here in the rate function there is the new try-catch pattern so as you can see you could just call the function again and then keep the return define the return values and in case there's no no revert or no no assertion failing this would in this example then return the value and flick the call as successful in this example because yeah the rate function has you and then the bool has a return value so for the actual value and if like that states a success for the of the call and in this example so there is a reason given for in the reverse overt reason and the first catch block that you put implement reacts on that so in this case because the function always works we would reach to get the catch branch and you could read out the actual string that was given in this case we would turn a zero and Marcus of lactis s not successful there's another branch that you could also implement so just imagine you have a revert without the reason string or like I said an assertion that fails you could define another catch branch here that reacts on the low level data and then here you could do whatever and it's also possible to use both so we just wanted to keep it out because then the example would have been too big but usually you would implement both branches what else to say yeah I think yeah let's let's talk afterwards if there are any questions yeah next are the function call options and Matias will take over again yes function call options you might know them as dot gasps and dot value as shown in this example to transfer way or gas to the function yet you're calling we changed the syntax of this that this change was triggered by actually another feature that will come right after this but I actually like the new syntax a lot it follows the named arguments syntax so you specify curly in curly braces the variable names and then the values and I think it looks less confusing because because before it looked like another function call which it really wasn't so I think this is a big plus and it is also very consistent with the new feature which is high level support for create - so this is one I really like because if you wanted to create a new contract using create - you had to do it man in inline assembly as shown here you first had to get the code from the contract you wanna create in this case product then we call cry 2 and local low-level assembly with 10 way we specify the code we specify the length of the code and we specify an individual salt which is creatively named salt in this example we check if the creation succeeded we revert if it doesn't and there's actually a this level and some of you might see it some don't does anyone see up I'm here that's why we introduced this I didn't see it in the beginning either so here the new syntax really just call new in the contract you use the named argument syntax from before for function call options you specify the salt and the way you wanna send and the difference here is it's easier to pass arguments to the constructor which we didn't even show in the previous example but you notice we have now a constructor errors payable we actually needed one but the compiler couldn't check it before because it didn't really know what we're doing in the low-level example now this wouldn't compile if I hadn't added this constructor and if you don't specify salt here then it would be just a normal new a normal great call basically and I think yes these are all the noteworthy mentioning of here we have some miscellaneous features we also want to mention but weren't big enough to variant whole slides Eric would you like to introduce yes how we have global enums and structs so they don't need to be defined in a contract anymore we are very slices based and which yeah I mean the syntax yeah you probably know this intact from other languages so you would just define to begin that in the brackets and finally we have a new is ma statement leave you might know return which basically ends the whole function called context leave just ends to the current you'll function so you can be more precise where the accent have more freedom in your control flow we're moving on to a pool Eric who wrote almost alone yeah so this tool is called slip T upgrade and it came out of the missus and missus Edna says it um like to just give you a quick look in our testing pipeline we have some external projects and therefore contracts that we always our new compiler versions so one is how changes that we are doing actually affect this existing code bases so we have for example open then we have notes and the thing this features we to upgrade the contract so and as Matthias already o-net clarifications we need a lot of manual updating of the contracts so and just to cut this a little bit down we decided to build this tool on our own and then it turned out that it was likes internet and then with that okay yeah why should we make this like kind of public and write some nice documentation on it and so this is why it will ended up and it's kind of we are kind of simple so it's based on lip solidity so it's a C++ tool and it just parses and compiles through wiki and it's a hybrid solution so we are checking the errors that are like being reported by the compiler and then we're doing like a simple textural source manipulation based on regular expressions the contract itself so for example this is a prio 6o version and just like three contracts and there's like some inheritance in it and compiling this with the newest compiler version would lead to several errors that are being reported but the tool is able to upgrade the contracts for you and yeah I will just quickly show you the command line and vocation here so the tool like as I said this console it great you just pass a source alone and principle there are no errors being reported or no errors left there operates so you could also have the situation that there are still errors that the tool couldn't upgrade itself but we implemented the zeros most of your 6-0 futures that are that the tool is able to upgrade automate it so 4x the inhabitants features but of course so because the semantics of an assignment to let member of an array it's not so easy so we left that out and we also experimented a little bit and integrated some zero-five-zero features for example the default latif for functions and yad would we would love to get some feedback on it so if you're interested just consult the documentation there's a sub section and the compiler in the section using the compiler yeah and yeah we're kind of interested if this is like useful for contract developers next one compiler features so we I think we are running om with a tail here so the first one which is also an interesting feature is the Jason import so before I don't know I couldn't remember which version and true was it introduced I think it was introduced in 0 6 0 right I think so too yeah yeah so as you might know it's possible to export the ast in a JSON format and now it's possible to import this again and then run the compilation on the perteet a team we also put a lot of effort into the wasn't back-end so every feature that is do you know the intermediate representation called you'll like ten long assembly language so yeah as I said this is the intermediate representation of our solidity code so everything that can be compiled through you like every solidity contract that can be compiled through you can now also be compiled to was a webassembly subset for the EVM yeah the ABI encoder version 2 is no longer considered experimental we still need to specify the same old pragma experimental instruction to use it though so that you don't have to update the contracts mainly not considered experimental means there are no warnings anymore if you use it and there is no experimental literally in your bytecode when compiling and yet otherwise the you'll optimizer you'll is basically our intermediate and assembly language is now also no longer experimental and is automatically activated when you specify the normal optimized flag before you had in the head its own flag we are gonna have a short look into future things we're only working on starting with the you'll back-end which basically means a solidity first to you'll and then compile that to the EVM or whatever backend we want then I think this is your part so we also looked into LSP implementations so language server protocol that's quite useful for IDE integration it just started looking into the specification that comes from Microsoft and yeah I think there's a prototype and because we have the feeling that the community is quite interesting interested in this feature we yeah we are also eager to implement that and then yeah there's some other things but no word like what to mention here is like immutable immutable breyer bullets that could be for example only assigned once in the constructor and are then constant so but this is also like and like an open discussion and if you feel that you want to contribute or like but I paid them to discussion you could just like look through our issues and try to find the discussion there also we have a mailing list I think was heard of like a year ago right now there's not we are we're trying to actually open up discussions there and it's a Google user group and there are like some posts and like some things going on and we would really love to see more people participating in the doctor and them and their discussions there the important thing to note here is it's about language development here not about questions about simplicity or things like that I mean it's it's about solidity but it's mostly like language language design the next thing that we are like very excited about its the solidity summit so at the end of April we will have a language to day language summit here in Berlin it's a two day friendly sized singletrack event with talks and workshops so if you're interested in attending this then just navigate to the URL and sign up for it and yeah we are happy to receive proposals for talks workshops yeah would would be very nice to see you there otherwise we're very approachable on various online and offline resources you can post issues and feedback and feature ideas on github you can visit us on the Gator chat and you can be can participate in our Google Hangouts meeting twice a week where you can either just listen in talk to us ask questions of if you wanna do stuff yourself we always happy to help and direct you to interesting issues another thing we forgot to mention if you have projects and solidity that compile on the current version please approach us and we would love to integrate them in our CI and yes I think questions well you can always approach us later thank you thank you wait there's a question he asked how many people are currently working at the compiler I think we're seven to eight now but it's like only a few are full-time and it's very spread over the week yeah I think eight to nine I mean there are people also involved in other projects in the foundation for example and they're just like coming in for we doing some stuff there and we also I mean we have some external contributions we are always trying to see how in Crete how to increase that mmm yeah but I think like 8 to 9 should be fine 