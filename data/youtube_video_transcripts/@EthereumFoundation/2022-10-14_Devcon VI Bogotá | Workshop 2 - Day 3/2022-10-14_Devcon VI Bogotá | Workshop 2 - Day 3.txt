foreign [Music] [Music] [Music] [Music] [Music] [Music] thank you [Music] [Music] thank you foreign [Music] [Music] for the first time in my life [Music] [Music] [Music] thank you tonight [Music] to touch me [Music] [Music] questions [Music] thank you [Music] thank you [Music] [Music] [Music] [Music] thank you [Music] foreign [Music] [Music] [Music] foreign foreign [Music] [Music] foreign [Music] foreign [Music] foreign [Music] [Music] thank you [Music] [Music] thank you foreign foreign foreign [Music] [Music] [Music] thank you [Music] [Music] [Music] [Music] thank you foreign [Music] [Music] thank you [Music] thank you [Music] thank you [Music] foreign [Music] [Music] [Music] thank you foreign [Music] [Music] foreign [Music] [Music] foreign [Music] [Music] thank you [Music] I want [Music] to go [Music] foreign [Music] [Music] [Music] thank you [Music] [Music] [Music] thank you foreign [Music] [Music] [Music] thank you [Music] [Music] foreign [Music] foreign [Music] [Music] different [Music] [Music] foreign [Music] [Music] [Music] [Music] [Music] foreign [Music] foreign [Music] foreign [Music] [Music] foreign [Music] [Music] [Music] [Music] thank you [Music] all right welcome everybody this is going to be demystifying ethereum assembly a practical zero to one guide so my name is Joshua or JT Riley I'm an evm smart contract engineer and so a little bit about why you know why I'm here giving this presentation uh there's a really really big gap between the intermediate solidity developer and the Wizards that can do the assembly Blackmagic right that we see you know in some um popular GitHub repos so um I kind of went through this the hard way reading through you know as much documentation and paper and as many papers as I could um and hopefully I've condensed this down enough that uh you know everybody here can kind of pick this up a little bit faster or maybe if you already know this you know maybe this will kind of reinforce or you can learn new things so this Workshop is going to be you know pretty interactive so if anybody has questions uh if I go over something and maybe it's not clear you know feel free to stop me raise your hand ask questions we're going to get to the bottom of pretty much anything you guys have questions on today so as we get started um section one obviously understanding the ethereum virtual machine uh here is a link tree it's going to be the link tree slash evm assembly and so this is going to have some useful links throughout this presentation uh the most important one um you know for you to be able to follow along and kind of play with these things is called evm.codes so I'm going to be using that as well periodically throughout basically what this is is a fantastic resource it's got uh you know everything you need to know about instructions and then it also has a playground and that's where we're going to be demoing some of these things so we can really visualize and internalize what's going on foreign so first up we're going to talk about the instruction set so the evm is a stack-based virtual machine with a relatively small instruction set and these instructions can be categorized by one of the following roughly first is stack instructions so these are things that have to do with the stack the values that are on the stack and swapping duplicating things like this arithmetic instructions are addition subtraction pretty basic stuff comparison instructions tend to compare two values and then push zero if it's false or one if it's true bitwise instructions has to do with like bit shifting and other really cool stuff memory instructions are going to be interacting with the memory in the evm which we'll get into a little bit more on that page and then contextual instructions so these are like reading and writing to the environment to storage and other things like that so first we have stack instructions so stack instructions involve manipulating the position of a value on the stack or values on the stack so push in value basically pushes a value to the top of the stack where n is the byte size of that value pop will pop a value off the top of the stack swap in we'll swap a value on the stack with another and then dupe in will actually duplicate a value based on the index so as an example here this is a mnemonic byte code basically it's just a human readable format of what the actual evm bytecode is so this is at the lowest level uh so first we have push one right so we're pushing a value of of size one byte the value is going to be one and over here these uh orange bits here this is actually just comments to kind of represent exactly you know what the stack should look like after any given instruction this next one is going to push one and that value of one byte is going to be two so now we have two and one on the stack you can do swap one which will swap we have dupe one which can duplicate the first value on the stack and then from there we just do pop until we run out of values on the stack so if you guys want to open up the evm.codes website this is evm.code slash playground you can also find it in the link tree so first we're going to do uh basically pushing the number one to the stack right so we push of size one the value is going to be one we'll do the same thing with the number two I can do it with three and then we can start playing with this right so let's say we want to swap the top instruction or sorry the top stack item with one that's two items down from that so we can do swap two and whenever we run this we can basically step through every instruction here so the first one pushes the one to the stack the second pushes the two to the stack you can see the stack represented down here in the bottom right we'll do the same for three and then swap two should swap the number three with the item two items down from it and there we go and it swaps so from stat constructions we're going to go to arithmetic instructions so of course add we'll add two values sub we'll subtract two values mole will multiply two values s mole does the same thing but it treats the number as a signed integer so what this means is that the number can be represented as positive or negative same thing with div div is divide and then s div treats them as signed integers mod will actually do the modulus so the remainder after division exp does exponentiation and then we actually have some instructions add mod and mole mod that will consume three items and basically do addition then modulo and then multiplication then modulo and so here's our arithmetic example we push a one to the stack we push a 2 to the stack and then we call the add instruction it consumes the two and the one adds them together and pushes a three to the stack next we'll push the number two to the stack we'll duplicate it so all right sorry we'll duplicate the second item on the stack right so now we have three two three and then we'll multiply which will give us three or sorry we'll multiply it'll give us six and so now the stack is six and then three and then we'll divide those which will give us two so hopping over to the playground again so we'll push two push three multiply and let's push let's say five and then add so as we step through this see the two is pushed to the stack then the three those are multiplied so the two and three are consumed there's the six we push the five we add it together and that'll give us 11. now this looks like B because this is actually an hexadecimal representation so instead of going you know one to nine then rolling over it actually goes one to nine then a to F and then it rolls over to the next foreign so next up we have comparison instructions so what this will do is pop one or two values from the stack perform a comparison and then based on the result it'll either return true or false those are actually reversed um if it pushes true it's going to be one if it pushes false it's going to be zero so LT will push if the Top Value is less than the second value SLT of course is with signed integers greater than or gt does greater than so if the Top Value is greater than the second value then we push one EQ will compare and see if the top two items on the stack are equal and then is zero we'll push a true to the to the Top If sorry it'll push true if the Top Value is zero now something to note about is zero you're going to see this a lot in uh you know Yule file is another like low level assembly stuff is zero is commonly used as a sort of inverse operator right so it's same as the exclamation point in front of a Boolean thank you so as a comparison example we push one and then we push two we'll check equal of course this is going to push false that's going to be zero and then we can use is zero to invert that if we need to for whatever reason so it'll invert it the true and then at the end we pop there next up we have bitwise instructions so bitwise instructions pop one or more values from the stack and perform some bitwise operation on them now and performs a bit wise and on the top two stack values so what this means is that every bit or every one is one or zero within this number if you compare two values the result is only one if both bits are one right so if uh actually I think we'll have a bitwise example in a second but basically it's only a one if the two bits are one uh an or operation will be one if either of the two values are one xor is exclusive or so basically it will only push a one if one of the two values is one but not both uh not we'll invert it so whatever the value is it'll invert that if it's zero one if it's one zero and then shr and shl will perform bit shift operations where we can shift the bits left and right so as an example uh over here on the left there's a little bit of encoding here just showing you um you know basically what these numbers look like in binary format and then on the right we have push one push two familiar with this but the shl operation is going to shift the number one by two bits right so it's going to move it over two so we can see uh here it starts at zero zero zero one but after it moves over to it's going to be 0 1 0 0. and then we can do the same thing to shift it right so we push another two to the stack shr is going to shift it back to where it was and then the not instruction as you can see it's going to flip every bit so zero zero zero one becomes one one one zero so memory instructions can read and write to a chunk of memory now memory is this linear data that can be read and written to during the execution of a program so it's a different place than the stack it's good for storing things like arbitrarily sized values and things like that so M store will store a 32 byte or 256 bit word to memory everything in the evm operates on these 32 byte words so we can store full 32 byte word we can actually also store a single byte or 8-bit word to memory and we can also M load so what this does is loads a 32 byte word for memory given some index in that memory so here we're going to push the number one then the number zero to the stack and what M store is going to do is consume these two and it's going to say at position zero we're going to store the number one and it's going to be padded out to the full 32 bytes and so if we basically after we've written to memory if we push a zero to the stacker if we push you know any um any index and memory to the stack we can call M load it's going to consume that index and then return to us the value there so in this case pushing 0 and M load is actually going to pull out this one we'll go ahead and do an example for this one zoom in is that better cool so we'll push the number one to the stack right we'll push one to the stack then we'll push zero to the stack and M store is going to treat the zero as the index and the one is the value and we want to when we want to retrieve this later we can push one oh sorry push zero and then M load and so if we step through this we'll see the stack has a one then a zero M store is going to put in memory that first word is a one and whenever we want to load from this we start at index 0 and load and it's going to push that value back onto the stack now getting in the context instructions uh specifically the ones that read from the local context and this is not a comprehensive list there are actually quite a few but some of the important ones uh caller pushes the address that called the current context so if you're familiar with solidity this is the same thing as message.cinder we have timestamp which pushes the current Block's timestamp again same thing as block.timestamp then we have other things like static call which can make a read-only call to another contract so if there's a function that sits on another contract we can call that through static call and as long as it doesn't write to persistent storage or doesn't update the state of the evm then we can read from that call data load can load a chunk of call data into the current context and so what the call data is is basically the data that is sent to your contract to tell you a little bit about what function to execute what arguments it has and things similar to this so call data load can actually pull some of that data for you s-load can read a piece of data from persistent storage on the current contract so contracts can only read their own storage but basically we can read any slot using S load so as a quick context example we can use the color instruction and it'll push that message sender to the stack we can for example let's say we want to see if the caller is an owner of a contract right and let's say the owner is stored at slot zero in storage what we can do then is we can use push zero and then s load and that's going to load from the first slot whatever data is there in this case it's our owner and then we can compare them by using equal right so this is like the simplest representation of how to check if a contract is owned by somebody foreign next we have the context instructions that can write and again non-comprehensive lots of stuff going on here but some of the really important ones s store can store data to persistent storage log in can append data to the current transactions logs where n is the number of special indexed values in the log right so if you've again if you've written solidity you see the events you see sometimes that keyword indexed all of these are actual indexed indexed topics within this event now something to note here is insolidity you can only have three indexed arguments in an event but you can actually have up to log four and the reason for this is a lot the very first Topic in any log is actually the signature of an event right so it's basically just a sha3 hash of this event's signature which we'll get into a little bit more in a moment and then the rest are the index topics that you specify next is going to be call so it makes a call to an external contract or to external code but this actually can update the global state right so there's no restrictions on solely reading or anything like that and then finally we have create and create two and so what these can do is actually deploy code to a new address creating a new contract so it's just a quick example of what you can write for example maybe we want to store the last timestamp that some specific thing happened right so we can use timestamp to push the Block's timestamp to the stack we can push a zero and then s store and what's that what that's going to do is store that timestamp at slot zero so as a quick review again the evm has a fairly simple instruction set most of what we've gone through this is the bulk of what's actually going on under the hood of course this section didn't cover every instruction but it serves as a foundational understanding for Yule in the following sections and so to the left there's a simple contract that will store the caller's address and persistent storage and then return true to indicate success right so stepping through this we have the caller we're pushing slot zero we're calling s store so that's going to store the caller the caller address and Storage next we want to store true or one in memory and we can store that in the very first slot so we'll push one which is true we'll push zero which is a slot in memory we'll call M store which puts that in the memory and then to return we actually have to give it two arguments one is the offset in memory where we want to return data from and then the second is the word size or the memory size that we want to return in this case it's actually just going to be a single 32 byte word so we'll push Ox 20 Push zero and then return so any questions so far on the instruction set right here yes so these are the representation of uh the instructions here so here you only have like push one push one and store Etc whenever we run this we can actually step through we can step through the instructions and this is just a representation here so we can right so memory is here anything that's written the memory goes into here um anything on the stack is going to be here and then persistent storage if any is going to be down there and then return value fitting the stack can be 1024 items I know you'll notice in in solidity you'll get the stack too deep error and actually the reason for this is you can only Swap and duplicate items 16 deep right so there's like a limit to how many local variables you can have because solidity actually stores these variables on the stack so once it gets beyond that solidity doesn't have like an easy way to access that without losing information so that that's why you see that a lot um but yeah it actually can technically go like way way deeper um the memory is the frame dependent right like when you do a static color thank you we want to store that in memory and you basically you know we'll just go ahead and I'll just go ahead and answer some of these quick questions right now while they're while they're getting a setback up so you mentioned um like return data right okay so uh they're actually special instructions to handle return data you have return data size and return data copy and so what you can do is whenever you actually make a call you're not actually getting all that stuff back solidity kind of does does a little bit of magic for you there but basically what you can do is use the return data size instruction it's going to give you the size of whatever was returned and then you can use that to copy in the memory board it's like this yeah so it's not stored in memory per se like it's only stored in memory whenever you explicitly do it yeah a vlog zero um oh I guess we have the spec now yeah actually I don't want to get too too far ahead of myself because we are going to do some more logging stuff but um I will go ahead and let you know so uh basically every log instruction um it takes you know up to the number of topics which are on the stack and then it actually also takes a memory pointer and size so even if we don't log any topics per se we can actually just log like a big chunk of memory and so that's that's one way that we can you know push data to that as an anonymous event foreign it should be within the event logs I'm not exactly sure how the client libraries decode Anonymous events obviously it's a little um unusual to see those nowadays but yeah we can uh if we have time at the end we can actually probably just break open a remix see how it works are we good you mentioned yes so uh create two uh one it's I believe a bit more gas efficient and there's actually a way to deterministically deploy to specific addresses from on chain using Create two um so it's just kind of a choosing utility of exactly which one you want to do foreign okay cool sorry I didn't want to go too far and then we have to go back great so the hardest part is over uh that was all the really like in-depth stuff that uh we'll kind of give you this foundational knowledge for how to write Yule you'll thankfully has a much higher level syntax uh so what Yule is is it's a low-level language uh that can be written in inline solidity or as a standalone language you can write your files by themselves but you can also use it as a compilation Target so it also acts as an intermediate language that you can compile other high-level languages to uh built into the language are most evm instructions these are callable as functions uh there's basic control flow support and functions well user-defined functions now you'll notice whenever we start looking at your code that the stack is largely abstracted away with the exception of a built-in pop function so if there's some value that maybe you don't need that's returned from a function you can just pop that immediately so here we have the syntax overview now note that the keywords object and code are actually only used in Standalone you'll files so chances are you're not going to be touching this if you're just writing inline assembly um one other thing to note here before we start stepping through uh yield does have the if statement but it does not have the else statement so to handle multiple cases we can actually just use a switch and then the for Loop functions very similar to what you see in other high-level languages obviously the syntax is a little bit more funky but it still does the same thing so stepping through starting at the top we have the assignment syntax as soon as we have a colon an equal sign so anything on the right side is assigned to the left side variable if the variable is being newly declared if we're not reassigning then we need to use the keyword let for the function syntax we have the keyword function the name of your function any arguments and then return variables from that and so inside this function you can see the letter c is our declared as a variable implicitly by saying this is a return value and then colon equals will assign the sum of A and B right so you can see this is a lot simpler to read than just pushing things and adding and things like this and another thing to note about these internal functions is that the return is implicit because return itself is actually an instruction that returns to the caller itself that's not what this is doing this is actually just manipulating some items leaving an item on the stack and then jumping back from wherever this function was called foreign so here we have the if statement in this case we're checking if a is equal to zero and if this is true then we can execute some code inside of that in this case we're just doing a revert below this we have the switch so the switch we have a value that we want to compare against and then each case is going to have the value that this variable could be right so case one means if a is equal to one then we'll handle that yeah comments are wrong here um case two is if a is equal to 2 and then default is our fallback right so if nothing else matches if we need to just do some logic to handle the rest we use default and then finally we have the for Loop right so first we have uh let I we're assigning it zero so this is your I equals zero part in the middle we have that comparison so it's less than I and a so as long as I is less than a we're going to continue iterating and then next we have I being assigned basically the sum of itself uh and one right so we're basically incrementing it and then inside of there we can iterate and do our looping logic so as a quick comparison to mnemonic byte code over here on the left that was the code that we wrote a moment ago to uh you know store the caller in storage uh store true in memory and then return that from memory and then over on the right side is how we do it in Yule so a lot less a lot less verbose and so now we're going to jump into Yule in solidity and this is really important because not very many people write Standalone assembly files these days most of the time you're going to be operating within the bounds of a solidity file so you need to understand what standards and abstraction solidity has created so some of these include the call data layout which is a layout of that data that gets sent to your contract the memory layout storage layout event logging and errors so call data layout per the application binary interface or ABI standard the call data layout is as follows so first the first four bytes are the selector of a function and basically this is the sha3 hash of a function signature and that includes the name and then any argument types within that next after the first four bytes each argument is padded to 32 bytes no matter what even if it's a un8 it's always up to 32 bytes um if an argument is of dynamic size then the slot where it should be is actually going to hold a pointer to a place in call data where the rest of the data is so if we have let's say a string that's over 32 characters it's not going to fit in a single slot what we have is a pointer that says okay after everything else here's where the string starts and it's just going to go and there are other ways to determine you know how long the string is so as a quick visual representation here we have the transfer function which this comes from the erc20 standard so first up we have the signature so that's transfer it has address un256. now we're actually hashing here is transfer parentheses address un256 that's the only part that we're hashing here so we can see the the hash full hash digest here we're actually going to clip that to the leftmost four bytes and then the actual call data layout of one of these is going to be those four bytes followed by an address in this case it's going to be the target to whom we're sending the erc20 and then the next is going to be the value right so even though these you know like an address is not a full 32 bytes we're still padding it all the way okay next is going to be the memory layout now this one is really really important because per the solidity documentation the first four slots of memory are reserved now slot zero and Slot Ox 20 or slot 32 these are actually scratch space so you can use these you know whenever you're doing things in inline assembly the ox40 though is the free memory pointer so basically what this does is as memory is expanding solidity will actually track how big memory is and when you can start adding new things to memory and so what we'll actually do in some of this in some of the seal code is we'll actually load from that to figure out where we can start storing things in memory so it's really important if this does get overwritten you have to make sure that you have that variable on hand right so you can increment it if you store more things in memory et cetera Etc and then ox60 is a zero slot so the zero slot is reserved specifically for whenever you're allocating new arrays I believe um this is like basically a big big No-No Zone anytime people start overriding this uh you know it's it's not a very good security practice you have to be very very careful about it so I'm not going to recommend it but we have seen it before and we'll probably take a look at somebody who does that a little bit later uh no dynamically sized arrays will occupy one slot which holds that pointer to where the actual value is in memory there's another slide that indicates the length and then every every slot after that is reserved for a single element so if you have five elements even if they're small values they're going to occupy five full slots now byte arrays and strings are similar with the exception that their elements are tightly packed and aligned to the left so for Strings it's you're basically using a single byte value to represent a character so in this case on the byte level it is equivalent to byte arrays we're going to pack those as tightly as possible so as a quick memory example we're going to step through this now it's a function uh it's pure it's going to return some bytes right and so what we're going to do in here is first load the free memory pointer so again we're going to load from ox40. we're going to declare this or assign this variable data because remember anything that's declared bytes memory good zoom in oh yeah I thought so thank you it is not letting me zoom in yeah sorry this is not going to let me zoom in here um but I'll go over basically every lines we'll step through here so uh yeah the data basically what we're doing is storing that pointer to where the bytes are going to be restoring that next we're going to store the length uh you know the length of the byte array at this point there so at the free memory pointer we're going to store byte's length in this case we're just going to store four bytes it's going to be one one two two three three four four um we're going to store that then and the next slide we're gonna well sorry first we're going to increment the free memory pointer right so we're keeping track of this we're keeping track of how much um you know how much memory is being used here how much memory is being written to so we're going to increment that by 32 bytes or by a single word then we're going to store at this new location the bytes that are going to be padded they're going to be packed to the left after this we're going to increment the free memory pointer one more time and we're going to store the basically in the free memory pointer slot we're going to store this updated free memory pointer right so basically as we're incrementing this we're keeping track of where the new free memory is and then once we're finished with all of this we're going to store it at the ox40 slot any questions right so it's going to get let's say you append an extra bite to the end of this it's going to store that extra bite at the end it's going to keep it packed and then it's going to increase the something else it will move essentially right all of it should I haven't tried that we can actually try that as well we can hop over to remix and try that um yeah it would make sense if it would right because then it would just get really really confusing right foreign right right you're right sorry thank you storage right so in solidity uh you do have to specify the length ahead of time thank you um then and they don't cheat on one it's like the like like a struct like a memory structure so memory struck so struct actually acts similar to a dynamically sized uh value so it's actually going to be a pointer to that as well right right so whenever we store so the first time we're storing the bytes length right we're storing the number four even though it's just a single value that's actually occupying a full 32 bytes so we want to increment it by the full 32. any other questions great so next we're going to have storage now storage is actually going to be a few different cases here first we'll start with statically sized variables so personalities documentation storage layout starts at slot zero the data is stored and the rightmost bytes of that slot now if the next value can fit into the same slot obviously this is determined by type and the maximum value it will actually be right aligned into the same slot so you can actually pack variables into storage you can do the same thing with storage structs and then immutable and constant values that you see in the contracts they're actually not stored in storage at all um so basically what these are is they replace that compile time with the exception of immutables so if you have an immutable that can only be determined at deploy time whenever it runs to the Constructor it'll actually replace every instance of that in the byte code so as a quick example we have a contract it's got five values in it first is going to be a full un256 so we want to occupy an entire 32 byte slot with this next we have two values of 128 bits so basically 16 bytes each so these can actually be packed into a single slot and we'll see that they are so B is two it's here and the right most uh bit and C is packed in the next rice rightmost place in that slot and then we have finally two units which are stored here all right so everything is packed as tightly as possible in storage whenever we're doing this layout next for a dynamically sized variables again per the documentation and solidity a mapping slot is the hash of the key value concatenated with the storage slot right so let's say for example in a balance mapping in an erc20 IT Maps an address to a unit 256 let's say it's in slot zero what it's going to do is whenever you need to read or write to this we're going to take that address Pat it to 32 bytes concatenate that with another 32 bytes which is the slot it's going to be zero and then we hash all of that and that's where the actual value is stored now dynamically sized arrays it stores the current length in whatever slot it occupies and then its elements are stored sequentially starting at the sha3 hash of that slot number byte arrays and strings are stored the same way as other Dynamic arrays unless the length is 31 or less if this is the case then what's going to happen is all of that's going to be packed into a single slot left aligned and then the length of that is going to be packed or is going to be placed at the rightmost byte and it's going to be 2x the length so looking at this one we have three storage variables we have a string a array and a mapping so looking to the storage layout first over to the left we have six one six one six one six one these are the Four A's and then over on the right we have eight which is two times the length in the next slot we're going to store the length of this data value it's going to store one and two right so what's going to happen here is whenever we run whenever the code is executed it's going to see that the length is 2 here at slot one and whenever it wants to access these values it's going to Hash slot one and that's going to point down here to oxb1 et cetera Etc and then we can see here's the first value and here's the second value and then finally we have the mapping it's mapping an address to a unit 256. the actual storage slot of a mapping is always zero that doesn't mean that it's not incremented the storage is still incremented but this slot is always going to be zero and then any addresses that are mapped to of course will be um that hash right so oxe9 et cetera Etc so one more thing to mention something that's really important to note is storage in regards to inheritance so solidity uses C3 linearization so basically in the context of storage what this means is storage slots an apparent contract precede the child contract storage when a child has multiple parents the order of the parents storage is set by the order of inheritance and this process is repeated recursively and storage packing rules are still in play when applicable so here we have uh basic inheritance example we have parent zero it's going to store a it's going to be one parent one is going to store B at a value of 2 and then finally we have child which is going to inherit parent 0 and parent one and it's going to have its own value C and that's going to be 3 and looking through the storage layout first we have parent zero storage then parent one storage then child storage this is really important to note especially with things like proxy contracts you'll see in some of the open Zeppelin implementations these storage paddings and things like this for upgradeability so next up we have event logs so per the standardization event logs follow the following rules they can have up to four topics the first topic is always that hash of the event signature so it's going to be the event name parentheses and any any types uh and the non-index topics are logged by storing them in memory and then passing to that log instruction a pointer to where that memory starts and how big that memory is so as an event log example at the top we have a hash and that's going to be the the event signature hash uh next we're just going to have you know A and B simple constants now in solidity this first function is how we'll log this right we say emit the name of the event and then any arguments that go to that event next we have log in Yule so this is actually what's happening under the hood whenever you do this in solidity so first we want to store note that uh B is not indexed so we want to store that in memory and then a is indexed so we're going to have that you know on the stack right it doesn't have to go into memory so first thing we do is we're going to store B we can just store it at slot zero we're not going to be dealing with memory after this right the function is going to end so we store at slot zero B and then we call the log 2 instruction and what we're going to pass to it is a memory pointer in this case slot zero of memory the size of memory which is going to be 32 bytes the event hash which is going to be topic one and then the index topic a which is going to be topic two so next we have errors uh so per the standardization an error consists of a four byte selector and some error data now solidity actually has two predefined errors this is error and panic but since solidity 0.8.4 developers can actually Define custom error types where you can have names and arguments and it's actually a bit more efficient than the standard require Boolean string the reason for this is the the solidity defined errors first is panic and it's got a unit 256. uh so this is things like uh divide by zero overflow underflow that's when the Panic comes into play each one has its own code it's in the documentation and the next is the actual error error this takes a string in memory and you can see so first is a panic code so we have these four bytes which is the Panic selector and then the next 32 bytes is going to be the actual Panic code in this case it's one then the next one is going to be require or what is standard with require we pass it a Boolean if it's false it's going to throw this error with a string in it now note this actually takes up a lot more memory because we have the error selector and remember per the standards of strings we first have to have a pointer to the string and then the actual string itself right so that's going to occupy extra data [Music] right so basically because the error selector is only an offset of four bytes that's actually not padded to the full 32. so right after those four bytes we're going to start putting other data any other questions great all right so next we're going to do applied yield plus solidity so we're actually going to hop over to remix that's a remix.othereum.org and from that link tree earlier we actually have some boilerplate code here make sure this is big enough to see uh so you might want to just copy paste this from that link if you're going to be following along because you know lots of already pre-encoded data and all that kind of stuff so I'll give you guys a minute to get that pulled up copy pasted all that good stuff thank you foreign okay is that you using Chinese right yep so that's going to have the code it's going to be an adjust but you can just copy paste that yeah yes one moment appreciated maybe not I'm going to write it right here so it's going to be the link uh link tr.e ethereum assembly all right hopefully internet doesn't rug pull us here all right we'll go ahead and jump into it so everything here that's predefined this is just for the sake of us not having to go in and code stuff in the hexadecimal and all of that you know right in the middle of the workshop so just looking through these constants really quick how we have the length of the name in this case the name is actually going to be Yule token so the length is going to be nine characters and then in here we have padded over to the left the uh the string next we have the symbol that's going to just be you'll Yul all caps and so here we can see the length is three and these are the three characters for that string after this I went ahead and hashed the selectors for two two custom errors that we're defining here one is going to be insufficient balance and the other is going to be insufficient allowance now no insufficient allowance we're actually going to pass an address of the owner and the spender in here and this is going to give better error messages for client libraries and for users so hopping into this first thing we're going to do is we're going to define the name function now we're going to make this pure we're not storing anything in storage we're actually just going to return a constant I'm just going to return a string in memory okay now what we're going to do if we remember the standard for storing strings and memory first is going to be the pointer then the next slot is going to be the length and then the slot after that is going to be the actual data itself so we're going to do three memory rights and then we're going to return from that so first we're going to M store at slot zero we're going to store ox 20. and that's where the actual data is going to be it's going to be a 32 byte offset next we're going to store oh no hold on safety memory pointer we want to load from memory so we load that now this actually should be fine in this case like we know exactly where it is because nothing's been written the memory but it is good practice as often as possible to use this free memory pointer so we're going to load from ox40 sure yeah so let's say um so I mean if you just start writing to the zero slot and in this case we're going to occupy three slots um that's going to take slot zero Ox 20 and Ox 40. so it's actually going to overwrite the free memory pointer now in this case we're actually returning from assembly so we are safe here but the problem is if we're doing some assembly let's say within you know a function and maybe there's stuff that's happening after that solidity is going to trust that whatever value is in ox40 is the right value so if we overwrite this to something strange in this case uh you know it would be the string padded over to the left which is actually technically a massive number this would actually consume a massive amount of gas and realistically probably revert but yeah so basically as much as possible we want to use um you know basically load whatever is at Ox 40 that's going to point normally it starts at Ox 80 so that's after the four Reserve slots uh but again for the sake of you know keeping it safe we're going to do it like this so we m-store at the mem pointer we're going to store the length or sorry not the length the ox 20 pointer after this I'm going to store 32 bytes later we're going to store the actual length so we're going to add the mem pointer nox20 so we're increasing you know by a single word size we're going to store the name length next we're going to store at an ox 40 byte offset uh you mean like after the first M store in the uh no so this is actually an offset from this value itself so yeah so the ox 20 offset is just uh pointing to the actual link that's itself so uh we stored the pointer restoring the length and now finally we're actually going to store the data and so what memory should look like right now is starting at the free memory pointer we have the string pointer the string length and then the actual string and so this is going to occupy three slots which is ox60 so what we can do is return starting at the mem pointer we can return Ox 60 bytes so very quickly we're going to compile this I'm on solidity 0.8.17 we'll check that the compiler is at 0.8.17 everything's all good so now we're just going to deploy this to a local virtual machine and here we have the name function whenever we hit it it's going to return Yule token for us all right so next we have the symbol function it's going to do basically the same thing the only difference being we need to store the symbol length and the symbol data thank you so first we load our mem pointer then we store in memory at the mem pointer the string pointer and an offset of ox 20 we'll store the symbol length and add an offset of Ox 40 . or we'll store the symbol data and then same thing as before it occupies the same number of slots because everything is padded we'll return mem pointer ox60 now note in this case we're actually not incrementing the free memory pointer and that's because we actually are returning from the assembly itself if we were to break out and continue doing things we would actually want to actually store you know what the new free memory pointer is in this case we would increment it by ox60 foreign next up we're going to do decimals it's going to return a un8 so first now in this case we're actually not occupying very much memory at all we're actually only occupying a single slot so we can't actually just write to the very first slot right it's mostly whenever you need the right three or more slots that you want to actually do it at the memory pointer in this case we're going to do a little bit of a hack there to keep that in the lowest slot so we M store at zero the number 18 because we're not bad people and use six as decimals and then from there we're going to return from slot zero in memory we're going to return Ox 20 even though it's a un8 it's stored at the rightmost bytes so we need to return that full 32 byte word all right now that we're done with um all of that basic boilerplate stuff let's go ahead and set up a mapping this is going to be mapping an address to un256 and we're going to make this internal in this case because I want us to actually like do it in assembly and see exactly what's happening obviously we can just make this public and make it a lot easier but we'll say internal underscore balances next storage slot we're going to need after that is going to be the allowances so we're going to map and address to a nested mapping which Maps an address to a un256 I'm just going to comment here what this is actually mapping to great all right so next we're going to do the balance of function it's going to take an address and we're actually not going to name this variable because we're going to manually load it from call data so we can see how call data is working but it is going to take an address it's going to be a public view function because we are going to read from State and it's going to return a uint 256. all right a quick time check great okay so this is where it's going to get weird um remember we're mapping an address to a balance and per the standard what we need to do is we need to hash the address and then the slot in memory or a slot and storage in this case it's zero so we're going to Pat an address and then we're going to put zero and then we're going to Hash it but the hashing function actually reads from memory so we're going to use some memory to do this okay so first thing we do is we're going to m-store actually no we're going to assign this variable for readability we'll optimize a little bit in a moment so first thing we want to do is get the let's say account and so what we need to do is load the address from call data now if you remember the first four bytes are the function selector and then the next 32 bytes are the first argument in this case our address so what we'll do is we'll call data load and we're going to do that at an index of four so it's going to take the next 32 bytes and put that into the account variable next we're going to store this in memory at slot zero we're going to store account and then at slot Ox 20 or at the 32 byte slot we're going to store just zero next we're going to get the hash which is going to be 256. and what this is going to take an assembly now in you know high level solidity what this is going to take is like a string or bytes but in low level uh Yule it's actually going to take a pointer in memory and the size and memory so in this case we're going to start at slot zero and we're going to consume two different slots right so ox 40. so this should actually be the key to this person's balance so we can do from here is we'll say balance and that's going to be S load oh no balance is a reserved word hold on there we go account balance is going to be S load at that hash right so we're loading from persistent storage this slot next thing we want to do from here is we want to m-store now at this at this point we're not actually going to need uh what's in slot zero and Slot uh well 30 well slot one like 0 and 32 here so we can actually just overwrite that with the account balance foreign and then finally we're gonna return and so that's going to start at slot zero and it's going to be Ox 20 bytes so this is kind of like a more verbose version so we can see exactly what's going on with variable names and things like that but let's go ahead and do just a little bit of optimization and seeing like what what you might actually see in production right so account is only used once that's loading here from call data so we can actually just remove that and put that here right so we're storing in memory add slot zero whatever's in-call data starting at four here we have this hash instead of declaring a new variable we can actually just load that straight from Storage and then instead of declaring an account balance variable we can actually just replace that as well right and so now it should be functionally exactly the same we're storing the first argument in memory at slot zero we're storing the slot number in slot ox 20. and then we're hashing that loading from Storage putting that value in the memory and then returning from memory and so this is the full process of what a balance of function is doing that's the length of uh memory so far so these these two slots sorry exactly yeah all right exactly because it's in the it's in the first storage slot we can do that at zero actually something else we can do here since this is already implicitly zero uh we could remove that but again for the sake of safety we'll just leave that for now uh return with like just parentheses foreign right so in this case it's actually going to give us an error because it actually is um oh right right so like basically if we don't say like return down here oh yeah so in that case it's actually not going to return anything like if we did this it would actually like load from call data load from Storage put it in the memory but it wouldn't actually return anything to the caller but the function itself is prepared to return right so I mean you can see here it gives us a compiler warning let's see unnamed return variable can remain unassigned that's actually a weird one let's try that it's going to give us a warning but we're going to try it anyway uh by the way this is using remix is a fantastic way to try out these little edge cases if you're ever not certain how something works this has been an invaluable resource to try these things out so let's go ahead and give it a try balance of uh we're gonna need an address we'll just copy this one it returns a zero okay so I guess in that case if you don't explicitly return Then solidity will actually insert a return statement for you and it's just going to return you know nothing at all so call data only loads using call data load it only loads 32 bytes so in the case of like for example if you need to figure out what the function selector is right you can only grab the full 32 bytes so in this case you would actually use bit shifting you would want to there's those uh four leftmost bytes you want to shift them all the way to the right foreign so just adding this alone shouldn't add any extra op codes this is just like a abstraction for the high level language but I believe we could actually just access it like this so this and what we were doing a moment ago is actually functionally identical right so either we can like manually load from call data or if we name the argument we can actually just put that in there right yeah because the the function selector will be the same and then if it's not actually used it shouldn't consume and I mean of course it'll there will still be a place in the call data for it but if we're not explicitly using that variable then you know there's no point in which that's going to be loaded from call data by solidity listening stories um no so what this actually does is uh so the mem pointer tells you obviously where in memory to get the value and then ox60 is a length but what this is actually going to do in this contract it's going to finish executing it's going to stop executing and then whoever called this contract whether it's neoa or another contract it'll actually return that data so it'll take that chunk of memory in this case 60 by or ox60 bytes from premium pointer and that's actually going to be returned you know into it's going to be returned either to the client Library like ethers or web through JS or it's going to be returned to another contract and coded as a string three still question right right as soon as we call return it's actually going to stop execution from there so even if we put anything after that as long as it always returns we'll never go there so each function has its own memory uh stack when you execute or they share across like if you go uh I don't know right great question so um any time that you call a contract it's going to create what's called a context and so this context is going to have a clean stack a clean memory it's going to be able to access the storage at whatever address is there right and then other contextual information so basically anytime a function is called on this everything is a clean slate so it's going to read and write from that same clean slate and then once the function finishes it stops and the memory is gone right so uh in this case like they're technically writing to the same same storage slots but they're never executing at the same time so we don't have to worry about any kind of like memory overwrites or anything pictures so if you call an internal function um actually at compile time but this is a little bit confusing about solidity is that you have like public and internal functions public functions explicitly you know take some information from from the caller and then it's going to return some information based on that whereas internal functions there's actually what it does is it takes a number of items on the stack let's say your internal function takes three arguments it's going to expect three values on the stack and then it's going to operate on that and if it returns anything it's actually just leaving values on the stack so inside of internal functions whenever you return from that is not actually using the return instruction it's actually just leaving it on the stack and jumping back to where it came from but they think um right so the first thing that happens um during the execution of a contract at least per solidity is we're actually going to store a free memory pointer so like the first two slots you know zero and Ox 20 these are always going to start at a zero Ox 40 is going to have that free memory pointer and then uh the next slide after that of course is the zero slot so we don't putting anything there we can actually take a look uh briefly if we compile this and we look at compilation details so you'll notice the first few op codes here we're going to push ox80 then we're going to push Ox 40 and then we're going to M store and what that's doing is storing ox80 which is the first free memory pointer we're storing that at slot ox40 and this is the first this is actually like a big Telltale sign that a contract was written in solidity this always happens first every solidity contract starts with you know 6080604052 but people break up together so you mean like when you have multiple internal functions or right yeah exactly so what what solidity actually does is those first two slots uh the reason that they're kind of reserved is that's actually normally used as a sort of scratch space for hashing so normally you're hashing two values together so that's where we'll put that and then hash that together all right right so uh per the standard of how strings are stored in memory it's always a pointer to the string and then the length of the string and then the actual string itself um so in this case it's kind of a formality but it's really important to have that Ox 20 there because whenever we return it the client libraries expect it to be encoded as um actually no does that return that we're gonna try it so let's call name and what we can do here this is another great way to look through transactions and find things you might not be sure about let's break this out and it's not going to let me make it bigger okay uh right so what we'll do right here at the very end let's take a look so we have some memory laid out here uh mostly zeros it looks like hold on foreign this really quick I really wish this would make me let me uh make it a little bit bigger here uh but so here's the state of the stack right in this case we're going to push uh the free memory pointer which is ox80 we're gonna push uh the length which is ox60 and what that's going to do is point to slot ox80 in memory which is going to be here and it's going to go for ox60 bytes so here's the first here's the second and then here is the third right so because this actually gets returned with it client libraries are going to use this to actually decode strings so if we actually didn't if we didn't return this properly it would actually throw an error like it wouldn't know how to decode it would just give you a bunch of bytes back right so in that case it is sort of a formality but it is important you know to make sure that the client number libraries know how to decode I think there was one more question right call it internally Oh you mean like if I say like this dot name right so we wouldn't want to use the the return instruction inside of an internal function like if it's being called internally um I mean you can use that but just know that that's going to stop execution at that point which is not what you want right because that'll actually return back to the caller so if you're trying to like return from an internal function you're actually just you know jumping back to the main function and that's where the actual return instruction is going to be um and like 20 yes that's an upset right okay okay so if you store the data I don't know if there's 16 for example uh yeah so what that actually is is it's it's Ox 20 from that place in memory right uh so balance let's go ahead and put that return back okay uh next we're gonna do the transfer and this is where it's going to get weird we're going to have basically some conditional logic in here remember that overflow and underflow checks only happen in solidity 0.8 and after so basically anything before that and then anything assembly is unchecked which means if somebody tries to transfer out more than they actually have the evm is not going to stop that from happening it will actually underflow roll back over to the very top and then they're going to have some obscenely massive amount of tokens so we want to make sure to check beforehand that the sender has enough tokens before they transfer out foreign it's going to be a non-payable so we're actually just going to call it public and it's going to return a Boolean so first thing we want to do is load the caller's balance right so what we need to do is Hash um you know that that information that we did before so let's say let's no we're going to m-store one more time so we're going to get the mem pointer by loading from memory from the mem pointer we're going to store the caller's address in this case we can get that by calling caller with parentheses at the next slot so minpointer Plus ox20 we're going to store the balance slot which is actually going to be zero then we're going to hash and let's say caller balance so we hash these two starting at mem pointer with a size of ox40 and we're going to take that hash and use it to load from Storage so now we want to check and make sure that the caller's balance is at least as big as the amount now now that we've done the call data loading we're actually just going to do this for the sake of time we'll say value and thank you receiver just to keep things succinct so we want to check and say if less than so if color balance is less than the value to transfer we're actually going to do some revert logic so we're going to take insufficient balance selector now this actually isn't going to take any arguments so all we really need to do is actually just store this one value foreign again at this point we're reverting we're about to stop execution so we can basically just you know write to uh the zero slot this can't cause any harm so M store at zero the insufficient balance selector that's going to be that four byte selector padded to 32 bytes and then we're going to revert and revert actually functions the same way as the return instruction so we're going to give it a pointer and a size in memory in this case we're doing the full ox20 I guess we could also just do oxo4 and so that's going to revert with that and this is good because whenever we revert with the selector client libraries are going to have access to this ABI it's going to see that there is you know this error called insufficient balance and that's the selector and then we can actually do some you know better error handling uh on the client side sometimes you'll see people revert with zero zero and that actually just reverts with nothing and obviously this isn't super helpful so as often as possible even though it does take a long time and it is annoying make sure to store proper error information okay so uh from here we know that the color balance like if we're at this point in the code we know the color balance is sufficient so what we'll do is we'll deduct that we'll deduct the value from the color balance and then we'll add it to the receiver's balance just one moment perfect just double checking okay so uh we add these two together and then we'll say let's say receiver balance right oh right vice versa thank you sub okay so next we want to get the receiver balance and so we'll do this in a similar way iPhone new color balance thank you sweet okay so to get the receiver balance we're gonna do the same thing except we're actually going to use the receiver as opposed to the caller again we're not going to need these two slots of memory anymore so we can actually just overwrite these foreign [Music] so the receiver balance is going to be what we load from Storage which is going to be the hash starting at mem pointer and of size ox 40. so this is where we get the receiver balance actually Let's do let's do this color balance slots because we're going to need this later so let's take this and we're basically just going to create a variable with this right same thing great so uh functionally identical but now we can actually access uh the slots a little bit later whenever we need it so now we want to get the new receiver balance again we'll optimize a little bit later new receiver balance is going to be sub sorry thank you there we go okay so subtract from color balance add to receiver balance the value okay so now we have our new balances set up we've done um you know the addition and subtraction so now we just need to store these back into storage so we'll say s store we need the key in the value in this case the key is going to be the caller balance slot and the value is going to be new caller balance and same thing receiver balance slot new receiver balance all good cool um yeah so just as a quick review of what we're doing with this transfer loading loading the free memory pointer we're going to store at that memory pointer the caller then zero because that's the slot of the balance mapping we're going to Hash that to get the slot we're going to load from it to get the color balance assert that it actually does have the balance that it needs if not we're going to revert then we're going to Inc sorry decrements or decrease the new caller to the new color balance then we're going to do the same thing for the receiver obviously we don't need to check for the Overflow we're going to check that a little bit later um but we can be certain that this is not going to overflow um so we'll increase the receiver balance to give us our new receiver balance and then we'll store that uh in storage here so last thing we need to do after all of this is we need to return from Return to the caller a Boolean in this case we're going to return true it's the way we do that again it doesn't matter now we're at the end of the execution so we'll store add slot zero ox1 which will be our true value and if you return those 32 bytes important the log yes the log thank you okay so we're going to have a transfer event probably should have hashed this uh as well but we'll get those hashes in just a moment um so it's going to be a transfer event we're going to have an indexed sender and indexed receiver foreign great so uh per the rules that we mentioned earlier we're going to have so this is going to actually be log three right we're going to log the event signature of event hash then we're going to log the sender as a topic the receiver as a topic and then the amount because it's not an indexed topic we're going to put that in memory and then um basically pass the pointers to that to the log instruction so I'm going to quickly oh well so small foreign so another place that you can do this if you want to get this stuff online and you might not have um if you might not have cast installed on your local machine what you can do is go to this online hashing tool and you can basically punch in this stuff I think internet is going to rug me once again but oh no there we go cool so we can just say transfer and then same thing right so Ox DD F2 etc etc all right so we're going to set that as a constant all right I'm going to add some comments in here just a moment okay we're gonna store and now log okay so before we do any of the logging remember we have to store the amount into memory so in this case again execution is about to end so we don't have to be too too careful about where we put things in memory so let's go ahead and M store at slot zero the amount I think in this case we called it the value right so we're storing that in memory and now we want to call log but remember we want to have the two indexed arguments and we want the um event signature so that's going to be log3 first thing we want to pass is the pointer in memory it's going to start at zero the size is just going to be this one value right everything else is going to come from the stack we just need these 32 bytes at the beginning then we're going to say transfer hash the next topic is going to be the caller and then the final topic is going to be the receiver great so at this point we handle the balances update the storage log the event and return thank you values the values in the log are only the non-indexed so the actual indexed arguments are on the stack and then the um then the non-index are in memory which also um I believe this is also in the link tree the full like yield documentation basically everything you need to know about this it's also going to have our log instructions in here right so log 0 1 2 3 and 4. um London more heaters because you are adding a new value so if it's the same it uses the same slot it first increases right no no so whatever your Val whatever the value is at that slot it will decrease and it loads increases oh yes yes okay right right catch thank you right yeah so let's do that as well so let's just say equals uh if the caller is equal to the receiver subtract store load add store right oh yeah so it evens out yeah right right yeah yeah great um yeah for the sake of time we're going to be bad developers and we're just gonna revert with zero zero and we're just not going to tell anybody about that all right all right great um good catch thank you so after transfer let's do allowance no um okay let's do allowance great okay so um in this case what we need to do is all right so we're going to take the owner we're going to map that to a spender which then we map to a number so the way that this works in storage is we're going to hash the owner and slot make sure I get this right owner and slot and then the result of this will hash again so owner slot hash then the final key let's double check the documentation make sure we get that right great so uh here is the standard function and then nesting that would be right right idea wrong order so the mapping rules are applied then uh recursively so we're going to bring that down here so we can remember okay so first we're going to do the inner hash so we're going to M store the owner yep we're going to m-store the owner at slot zero we're going to M store at the next slot the slot which is going to be zero inner hash is going to be shot three hash of the first two slots and then we're basically going to do the same thing again with the inner hash wait slot one thank you okay and then suspender foreign slot then is going to be the hash of these once again okay and so now what we want to do is load from Storage and then we want to store this in memory and return that back to the caller foreign owner here we go okay so uh we hash together to form the first slot and then we hash again to form the second slot for this mapping we load from that slot put that in memory and then we return it from memory to the caller so next thing we want to do is going to be approve okay so in the interest of time we're going to copy paste as all good developers do okay so um we're gonna do the same thing so the hashing figure out the slot and then from here we want to set the value at this slot to the new amount so s store at allowance slots the amount next thing we want to do before we return is we want to create a log and that's going to be the approve event it's going to have an owner foreign ER and an amount and so functionally this is going to be the same as the transfer we have two indexed arguments so it's going to be log three and we'll have to store the amount into memory great is it approve or approval it's just a proof okay just a moment approval great that's going to be approval say from here we'll take this hash make sure that's hex okay so uh before we log the event again we want to store the amount and Storage and then we want to log three we'll start at slot zero it's going to be of size Ox 20 because it's just the amount first topic is going to be the approval hash next one is going to be the owner in this case that's going to be our caller and the final one is going to be the spender the person who can spend on their behalf okay now that we've logged the event last thing we want to do is store one which for true then we want to return that full amount great easy um right so on the lowest level a Boolean is actually represented as basically a un8 that can only be zero or one so it just occupies a single byte but in this case we're returning the uh the ox 20 just returning the full word okay we're going to do transfer from so this is going to have a sender a receiver and an amount all right so we're going to do a very similar thing to the transfer from function we're actually going to just copy paste most of this with an exception I don't know if I'm going to be able to do this with this tiny Mouse hold on nice okay no we're just gonna do it from scratch we'll do it live okay so we'll load the mem pointer we want to generate the slot first for the approval so we'll do the same thing as here uh just a moment owner it's going to be okay so the owner in this case is going to be the sender and then the spender in this case is going to be the caller right so basically we want to check um what we're trying to load here what we're trying to see is the Spenders permissions on behalf of the sender we'll call that caller allowance okay we're going to load from that slot and so basically we want to do the same thing we want to check and make sure that color allowance is not less than the amount right so if it is less than then we're going to revert in this case we're going to be storing the insufficient allowance error so notice this is going to take two arguments that's going to be the owner and the Spender since we're going to be storing a bit more information here even though it is going to end execution again formalities mem pointer so we're going to store the insufficient allowance selector so that's going to be the first four bytes now remember it's only four bytes in memory that we're occupying here we actually want to write after this the next 32 bytes so instead of adding a full ox20 we're actually just going to add ox04 right so it's going to be the four bytes then the next 32 bytes and then the next 32 bytes after that so storing it this slot it's going to be foreign ER in this case that's going to be the spin or the the sender and then the next one is going to be one second so the next one is going to be the actual caller so notice we're still increasing by Ox 20 at this point but because it is at an offset of four first slot is going to be the Min pointer the next one is going to be Min pointer plus four and then the next one is going to be the Min pointer plus four plus 32. and so this is our entire uh Chunk in memory where the error is so we're going to revert starting at the mem pointer and then it's going to be Ox let's see four 24 and then 44. so ox44 and so that's going to yeah basically assert that they actually have the allowance uh to spend there so now that we've done that let's go ahead and foreign so next thing we want to do is we want to get the balance slot from the sender balance thank you there we go okay so uh doing the same thing I got hold on compiler is being obnoxious we're just going to do this this is not actually important I'm actually just doing this so the compiler doesn't give us all this yellow text everywhere we're gonna get rid of that in a moment okay uh so we're going to load the sender's balance um basically again we're storing the sender storing the actual pointer in memory where this or pointer and storage where this is going to come from uh we're going to Hash that to get the slot from the slot we load the balance then we want to assert that it is at least that amount otherwise will revert with insufficient balance then we will s store at the sender balance slot the sum of Cinder balance and amount great next we'll do the receiver so basically the same thing okay and then we will store okay oops inverse great so uh same thing as before basically once we pass this approval check we're going to check the balances make sure that it's all good send all this stuff through last thing we want to do before we return is we want to do the log so again M store at zero the amounts log common three it's going to start at slot zero offset of ox 20. transfer hash is going to be the first second is going to be the sender and final is going to be the receiver oh and one last thing before we do this before we return as we want to make sure we decrease the allowance if it is not the max you and 256 value so if it is less than we're checking I'm not sure of a good way to get this max value in assembly so I can no we're gonna have to log that or something photos sorry right yeah I didn't want to have to do it that way but it looks like I'm gonna have to uh you could underflow um which that is one thing that works but also that does add like that is computation um at runtime best way all right and the reason that we actually can't just use um so normally you could do something like type un256.max but this actually is disallowed and assembly because this is you know a higher level um higher level functionality so we'll just do that right so if the caller allowance is less than this enormous value what we want to do then is decrease the caller allowance and we'll store that back in the allowance slot thank you and again since we already checked to make sure that they have sufficient allowance this should never underflow okay then finally we're going to store true and then we're going to return it when is that what is it right so so there's a common pattern it's not part of the standard but this is something that uh seeing increasingly basically um to give like an infinite approval uh you could just set it to the max you went to 56 value and so instead of actually having to do like math on that right we can just you know check that right so if less than then we s store so that's all good all right so just reviewing this one Function One Last Time we're going to generate the allowance slot check the allowance make sure it's sufficient if not we revert if it's less than the max value we're actually going to decrease the color allowance next we want to make sure the sender balance is sufficient if not we revert then we want to subtract from the sender balance this amount then we want to add to the receiver balance this amount then finally we're going to log and then return true leaders 165. uh right so so this is uh to generate the hash so we're storing at slot zero descender and he said the other was 205. 201 um yeah same thing right so at the memory pointer and then at the memory pointer plus ox 20. right okay so we have transfer from we have approve we have allowance we have transfer balance of total Supply and again we're just going to keep this internal just so we can you know for the sake of the exercise write this out now of course all of this that we're doing here is like very much over abusing assembly and in general you don't want to use it this much this is just to give like a good picture as to like what's actually happening into the hood here so total Supply it's going to be a public view function okay now this one's actually going to be really easy basically what we want to do is store the value at this slot now this is slot number three or slot ox02 this is Oxo oxo1 oxo2 so we can M store at slot zero the value that is loaded from Ox O2 then from there return Oxo ox 20. I meant right so I was actually going to do that in the Constructor um if we want to do a Min function we could well actually are we short on time right yeah so it's always zero best token uh was there another question transfer from hash three slots at the same oh right so if you want to Hash three slots then you the first argument would be where in memory it is and then you would just say ox60 so that's three slots uh in this case we're only over hashing two that's just per the solidity standard uh but you could hash bigger stuff uh not quite so the the reason that uh we did the like separate hashing here is because um the second time we hash we're actually um concatenating the caller and the first hash like digest so it has to be two different hashes all right so in our Constructor we will once again abuse assembly uh so basically what we'll do here is we'll just do a static total supply for the sake of Simplicity we're going to store foreign slot the initial Supply so first thing we want to do M store the caller next is going to be the slot for balances and we're going to s store at the slots total Supply what do we want to call this Max yeah I like it cool all right so we'll do that um now since this is kind of technically a transfer from the zero address we'll go ahead and log an event for this as well so uh mounts we're going to store into memory and then from there we're going to call log three transfer hash no no no no no no log three memory pointer it's gonna be zero memory size it's going to be Ox 20 to store that value transfer hash zero address we can just say zero here then receiver and all three topics perfect now from here we're not going to return because in the Constructor of a contract the way that like a contract is actually deployed to the chain is we take the entire contracts byte code and then some and basically what we're doing is returning the entire contracts bytecode like we're putting the whole byte code in memory and then calling return on that that's how the actual deployment process works and part of the reason why deployments go get so obscenely expensive because memory gas costs expand gas expansion um sorry memory expansion gas cost scale quadratically so it gets very very expensive but the reason that I bring this up is we're not going to call return here because a Constructor needs to do its job and return the bytecode at the end of this constructor's execution so everything compiles Moment of Truth whoops hold on all right so first let's check decimals should be 18 name should be yield token symbol should be Yule total Supply we did not increase the total Supply so s store that's going to be slot oxo2 and it's going to be Max un256. great good coin great tokenomics foreign total Supply now it's this enormous number and let's do a quick transfer now we're just going to transfer to some random address who cares first let's call balanceov on this address just for the sake of seeing what's what it's a balance of this should be the deployer's address foreign interesting caller ox00 ah that said okay okay there we go one more try so balance of here our enormous number and then finally we'll just make a quick transfer here for let's say 10. because we're stingy and then we call and the balance is now 10 and that's an erc20 token written purely in yule and that concludes today's Workshop [Applause] so um really quick uh these are some other resources that you guys can check out educational resources evm codes obviously the yellow paper if you're the generator and you're into that kind of thing uh developer tooling and languages Huff language is basically a low-level Assembly Language that will teach you a lot about the evm uh The Foundry development environment really good for testing and trying things and the remix browser IDE for that local testing and the browser from um add liquidity or swap so that's not possible now um right because all it has access to is like the message sender right um now maybe uh right right uh any other questions so right so some things are trivial but some things you can actually like very heavily optimize and that's that's actually why a lot of people tend to use assembly like for example take ABI dot encode so this is actually like fairly gas intensive especially like let's say you want to Loop a number of external calls it's actually ABI encoding every time right and there's like a lot of gaskets being consumed there whereas like maybe you're calling the same function over this entire Loop instead maybe what you could do in assembly is you run that Loop but let's say instead of you know doing this encoding the entire time every single time you just store it once and you kind of like cache that right and so things like that will actually give you massive improvements and gas efficiency foreign right it is improving so a little bit about the state of the solidity compiler originally solidity used it's basically its own pipeline so it would go from you know solidity to intermediate representation to bytecode now there's actually a migration happening where basically solidity will compile to Yule and then we can actually use Yules pipeline to optimize because the Yule Optimizer is very well developed this was actually sort of the original reason of using Yule is that like many high-level languages could compile to Yule and have the same you know basically intermediate representation where everybody can take advantage of the same optimizer yeah yeah you did an ID oh this one yeah uh yeah I can share this of course let me we'll just copy pasta this into uh little GitHub gist no no internet okay well uh I'll definitely do that and I'll be in touch thank you questions [Music] [Music] [Music] [Music] thank you [Music] [Music] thank you thank you [Music] [Music] foreign [Music] [Music] [Music] [Music] foreign [Music] [Music] [Music] foreign [Music] thank you thank you [Music] foreign [Music] [Music] okay [Music] [Music] thank you [Music] [Music] [Music] foreign [Music] thank you foreign [Music] [Music] thank you foreign [Music] [Music] foreign [Music] [Music] thank you [Music] for the first time in my life [Music] message me [Music] [Music] all right [Music] losing control [Music] trees [Music] [Music] foreign [Music] foreign [Music] [Music] [Music] thank you [Music] [Music] foreign [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] [Music] [Music] [Music] foreign [Music] [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] [Music] foreign thank you [Music] [Music] foreign [Music] foreign [Music] thank you [Music] thank you [Music] foreign [Music] hello guys Welcome to our Workshop about building the apps like a pro and my name is and these are my colleagues mihao bartek and shamek they will help me today so if you have any questions or problems let them know they will help you for sure all right so maybe let's start from what the app is anyone wants to answer this question what is the app the centralized application okay can we have second mic so we can handle questions where is it second one where um uh ID app is an application that rather runs on a centralized server runs on a decentralized network like ethereum or an L2 so is it like UI for decentralized system maybe application that uses that centralized system or maybe application that uses smart contracts in blockchain and maybe an application that has no Central server so like it's hard to Define like find one simple definition of decentralized application but apparently it's very easy to build we've used that of course so let's see first how to build the centralized application yeah we have different ethereum API providers like Alchemy and inferior and we can connect them right so we can get this connection to blockchain by them and we have different blockchain calls two of them actually read that are totally free and you only read their state of the blockchain uh while the second one a right type of calls and it costs gas fee it requires wallet connection additionally it changes the state of the blockchain that's why it needs private key and follow so these are the examples of such blockchain calls first is read and here we just check the balance of the this address and the second one right right call we just send transaction to the to the address so that's why we need private key and the wallet let's talk about blockchain state for a second it's all about mining blocks right and each new block is from 10 to 20 seconds so each block is like around 15 seconds or something like that and the state might changed so each time we need to check whether the new block didn't change our our state so our application needs to be updated very often ideally each block we should update our state in the application right I hope you agree with me Additionally the app is very complex like typical application interacts with a lot of smart contracts a lot which is let's say x it might be 50 it might be 100 and it needs to update State very often frequently ideally each new block so it's like X calls per 50 30 seconds so that's a lot let's review leading API provider costs and you can see that it costs a lot if you want to optimize your application you can pay up to one thousand dollars per month if you want to optimize your application if you have too many smart contracts interactions but we have something like multicore and it helps us aggregate it's like actually it's smart contract that helps us aggregate all these different calls into one simple single request so there is no problems with optimization right so we can just use this smart contract it has this function aggregate so we can but all these calls in my request additionally we have guarantee that all these values we get from from the blockchain will will be from the same block which then we will have state consistency which is great so this is how it looks like with without and with multiple so without we have this a lot of different requests to different smart contracts but with multiple we have only one call to multicol and then multi-call calls all these different smart contracts for us so let's summarize the app requirements we have we should have like a requests we should um like update our state ideally each new block right we should have consistent state so all the data should be taken from the same block additionally we should like optimize our app so we won't spam API with a lot of requests but don't worry use that does it all so you don't have to worry about all these different multi-calls and updating State teaching block it's everything built in use that so let's go to examples of code how to use user so here we have an example how to connect to a network because we need to have like a wallet connection to interact with smart contracts right so see how simple is that we just get we have this use eaters function that we can get from used app and it returns us activate browser load which is a function and when we call this function we have our like like used app will ask metamask to connect so to your to your application so it's that easy I mean in this few lines you can connect your wallet with metamask or any other wallet and in this case it's like browser wallet so it's my task but yeah and additionally this account is just the address that is currently connected so that's really simple Peter balance this is how we can get it another function use either balance and it gets account which is the address you want to check the address the balance and then that's it and the nice thing is that this ether balance you get from UC turbulence function will be like of course will be put in the multi-caller call so it will be only one call each new hook you use from a used app will generate only one call each new block and the state will be updated on each new block so that's additional really cool additionally we have another example of a nice helper function which is use token balance and this is how you can use it you just pass their address of token you would like to check the balance on and then the account address that you would like to check this balance account and and you get updated each on each new block by balance in this case but you need to remember about one thing that is really important here because we need to wrap your application with the app provider that we also provide as used app and it needs configuration for example here we just passed read only chain ID so the change that we would like to support in read-only mode and with only URLs for example our own infuria or Alchemy or any other API provider URL so we can support anything and you need to pass this config to the app provider so that is the only requirement and only then inside of this app you can use any hook we provide from USB additionally we support multiplayer multi-chain multi-chain so you can for example here we have this switching networks function so you just import switch Network and each and this function will ask your wallet to switch Network for example in this case we want to send transaction but we want to send this transaction only if we have we are on mainnet so in this case we check whether the chain current current chain ID current in wallet train ID is not mainnet and if it's not then we switch we um we want to enforce on the user to switch Network and this is how it can be done with fuel step and this is how we can check for example in read-only mode on different chains for example iter balance so for each hook we provide you can add additional parameter which is chain ID and an object that gets chain ID and this is how you can get for example mainnet arbitrum and ZK sync balance in one place and this is super easy to use all right so that's it from Theory and now we can go to some practice and practical stuff we can start coding so what we are going to do today is we want to create an application that will interact with um girl usdc that is deployed there and we'll use used app and all these different it's different um features so these are the requirements that in my opinion this app should have but if you feel like you would like to do something else feel free to do that so in my opinion we should first start with connecting our wallet right so we should have like this button connect and then connect with metamask or any other wallet then we would like to display our heater balance and to prove you that it can be multi-chain and we can do it on girly and girly optimism so let's display two different balances then let's display girl usdc balance as well our balance of course then probably it will be zero so let's make this application to meet ourselves some usdc and then transfer this girl usdc to anyone maybe it can be your friend next to you sitting next to you yeah so that's what in my opinion we could today today I do today so yeah and we prepared two tracks for you you can scan this QR code and go to code sandbox where is prepare the boilerplate so you can start coding with us and we have the different tracks first one is easy tracks so we are going to live code review so I will be doing all these different steps and you can follow me and of course we have here bartek sham Academy how who will help you if you get lost and additionally we have protracts so you can do it yourself we have here the requirements displayed so you will know what to do something happens so okay now you should see and great and yeah if you get lost you can switch from one track to the other so if you go to Pro track and you decide yeah no I I can do that I can't do this and I would like to switch to easy track someone from my colleagues will help you to get up to speed with us and then you can continue Additionally you can join our telegram group and if you don't have regularly clearly it if on your account we can send you um prepared prepared a script that will send you automatically some girly if so yeah go to this telegram group if you don't have Gallery if or you can use of course faucet garlic faucet but yeah it will be easier for you to just go to the telegram group send your address and we'll send you send you girly if right and additionally we have something super extra for you because there is a chance to win a ledger Nano s so we decided that okay so anyone who creates the application with my help or yourself then there will be a chance like one like last 10 minutes of the workshop we're going to allow you to present Your solution and how you did that and the best the most interesting application will win the journal right how does it sound I hope cool of course we won't get you the real Ledger we'll give you a gift card right because it's not safe to get your Ledger from anyone right you know that I hope all right so yeah not this one all right so let's go back to and this slide yeah so any questions so far everything's clear okay we have one question there I can pass you a mic oh hello hello um I suppose that yet but uh this work with uh all the scaffolding tools like a create reactor app and all that kind of stuff I mean it's it's working automatically with create react app and uh yeah yeah okay yeah that's all thank you sure yeah so for this workshop for Workshop we prepared like a code sandbox but you can use it to create a react app yeah right um any other questions Maybe all right so if there are no questions let's go to coding right now so who choose the project raise your hands one two three four five okay there are something all right and who is going to code with me on easy track great perfect so let's go talk all right let me make it bigger yeah so did you manage to scan the QR code are you at the same page as I am that's important because this is where we are going to work together uh do you have it all right so you can scan it again so this link leads you to code sandbox and there are some ready components that we are going to use and this is all right so are you with me on this page did you manage to love that I know the internet connection is really bad here and there on the wall there is like a password to another Wi-Fi password for Workshop specifically so it might be useful for you to use that one or maybe your your mobile one will be fine as well all right guys so if you have any questions just raise your hands and we'll help you all right so are we ready to start coding I hope so all right so if you are with me and then let's go to app.js and this is where we are going to start our uh coding actually let's go to index.js and this is where we are going to start all right so I hope you remember what I said before but always before we start using used up we need to start with wrapping our application in the app provider and in my opinion index.js is the perfect place to start and to do that so let's first here import the app provider and you can do it like this from use that curve not like this like this can you make the phone bigger that was the question that I heard is it better now a question there is it better can you see it great all right so we can import the app Provider from used app add use dab slash car and this is the exact name all right and now as you remember I told you that we need to create configuration file a configuration object for that and so let's name it config as always and it needs to be an object and what we need there is like read only and chain ID it might be for example let's start maybe with yeah go early let's import chain ID from used app as well so we can use it chain ID dot as you can see use that supports a lot of different chains and girl is one of them great so we have this config file ready for now thank you yeah and also yeah let's add also read only urls and that's another object with and keys are the chain ID chain ID actually chain ID so in this case let's use clearly as well and then we can use get default provider function from that we can import from eaters I hope you know eaters library is a great Library if you use it then I hope you like it and this is how we can create this read-only URL from a for configure configuration all right and now we have our config so we can pass it to the app provider so first let's wrap our application you can do it here with the app provider like this and pass their config always remember to close text all right so this is how it should look like everyone follows is everything clear nice so now we have this um our app wrapped with the app provider and now we can go to our app and actually start coding so as I said before let's start from connection of our wallet and how we can do that first we need to import use eaters function and we can do it like this from use that curve as well because this is our core function and it you will see in the future that it returns a lot of different useful helpers functions and one of it is actually activate browser wallet function and we of course need to call this function all right we can add here button with on click function we'll just call this activate browser wallet action right let's display connect text on this button and voila you can see this button and when we click on it it should ask our metamask to connect I know the font is really small but yeah and as you can see it works and that was only one one line of codex or two lines but okay how can I know that it worked that I'm connected to this application of course I should display my address right that address of the account that I'm I connected so let's import accounts and that's and let's display it and this is how we can do that we need to make sure that this account exists because then it will be just undefined and as you can see we we can see actually the address so it worked it worked well all right so now let's display my balance and how we can do that we can just simply use another great function so maybe let's first import this function so you won't get lost again we import this function from use that course so we can do it after comma use inter balance it's called all right and now let's just use this function let's call this iter balance and then use this function and let's pass there my address and let's display balance maybe let's add new line all right we have an error and you know how to fix that maybe and he has an idea yeah so yeah that's just an object so what's used up like use either balance returns in this function big number exactly that's how we should just pass it like make it uh yeah this string right for example here in this case let's start with string and now it should work let's wait for a second so usdap will return um big number so in this case we can parse it to string but I prefer to not use the string and you will see why because it will display a lot of different zeros okay let's see why it's not working let's try to uncomment it comment it and then see foreign [Music] yeah already but too many people in one building and that's how it ends all right let's wait for a second but yeah so what we'll see on the screen when we parse iter balanced as a string we will see some number with 18 zeros right because that's a big number and that's why we shouldn't display such thing to user because they will get like you know uh they will see what happens what happening why do I have so many eaters right so normally I really like to use Peter's functions for that and this is how you can get this function so I always use utils parsitter not format heater sorry I always confuse these two all right and this is how I always like to display balance offitter of course for different tokens you like to you would like to use probably format units and then pass as the second argument and number of decimals that this token use Workshop Wi-Fi you suggest maybe something is happening oh nice all right let's connect again click nice all right and we display account and now let's try to display eater bands but still the internet all right can you see it the balance nice all right so now maybe we could display balance on optimism clearly right because we can do that as well but first we would need to add configuration file right all right so let's not do that right now let's let's go to the next step and when we have time we can um go back to um optimism Gallery all right so as I said before we would like to create an application to interact with usdc that is deployed on gardening and you can find this address of this usdc in the addresses.js file and if you are a smart contract developer and you know how to or maybe not you are a developer but you'll know how to read the code of smart contract you will see that this this contract has open open mean function so anyone can mean any amount of token they want so we are going to use this test usdc for this Workshop purposes all right but first let's just display the bus um of our address in this usdc is there any problem and you need maybe help so anyone needs help yeah if you are coding and you get lost or you would like some help or you are you know on Pro track and you need help bartek mijo could you handle that question and maybe you see that it's easy but you haven't started with us and you would like to join us then also raise your hand and we are going to help you with anything all right uh yeah I can see you someone will come to you in a second because uh uh yeah index.js and this is how it looks uh yeah anyone needs some help raise your hand and uhmek is free for some help the person in the back you need help could you help out there yeah the address of the smart contract is in the file addresses.js and you have it in the sandbox it's there so you can find it on the left side no no no YouTube is important from eaters eaters yeah eaters it's a great Library I love eaters seriously amen all right guys can we move on okay I'll wait a few seconds we had the question there no it's fine okay address okay anyone needs help raise your hand bartek is free and he can help you yeah index.js here you have it so we imported the app provider and chain ID from used up car and additionally get default Provider from meters all right foreign so let's go back to app.js and now let's display usdc girly usdc balance of my account it's probably zero but I would be surprised if it wasn't zero all right so now let's start from importing the depth function the function is called use tokenbalance written like that all right and now let's just get it from blood like this and we need to and here as you can see we there are two arguments first is token address so we can use the address that I have here it's called usdc and I export it so I can just import it like this import usdc from addresses perfect so now we have the address of usdc and we can pass it as a first argument of the use token balance function and the second argument is my account address like this all right and now let's just simply display this balance on our UI let's add another enter and that just displayed but still this is a big number so we need to first let's start with making it it string all right let's wait a second and yeah we have one big zero all right so now we can do something more difficult and we can call like send a transaction to usdc and we can mint our um some usdc token all right and this I hope I remember the Syntax for it but we'll definitely will need to use use contract function all right and this is how you can import it from used up curve as well all right and this function is really interesting and it gets three different arguments and these are more advanced so I hope you won't get lost and if you get lost we'll help you um with that so this function will return um send function like that so we can get it like that because it's an object and one of the um parameters like returns uh values is send function and this is the send function we will call it so just send this transaction and we can use it like that so use contract function and you can see that we will need contract contract function name and what else options all right so let's start with contract because that's um tough to create all right so contract is an abstract of this contract so let's name it usdc and it will be in contract that if you know eaters Library you will know this contract let's import maybe yeah let's import this contract from eaters first and we need to create this contract again what it needs first it needs this address so we can just simply pass usdc in the address and then we need contact interface and we need to create it so let's import it from meters as well and this is how you can do that it's hidden in providers dot interface not providers but duties sorry utils dot interface and that's an object so we need to create it foreign fragments of Abi so in this case for usdc we'll we are going to need only mean function so for now let's just create it by hand so it's just an array of signatures of these functions so let's name let's create it like that it will get address and value which is un25 and this is interface we need for this contract are you guys following is it fine all right so what else do we need for this contract address interface and should be it all right so now we can use this usdc contract to get this send function all right what is the second argument we need here it's function name so we can just use this mint function so here we just need to pass the name of the function we want to use so if we want to use more functions then we can just add more functions to the interface we created before right like send and like in production you would probably need to have that you know the interface that was the result of compilation of your smart contract so you want to type each function separately but for this Workshop we are just like you know using this simpler version all right and now actually that's it and now we can try to use this function let's see if it works uh yeah let's give me one second maybe let me make this interface like this [Music] can you see it now is it better okay that's my suggestion thank you all right guys any questions so far anyone needs help raise your hand and the guys here can help you all right so now let's come again oh question um she will go my man is is the um is it I saw you you put ether's providers that um import but no it's not necessary okay it's not necessary that's that's all yeah sorry that was my bet all right we will just need a utils from meters all right and now I hope it works all right so now we want to trigger this transaction somehow and we can do it by adding additional button like this button with texts sent sent message right all right so I know this is not the prettiest application you ever seen all right so create let's create another um button and here let's add like this all right and what we would like to do on click we want to actually trigger this send so send this transaction and let's do it like this because we need to pass argument to this function and if you know erc20 inter standards you know that mean function gets to arguments one of this is address of the address you would like to meet and the second one is the value right so first maybe let's use the account we are connected to and let's start with one all right and now Let's test it it works so as you can see it triggered metamask window and we can see here that something is happening all right let's confirm random application confirm metamask transactions all right and now let's wait a second for this for this transaction to be minted and we expect that if we did it correctly the balance of the of usdc should change right and voila it changed nice cool so as you can see use that updates all of that with each new block so it takes some time of course we have internet here really poor but yeah all right so are you following have you managed to send this transaction with me who sent the transaction nice great we have three free people who did that all right guys so who got lost and need some help with sending this transaction behind you all right anyone else would like some help with that uh we have another person question would you like to get me Mike wondering I was wondering where we're getting the usdc from yes so usdc [Music] oh okay so you all have it okay thank you sure yeah app.js all right so I will give you like one minute to uh could you pass the mind I was just saying like there was a link at the beginning to get uh the girly um yeah details right this is the link to our telegram group and if you send their your address okay [Music] transfer you some girly if yeah we already founded a bunch of accounts please send yours as well a question or help help um where are you in there hey could you raise your hands and guys so if you need help just raise your hand section is there waiting for yeah I'll go back to uh to the app.js and in the meantime I'll add some changes to to the application so it looks nicer so here look like this nice better now let's do the same with eater balance like this nice all right so who is ready to move on to the next step perfect perfect we are ready great so maybe let's change it because as you can see here the balance is one right but we know that usdc has more decimals than just the zero uh do you know how many decimals do usdc have 18 not it's not 19. six exactly right all right so what we need to do here is to form like first of all we need to actually send mint ourselves not one like base like um unit of usdc I actually would like to meet ourselves one usdc right one foot it was DC so let's use utils for that and it's ours units and it will need us to parse string and yeah and the second argument is the number of decimals so like that all right so as you can see here instead of just passing simple one I'm just using utils.parse units with six decimals so we'll have one full usdc minted all right so let's try again I mean some usdc but this time it won't be just one unit of usdc we will go for full USD and again if you have any questions just raise your hand if you would like to speed up speed with us let's confirm this transaction yeah and now let's wait a second and simple question do we have any volunteer to present in five minutes nice perfect any other volunteers present their Solutions so no oh okay we'll have competition then perfect all right it takes some time nice so we minted more usdc but now we need to display it differently right because it's just one and a bunch of zeros so let's use format units similarly to the previous one with six decimals nice so managed to do that all right and now our final step of this Workshop which is sending usdc to someone else so we mean that ourselves one usdc and now let's transfer it to someone else all right so our first step in this should be adding to interface transfer function right because for now our application doesn't know that erc20 like usdc has this functionality all right so let's add function transfer and do you know what arguments transfer function gets in year C20 first is address right for whom and the second is value right so again we use address and you you need two five six great so we have our interface and now again we can use use contract function but this time we'll need to name this sent differently because it won't work it's the same as mint but the name is different right so the arguments are the same all right so let's go back to use contract function let's name this parameter transfer okay and now we won't have Collision all right and now here also let's use transfer right so we we change the name of the function we would like to call right all right so now we can actually use this function so let's add another button I know it's not pretty application and another on click function let's name it send usdc and now let's call this transfer with arguments so all right so where should we send this usdc I mean where I mean what accounts address what address maybe if you are on the telegram group you can take different address not yours but someone else and then sent this person some usdc right so so in my case it will be my second metamask account right so I will so here you can pass this simple string right the address will be just a string and now we can transfer so let's start with simple one or you can change the actually use different numbers so because if we everyone will send like one way of usdc then we won't see that change right because everyone will be the same number all right so I will send free maybe all right and anyone needs help raise your hand bartek is here to help okay we have someone there great and now in the meantime I will try to click Send usdc and try to do that all right foreign yes sure foreign you will find the person the red shirt all right guys we have 10 minutes and till the end of the workshop so maybe the people that would like to present get ready and you'll show us your solution all right guys so we managed to send usdc so yeah that would be it guys I hope you managed to do the same thing as me and yeah if we have volunteers then yeah maybe let me just tell you thank you for your um for your being here and thank you for coding with us and yeah if you have any questions just don't hesitate and raise your hand if you have questions thank you all right and now we have some time for presentations so if you would like to show you show us your solution feel free to come here and get a chance to win a ledger Round of Applause [Applause] foreign [Music] yeah guys I hope you enjoyed the workshop and that now you will use use that for you know your application development because I hope you you know how right now how easy is that right all right okay so I coded it into my little website and you can connect with your wallet and here you see the address you can disconnect again and and of course yeah but the app looks amazing thanks let's see if it comes up again before okay and the special feature I can send to myself it's just a wrong text on the button I think and I can send to others by copy pasting an address and um I can send directly to them all right and like this can we see the code and how is it used in your step okay so what I do is that I take an input with the target value and I set a state and then I use that state in the send foreign nice thank you great [Applause] any other volunteers all right in the meantime guys if you have any questions regarding used up feel free to ask them foreign thank you all right guys we don't have any more time but you can show it um outside of the room and then we will get a winner all right thank you [Applause] okay um thank you um [Music] thank you [Music] thank you [Music] [Music] thank you [Music] [Music] foreign [Music] [Music] thank you [Music] [Music] foreign [Music] [Music] thank you friendships foreign hello everyone um I'm Fabrizio these will be a talk about compositionality uh it's probably a word that not all of you know and I'll try to explain what this is about in the course of this Workshop uh in the last months probably a year or so we've been hearing a lot about composable things composable blockchains composable service compositionality is basically just a mathematical Structure Theory that tells you how to do that in the most principle way possible uh I'll start and if you have any question just feel free to like raise your hand and interrupt me and I'll try to answer and or clarify okay so first of all to introduce the concept of compositionality we need to introduce some basic building blocks that are systems and processes so compositionality is basically the study of how systems compose to give life to more complex systems systems are basically things that can be transformed enacted upon and processes are exactly the things that act on systems and transform them uh a very interesting Insight from Modern mathematics the mathematics developed from 1950 onwards is that often is way more fruitful to understand something to describe it by looking at how the thing composes and behaves in a context so instead of splitting things open and look how they look on the inside we describe them by saying how they behave and how they interact um okay so let's start with something very very simple I will use a lot of pictures in this talk and hopefully close to zero mathematics uh for people that love mathematics I cannot that there is a soundness a completeness theorem that says that these pictures are formal which means by doing pictures we're actually doing mathematics it's just easier and more beautiful in my opinion so in here we have a very simple process that we depict as a box it just takes a number in input adds one and spits a number in as output I mean for I guess everyone acquainted to with programming that's just like man yeah okay uh the point is that when we have a process a process like that we can compose it with other processes so for instance in here we take this process we notice that it needs an input that is a number and spits out an output that is a number and we realize that oh we can actually pipe this process with itself and if we do that by just concatenating the boxes you see that these will be equivalent to the process that adds two to your input now this seems very naive but the nice thing about this picture is that it goes both ways you can start from the top row where you have simple components and you actually abstract away so add to uh is basically just you know the dotted box encompassing the two or you can do the opposite you can start from a process up to and open it up and further specify it with a finer degree of accuracy and since you have an equal sign you can basically go both ways now there are very peculiar processes that that are called identity processes these are the processes that don't do anything in this case with the number example we have a process that is at zero that takes a number in input does absolutely nothing with it and spits the same number as output the good thing about graphical reasoning is that since this thing is not doing absolutely anything we can just not draw it and indeed I'm drawing it as a dotted box uh down here just to highlight that there should be something there but you know with this very simple trick we can already start proving some equations that are very simple so if I add one and then I add 0 is like just adding one right if you know you adopt the convention of not drawing identity processes then the picture on the top row just looks like the one in the bottom row while you have stretched a wire a little bit more similarly from uh I don't have it here on on the slides but you can understand that in this formalism the composition is associative we don't use parentheses if you concatenate three boxes one after the other it doesn't matter in which order you obstruct them in the end you only have three boxes so it doesn't matter how you group them okay let's do another example so for this example I'm using gravitation gravitation that has absolutely nothing to do with crypto I admit uh at least I I think I don't know maybe uh so we have a system that is a sun that is just sit there and you know does nothing and raise the earth that is orbiting around the Sun so you know during many centuries people thought a lot about this and at some point basically a guy called Newton found out that there is a process that you can call evolve in which you can feed a state of your system and then you can say okay show me what happens one second later and this is a beautiful predictive power of physics in this case of dynamical systems that allows you to start from some experimental evidence and predict what is going to happen uh in the future you see that in this example you also have an identity process that is the process that doesn't evolve evolve for like zero time it's just taking the input and is not looking in the future or in the past it's just giving you the state that is as it is now and we see that we have a notion of composition because if I let evolve the process for I don't know one second I go from the position Mark type t0 to the position Mark T1 again I can feed T1 to the system another time let it evolve for another second and I go to T2 and that would be the same of evolving the system for two seconds so again I can combine These Bricks now the important thing is that anything that matters everything that matters in this formalism is how things are connected you can deform the wires no problem what you can't do is you cannot make new connections or splitting connections if you do you are getting something that has a different meaning another important thing is that you can only compose things with matching types for instance senior I have the Hub one process we saw that that spits out a number but the evolved thing wanted something of type sun earth as an input so you see that it doesn't really make sense to compose these things because they are apples and pears Okay so this tells us the types in this formalism are very important the way you type your processes changes what you can and cannot compose okay as an example imagine that you have a car right you have the wheel and the shaft and the gas tank and you could see this as a process that takes some inputs for instance I don't know fuel or and Human Action and produces heat and motion but when you look very carefully you see that you could pour any liquid in your car right like the gas tank won't complain if you fill it with water clearly the engine will though and basically from this you can you know infer that the problem here is that the type of input of our process is to General and it allows you to fiddle with the process in a way that produces unintended Behavior another example that I like is imagine a socket in the wall you can put a plug into it and you know use any electronic Appliance but if you have a couple of nails you can also stick the nails in the socket and where you go what you get is emerging behavior all over you and very painful so the important thing here is this is the main message of compositionality so when you look at this process like the socket and plug process you can start asking what are the properties that are preserved when I compose these processes together so physically sticking the nails in the socket makes total sense because they fit but if you're looking at things through the lens of safety regulations you see that a nail can be saved can you know be certified with whatever standard your country has same thing for the socket but when you compose them suddenly you have a very very unsafe system compositionality is exactly the art of choosing these types in a way that emergent behavior is averted as much as possible so that when you compose things you know precisely what is going what we are going to get now under the hood compositionality is based on a theory called category Theory this was invented in 1942 and had a monstrous impact on Modern mathematics essentially you can see it as a super glue of mathematics that describes how different theories compose and interact basically all the main progress in you know big areas of mathematics like algebraic geometry or algebraic topology come from here and in the last year people started realizing that this thing can be applied also outside of mathematics because again it embodies this perspective that you can describe things but looking how they behave in a context so when I show you those diagrams what I'm really doing I'm always speaking a category that defines the universe I'm working on and working in uh let me just dig a bit deeper into this idea so if you want to define a category if you're a mathematician you want to Define it formally basically you have to specify various entities you have to specify objects that correspond to systems in the pictures I showed you before so objects would be the wires in the box and wire pictures you have to specify morphisms that are the process the boxes that transform objects into objects you are required to specify identities so for each system you need to have a process that doesn't do anything to it and then you basically have to specify a composition law uh a recipe that tells you what happens when you compose processes together uh let me give you some examples of categories that are probably familiar to uh I hope as many people as possible here there's a category called set where your objects are sets and your morphisms so your processes are functions between sets there is always a function that doesn't do anything and you can pipe functions into each other for programmers there is another category called Data where your objects are data types and your programs are programs that turn data types into data types again you can compose programs this is basically functional programming Style programming you can pipe you know the output of a program into the input of another program if the data type matches and you have also a program that just Returns the input without doing anything so what is the difference between these two categories well set offers an intention sorry an extensional perspective what it means is that for instance if I consider the set of integer numbers I have exactly one function that takes a number and adds n to it on the contrary in data I have multiple ways of either specify what integer numbers are and I have multiple programs that sum n to your term in here I just brought two of them but in general you see that in the car in the category data the formalization the implementation matters so these two categories offer very different views on the same phenomenon in one case you're saying I'm only interested about behavior I'm not interested about the inner workings of these functions in the other one you say no I do and I distinguish two processes they could uh emit the same output on the same input but I want to keep them distinguished now the cool thing about category tier is that you can connect these different perspectives there is a notion called functor that turns a category into another category in our framework this would be a box that is sort of like level two box that allows you to change the universe you are working in so um basically what you do to define a functor is you specify a mapping from the object of the category C to the objects of the category D so you have to say where systems of C go in D you do the same for the morphism so for each process in C you have to map it to a process in D and and this is the important thing these mappings have to map identities into identities and compositions into compositions so what it means is that if I compose two processes in C and then I use the functor is the same of using the functions on the components and then composing them in D questions or sure not necessarily you can have functors that are called full and faithful that allow you to yet basically be inverted and go one direction to the other but no in general these can you can lose information or you can embed it embed a less expressive Universe into a more expressive Universe if you want to sure but sorry the factors as information so I don't know linear transformations uh maybe I don't know like there is this very convenient thing that in category Theory everything is everything else like I'm not going in depth into that but you can describe a category as a factor and a factor as a category and blah blah blah so it it is possible maybe to describe a function as a sort of linear transformation in general what I can say is that you can Define categories of vector spaces for instance and in that case your morphisms your systems will be linear applications that respect the linearity of the vector space uh yeah you know uh yeah yeah this is exactly what happens because this thing is basically mapping processes of C to processes of D so you can see it as an higher level function and indeed a factor is a process in the category of categories so you can do this kind of you know level up let me give you an example of functor this is a functor that actually collapses information we saw two categories data and set and we can define a functor that sends a data type into the set it implements and sends every program to the function it implements so this is exactly what I was saying before that you can start in the category data and be you know very detailed about distinguishing things and then you say actually I don't care I want to collapse all this information and I want to forget about you know these different details you apply this functor and that's exactly what you get all your process compositions now you know lose a part of information obviously there are very interesting questions like how do I invert these things can is there a procedure to canonically invert a functor and actually go for instance from just a specification to sorry from a behavioral extensional perspective to something more complicated sometimes you can sometimes you can I don't think yeah so imagine that int is a data type that you define I don't know inascal uh about integers that data type is basically modeling the set of integers in a computer right so conceptually you can say I can send that to Z similarly if you have the data type string you can have a set of all the possible words on an alphabet and again you can send string to that set uh with this functor basically what happens is that these two programs here get mapped to the same function between sets so I have two different implementations of the same program that maybe you know I consider separate as programs like if I for instance hash the one on the left and the one on the right the hashes will be different uh but they correspond to the same function they are implementing the same function so when I go from data to set i'm I deciding willingly to lose that information okay let's try to use what we got up to now to do some process design that is actually the interesting part of it this is a very simple example imagine that you have a grid and you want to define the process of moving on this grid so imagine that you can only move of you know a kind of fixed amount of things so it's not like I cannot move like 0.1 steps but only one step at a time in this case you'll see that wherever you are there will be four fundamental processes that are up down left right that allow you to move one step and now I can basically describe every path as a concatenation of these processes so for instance if I move three times right and two times down I'm describing the L path I have there if I feed to this process a couple of coordinates that tell me where I am then these coordinates will be transformed as in the end of the path basically and we see that in this kind of theory we also have some equations like if you move right and then down does the same of moving down and then right you are describing a square you are just walking in like different paths but you end up in the same place let's spice this up and let's do it concurrently now we have multiple agents uh wandering on this grid and we want to model you know how they move intuitively what you do is well now we want to consider processes that happen in parallel like if I have two agents for instance I can have this process here that says agent one moves three times on the right and agent two moves down and then on the right and now we see that new equations pop out so for instance I have this equation here called The Interchange law that basically says these two threads are separate you can see the first are saying I move somewhere internet do nothing the other agent does nothing and wish for you to move and then moves in this setup is the same if you just you know swap the things and second agent moves first and first agent moves later why because intuitively these two agents are not causally interfering with each other agent one doesn't care at all about what agent 2 does and vice versa and so in these formalization of moving on a grid concurrently I have these extra equations mathematically we say that the Universe we are relying upon is not just a category but it's something called the monoidal category that basically means a category where you can do also things in parallel okay let's do more like programming oriented example so let's consider a very simple record let's call it person uh This Record has two Fields name and surname okay um now you can notice that in this record uh in this example person is basically just a couple of terms of type name and surname now we want to be able to you know functionally describe the procedure of extracting a subfield of this record so you give me a person I give you the name for instance and we also want to be able to replace the subfield of a given type with a subfield of a different type this is a bit more complicated but what it really means is that for instance imagine that I want to edit this personal record I want to strip surname out and put a new field in called age that is of different type so the point is how can we do that in a automated and more importantly compositional way uh so what I mean by compositional is Imagine This example where I have the record person but one of the fields is itself a record it's a sub record and now I say okay I want to replace the city thing there Bogota with something else intuitively I want to be able to pipe the process for editing person with the process for editing address and you know feed these compose these two processes in a way so that I don't have to reinvent the wheel every time the way you do this in a functional programming and in compositionality is with something called a lens that is a particular example of something called an optic so what is the idea uh the idea is that a lens is just a couple of processes one called get and one could put and basically get is taking your record and is giving you the subfield that in this case is s subfield of a what put does instead put is taking your record a is taking something of type T and intuitively is replacing s with t and now he's spitting out something of type B you see the type of a could change because you replace the type of a subfield of this thing if a was a couple of strings with this put I could substitute a string type with a nint type and then the overall type of the record will change the funny thing about this is that you know there is an ask a library for instance that allow you allows you to automatically get these things for every a s and t as soon as you define your type A this thing will you know create the Setters and Getters automatically for you so it's a it's a procedure that you can automate and that's the cool thing now you don't have to do it manually the library does it for you okay so I'll do these things compose imagine that I have two lenses so the first is sticking the subfield s from a and the second one is taking the sub field V from s the get part is easy because you see you can just telescopically access the records you can say I start from a I pull out s and I pull out V from s part is a bit more complicated so what happens here is that imagine that in S I am replacing the subfield V with a subfield W and I obtain something of type t and now I want to replace uh s with this type B into a how do I compose these two things well with this sort of like monstrous awful thing here in in the bottom where I basically take a I copy a I get S from a now you see I can use this put put V and basically substitute uh V in s with W I get something of type T and then I can use put on T and A to get a B I know that this song sounds very cumbersome and difficult to follow but the good thing is that you can you know topologically deform these diagrams and basically Express them in a way that makes way more sense so in here instead of considering this funk these things are two couple separate processes I'm you know packaging them as a unique thing so as you can see this thing is a bit strange because it has arrows going in opposite directions so on the top row a gets processed into an S so you are extracting s from a on the bottom row you are getting this t on the right and you know you are writing s with t and you are getting a B on the left this is an example of a bimodular data accepts accessor the way you can think about it is as a process that says if you give me an a I will read field s and forward the output to you and if someone else from the future will give me a t i will replace S in a with it and return you a b and the good thing about it is now you can compose them exactly as you composed the processes we sew up to now and when you do this if you squint your eyes a bit you see that we are doing something that is basically equivalent at that to that cumbersome composition we had before but now is again graphical like you can just compose these Lego bricks together again and this is the art of compositionality anything that really changing is the point of view so you can still deform this thing in another way I'm just rewriting the top diagram as the bottom diagram if you see the interconnectivity of the diagram didn't change and I can shape it as a comb basically and again it's the same like you get a in you get an S out then you get a t in and then you get a B out these is really interesting because when you look at this com process it really looks like something that wants to be a normal function but it can't because it's waiting for you to do something intuitively if you have an automated way to turn S into T that thing would just be one of those naive building blocks we saw in the beginning and you know in this framework the composition will be nested he would be of this sort you are basically composing comms by substituting a comp in the whole of the bigger comp and again this composition is exactly the same when you follow the the processes and the interconnections of this one this one and this one are the same thing we just deformed the way we arrange the diagrams now again as I said you can see a comb as an incomplete process that basically is waiting for you to do something to turn a nest into a t and that would be that F that you put there and if you put it there this thing basically closes up and just becomes a normal process but what is really interesting about this is that we found a pattern so we started by modeling record rewriting but now we found a new pattern of composition that is this kind of nested composition and indeed there are a lot of things that compose in this way if you abstract from details for a second these two processes are basically representing two different points of view of the same thing that is bi-directional transformations now let me give you an example of how you can use these things an example would be estrus what is an escrow trait an escrow trade is when I want to give something to someone but I don't trust that someone or that someone doesn't trust me and so what I do is I take my funds instead of giving them directly I lock them up in a vault and then basically you know my counterparty will ship me some goods and when I receive them I will confirm that I received them and at that point my funds are unlocked and forwarded and that is exactly a calm looking thing it's like I committed my funds I locked them and now I'm waiting for confirmation and as soon as you give me confirmation and you put it in.com then this looks like a standard transaction from A to B another example and this will be the main point of the second part that my colleague Philip will do is Game Theory so we can model games in Game Theory as op as open processes basically in that case a game will be a process that has again two inputs and two outputs it will take in input and observation so it will observe the word it will spit out an action According to some strategy it will receive a payoff from the outside world and you will return a feedback the feedback is probably the most difficult part to get in this composition method and you have to imagine it one of the ways to imagine it is is the portion of your payoff that you have to return to someone else stupid example if you take a depth you place a bet you win you get a payoff that you have to repay the debt and the debt repayment would be the feedback wire in this system of compositional Game Theory we can recover traditional games as a composition of processes so this for instance is the prisoner dilemma uh I guess a game most of you are familiar with and normally we see it as a payoff Matrix and you know like if player R does this then this is what happens if player B does that blah blah blah in this case prisoner dilemma is the composition of three different processes player one player two and payoff Matrix these three things in isolations are games player one and player two are games that do not observe anything because you don't do any observation in the prisoner dilemma they just act they just you know Express a choice and they receive a feedback for that choice the payoff Matrix gain is a game that doesn't act it doesn't have any strategic value but it just observes the players move and returns some feedback and again you see that in this setting the players payoffs are the payoff Matrix feedback and the player's actions are the payoff Matrix observations so yeah the cool thing about that is that now we can quickly prototype games by basically creating these blocks and interconnecting them with each other one thing we are currently working on uh and Philip will show a demo of this is for instance a way to lift evm byte code to open games automatically in doing that you know if you deploy a smart contract we can take your smart contract and put it into this framework and then we can strategically probe it your smart contract would become like the payoff Matrix in this system and then we can economically probe it with players that can be honest or untrustworthy and see you know which strategies are actually winning strategies or not and so if your contract is economically sound economically stable or not or in within which bounds it operates financially in the way you intended so this is the theory part that is concluded and I will leave for the second part everything to Philip uh and basically yeah in this short tutorial we saw how we can use this compositionality techniques to guide our intuition in designing processes we started with something very simple then we start we did a bit more involved the um examples and then we found out that those examples were actually modeling and more General pattern this bi-directional composition and we were able to basically recycle that pattern to instantiate other things like escrows or open games and yeah that's everything for me and I'll just pass it to Philip thank you [Applause] have any questions if you have any questions we can in the meantime that Philips accept the computer feel free to Classic sure uh Define huh uh yeah uh I I mean in here I kind of cheated because I basically just defined an optic as you know this box obstructing the details indeed mathematically you can uh prove that I mean the definition of optic is exactly something that embeds that thing mathematically it's a bit complicated to describe uh but graphically that's exactly what it is an optic is something that has this sort of nested notion of composition basically sure yeah there are various ways to do that uh Philippe is the expert in this and I don't know maybe you won't yeah sorry um what's your question whether you can also do repeatedly yeah yeah you can do that um so the game that for business short is a one shot game but you can also think about this as taking that let's say you want to iterate it finally many times you just stack it on each other the only um qualification you have to make um if you looked at the slide they were basically the um the the wires were not coming in from the outside you have the game with wires and then you can stack it basically alternative way to do is also you can turn it into a Markov game which has a state and then you can basically think about it as approximating it to be run infinitely okay other questions to the first part there is a question in the first part um let me do the following I'm trying I'm jumping on my slides ahead um to show you this then I will go back ah sorry could you guys sorry can you switch on the okay um let me go to the so here um you have to think about it as two Dimensions right so time flows from left to right and if you start from the left there are two things P1 and P2 they are not connected which means they happen in parallel so this is simultaneously happening then afterwards the output the move which is y1 and Y2 that move is consumed by U which is the payoff function and in that sense U follows sequentially after these two games right you can also think about these two games P1 and B2 being merged into one and then it's just big two games being stacked on top okay so let me go back to the start you can already see what is coming okay um so what we want to do in this in this part in the second part by the way hi I'm Philip thanks thank you all for coming um what we want to do in the second part is basically take a deeper look look at compositional Game Theory as one specific instance of um how you can think about compositionality and what compositionality possibly can give you as value to um as an approach to thinking about in-depth specific context of strategic interactions okay compositional Game Theory what is that actually so it's a at the beginning actually this was a research project which was focused on providing a new formal language for game theoretic reasoning yeah you probably have heard about Game Theory many of you probably have already seen it it's a mathematical language to express the reasoning about agents and what we provide is just another language in some sense now this language is as for pizza already introduced based on the categorical framework and this has several consequences one is you give you first of all you get a graphical way of reasoning but most importantly you get a way of compositionally approaching the modeling problems um that you that you face okay now if you just do the diagrams and you you know suppose you would be forced of you know using diagrams for very large systems like a staking protocol or other complicated more complicated systems that would be limiting it would not be that much help it might be a cool new Theory it might be of interest because some academics but practically maybe not so much relevant what is up what however is a consequence of what also for pizza already said dami there is a very close connection to Optics and Optics allow more or less these things to be directly implemented enabled us to also develop on the site a software tool which basically takes the language of category theory for modeling games and turns it into a software framework that you can use that supports your modeling process and that's the key thing because if you would be forced to doing things on pen and paper well yeah would not be that practical once you have this Tooling in the back then you can actually leverage um the basically the benefits of compositionality and the purpose of that basically second part is hopefully to convince you that at least this might be interesting and hopefully more that this might be really useful okay so a large chunk of the talk will also focus on the implementation so what does the implementation actually provide um first and foremost it's just a framework in which you can express and represent strategic interactions like the prison dilemma but obviously also more complicated stuff many times you're not only interested in representing models but you naturally are interested in you know what kind of behavior may result from these models so you want to you also want to analyze them in various ways in the current engine there are basically three ways to do that one is interactively so you basically run a session and then you can query um your model let's say I'm looking at a stake um staking protocol and I have some idea what would constitute on a strategy of the participants and then I can ask okay if I'm feeding in a strategy this is actually an equilibrium or do specific agents have an incentive to deviate and the way it works is a bit like a proof assistant it will tell you you know your proposition that these strategies make sense either makes sense and then it's good or it will they will the compiler or the engine will tell you wait at least one agent basically has an incentive to deviate and here's the incentive here's the specific action that this player can take um now the interactive part is very useful to explore parts of the model and for the staking stuff we will also see an extended example on this it's quite useful to think about specific vectors of attack and then you can verify does this actually work or you know what two specific agents actually react to If a strategy of another player changes you can also think about for pizza alluded to that um that there is a system a which is somehow represented as an open game or several open games you make changes in that system these changes propagate in your open games and then in the back you're running tests on what kind of behavior would you expect from this kind of system yeah so it might be that you have an incentive mechanism and it works but you make a change to the overall protocol a how does that actually is then this is translated into the open games framework and in the back you're running tests on the behavior of the agents and then maybe things go through or you get a warning something is not working anymore as before and lastly theoretically as well as from a practical implementation perspective there's a very close connection to machine learning framework specifically reinforcement learning I will say a bit more at the end if I have time but the idea basically is that you can either leverage reinforcement learning techniques and machine learning techniques more generally for solving and analyzing games solving of course has limitations because it's very complex but for some specific games it's feasible and on the other hand you can also turn it around you can also make Learners basically part of the game so that you have an interactive interaction of learning agents basically which is also quite useful because you basically have to think about this as you know institutional players um updating or actually um Learners themselves as part of the um of the model for instance in pricing settings okay um what's the key Innovation well compositionality obviously that's a key point but what does it actually mean here if you think about the prisoner dilemma what is already showed um is that you can think about the prison dilemma at least from what you have seen so far as either one monolithic billing block or at the minimum you're splitting it up in three components right now for a prisoner dilemma that's not that relevant but the more complex your scenarios become the more helpful it actually is to say look I'm taking that part I'm zooming in I'm modeling it zoom out take another part model that zoom out and so on and so on and later on if you do it right you have basically systematic ways of composing these things together into a bigger model now this doesn't end at that level you can also for programming purposes or because of convenience you can further modernize your code let's say there is a specific thing a specific way you want to approach it you can split this up implement it in different ways and the key thing about all of this basically so far is that all what you're doing will be guaranteed to make game theoretic sense if you follow basically the syntactic descriptions or restrict restrictions of the engine that means you start out modeling if you use our language you end up you can decompose things each of these components will make sense from a gamethodic perspective and the composting will also make game Authority sense that's compositionality at action why is this useful well you get an overall feel on the over on the on your situation that you want to model and it is sound and you can ask questions like okay what's equilibrium of that or you know if we repeat it um a Serial deviation strategy if you think about more like a Markov strategy for instance other ways of um deviating that a profitable profitable for specific players another perspective basically is that this turns the pro the modeling exercise into a programming exercise so the idea of zooming in and zooming out I'm sorry and you know modeling Parts in isolation is more or less just like divide and conquer a typical pattern that you would apply in any kind of or many programming um problems okay and the key thing again is you can modulize your code further we will see this later on we will you know we will have regular High School functions that we just lived into that and you can change these components but as long as you're staying inside of that system you are guaranteed that these things make our kind of well defined no warning uh the fact that is uh this is game 3D well designed well well defined does of course not mean that your model makes sense you can come you know you can model complete garbage um we can't help you with that if you're you know really intended to do that but what we can guarantee to you is or what this kind of helps you is at least in the process of modeling we have a scaffold that you can use all right so how is this useful um the main thing basically is I alluded to that if you have you know if you can apply divide and conquer you can easily deal with complex scenarios um it overall also speeds up the process of modeling in several ways first you know division of labor so in principle the larger the systems you can actually very easily collaborate with people um secondly if you want to change a component you can easily do that as long as the rest stays intact and lastly because everything is expressed as code there is obvious reuse for components and you know we have been said we have had several projects in the past and we can see that there are some patterns that just emerge that you can use over and over again which is useful because it speeds up um down the road how um you know and you want to model something information okay and of course yeah I mentioned this already before um you can also think about it as just being part of a larger stack where um it's just feeling a proper it's fulfilling a certain um service um like testing properties again on your on the safeness of the system from an economic perspective okay this is kind of the introduction very roughly what this engine is doing why it's possibly useful why it's maybe interesting what I want to do for the rest of this Workshop um and for basically the second part I will give you an intuition about how to model with this tool how to represent games and again the focus will be on showing that compositionality is actually useful or hopefully useful um secondly I will also give you an intuition of you know how does an analysis actually work what does it look like I will be shorter on that second part the reason is in order to make sense of the analysis you obviously have to have a deep understanding of the model um this is given the type constraints not really feasible but I still will give you an intuition of how does it actually work how does this look like okay and a leading example um that we will converge to is basically a staking protocol it's a simplified model that illustrates um these two components of compositionality and also the kind of analysis you want to run in this in this system foreign good I start with not code but directly coming back to what for pizza actually namely um introducing a bit Theory this will be partly repetition but it doesn't hurt it will be mostly about diagrams so not much mathematical content the reason I do this is the theoretical approach is more or less directly the way that implementation works model is some kind of difficulties in the back obviously if you understand how the modeling on the theoretical side works you basically have a very good idea of how then the syntax actually works and operates and that means you also basically know how to use that that um that engine basically okay so you've seen this this is a bi-directional information transformation Transformer from both sides so X is transformed into Y and then there's something coming from R to s both directions again convention is if you want to think about this is that time is from if time is on the left so on the side of X and S and the future is basically the passes on the X side and the future is on the Y side okay now in some sense in the essence of conversational game theory is that what we showed is any kind of game that you want to model has this shape and can be put into this shape whether it's just a single player making a decision which is kind of a non-typical game or a very large complex system many players moving and interacting everything can be modeled in that shape whether it's very large or very small now why is this good or why is this useful well it's useful because you can start out with small components like one player maybe just also computation something very trivial and you can plug these things together and slowly from the bottom up you have like Lego blocks you can build up a system that is quite complex and of course because you're programming you can also kind of box things and say well this is a pattern maybe two players interacting in a certain way this is quite useful you know I'm giving that a name and I'm going to be reusing that component over again okay so everything is of that shape you know so it's a bit like it's like a closer closure property in some sense you start out with a number you add a number you end up with a number the same year you started with one game compose another game you end up in another game and this is in some sense what I referred to before as this guarantees you that you stay in a formerly well defined framework okay let me come back a bit to the concrete Implement concrete interpretation of this specific box and for the next few minutes think about this box as just one player doing something now one way to think about this is essentially the player is just doing some kind of information transformation right so there is something coming from the past a move information whatever X the player observes this and internally something happens he's outputting a move why okay now the question of course is what kind of move will a player make this depends on what what kind of moves he has available but it also of course if it is a game theoretic agent Let Me Assume for now it's a rational agent who wants to maximize something he needs to think about what's my effect of choosing wire on my utility and you see that the wire is an open wire so it doesn't really specify exactly how it is interacting yet within my with the environment but what we can say is the player is expecting an R back from the environment and this openness between my action wire and the payoff data or whatever actually are is in fact what I receive from the environment that openness makes it possible to take it like a building block put it in specific situations and then sometimes I might be able to close the loop um in a certain way the most trivial way of closing it would be I have one player and I'm just bending the Y back into r and then basically my why my action that I take will be directly to think that I observe and I affect I have full control basically most interesting scenarios from a game theory perspective are obviously not like that but my why will not solely determine what my payoff actually is like in a prison dilemma there's another agent doing something and this will also affect my payoff and of course this is the idea that at some point we will give a concrete environment which determines how this y actually is spent back into a specific payoff whatever or whatever result you actually care about as an agent okay so that's the basic structure now I said before we are building up from the bottom what we want is we want to compose larger games by composing simpler games and what we need for this are essentially two kind of things we want some building blocks think a bit you know again like Lego um you have one specific thing and from that if you have it and you have more of them you can just build up a world for instance so we need the building blocks the atomic units if you like and then we need operations how to compose stuff on the buildings on the atomic building blocks we have essentially two which is a decision a single player making a decision and a computation computation means just some input is observed some output is basically the result um these these computations can have side effects so it could be um actually a deterministic input is turned into a probabilistic distribution or a probability probability distribution as an input is turned into another probability distribution good what are the composition operations for those of you who already followed for pizza you will already guess it it's parallel and sequential composition um parallel in the game 3D sense um is maybe more easily interpreted as simultaneous and what this looks like essentially is again repeating a bit of what we have seen you have two games G1 and G2 if they are in parallel you can compose them and then again you will have this basic shape of input X crossed X2 X2 in that case turned into a certain output and it's the same time expecting a certain result and sending some information back into the past okay sequential composition we have G first H following you can stack them on each other so that they look in the following way now what is important so far I haven't said anything about what these labels x y and actually correspond to um you can think about them as shapes and only games that actually have the right shape can be stacked on each other and this is important because you know if I say you know give me two games and I can compose them you might wonder that sounds weird how can this be possible in generality right I can easily come up with two games that are not so easy or maybe not at all composable the Restriction that you have is that these shapes the labels here actually have to match up only then can you stack games together forbidity already set from a categorical perspective and then of course also from the programming perspectives perspective these labels will be types so only if the types match up can you actually stack games together this is quite useful um and it's actually an important restriction because you know if let's say G is outputting a Boolean and H is expecting a numerical value or numerical type you can't match them up basically right what is even more important if you try to do that the engine in that case has to compiler will loudly complain that this is not feasible you can't do that what is more because you can't obviously design your own types you have also degrees of freedom of you know being very specific about what kind of input type is actually expected yeah so it's basically also part of the modeling effort that you can you have control over um how easy is it actually to um stack these things okay and full circle back to the prisoner dilemma again I already alluded to it just very briefly what is this actually representing um two compositions first parallel or simultaneous between P1 and P2 and then sequential um the U and again if you go back to the parallel composition you can basically think I'm first composing the two players in parallel into again this shape and then I'm composing that one sequentially with the utility function of the payoff function foreign questions so far yeah can you explain why the utility function is applied sequentially um yes in a sense of the the utility function essentially is just a computation right so it's waiting there for you and it's waiting for two actions one will player one and remember player two so it has to wait until these action these actions relax in that sense it's sequential in the implementation that I showed you will decide this directly as variable output of P1 being fed into the U okay other questions foreign implementation first a bit of an overview so what is actually what does the implementation actually look like it's a domain specific language embedded in Haskell you might wonder why Haskell um one of the reasons is that infra Pizza already said this as well as well the Optics and lenses are something that exist and you can build implementation basically on pre-existing structures in Haskell which is nice because um your theory has a direct correspondence to the elements that you use for the implementation in other words it makes it also easier to control that your implementation actually is correct okay another thing which is quite useful the typing system of Haskell is um actually um can be well sometimes your enemy but sometimes also your friend if you have larger components larger operations and you wonder what inputs if you want to query games do I actually have to supply the type system is quite useful because it can it infers the types and they can tell you your strategy that you have to supply has the following type right it has is a tuple of double pool or maybe something much more complicated this sounds at the beginning kind of bit you know why are you in it yet why would you need that but the more complex your scenarios are the more useful these properties and these this functionality actually is okay this is under active development it's under the active development from two sides from the programming perspective of things we you know we feel like features that we want and we want to implement but also the theory is continuously developed and this is something I will come back to um at the end if I have time okay we are using it for a couple of things um staking protocols an example a simple example you will see today token design and there are also applications outside of crypto good the first thing we want to focus on how does the engine actually work in the sense of how do we represent games how does this work all right so on the left you can see again the game with the inputs and outputs on the right hand right hand side you basically see the syntactic expression um which is basically this square bracket open game and then what follows until the the last square bracket that internally is basically the DSL and telling here is a game coming with a certain shape okay um there is what is called internals of G between the dashed lines I will say something about this in a minute first what you should see is there are four Fields inputs feedback output returns and they exactly correspond to the wires so you can see this as basically a way of expressing a two-dimensional element kind of language into um the the language of or the the programming syntax in within Haskell so the inputs are just the outside system another way to think about this box essentially is each open game is almost like an interface right you have something internally happen but to the outside world is somehow it is um connected or maybe not connected through its interface that it offers what happens internally internally is where the place of credit information is generated so insights of these dashed lines there are what we call line blocks these are five lines basically there could be many of them um they roughly correspond again or mirror the outside wires so if inputs feedback output returns and then there is an additional field which is the operation field that is essentially where information is created now the first thing to observe is in a simplest game if I'm just talking about one single player making a decision the input X could be exactly linked to the outside wire X that I showed you before and it's the wire going out or actually coming in similarly the output y um is we will be the result of the information that is created and will be directly pushed outside of the box however this not this is not necessarily the case in the sense of there could be more line blocks there could be more complicated things and some of these inputs and output fields and so on could be just totally consumed inside of that game without any exposure to the outside world okay the operation can be two things like here this is the dependent decision just means this is a decision operation so one player makes a decision or alternatively a computation these two building blocks you don't need more if you have that you can basically build the most complicated model you want okay here's the prisoner dilemma um again the diagram from before first you can see um if you look at the left hand side the outside Fields the outside interfaces here are empty this tells you two things first you don't always need to supply information sometimes the games don't have are not connected to the outside world or only partly connected and internally what you can see is um there are three line blocks the first one the second one and the first and the second basically are player one and player two again for both of them they don't observe anything from the past there is no input they output something which is the decision player one and decision Player Two And they also need something from the environment back this is the payoff player one pair of player two which are only defined at the third line block which is the payoffs PD this is the utility function and here coming back to connecting to your question before the form this function is expecting basically an input from above which tells you this is a sequential a sequential composition right keep in mind the diagrammatic language is two-dimensional hassle is not okay now the last element the pair of SPD is also outputting the payoffs and these payouts are then connected back to the the players and you can see already um you know certain elements of Haskell also help because the order of where these things are actually don't matter and it helps in the evaluation later yeah okay questions so far is the center roughly clear at least area so so yeah you have a question I wanted to ask about oh thank you I wanted to ask you about the inputs and feedback before and after the uh internal definitions like like are those the inputs going into P1 you mean outside of sorry on this slide yeah yes so the first inputs and feedback the ones that have a blank um this okay I should have feel precise thanks for the pointer so um what is actually the inputs would correspond to an ingoing wire into the overall game um I could think about the overall game as a box itself right so this this is just one box with possible in-going in-going and outgoing wires what it essentially represents is an empty not an empty box but in a box which is not connected at all to the outside world right okay I'm cutting just away four of these wires and um why is this relevant actually if you think about a prisoner dilemma a One-Shot game it has no past and it has also no future right it's one shot by definition there is no need to send information back or send information into the future and topologically I can kind of represent these features in a sense that there are wires or they are not wires it's also useful in the sense that you know if you model more complex games you can see that only when there is a connection through a wire there is actually an effect happening so sometimes these diagrams can be extremely helpful in kind of understanding what actually dependencies for sure thank you okay other questions okay so in the last part I want to look at a staking model this is you know a simple model still in the sense that I can most mostly explain all the components that are needed in the in the scope of the workshop the motivation comes actually have said that part of the engine um we're kind of funded by the ethereum foundation and we were working with the robust incentive group that was one of the examples that they prompted us to work on um and that's basically what we did so this is this is a simplified version of that of that work I will focus on compositionality you can guess it already um specifically now what I want to show is how I'm basically not composing things but I first will actually decompose stuff I will look at the overall problem and I will put it in as small parts and bits as possible I want to also illustrate um what we sometimes refer to as a zooming in operation I said before all of the components are making game theoretic sense which means if I'm modeling something complicated I can when I want to obviously look at the overall complex thing and you know analyze this but sometimes I might not care about the overall thing but I might just care let's say the the validator is a mistaken protocol what are they actually doing for a specific input what I can do then is if I have the model as a specific component I can just zoom in look at this specific thing analyze this specific thing without regard of the rest it's a bit like unit testing of specific units if you like which can be extremely useful given time there are obviously more details that I can I cannot explain all the details behind it but this is explicitly based on a blog post that we wrote which gives much more context also on the relation to you know where the idea for the model comes from and also all of the components are explained in detail okay so what's the basic setup here we have essentially um several periods possibly in each period there is one proposal and there are two validators um what are they doing the proposal basically observes a chain I will say in a minute or give you a picture of how this actually looks like and the proposal basically observes their chain and then decides um yeah I want to extend the chain at the chain and basically says okay there are several blocks on which block am I actually building again it's simplified and what are the validators doing the validators basically observe the Delta between what was the chain before and what was um basically the result after the proposal moved and then they can make it they have to make a decision on a voting decision on what do they think is the legitimate head of that chain and legitimate obviously in the sense if they are trying to be honest and are not malicious okay so this would be one example of how this looks like what is the underlying data type um it has we'll be using Haskell obviously in Haskell this will be what is called an algebraic graph it's just a simple graph here um each block has two information namely an ID and then votes in that specific example here this would be kind of the ideal world we started with I'm block one built on on that block two and so on have a linear chain the votes are in everything looks fine okay now if you take that as a specific input for one period let's say this system you know now is period four coming what will be the action of The Proposal The Proposal will basically um say yeah I want to build on that chain I'm choosing in that case I'm choosing um ID3 which is the legitimate hat according to the protocol that we are interested in at that moment he makes the decision that block gets appended but there are no no votes yet and then the validators come in they observe the ID which was proposed and then they can cast their vote and in this case here they will do everything is very nice yeah this is the this is a really nice World here okay um however sometimes things are not so easy um specifically if uh if you know everything would be deterministic then obviously all the problems would go away but you have networks issue in reality which means the staking Protocols are hard you have to think about certain problems one of the problems could be that um what if there is time lag between the proposal and the tester and what happens if this is an example here there was a proposal in period four and he's actually malicious he's just letting time pass by at some point proposal from The Next Period observes the chain thinks okay the other guy hasn't done anything I'm building on the chain and legitimately you know he's honest Builds on ID3 and that moment before the validators come in I said the first the four proposal from period four actually sneaks in and places in all his own his own um block on that check so it's basically and now the question is what happens this is one of the motivating examples okay do you have questions to the basic setup more details to follow foreign if not let me jump to um that's not really looking nice okay can you read this should I increase the fund is it okay okay um left hand side is basically the model right hand side will be just an interactive session that I will be using um let me start with something first um in order to implement the model you need a lot of background information right I need to actually think about what's the data type of the chain if there is a new block being proposed how do I actually edit um this for instance this function here at the chain um it's just observing a chain it's observing an ID which was proposed and it's you know creating a new chain so I lead them I need a lot of background stuff in order to make this model work which is just basically you know Haskell in that sense Haskell functions and computations another one would be for instance determine head I'm clearly in order for the protocol to work which has a certain goal um I need to be able to at each point say what are the hat or the heads if they are non-determinate and this is basically the second function what it's doing and there's a lot of other stuff that I'm not showing you um that comes in so you need for that in order to kind of use this you need first this um the structure in order to basically I'll say that this is the computational background to which I'm working now you might wonder okay for you know it wouldn't it be nice if this would be coming from the outside world and indeed for some problems you just need to create it but in other cases and this is something we'll be working with in the future or towards is can part of that basic infrastructure that we are interfacing with in the end and that is actually not that interesting from your modeling perspective it's just something you want to take as given can you somehow import it from the outside world or can you connect this tooling to the outside world okay for this purpose here I'm just recreating it um what it actually does is not so important just think about it for now what the behavior is um of air chain and so on and so some functionality I will explain on the Fly good these are all functions the first thing we want to do we want to create basic building blocks that we'll be relying on yeah I said before we'll be making hit here really really kind of um fine-grained in a sense we start at the real bottom of let's make add to chain actually an open gate put it into a computational framework so that we have a building block that we can move around if we want to similarly let's do that for determined head maybe we needed a different points um and then we kind of have this building clock available as an opening also note essentially for the whole system here the protocol logic is exclusively in determined head this is this function that you can see here if you change that all the rest stays intact and that's another way of if you make it you know if you try to approach the problem in that way you will save a lot of redoing um if you want to make changes to the protocol okay um let me jump here right okay so I showed you the the function before um let me actually let me put it next to each other so add to Adblock basically is doing nothing else it's just a computation um it observes the chain old and observes an ID and then it you know puts that into the inputs field inside and it's basically this is the forward function keyword remember we had the decision and basically computation this is one instance of the computation and then it does just the add chain to weight which is uh similar to what we have in the attitude chain by the way I can explain in a minute yeah but it's the same in principle it's the same idea you just take a component plug it in and lift it into an open gate it's just a computation similarly determine head of the chain um here as you can see this input here um is basically just a function from the right hand side I'm lifting it into an open game just a building block good these are very boring building blocks so let's move on what do I need I have proposer I have validators so what makes problems is to think about how does the validator actually look like okay let's model the validator um if you think about what a validator is doing I said before the action he does is he observes the new chain he observes the Delta which means he also has an access to the oil chain that's the input here um that's also the input to the line element here and then there is a decision and what you can see here in that expression is just basically that's telling internally the dependent decision operator what is the action space so where colors they actually can choose from um here this is basically just because we start the IDS of the of the blocks from one until the vertex count basically how many vertex are there and then this is basically the choice that the validator can do okay so we have basically a bit of computational background adds a block we have the determined head of chain we have the validator um now we have the proposer okay what is the proposal doing well the proposal observes the chain also internally he makes a decision um what decision does it do well you can choose basically on which block to build that is the outset this is the decision proposer which is coming out here and then you can see this is the first game in that in that context where we have another line block there's some kind of additional functionality this is just basically producing the new chain yeah this is taking two graphs as I said this is a specific library from Haskell which is algebraic you can just plug things together and you get the new the new chain and the output so the wiring of that game is basically chain old and chain U this is my interface of what the proposer is doing okay now the thing um I cheated you a bit um on two places maybe already spotted it if you look at for the validator as well as the proposer if you look at the return type here a return field I'm returning a constant zero which is kind of weird right because I said before isn't that where actually the Strategic context come from the environment telling me what to do blah blah blah blah and now it's just saying it's zero it doesn't look really strategic now this is an instance and I will come back to this this is an instance of where we actually had exactly what I just blah blah namely we had the inputs coming from the outside world and block them through but then realized that there is actually a very neat useful pattern here that we can abstract out and make it much easier to compose later on the payoffs in a different way yeah this is in some sense a bit of Haskell background that made it possible to kind of split this up even further that is what I meant initially when I said when you start modeling in this chain you can of course sometimes realize just programming patterns drastically abstract them out and replace them with something else why is this actually happening in a sense keep in mind for the protocol to work in Period T the decisions of proposal as well as validators are not rewarded they are only rewarded in the future that means their reward actually is conditioning on what is coming from the future and this is a way and I will show you in a minute how we actually can deal with this and the same is true for the validator as well as the proposal okay so here's an example um of what you can see here basically how this is done this is what is called out of update payoff validator um this is an auxiliary thing it's taking in a pool the ball is basically was the validation correct according to the protocol that is then determining the payoff um payoff can also be negative so if the pro and basically that protocol determines what this validator did actually in t in t plus one doesn't actually look good so we will punish it could be a negative value okay that value is feed forward and then there is this add payoffs construction this is just another open game and what internally is happening internally this is associating the payoff to the player which is parameterized by name so you can you can put this component in different places and it will automatically add the payoff at that point to your player do you have to do it in that form no I said before you could also kind of make it more with the wires and so on but this is a pattern which makes it extremely lightweight of recomposing the pairs and again this is useful for the following reason if you think about and for here I'm assuming the payoffs are evaluated just in one period advanced The Proposal do something the validators do something and then in the next period it gets evaluated what they actually do of course I could have a protocol which actually takes more more episodes what do I do then I can of course kind of take the wires put them through which is still okay but I can also just use it and say well the information Flows In Direction and I can compose this value add payoffs with the same name with the same identifier again at that point and I'm done it's not something we plan for but it's just something which emerged out of working on this and there are other examples like this okay these are the components that we need um now we want to take the next step first that would be awesome we have not only one validator but we have several of them what we do here we are grouping them together right so we say well there's a chain new chain old input and then there's some kind of information this is just information about past behavior from the other validators from the period before and then the thing is what this should observe is the following here and here validator this is the construct which is on the right hand side so we take that and block in the open game here okay and this is basically the second step of nesting we already have one for the proposal but for the validator basically we bottle it as an open game and then we plug it into the group and now you can also see um the the structure basically of that component validated script decision is made but you can also extend the number of players if you want you just basically add one line here add functionality but the overall interfacing of that group of decision making process is the same whether it's 100 or just two and there are also ways I should say this you don't always have to make this explicit if they are symmetric in some sense there's also convenience pattern such as you can say here 10 players of the same type put them there good so this is the validated group decision we also need to make the payment for the validators again it's not only one validator but two and again you could think about this as being extended to more players the thing to keep in mind um is again is um and I repeat myself but it's important this validation step is in time t for the behavior of T minus 1. yes you have a question okay maybe you ask a question again and everyone yeah he was asking uh I'd like to know what's operation the operation field basically the operation field okay the operation field is from one perspective basically what the where the the um strategic information is created if it's a function it will be just saying um let me give you the example here I'm filling the operation with basically two keywords namely either um forward function or dependent decision yeah what is the forward function doing it's just lifting a normal function a normal has to function into an open game which means in the simplest case it's just a deterministic function that determine head takes a chain and outputs ahead and then I'm interfacing it with the outside world if you're talking about a decision it's different look at the validator this is the keyword dependent decision the validator in this case the decision is the following the player observes this chain you chain hold that's his observation his information and then he makes a move he has to pick an element and this element in that case is an index tool which of the block elements do I believe to be the head or I'm choosing to be the head yeah okay then there'll be an operation between returns and feedback sorry second like so so this is doing the like from left to right yeah movement correct and what about the other direction okay that's a good point so first let's take one step back um if you think about the prisoner dilemma there was also the case where the agents did not send information back into the past yeah okay so that explains and the reasoning is simply here I don't need to send the information from these players back into the past and the reason I don't need to do that is um there is basically the protocol is moving forward and I don't need to send this information back it's like I'm creating a state and the state will summarize what is going on why I'm doing this in this form is the following the following reason I will end up with one episode that episode will be basically a basic game for Markov game and then I can stack these again on it on each other and repeat them if I want to now you are right if you wanted let's say you you're just explicitly wanted to model two episodes you could say um parts of these elements for instance what these guys expect here what the return is is actually coming from this returns field over here and I said before you can do that the reason I'm not doing it is here is exactly for if I want to Stack more more episodes with payoff still being created for players in let's say T minus four I can easier do that okay maybe it will become clearer when we come to the rest if not you know feel free to ask again other questions um could you tell me the time I have no idea 25 okay good okay well it is payments um again this looks like a bit more you know convenient stuff but this is a I mean the question we should ask if you modeled yourself is how can you how can you model it in a way that is actually really a building block um I said before one way of doing it is that the interfaces are relatively flexible so I'm just leading the fee which is an outside outside parameter um and then internally basically I just need the payoffs I need to chain new and the hat ID which was chosen and with that basically I have the full picture and that the protocol can evaluate once the behavior actually correct okay and you can see this is actually happening in a function that I didn't show you this is a tested correct they tested correct is basically just telling according to the logic of the of on the protocol the information I got yes made sense or no and it's outputting a pool it's just saying yes or no and it's doing that for player one and it's doing it for player two and these then corrected a tests that are basically input into this function pay or validator here on the right which you can also see here it's just taking boss validator correct or not and then it's basically updating good okay also what you should see and this is kind of coming a bit back to this discussion on why is there no information being sent back this is also um there's also no information sent in the future right if I would be doing this again without my way of composing this one player which just magically updates I would have to explicitly feedback that information uh so here you have uh potentially Boolean values that are that that um the outputs which is the correct attested one and two uh but then in a different block you had an input and output that was actually called boo so I'm a little confused whether uh that's this is supposed to be like a label or a type um okay this is basically the question of the scope of the of the um of the environment basically so the reason I call this rule here is I'm just telling about basically me for the reader I know this is a pool and I basically know what is happening why am I doing this here differently I'm doing the correct test that because I'm giving it information that I can easier pass it right if I would be just saying Bull in that specific context I might know what it is but I don't know where the bull is coming from right so it's it's like you might disagree with my um basically with my nomenclature or with the way I I label things but for me internally it was just like I understand what it actually means and that's the reason basically yeah the thing to keep in mind in a categorical framework because you have these wires going in basically bound variables come in um the outgoing wires are basically binding new variables to the output right so in case of the correct the test that I'm binding a value that is the outcome of that operation to that specific um character tested which means if I'm reusing it it's mounted okay other questions all right let's continue so we have to validate us payment and now we have everything assembled for a one period game one episode game foreign makes it on not completely what it basically tells you is this is one episode I'm now putting everything together there are certain parameterizations ignore them for now they're just details um of you know how do they call the players what is the reward and what is the fee and so on you should really think about it again as an as a diagram with in-going and outgoing wires so the in-going wires are basically chain old head of chain from the period -2 um validators map this is just basically summarizing the information of what the validators have done before and in principle you should think about this I keep enough information so that the protocol Works in a simple case here just one episode if there would be more episodes this would be it's just a record type basically it would contain more records okay um what we then have basically is the proposal moves first he observes the chain he outputs a new chain keep in mind this is this again so he's observing the train and then internally is also at the same time creating the new chain this is a computation taking place here okay proposal Moves new chain is created then the validators move as a group they observe the new chain they observe the old chain there's also access to the old information validator smash facilitators hashmap old and then they make a decision they create new this basically new map containing the updated information how did all of these validators actually behave and they also have the chain updated because when they cast their votes remember the shape of the of um the blocks are basically an ID and a voting value all right the thing to remember and I'm repeating myself I know that it's important to understand what is happening that the payments basically that happen are happening not for the decisions to that are made by the players in that episode but from the episode before or if I would be looking at them more longer Horizon from the episodes before good after this this is the main things the decisions are made by the proposal by the validators now I'm basically during bookkeeping um I'm determining the head of the chain I do the validators payment this is from the past I also check I didn't explain this but this is basically also bookkeeping I'll just look at what was the old proposal actually doing did he actually do something and then I'm getting that as an input to the proposal payment again for the period before now the complicating thing here is that I'm targeting a model which itself has a structure that if you just look at the output chain new updated head of chain and so on validators hashmap and you look above you can see there's a pattern basically the input types here chain old head of I mean you can't see that but I'm telling you the input type Jane old head of chain and that here are exactly the output types which means I now I can take the one episode and just say okay maybe I want to run it for three episodes I'm taking the same element and I'm just connecting them or I'm not doing that here if I want to run this as a Markov game and you know I want to approximate it like I'm running this for a long time I could just basically use a specific operator we developed that you can embed the stage game and then I'm repeating it yeah so you're starting you're initializing the game you create a one-stage output that is fed back into the next period And so you go on okay I'm not doing that here um I want to jump for the last part basically a bit and looking into how do you actually analyze these gigs I mentioned before on the slide what I want to do is I want to um illustrate a bit of what is the zooming actually what is the zooming how does the zooming work and you can already see because I'm focusing on the one episode I'm actually ignoring any kind of repetition clearly if you care about the overall protocol at some point you have to think about the Dynamics and also longer time period periods but for some questions it might be relevant to see is it actually working locally to give you an example suppose you're interested in honest Behavior by proposal as well as validator and I'm giving you you know I'm initially initializing this with specific inputs and I'm testing in that one period do the players actually have an incentive to work in that way and if not if you find out basically just by zooming in on that context it's not well the important you just can put everything else aside you don't have to think about the Dynamics that's enough similarly if you care about let's say vectors of attacks very often it's enough to focus on specific Parts in order to evaluate whether the attack is actually working or not foreign no yes maybe okay I said um in the context of like uh you know modeling like the domain of like a game and you know like a software team working with like a program like this you know if they have to Liaison with like the product team we should have an understanding of like the ux wouldn't it be easier for them if they want to model attack vectors to just model what the agents could do and then use a genetic algorithm for example might well be depends on the context right um the key thing is here you can have you have both basically The Best of Both Worlds you can just look at the one component but if that is not the only query you want to do but you also want to look at the more complicated stuff you have it as well right so nothing I mean in principle what you could do is actually you can take this component interface it to the outside world runs a learning algorithm on top and that's it and it would be exactly the same thing but it will be part of the overall consistent framework and that's an important thing if you care about the design for instance you want to make sure that everything is somehow consistent obviously right and then it's much easier to say I'm taking an element which is consistent with the rest and just interface it to the outside world and then simulate it clearly I mean you know this is also ethical I'm not sure how many people will be using it in that form right that's another question that is I think lurking in the yeah in the back so there are I mean this is at the moment actually to work with that you don't need that much Haskell because you need to understand the syntax of the engine and most of what I showed you is inside clearly you need some kind of knowledge of Haskell to work with the outside world but if that also goes away it's easy to think of this as basically working as you have a domain specific language and that's all you need to know when you have some operators on top then parts of the pain hopefully go away okay other questions all right if not the model slide one shall we start again maybe maybe afterwards okay um let's jump a bit into the um analysis um okay here's a bit more Haskell pain for you um and even more than average namely I'm using something which is um kind of what is called arrows uh if you know if you don't know what it is for now you just think about this as I'm defining a strategy for proposer as well as for the validator what is this basically doing is the following is creating a function and the function tells me I'm observing a chain and what you want me to do is I'm basically sending an ID remember the proposal observes the chain and decides on which which element to build what the rest is basically saying is this is an honest strategy it does the following determine head this is a functionality from before so I'm looking into the chain I'm looking at what is the what is the what is the head of the chain according to the protocol if it is play that game play that strategy if not if there are multiple candidates randomized this is happening here basically and this is done uniformly and the validator does exactly the same it's basically a super honest as well he's just looking at um what's the head if the hat is a single value play that if multiple values randomized among them good and then basically we kind of encapsulate everything in this so reminder this is basically [Music] um uh referring to the one episode game I'm plugging in some variables or some parameters which you can ignore for now and then what is the thing that I'm doing uh let me actually run it differently um so I'm analyzing foreign interactive session with the high school compiler I'm querying that thing and what I'm getting out basically is simplistic information namely um the output just tells me everything is is fine um you don't have to worry go home or go to the pub everything is working now this is a specific thing what it actually tells you and in fact this is the protocol is inspired by you know by one of the biggest um by ethereum basically you can see that the specific assumption is working no incent no agent has an incentive to deviate okay nice and nice and clean so far but now we want to do the following now we want to come back to this picture here I said before that let's suppose in the past period there's a guy who's actually not so nice and he's deciding not to propose he's waiting at that moment at some point after some time threshold the next proposal which is um the lower one here basically observes the chain steps in he wants to be nice he's honest proposes a new a new head um and at that moment before your testers can actually be active the old proposal steps in and just basically proposes his own his own head of the chain okay there are various ways in doing this I could just model explicitly the attack game um and it is actually merits to do that but here's an alternative way you can do it and this is I'm referring to the zooming in that I want to illustrate I've created another version here which is doing this one episode attack which is doing a simple trick namely I'm introducing an additional variable because I'm just focused on this one period I can do that it's easy I just add which is the chain manipulated um all the rest is the same the proposer observes the old change so he's basically still operating under the information from the past and then what happens is this line block is added I'm merging the two proposed heads into one chain so then I have really a fork and then what is happening the validators are observing the forked version so they have to deal with the problem basically now is this the only way to do it no you have multiple ways of doing it but this is you know this is part of the what the model has to decide how can this be done in an easy and accessible way another way to another way to do this and on one branch we actually do this is explicitly keeping time of the um keeping track of time and basically look at the timing game right so that time passes and then the proposal from the first period can until a certain point act the problem is that until a certain threshold the all the other players don't know whether the other guy moved or just they haven't received the signal yet but this is much more involved here I'm just cutting into this thing and I'm just focusing on that one aspect that I care about namely what do the validators actually do okay let's jump to this um attack okay um strategy proposal is the same then we have what I call the strategy validator random it's also the same from before I add two new strategies for validators one is strategy validator four and Vol validator five this is something very um very simple namely in case of a tie when there are multiple things I'm just taking here by hand I'm just taking the fourth element all right and you know for that specific example I'm just specializing it for that specific thing because it's enough but you could also easily extend it to a more general grid in other words when there are multiple candidates I'm just deterministically choosing one of the elements right and I'm doing the same for five but just on the other on the other element okay now I have several scenarios um I have scenario four and five which is just the same proposal strategy as before honest in the manipulator chain and then the validators are just deterministically both um voting for id4 in case of a type or alternatively five and lastly the random is basically I'm just taking the element so the honest behavior from before namely if there is a tie I'm just randomizing which obviously is also debatable whether this is a good idea but for illustration purposes that's enough okay let me run through four you can see this is nice this is also not nice this isn't this is an equilibrium and five as well okay so far this looks like pretty useless because everything is in equilibrium but in fact what it tells you is that suddenly we have two equilibrium at the same time and both are kind of either we go with the honors proposal and the one who proposed before or we actually go with the five which tells you um this is not in the interest of the protocol this one of them should not be in equilibrium and you'll see even more if I'm sticking to the actual Behavior of introducing the possibility of random basically just honestly saying I don't know when I'm randomizing you can you get different information um and this is the alternative namely the system recognizes one of the agents has a deviation the formatting is horrible but um basically focus on the first part the player with the name a21 has a deviating property it's optimal payoff is two current payoff is one what's the optimal action you need to see he just he should choose his move one why is this the case you can easily imagine because basically these players tried to coordinate and if they are diverging the protocol will punish them so they actually are better off voting for both coordinating on the wrong or on the manipulated um head of the chain instead of sticking to their honor strategy so at that moment you see Things Fall Apart with that variety of where it's relatively simple model and again this kind of it's a simple illustration here but that kind of structure was actually a motivation from a unrealistic attack good let me close with one more thing and this is then more or less the end with kind of some remarks this is the interactive version I said before you can also think about this as being part of a system so you can um um basically also run the testing in parallel or as an alternative so if you do this basically what will happen is you have some kind of specification test this includes the equilibrium but it can also be the parts you know it's the staking protocol working in the right way and then hesper is actually quite nice on that end because it can create a lot of very well structured arbitrary examples that you care about and then you will see at the end hopefully something green like this which generated in that case I think 100 different starting points for the chain evaluated them and you get some result yeah and you can see this is basically you can you can extend this in all kinds of versions it can be either on the behavioral level really thinking about equilibrium that would be the first test or if you go down really just the components foreign let me conclude um on two levels first a bit more concretely what is the end of the next steps for this engine and then circling back to where we actually started so this is connected the rest of category Theory or maybe more precisely applied category Theory so one of the things and some of actually formal verification people are here we are one project that we have is I mentioned this we want to have more pipeline from let's say starting from evm code into actual open games representation a lot of work has already been done that we can dock on and one project is basically to kind of extend this towards the open games framework so that if you can start with some um smart contracts you basically get an open games representation and then you can start querying them um either automatically or with your manual maybe you have some ideas of what you want to query in a manual in a manual way or you have some more bigger and analysts tools on top foreign you know the analytics we have so far we're extending them permanently we're also you know going into different applications and think about how they you know what specific analytics are relevant there um the outside of staking and I should mention this before which is an actually important thing the engine itself the end the version that you see here is basically built on Theory version outdated time -3 or so there have been three more iterations and one of the tasks in the next week the month will be basically an update of the engine the theory itself is also continuously developed okay lastly compositionality that was the starting point you've seen one instance of why compositionality might be useful in the context of open games what is interesting about this specific example is that when we started um out there is this basic question that probably raised in the initial sliding or in the initial beginning of his presentation namely how the systems compose in the gaming Theory are in the game City setting we have a relatively clear answer and what was interesting was in the beginning the implementation and the way we did it categorically is not at all doesn't resemble at all the way it looks right now because at the beginning we had a very different way what we realized actually is the connection to lenses in a categorical framework what we also realized um was actually realizing that the existing deterministic lenses are not enough and this is quite obvious because games need Randomness right you need to deal with um non-deterministic moves that actually LED also to Innovations on the on the side of the um Optics implementation and that itself repeats alluded to that is itself now kind of a you know in an area which is almost exploding in all kinds of directions and making connections and extending this framework this is one of the things which is quite nice actually about all of this work that it's tightly it's tying back into other fields within the categorical framework and examples of that are a control theory reinforcement learning active inference others to be developed and the abstraction here really enables you to see that these patterns are or that these different instances are actually related to Common patterns and lastly what is more you can also make cross cross combinations one of the interesting ones is actually thinking about games and learning mode right which is not new itself but if you see it in that form and you have this new pattern it's quite info I find it quite insightful and quite useful actually to see it in that form good thank you very much [Applause] questions yeah or to me or to repeat soon maybe you wanna so I'm wondering if we can talk about like uh real world attack example and how that would um come into such a system and in particular I guess on my mind is the mango attack from a couple days ago where it was essentially in Oracle exploits and the um it seems to me like an orca would be inherently outside of a system that you're modeling this way or is that is that an incorrect assumption um sorry let me go back go back here just if you think about no here if you think about this um X doesn't have to come from the in from the world it's from the game itself right it can be something from the outside perspective so I can't interface this that system with something which is drawn from an outside could be from a database or whatever it actually is where it's coming from yeah depending on how I deployed this it could be continuously updated and I'm running that basically on a permanent basis so this is this is clearly possible um you can also parameterize games um I'm not sure you maybe remember this part I just go there um if you look something like this one episode editor attack there are a couple of parameters which are actually exogenous they are not part of the internal structure I can make them endogenous querying them but I can also just say they're coming from the outside and I'm fixing them like the names layers of feedbacks or sorry fees and Rewards uh can you establish bounds on those parameters um it depends on what you mean with bounce first of all keep in mind that I mean they're structured it because they have to be typed right so if they have the wrong time they will not will not work um then I mean what exactly do you mean by by balance in the sense of values or so yeah I don't mean like a type bound I mean uh value bounce um well again I mean you have limitations in a sense if you're working with an escrow you clearly have boundaries for certain types that you can use um there are also of course the question of the computational complexity at some point right um I haven't talked about this because this is also part of active research um so far I'm using compositionality exclusively on the level of composing a representation there are results that show that you know Computing equilibrium is very hard um and we will not break these results but in the practice of actually Computing concrete concrete games um you might be able to leverage also the compositionality right because some component here might be computed but it might be independent of that and then you can compute or um some compute some component here might compute but it will only affect another component sure please another thing to keep in mind is that as Philip said um you can have that a game can you know just have a function as internals or it can have you know strategies so in the case of an oracle you can either treat it as a parameter that basically comes from the outside world or you can model it as a stupid function that has no agency whatsoever or you can model it as I don't know a protocol that has its own set of economic incentives to work in the right way I guess that would be the case of like the centralized oracles where you know people are incentivated to not to lie and whatever the cool thing about this is that then you can start from a scenario where the Oracle is honest the the very cool thing that practice teaches us is that usually when people design a protocol they have already an intuitive notion of what is the equilibrium where everyone is honest so you say okay you test that you have an equilibrium and now you can basically start bribing the Oracle so you can start basically you know adding incentives to the Oracle to lie and one thing that you can do very efficiently computationally is finding a bound that is basically the cost of breaking your equilibrium so say how much do I have to bribe the Oracle to break the equilibrium and then this is super useful because now you can find parameters and and you know since you are starting from equilibrium that you already knew you don't have to do equilibrium search it's just equilibrium checking you just like linearly increment this parameter and say okay this is how much we are protected and and then yeah that that would be a sort of bound between your model how expensive would be to it up basically oh hi um I have a few questions because I've been really listening so intently and I've written some things down so it's okay I mean the first one was um you know could you perhaps optimize the compiler by modeling like modeling with category Theory and with your tools oh sorry was that kind of hard to understand um could you perhaps Model A compiler and optimize a compiler using your tools and with category Theory okay um they're actually doing people doing this yeah I think at least at least trying but honestly this is definitely the outset of my expertise I can't say that but you you can probably check the research of these professors called dangika that is using category Theory to do compiler optimization uh so yeah that would be probably the closest thing okay and that's exactly where my knowledge of it and thanks um and then another question and I'm going to speed run it so nobody gets offended that we're taking a long time um could you model uh perhaps uh an iterated prisoner's dilemma with a variable number of agents and rounds yeah beautiful very cool and um will you ever release uh like a function annotated sort of preprocessor language that's maybe syntax agnostic or something that you could add into other code bases that aren't Haskell based in the future maybe very cool okay other questions thanks for coming [Applause] [Music] [Music] thank you [Music] [Music] [Music] thank you [Music] [Music] [Music] [Music] thank you [Music] thank you [Music] [Music] [Music] [Music] thank you [Music] thank you [Music] [Music] [Music] foreign [Music] [Music] [Music] [Music] thank you [Music] foreign thank you foreign foreign [Music] [Music] foreign [Music] foreign [Music] [Music] thank you [Music] cool foreign we can we can wait like two or three more minutes sure sure we can like very casually get started cool welcome everyone um I think this is one of the first ever workshops at Defcon um featuring a really new exciting space that has evolved over the past uh really only over the past year um called DSi and DSi is short for decent flash size and so the goal today is really um the title of the talk is my contracts in Petri dishes essentially merging these two Fields together uh and then with a goal to who everyone is here today to kind of look at beginning to create a shared technical infrastructure roadmap for what is actually required to make DC a success uh of course we saw some people coming in uh maybe a few words about myself um hi everyone my name is Paul cohas um I'm the CEO and co-founder of a company and ecosystem protocol called molecule um and I had the amazing opportunity last year to work with a great group of people to launch one of the first dci-centric research organizations called vidad um maybe maybe just start with that like maybe a show of hands who's heard of vidad okay so almost pretty much everyone uh it was a little bit hard for me to gauge the audience of this um of the talk today uh just because you there's obviously a lot of um what developers at Defcon it's a it's a developer-centric uh conference uh and this whole concept of of design is still pretty massive um whoop okay back cool maybe I can share a few words just about myself um I actually don't have a background in science but rather in economics traditionally um however science and specifically like biotech has been a huge personal hobby of mine since my teenagers I spent a lot of time in in online biohacking communities as a teenager um and some of you may be familiar with these there's all of these different subreddits focused on nootropics for example or biohacking and so as a teenager I spent kind of time in in these online communities that were for example um diabetics and that we're looking at alternative ways of um accessing insulin as many of you probably know incident prices in the United States have skyrocketed over the past over the past decade and so these communities were looking at ways of producing their own insulin kind of in in a garage which sounds super risky but actually often people are um our current Healthcare System really like underserves certain patient population similar cases in for example in different HIV communities that we're kind of collaborating online to develop their own open source Gene therapies uh or in other cases you have um communities of psychedelic researchers and enthusiasts that are kind of exploring hundreds of different novel psychedelic compounds so what happened in these communities someone would say hey here's an interesting chemical structure I think it could do this doesn't this in the human body has someone tested this and then something else would say yeah I tried it it did this and this and this and then essentially people um some of you might know this as trip reports uh it's essentially a form of like very anecdotal data collection um but I found this form of like open source drug development really really fascinating and at the same time then I began looking at like the larger macroeconomic landscape of farmer and because I started asking myself well why are these people online in the first place actually in many cases engaging in very dangerous experimental behavior on with their own bodies um and it's often out of sheer necessity because um either through lack of access or because um because certain medications and Therapeutics are fundamentally overpriced um and then I went on and studied studied economics and during my time studying economics I got an interest in trading biotech stocks and so biotech stock typically trades um around kind of the success of one of the core assets that is being developed doing okay one of the core assets that are being developed and so if positive data emerges about one of these assets typically the price goes up and if negative data emerges the price goes down um but with um yeah okay we might have to plug it in then but sure it's fine um and so within biotech companies this data is extremely well guarded it's typically only released like every two or three months typically only released every two or three months and when the data is released positive or negative the um the stock typically does in a 5x or it does money eight minus 80 in a day which is actually really inefficient if we think about um if we think about how markets work it's like this fundamental information asymmetry but furthermore most biote companies actually only have an incentive to share positive data so a biotech company could be generating 100 studies on a specific compound and two of them are positive uh and let's say eight of them were inconclusive and 90 90 of them were negative they would only show the two that are positive um because you typically wouldn't want that what to other people to know that what you're developing actually isn't working but in the context of science this is extremely inefficient so in science today there's there's this problem called the reproducibility crisis that is actually quite hard to reproduce other people's um other people's data sets that have generated uh so just keep going okay okay um and so as I began looking into these companies it reminded me of my experience as a teenager in being in these much more open online shared communities where people just kind of live share data in real time and I thought to myself hey there's actually this there's something there on the one side we have a pharmaceutical system that's incredibly inefficient and on the other side we have kind of these online open source communities of patients researchers Gathering um that could potentially be much more efficient and a lot of this reminded me of the way that open source software is done which is I think a really big Topic in in the crypto space and any ethereum space um and so in open source software you have to remember that really up until the 80s or 90s um open source was not a thing and actually famously Microsoft called open source software a cancer many many years actually actively tried to sue the Linux Foundation um and Pharma today on like biotech and actually much of science still works like open source in the 80s and 90s you have to imagine like Pharma companies like like giant ibms that are trying to develop everything closed source and effectively buying a drug from a from a pharmacy that is kind of licensed through a very very long complex closer process it's similar to like in the 90s buying a Windows CD and then going home and providing in your CD key I don't know how many of you remember doing that but and today that would be Unthinkable right be Unthinkable to still go into a physical Store buy a CD that is protected and then and then enter that CD key but that's essentially where much of the scientific system is still in today foreign still not look at that um and so as I began getting more and more into this um I kind of realized that there's a fundamental opportunity here to create a much more open and shared system through the use of web3 Technologies because the fundamental difference often in science and in software is that science is is in need space it exists in the real world and so you can't just as easily as easily replicate it as you can in other Industries uh sorry the presentation is not online that's in here are we okay no this is not working anyway Okay cool so what do we what are we here to do today um oh God foreign day three of a conference like technical technical difficulties are built in um so here today we will we're going to look at what are the problems definition and goals of the DSi community in space as a whole uh we're going to look a little bit about what we've accomplished so far specifically by going into one specific um one specific use case we want to look at where the whole Space is going and the different Lego blocks that are emerging and then essentially quickly move into Workshop sessions and different breakout groups to explore specific building blocks that have emerged in the in the D side space so DSi has actually only existed for around one year it's a very very new phenomenon and the goal for this Workshop today is also to essentially help Define a future roadmap of where the space is going and and how we can build Technical Solutions to essentially enable the next generation of design developers um to build permissionless open systems that that can really serve future Generations um I asked briefly before who knows about video dial but it would be really interesting actually to know who maybe in the audience actually has a scientific background okay it's actually much more people than expected can I maybe ask you what your what your background is social scientist okay cool and there was a hand up over there Dentistry cool anyone else yeah medicine okay perfect and there's listening yeah can you see that again oh pre-clinical research okay that's that's how that's our job also doctor used to be a doctor now a d side Dev Kevin anatomy and cell biology cool awesome what a great crowd um it's just gonna keep haunting me uh so even though the spaces only existed for a year um there's actually we've seen almost a Cambrian explosion of Desai projects uh and there's a lot of tinkering and like ongoing development um big shout out to a team called ultra rare bio if you want to follow them for like updates around the DSi space um this overview was actually created in I think in May so I think by now already there's a whole range of new projects downs and systems that have emerged that are actually not not on here um but just to see how quickly the space is moving and as any kind of new industry emerges one of the most important things is to avoid redundancy and if you maybe some of you remember how the whole defy space and D5 Community came into being it's really through building open interoperable Lego blocks that we can all build on together and so the biggest thing that you actually want to avoid in the early development of a of a space like this is yeah redundancy and you want to enable permissionless interoperability permissionless for example means not introducing friction in the use of services permission is means building in an open source way permissionless means um creating events like this for communities to come together and share rather than building in in silos because what now that we like in building out the design space we should really ensure that we're not kind of making the same mistakes as the the industries and people that came before us um and it's tempting to do so and it's tempting to do so because actually creating friction between systems is the way that most Industries actually capture value today it's about introducing them to learn um and so I represent an organization called molecule and this is also something that's really important to us like how can we enable open permission assistance how can we enable other people to to build together rather than um rather than introducing frictions and systems um yes cool so we have a big opportunity here today to define the roadmap for future Builders um and create an open collaborative technical infrastructure in the same way that that ethereum enabled an open collaborative infrastructure and so DSi will be most successful in my view if really enabled as these interoperable permissionless Lego blocks that we can all put together and and build on so now the question for today's Workshop is what Lego blocks do we need for which types of design application pretty simple um and if we manage to build those Lego blocks in the right way then I already think in two years we won't in two years we won't have we won't have 80 organizations but we'll probably have like two thousand this is essentially what what would happen in in the web 3 space when D5 came around in probably in 2018-19 I remember there being like maybe two three four five D5 applications they were extremely early um but if some of you for example remember maker down uh would then launch or not remember but no maker dial who launched cdps and die so die essentially was a building block that enabled the the emergence of a huge amount of default applications um and that's that's one way to think so science today is full of problems funding in science is incredibly difficult it's highly competitive it's very asymmetrically distributed often only goes to the best universities it goes to um scientists that have a lot of academic pedigree it's very political to get funded um and there's a really interesting Insight that actually most scientists today would change their topics or their field if if funding was not a concern so almost like scientists that they have to be extremely opportunistic they can't often actually work on what they want to work on they can't actually work on their feces they often have to just chase the money um so one of the first researchers that we worked with that molecule and also one of the the first researchers to get funded through vidad gave us a famous quote which was that he spent 80 of his time fundraising and 20 of the time doing the research and so fundraising in this context actually means getting grants um from different different institutions then the second thing is replication um I gave this example earlier in with biotech companies but much of science today is not reproducible uh so someone will will say hey here's a study I got the following outputs and then you'll try to run the same experiments and not get the same answers so how do we get there um the the further thing is competition so science today has become hyper competitive and that really creates perverse incentives um often you have uh you have competition for the same grants and then there's an issue with um essentially like scooping each other's work so it's also we don't have a system yet today where there's a lot of scientific Integrity actually between different scientists and then a last problem is that science today is still really inaccessible um much of important scientific literature lives really behind paywalls um it's not it's not open source um and science is often to many people still not very accessible if we think that actually before any before the whole nft art craze I never felt that art was very accessible to me it's like quite a complex actually process to go into a gallery to figure out what you like to like it's art wasn't very accessible for nfts but so I think Webster actually has the potential to make signs much more accessible to the to the broader population for example if you have a specific disease and you're really interested in maybe funding Therapeutics and then area or actually getting much deeper involved in it it's not it's not that easy for you today foreign and a lot of these problems that we actually face uh in the scientific Community are the same problems that we have in other Industries today they stem from centralizing authorities um so funding for example is largely distributed through governments uh or it's largely distributed through very powerful large private corporations um and decentralizing authorities essentially affect each part of the scientific value flow another example is the publishing houses that essentially control much of how what is actually published so if a publisher doesn't want to doesn't want to publish your research it may just mean that it actually never never gets disseminated to a much broader audience uh and so this is what has to what we've well we have to start changing move away from decentralizing authorities that actually govern access to science and govern Truth uh and move into a much more open scientific system so the question is and maybe one one addition here um how many of you are familiar with the open science movement does anyone want to give a definition of open science yeah lower barriers um I remember talking to the Center for open science who was working on a replication challenge um and basically trying to find a lot of I guess you would say web 2 was of addressing these problems and why do you think open science today do you think it has succeeded um I it doesn't seem like it's gone as fast this year to help go and I think that they don't really have that much better yeah yeah so funding huge problem and funding is often based on incentives what are the incentives for open science today good wealth yeah let's build a better Planet like Yay unfortunately like like Goodwill doesn't pay and unfortunately we live in a very capitalistic and profit-oriented system it's actually the most interesting application of web 3 I think today has really been creating incentive machines uh incentive machines that fundamentally alter people's behavior and so I think a fundamental thesis for us it was that the reason open science has not succeeded is because um because there's no incentive on it um and for taking this example that we had earlier with a biotech company that actually only has incentives to publish positive data but not the negative if we now had open public markets as we do in the crypto space for example if I you can make an analogy that if I find a bug in a crypto Network that's like open source research so actually crypto networks are relatively open source so if I discover a bug data is actually now valuable negative information so that could be like this crypto network is flawed and now I have two options I can I could hack it and stand to benefit from that and through that actually I'm revealing that this code is fundamentally flawed which is actually valuable to society it's like this was actually flawed um or I could I could also just ping the team and tell them hey guys your code is buggy you should fix this ASAP now imagine if we had the same thing for medicine if if there was an incentive to now create both positive and negative data about an asset I could be like hey there's a drug here that's in development um there's a lot of kind of there's a lot of hype around it but actually I as a scientist have a thesis that this drug might actually be toxic in humans in this in this use case and now I have an incentive to release that data or actually to create it and so all of these incentives are actually for open science are missing today and that's what we're going to build together [Laughter] um so what if science is decentralized maybe first let's ask the question of why is decentralization so important in decentralized system users can participate in a trustless system so you don't need to trust a middleman I don't need to trust a publishing house for example I can trust other participants in the system it lowers the risk of systemic failures um I don't know if you have some of you recently heard about the the big Alzheimer's trial or Benji can you maybe quickly oh anyone from the audience yeah I mean there's been this whole issue around like the amyloids yeah Alzheimer's and there's been a lot of um I think career academics who have built their reputation and their Laboratories and their funding around Alzheimer's and the particular pieces and I think they managed to through political force while being through the power of the Alzheimer's Alzheimer's institution and AMOLED data relationships through a drug Community approval process that stuff before yeah and it got extremely far just based on a fundamentally flawed hypothesis and that fundamentally pipe flood hypothesis was promoted by centralizing authorities um yeah and so actually many drugs I think not just wondering many drugs were actually started being developed just based on that thesis yeah um another one is just like avoiding censorship resistance avoiding censorship resistance Fosters in much more open culture and the last point is really enabling enabling global global collaboration so what is the why what and how of design so why are we doing this we're doing this to build an open science movement and to make science more collaborative and make it accessible and open to everyone like if you're a promising scientist in Nairobi you should have the same opportunities and chances as a promising scientist at Harvard today that is not the case in the same way that if you are Developer on ethereum I don't really care if you're in Nairobi or in Cape Town or in in Boston does make a difference the same thing should apply for science what are we doing we're building a Global open alternative to the current scientific system that anyone can participate in so equal access to anyone equal opportunity if you have a promising um actually Vincent I love that that example that you typically give around um around getting funded by a Dao as a young researcher you could be in a 16 year old whiz kid sitting somewhere having a great idea looking for funding in the current scientific system you'd never get funding there's zero credibility zero trust to actually receive funding from a reputable institution but with these dials that are emerging like age doesn't really matter anymore what matters are your ideas your integrity and the data that you can produce and how are we doing this so we have three fundamentally as a technology that enables scientists to raise funding to run experiments to share data and distribute their insights much more openly so what design verticals have emerged because the scientific field is extremely broad um so the area that this has currently targeting and attempting to disrupt one is funding of data IP and impact which is a huge field so what we essentially trying to enable is Foster and more democratic funding mechanisms that enable communities to form and govern impact or novel forms by P another big vertical is publishing so having transparent Open Access publishing with aligned incentives for all participants having incentivized peer review Systems for example the third one is Dows and research on governance over these research assets so dials present an entirely new way of organizing researcher or patient involvement and for example clinical trials this has never been possible before if you're a patient today you you have no absolutely no choice What lands what like what comes onto the market you have no choice of the price it might be in life-saving medicine that you need every day to survive you have no influence on the price on access whether it is actually the web indication um yeah and neither do researchers so we have this very long drug development process but we've removed the core stakeholders from that process and another one is identity and reputation systems for academic credentialing so how do we actually trust scientists in these different systems um maybe I want to ask into the audience so these are kind of design verticals that we've seen emerge across the field do you feel that anything is actually missing there yeah how would you just uh like in what in what use case foreign yeah really good point yep um yeah so what we're going to do in the like what yes addressing like the replication or reproducibility of data um that's actually a good point well in publishing actually but we should add it that's actually let's um let's note that as a point for the workshop later it would actually be awesome to like not just consider these errors but really map out realistically what all the different verticals are um I want to go a little bit into just one of the verticals which we're working on specifically but we also don't have to spend too much time on it um there's a lot of other talks that I've given in the past but I can go into this um but of all of these areas where we currently seeing the most traction is funding an IP um uh because it's like it's relatively simple today I think to facilitate um funding use cases through web3 technology I think it's still much harder for example to to facilitate Identity or reputation systems 303. foreign ticals in in funding in IP so we have retroactive public goods funding um some of you may have participated or even benefited from the recent DSi Bitcoin route um so that was a great um a great example of that the other one is quadratic funding having a fair more democratic way to balance actually allocate funding to projects um a third one is having Dows and tokenized incentive structures such as we did not and the fourth one um are IP nfts which are a new form of of unchain native IP and data ownership so actually for each of these verticals as well something that we could do later we could start defining all of the different sub areas in that vertical um I want to quickly maybe ask a question into the audience uh so do you want me to go deep into one of these verticals now or should we actually leave it much more open go deep okay let's go deep my goal like yeah whatever yeah the only thing I want to avoid is that we prime it too much about this one use case because there's so many other use cases but what is interesting about looking at funding an IP and specifically what uh would we as molecules have developed which is the action of T is that it's already very applicable in this theoretic um but so if we look at one of the like the fundamental problem spaces of how does innovation and biotech research actually work today so you have Innovation emerging at the fringes of an organization and then in most organizations Innovation is driven through a funnel um and then essentially you curate ideas as they emerge in systems and eventually something goes into a market so you have idea generation you define the project and it moves through this funnel um and you can actually map the same process to the entire drug development pipeline so this process today can take like industry industry averages to take up to 10 years to actually develop a new drug and to drive it through all these Cycles but now one of the biggest problems with that is that like um cancer is a global phenomenon yet every company developing cancer Therapeutics is doing it in a silo by themselves and you could ask wait wouldn't it be much more efficient if this was done as an open and public funnel imagine instead of every company having this funnel by themselves and and like we're essentially investing so many resources on a global scale to try to achieve the same thing wouldn't it be much more efficient if we had a giant open funnel um and this is essentially what we could build with red free and you can imagine each of these little dots are now individual research projects or individual individual assets driving through this funnel um and why is it why is it that way and the reason actually behind that everyone is doing their own thing is because we have something that called the patent system that fundamentally uses IP um but patents are really Legacy legal physical assets um patterns are literally often still in most organizations boxes of papers which if you think we're in 2022 is absolutely mind-boggling it's somewhat ridiculous that we're using an extremely bureaucratic and outdated IP system um that makes IP very hard to enact it's often much too expensive to claim IP in the early stages it's really hard to get IP out of the university the patent finding system takes ages um and so what happened actually often that a lot of Ip were a lot of promising projects that are in here never see the light of day and it's not because of because they're actually not interesting projects it's actually because the entire Innovation System that we've built around them is is really inefficient uh and so there's something called the valley of death which typically happens here so actually most of the world's Innovation never even enters like enters further stages uh which is if we think about scientific progress is really it's really a shame it's like there's so much good um good signs that never sees the light of day and if we think about data and software data and software today is completely virtual but if you think Back 40 years ago companies literally had still had like entire floors with filing cabinets deploying hundreds of people to sort through those data sets um this is an example I really like using the screenshot was taken about a week ago this is the current state of the art of the US PTO patent search system that's literally how it looks in 2022. and uh the only other the only alternatives to this system are paying really expensive like legal software to essentially to essentially search and discover patents so if we if if I were someone who was like hey let me look for interesting cancer research that's been patented and I'm like trying to find something in here like this is this is what I'm supposed to use from the government of course there's better systems than this but they're typically proprietary I'd have to pay for them um yeah so this this is what we want to get away from yes yeah what what do you think I mean I think the first thing the first thing I would say is it's extremely static uh it's impossible for me to actually contact the um the researcher or The Institute that's working on it it's hard for me to see what's done or if anything has been successful around it um okay here's Google appreciation here is a very low resolution like high volume database that the U.S government is like interfaces that go over this but I think this is the problem about just like fundamental and transparency extract um hmm I think also like because like never like okay to understand how experiments will run more like I also I have no idea if someone's actively working on this uh I also yeah it's and actually if someone has patented it almost disincentivizes me to work on it because like fundamentally for example if uh if let's say I'm a researcher at a university and I look at a new interesting molecule that that I've kind of come across and I search whether it's been patented and I realize it's been patented like I don't have an incentive to Now work on it because I could literally get sued for for engaging in that in that in that research so IP monopolies really kill Innovation at large and they also lead to much higher drug prices um so what we have a system today that rather than the best science winning we really have Revenue drivers that dominate that dominate medicine so at molecule we've really spent almost the past few years asking ourselves what could a better system look like for this and trying to build towards an open market for iip so kind of trying to reimagine the system and making it much more transparent and one fundamental thesis that we have is that most of the world's potential scientific Talent remains untapped and so for example if we think through what happened in in the nft market the nft market for for artists and now for music fundamentally has changed how we interact with art and fundamentally has enabled a different Creator economy for artists uh and so what if we enable a creative economy for scientists um to really help helping the best Innovation across the world rise to the top um so we are building towards an open transparent Marketplace for research funding that is underpinned by a new a new design primitive and now the question is really how do we bring legal IP and data into web3 and one kind of D side Lego block that that we've started building on is essentially a new a concept called an ipnft so what is an iPhone ft ipnft is first it's a legal contract and a real world license that is tied to research or data so it's a legal contract that now takes IP out of an organization or out of University and attaches that to an nft the second is it has a storage layer so you have a decentralized permanent data storage with public and private data repos so almost now imagine this this nft is like simple simplest way of saying it is like has like a decentralized Google Drive attached to it where the owner can now provide read and write permissions to anyone that wants that it's transactable in the same way that an nft is transactable it's discoverable through public metadata around that nft so I can now publicly on change start searching through the metadata of these assets and then fundamentally and I think this is the most exciting part you the IP now becomes programmable and composable that means you have governance you have fractionalization um if you're interested in actually ipfg fractionalization um we have one of our someone from our legal team here we've developed a new framework that's called the friends framework um because fundamentally what you need to avoid is making any of these assets like Securities because then they don't become transactable in web 3 and they don't become Lego blocks at least for now um you can have programmatic royalties or pay for Success models we also have someone here from the crowdfunding cures um team which pay for Success models represent a really new fascinating way to essentially do repurposing of um of of drugs what does this kind of look like from a kind of from an online perspective so you have a real legal contract that's mapped onto a smart contract that then maps to metadata that is stored in our wave and then you have encrypted and private patent data that now fundamentally protects the IP and this latter part you can open up you can open source it or you can keep it private um one one really one big thing that Riri does it's actually really hard to do open science in a field like biotech because um we began we began working with an organization called The Open Source Pharma Foundation this is in uh in 2019 and essentially what they do is they create public GitHub repos for um open source drug development that they're doing so they were researching malaria open source mycertoma essentially different tropical diseases that it really underserved and so um what they realized though in doing that as soon as you publish for example the the structure of a new molecule in a gift of people you open source it and you say this could be used as a malaria drug it fundamentally forever becomes unpatentable and now they were working with the development in the Gates Foundation for example and then realized about doing that that the Gates Foundation essentially said we'll never be able to fund any of your malaria drugs even if they work because they become unpackentable and because the problem is if you don't have any paths around drugs you can't essentially get the asset through late stage clinical development no one is going to come and pay let's say the 100 million dollar plus that you need for legacy to a stage three clinical trial which is like which is a big shame it's just how the system works today it's today it's fundamentally impossible to do open source drug development um however I think as dials and communities for example get much larger you can actually move more in into impact driven development so maybe so to close the session ipnfts in our view are really a first composable web 3 Lego block so they can be transacted like nfts and applied for funding Dows can now build portfolios of research um of ipn FTS so we have this new phenomenon um a bio dials that have been emerging which are dials that are now focused on different therapeutic areas so since we design emerged we now have a dial focusing on Neuroscience um there's a dial focusing on psychedelic research there's a doubt focusing on women's reproductive Health there's a dow focusing on hair loss uh there's another doubt focusing on synthetic biology and all of these dials can now use the ipnft as a basic building block to build an on-chain portfolio of IP um nfts can also be fractionalized kind of and be inserted as design Lego blocks you could imagine an nft and an ipn ft being fractionalized and then those fractions going into different on-chain liquidity pools um they're fascinating new mechanisms where the the the fees that are now being generated through these liquidity pools can actually be used to fund the research as well so everything that has been built in D5 for the past two years three years can now also be cross-applied to design um for example also data access cannot be granted by multi-signature wallets um and we really only beginning to scratch the surface of what is possible here now one of our core goals and molecules for the next uh for the next two months three months it's actually fully open sourcing this first version of the ipfg protocol to enable anyone to start playing around with it and essentially just tinkering around with it because we don't actually know yet how many applications this this can be used for um so what are the basic design web 3 Lego blocks so I think we're looking at transaction layers we're looking at data storage layers we're looking at compute and execution layers um and then finally we have identity layers or reputation layers the ipnft for example combines what I would say is a transaction layer and a data storage layer but it doesn't actually touch any of the other layers um and so now we're slowly moving into the the workshop part I think Tyler just left uh so the goals for this Workshop today is essentially now to look at both what Lego blocks do we have and uh to look at how how are they matched with different design verticals so we have different Lego blocks that are merging mode three how do we map them into these D7 verticals before to to solve fundamental problems in in web 3. so the goal of this Workshop uh will be to really explore how we can how decentralized science can improve the process of funding doing and disseminating science through the use of decentralized systems so now we're going to look at each of these different elements uh and yeah since you start workshopping them Vincent yeah so the form of the workshop will be that we now have a breakout session for about 40 minutes where we can gather around these different topics uh we also have multiple members from leading organizations from these different areas uh in the room with us today um we can then do like breakout pitches where people from that have not formed through these different teams can essentially pitch their ideas and then we we can all discuss them together Vincent yeah so maybe um like basically we'll collect all the outputs from nodes kind of from each table um in a shared Google doc which also has some of the um like links and instructions so you can scan this link I think it's also under um yeah do it again [Music] foreign [Music] thank you yourself thank you thank you oh my God foreign foreign but thank you questions thank you thank you they're not published everybody thank you right here cool just everyone a quick reminder that we have about 20 it's about 20 past five now um so let's take maybe another nine minutes to actually start collating outputs and results and then in about nine minutes so this is half past we want to go into each team kind of pitching what they've come up with and if you haven't like had a breakthrough that's okay too maybe share all of the kind of the learnings that have come and then we can go into public discussion of the outputs thank you so much foreign thank you however conditions we don't uh on another game like that's all right um thank you [Music] right now oppose like how much um is like what are the sort of legal ties yeah congratulations thank you creation Department thank you foreign they're like here they have the ability um foreign extended by yourself in other ways foreign thank you for me um thank you um [Music] foreign response right now yeah cool time is slowly up I want to slowly start bringing all of you guys back oink oink [Laughter] what no why will it be called my attention I don't know I was just yeah did the pig didn't catch it okay cool hey everyone uh so I want to slowly start bringing us back because it would be awesome if each of your groups can now kind of present the specific vertical that you explored and some of the solutions uh some of the Lego blocks that maybe emerged around that um so maybe if someone from your team can come up or do you want to stay in your circle what do you prefer stay in the circle okay but you have to stand up while you're presenting um who wants and so maybe take two to three minutes to walk through the findings of your team and maybe the solutions that you discussed um and then it will be really awesome if someone from your team can actually capture it and if you haven't already just write it and put it into this document uh if it is already in the document I'm actually just going to scroll through and check if anyone can see I think I misplaced the mic somewhere or maybe the support people took it but it should be somewhere um and yeah so just transcribe kind of that main outputs that you're also going to present into this doc so that we can share it with the world and the community after this that would be really awesome okay um who wants to go first you have to stand up or I can so uh we were looking at a scientific reputation system and looking first at how our current like scientific reputation system functions so we first mapped the current system out into two verticals one would be formal credentials and other would be sort of informal reputation and formal credentials are things that are verifiable measurable and somewhat quantifiable these are things like academic affiliation degree impact factor H score pedigree citations for example and funding sources and then there's more sort of informal more let's say qualitative reputation things this is like social media and press collaborators and peers um who you know political affiliations hype your ability to influence others and we mapped out some pros and cons in each of these if you want to like look at these in detail you're you're more than welcome to they'll be in the dock but just as like a high level example without going into excruciating depth on each of these things like academic affiliation can demonstrate or attract quality they could signal trustworthiness they can be associated with specific areas of expertise they could act as sort of shelling points but on the other side they can create inequality they can for example Foster sort of like uh certain reinforcement patterns create like Legacy students there's a bunch of problems in sort of fostering sorry this the stock is moving in real timeism um reading it I'll just talk through it rather I think I can do it from memory um there's there's a bunch of things in the context of this current um let's say verifiable metrics that still need work so impact factor is something that um I think can be quite positive in terms of it could demonstrate readership and citations but it can also be heavily gamified and is used to largely um sort of reinforce um yeah certain popular ideas many noble laureates for example don't publish in high impact journals their ideas are initially rejected so we're basically trying to look at in the context of all of these different um verticals whether they be like verifiable credentials or sort of informal credentials what are the sort of things that we want to bring over into into DSi in the context of this um let's say new reputation system and so we did a little bit of work thinking about things like um credentials and these could be represented by things like Soul bound tokens for example so instead of just having academic affiliations we want to have things like industry affiliations Guild affiliations Dow affiliations what are the communities that you're associated with what are the values of those communities and how do we measure those um I think we also want to look at for people who are involved actively in funding how are they making an impact what Dallas and organizations are they a part of what areas have they done research in what areas have they may be impacted and this is also a hard thing to measure but I think using impact certificates and actually pull-ups in some cases you could begin to use some of those Technologies to measure um the impact that somebody's having we could also look at things like gits and like pull requests in the context of liking data becoming increasingly but like let's say if you're doing in silica work in the context of of biology um you can begin to look uh more in real time at how somebody is contributing data to a certain research area and began to measure an impact that way and there's also things like measuring Dow reputation so if I'm a contributor in a Dell you know am I somebody that people are delegating boats to am I somebody who's being rewarded by things like coordinate have I been elected as Stuart and then also looking at other factors like value captured value generated am I deploying funding have I have I received funding from certain people we could also look at like token Holdings we could look at how active I am as a governance contributor in a dial but in the end there's all of these sort of uh all of these I would say new interaction patterns that are happening by the internet that are actually producing a lot of really really rich data that is quite different from how PSI science works today and what we want to try to figure out and where we haven't gotten to actually in the context of this short session is really thinking about how those things are all weighted how they're measured and I think the most interesting question here we think about creating like a holistic reputation system that would be akin to something like impact factor um it's really challenging to do because I think the needs of scientific communities are are very different so for example I might be somebody that from a reputation perspective is a really good developer or is maybe just really good at data collation and data analysis how is my reputation weighed against somebody who is maybe also publishing and also funding research and so thinking about dynamically how these systems interact I think will be a really interesting technical challenge one of the things that we were thinking about was like if a Dao has a certain set of needs so for example feedadel might have a need for longevity researchers that have worked in X or Y fields and have of for example experience with certain assays in certain data techniques that is very different from another organization that is maybe just an investment focused Dao and wants to know if somebody has been particularly good at deploying funding or making good bets and so I'll cap it here so like the the thing that we're thinking about is like in the context of a how can we create Dynamic reputation systems where the organizations themselves are specifying what they're looking for whether it be a series of Soul bound tokens and DOW affiliations or specific credentials and how can we have a system that basically adapts based on the skill sets that that individuals have so sort of like everything we've talked about taking a dynamic approach to this reputation system that is not one-sided meaning that it's not just the impact factor of researcher but the needs of an organization juxtaposed against uh the specific skill set that someone has and I think this could be really interesting because going back to an earlier example that you made Paul if there's like a 16 year old somewhere in the world that ends up being an excellent scientific reviewer because they self taught themselves I don't know like biochemistry and you know on the internet no one knows your age but they're making they're making like comments on papers or whatever that are really valued by the community we want a way to to measure that that is like independent of academic affiliation for example or what if it was even just an AI bot or a dog on the internet no one knows you're a dog and in a blockchain network no one knows you're afraid on that note thank you so much for sharing that Tyler could your group also please upload uh your doc into the into the section and then maybe I'll just go uh sorry it's a bit buggy here cool we'll go into tableware traffic public goods next just because that's up right now okay awesome and we have about maybe we have about three minutes at the moment for each um for each topic I just want to make sure that everyone gets a chance to speak before they kick us out of here oh Sava yeah do you want to come up front cool here we go send science is a public good so the most important thing is to look at like how do we value impact that's the trickiest part um and then once we've got that essentially the market um we need to find retractive funding so in this particular case we're talking about we've got this thing called the longevity prize um the um Vincent's um sorting and we read it through get coin and sort of rate say 250 Grand and so we've got like a source of retroactive funding available um then the next question is kind of what do we want to uh what sort of impacts you know is going to be in something that can scale got a really great idea I raise money basically from from investors where before like you know because it's a public good essentially there's no way like under the traditional way there's no way like under the traditional IEP system that you can enforce a Monopoly price so um yeah I keep talking about generic drugs and things like that so that's something I'm interested in but which is yeah basically if you can get an off patent drug and repurpose it to treat a new disease like so ketamine to treat depression let's say you know you could actually create like billions of dollars and and social value with quite a like little bit of um investment there retractive funding so um yeah um so so yeah basically once once you've delivered the impact whatever that might be so for instance improved clinical outcomes versus usual care then you will get um the outcome payment under this um uh the from the retracted funding um and the market basically figures things out so if it's not enough funding like if 250k is not enough you can basically get um philanthropy to put in the rest so it's a little bit like Bitcoin where like you sort of have little donations creating signals or little Investments creating signals for a philanthropic funder to come in and and find the rest so yeah Lego blocks that you see that are really important to make this effect uh oh yeah yeah I think what one could add is basically that um every scientist could basically mint this impact certificate even if they have like other funding and then could sell it like one of our ideas was in a more like crowdfunding sense that you don't have to buy it for say a hundred thousand but you can put in 100 bucks or a thousand bucks and get like almost like a small share in this impact certificate which could be just like an um IBN ft which could then be basically put into like a million pieces for example and then it's almost like also like a pulp and kind of like um collectible because you show that you funded research so so it gives you not only potentially like the price but also almost like some status as we can science funder you're doing like impact so it's kind of like also a bit of philanthropy and it's almost like a collectible so you can like collect all the little research you found it um but it's also like a prediction Market because you can potentially sell it so like as it could hit the price it could also grow in value so it's almost like you're signaling what you think is the most likely to dot com so the Lego blocks are like iPhone FPS El c20s and kind of like deploying them just like on uniswap and then people getting great liquidity or short than uh just one more thing I like so for retroactive funders that's super important so maybe you could have an open like uh impact uh mid you know impact nft scientific impact nft to encourage people to become retractive funders uh okay we have data and process up next so so I think some of the things we talked about was like uh so the first thing we want to do is like how can we uh collect data for uh uh for scientific purposes and then one of the things we cover one of the problems that we need to solve is like how do we collect uh how do we get gather people not just for collecting surveys not just for conducting surveys but also like how do you gather people to uh participate in clinical trials and all that falls under like a a a a we need sort of like a database of sorts which can store metadata and allow people to like ask questions to this entire population and see narrow them down to specific uh segments and so that could be like a distributed database for example maybe and and then you have to apply like operations on that distributed database to find your target audience and so other things we talked about was like uh how do we in throughout the scientific process uh you also need to like I didn't before you even start research you need to identify what is a problem that actually needs to be solved and so uh in in order to identify a real issue that needs to be solved you have to make sure that uh it's the actual problem and and you need to uh not not you can't trust a majority of the population to know what is the natural problem because certain uh populations may have like uh like there may be like groups of people who are healthy and groups of people who aren't and and the healthy people may uh outvote the unhealthy people so then how do you address the problems with the unhealthy people like MiMi uh yeah like like uh because we do actually need to solve the problem for unhealthy people in a way uh yeah so what is the right thing to fund is the there's a problem in yourself also and then yeah more things on uh yeah so can you scroll down right scroll down okay oh oh my God so I think other things are like uh [Music] um yeah like so we talked about Cloud labs and how can like Cloud labs and like how can we conduct uh how can we have like databases of people of labs or like facilities that can uh help conduct research and then also like even currently web uh and then also another thing is like throughout the signing process you also need to make sure your experiments are conducted uh uh trust in a trusted manner so how can we have chains of trust that go that go from like from the ground maybe like from the individual level all the way to back to the researcher and then beyond the research actually yeah and uh I think one final thing we touched on is like how do you duplicate uh how do you duplicate experiments or studies conducted and that will usually involve like open source studies and being able to query these studies so we'll need solutions to like uh uh catalog and index uh studies already conducted in the past and yeah there's a lot of problems in I think in in summary there's a lot of problems throughout the scientific process that requires individual tools and race uh two very uh specific open tools that are globally accessible and in order to be able to re increase the efficiency of the way the scientific process is conducted yeah I think that's summary of what we would think thank you so much [Applause] okay any questions from anyone also maybe on the previous topic I would love to give more time for questions and discussion actually but we're also quite low on time and I want everyone to be able to present um okay then last but not least we have publishing what sorry okay thank you um so we're the publishing team um I guess for us it's it's really a question of building connective tissue or also device that we're also the penguin team because we have a penguin on our little thing here um but but the real real question we're trying to solve is that of like connective tissue and really linking everything together and the big question at the top is how do we amplify Collective thinking within the context of scientific discovery and how can we make that process easier um for people and this involves you know at the start we're just asking lots of questions um you know who are we designing this for are we designing this to replace from for Publishers or for researchers um and also is there an incentive for Publishers to participate so what we kind of realized during our discussion is that um basically what we're trying to do is replace public centralized and Equitable for the researchers that are involved um and another big problem that we talked about was actually actually um crypto history and and I think Brewster kale had a brilliant talk on this yesterday on the day before from the internet archive um how you can just pull Publications off of the record and you don't want you really want to avoid that and you want things to be accountable uh 50 100 years down the road so our our solution is really just to use the existing technologies that already are around like our weave and content addressing to build connective tissue um for linking between papers and Publications um and the big sort of money or like the Lego here would be for DSI would be some sort of publishing standard with the associated metadata that will link these papers together whether that is like referencing um whether that is like referring to people who built the system built wrote the paper and I think that's where it kind of plugs into the reputation system that the other team presents earlier um and also we discussed like how can we connect these papers to the IP that resulted from them and we were talking about how we could plug that in as well so you could imagine visiting like a Wikipedia site that pulls from an RV backend and has like really good user interface you could click and see what IPS are related to this how the reputation of these scientists who wrote this is and like also look at the references by 4 following the r weave links and because it's are we if it's permanent um you don't have to like worry about the data disappearing any point in time um the we also looked at some other systems here like Wikipedia is probably a great example for a linked um content system that has worked really well for for data um also stuff like DSi labs and bio rxiv um we're doing research in adjacent spaces um but but yeah that's about it thank you [Applause] thank you so much I really like how you can um essentially already started creating connections between the different um yeah the different topics um team in the back Benji that sounds like a bad excuse can you still talk about it um and we we have about six minutes six minutes left okay Mike okay I feel powerful now um so uh we talked about uh decentralized clinical trials um firstly why would you decentralize them how would web 3 work I think we came to a broad consensus that generally generally speaking the things you'd initially want to look at would be clinical trials or things that weren't particularly dangerous you can get over the counter um and it's okay to ask the general public to do um we talked about data issues in that whether data should be stored in people's phone encrypt input on the blockchain and the issues that can happen when you've locked data up on people's devices and they get sick or ill or unconscious um and generally decide that in a clinical trial they should probably always consent and those exceptions that matter too much we also talked about how you would decide which trials to run and why um I think broadly we agreed there should be some vague oversights from professional people in that so you don't do something too dangerous um and last we talked about went down a big rabbit hole on incentives um the potential of micropayments and the pitfalls of people just taking the step counter um and attaching it to a piece of string and putting it in front of a fan apparently that works quite well um yeah thank you so much thank you okay so on the legal side we worked on a practical case um and I presented a problem to Jesse so I work for society Institute we are sort of perfect a problem child for this eye we are a non-profit organization that is based in California that has existed for 40 years doing science really at the edge trying to accelerate science that's way too ambitious or too Niche for legacy institution generally to to feel comfortable to fund so you we work on neurotech biotech trying to push longevity Aid reversal brain computer interfaces building Dyson spheres because we also work on Space um AI crypto Etc um and so we have this organization it's a non-profit and we want to Dao if I eat um and so there were two main categories of problems that I presented to Jesse one of them was how do we not deal Paradise the existing organization and the second one was more focused on governance and how to create a data structure that is really aligned with the ethics of our organization and Jesse was very helpful thanks Lou so we only have two two sets of solutions to these two questions one is how do you make a dow from your non-profit that doesn't jeopardize the Dao in its existence and the answer is well we did defeated now a fair launch with with no pre-sale then that may Rob some people the wrong way who want to raise money privately from investors before launching the Dow but it's really the key to prevent an existential risk to your organization is to do a fair launch and what that means in practice is um having a team that's willing to bootstrap and and launch this organization and then get retroactively voted for their token-based compensation after the launch of the Dow number two is that there should be no direct claim on the treasury so you can't have a malach Dao style Rage Quit function that allows for the token holders to claim treasury assets there has to be some kind of break in that chain in order to prevent the token from having a secured interest in the treasury of the Dow in other words the token being a security and in that same vein no distribution of profits to token holders and so that leads to the question of like well well if you can't distribute profits to token holders token holders have no direct claim on the treasury then then what's the token for right how do you reward people for participating in this dial at all and and the answer is in part when we do a Vita Dao and the best example is to look at a university endowment a university endowment makes Investments right it makes money it it makes money for the University and then that money is distributed to University administrators to students through scholarships to making buildings to making the university a better place no Professor or student has a direct claim on profits that are made from the investments in the university endowment but the university grows and becomes a better place and becomes a higher salaries professors get paid more scholarships are handed out to larger degrees the more money that the endowment makes however again no Professor has any claim on profits that are made from the the university endowment and so I encourage you to think of your biotech Dao and the money that it's making and the treasury that it has like a university endowment and the structure of the Dow as a non-profit structured almost like a university and then later um with our IP nft 2.0 protocol and the fractionalization that comes with that into friends and fam tokens which we can talk about at dinner tonight um you you what what you do is you have a really interesting system whereby the token holders of your doubt don't just have the ability to vote in snapshot on governance proposals which is like you know step one of Doubt participation and that's about as far as many dials get unless they have this monologue style rage quid function what you have with IP nfts and their fractions is the ability to drive value to token holders and allow them to accumulate portions of the IP and portions of the treasury assets direct exposure to interesting projects that they want to co-govern and you know if they kyc into credit that they want to co-own yeah okay thank you just making a final announcement uh wait don't disconnect I put on top of the document so tonight in my in partnership with molecule foresight is foresight is the hosting a decide dinner at tiatro repeal and so we invite you all to join and continue this discussion I put the uh perfect thanks um otherwise the link is at the top of the document I put it just under the agenda on in the Google Doc you can directly click there and register and join you join us that's it pause thank you so much yeah a massive thank you for everyone um that participated here I think we had some really really cool exciting insights come out of this uh you all have the shared talk um what we'll try to do maybe from outside is like maybe collate this into like a blog post of sorts or just a maybe a Twitter thread um to share it with the community if you want to be tagged in it please feel free to put your Twitter handle into the doc um yeah and uh look forward to maybe seeing some of you at the dinner tonight and remember build uh build Lego blocks build railroads build roads that other people can use and that can cross integrate uh into the community because we still have such a big opportunity here to set those Railways for everyone to um yeah to interoperate which is what open signs and decide should all be about thank you so much [Applause] [Music] thank you [Music] [Music] [Music] [Music] [Music] thank you [Music] awesome [Music] [Music] foreign [Music] [Music] [Music] [Music] [Music] [Music] thank you [Music] thank you foreign [Music] thank you [Music] foreign [Music] [Applause] [Music] [Applause] foreign [Applause] [Music] [Music] [Applause] [Music] 