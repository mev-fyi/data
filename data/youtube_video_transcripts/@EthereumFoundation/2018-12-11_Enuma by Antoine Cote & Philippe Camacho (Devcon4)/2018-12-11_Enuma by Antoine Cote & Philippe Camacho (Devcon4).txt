I'm Antoine this is Philip we're from a new mud technology enema is a engineering company so basically everybody in the company is a developer we've been around since 2015 worked on different blockchain projects way back we started with Bitcoin multi-chain aetherium worked with different block chains so we got a grant from aetherium in May to work on sprites payment channels so I'll show you what we've done here and we've also been building kind of like after after we've done the work on sprites we started working on decentralized exchange and how we can make them more performant because if you've used the decks that are available out there today but a lot of them are really slow you have to wait a while for your transactions to be confirmed so we're trying to solve that problem also using state channels I would have done it live but I was having some problem with the Wi-Fi so I recorded the demo just about an hour ago here just to show you this is the the sprites demo so what what we have here is on the left side is a merchant website so imagine you're going to the convenience store and you want to to buy like I live in Hong Kong in Hong Kong we have this card that I can top up with money go to the merchants swipe it and buy buy things so so that's my merchants website oops I think it has no path so I can select some some items and we're using the die stable coin here because I don't want the price of my Pepsi coke to change day to day so I select some items so one-point-six die and then click on checkout so I get a QR code and then using the application this is on my iPhone I'll tap to login and unlock my my wallet so this is by the way we're mostly back in engineers sorry for the UX if if anybody here is talented in UX or we're hiring but this is mostly a dev demo to show that you can connect to the channel then my balance she will show up in the history of transactions then I'll click on make payment scan the QR code is very fast and confirm that that payment to the merchant and then it says payment successful the merchant should see the balance of 1.6 so by the way here there's like three parties involved so there's the end-user going to the to the shop there's a payment provider who's the middleman and then there's a merchant and where Sprite comes in is that we use the conditional payments so that I can pay the payment provider the payment provider can turn around and give the money to the merchant and then that payment is done you know once I reveal the preimage and then the merchant can at some point decide to withdraw which actually does a this is where the Unchained transaction comes in so typically the merchant would withdraw maybe you know just once a day or once every you know a few weeks all the other transactions are done that layer to this part was just to show the the blockchain transaction idea actually and I'll pass over to Philip to talk a bit about what we've done since with decentralized exchange Thank You Anton hi so as in two-dimension we are also working on secure decentralized exchange and we've been working this since a few months and our initial approach was to use these payment channel year two techniques and with the idea that all the user would be part of a network and create channel between each other and and then be able to exchange token right and after analyzing this and trying a lot we realize that there are many shortcomings to this approach for example if you use these payment channels in general you need to have collaterals in order to ensure that the payments go through then ok we need to build this network but how do we do this I mean it's not easy to build a network it's not only about code it's about incentive incentivizing users to join the network and so on and so on so we had more questions than answers and also there are like technical challenges like ok we have plenty of orders that are spread across this decentralized network how do we match these orders who is going to do to do that so after thinking a lot and banging our heads on the wall we we decide to step back and think again about the problem right the problem when we build an exchange that we we want to avoid to be the next empty goes so what does it mean it means that if we want to avoid that users should be always in control of their assets their token so having a decentralized network is a way to achieve this but maybe there are other solutions and that's why we end up with this concept of trustless exchange more than decentralized and the nice thing is that we get kind of best of both worlds we have first something that would be more like a based I didn't put centralized because it's like what you want to avoid but it's the idea that we have a coordinator that would take all the orders match them and update the balance correctly but at the same time it would be trustless and this one and if you have these both things we can be both efficient and secure so at a very high level how it work well we'll have this hub that will take the orders and merge them and from time to time it would synchronize blockchain to ensure that all the balances have been dated correctly and users will use the blockchain only to deposit and withdraw and all the rest will be made with through the hub so yes there's still quite some work to do on this in particular analyzing the security in details in detail will you be the new protocol you need to verify be sure that there's no like flows and problems and also being able to implement like the feature of an exchange like atomic swaps and impartial order and now Antoine is going to show a little demo of what you got so far thanks yeah the demo may not look so impressive but what we've done is we've implemented all the the theory of how at layer 2 an exchange would be done atomic exchange completely trust less and so what's missing from the demo would be the unchain part like depositing and we're drawing at the end but just to give you an idea of of how this would actually you know some of the the code we have like we actually create an exchange object we create multiple different trading pairs there's two parties involved here that are going to deposit money in the channel and then trade with each other so they do create order objects and then these orders are being matched and and each order you see when I place an order the order has to be signed by the first party and then to take an order that's been placed in the order book I also have to assign if you're interested that comes yes after that I'll give you all the details but when I I run it on my old MacBook this is a 2015 MacBook we take advantage of all the cores should finish pretty soon well I just got under like 2000 transactions per second again like at layer two so so we are working on mechanisms to you know to handle the deposits the withdrawals and also there's some synchronization that needs to happen on chain at some frequency but this is a kind of number we can expect like even from an from the old machine so and this is horizontally scalable so we can add more nodes to the network oh thank you you 