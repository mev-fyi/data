all right we are alive cool I think what we did last time Alex was we actually had each of the II was and team members briefly share like a quick update about what they're working on I don't know if you had a different format in mind for this call well if you want to do that is it that likes me or sorry yeah this is that like suede I'm just gonna I'm gonna refer to you as AK sick on this call yeah I think that might be a good idea to give some kind of update where we are especially regarding the design process we started to do so who is willing to start ok I can I can start in that case so I have been mostly working on a couple of different things one of them is Hera which is the the C++ implementation of a in me was in Vienna and things one of them is Hera which is the C++ implementation of a correct could you switch a few Mike I just muted him sorry about that Greg we were getting some echo from your side okay so worked a lot on on the Hera together with Jake to get mostly VM or more like engine abstraction into it and the main goal with that is that we going to support multiple underlying engines to execute while some code and that will enable us to do benchmarks across them and have a better idea of performance I currently it only works with binary n' which is an interpreter but we have abbott again another interpreter and Vavoom which is a JIT in progress and that should we hopefully finished pretty soon and the second thing I must Lee worked on has been the rust implementation of the pre compiles so we have a repository called rust no rather he wasn't - pecan pies on the he was in project which has pretty much all the current pecan pies implemented in rust and we do exceptions it doesn't have the mod exp and doesn't have easy recover but it does have everything else and on top of that it has two new proposed kind of pecan pies in progress one of them is for Perry easy pairing on a curve called BLS 12 - 3 8 1 which supposed to be much faster to do pairing on as opposed to the the current B and 128 curve supported by T reom as so this could be utilized by projects such as Sokratis in the last thing i spent some time on is EVM - wasn't which is our EVM - if he was in translation tool and I'm kinda excited about that one so that's update from me awesome thanks for the update Alex yeah let's continue with updates and then maybe we'll move into questions after that cool Jake you want to get a quick update what what you're working on and maybe just feel free to introduce yourself as well hey guys um yeah well I'm Jake I work on primarily Hira right now and at the moment I'm working on kind of well the abstraction layer for the execution engine has been done for a while but at the moment we're working on merging it into master in the more PR friendly way and we're also looking we're also um laying out the foundation for implementing support for WebM as Alex said additionally we're considering looking at jet engines used in browsers for example spider monkey or v8 - as alternative jet engines for webassembly um another thing I'm working on is a tool written in rust to validate the properties of laws and contracts more generally I've been referring it as referring to it as the ECI tool but looking at it now it actually might be kind of like a prototype of the Sentinel contract for all the parts that don't involve metering yeah that's that's pretty much it for me cool thanks Jake Jared you want to do the same hey guys I'm Jared lately I've been spending most of my time on infrastructure automation for the the upcoming tests net public test net that we're working on and I've also spent quite a bit of time lately just getting a full toolset for that ready and so what that looks like is a lock Explorer Annie wasum a plugin plugin block Explorer and then a small smart contracts II wasn't smart contract editing environment that I've called awasum studio yeah I've made various contributions to other Evo's and projects but yeah mostly everything I've been focused on is around the test net lately so yep awesome thanks Jared bubble hi I'm mostly working on the images API for PM's that includes EVM so called one and he was an engines and helping with some good system issues and I'm maintaining C++ client of its you awesome thanks pal cool I'm Lane and I'm primarily focused right now on a new tool chain that I'm very excited about using typescript so actually it's called assembly script which is sort of a a subset of typescript which is strictly typed JavaScript and so basically giving you the ability to write smart contracts in in typescript and assembly script and compile them and run them and test them and everything integrated into the truffle suite which is coming along really well and I hope to be able to share that sort of publicly quite soon cool okay actually I think you wanted to talk about the design stuff a bit yeah so basically some of you may have heard about it but we had a decision hang out probably a month ago and the main purpose of the decision hang out it's kind of like the format of the old core devs meeting to discuss design issues which have been proposed and the goal would be to actually agree on some of those and make decisions it was a good learning curve and we have adapted that instead of a process on the design repo right now and the process is kind of okay maybe maybe started from the the part that first of all I'm not sure if everyone is aware of that but we had kind of a revision system for the given specification but that was scattered around between the different parts of the specification so different parts at different revisions for example the one for the functions the house functions contracts can import had a version number versus everything else and we have changed it into a single revision so the specification has a single revision at the moment and right now it's at revision number three and in in the past couple of months we were kind in a limbo where it was really hard to make decisions or changes to this and that has been solved now with a process where we have we are using github project system to mark revisions and right now we are discussing changes for revision four and the plants you have the plenty of a fixed amount of time for discussing changes for each revision and once all the changes for given revision Iran the deadlines are accepted the bumpty version and that's that's the diversion of the spec and at that point at the test feeds and all the VMS we maintained will be bumped to that specific version and and from that point on also contracts and other tooling can can use those words not to the point of had to actually discuss issues and changes is that probably is the more a more important one so anybody is free to propose changes either as issues or or even pour requests and when you do something like that you should you should indicate whether you you plan to discuss it in and and this round of changes so for example in changes for revision for and we would like to get as much feedback as possible on on the issues and the poor acquire but one exception for this specific revision for I have mentioned is this is kinda an internal one in the sense that we would like to close it off really soon and just get going because it changes like basic things we weren't happy with and but the next one revision five plans to be a three-month long discussion period plan to finish end of August and in during this period we plan to review every single its exported host method deeply and and provide suggestions had to improve every single one of those so in depth I would invite everyone to to take a part off and then the next stage is called revision six which is planned to be another month of discussion I I hope this kind of sets like a baseline on how we do changes in the specification so if any questions regarding this process please ask it now yeah I don't think I have explained it clearly because I was just jumping around so if anyone from the wasn't team wants to do a recap I mean just to set the stage a little bit here and just to provide a tiny bit of context that might be helpful ye Hwa's 'm is sort of like a standard right so where we have this thing called I know the name has changed a few times but I still call that the EEI right the etherium environment interface actually because that's sort of the right term to use for the kind of standard we're designing or I always forget if we landed on a different name for that I think that's also maybe one of the issues to be debated but EEI virtually only stood for the host functions contracts can import so it's only a subset of the entire specification right so yeah so we have this specification that you know originally was intended to be completely incompatible which is to say that you could compile contracts using the e azam toolchain deploy them and they could sort of interact with existing IBM legacy byte code contracts bi-directionally but so the the spec is now now beginning to deviate a bit from fully VM compatibility which I guess is part of the motivation for introducing the revision system here right is it actually is it the case that like revision 1 is the VM compatible version and revision 2 is where we kind of begin to deviate or is it 3 I can't remember no I would say we gonna deviate deeply at revision 5 so the old revisions revision we started revision 0 and it's been kind of stable for two years at revision 2 then we resumed actual work on the project and in from revision to to revision 3 we only made small changes still keeping full EVM compatibility and mostly the changes were to support byzantium features and now in revision 4 which is the one we're working on currently still maintains full EVM compatibility we are just trying to clarify a couple of things to make it more easy to use and by EVM compatibility here we mostly mean because it can have two different meanings and we have to also explain this in the future and much better but it means two things one of them is better II wasn't contracts can interact with EVM contracts and EVM contracts contracted II wasn't contracts and the second one is whether we can implement EVM tourism as a tool on top of this he was maybe I and we may deviate in in both of these different parts in the future it might be helpful as an example could we bring up one or two concrete examples of elements that are up for discussion in the design repository and things that are sort of going to go into like revision for things we talked about yesterday for example just to give it people a sense of the type of things were struggling with here deciding about so a good example for these tiny changes which just make life easier is one where the there's an opcode in avium called return which stops execution and returns data and in the e I in a was in host functions we have decided to use the very same name so contracts written in whatever language would import a function called return which which explains what it tries to do but isn't really convenient in many languages because return is usually a keyword so in most of most of the languages if you're importing a function called return you have to work work around a bit so we've decided to change it to call it finish so probably is one of the examples and another one and which is a bit more change is the one regarding block hash and the block hash function is doing the same thing as the block hash of code in idiom is doing and we have adapted that is supposed to the evm we're in EVM the only way to know whether it failed or not as it returns hmm it returns all zeros on this stack and and it wasn't with functions we do have the ability to to return to variety memory as well as to return a status code so we decided to also return a state is good indicating whether the block hash function was successful or it was a failure so these are the kind of changes we are making right now they're not really substantial they don't make any kind of compatibility but it just makes life easier one other question that might be helpful to talk about is sort of the standards we're using or the process by which we're deciding how these things should work so like POSIX is definitely a factor we're considering would you mind speaking briefly to that like how much is this informed by the EIT process how much is it informed by existing standards like POSIX how much is it something else Emma Dei IP would be the process of how to make decisions I guess kind of ended that regard with it do you plan to move into that direction especially with with this so-called provision 5 and I guess that that that's as much as we can we can really say about the EIP process in regards to it wasn't designed yeah sorry I wasn't referring to the IT process I was referring to like the II wasn't design process when we're deciding you know whether things should have return values that indicate success or not like how do we make that decision so the initial design was also kind of influenced by POSIX and therefore said I'd like to you two aspects to this one the way he wasn't and one the way webassembly itself is designed and it's designed in a way that functions at least currently can only return a single value which is up to 64 bits in size and that means if we are trying to return larger data which we do need to do a lot in aetherium we need to find other ways to do that and the natural v is kinda to use a memory space and have these functions just refer to a memory location where they expect the output data to be written so this is also basically this is what webassembly offers and this is the way is usually designed so by posix we mean how like Lipsy or NEC api's would work so basically all of the functions were designed initially with this in mind and now we are trying to at least in in this stage we are trying to make sure that every single function in in the specification follows this logic more closely and there's no there's no like two or three different ways of handling things any questions about near the stuff or I don't know maybe we could also open the floor to more general questions [Applause] sorry guys I'm not a question someone else has to ask a question so as far as the blood cash status code works like how how is that implemented where you have like a return value and a status code and how are you checking both of those or like what is the syntax for that look like that's actually a good question because there there's a second extending design decision pending on that one so basically how get block hash works is it's a function with two inputs the first simple dish is 64 bit number for the block number and the second the parameter is a memory offset where it expects the actual block hash which is 256 bit wide to be written into and lastly it can also return a value and the very huge returns is a zero on success or one on failure and so far we have decided that in case of a failure the memory the effort memory requested by the block hash function remains unchanged so whatever was there in the memory prior to execution will be left as is and there was a reason for this but there's also a reason to to just zero out or decide on what kind of value the that memory area should take in case of a failure so there's a new design discussion where we review every single function which can have a failure and also has an output Emery area and we should make a decision consistently had should operate should all of them just keep the memory unchanged or should all of them set the memory to a specific value that's the kind of house where's the question yeah definitely I think that this is sort of the same way that I would view like the high-level delegate cooperation and solidity where the status code directly returned but it's very unclear at least to developers that you can still access the data that was returned by that and other high-level calls by just like accessing returned data so is this like something that I don't know is yeah I guess is the decision now that we're going to put a pointer into all of these functions that in adjust everything will be copied to that location yeah yeah most of these actually work like that and regarding delegate call or any kind of call that is one of the changes which have been made in and revision tree that any of the calls don't take memory pointer so they're they don't write you any memory rather the contract has to explicitly call returned data copy to acquire the data so basically there's this only one way to to receive the data from calls as opposed to the two different ways in IBM so with the get block hash function I guess you're expecting only a 32 byte return size so I guess I'm wondering like are you implementing some sort of a pointer type how do we make it easy for developers to supply a destination to copy memory issue and like they know that they're not overriding anything this would be answered by the effect that it is like personal opinion but I do feel that domain-specific languages make a lot of sense for things like writing contracts so for example if you take the solidity solidity plans do you have it was am support and and in that case the compiler would hide all of that complexity from the user and they wouldn't really be any change to the user had to interact with the blockchain but if they are speaking a bad more low-level languages for example C then the user has to be fully aware of what's going on and the middle layer between these would be probably assembly script or rust but yeah I would say probably assembly script is kind of like a middle layer between these two where we're still not like a fully domain-specific language but probably it gives you better guarantees and then what C is doing maybe Lin can talk a bit more about this yeah I mean I think that's accurate in terms of where it falls you know relative to C and solidity it's definitely not strictly a domain-specific language so far in the work I've done so far I've made very very small number of modifications to assembly script itself right so I'm just using decorators right now primarily but I think it's just too soon just not enough of it has been built yet to sort of answer that in more depth when changes get me to EVM actually Alex I'm curious actually I'm curious how this works right what is the process by which like solidity itself gets updated to add support for new like op codes or changes and things like that like for example return date a copy so its solidity and mostly that this may change because now we have an EVM version setting in a compiler but before that we were really conservative when and how to introduce new op codes and but since we have that setting things may be a bit easier but how it has been in the past is whenever a heart for kit this is decision on the EIP s for heart for core really concrete we're really close to acceptance the confidence level was high there was a point when we started to implement support for it there's one caveat is that in many cases this testing infrastructure of aetherium relies on either code written in lll or were even code written in solidity and in order to do that they would need language support and now with the for the last like two years solidity has that feature for inline assembly but if anything is that both lll and and solid it is inline assembly they rely on the same underlying assembler so basically the first step usually we did is we just added the basic op codes to the assembler which then made it accessible to lll and inline assembly solidity and because this was needed for tests to be written and when confidence was really high that all of these of codes gonna make it into the main chain or if it was a backwards compatible change such as using revert because we wanted a failure anyway so we could just start using the revert up code which caused a failure and after the change still caused a failure with less less gas so we could merge those up front but now I think it's just gonna work based on the the EVM version requested during compilation so one of the things that was mentioned was like can we create a method to I guess provide a way to do you awesome to evm and vice versa how like divergent can these get before that becomes completely unfeasible or is it even feasible with the current direction does anybody else from the team want to have a go at this but I feel lonely speaking here but I can I can get an answer if nobody else wants to what I can try so I believe tool called EVM tourism it's going to be feasible for a long time it's with the incoming changes probably there will be like more work for the tool to be done at runtime to simulate EVM within the it was in context so yeah so far we have quite quite long queue of changes that were proposed but just just on a paper it looks like it would it would be possible to simulate EVM it it will require just a bit more code to generate to support that so you would get some additional so the mapping couldn't be so like one one you will do additional checks to support particular EVM up code maybe to some code additional evaluation depending on on the some preconditions of that and or maybe like execute three or four different it was a most functions to support that but looks like at this moment there is nothing so big on the horizon to to break the compatibility I think the only the only aspect of that is I mean to support AVM we are adding functions to the set of host functions that probably wouldn't end up there if we designed that from scratch so that means maybe at some point we'll just forbid using them in pure it was in contracts to like we'll have the specification of them but depending if on that if you're deploying the new it was in contract they might be forbidden there and to support EVM to azam they might be available because EVM to Azzam will we'll work with some privileged in the client so so so we might end up to specifying the some set of functions and then subdivide them into subsets and they might be useful in some context and not not useful in others so it wasn't - EVM plant I guess that's where I was having a hard time figuring out how that would be possible if they're particularly divergent or is it just EVM - awesome it's just EVM - awesome the other way it's not something great like this and then I guess one of the things that I think other Alex mentioned was that you may have for example so if you have a call or a delegate called then you remove the parts of those off codes that currently require specification for where you want the memory to be copied to so out and out sighs I actually really like that idea is that a change that would be mirrored in the EVM or is that just something that is planned entirely for you awesome well if I understand the question that's already in the VM its it's only the matter that you actually have like two different ways of getting the output from from a call and and the newer one is also more flexible and more generic one so in one so we just like we skipped the old one and we use the pattern ax with this return buffer that is accessible after the call and also solidity switch to that as well I guess so there's there's certainly a return buffer but I was I thought what I had thought from from what he had said is that specifically so a call up code takes gasps address value in in size out size and you would remove the out and out sighs who would only take four or five five five arguments instead of seven on the stack is that what was being said or yeah I think so I mean actually I'm not like super familiar with with the code with the call serious back yet but yeah that might be the case okay in in the e bottom version of the call those two have been removed so you understood that correctly but I think your question the second question you had was more like whether this change could also be proposed to EVM if I got that correctly right as I understand it there is some talk of EVM 1.5 in I'm not sure if that's still a possibility or if that's yeah I think personally to remove those fields from the call seemed kind of unlikely at the moment because that would be break backwards compatibility so they're mostly features if there was changes they were introduced within you up code as opposed to changing an old up code so I think this specific what change probably is unlikely to happen on the EVM but as regards your second question regarding India 1.5 I think that's a separate discussion but we certainly have the right person on the call with Gregg who is the the main person pushing even 1.5 so he may he may be able to give you some ideas if Gregg wants to speak I'm here I'm not sure I got a clear question to answer there and I'm yeah no I think the question is just I don't want to hijack the Wasson call here but I guess the question was whether the out-and-out size would be removed from the like call based op codes and EVM no no xxxx right it's for backwards compatibility it's almost impossible to change anything that's already in the EVM the best you can do is put in something new that works better and encourage people to not use the old stuff anymore and if one CVM 1.5 is supporting validation at least you can refuse to put stuff on the blockchain that does things the old way but you still have to keep supporting the old way forever make sense lock chains never die but yeah one more huh sorry where is the what is the current line of thought on awasum and EDM contracts interacting with each other how does that work from a client perspective is that like what is it does it become really inefficient if you suddenly switch from one VM to the other I don't know how that works so as of at least today and I think that that probably is one of the motivations at least right now for the upcoming test net is to have compatibility and have the ability to run above kind of VMs on the same network but this in the future test might change but I think for the test net this is one of the goals we have and then in terms of has seamless that is to the user it should be entirely seamless and if they keep using EVM code then obviously there is no change but one one tutorial we are planning to to work and publish is the is one where there is an EVM or more specifically a stolidity contract which can be deployed and interacted with the usual tools such as remix and test solidity contract interacts with an other contract which is any wasn't contract and for example that other contract could be something similar to a pre compiled in terms of implementing a more heavy feature which is worth writing in a low-level language so one example here could be that we deploy say Blake Blake to be hashing SNA wasn't contract and make it to speak to a solidity contract and the tutorial would explain how to a solidity contract can speak to such a such a knee wasn't contract sure I think it makes a lot of sense from someone that's maybe using the contracts but from I guess the nodes perspective is really what I was wondering if you have to simulate running an EVM contract that calls into an e wasum contract are you then using two different programs to like mid execution to run that and is that inefficient so maybe I'm just gonna say one word before maybe handing over to to Pavel if he wants to you to explain a bit more on that but in practice every single contract has its own and clave its own instance of execution so even with he wasn't for every single new call we need to instantiate a new new instance and it doesn't really matter whether that's it wasn't VM or that's that's an AVM interpreter so it instantiates a new instance of the VM whatever VM it's supposed to run yeah okay but that's a case for EVM already I'm not sure if probably if you want to expand a bit on that we TV MC or is it worth expanding on there I think you pretty much change to answer my question anyway right I have a question now what will everyone on this call hmm what will be the first contract / project that you will deploy on the US on test net I tend to just shoot for the joking contracts because it's something that's so easy to understand and do you plan to to write that in any language compatible to it wasn't at the time that the text net is released what will be comparable to EU awesome will solidity exist yet or will I need to be using something like typescript or or rust or what so C C++ and rust are definitely working even today I think assembly script is close to completion at least in terms of usability of like basic things I do hope and expect that assembly scripted at the time of the test at launch will be in a state where it can be used for you know basic tasks easily unfortunately solidity probably will take a bit longer to be supported but yet that stay and go to also have solidity to compile to it when is the test at launch so we're aiming to to launch it at before around DEFCON okay that's like early November right and yeah like end of October would be Def Con so yeah around around that time hi I'm Joe so I work on a project called arithmetic ax and it's a computational mathematics platform and we'll probably be interested in porting some of that too II was um I'm interested to know for a wasn't project like what's kind of like the simplest way to UM get involved as far as like do you just read the repo and then just start kind of like a branching or what hi Joe yeah that sounds awesome probably the the best things you could do is have a look at the design repo some parts of it and adjoined the Gator channel if you're in gator because in Gator we can give mostly instant feedback to you questions yeah I think we need to probably do some kind of tutorials because the design repo isn't isn't the most digestible one so if you do a deep dive into looking into the design repo I'm sure you're gonna have a lot of questions and and you could tell us how to where you got lost or how to improve it great thank you yeah we're very well aware that we can do better on documentation and that's high in our list of priorities certainly as we're gearing up to launch the test net we'll be putting a lot of effort into tutorials documentation hopefully like sort of explain your videos that kind of stuff as well and we really need your help with those things understanding like Alex asks what are your priorities what formats are the most helpful that sort of stuff oh yeah so it definitely wasn't a critique on it I have just kind of had a cursory look at the at the github repo and it seems you know put together no definitely getting the Gator general and what you'll know if I have any questions yeah please definitely get on to the channel because the design repo probably doesn't explain a lot of things and it is centrally organized in a way that it can be digested so you probably yeah it doesn't really explain how to run a node which should be possible already and had to interact with it and you know what kind of languages and had to use any of those languages together with he was in because most of this information is scattered around in the different projects so for example some information can be found and he was and pre compiles which in a basic way explains if someone is familiar with trust explains had to compile rust code to II wasn't and and what features can be used and then Hera which is the VM in the readme kinda explains how to compile it and how to use it with CBP team to run a node but none of this is collected into a single place yet I think fun project could be to implement the evm inside you awesome is that something that anyone's tried just as a side project or something there was there was an EVM in solidity project I think right I don't remember how complete that was I've seen a couple of those yet but hey that could have interesting implications for like plasma and stuff if we could actually get it working yeah I think the most appealing aspect of it to me is just that that really I guess helps you understand what the conversion is between the two or you know at a low level how they both work thanks Alex are you volunteering to work on that it's interesting to me so maybe I don't know sort of a better a better even in callosum would be a more useful project I think you learn the same things EVM to awesome implemented on the VMware awesome no just um turning it into a really good compiler rather than just what it is like well maybe it's improved since I last looked it's as C++ now right as an improvement last I looked it was a fairly well maybe it can't be much better without 1.5 but it it just sort of chops it up and spits it out YUM and then it's left to the wasum compiler to try and reoptimize it oh yeah yeah that's still the case so I think Alex was kind of pointing well I guess we have like this two different options so what EVM to wasn't currently is doing it's translating EVM into was on bytecode which then can be executed but another interesting project is mentioned here would be combining an EVM interpreter into awesome and wanna get us a contract so instead of instead of doing the compilation up front just run it at the time sort of the difference between ahead of time in just in time compilation I guess right or I guess it's interpreting versus ahead of time compilation so that would be a tool to take EVM contracts you had on the blockchain basically convert them to azam and and stop using the old ones I don't think that it would be a real tool that that kind of thing sounds really inefficient it's just a for fun project no it would be very efficient you you wouldn't be translating it over and over again you translate it once and stop using the old one I yeah I think I meant that the overhead of simulating the EVM within the wasum contract sounds like it would be less far less efficient than just writing it in blossom or something like that true true [Applause] I think that the idea actually is good in terms of so with DVM tourism and one of the reasons fee so basically iam tourism I was part of initially of a compatibility proposal where the especially in like clients the like lines wouldn't need to implement EVM at all they could just implement you awesome and then they could use EVM - wasn't - to still run even contracts but then lately the main reason we have invested time in EVM - wasn't it was that with the help of it we can tap into the testing testing speed of etherium but as Craig has mentioned the the code could could have some improvements and it isn't compatible with all the up codes at least in in Byzantium so compared to that and that kind of seems like it's gonna take a while to make it fully compatible but compared to that your idea of compiling and already existing maybe an already existing EVM interpreter and here any C or rest implementation comes to my mind could be like a good good way in the middle - to tap into the testing suite now it when you're running like clients all of these issues of attack surface go away my clients can run code of their own choosing they're just they're not part of the attack surface of the entire net in the same way I don't understand the various kinds of nodes and how they interact as well as I should but there's a level below which these attacks don't affect anything but the node that's being attacked so these these nodes can actually go ahead and use existing existing laws of implementations get the performance out of them running EVM tourism doesn't look so expensive they can go ahead and cache the results of having done that it's a whole different world there yeah a lot of efficiencies can be gained in various ways that are not available to full nodes that have to be gas hardened was that not understood or not interesting no sorry Greg I was just thinking something else but thank you I think that was good insight and I was just like looking at the clock because we are taking to the end of the one hour so I was I was wondering if if you have any herb like questions topics to discuss I don't cool thank you guys for joining for asking questions for listening Alex do we know what tempo we intend to do these calls on going forward is it two weeks three weeks I think we really wanted to do them every yeah two or three weeks last time we kinda leaned towards to do it every two weeks to be consistent and do it at the very same time so just like the ol core devs people care people have an expectation when it is and there's not much deviation today so I think that would make sense for this call as well because then we could be better prepared and yeah it probably is a good idea but maybe two weeks is too short maybe we should do it every three weeks I'm not sure my gut tells me three weeks every three weeks is enough for now but maybe after the test has launched and you know we have more questions coming in and more to talk about that maybe we could do it more often what one housekeeping thing I was looking at the the the the meeting kind of like times right and you know ones for for the us were off by an hour because we're in daylight time right now just FYI thanks Joseph yeah I appreciate that um I did double check the times I'm pretty sure they're right but I'll triple check and we'll be super careful of that going forward I know that the one-hour thing what the daylight time can be confusing UTC is our friend yeah that's what I did I put it there by calendar as UTC and then I got the right time yeah when in doubt UTC prevails I'm gonna I'm gonna run thank you guys so much this is really helpful mm-hmm great it's like thank you for the great questions likewise thanks guys we should we should talk soon Alex yep definitely 