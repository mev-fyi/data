okay we're live Alex did you or anyone else have any particular agenda or discussion items I don't think anyone added anything today ticket github yeah nobody ever adds anything but since we have Danny and Sammy here I think they probably have questions so I would just start with those and answering those questions okay well I don't actually have any questions I just i-i've a Quadro bit and well I think I think CCC nah seen a husband like pintuck talking to you guys from through a bit but he's now working on at a pro project so so I'm just just checking out what's going on cool yeah nice - nice to meet you send me we're a big fan of tribute here and I've definitely had a lot of conversations with Mussina about what what the trivet team is doing with technology yeah if anyone if anyone has questions for us then please feel free to chime in with questions if not maybe we could kind of go down the line and each of us just give a brief update of kind of what we're working on and that is the project is that sound reasonable and I think there's actually one agenda point we could talk about in the last couple days I have seen some discussion around the future of EVM based languages versus he was in in the connection to you apparently there was an update last Glasgow awkward F call by Vitalik and with the potential roadmap on having termed etherium 2.0 and some people have understood those words as going forward to it something based on webassembly or maybe more specifically he wasn't and that would mean that all of these EVM based languages would kind of be deprecated and wouldn't really have a future so maybe that's a good topic to talk about and what do you think guys I think I agree but we I think we could also do the update thing just for the purpose of documenting what's going on maybe we could do a quick update and then talk about that mm yeah I guess let's do an update do you wanna start cover it with your side of things I'm sure so yeah the I mean more more naming crisis is happening because we're trying to you know figure out what to name all these you know we're trying to plug in you know II was um VM evil ISM execution engines into into aetherium clients and make them ready to run on a blockchain and that is causing confusion about like are we going to you know have ewaz encode able to call EVM code and if so what's the layer that kind of handles all that logic but otherwise just been kind of gradually refactoring KVM to make it so that I can pull out these call semantics but I don't like I think I'm running into a little bit of the perfect is the enemy of the good crisis because I keep not quite being satisfied with the refactorings and it makes me not make enough progress probably so I'm gonna try to get this gas refactoring into KVM and then I'll be able to pull out the hopefully pull out the calls into the the K specification of this abstraction layer between a client and execution engine and yeah that's about it otherwise I've just been working on K tooling stuff which is not very he wasn't specific but could produce an e woz and debugger for instance or EVM debugger stuff like that so that's about it any questions or move on if anyone has questions please feel free to just pick up I think separately we could we could also deep dive a bit more into this naming discussion Everett has mentioned but maybe do it after day to stand up okay I'll go ahead and give an update hi guys this is Lane I'm starting my avatar says aetherium foundation I can't change it that's just how the streaming software works yeah so as people may or may not be aware we are working now on launching any wasn't pet net so the piece of that I've been working on is test of trying to write some low-level webassembly test to make sure that all of the various AEI host functions are working properly or passing the test that the layer we have with system between the deposit engine and the etherium client that were using CTP etherium yes basically is bug free or as close to bug free as possible I think we may talk a little bit more about what host functions and EE I and all that kind of stuff gives in a few minutes here that sort of seems like an interesting topic to dive into and the other thing I've been focused on is we are now talking to the Trinity team right so Trinity is a brand new client written in Python that Piper Miriam and Jason Carver and a bunch of other awesome people are working on and they've just done an alpha release so we're sort of figuring out right now how to a specific question which is how to integrate how to add us and supports to Trinity and then a related general question which is how to think about adding he wasn't support to any aetherium clients in general where we're going some proposals and hope to share those very very soon for feedback you it's great to hear Lane maybe I go next um mostly I've been and been working on on Hera which is the C++ DM implementation and I also have been working on the a library in rust to implement the awasum quote EEI which is all the methods as of today all the methods a contract can access and give a nicer abstraction in rust and in connection to that of working a couple of currently team pre comprised implemented in rust which can be compiled directly to be web assembly and this would be a I mean it has two purposes one of them the actual library can be used to write contracts in rust and the pre-compile makes sense for two reasons one of them they're like a good demonstration of why there wouldn't be a need to have pre comp eyes because one could write them as a contract and second it should be a good starting point to do benchmarks across different he wasn't VM implementations as Lynn has mentioned there is working progress to implement in native he was him support in Trinity which means the entire VM and the execution engine and the execution engine is the actual part running web assembly today the entire VM would be written and entire clients in the VM would be written in Python whereas Hera which is the C++ implementation uses currently a single C++ execution engine called binary n' but there's some work ongoing which would enable her to use multiple execution engines of course one at a time and but one of the newer execution engines we're looking at is a JIT and based on LLVM and having these pre-comp eyes and having the support for the jet as well as having the trinity implementation would enable us to do benchmarks across all of these and having benchmarks would enable us to do a couple of things but one of them is to determine the entire gas calculation gas costs in a more reasonable way than we did before and so I think that's really exciting and thank you you I think I can go next well lately I've been working on writing more test cases for yusin and reviewing reviewing well do test cases from Lane as well well yeah I think we are having good progress on on writing new test cases well Casey and art are known here but they are having a good progress as well on on the on the e wasum explorer so I've been trying to help a little bit on that and fixing just minor minor bugs there you go you guys can you explain what you want to explore it and how it fits into the cat that yeah sure well currently the the the you awesome Explorer we have is a fork from either shine so Jarrett and Casey adapted it to to access the Eva and E was a note and actually show for example you can see the the current blocks you can see the pending transactions you you have you also have the a list of accounts and you can see the even some by code of the contracts deployed to the e wasum test net and I that's it thank you go does anyone have any questions about any of the upgrade topics and if not we'll move on to the other topic that Alex proposed cool Alex I think you said you wanted to talk about the naming / abstraction P sorry um yesterday there would be two topics I think could be a good conversation starter one of them as these two different abstractions we have in the naming random or made three different abstractions and the naming a random and which may be quite a big topic to talk about and the other one is what is the future of Evo based languages and if he wasn't comes around which one should we start with well the naming one seems like a more concrete discussion to me so I would vote to start with that but it's up to I don't know how how concrete you and using the other discussion being well for the other one at least from myself I can give my opinion and then overs you just to set the scene but luckily we do have a couple of other people from from vipers well on the call so they might be able to chime in and give their own view on the topic regarding the naming discussion I guess we would need to start with a quick introduction to what are these different things we are trying to name and and I guess started the naming discussion from that point and I'm happy to start a bit with any of those naming is the most important thing first for someone that has come from name in fiber to fiber with the Y I can just tell you guys please just check everywhere where these names have been used before we've had trouble with the capitalization of ye Hwa's em is it lowercase e upper case was M is it all lowercase which is not even as hard as changing a letter so couldn't speak yeah just just trust me take taken from from me be very careful because it turned out there was already a Viper language like a programming language we had to change it so now it's with the Y so guys just like Google yourself flat and make sure like all the items or like for instance pi PI the package managers also have those names available it's very important that's all I could say yeah I agree I guess if you're in community kind of has a history of naming problems huh yeah I'm glad settled on Viper with the why and it's no naming conflict and everybody's happy and using that name well if you're if you're on maybe we should just quickly start with the language part Everett if you like yeah yeah okay I guess I can watch so you want to start with your view on wiper and what the future would be with wiper if he wasn't comes around alright I'll start with what we just discussed it kind of happened organically right so what is what is interesting is like what what are the implications because we see these things like and even to wasn't convert right and I looked at it and we just start laughing because like all our languages I mean and this includes solidity was basically designed around this concept of 256 bits and now we're moving to 64 bits and the conclusion that I just made well overthinking it just like for 10 minutes so so just consider what I'm saying that it's a - well full through is that basically like we either have to start adding new types to these languages because it just doesn't make sense to translate 256 bits the incentives are just not there to do so because it's just so much more inefficient to write 256 bit math in 64 bit math and then there's no incentive for anybody to ever run a contract using v1 which means we have to start adding 64 bit types to the language so that would be my first question is that is that what's intended I think if you're asking about deprecation of v1 at least my personal opinion is that yeah we should you know take steps to deprecated EVM again but just because it's you know it was kind of a first cut and it's you know it doesn't have good modularity and separation of concerns and it has like some kind of weird things that people kind of largely agree are not good for for low level VM languages stuff like the unstructured control flow and all sorts of other little issues and I think I think people largely agree that that EVM v1 is not the ideal design of a VM it doesn't have good separation between the etherium level stuff and the VM level stuff but regarding the 256 bit and 64 bit translations I think that's just a fact of life that we're gonna have to live with the idea behind waz M is you know we're we're we're trying to make and you know a language that Maps well to hardware so that it can be you know executed efficiently on hardware and so that a lot of the standard optimization engines that exist can be applied directly to it and the fact of the matter is that 256-bit hardware doesn't exist like that it's all so right so the translator would be a stopgap basically you mean EVM the wasman specifically yes it would be like a type of stopgap until the languages accommodate 64-bit types well I don't know if I would I would like it to be that EVM to azam is yeah just a stopgap basically just to get just to be an initial approximation of the contract but I would not count on even what awasum being a semantics preserving transformation right I would say like so you know I would I would say like if you if you are confident in your bytecode before and then you put it through EVM the wazoo you still need to go through all your quality assurance checks on the generated wasum code to be confident in your bytecode after yeah so basically what the conclusion I'm making for my site is one contest has just thought from scratch in terms of the lat which development like you could take the syntax as the base the you know the the structure of what it looks like but basically considering like you don't everything should just start from scratch including even the ABI yeah I suppose I suppose so I don't know how much how much from scratch though you really have to do because I think that a lot of that heavy lifting has been done I think Alex would know better than me about exactly how much the heavy lifting has been done but but I think like a lot of the the 256 you know a bit encoding into 64-bit arithmetic has been done so Alex can you maybe talk a bit about that and so actually I wanted to read it okay so I guess I didn't on you did I just wanted to give a quick overview for those potential people who can maybe watch this after the live stream and just to maybe clarify some of the confusion um and that confusion is and sorry for saying this having all the VIPRE for folks on the call but it really seems at the moment solidity would would have a bigger market share so people are really concerned what happens to solidity if he wasn't ghost life and but it's it's nothing against wiper it's just the effect that may or hopefully will change actually hope there will be more languages just first of all we we have set this I think every single time we made any kind of discussion about he wasn't is it really makes sense to have domain-specific languages for smart contracts and but one of the main points of using that assembly is that we have access to a much bigger and much more mature tool chain and one of those two chains is LLVM which enables a lot of different languages people are familiar with but they may not be domain-specific enough in some cases but they do make sense to to write heavy-lifting code in for example that the one thing already mentioned would be pre-compile anything which would be like a utility library or a much more low-level thing that really makes sense probably to write in a language which can be optimized but at all the existing to change but probably higher level rules and logic very likely makes more sense to be written in a Toni specifc language and one of those would be solidity another example today would be Viper but they're I think they're ton a ton more being developed for EVM and and probably quite a few being developed for web assembly based blockchains already and and for the for the actual solidity in question in the solidity project itself there is an intermediate language in development which would have a web assembly output but then of course the solidity language will need to be translated into this intermediate language which probably is a tiny bit bigger task but we do expect it to happen you know fairly soon within in within a year but it's worth mentioning that one of the one of the other projects working on the K framework of whichever to behave on the call who is a big contributor to the K framework K framework based on my understanding should be able to compile solidity to web assembly at some point the future as well so one may not need to you to wait for the solidity compiled to compiler to support this and yeah I would say the solidity compiler will probably have support for awasum sooner than the K framework SBC stuff will be ready that's more of a six months sort of proposition but but also the I think supporting awasum from Seoul see shouldn't be too too hard because it took two engineers here at RV only a few months to support ela from Sol C so I think that it should be and y la has different architecture for integers and stuff then and DVM does for example so okay go on yeah it's definitely not it's not a big deal to do it it's just a matter of time and right now the the focus isn't on on that project and but it's definitely definitely on the the timeline to to be one of the DZ more important projects next so hopefully that will happen but as a stopgap as Everett is mentioned and iam tourism could be used to translate codes generated by solidity or viper-two webassembly and and then I guess just a quick note on this other topic which have been brought up whether we should keep all of these 256-bit centric designs we have currently one of them is the ABI the contract ABI and I think personally I would be interested in and maybe looking at this in more detail and I'm thinking about a 64-bit ABI which actually isn't really dependent on e wasum it could be supported by current EVM languages as well and and if the ecosystem is is determined to use he wasn't which would be 64-bit then this transition could be started even before launching it wasn't but there probably is a good idea to think about that and because whenever a contract a higher level logic contract would need to be written in any kind of language and most of the languages aren't really designed for 256 bits and therefore there would be a need for a framework and in any of these languages to deal with ABI encoding and everything else which would be a common thing in writing a contract and and if that is 256 bit on a 64-bit machine there is probably a lot of wasted effort which doesn't need to be done so probably in the next couple of months that could be a good discussion point I think that's all I wanted to say you sounds good to me basically from since we're a very small team as in it's just me currently on permanently on Viper the way I see it is I would start with the second version of Viper that specifically targets 64-bit and all the types would would specifically be catered for that including the in-memory bytes because that also changes so kind of like writing a second version but just keeping the the lessons we've learned from the syntax I'd I don't know if that's if it's even necessary to be that extreme though because the already in the EVM towas and repo there are a bunch of chunks of wasum code that directly you know do the 256 bit arithmetic over 64 you know over the 64 bit representation just you know handling chunks of them at a time so you know for you can I think the approach I would think is you know okay add the 64 bit types to to Viper and then when you're emitting EVM code you know just round it up to 256 bits and then when you're emitting wasum code if it's a 64 byte use the native and if it's the 256 just omit the chunk of wasum code that you know handles the two things so I'm just saying I don't know if it's I don't know if you need to worry too much about it at that layer I guess is what I would say or maybe you could just start off by adding the 64 bit types to the Viper level and then say okay if you're emitting wasum code you know we're only going to let you use the 64 bit types initially and then down the line worry about emitting I'm just saying like there's already wasum code in place our new chunks of azam code you can take that have at least some testing against them forget that that's roughly what I have in mind so like sort of have like like like I said the stopgap one would support like let's call it Viper one it's not the real version but it would be the eBay in one version and then I see like adding 64-bit types being like only like sort of like mashed together but it's early day so I'll see how it how it develops but yes that's that's roughly what I had in mind okay yeah and actually there's one comment on on the API so you know right now the ABI on on the part of interfacing with the contract it usually starts with a selector which is a 32-bit and number and which then which isn't followed by the actual ABI encoded data at this selector right now all these is a hash of the function name and the input argument types but it doesn't take the return types into consideration and there has been an issue I'm not sure if you guys are familiar with it or heard about it but due to due to the way solidity the compiler in solidity didn't do a couple of checks in the past because it was kinda impossible to do them effectively before having the return data copy and return date the size of codes it didn't do it didn't do any checks better the called function on a remote contract returned to expected data length because there was no no way to tell and therefore in ER C 20 tokens some of them I think at some point and they have changed the interface of ER C 20 the transfer function and previously it didn't return anything but after this change its return a boolean and they also changed the semantics better on an error it should return false or whether it should throw but it was a big mix between these two and some of the centralized exchanges the started to take the newer version of the interface where it expects a billion and the boolean has to return true if it was successful and there was a change in the compile and the solidity compiler when recently the size was made available and byzantium and after that basically what happened I think roughly five to ten percent of the tokens were broken if they if the exchanges were compared with the recent solely diversion which actually checked the length I can give you the the actual issue numbers too which explains this in more detail but what this sparked is a discussion is a potential change to the API where the selector should include the return data types as well and not just the the input argument the types of the input arguments and if we want to include those in the API that's already a breaking change and if you do that we could also consider looking at a different kind of API then what we have today and I'm sorry tests this may have been too long as an explanation but may be relevant to this discussion I agree that would be a perfect in order to put it in but even considering like the history we must actually consider having some type of versioned API perhaps if you know what I mean because this is a perfect example that like completely backfired and it's really difficult to patch postmortem yeah DVD versioning also came up as a potential thing which should be added if such applications just made yeah so Abed will allow breaking changes and it would allow the the client libraries to pack you know the dates are based on a version kind of like catering for expansion later like you don't decide something like you kind of design it so you can expand it later I think that that would definitely be a good value add in the API design yeah I think versioning in general is something that needs to happen in a lot more places yeah the ecosystem yeah I and the API would be a perfect use case because you can have like the client knows okay this is V eggs so I can't do this and then like the the contract can just assert based on like I don't know you know eight bits even it doesn't need to be much make it like 32 bits I guess every the only reason I mentioned this is it's definitely not an issue to support the current ABI even if if the language is designed to be 64 bit but if we have this opportunity to maybe change the ABI because of these issues then we may it may be may be useful to think ahead and look at 64 bit options yeah the reason why I suggested like thinking of a new API is basically because because of the incentives people are going to only be using 64-bit structures because it's going to be so much faster than the you know the stopgap would there's no real reason to send all that all those zero bytes just because of the old version I certainly hope so do you guys want to move on to the the naming discussion Alex just one quick note like a time check here I'm gonna have to end the call in about 15 minutes sharp we can maybe go two or three minutes over let's just make the best use of time if it is a big topic okay I guess I can give like a one-minute overview of what we would like to name so one thing we have I guess I start from this part is EVM see we started out as a C header defining an a/b I had to plug in a VM implementation into an ATM kind and we started from is writing an EVM JIT and a C++ and plugging it into the C++ client and it also the motivation to have it plugged in into go etherium and with the air sis has evolved into a stable specification and it's called EVM see right now it is supported on a client side by CPP theorem and there's a prototype for goiter iam Enders and I did it prototype for Pi areum but it's been proposed that maybe it should be supported by PI EVM on the VM side it has three working VMs implemented in it one of them is EVM  the other one is a interpreter called Aleph interpreter which is the old interpreter pulled out from CPP aetherium and third one is Hera which is the V was an implementation so this e vm c is defining and abstraction layer had to separate the VM from the client and there are consideration that there are other ideas that this could be used as just an abstract layer even if it's not see but used within client even within the Python client female like Alex that kam also conforms largely to EB MC I heard about it I I migrated it over to use the same status codes for instance in the same and I naming conventions yeah the status code was is one thing I'm not sure if you also use the the rest of subtraction well yet this came up really as a discussion in PI a vm / Trinity the the other thing here we have right now is something called EEI which started out as a list of functions contracts only wasn't can import from the client and ii i stands for atiim environment interface but it really seems like that it could be used as an abstract interface of what are the state a client exposes to a contract and how the state can be accessed and modified and and ever it has started to use E is a term for this exact thing this abstract thing in the K framework and the last thing we have which the I was originally used for is the actual list of functions a contract only was and can use so probably these are the three things we have right now and there is a confusion between them between the naming of them I'm not sure ever I do you want to take over from here that sounds pretty pretty accurate in terms of my understanding of that of the situation but yeah the main the main thing is we're going to the Trinity folks with this proposal and I just want to you know not be spreading more confusion with with you know more different uses of the names so yeah I think the the original adding the EEI spec I was thinking EE I was both layers it was the you know the there's the EVM sea which is kind of the layer that the execution engine exposes to the client in order to drive the execution engine and to get back information about what has happened during execution like was it an out of gas or a revert or something like that and then the II I is the other direction what the client exposes to the EVM and initially I was kind of ballooning II I out to cover both layers but I think now EVM C is kind of the client the execution engine side and EE I is more the client side but I still think that EE I should be more general than just II was them for instance because we well I mean you could you could think like you know II was in v10 he was in v2 dot o or something right you want you know at least it to be you know specific to each each version if he was and then beyond that you would think okay I would also want to be able to support the different versions of EVM or or something like that so yeah so for my my thoughts on it are you know II I would be the methods exposed the state update and state get getter methods exposed by the etherium client or theorem node to the execution engine and the execution engine also exposes some kind of status codes and hooks for driving execution to the client and then we could call that EVM C or we could call the whole thing EVM C and come up with some other name for the smaller thing that is that what the execution engine is exposing but yeah mostly I just want to make sure that we and you know I want to like let's decide on some names and commit to it type of thing you know like let's let's just do that and move forward I think I would like to add one one day don't think to the EPMC is that we really to make a separation I think between two things fe BMC is used for the abstraction layer then the actual CA bi we which is which is what's emc right now is the CA b i should have a distinct name because it's one thing that a client has this internal abstract separation of concerns regarding the decline in the state and the vm and it's another thing that's a actual vm conforms to this if this a bi and the client conforms to the api and therefore VMs can be plugged in to the client well I guess I would just think of calling that as like you know the C plus the CPP aetherium implementation of EDM see you see what I mean like you don't I don't know that we need a whole new name for each languages implementation of the same interface as much as just saying like this is you know the implementation of the interface in this language so it's actually not C++ related this is it is more like a an actual API and whatever system you're on but it definitely works in the Mac and Linux or any kind of UNIX or POSIX system it's an actual ABI binaries can be compiled to you and if you have the VM comparison binary then you should be able to like the client could use an FF I if it's it's a script language or it could be an actual binary and would be able to load the binary without any issues whereas I think if it's just the abstract the abstract layer of another client that may not be hundred percent compatible also I don't think we will come to any kind of consensus during this call but it's more like just raising the the actual topic for discussion and whoever's on the call who or whoever is watching this after feel free to to raise your voice and come today you awesome lobby which should be on I guess in the YouTube description as well you yeah I'm I don't know I guess that seems like a pretty succinct summary of what's going on there so I don't yeah I also don't I also think we should discuss this over text and pull requests more than over over a video call cool any last-minute questions or updates okay yeah I think that's a good place to stop Alex ever thank you guys so much that's um I'm learning here as well and this is just really really interesting topics as you guys said we're not going to reach any conclusions on this call but please join us in the in the e azam getter channel I posted that both on the public youtube link as well as here in the Meetup thanks guys we'll see you again in I guess three weeks for the next call hi Greg thanks guys okay thank you bye bye thank you 