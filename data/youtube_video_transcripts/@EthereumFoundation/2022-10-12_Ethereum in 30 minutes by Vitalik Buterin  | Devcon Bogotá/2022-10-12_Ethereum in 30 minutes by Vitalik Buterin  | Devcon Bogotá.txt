foreign [Music] so this is actually not the first time I've given this talk right this is uh they I've given something like this about pretty much once every Defcon I think since uh at least Defcon 1 and the point of this talk has always been to just give a kind of big rapid fire introduction into some of the basics of how ethereum Works some of the basics of what ethereum tries to accomplish and I'm gonna just try to get it done within um I guess right now it's uh 1.8 kiloseconds or 150 slots um so what is ethereum right ethereum is a general purpose blockchain so people have seen a general purpose assess the platforms before and people have seen blockchains before and I think at this point we can all kind of intuitively understand what the value of both of those categories is right so blockchains can facilitate a large-scale consensus they can protect against censorship they can enable censorship resistance applications blockchains are always available if you build on a blockchain and then the thing that you build on that blockchain is going to be available it's not going to just get pulled under you because you know some particular company decides it would be 12 more profitable if they just change the API on you without notice it is uh you know independent of any one particular nation state it's not dependent on any particular centralized Corporation avoid dependence on centralized parties um it's the you know one neutral ground at a time when almost every other grounds that we see is uh you know picking picking sides of some kind or other and you know often for very good reasons but no blockchains are this a kind of base layer between parties that do not trust each other that you know still allows them to have positive sum interactions blockchains can allow applications that are open that are transparent where people who participate on them or can be sure that the application is going to follow the rules that they sign up for right so blockchains are great for you know things that really need stability um so there is a good reason why money is the first app um but there's other apps as well and I'm sure a lot of people behind those apps are going to be talking a lot about them at this conference general purpose platforms are powerful too right general purpose platforms are interesting because they open the door to Independence Innovation so if you have a general purpose platform then it just makes it much easier to build something on top of it because if he wants to build some specific thing instead of having to like rebuild all the infrastructure yourself you know you just add a tiny little piece right they can create powerful Network effects between different types of applications so you know you got your uniswap and then you got your like Dow that plugs into the unit Swap and then that you and then that unit swap itself gets used to trade between you know usdc tokens and maker tokens and you can create these kind of complicated chains of seven different applications that all talk to each other and sometimes they talk to each other in insanely crazy ways within one single transaction that uh you know really fun people from Paradigm go and write amazing blog posts about um but so uh general purpose platforms lower the barriers to entry they make it simpler to build they enable a lot of innovation and often general purpose platforms end up being far more useful that even the creators originally imagined so ethereum is a general purpose blockchain right and so ethereum tries to be both so this is like one of the sort of three-minute pitches of you know what ethereum could could allow you to do so what what is ethereum and how does this work so these three pictures are from a slide that I use to describe ethereum at some of the previous ethereum in uh 30 minute sessions right so you know you have like single application blockchains which are like pocket calculators then you have like multi-application blockchains that explicitly support a small number of applications I call them Swiss army knife blockchains and then you have you know the smartphone blockchain oh it's a you know it's general purpose and if you want to do something you just like download the app right so these days you know unfortunately even over in you know 2022 and uh you know talking about a general blockchain being general purpose as though that's something cool is um you know kind of like a someone selling a house describing their house by saying you know we're we're really modern we have a refrigerator who here has a refrigerator well lots of people have not raised their hands I'm impressed um I I guess that do people like order out do people eat raw food like what's the idea here I don't know I mean people have done refrigerator Free Living successfully for like you know 1900 years in the ad era alone but uh that's uh you know it's still impressive um anyway so like what does the blockchain look like right so one of the uh exciting things about doing this presentation this year is that like I actually had to change it a lot right like between a lot of the previous sub ones it's like okay you know it's ethereum here's how it works okay it's ethereum it's how it works okay it's ethereum it's how it works but in between the last Defcon and this one the way that the ethereum blockchain works just like changed very fundamentally right and the the rate of change and our ability to actually execute on and implements changes to the ethereum protocol significant changes that we have wanted to do I'm almost since the protocols are launched and that we've been talking about for almost a decade but you know finally managed to done has really been accelerating right so we had eip1559 in you know 2020 and then the beacon chain launched and now the beacon chain took over and you and uh you know ethereum is only a proof of stake system so you know lots of very big changes and you know lots of different things that we have to talk about right so like remember back in when during the proof of work era we had to talk about how like blocks include Uncle blocks right do people remember this so people remember how like sometimes people would even you know try to be gender neutral call them armor blocks instead of Uncle blocks as well and like you know I get this I you know I get the sentiment very honorable sentiment but like come on like armor just sounds like an insult for people who meditate but okay so these days you know we're proof of stake right and um the blockchain looks kind of different from what it did before right so what so let's like talk about what the blockchain looks like without reference to you know the dark old proof of work era that our grandchildren will eventually remember in the same light as how they yeah remember how houses used to not have refrigerators so you have blocks right and blocks contain transactions what is a transaction a transaction is an object sent by a user that contains information about something that they want to do right so if I want if I have like some if there's the yeah cryptocurrency inside of ethereum and I want to send you one is then that request would be packaged up inside of a transaction if let's say I have an nft and I want to send you the nft that um request is packaged up inside of a transaction if I want to publish an entirely new application then and create the smart contract for the application and that's something I'll cover later that is also packaged up inside of a transaction so a transaction is like a package of data data that contains information about stuff that somebody wants to do these transactions get included in blocks every block emails are created by by a validator and a block so blocks already just these packages of transactions and one new block comes every slot one slot is 12 seconds then we have attestations attestations confirm blocks right so attestations are like these messages signed by other validators that basically solidify the position of a block inside of the API blockchain right so when you a block gets published and then that block within a few seconds it almost immediately gets thousands of attestations supporting it and that and it solidifies that walk's position in the chain such that other blocks that compete with that block that like also try to claim that their you know that are not kind of children of that block but that are you know siblings and they try to claim that they're the real history those blocks are not not going to be able to get through right so in as Danny mentioned you know in the entire almost month that post merge ethereum has been running we've only had like 20 26 reorgs and that's maybe an over count and even those cases are cases where a block is published too late and it probably did not get many other stations right so lots of attestations in parallel solidify the position of a block in the chain block gets published block gets attested black is published block has a tested block is published block gets attested right people understand um raise your hand a few I understand okay wow it's like more people understand this than have a refrigerator this is like a basic okay so let's talk about what happens inside of a blockchain right so uh you know there's the blockchain keeps track of um information that we call State and the the state that the blockchain keeps track of is made up of accounts right and there's two types of accounts basically you can think of them for now as like accounts controlled by people and accounts controlled by robots where the robots also are also only exist inside of the chain right so an externally owned account is this is an account that represents a user right so like for example if you hold East today that ease is stored inside of your externally owned account right so there exists a record which is like an eoa that is in the blockchain that the blockchain keeps track of and that object contains the record saying you know hey this address contains this amount of eth the other kind of account is what we call a contract a contract is like a computer program that lives on chain the code of that computer program is on chain so the chain stores the code of the contract the chain stores internal storage of the contract internal storage just like memory that that contract has the ability to update and contracts are basically how all applications that that are in ethereum work right so an application is generally has an on-chain component that kind of controls the business logic of that application that generally is one or a set of contracts so what do contracts look like um so this is an example of a source code of a simple smart contract and this is by the way in a language called a Viper it's a a less well-known language it's the kind of largest alternative to solidity and so if people aesthetically prefer coding in Python syntax I mean like I personally think python is like way aesthetically Superior to anything using curly braces but I know this is a controversial topic and like half of you are going to cancel me um but um you know if uh if that's you or if you like some of uh Viper's kind of other features that like try to kind of take a very Pro or from scratch approach to being sort of more restrictive and more secure in various ways you can check it out but this is a simple you know contract for Asia domain name registry right so basically the same sort of thing that ens is trying to do right so what do we have here right so we have first like a mapping right domains mapping bytes 32 we're gonna uh and a two Asia domain right um right so the bytes 32 here is like basically you know the address like what the domain is right so the you know I'm just kind of being very lazy and very simple not introducing strings they're variable lengths or fancy stuff and you know if you want to like register George then you would just like put 26 zero bytes and you would like stick George at the end and uh you know that would be the key in the mapping and then the value in the mapping is just who is the owner and what is the IP address that the domain corresponds to right so then we have two functions the first function is set owner right so the point of this function is basically if you are the owner then you can transfer ownership to a new owner or if the domain is not yet claimed then you can call this function set it to yourself or set it to some owner and you can become the owner right so you should be able to you know if you have any programming experience just kind of read the code and understand what's going on right basically you look at what the owner of the particular domain that you're looking at right now is and if that owner is zero or if that owner is you then you can set the owner to whatever you want right so that's one function and then the other function is well if you are the owner you can set the IP so what's actually going on here right basically we have these functions and it's a piece of code how does this actually kind of translate to what's happening on a chain so this is a transaction flow example right so basically what we have here is you know you have a the contract that's the a kind of bubble on the bottom the zero x849 c41 down there right that is a an account it is a contract account and that contract account is going to have a piece of code what is that code it's the compiled version of this right so that lives on chain and then you have that contract and it also has some storage now at the top we have a transaction right so as we mentioned before transactions are like these packaged objects that represent requests to do something so in this case um you will we're going to make a request to change the basically calls on your set address right so we're going to call it with a particular domain we're going to call it with a particular new address and you're going to make a transaction where the two of the transaction right the two address is the account that you're calling right so it's going to be 0x 849 c41 down there the data is going to be the stuff that you call it with and then the signature is like cryptographic data that proves that it actually is you the owner of the sender account that actually yeah created the transaction right so the signature determines who the sender is only the sender like only the owner of the actual private key corresponding to the sender can actually create a transaction without sender so that transaction gets included in a block what happens in the evm right so it starts off with a call from the like the accounts at the top the ca291d up there right the accounts at the top which is an externally owned account that is the account owned by you right now what does that accounts do so what are the state changes that happen so first of all your balance goes down a bit to pay for the transaction fee and then a bit of balance gets transferred to the miner um or now to the blog proposer and then it makes another call and that call calls down to the contract that is the application and the data of the call encodes what you want to do and then basically it actually does like a series of storage operations that just are what's happening here right so first you do an SLO to storage load it's a base to figure out like what actually is a in the domain or in the storage for the particular domain it returns let's say a zero because nothing has happened there yet and then we s store and in this case um you know we're changing the address and it's just going to s store add a particular address that maps to where that domain is stored and it's going to store the new address there right so this is like a very simple example but look this is a bit of a view of you know what happens inside of the evm when you send a transaction yes this is something in ethereum that has not changed yet right so gas is the unit of resource consumption within ethereum right so examples of gas so a transaction costs a base 21 000 gas each computational step costs usually between 2 and 10 guests depending on how how complicated the operation is editing a storage slot costs 5000 gas or it costs 20 000 gas if the storage slot is not filled yet and so you're actually expanding the storage and every byte of data in a transaction costs 16 gas or if it's a zero byte then it only costs for gas right so gas is like this master unit that represents all of the resources that are being consumed during the execution of a transaction if you send a transaction which gets included in a block you have to pay a fee that's proportional to how much gas the transaction consumed right so whatever amount of Reason total resources and transactions consumed you have to pay an amount proportional to that right so the fee is basically the What's called the base fee plus priority fee multiplied by the gas you use so the base fee is like a fee that's adjusted by the protocol it adjusts up or down to try to keep the usage at about the same level and then the priority fee is like an extra amount that you pay the block proposer to sort of encourage them to add your transaction and in this partic generally people just set a priority of one but you know if there's a particular time where lots and lots of people are sending huge numbers of transactions and the blocks are congested you can set a higher priority for you to get in first and a maximum of 30 000 gas can be spent inside of each block right so who remembers how much gas that a basic transaction costs hint it's in the previous slide twenty one thousand okay um so thirty thousand Thirty million divided by Twenty One Thousand anyone want to guess about how much that is one refrigerator excellent answer yeah so it's uh okay right so it is uh you know going to be about about in the 1400 range right so a maximum of fourteen hundred you know roughly simple transactions can make it into each block and uh you know if they Transit but on average it's going to be 700 because like the priority fee adjusts to keep the average usage around 50 or sorry the base fee adjust to keep their usage around 15 million but um you know if the transactions get more complicated then they start consuming more gas and and uh you know you a block can include fewer of them so that's what gas is so this is what a transaction object looks like right so a transaction as we mentioned is like this Big Blob of data that represents uh you know a thing that a user wants to do that gets included on chain um and you know you can see it kind of some of the parameters of what they are so transaction type this particular transaction type is 0x02 there's also zero one and like others before it um chain ID which chain is this for are you even sending a transaction for ethereum M or four ethereum classic or for East pal who here has sent the transaction on each power No Hands raised almost okay I got a couple of hands raised okay no no don't worry you're not canceled um so okay these you know just we want to give people the ability to send a transaction on one chain instead of sending it on all the other chains you know it's not that hard right um nuts this is like an anti-replay value right so every time you send a transaction that gets included the non's also like has to go up by one each time right so this prevents a transaction that you send for being included more than once pretty simple Max priority fee and the priority fee that you're paying Max fee which is like the maximum base fee that you're willing to pay gas limit the maximum gas the transaction is allowed to consume um destination which Azure is the transaction goes to the amount how much how much each that you're sending data is uh if you're calling a contracts then the then what is the data that gets passed in the call access to list is like this fancy way to access some accounts and some storage slots kind of earlier and access them a little more cheaply and then the signature is like a cryptographic thing that verifies you know who sent the transaction okay so high level languages right so uh you know we mentioned that there's Viper um there's also solidity there's also um you know lll there's like a long list of kind of various high-level languages that you can write contracts in so when you write a a smart contract you're generally writing in this high level code there's a compiler the compiler converts the high level code to bytecode and it also outputs an API ABI stands for application binary interface it's basically the way to encode particular like requests like things that users want to do like users attempts to call particular functions in the contract into a set of bytes right so in this case like if you call you know set owner with a particular um you know this particular address actually this should be this should be set IPA but an IPM that's a bit of a mistake right then you could use the API and you can convert that into some call data right and the call data is what actually gets into the transaction right so there's this kind of logic that happens that basically converts this sort of high level human readable stuff that people want to do you know both the human readable code of the contract and kind of human readable instructions like you know I wants to send Bob 25 East because I really like him you wouldn't put the I really like him part into the contract you would like sensible love mode off chain or something but you know convert that into a kind of byte request that the evm understands um so proof of State consensus right so the thing that actually kind of keeps the whole thing safe so we talked about blocks we talked about other stations who gets to produce these blocks to data stations anyone can if they deposit 32 East and become a validator right and if you have less than 32 East then you can join the system through stake pools right so there are stake pools you know there's rocket pool there's Lido there's a bunch of other pools and you and if you have less than 32 East you could kind of become part of a validator using a stake pool as well so deposit 32 East becomes a validator and in each slot 12 seconds 1 over 32 of all validators attest to the block that was created during that slot the validators get Revenue right so why would you stake well you get rewards you get two kinds of rewards you get in protocol rewards so you get automatic rewards for creating blocks creating attestations you know doing all of the good things and you also get priority fees and Mev from transactions right so you know you get Revenue in two ways and validators can you know withdraw at any time well this will be enabled in the next hard Fork right but validators will be able to withdraw at any time with a delay um and usually that delay will be pretty short but in extreme cases like if everyone's trying not throughout the same time then there is going to be a queue and you might have to wait for some amount of time so that's proof of State consensus right basically yeah you know if you have 32 East you can deposit become a validator and all of these validators are the ones that participate in this big system of blocks and attestations that keeps the chain progressing and keeps the blocks that are being added safe um Fox choice right so the reason why we need to have like weird fancy stuff to inconsensus is because what if you have this situation where people publish two blocks and those blocks disagree with each other right so in this case you have two blocks and these blocks are um you know they're sister blocks right they have the same parent and so clearly you can't get like put both of these blocks in at the same time they might have conflicting transactions they have some of the same transactions they even might have some of the same transactions in different order right but blocks or you know what happens if you have like two blocks that create two conflicting histories you have to choose one of you have to choose one of these histories somehow right and the mechanism that does this choosing is called the fork choice right because the blockchain forked and we have to choose one one part of the fork so the mechanism that does this right now it's called lmd ghost and it's very simple it's just as a station counting basically you have Block in you have Block B and you just count the number of attestations that support block a or support its children and then you also count the number of attestations to support block e Block B or supported indirectly by supporting its children you see which side has more in this case the top side has four the bottom side has six the bottom side wins and so each use Block B right so this is one part of the yapper of second census there is also this mechanism called Casper FFG finalization right test prep of G finalization is like this extra Gadget that lives on top of this attestation game and it gives us this really extra special property that if more than two-thirds of validators are online and honest then after two epochs so one Epoch is 32 slots and or 6.4 minutes so after 12.8 minutes a block gets finalized and that block cannot be reverted right so if we take this example if we take the Block B over here after one Epoch if more than two-thirds of the Adjusters in that Epoch support B then B is Justified and if after another Epoch more than two-thirds of a tester still support B then b gets finalized right once the block is finalized it cannot be reverted but you know in practice waiting for the Casper F of G finality is like more a thing for high value use cases if you are just making a very simple application that's not doing anything super high value then generally one of what we call safe swad is enough for most applications right so if you have one slot we're doing that's what the proposer acts correctly and he gets lots of attestations then that's like generally enough to be secure Merkle tree is um who here knows uh who's um on the yep picture here um who here thinks it's records while who here thinks it's Ray dalio who here thinks it's Craig right who here thinks it's uh Satoshi um interesting so a few people think Ralph Mercola Satoshi that's fascinating okay I gave away the answer it's Ralph Merkel right so Ralph Burkle is great because he invented Merkle trees and he also invented um the Merkel Dam guard construction for hash functions um which you know actually has uh has some problems since and uh it's um you know why people want to switch to sponges lately but it was you know an amazing invention for its time and you know he uh recently also doing some interesting stuff about cryonics but you know Merkle trees are great and dojas are also great um rough workout doses are not actually connected the only connection is that I like both of them um but the um so what are Merkle trees right a Merkel tree is like this data structure that lets you create one small object that commits to a large number of objects where it becomes very easy to prove for any one of those objects that that object is inside of this entire big entire tree right so you have this one object that's called you know a header and it might be committing to like a million different things and for any one of those million things you can make a short proof that shows that that one thing actually is you know in these set of things that that's been committed to why do we care about this well ethereum blocks are big the ethereum state is even bigger right the ethereum state is like 40 gigabytes so what if you wants to prove something that happens in a block or prove something about your account and you want to prove it to someone that has these block headers that are at the top but that does not have the entire 40 gig 40 gigabytes or the entire you know really huge amount of of data in the ethereum chain well Miracle proofs come to the rescue right basically you just provide the value you provide a couple of like sister hashes going up along the tree and anyone can verify the proof by just kind of continuing the hash up the values going going up together and then seeing whether the route they get matches right so really powerful technology ethereum actually you know uses it everywhere um last fun thing Layer Two protocols right so most people or increasingly more and more people don't use ethereum directly they usually what are called Layer Two protocols that inherit security from ethereum and add higher scalability on top right so Roll-Ups I wrote an article on them they're really fun there's a bunch of them from a user's point of view living on a modern Layer Two feels like living on ethereum you know applications work the same way but because these applications don't stick everything on ethereum directly fees are many times lower so layer twos are great layer twos are how ethereum is scaling and you know we encourage everyone to pay attention and learn a lot about layer twos this year so finally you know future directions the merge done yay um okay next stop the search increasing scalability going finally going sustainably below five cents a transaction going getting us to thousands of transactions a second next up The Verge replacing Merkle trees with more efficient structures don't let ethereum knows be much lighter ethereum notes don't have to have huge amounts of data becomes much easier for anyone to run them yay The Purge clearing out all data clearing out technical debt making ethereum nodes easier to run and making an easier end protocol simpler and the Splurge grab bag of various useful stuff account abstraction evm improvements for potion Builder separation making everything amazing with ZK snarks yay ethereum is getting better and I'll have to keep rewriting this presentation for next year amazing thank you guys bye-bye [Applause] 