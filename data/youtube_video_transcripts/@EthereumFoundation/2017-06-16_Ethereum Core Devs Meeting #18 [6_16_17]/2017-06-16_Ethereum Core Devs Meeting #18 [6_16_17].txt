[Music] [Music] member [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] yes my car okay [Music] [Music] No [Music] [Music] [Music] [Music] [Music] hexam [Music] yeah haiya the talat can you hear me up you're on mute metallic on hangouts yes I can hear you Hudson perfect Robert can you hear me yes I can excellent Andre yes we can hear you I'm here with youichi and coming back you to me Jim I hello awesome alright I think we can get started so mm-hmm let's see up I'm on the wrong agenda here we go see I put a link to the agenda in the chat I also put a link to the troll box and the first item is VIP 206 the revert opcode you each you had a question about it so you each you can go ahead with that won't up sorry probably specificity for the moment that I have to remember about people's oh yeah no problem uh Jeff you had a question over the ethnicity of EC da accounts on a IP 208 for transaction and signature abstraction yeah that's correct so the the the issue here I think it's easiest to understand in the context of for example ECDSA accounts right now trying to use e NS and so basically the fact that ECDSA accounts can only do one operation at a time means that they can't do something like look up a name and then do a transaction to the address it resolves to or something like that um and obviously if we move to contract based a new a new contract for ECDSA then that would pretend really have the ability to perform multiple operations atomically and so then my question was mainly about do we expect everyone in ECDSA to move over to contract based accounts is that kind of the plan or if not do we need to to deal with the atomicity issue some other way I would so my personal preference would be that in the long term we should move everyone into into ie ipv6 contracts but realistically speaking I do think that if we're going to make the transition compulsory that's something that we should do is slowly and carefully and if it loses backwards-compatibility possibly over a fairly long duration so it's like in the long term personally I based I do feel like making every account to be contract based is better because it reduces the number of classes of things that the protocol has to has to be able to deal with but basically there is a couple of challenges so one of them is that if we wants to make some kind of compulsory transition then we might still have to keep the old adviye well actually no you it's not it's not really a problem to keep the old ugly old addressing scheme because we can just like swap the code over and in place for something that's that basically does the exact same thing I guess the main challenge would be that as you as you said in your post that it would break txw origin right and I just saw your reply about asking for a concrete use case and I have one about the issue with TX origin so right now TX origin is the only way to attribute the difference between who published a response in a state channel and who signed a response AM and since we expect there to be like third-party transaction publishing services for state channels then it's actually quite an important role and why do you want the no in protocol who published the yeah response basically so that you can on the one hand pay rewards and bounties for people who publish transactions for you well you weren't available or online and on the other side so that you can differentiate between like like a publicly claims bounty where anyone might be actually publishing the transaction and versus something that's just coming in through a forwarding contract so like right now the way that you accept sign messages from strangers this might be different post metropolis but the way that you submit the sign messages of strangers is that you need to set up a ECDSA validating forwarding contract that's a member of say the multi-sig that controls the channel no so i its TX origin is really the only way to identify who is submitting the message because you're using the forwarding contract as the validation of ownership so you're already using message center okay in okay so that case I guess there's two so with the exit origin right there's two there's two things that we could possibly do over one of them is to basically do nothing and let the opcode deprecate itself and the other is that we do this change where if TX dot Center is the null Center then we basically switch the exit origin to being the TX to account and I think I am may have mentioned that I like personally speaking I am happy with both and if we decide that there is enough value in that letting people know who the origin is then I'd be if that's what we have you taking that road so I think setting it to the to account isn't quite enough if you have like contracts which would manage multiple accounts like you know verifying some other signature scheme but you know anybody create it an accountant or contract rather well just happen the contract be able to set txl origin as it prefers but only if it's the first call in the chain to do that so you could so if you're to like if the goal that you're trying to meet is to have a different is to be able to have generic contracts for verifying specific signature algorithms then you probably do not want to have a workflow that says like no sender calls a signature of your fire signature of your fire calls the accounts you probably want no sender calls the account then the account calls a signature verifier the signature verify replies your want to be counted in the account does its thing and the rationale for that would be that on the one hand you would have one so on the one hand he it would be cleaner from a txt origin perspective and on the other hand you would also be able to use this signature of your fire for applications other than being the single signature of your fire inside for a forwarding contract so at one example is that if let's say that we have a contract in a library whose purpose is to be let's say a way import signature of your fire now let's say I wants to have an account and I want that accounts to be a two or three multi multi sigil import signatures then that's something that if we just say it should make signature of your fire just like the libraries that return zero or one that could it could be just be constructed very easily because you just like all the way important is revere fire three times whereas if you made it be if you made it follow this kind of forwarding pattern were like no sender call signature purifier calls the account so that would be harder to compose sure yeah I think that that makes sense that's speaking strictly from a flexibility perspective and I'd rather not set it up in a way that she warns us into one road implementation hmm um so so the other challenge with allowing if you actually allowed to set TX origin is that that's a security loophole right because malicious contract can set a weird TX ID origin that doesn't belong to it I mean I think you could say that like you could have a knob code that sets the txt origin value to the message sender only if ncx that origin has not yet been said but look that just seems weird and I'm not convinced the the extra complexity is worth worth it over just like a simple and first check the T extender and if not check check the TX destination so I'm sorry I didn't do it up on this exact use case for state channels but it sounded like what you it sound like it don't necessarily want to have to exit origin but more like anesthesia sender of minus 2 or something like that so two levels up in the call chain or am I wrong there at present its TX at origin that actually that you want now you don't need to go one more level in the call chain and I think even if we switch the contract accounts would be it would just be the minus one not two levels deep I mean what about what about so what I'll so what we previously also discussed about TX at origin is in the presence of callbacks may it be via some Oracle or across shard a call or something like that then TX a large net it's actually actually not the person who published something but TX at origin is just the service that did the callback would that still work for your use case uh yeah that could potentially be okay I at the you get you plan around that sharding will require some planning around that sort of thing anyways I think yeah what that beholder would that be a workaround where this the account that current list is currently is TX origin has to call into the state channel rewarding contract whatever to set their address and then it is the is identified in that way with that work as a book around um it doesn't work the way you described because the state channels don't look like state channels they just look like multi SIG's and the other random people we're publishing messages aren't members of them so they don't have any there is no place for them to call there is nothing for them to register you could set up a separate registry where they they claim it and then it's sort of I guess it would have to like atomically reset every time I don't know there could be some kind of weird workaround and it also it definitely doesn't work if you don't have a de Missa tee at like at present definitely it's impossible to do without TX dot origin but if we have atomicity I'm where you can have multiple operations inside of the same externally signed transaction then you might be able to build a workaround MMSE okay one thing that I can say about TX dot origin is that it's nice sometimes for it to be the person who's paying the gas if the of TN pro like protocols where you want to refund whoever's paying the gas and it's like we lose the property that TX de origen is the person paying the gas then that might not be that nice but for abstract the contract that's not necessarily the case anymore right if we could have how I because this called are called style contracts where some some other person pays for I guess not the the initial the TX an origin contract did you want a TX gas there is a well-defined single gas pair not necessarily lives um that could be could be wrong in the context of something like a mandatory gas price policy yeah and it could also be a broadly in the context of weird stuff where one guy pays for gas a lot in New York when and the other guy compensates him and Lexie for Doge yeah so that's actually kind of why I want there to be a TX dot gas payer I think ooh I'm getting the kind of sample maybe there's better abstraction for what you guys want a need that it's not take for the wording but it's something which is better suited for those purposes but less likely it's been abused like a closed organ for authority so the situation I'm describing isn't using TX at origin for authority it's just using it for identifying who the original I like who kicked off the chain of events basically ya know paying for gas is the the first good use case like there's also text origins uh neck didn't you do some just basic scanning of the network to see who's using TX origin or as was that for something else that was something else that was me trying to scan for things that tried to read fast the end of call data that's right okay never mind them it would be a useful thing to do this and it would actually be a lot simpler the the called out thing okay so there's a number of issues on the IP 208 so what we can do is it sounds like we've actually have found a use case for it in this in that case so if you could maybe actually I don't know what it'd be worth it for Nick to run something like that to see just how in use it is I guess that could help determine if a different abstraction should be created and transaction origin than deprecated as long as it's not in wide use informally I'm fairly sure nobody's using it much to pay for gas because the issue is that the caller connects can brief you by seeing a very high gas price but I agree to gathering data is probably a good idea and I have been meaning to build some better stat stuff for a while but I am kind of absurdly busy and I'm not sure that the Tel Aviv area if I took time to off to a garbage collection that logically stats on T X origin yeah I mean it's just yeah whatever the priorities are so yeah okay cool so I think that hmm anyone else have comments on that so go ahead yeah I just have a question about gas price and account abstraction mm-hm is it going to be possible to have different gas prices on different legs of the execution of a new transaction so it's theoretically possible for accounts to pay the miner whatever amount they want if the miner is willing to accept it so like you could potentially have an accounts that has some weird policy where charges where it pays like 20 she and infer gas in the other column intention for everything in the inter call but I expects that miners wouldn't would prefer to just accept transactions with uniform gas policy is basically because their incentives are primarily structured by the uniform gas limit and obvious with a uniform uncle risk or the yeah I got a largely inform uncle risk what is it the gas price interactions anymore except for kind of roll sale transactions ya know so like a P 86 transactions have a gas price but it's basically this digital or always the the gas price that the protocol is aware of is basically the schedule Christian's you have a comment yeah so I mean I was just thinking about what others there might be a way might be a solution where we delay the solution in some way like for example throw when someone uses T X origin inside a transaction that is initiated from from a new start transaction something like that yeah hmm yeah I mean yeah so like the thing that we could potentially do is we could or potentially the other thing we could do is just like do nothing to TX out origin right now and then just like explicitly say you know we are going to we are probably going to change the exit origin behavior in the future and then whenever we end up doing the next hard work that starts making yet or whatever hard work starts making transitions the AP 86 accounts compulsory that's the one where roll figure out what's to do with the exit origin more properly when if they do nothing you mean it becomes a null sender right yes I personally in favor of doing that learning takes or can be in the null center and then at some point in the future and address exhibition with the gypsy's case here and that might be an T X dot yes right gasp√© or whatever you know at the moment that business seem like we have any kind of infrastructure to tell really who's paying gas in some way if the abstraction will use less miners kind of arbitrarily decide to take conversation well to be Theo there's no such thing as an abstraction layer that doesn't like miners arbitrarily take compensation yeah I mean you can you can like make them take at least some amount you know this boy yes but that's like totally totally different from not making them take compensation like you're you're conflating taxes and maximum wages so one issue with that proposal of just like leaving take Sargent to be the null sender during the intervening period and then worry about it later is that if for the the state child's use case I was mentioning that would actually leave a dead zone where we if we didn't have like standards around atomicity for ECDSA transactions kind of in widespread use until we switched TX at origin then in that intervening period there would actually be no way to do the use case in state channels well no there would still be the use already to see so if there would still be the current way of doing things but I guess you would not get the benefit of like metropolis style atomicity + TX that origin gas payments although the one thing that I can say though is that you could create stuck inside a VIP 86 you could create structures where some contract that's deeper down the call chain pays for the guests or directly instead of like compensating the TX origin so for the state shell is use we're not trying to compensate for gas um so it doesn't really that one but all registers well but on your trying to still you're trying to accommodate the guy who's including these yeah hmm so great I'm kinda trying to Sophia's attribution right even to do attribution to whoever he had a broadcasting transaction one wait to get that attribution would be just a data encoded signature of the prism publishing it can yeah it has an issue that the miner can say oh cool I could make some money a month which is out the transaction but these yeah that's also adjust another point is that if you are going to rely on the origin for like creating a bribe that goes beyond covering gas payments then that's a mechanism that's going to trivially front-runner ball by minors because they can just like see what transactions they're collecting bounties and then replace them with transactions coming from themselves God that stuff that's that's definitely true in this in this case as well it like that's definitely a feature not a bug of anyone can pay scenarios I you don't if if the miners are actively trying to front run these it's better for the user because it just means that they're getting in even faster it's even higher level of guarantees there's no disadvantage to the user and outside of the anyone can pay situation or the anyone can publish situation where you're contracting with someone specific then if somebody else who isn't on the list submits it they're not getting anything anyways and there's no front running resident okay hmm okay but then you can assume or do a signature I'm sorry I you're cutting out a little bit adding didn't quite catch that also I'm far away from the mic I said for the attribution of who publishes state you can just use a signature that you attach to the transaction as data um I I think that makes sense but I'm not sure I quite understand like are you talking inside of a new contract style transaction or inside of an existing you a transaction so if you the transaction that publishes the state they're you include whatever the state channel state is that you want to send in plus you sign that you are the person via account actually that's the publishing right so that takes us back to the atomicity issue which that you can't do two operations from an EA but okay so I think in the interest of time would this be something we could flesh out on the EIP itself and then also just bring up with the with the newer information next meeting sure yeah cool yeah and I think that yeah this opens up a lot of new things we hadn't really thought about before transaction origin because I know we've been talking about it for a while and Fabien is not in here but he had also been a proponent for keeping transaction origin so I'm sure he's going to want some to participate in some of the feedback in there so back to the agenda if everyone could just refresh the page I added and took off some agenda items cuz Sophie I like that the agenda item from Sophie is gone and I added Martin's so the next item actually are it's a list of three concerns from Martin hull Sunday on e IP 208 so saying the IP we were just talking about I'm not sure if any of these were touched in the conversation but I'll let Martin take it away yeah so now we haven't first part yeah basically the thing is that with metropolis is going to be possible think of the exact same transaction multiple times within a block and I'm a bit curious about potential side effects that that can have side effects on the clients and if that's something that we need to discuss and think about can you give an example of a side effect so one side effect is that we have the RPC interfaces which needs to change potentially to to return multiple transactions another potential side effect depends on how transactions are stored internally within clients and if there are data structures where which assume that one transaction hash equals exactly one execution and one receipt then we can be internally inconsistent state stuff like that and we have other RPC methods where you send in a transaction hash and you get one thing back we need to modify the perhaps the parameter set for that so that the face not on the hash but also a hash block cache and the index so just a quick comment here unless because of that there's some kind of intrinsic gigantic problem this is not relevant for the heart frog itself because the feature won't be active right what I mean the pigeon won't back we won't activate such transactions at the heart for only later I'm not sure follow they won't be active so the road so there is the possibility that a malicious miner will in or we'll just say a miner who is not cooperating with urban and default software will include five copies of the same transaction right so yeah so what we enacted what we can so like that that is a good arguments for why we don't need to care about the interfaces for accessing multiple copies of a transaction to be it to be too convenient because like yeah if worse comes to worse the only initial use cases for those will be transactions that are submitted by like basically extremely irregular users and we can tell them to go build their own systems but it is at the points where like what the client does this should not break if two transactions of the same hash get into the blockchain can we know consider whether they're straightforward changes we can make to restore the intriguing invariant the transaction hashes unique like the being challenged there is basically that like that would first of all blowed the stake well so in the current case it would basically create like on one ending State float and I mean we could have transaction deadlines but then that would still have a substantial state board and that would still require an in-state garbage collection mechanism I never depend on on how he did it I mean the simplest way we could just be to reinstate not opsins as the one required part of a transaction and there is the signature verification is up to you you another would be for instance to to have a more generalized non scheme with where transactions are expected to apply some transformation no I don't mean I'd see in the long term there are legitimate what so they're in the long term there are legitimate uses for EM universe of all making meeting in to be flaky brutalized and I would say even just accepting the same hunk of data multiple times so the key one that I'm said well or one of the key ones that I'm thinking about for example is like if you have some particular thing that needs to get poked and then the transaction that pokes it should really just be like a really minimal thing that has like no signature and nothing else and because so it's and it could just like say poke the etherium alarm clock in and if you're more important its thing and I would say that it would be added complexity for that sort of thing to have to require dances and figure out where it's consoles are coming from mmm I don't I'd also say that there are there are going to be benefits from eventually moving the protocol to this regime where as long as transactions are correctly formatted they are valid no matter what basically because it lets us do like weird stuff like agreeing on blocks and agreeing on state routes out of order yeah I mean I agree nonces are suboptimal even under the current scheme but there are times when you want your transactions be ordered that there are other times when you really don't yeah but I just mmm I know I worry that this may be a more useful and more pervasive and very unfriendly saying or than it's a really obvious meaning we have blanks and instead of transactions on one sorry so like in general we definitely should be moving toward relying on words for things yes but I I think that I mean transactions are still a fundamental components and systems we can air and where do we stand on transaction queuing because I remember one of the previous issues was that with the system you can no longer rely on two transactions you submit being execution the same order because the miner could choose to execute second one last and then all your code can do is reject it in which case it never gets executed well hold on so if you have each one thing that you can do right is if you're specifically talking about like regular users then regular users are going to be using a white listed account and the white lights that account is going to have an on scheme and so if miners include one out of order then when you process the blocks you'll be able to tell that the transaction hit an error and so we can just ignore it right but the the issue is that you can't queue up say five transactions because the miner can't wait is to equal because if it does choose to no fusion or this sort of thing the point is that the miner can totally choose to include the second one but then the second one or turn in air and so you can just go ahead and refer the second one right or you can go ahead and one second the mine I can just keep including your transactions out of order and chose you for years but I do if I don't have the gas now what the points the the point that I'm making is that including each transaction out of order is exactly equivalent to a know of except except for wasting gas right and so like that issue but I'm saying that that's bad because if to know up in then you can force me to waste gas arbitrarily so a minor it's good miners can already waste gas arbitrarily they've always had that freedom my guess miners now miners can waste their own gas arbitrarily right so remember that when you when your transaction gets in so remember the mechanism that pays for gas is not something like automatically deduct from your balance right the mechanism that pays for gas for the ae86 transaction is itself EVM code that since that that has to run so if your transaction gets into out of order then it gets included and then it river it hits an error it reverts which means everything reverse including the gas payment okay fair enough but then I still I'm still in a position where I can't reliably queue stuff up or if I'd if I want my I have to remain online and active in order to respond like I'm I'm still feeling to see why the ability to include know what transactions and makes any difference whatsoever well so previously I could chew up five transactions that I could be sure that either they will eventually make it into the chain or nothing else to them will but now whoa hold on so you could still so replace the word make it wasn't with the phrase make it into the chain with the phrase make it into the chain and have an effect yes because that's what you'll do that's what you'll ultimately care about right yeah I know that but if but if okay so to put it this way I can I can currently I can broadcast transactions I mean they'll offline and not care I think you'll be able to do the same thing but I are slightly talking past each other I don't know if you both realize it but I've added one bet yeah I Nick what vitalik is saying is that um that minor including that that no op out of order transaction has no effect on other minors just including it later to get actual gas so it is effect is effectively as if it was not included okay in that case the other question is how do we know when to discard transactions from the finger at all you know when each so you discard a transaction with nonce n when either the a transaction with nonce and or bonds or nonce higher than n gets included and successfully execute right so then transaction call implementation they still needs to care about bounces yeah well it still needs to cure yet what it needs to cure like in protocol nan says yeah or sorry not in protocol and I care about like these and in account nuances that are managed by account code yes which may be very firmly counted answer but initially at least we won't have any way to we won't have any sane way to propagate nom noms transactions then we might try to execute them in a whole bunch of different orders and kind of give up because they can't find announces no they're not happy yeah so like if you have some Apple right now with in the kind of earliest version if you have some application that relies on things other than nonsense you'll have to like go make a private agreement with the money boil up fully we've chosen the mother I'm better I mean we could with the revert opcode we have different ways to flag errors right so the the nonce checking algorithm might signal to the minor don't do not yet include this transaction or yeah okay this transaction cannot be included anymore in any future yeah this is something I suggested in the past I think would be very good if there's some way for a transaction to communicate with a limited guess what its statuses in terms of inclusion like whether it wants to be kept yeah I'd I'd support making that bi default a part of the default account but do you want to have a gas sender what do you need a gas sender like some account that the protocol knows to kind of like check the check their balance to make sure that they have enough yeah I set a particular gas price they like execute the transaction I mean like that's all part that's all part of the default account code right yeah but you can be in the default you know oops actually we can do what you can deviate in the default substantially and do something something or clear you can totally implement something but if we a little weird but then like miners will not accept it because it's not part would be a lot part of the light West or like it doesn't match the yeah filter there's the miners will get to decide to filter it's not like part of the red zone yes but if miner is the side of filter that's completely crazy that that's their own fault and they'll and they're the ones that lose money for it like minor B minor B is the F minor B uses our recommended filter then they should not be negatively affected by minor a using active will increase assaulter so Martin um I think that I'm trying to keep up but I believe that this that this discussion was over agenda item 1.3.1 I guess did you want to bring up the other points or conclude that point potentially now we can come to the three points I just want to get a discussion about politics of science no no I think it's definitely something that's really worth discussing all right cool so we can bring this back to the EIP yeah martin if you could like kind of summarize this and an EIP comment and then the others can kind of look there and comment further on it after you know based on the discussions from this call as well yeah thank you okay so the next agenda item is a dot for so II I P 2:11 returned at a copy and returned data size is that one good to go like I can merge the pr potentially or were there any changes I think this is Christian's um and looks like Ichi has reviewed it does anyone have any comments on that Christian especially on if it's done I forget did we agree on if like if you ask for data that goes beyond the return data boundaries did we agree that zeros are you agree oh that's a throw we agreed that we look real quick Oh throwing approach rather than filling with zeros I put a comment in the EEP that we decided that on the back end of June okay um and that sounds good cool crescendo are also I'm just I'm sorry just another clarification is that the returned data gets triggered by or gets reset by a call call code delegate call or step or static call but not a create correct because greats have never turned data I think we decided that it's reset on every time and your stack frame is created okay so on a creator gets reset to know or if yes on create instructions it gets visited because put instructions sometimes returns data when it fails right I see it also knows what that hold on like a create instruction though all I see it so right now though the output like the output of a create doesn't really go anywhere right like it just it's a the comment in the AP which says create and create tool are considered to return the empty buffer in the success case and the failure data in the failure case okay that sounds good okay great and I'm going to put a note in that AIP to clarify that after I take notes after the meeting Christian would you consider this done I can merge it and stuff I think you can reverse yes sweet okay if there's no other comments on that item 1.5 so there was a comment on AIP 213 which involves the ZK snark verification primitives there was a comment about Oh actually not even comment basically the thing left to do is to decide on gas cost so I just wanted to bring that up because it's been about you know good 20 25 days that people have been saying we decide on gas cost so what is the general process for deciding on gas cost or should that just be recommended by a client and another people comment um I would so personally I want to wait until we get the so I actually can we just like organize the gas per second values for parity C++ Jeff and Python in just one place and see what they're like on all four of them I'm especially interested in gas because we we I don't think we've seen that yet questions also do we want to make benchmarks on exactly the same machine for all implementations we can I think maybe Casey or Martin would know this do we have a testing system set up where we can spin up nodes from different clients to be able to run something like this on the same type of machine with the same specs yeah I mean we have but I think what what we commonly done is for these measurements I think what the has been done is doing it running it on a laptop I think it would be I mean it obviously makes sense runs on the same laptop there's some measurements but I don't know what about the standard laptop would be we do have now I mean we can run the the even binaries for parity and get isolated without the rest of the blockchain stuff and there's some measurements on that I don't know if that would be enough or if we want do it a bit more reproducible Arkadiy or Robert what what is the parity team done in regards to this or have y'all done gas estimation to parity through a process ever yeah it's some benchmark for easy parents but not for addition and multiplication I've posted the results earlier I can probably run the same kind of benchmark for a digital number okay so I don't you check on the same hardware so I don't think we care much about benchmarks for the Edition because we excite like I personally expect that the gas cost for that opcode will be dominated by the gas cost for the for the call-off code anyway but for multiplication and pairings that penalize hadi can you share the this cases you use the for Intermountain and yeah awesome bit later I think it would be good if the benchmarking would be coordinate by a single person okay I don't think anyone has time right now but who wants to take that up yeah if no one does we'll draw a name or how to a hat or do something creative Martin couldn't you add the block test to hide the basically just a full block that simply done with these codes and then just run it against the different clients yeah I'm not sure how how stable that platform is with regards to know okay so image real estate doctor okay okay just saying that hive does have support for some form of benchmarking so maybe who don't work but maybe no yeah I mean - Bobby dude but I'm not sure if the I don't know how of the aja systems are on there for the same stuff every time around but I really I don't mean run it on agent I meant just but it our local yeah we don't actually make the same person or machine to benchmark everything do we we can just benchmark against unknowing baseline like ECDSA 6g validation so hardware it has nothing to do with it neck like that won't affect stuff well if we determine that it's like twice as fast as our slowest operation and we should price us at you know on average across the implementations or in worst case cross implementations and we should price at us you know half our waste operation but there might be variations in the in the baseline itself across the implementations so much nothing great but the implementations already have to be fast enough to keep up with the blockchain and we presumably effects that in when we price the guess and to the existing operations I think we can we can organize for all implementations to offer an isolated virtual machine binary to run don't we yeah I think I think that's doable um organizing and I should say so on the git er chat let's talk about doing that brainstorm a little bit more but yeah it sounds like that would need to be done for actually any of the up code related EEP changes am I am I correct or there's some that are just kind of a given or like we know already so most of the others are just variations of existing up code so nothing has to be determined there okay so yeah let's either do a thing add a one else have comments it was a discussion about benchmarking yeah you hope cause I want to say that we could easily add the more tests for that laying the blocks in test form it could make a transaction that would call a single op code so many times that gasps longest link to the mouse like it that accepts a 250 million Gosling it is okay and the Salukis man follows that grass to call so many paths there in specific or code and see how it consumes the resources on every client still hype okay um Dmitry would you be okay leading that or at minimum getting kind of a chat together organized or using the all core dev chat to to get support from the other clients and get that together it sounds like this actually could fall into the to the testing wheelhouse this test would be able to walk on hive so you don't need any specific support from other clients you could use right okay yeah regarding up emoji that's high then you would add also the we added the add authority because stuff if she means that such as just estimate crush on sink on high then clients required to implement a general status of blockchain just at least and since I could run this blockchain test survey testing - or we could just see the script in - complimented locally and run blocking put roses on their own environments or we're going to the birth of product is it is I think why you want to put to bid to do it in hive and another approach would be to run as ruler EVM code just going to give in binary and then we can see if two measurements match that with each other hmm I think and we could add this issue to our documentation process so to help us developers and benchmarking tests with their own environment yeah uncle that's a that's a good point there actually I sent out a call on reddit a few weeks ago to get people to help with metropolis testing and we had literally over 85 or 90 individual emails from people asking the help test and I've also been getting some known community members who are wanting to help test so we've written up some preliminary rough documentation and have a lot more resources written up on lll and some of the stack and like EVM and assembly requirements to be able to do that so we're going to release that today I mean mailing all 95 people back and then 85 people back and then posting to read it again so maybe we can set up like a spreadsheet for people who are testing on their own consumer hardware to put in what they're doing I'd a lot of people probably wouldn't have the knowledge and time to do that but in combination with you know us doing it ourselves I think that'd be a good benchmark so yeah okay so it sounds like we'll talk more about this in the all core dev Channel I was there any other comments on that all right cool so item number six is going to be AI P 214 static Hall metallic made a comment on various potential errors within that and the static call AI P so you can go ahead of italic yeah like neither of these seem very controversial but basically there's like the S store bytes opcode referenced in there and that opcode was one that I proposed about a year ago but I've since withdrawn a proposal and it doesn't exist and that output doesn't exist so is so that shouldn't be in there and also there's a sentence that says they only they also include call and delegate call with a non-zero value but there's no such thing as the delegate call with a nonzero value because they'll get called doesn't have a value as an argument so those are two just like purely stylistic elements and then a third one is that says something about these yet the value it's it says its value as always copy the sub calls or sub creates and they are what's like there's no such thing as a sub create of a static call because a create inside a static call always fails so I can no substantive changes but just like three things they are in there that should be changed in the text because they're they refer to things that could that are not possible okay I think the the second item what is it so sorry so that the the first delegate call is meant to be a call code I guess so also include call and call code with a non-zero value red sound better hold on but then the next sentence is as an exception call code is not considered state changing even with a non-zero value okay I'll take a look at the full context and modified according hope so does that finish up that item Vitalik yeah okay great so item B updates to testing I just kind of explained some of the documentation and other updates from Oh some of the stuff I've written up Dimitri and yo Ichi and like Martin anybody else is doing testing do you want to kind of give your update on where we're at with that and some of the improvements this is yuuichi I joined this testing airport like a month ago and I'm new to the whole process so I met many issues so I'm adding I'm trying to out the documentation to this test test home and that produces educational sources this documentation is in a date stage of review and I'm also changing tested so that it causes errors when people make spelling mistakes in the command because I wasted lots of times not noticing I made the spelling mistakes and so on so I'm kind of doing a guinea pig to this process the trying to fix robots okay and from my partner we created an docker image of the tested so and you contributors for this would just use a docker image and not both of these building from the so building CDI intent is for the dtmc compiler for test generation and then you know we maintain a documentation how to use the tester and eat when it's inside the docker container so this doesn't one of you guys you reach into a tree and have any kind of estimate about how much test coverage the topless test coverage we have at the moment I could try does it I guess 55% all right good all right um and I just posted in the hangouts chat and I'm also posting in the getter chat the documentation summary so anybody who's interested in helping test or if you know anybody who'd be interested in kind of getting more familiar with the internals of etherium and what we're doing with Metro um go ahead and pass them this I'm gonna also post this to reddit right after we get done with this call so let's see where's the agenda pull as anybody else have updates to testing okay great so the details and implementations of the e IPS let's do updates from the client team on the agenda I put links to the pull request that kind of compiled or tracked what a IPS are being implemented per client so we can start with death Peter do you have updates or anybody else from the get the team sure so we had a discussion yesterday about it and with Jeff he said that most of the IPS are done if you open a PR you I just updated the list the description so that there's a whole rundown in theory all the up code almost most of the IPS I've done one of the EIP that Jeff missed that I'm going to try to add on Monday z IP 96 the block cache stuff so that one is not done and Jeff is still miss tweaking the EIP 86 with regarding the creative opcode apart from this I think Felix is a Felix wants to revamp our internal tests so that you can properly test the metropolis changes on our CIS and let's see where where that leads us so in theory it's mostly done just the final tweaks are going in practice we'll see absolutists alright excellent but that's great parity Arkadiy or Robert well yeah we've completed our presentation while ago I need some smaller changes for whatever it was discussed in past weeks and you know we're also waiting on the test Mosca also for mod exp there's new gas cost calculations but it seems in the discussion that maybe there will be even more updates to that so we haven't quite got that ready yet ok great that'll be useful when we're doing the comparisons across clients so that's that's good news ok great um CPP aetherium I think I have yeah there's a PR that kind of lists some of the progress so is pawel here or a Christian you can speak on it I think andreas and knows more about it oh yeah a drive yeah during last two weeks we merged the clock cache implementation and also look to cover compiled and also made a couple of minor fixes like throw on return data copy access and out of bounds and changing the molex go gas cost so what's left is great to up code support and also it's almost ready I think yeah that's it ok great um pull update um so on the yellow paper yuuichi ah it's finished but now the focus is known how to get the spurious dormancy oh okay great okay and then PI theorem or PI a p-- I saw Jan was in here but I think he had to drop off so the talaq d do you are you yeah the update um let me see and while the Telex looking at are there other clients and this chap that i missed on the list I think I got everybody who regularly attends meetings and then also while he's looking that up is it does anyone have an update on ethereum J and Romans team they haven't been in a meeting in a while and I believe that pretty much all of their projects are stagnant right now does anyone had contact with Roman or his team in the last of two to four weeks I am getting the feeling that they might not have enough resources to do all of this stuff especially since there are a lot of though projects haven't gone far yeah I mean there was a post from gab that said that Roman was taking a break but didn't give much details besides that and they've been dead silent on their slack for about a month so um I might try to reach out but otherwise I think we should consider Java aetherium client not to be up to date along with Ruby and a few others cool so you have italic whenever you find that update or if you want just post it later in the comments that's fine too roto which update was this video just how far pioneer iam is or I thought right here oh right right I was trying to look this up but I look beat the problem is that there isn't like one nice set commit that I can point to the so so what have you know we do have is that I just list stuff that I know is implemented which is all of the pre compiles static call I'm uh pervert I believe return to our return data so possibly not with the guy change that makes it I'm out of balance stuff a return mirror then I'm a PA t6 definitely but ninety six not yet ninety and ninety eight not yet a bit like all the ones that don't have to with transactions I'm waiting until we have until we have like watching tests for them and revert off code yessss and a later stuff yes okay great um and are you primary on that or is it Jan or who's who's kind of doing on the path I've been I've been primary on EIP is okay great just so I'm aware perfect so the next thing on the list because there were no other clients in the chat review time estimates for testing and release the last time estimate we had was between August and September for testing and release period is that does anyone have a comment on that if it should be changed in any way okay great yeah sounds like from the testing update that we have and the potential that we might get an influx of testers who can accelerate that we might know more next meeting so any other comments on that um yeah I'm excited to see these contributors um I think some uncertainties how it goes maybe the overhead of answering questions and so on will all go away in the first one or two weeks but after that I guess we can get to the stage where these additional people will make the process faster yeah I agree and I think that we can kind of guide some of the people to also update some of the testing documentation as they're going along to not have to go through the whole getter channel every time someone has a question so yeah that'll that'll help that a lot I think that was the last official agenda item does anyone have any other things they want to bring up it can be non agenda or never okay well the skipped first agenda item I remembered what it wants oh that's right okay khe it so the e one sentence is missing from deep and I will work with that xb um to fix that the missing sentence would say the B word instruction returns data which could be available in the same way as return the data returned from the return instruction or something like that that one sentence is missing from that specification section of this EEP um I can work with that xB is obvious okay great perfect um so okay cool that I think that covers everything after that's changed we can look it over but yeah it didn't look like a big change like you mentioned um cool any other topics or items or anything I done I kind of like be caught up on you know any conversations that anyone's had eight point three six cool uh which one was that again you look it's dark funds one that's right yeah so um that was brought up by who was it so um I'm having to find it real quick but basically I talked to some exchanges fairly recently there was a group on skype who got together it was actually more than exchanges exchanges and then other interested parties in the EEP and they basically asked me so if we want to get this done how do we get it done and I gave him the whole process which was you know get community support do a and a shoe on the eats than a formal EEP and then kind of see which developers are interested in implementing etc and I think that the conclusion they came to at this point what I feel like and they can kind of answer for themselves in the EEP was that they they don't want to put in an e for that right now because it would be controversial and it would kind of seem like a whole nother thing especially coming to metropolis the other thing is at the point where we pretty much locked down the EIP s it would be too much time to test and also to figure out a Democrat or an eye even Democrats that a process for determining which stuck funds get out Vitalik I know you wrote the EIP do you have an updated summary of your thoughts on the EIP with the recent quadriga CX hack and stuff like that or not yeah so the other thing that right so basically the challenge is that with with quadriga you know said basically that the API key 156 works well when you have an entire class of situations where like you can very clearly identify that first of all you have an you have an account where money is not accessible in second where you can identify who like a party that that money should reasonably belong to right so at one very natural cases if money goes into an empty contract then you can have probably said sending the money to a creator is like not that bad a thing to do the the challenge with the quadriga case is basically that the money is stuck inside of a guest splitter contract and the gas motor cut like with the splitter contract it's much harder to do like you get we can mathematically reason and show that that money is stuck because like any transaction coming in will have the same else coming out but it's like a much harder to turn that into a kind of principled rule that would make sense that stick into into the protocol and it would um the and the other thing is obviously identifying like basically approval to refunds but where that money came from inside of the state so that we know who them or whom to refund so so like in general I would really rather avoid making contorted rules that only apply to one specific case because I feel like those kinds of like those kinds of things and in general accepts said that precedents that should be had and should be done only only in the most extreme situations yeah whereas something where like you could if you can come up with some some specific class of users we're like serious people we're a case for like a few thousand people lost lost money and it was all done the same way and we have this kind of very clear and unambiguous way of determining who a reasonable owner is then it makes a quite a bit more doing something like Yeti 156 to recover the funds is quite a bit more reasonable and that would be the case of something like the implementation error in aetherium Jas util that cause yes some lost funds who is that could that be entirely like technically proven that they were lost because of that yes okay hmm so yes so that's you might notice in specification version two I have a function to clear lowercase hex address and like it does that okay and it sounds like the people who are the most vocal about this and I mean it's not a huge amount of people but the ones who are the most vocal do not fall in that category of something that can be easily checked like well v2 so there are like basically three V at least I know of a few major categories of losses right so one of them is some empty contracts we are either like somewhat one case I could imagine is a guy sensor someone sends money to an account or well we'll just say either to an account and that is they think that that account has code in it but actually it doesn't and a contracts creation failed and now they have like no way of getting that in getting B third back so that's something that we cook that we could fairly is a lake at recover and in other cases where people send ether to an address on the ETH chain where that has that only has a contract on the e.t.c chain so that's also recoverable the same way then the JavaScript bug is also easily recoverable that's the second case the third case is people accidentally sending money either the junk addresses or its address as where they accidentally either on either a zero address or addresses where they accidentally lopped off I missed a couple of characters at the end so the zero address is kind of hard to recover from but if it's a few characters at the ends and that's easy to recover from because you could basically just declare an address which is some some low power of 16 multiplied by an existing m in existing address and then there's a weird very special cases and a quadriga the quality recapping unfortunately it's a closed more like a weird special taste I see okay Vlad what were your thoughts on that or was that the update you wanted yeah I mean that sounds that sounds pretty reasonable I mean I totally get it um yeah cool okay anybody else have any other off-topic or non agenda items to bring up so I still have something um please interrupt me if that was already discussed last week but so am I correct in that after metropolis it will change the way addresses are calculated yes they do yeah and it's the community appropriately aware of that I mean there are some techniques where you where you send ether to some address and then have a transaction it's not yet published which will later create a contract at the address and the ain't these things will take laughter right yeah so the community should definitely be made very aware of that and so I mean one nice thing is that if we do commit to 156 then like anyone who isn't or joeys the first part of 156 then people who aren't aware well basically just like automatically fall into that first class where they send either to an empty contract um if we end up deciding that it's too risky then we could always like fully do some we you some weird bit flipping thing where we sew like one example would be that we could that of a way of making this change totally safe as we make it apply only to VIP eighty-six transactions so actually now that would be a weird because yeah no that's yeah it's fine yeah so we make it all yet so if we cared about making this change like completely safe no risk then we make it only apply to transactions where the sender is the null sender and with that then we also have to I mean it also plans to create up code right um right no no it doesn't apply to the create output it will remember that's why we've created the create to up code oh yeah right right hmm no okay so the concern is the community not realizing the breaking change or I would be would it be considered a breaking change from the point of view of most app developers um you know it's so like I mean risk that I see is that um like well actually I mean I don't think there are many users that rely on creating contracts and or create ascending to addresses that are not going to exist right here the main product if you told me that guy X you know or someone lost money because of this then I would bet that there's like more than 80% chance that it's because of this in combination with another bug that they had so like an example would be lets say someone accidentally sends ether to a contract in or to an account and that account is exists on the et Cie chain but not on the eth chain and then if we had not done this then they would have the ability to recover by making the exact same contract on mediation but because we did it the address key would have changed and they don't have that ability anymore so there are going to be cases where like this change would increase the risk of someone losing money in combination with Mickey Mickey another kind of mistake but those are mistakes that have a solarz probability of causing them to lose money in a regardless of what we do yeah I think we see something the just before metropolis if you are planning to create contracts that certain addresses may be a quiz you cannot do that so yeah before the middle for these kids yes like B yeah so basically like I see two routes here right one of them is like slightly slightly higher risk which is that we are just like be allowed it but right now about the fact that this is that this change is happening and the slightly lower risk thing is we basically just make the change only apply to AIP eighty-six transactions and like honestly I'd even I'd be here I totally qual with making it making the yeah we can only apply to yeah eighty-six transactions so it basically only make only making the the judge they change to the weather contract I just created a if the sender is the null sender um but I'm fine both ways okay metallic could you do a summary of that a quick comment on the EIP to bring up the possibility that that can happen and I think that that can be easily decided on the eat and then on the on 1:56 and I'll then I'll go back to Christian where I don't think that can go in during metropolis I think it was determined last meeting that then it's basically we don't have the time and the testing and all that other stuff but if it were to go in the future would it be a higher level of difficulty to do specification one or two of e IP 156 in future hard fork so it'll be the same level um you mean like is it harder to do what in serenity versus doing it in metropolis correct my expects not okay was thinking the same thing the I mean for specification for the ones like that are more special cases that we would have to come up with a system for and we're kind of leaning toward not doing in the first place that would be harder over time just because of the community growing and getting consensus over things but yeah for the other two because they're technically I think this can be brought up in later meetings for hard works Christian did your comment get fully answered yes okay so I mean perhaps I should also just directly reach out to the community can ask whether someone is using that and that they are will question asked whether they are aware of that change and from from the response coach whether we yeah how we we specify the creation okay great I can and the next week send out kind of a post across all social media channels and get our channels um anything I'm kind of in but beyond that I think that's pretty much all we can do and so I might even stick into reddit if the other mods agree all right cool I think we're wrapping up everybody change your passwords and make sure that you have to FA enabled that is not SMS that's on Google Authenticator because we had two mods of Reddit this morning their passwords were compromised and someone either was sending fake messages or went on and I think they changed like some stuff on reddit so go ahead and change everything and or all your passwords I should say cycle through them cool all right I think we're good here thanks everybody and we'll see you in two weeks - to load my own see [Music] [Music] you 