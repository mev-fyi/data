next person up is John he is going to speak on a cerium on Ruby welcome Jan thank you so thank you for coming to this talk and it's time for some simple stuff I think I believe the organizer arranged me after blood for some reason so yeah okay in in the next in the next 15 minutes I will introduce you to his sermon Ruby which is the intersection of his serum community and Ruby community before that a little bit about myself my name is Shahenshah and I'm a serum developer I in last year I created the Ruby certain project which is a full implementation of cerium in Ruby and I'm also working on pi serum and I'm running a blockchain technology startup named tape and we we are building underlying permission ledger and we also providing some consultancies to our customers and during our daily job we build some tools to help me develop taps okay so a little bit about Ruby Ruby is a language created by a japanese named Yukihiro Matsumoto whose nickname is Matz and the core principle of Ruby language I think you can get from this guy's face right that's happiness so Ruby is a language designed for human it it's very focused on readability so in one of his talk in one of math talk the presentation title is optimized for programmer happiness so if you make a spectrum of languages in the one side maybe maybe west right the ASM and in in the other side is Ruby I believe so it's all optimized for human and the source code written in rubies will read very naturally and we will see that later and the other good point of Ruby's flexibility so a lot of people is using Ruby to define her no DSL the main specific language so that the most famous one is rels right so real see is DSL for web development and I believe we can also use Ruby to define some DSL for smart culture so we created thethe testing and deployment framework for smart contract after you install tests you can open your console and type some command line like this like test new big thing big things the name of your next big project okay and this command will generate you a lot of files and directories an amount of directories the most important one are contracts and tests contracts will include the generated country template and test will include will have to generate a test template and then you can do tests generate token tokens the name of your smart contract so you can name it whatever but we use token for example and here's the here's the generated file in the on your left side you can see there's a solidity contract is empty and on your right hand is the generated test for the left side smart contract and the generated test is very simple it includes an example test so it just says assert a third equation of assert that the counter at address is not kneeled assert that the contract has been deployed okay so this is just generated out from the tool okay before we jump into a real smart contract test you need to know some tools at your hand you can use these keywords in your test so we have some we have some tools relate you to count X you can you have access to state state is a collection of accounts and you have access to head head is the the the most recent block of the chain the the current block and you have access to contract contract is the Ruby object the test framework built for you it's compiled from the solidity contract it it extract the ABI interface from the contract and the test framework we have you the cowshed object for you so you can use the object to do everything to do all kinds of scenes on the contract and you can take some actions so you can transfer Balan you can transfer user between accounts you can deploy contracts to the state deploy is not implemented yet so is in grey and you can call all kinds of functions on the counter object and they I they are some pre generated randomly generated accounts you can reference to them by using private keys pop keys addresses and as a tester yourself you can reference to your own private key using private key pop key energy and we also define aliases to these randomly generated accounts so you can use well-known names like Alice Bob Carol to reference to those generated accounts so here's a real test in the left its standard token contracts the token council has issue function chance for function and get balance and on your right hand is the test for the corresponding contract and you can say at the first line we we use contract issue Bob 100 and that means we invoke the issue function to issue Bob 100 tokens and then we transfer Carol 90 tokens from Bob and then we make sure that the the Carrows account has 19 token tokens in it and then we we do the chance for again we we we want to make sure that it can be done it will raise some exceptions so in in the contract has you can you can find one thing is that it's really the test is really compact right you you don't just know asynchronous in this test there's no callbacks there's no money you don't need to do that you just write the test and you run the test just just like you do in Java or C++ if we are wrong is instantly and give you feedback so we find this will speed up your development cycle largely because now you can trick with the contract on the left side and then you just run your test and you boom get get the result from your from your code you you just written in instantly and when there's something wrong you can go back to your code and do something this feedback circle is much shorter than if you deploy a contract to test net or if you use other things and there's better stuff what if what if you forget to write the first line you forget to issue Bob 100 tokens at first but you just chance for Carol now you will you will get a failure in test then then what you do how do you do bugger how do you bug this problem in in traditional programming contacts we may find we may open semantic bugger right but someone said logger is the ultimate debugger I don't remember whom and we found that in in solidity we have log although the law is some it is some kind different than the loggers log in traditional programming world but there's logger right so we can add a lot we can write a log in contracts and the test framework when when you run in the the test the test framework will print the log in your council so you can know what's happening in your contract you can know you can know immediately if the address to is correct passed in right you can do it to all kinds of things to inspect your contract and this is very important important for for debugging I believe an interest by default locks will be print to cancel but events won't although events are also some kinds of locks but you can trick those options to enable events printing so if you set print events to chew then if you if there is an event in your contract you will see the below lines like this in your council and here you can see the issue from account and amount and better test is a language agnostic framework so it also supports serpent and I don't know how many server and developers here whoa italic okay but sir burn is also very good smart country language yeah so the test is possible because we created a ruby serum which is a full implementation of Assyrian protocol it it includes a lot of sins so what behind has is test will compile the contracts and run the bytecode on Ruby's virtual machine and it doesn't involve any mining and block creation it just run the code on VM that's very simple right so so you can get instantaneous feedback and at this time ruby sermon has evolved into many has inspired many projects so inside inside Ruby sermon we have we have modules in charge of data like block transaction etc and EVM it's a full implementation of EVM so there's people using the code inside Ruby seven to extract ABI from contract and there are also utilities like address public key private key they are very convenient tools to help you convert data between address public key and private key and Ruby Sarah also has many dependencies like our LPS - serpent and SEC P and based on Ruby serum we are now building wrath ressies a full ruby client so it's some kind like Joey cerium so besides Ruby sermon we also need Ruby Tempe to P the network layer combined a network layer with Ruby sermon we we can build rest and then we have test the testing framework and we have Ruby eath Ruby's is a small tool extracted from not extracted but built based on ruby serum to help you create and sign transactions and we have is JSON RPC which is a JSON RPC kind talked to a serum server a serum note and there are some projects extracted from Ruby's area so thank you 