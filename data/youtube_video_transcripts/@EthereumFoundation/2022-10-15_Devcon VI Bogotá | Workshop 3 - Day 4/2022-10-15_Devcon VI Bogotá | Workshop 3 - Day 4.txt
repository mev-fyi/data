foreign foreign [Music] [Music] foreign foreign foreign foreign [Music] foreign cool so yeah hello everybody thanks for coming yeah welcome to this uh ethereum JS Workshop uh I'm Gabriel from the ethereum Justin my name is Scotty also from the ethereum JS team yeah so today we're just going to be walking you through our mono repo so you know the ethereum JS motor repo so we're basically the JavaScript team of the ethereum foundation and what we do with the ethereum JS and monorepo let me actually bring up the slides it's gonna be helpful so yeah what we do with ethereum.js is we basically build a set of tools that people can build upon so we're used by lots of uh you know JavaScript tooling that's you know I'm sure you're familiar with and um yeah and it's really a great set of tools for people to learn uh about blockchain in general because JavaScript is a you know really easy to use language that a lot of people a lot of web developers are familiar with and um yeah we're focused on you know helping out a lot with research as well I mean we have a for example a client going but it's not a production ready client like like get and and others and that's kind of an advantage for us because we can jump in early for you know in your eips and Implement stuff because we're not constrained by the maintenance of like a production ready client for example so yeah we've been helping out with lots of you know newer eips so yeah that's just you know an example of that so yeah three of the latest like PRS that are in progress in the model repo are you know a stateless vertical State manager to help out with vertical trees that yam and a bunch of other people are working with uh erp4844 which I'm sure you've heard about like Proto then charting EIP and uh yeah Beacon chain withdrawals which are going to be uh part of the Shanghai uh hard folk hard Fork hopefully I think Community would be pretty mad if that doesn't get in so yeah you want to sure I'd also like to just say hello and if you get a sense of who's with us today um people used are mono repo yet or you adapt developers um it's got like a sample from the crowd of like who what what brings you guys to this Workshop raise your hand if you've already interacted with the etmjs motor repo okay so this is relatively new to most of you awesome awesome um and that's good it's um part of our focus is having these tools available in a language that devs know and are building in and you know as you're as you're learning more about ethereum and about how all this works uh hopefully our library can help you get there so yeah I've been with the team since the beginning of the year Gabriel's been here a little bit longer um and yeah yeah so we so I'm going to go through that slide quickly just to give you a sense of the kinds of like packages that we have so we have an implementation in Vibe strip I mean we're College from JavaScript but technically right at the moment everything is typescript we've migrated to typescript about two years ago so we have a typescript implementation of the ethereum virtual machine uh we also provide you know building blocks like transaction block blockchain we also had to have a bunch of like smaller scope-like utils like for example if you wanna rlp uh like recursive and prefixing like encode things decode things uh we have a typescript implementation of uh Merkel pituitary as well which is you know the data structure that ethereum uses uh we have a Dev p2b package and an experimental client uh it has sync magnet there's been a guy who is was able to sync magnet up to the tip of the chain it's not really a performant so I mean you wouldn't want to use it in production and we don't have like the mitigation that are in place for more like production-ready clients but it is able to run all all blocks from mainnet so yeah I was just mentioning it's used by a bunch of tooling so all these are some of the you know packages that I'm sure you're familiar with like hard hat truffle metamask remix uh web3.js and a bunch of other you know projects uh use us as a dependency for to to build upon so yeah let us give you uh an overview of how the um the ethereum uh JS packages kind of work together right so at the very bottom we have the client now the arrows pointing to the client mean that the client is importing you know the packages uh all these other you know packages so at the very bottom we have client which Imports basically everything that we've built in the model repo or as common is just going to be more uh like General things that you probably wouldn't use by themselves but are going to be helpful for like for example in common you will have like specifications for hard forks and stuff like that which if you wanna you know build a block you know you need to know like which hard Fork You're Building you know a block for same thing with the transaction same thing if you want to run a block in the evm and stuff like that so that all leaves in common we've tried to modulize it in a way that's more that makes more sense and it makes it easy to to Import and Export things without them being all intertwined so yeah you might have heard like term VM evm eei we also have you know a state manager so basically uh VM is like a higher level like virtual machines virtual machine which uh sends you would provide that like a block you would tell the VM hey I want you to run the block or I want you to run a transaction that it would forward uh an individual like message calls to the evm which would deal with like the op codes and all that sort of stuff then the evm would report back and communicate with a state manager that's going to update like whatever state you have uh in your remote so it's much easier to interact with the state manager because then you can just for example update an account balance rather than like finding the proper key in the Merkel particular tree updating that and recomputing the route which would be you know super tedious obviously so we've abstracted most of that away with the state manager yeah I'll leave you to start it to talk about the portal Network which is another thing that we are working on right portal Network um it's actually a series of of networks that are peer-to-peer networks special storage networks and this is all in under construction and under design at the moment but we are implementing portal Network clients in typescript using ethereum JS libraries um there are two other teams working in rust and Nim at the same time to implement this so essentially if you if you want to interact with the blockchain right now you either need to run your own full node which is a very heavy process requiring a lot of your resources um and most most people aren't going to do that and most devices aren't going to want to do that I have some most reach out to inferior which is a centralized access to the blockchain which works fine but it is a centralized access to blockchain which is kind of the thing we're trying to avoid so it people have been working for many years trying to figure out what goes up in that top left box where we can have something lightweight accessible but also decentralized and the work on Les lay clients has essentially led us to this concept called the portal portal Network um portal network is it's an in it's an independent peer-to-peer Network it's almost like a bittorrents it's working on that principle where um if you need access to some amount of information from the blockchain you don't need to actually sync to the entire blockchain to retrieve your you know your block history or your account history or many of the things that human driven wallet interactions um need so that's the idea we we're building networks to support the users of this protocol not necessarily building up the protocol itself the way a real full node does and therefore this can exist on very light resource constrained devices you could build it into the back end of a wallet app and it can just be running in the background of your phone or your watch or your anything um essentially the more more devices hooked into these networks the better they will work and part of that is that you don't have to sync to the entire blockchain because that takes a long time and doesn't really make sense for a small app or a small device to want to do that takes a long time it's very heavy it doesn't really get you where you wanted to go so with the portal Network you could just Reach Out get the tip of the chain get your account balance and all these things and be immediately immediately serve your purpose kind of explaining the same thing with interior everyone's reaching out to the same thing with the Les you get this kind of pile up where the more nodes involved in the system the more clunky it works and the harder it is to actually return anything but a distributed system every everybody's got a piece a little piece of responsibility of the network and they hold as much data as they're willing to and they serve much as they can or want to so for a practical example in a you know just a Json RPC call for each get balance right now if you're running a node you have to maintain all of these databases where you can look up the the canal index you can look up storage you can look up State and return these things calculate them and then return the balance portal network is going to work exactly the same but instead of looking into your own databases your own huge piles of state and history you can reach out to these light networks you can receive your balance receive history receive state and send it and return it in the exact same way so for for the user using a Json RPC call it feels exactly the same but it is possible with very very limited resources and uh ours is called ultralight there's two other teams one's called Trin they're working in their rust and a coin called fluffy that is working in nem I'm so cool thing about Arts is that we can we have a CLI client but we also have it working in a browser so we can open up a browser page too you know we built like a stupid uh small block Explorer but you open up your browser page to this thing and the browser itself becomes a portal client using the same kind of uh same kind of memory and and storage as anything else and you know can both can both look up uh look up and serve yeah what else am I saying yeah essentially your your app can be a portal client if you if you were to bake this into they get into your app that can basically just be running in the backgrounds you don't even really have to think about it but it's Distributing the data among a large large network of pockets and phones and laptops um essentially taking a lot of the load off of Full clients and and making a lot of this data available in a much more lightweight way we have been building the history Network for the last year or so and that is imminently operational [Music] and then the idea is that the other networks can just build upon that but they will be independent Network so as a portal client you can participate in one or all of them you can you can be there as a freeloader and not contribute anything and it really doesn't take much away from it if you think about you know BitTorrent most people are most people don't really go into their torrent apps and change a lot of configurations to be selfish about it most people just download the thing and use it as it comes essentially you don't even really have to know that it's happening but you are serving the entire network yourself so that's yeah that's a side project but it's very exciting and is definitely part of the future of how these things will work yes sir mm-hmm so it's a distributed distributed hash table both of content and user addresses so for the most part you're going to be randomly assigned and addressed in that in that sphere and you can sort of configure the radius of of data you're willing to be responsible for um yeah so you you would be up here on the network you know if you constrained yourself to only holding like a tiny bit of data then you're not going to be asked for it very often and there are certainly malicious ways to just you know put a bunch of nodes up that aren't doing anything but um I don't know the for it just kind of means that we've built something worth attacking first of all and that there are solutions to those problems that can be worked out um and just I think we're counting on the General laziness of users that are going to download a wallet app that somebody made and not necessarily configure it to be like weirdly malicious there's no incentives here it's all just it's all just there because it benefits users and by benefiting one user you benefit all users so yes there are ways to attack it there are ways to be mean about it but I think for the most part as long as as long as enough users are just kind of passively participating then that's not as this isn't this isn't crucial to the protocol itself like portal Network going down does not affect ethereum in any way so we can build this thing that's lightweight and hopefully just working on just working on like natural natural law essentially um nobody really has anything to gain by trying to set it down and it doesn't really affect anything um yeah you know problems that we're working out or uh we're trying to steam ahead with like building the thing and then like solve all of these problems along the way but yeah please uh are it's Ultra late team is just two people it's me and me and Andrew from our team so uh we're always looking for help or for whatever kind of contributions are out there cool other questions on that before we move back to more like the actual hmgs motor repo so we uh we have a concept of a bridge node which is something that is um is synced to the net and is or synced to the chain and it's just feeding feeding into the portal Network if we have enough of those it just kind of saturates over time we also have kind of ideas of how to I don't know maybe like a babysitter node that kind of like circles the network and looks for gaps and and kind of helps helps fill in the gaps but yeah it's these kind of bridge nodes that originally saturate the network and maybe maintain that um the boot nodes are uh uh we have devops just put up a bunch of nodes for us that that are acting like boot nodes there's no real difference between a bridge client and a just regular client it's more uh are you are you doing this extra work to like add to the add to the network or are you just helping to gossip around the network yeah all right so we'll we'll move ahead with a demo uh video MJS so as you know the next hard for hard Fork is going to be named Shanghai and there's a test net running at the moment it was down for a couple days but it got back up I think this morning or last night uh it's uh it's a test step that basically implements a subset of the uh of the eips that are going to be part of Shanghai so there might be additional ones the one on this list at the moment but the like tentative like list of VIPs that are going to be included at the moment is is the one you see on the screen so the beacon chain withdrawals and the deactivates self-destruct our implemented yet in our in our client but uh yeah the schenden testnet is up and running we have it running with lodestar as a consensus uh client which is like the typescript you know consensus client and then we have it there with uh ethereum js's uh the execution client so that testnet is so it's live uh you can look it up there's a block explorer that I think we just put up this morning uh and as far as I know like the only execution client that's actually running that at the moment is ethereum JS with the JavaScript client so what I'll do is just I will not like run I will not access like the actual you know Live Test net but I'll run like the test net locally to give you a sense of how you would go about doing that and you might be interested in running that yourself when we go into the more like interactive part of the workshop so I just need to check out the proper pull request from our model repo so it's just that here so yeah as we said our mono repo is broken into you know packages can you see the vs code yeah cool awesome so we'll just go to the package client and I have you know a couple of instructions I've I've done here so basically what we first want to do is we want to create you know data folders for about you know the execution layer data and that consists data yeah zoom in I'm not sure if I can zoom in now actually but I can definitely zoom in vs codes at least that's going to be that is that better yeah cool no worries oh yeah yeah they're actually available on that pull request and in a couple slides uh there's a link tree with all of these uh alpines so you definitely can access all of these nodes and yeah it's it's a good exercise as well to uh you know run that yourself you will have time for that and we'll be happy to help everyone get that running so yeah the first thing we want to do is just create some data folders where the the state of the you know where the consensus client data and the execution client is going to live so we're gonna put that in data yeah Shandong so we're going to create an ethereum folder and we're going to create the load star folder as well so now we're good to go for that part so the next step is we're already going to start our uh execution uh like side and it's going to use a Genesis that's been done by one of the guys on our on our team usually like Shandong at genesis.json you'll see that more clearly here here in packages what now you're in practice oh yeah yeah you're right thanks yeah and there we go hopefully that works live coding is always a bit uh sketchy the the Wi-Fi is pretty good actually if you haven't noticed there's a workshop specific Wi-Fi network that you can access because they're the global Wi-Fi isn't working that well so yeah we see that we have a Json RPC server started because we started you know our client with the RPC RPC and giant flag we have a Genesis that we've specified and the data directory is ethereum JS which we've just created so that's pretty uh fairly simple so by default when you run the ethereum JS client it's gonna consider that the merge hard Fork has been activated because we've specified you know a Genesis after that so at the moment it's just waiting for a consensus flyer client connection without that it's going to be not going to be able to you know obviously execute blocks because it's not getting getting any so this is exactly what we're gonna do we're gonna start the lodestar uh consensus client so the the first thing we need to do is we're going to need to specify the Genesis hash to the um to the consensus uh layer client so to that to do that I'm actually going to bring up you know inferior and we're just going to query uh the hash of the uh I'm not going to bring up info actually I'm just going to query uh the local RPC that we we've seen specified here you see somewhere up here start Json RPC server localhost 8545 so I'm just going to do this is just a tooling to like visualize you know requests a bit better so let's see if I can recall how to do that by heart we'll see so we're just going to send a standard like Json RPC request to get the data of the you know the very first block in that you know exec exit execution client state so method then is going to be what is it it's it get locked by number if you see me make a typo be sure to point it out so that we don't break our execution live client by sending in like bad stuff and um so we're just gonna specify you know the very first block we could specify earliest uh as well uh this second option is just if we want the transactions we'll we'll say yes but it doesn't really uh matter all that much uh then we need to specify an ID I think we'll just go with one can you see properly yeah cool big enough so let's see if that works cool yeah so we've got you know the first Genesis block we should expect like the parent hash is going to be zero uh this is post uh merge sort of mixed hash is zero it's uh it's unused and denounces one two three four not sure what that is but that is probably like a default value or something so we're just gonna take the hash and uh yeah we're just gonna copy and paste that so then the only other thing that we need is we need to specify like an initial like timestamp so I'm just gonna quickly get the timestamp like in seconds and we're gonna add like a few like seconds to that when we do that you know right after so I'm gonna start the consensus client here and this is a fairly you know long command it's running with uh Docker like I've already installed Little Star in my machine I didn't want to do that you know here but we can help you you know set that up later if that's what you want to do so all that we're going to need to specify is we're going to need to specify the Genesis eat one hash and we actually have that from here so we're pasting the and then we are going to specify a Genesis time which is going to be that and I'm going to add like a number of seconds to it so let's see if this works so we should eventually start you know producing uh blocks so we see publish block that looks pretty good and then if we go back to the execution layer client it should have picked up on you know the consensus uh client starting to run producing blocks sending them back to it so let's see if we yeah it's uh assembling blocks build block looks perfect so we we are seeing that uh we have a local running with a bunch of newer eips now one thing we can do we have a test Suite I think for like it's spec so we have a bunch of tests here that we can run to see if the you know eips have been properly implemented so I won't go through all of them feel free to go through them yourself so EIP like 3670 is um like the EOS code execution the code validation so if you try to publish like a contract code that doesn't conform to the eof standard it will get uh you know rejected we have a bunch of related tests so we have uh can't exactly recall what this one is actually a bad there that label here just fix that and yeah so we can try and see if we can run the test I think it's in the SIM all right so it should oh I have to specify extra run through yeah right so this is going to interact with the chain that we have running locally and check if everything seems good so we've been able to make a transfer that's already you know not so bad and then it's going to test eof and a couple of other you know eips this is a bit slow maybe because I'm sharing the stream I'm not sure but yeah we see that test uh running and yeah I'll keep that running while I keep it up go back to the presentation slideshow all right all right so this is uh where we're going to start like the more interactive and I feel like interesting part of this Workshop where I mean we encourage you like to bring actually your laptop style and if you have if you don't have a laptop or you don't feel like you know coding yourself I would really encourage you like to to meet up with someone or to bear with someone who actually has a a laptop going because I feel like that's probably going to be the best way that you can we can show you about the mono repo and if people have like different degrees of uh of skill levels or familiarity with like blockchain in general we have a couple of like suggestions as to what we suggest you to do so if you're and that QR code is uh the link tree I was mentioning earlier so it has links to all all of these things along with the like Shandong test net instructions now I want to mention the structure of our mono repo you can clone the whole mono repo and it'll come with is it 12 packages so all all of the relevant packages will come in the mono repo if you clone that from GitHub but each individual package is also installable on its own um so you can you can install just the transaction package or just the block package you don't need to have the whole mono repo as a dependency you can have each individual each JS package yeah yeah because I would encourage you today to maybe clone the whole model repo so you can see everything and and get a sense of how they all connect to each other yeah yeah clothing the model repo is probably the way to go if you want to experiment a bit especially since some of these packages are interdependent on you know each other but if you were for example building a set of tooling and you only need to build blocks from data or build transactions from some piece of data that you have you could only import like app ethereum uh Block in that ethereum transaction and that would be you know all that you need you don't need to you know import the whole model repo it's just package based so yeah what we have like sort of prepared for you in terms of uh like paths if you're more like uh I was a beginner but like if you're more novice or if you've never really learned about you know Merkel Patricia trees uh a good way like to explore that is with a tutorial that uh have been written like two years ago and has been like uh updated recently and it basically goes through it uses our tree package to teach you about the very fundamentals of that data structure so it just starts with you know uh putting a value inside the the Merkel person should try uh database getting the value uh Computing a hash looking how you can you know make proofs from these hashes eventually all the way up to uh you know querying data on the blockchain and uh and interacting with it more dynamically in a way that's more similar to what you'd expect in the real world uh context so uh I'm super happy to help you as well uh answer any questions on trees it's the package I've worked the most on uh and the more I guess intermediate track although I mean Merkel perspectives are certainly like not super easy so we could have put that in their intermediate track as well uh you can experiment with like rlp encoding or decoding so this is the serializing uh algorithm currently used by ethereum and we cover a bit of that in the Patricia trees tutorial but if you want to experiment with like oh what does a an area containing a dog and cat strings look like when you are LPN code them that's the package you would go for it contains two methods rlp.encode rlp.d code super simple and you have a bunch of helpers like to convert hex to Strings and stuff like that another I feel like exciting thing that you could use are packages for is uh the block and the transaction packages one of the things you could do for example is query uh you know just like we've done here we've query the block so a good exercise would be to recompute the hash of that block from that data we have helpers that can do it for you uh like super easily where you basically just paste that Json object and it's going to recompute like the hash or a block object for which you can get the hash but it's also it can also be interesting to just take those fields like manually and try to recompute the hash yourself and we have all the helper methods you would you would need to to do that and if that feels a bit a bit hard you can look at how we actually Implement our helper methods and you know try that out go back to the yeah all right in the more advanced I guess track one of the things you could do is invent and Implement your own EIT that might look like super hard but we have an example here of a super like minimalistic e-ip and I'm actually gonna show that to you just so that you see how small like uh potential EIP can be so I think it's 18 for yeah right so it's adding like 92 bytes of code removing two pretty simple it's in the IP that goes into Shanghai just warms the coinbase address so if you take this as a as an example your I think you're easily going to be able to you know reproduce at least the scaffolding for an EIP and you can like invent this perhaps not so useful but like easy one where it just modifies the way maybe a block is run it maybe modifies the the name of field or something like that and uh yeah that I think that PR can serve as a guideline for how to do that and yeah most of the implementation is actually like it's basically just that line here in addition to like the scaffolding and a bunch of tests that are just confirmed that the EIP has been implemented properly in terms of other things that you could do you can run the local client as we you've seen us do and you can run the Shandong at testnet with lowestar as the consensus uh claimed so yeah now it's Off to the Races as the return always says so any uh does everyone raise your hand if you don't have a laptop well I have one so I won't raise my hand so everyone has one awesome so was everyone able to scan that uh link tree thing all right cool if not the link is just linked linktr.ee slash ethereum.js let me just bring it there all right so do I'm wondering how to best like structure this so either I can go through one of those myself for those who want a more uh follow along but I think what would be helpful is maybe if we just help everyone you know set up a local environment and if at some point you want to follow with what I'm doing you can do it or if you want to work on your own thing you can do it as well does that sound good to everybody yeah all right cool all right I'm just gonna walk around might not be best for the live stream not that interesting to watch it at this stage but uh I will be walking around and just raise your hand if you have a an issue of setting up your local environment just clone the model repo it's linked at uh so if you click on internment yet it's going to bring you to uh the monorepo itself uh go with Master yeah yeah just like that to me so first you're going to want to install the dependencies from so one yeah one sets clone do ntmi and it'll download dependencies for everything and build all the packages you can do that from the from the mono repo get this just let me know if there's yeah we're proud of you um yeah get calm down exactly you have it uh all right all right and once you've clowned uh molarapo the way to install it we use npm so just npm install is anyone running on the windows very happy to hear that oh yeah there's the door yeah for Windows users so he's I assume people are on uh Mac OS or Linux yeah yeah okay the workshop Wi-Fi's password is uh build it 22. uh lower caps build it and 22 the the number oh it's slow the repo is pretty big so it can take a couple here 800 kilobytes per second it's not too bad but uh we're yeah we're getting there we have time we have time and yeah make sure you're using the workshop Wi-Fi otherwise it's definitely going to be much longer yep you know yeah yeah yeah absolutely so you don't need them for what we're gonna do so just npm installed from the model repo itself make sure to run npm install in the you know mono repo instead of in packages themselves so that's going to build the whole thing which is what we want like that just look at that and search actually yeah oh okay yeah yeah so because yes but you're going to see is uh yeah and and you know build transactions from different kinds of data so uh you can look like you're familiar with typescript yeah so you can look up the pipe screen you know the uh yeah so one thing that I would suggest you do is maybe like query pip okay transaction where you opposed the IP 1559 transaction and then try to you know rebuild them or uh what would be sets of tools and make sure you compute the right hash again and you know stuff like that yeah all uh I'll reopen that yeah we're good for 10 minutes I'll come back is everyone good raise your hand if you need additional help okay so I think you just entered so yeah just uh you can clone the ethereum JS motor repo uh the second link intermediate Link in the uh in the link tree that you see here and then uh yeah just uh make sure you're on the you're on the master branch that should be default and then uh yeah just pull the latest and npm I've to install the model repo that should be all that you need so just just so I that I do something that's relevant for most people who's thinking of doing the uh Merkel Patricia trees tutorial awesome okay cool I wouldn't quite recommend it it does cover some of the stuff that were uh we would be doing in Block transactions in rlp but it just guides you through them rather than just showing you out there uh who's thinking of just going straight intermediate and building blocks transactions all right and who's thinking of trying to implement their own EIP is in one motivated all right awesome and uh what about running the client or running the Shandong test net okay yeah so I'll just be going through the tutorial as well in front since everyone is going to be doing that and it's going to be more interesting for people who watch the recording rather than just looking at the link tree for one hour foreign my local blockchain yeah so this is the folder that you should go in if you want to do that tutorial and the readme is is you know the tutorial itself what we also have is a set of examples like I had uh written this tutorial in JavaScript just so that people who know wanted to learn about ethereum didn't know about typescript didn't really have to you know I'll learn about it so those are like GS files that you can just run with the node trick yeah package is named uh try so once you've uh let me actually just reinstall since the Shandong thing is a bit uh a bit different yeah was everyone able to install successfully cool no issues huh you're waiting for the installation all right cool yeah it takes a while because it's building every package so uh yeah uh are you trying to run uh from the monorepo itself npm run test uh yeah it might be just because of this modules in the like a lot of the uh a lot of the general affairs that we have depend on that those sub modules foreign [Music] yeah they're pretty big they're pretty big I can't say for sure like depending on the bandwidth how long it's going to take my own machine the helmet doesn't take that long but uh you can just leave it running and see if uh oh oh that singular test okay uh let me give you an example of running a an individual test I'll just go okay the the the principle is going to be the same for all of the packages themselves so if you go within the individual package that you're trying to run the test in just do npm run tape and tape is like the testing you know framework that we use then you do uh double I think those are called Dash in English I'm not even sure uh then test to look at the test folder and then you just select the file basically that you uh that you want to run right so if I wanted to run for example the I don't know the the proof that spec test I would just do that and it's going to run that test individually if you do npm run tests it's just gonna run like a massive Suite of um of tests including like integration tests that depend on browser integration stuff like that and that's typically like super long we only do that like in the CI once in a while but the locally it's a bit tedious so and yeah then you see the the result of the test uh it passes so let me close that up all right so let me open up the tutorial again all right so there's you know a bit of preliminary info that you might want to read um you know data structure of ethereum is called the miracle pituitary it's a basically a combination of a myrtle tree and a picture should try a try is a data structure in which Keys represent the path leading to a specific node and the Myrtle tree is a structure in which a parent node the key of that is the hash of the all the trial nodes uh Miracle degree is interesting because if you want to prove that the certain value is part of the data at the large marbled restructure that you have you can do so by providing a bunch of like sister nodes we'll see uh that super clearly in the tutorial itself so yeah the instructions are here they're the same that you've just ran so clone them on the repo um install it and then go inside of that try package so I've been going through these like fairly you know slowly so feel free if you're you know want to go a bit faster to just go forward and don't let me like slow you down but the sort of first example we're going to use the try you know library before is uh creating and updating uh a base drawing so what does that look like so first of all we're importing the try uh class from the the try package and we can look at what you know that looks like it's probably like try file yeah so try is simply a class and uh you know it has a bunch of properties that you would expect uh on the you know database like structure it does use like a checkpoint DB is a as like a database and then you can provide options for the tree so some of the options are uh do you want to use this specific type of keys you want to use like plank keys or hashed Keys like are what is used in ethereum then we instantiate database you could provide like your own database here where you're instantiating a new like map DB and um and yeah instantiating a new tree when we you know construct a tree with the tree class and you can see you have a set of methods here you can for example you know get the root of the tree uh you can verify if a certain route exists you can get those are like these two methods or the ones we're going to be using the most so we have a get method to retrieve a value by providing a key and then we have a put a put method which stores a given value at a specific key so fairly standard you know database stuff but this is going to give us insight into how you know the that actual data structure works because it's not like a simple database so let me go back to the tutorial so the first thing we're gonna do is like instantiate uh the tree so I'll go to example one a yeah I'm just gonna comment that out so yeah to run a specific example you're just gonna go uh node examples and for example example one am I doing a typo oh it's within Merkel for trees and then example one a there we go so this all I'm going to be doing here as you can see is instantiating a new tree uh with you know the the try package from the monorepo and then logging the root of that tree and this is going to give us the the the root of the tree which is uh you can look up in the Docks but it's basically that uh the the the encoding of uh I think a demptia right um rlp encoding of an empty array so yeah we see like pretty fast we see we output a buffer which is a uh which is that now that doesn't tell us a whole lot but we could look up in the docs and see that this is actually exactly what we'd expect in uh as the root of Genesis like root of uh the try like data data structure so then we're going to move on to a more you know a more interesting test I'd say we're gonna we're gonna try to just put a value in it and see if we can actually retrieve it another thing we're also going to be able to see is how the the route you know has been updated given that so yeah what do we do here we're creating a key I mean a try natively uses buffers so we're doing like buffer from for for all of these so we're having test key that's going to be your key and we have this value this is going to be our value and then we're doing an asynchronous operation like putting that key value pair inside of the try and then we're going to try to retrieve that value fairly simple what we should expect here is uh so what should be the value well it should be the you know the encoded version uh the buffer from version of a test value and the value string we should expect to see value and if we don't there's there's been an issue either you know in the library or in the way we've used it it should also update the tree root so one thing I'm gonna do is I'm gonna also log try route before and what we should expect is uh like each Miracle Patricia Street like each state tree should always have a different uh hash if it differs and if it's the same it should always uh have the the same so let's try running this again so what do we have here we started with a empty try route yeah we had logged that before actually so the try route before you know is the same with just the same thing twice the value that we've retrieved is it's this if you are familiar with the you know this just uh the hex correspondence for all of the all of the characters and then if we uh convert that to a string we get back this value this is exactly what we expect then we see that the try route has you know massively changed as you would expect from uh any kind of hashing if it differs slightly totally different random result right that clear to everybody does that feel intuitive yeah any questions still remember we're always uh so a normal tree so this is the actual Myrtle Beach tree like data structure that we'd be uh that would be used like in production with ethereum the the only slight difference is that the mergul Patricia trees use like hash keys so instead of using the key we'd use like the the hashed version of that key and this is only to balance out the tree so that there's no Vector of attack where you always update like values in a similar region and make it more costly for nodes to run operations um the so what I think your question is is you know there are there's a if you had a normal little structure like this you would always like Traverse every single load would only give you one hex right because it's a 16 like width tree so if you have a key of like uh you know 32 bytes then you would Traverse like all these nodes on the way down there now Merkel Patricia trees are more efficient than that because if if they know that given a certain path there's only one possible path down they're going to create what's called uh an extension node which extends all the way down to the to the leaf so this allows you to shortcut unnecessary paths what you'd see if you didn't have that is there would be a bunch of layers in their Merkel pituitary where there's only like one specific branch that has a value and then you go down and there's only one specific Branch so for like sparse trees meaning like trees that aren't filled like with data all over this is incredibly more you know efficient because you don't have to store like all these unnecessary nodes this collapse collapse those back up into into one leaf instead of tree with only one leaf yeah absolutely so yeah I'll go ahead and check what example two is about yeah there's a couple of additional like notes Here that you might be interested in some of them I mentioned while while doing it it's also talking a bit about the rlp you know encoding uh function this is uh actually not up to date that link I think it's probably here yeah yeah so there are some very nice ducks in uh on ethereum.org for developers like if you're looking to learn a bit more about rlp you would just go there they have a bunch of examples and you couldn't even like use our library to test it out and play around with it so before values or so there's a bunch of values you could want to store in the miracle Patricia tree right and those need to be serialized before they are you know put inside of the tree this serialization is done with recursive land uh prefix encoding function and and yeah as I mentioned uh Keys also go in additional additional transformation they're not used like raw uh they're used uh we first take the keca 256 of the cube before we we update the tree so here we're basically going to do the same thing but we are going to use the hashed version of the key so how we're going to do that is we're just gonna you know import the kick to 56 that we have in you know ethereum.js slash util package and the only difference is we are going to uh as you see here uh put the value at the Keck of the key instead of the key itself so everything else is going to be uh you know exactly the same so let's see yeah similarly we're going to get you know an updated tree root so that you know nothing surprising here uh it's basically just you know we we had an alternative key which is the kick of the key we got the same value back no difference there any question on that um is the kabali industry okay so the the values themselves aren't hashed because otherwise we wouldn't be able to retreat them since you know hashing is one way uh the only thing that we hash is I mean this is like a key value you know data structure uh the value we keep you know native we just rlp encoded for you know serialization so that it's compatible but the the key itself that we're hashing we could very well well have a miracle surgery like data structure without hash keys and however at the you know early days of ethereum it was chosen that the keys are gonna were gonna be hashed uh the main reason why that was done is so that it uh evens out uh the tree uh naturally so it mitigated like vectors of attack where you could have people like constantly update like uh a part of the tree like very easily and now if you wanted to do that you'd have to like pre-compute a hash and since it's like non-deterministic well it's deterministic but you can like predict in advance what the hash is going to be obviously you basically have to do like proof of work to like uh Target like a specific part of the tree it imposes some Randomness on the the actual address and so if you have keys that are related they won't cluster in a part of the tree they'll be dispersed evenly and your key can be a short string and it ends up 32 bytes yep yeah yeah so in our case like keys are always like how does this like in the case of the the state tree Keys would be like the the account addresses but uh yeah The Tech Guy like hashing something obviously also has a benefit of making everything equal length which you want in like data structures like this all right so as we said like fairly fairly straightforward now we're going to do something you know a little bit more interesting now what we've seen is that the the like we've used the Keck 256 of the key but there's a you know there's a property of the tree that we can just use in order to do that natively that property is called use key hashing it's a Boolean that defaults to false but as you can set to true if you want when playing around with the tree is just more convenient to set it to false or have it you know default to files just because you you don't have like to to all do all that additional computation it's also easier if you want to debug what a value uh you know if you if you only have the the hash of the key you can never know like what was the actual key that I used to update this you cannot retrieve it back which uh it's actually an issue that has also come up when making the transition from Marvel trees to Vertical trees but that's a different uh that's a different topic so let's see what example 1C is about so I think it's basically the same thing but just using we use key hashing so what we should expect unless our yusuke hashing Boolean is implemented improperly as we should expect exactly the the same values that we have here including the updated tree root given that we're using the same yeah testing this valued uh that should work so let's see and yeah as expected we've created a new tree but we've updated it with the same key value pair and we are getting the same updated try route okay now we're going to do a a different operation so among the operations that are possible you can retrieve a value you can update the tree by adding new values you can also delete values from the tree so let's see what this looks like the as I as I kind of mentioned before every tree that is similar that has all the same data should you know compute the same room that's how we get you know the security properties of these uh of these trees so what we're going to do is we're going to update the tree it's going to update the route and then we'll we're going to delete that same key and it should give us back the exact same route that we started with let's look at the code all right yeah we've created updated then delete using the weight will helper method get it again we we shouldn't be getting uh a value when we try to you know retrieve uh that key I'm not exactly sure what we're going to get I'm not sure if it throws or oh it looks like yeah it's going to be null fair enough and uh let's see about that all right so we are starting out with the M3 empty Tri World here it starts with 56 E8 then we are updating uh the tree we're getting an updated tree root which is uh similar to the like unhashed key one we had before and then we are deleting that value again and what do we get back when we query that that tree for that key we uh we get back null which means like empty no it's not there and the tree route that we get back after the deletion is the same that we start with so yeah I kind of demonstrates that every you know same tree is going to have the same root yeah so now we're gonna take a bit of a deeper look at the actual you know data structure of uh the murder tree so it has you wanna go for this all right all right long to take over yeah I feel like I've been talking about no you're you're a good communicator you should do it all right all right so there are four kinds of nodes in the Myrtle Beach streets so there's the null node which is the one we just queried accidentally by you know deleting the tree that's a non-existent node you get back now when you query for something that doesn't exist there is a branch now what a branch node does is it's basically an intermediary node that points to a bunch of child nodes there is then a leaf node which is you know this is called the tree the leaves are the very M these are the nodes that contain like the you know the final values and then there are extension nodes extension nodes are the shortcut uh I was kind of hinting to so if if you have a key for example I mean we're going to see examples actually so it might be easier any question before we dive into looking we're going to look at all these four different kinds of nodes individually yeah is yeah how how is that initial route created yeah good question I'm I think it's the rlp encoding like it has basically still uh you know it's it's the hash of the value at that root because it's initialized with a value if it wasn't initialized with a value would just be null you know initially uh the way they're defined I'm sorry are you asking about the extension node like how how that route comes to be the very first yeah yeah yeah so how how would we able to calculate ourselves like manually the hash of the the root node and the empty root of an empty tree yeah so so yeah we can actually look at that directly in the code uh we have uh we set empty try route that's like a specific like constant property when so when we construct uh when we initialize the new tree what runs is like this Constructor function if we don't provide options and we we have like default options that we provide we instantiate the database and then the very next thing we do is initialize the empty Tri rule which is exactly the thing you know you're asking about uh this is actually quite simple so what it is is uh the rlp encoding of an empty string which uh yeah constantly okay so it's buffer Ox 80 and that's that's like I guess sort of a universal for empty tree yeah empty rlp well it that's actually a desirable property yeah that all you can know if and you could identify all empty trees from exactly that right like the same trees should always have the same root same with an empty tree every empty tree will have the same route yeah and if we let me take that example file actually and just compute that you manually so we're gonna need what we're gonna need something from rlp let me do it in the rlp package actually yeah I'm having a bit of trouble navigating with my screens so zoomed in foreign chat individually all right so this is importing the encode method from the ROP Library so what do we should expect to get back uh from you know an empty string oral pin coding would be ox80 which is you know the buffer we we just saw before so I'm gonna have to move out of that repo go into the example solder and then run this oh am I not in the right okay so why is it not logging always interesting when you do live coding you'll figure out how to cancel out something thank you yeah I switched package before the can just actually import they all just import it directly from uh there this oh it's actually in bins for that folder all right let's see if we can get something going now let me just rename that to address file actually all right it is not working at all all right okay we're finally again I'm getting about something and we're getting back uh 128. is that ox80 in HEX let me actually minutes oh yeah it's gonna be hard to import packages in a JS file like that huh you just okay yeah so 128 we we got back the decimal value but 128 is like ox 80 in decimals which is the the value that we're using inside of the tree to compute the root hash so we are basically just to to compute that you know root hash we are just hashing ox80 so if we take the kecought hash of the let me look back at the place where we were using KitKat so I don't have to re-import manually so if we're doing the kick at 256 of a buffer from like of safety we should expect to get back to the exact same like empty hash that serves as uh the root of an empty Merkel pituitary so let's see if we can reproduce that you know ourself we'll just comment out the rest to remove some noise navigate back to the tree package maybe I have to that as this string all right so we're getting back a uint array I just need to convert that to hex then we should be getting back to the same route that we initially started with so we have a buffer to hex util in the package now the way my testing thing is set up my not allow me to import that he yeah so I would need to do buffer to hex here uh well since I'm now running on a like JS thing I would need to build it before I'm able to run this so I will not do this here but those are we can trust that you know the values that are output here if you were to convert every one of them in you know in HEX would be the exact values of the the root of d of the miracle pursuitry that we had in the the example d like 68 nothing here is that a satisfactory answer it's your question are you yeah yeah cool any other questions before we move on to going to all uh specific kinds of nodes we're good everybody's following along all right nice so yeah we're just going to start with creating and looking up uh null node so how do we we're not actually really going to create an all node we're just gonna query for a key that is not present in the mergle partition tree so it's basically the simplest like test case you could imagine so what we're going to run is at 2 to a right let's look to something that here yes we're instantiating a new tree uh we are trying to find a path you know to the uh to the key test key and we'll see what kind of node we'll get back now what you will see now is that we're using findpath which is going to provide us with the actual node and then all the object instead of just providing us with the value so if you want to query the three four actual values just do get but if you want to get more information as to you know what the path is and what the node looks like you would just do a fine path so we're running example eight this provides us with uh yeah a null node as we would uh expect we could change that to uh pretty much you know anything and uh we would get back now as well no difference now one thing I'm going to try actually is if I query buffer from that I'm not sure if that's going to be a null node as well yeah okay that's not load interesting oh yeah the thing we were using before yeah I think it's still null it since it it's like defined as you know the initial hash is defined as that but there's no actual node that's present and that key from what I can recall the specs so they're yeah yeah it's basically a way to bootstrap the free so that it starts you know with something uh you could Define like a new Mercury data structure that uses like something different obviously from rlp encoding and also has a different like root hash you don't necessarily have to use it it's useful in the context of ethereum because we obviously want to be consistent throughout like implementations but it's not it's not a necessary part of the data structure like that you could Define It Anyway any way you want so yeah the null loud is a bit you know boring it's not as interesting and the ones that are to come uh it's also like slightly more complicated to to create because if you think about how you know these kind of keys work right you have a key and to retrieve the value for it you just go down each note is a hex value right so let's say the next part of the key is like seven you go branch number seven and then if it's uh you know four like in this example you take branch number four and you go all the way down now since like Miracle trees are like optimized with extension nodes uh you wouldn't get a branch every part of the way down what you would see is you would start at seven let's say you only had like one of the keys you would start at seven it would give you straight it would go you straight to the end because there's only one value that starts with seven so it would like kind of compress the tree for you uh so if we want to create a branch though that's like acts as an intermediary node you would wanna you know we want to store key that are all basically in the same spot and then Branch out at some point and that's actually interesting because it's super easy to do that you know with what we're going to do in this example but if we were using a hash tree then it's basically you know impossible to do that voluntarily and that gives you a sense of why that was chosen in the first place right why we're choosing uh to Hash keys in the context like a production you know database in ethereum to prevent like dos style attacks with uh you know just putting keys are always in the same spot all right so let's look at that actual example sample 2B foreign yeah I'm not saving any of that um well it is that like native format that this tree accepts like you could do it like we could have an implementation that just basically allows you to input anything but it would still be converted into something that natively ingestible by the tree so the tree is defined as a like hexary hexiratory meaning that every key must be like hexadecimal for it to be like conformed to the data structure if we didn't have this small values we'd have to convert it anyway so that I mean so that it maps to like a 16 uh 16 width key so yeah yeah absolutely yeah yeah so and also like RL Bean coding encodes things in Exodus mode so we're all like working with Native like hexadecimals here it was in that tree uh so yeah if we like unlike like hashes uh buffer is going to be it's just like the the hexary like encoding of the these keys so we should expect these uh all these values do still be quite similar and that is what we see here so right we have the prefect test Keys come in for all of them and test key is basically that part you know of the uh let me zoom in a little bit yeah that part of the of the buffer now we have 30 which is a 0 and 41 which is capital A which are you know the the last parts of it so what we should basically expect right is uh would you agree that we should expect like a branch node at 79 at which point you know it branches up so what we would see is like there's going to be a value at 79 a branch don't you know can have a value but then there's going to be two bats there's going to be path number three and path number four like in indexes of the array then it's going to go down all the way to you know a leaf node because it's basically the end of the path for that part of the path and then 41 which is going to be the another part for that you know other path does that make sense to the body mediation yeah yep that's uh through the idea of the the Patricia tree is that you're following the sort of following the keys along that path and everything that shares shares by it basically yeah yeah and something like to mention here this is only keys right this is not the values themselves and like later a bit in the tutorial we see how you know the hashes of every like parent is computed which is like different you know from this but uh yeah so if we had like uh also a a key address T we would see like that that would be only 74 because that's like lowercase D is 74 uh in HEX and uh we would see a branch note at 74 there would be value already there and then there would be like nodes uh like paths to all the way down to you know 79 it would be like we'll see that after but it would be like an extension node for optimization purposes and then you have well branches as we've said to 30 and and 41. so yeah what we're going to do is update the tree with all those keys we're going to find the path to test key and we're going to see what that node you know actually uh looks like all right so that's actually a pretty nice like visualization I think of what uh of what's going on so we have you know 33 buffers then we're updating with all those three keys so we're updating the tree with teskey test key zero test key a which all have the same prefix we query the the node that lives at Key test key which is the the common prefix for all those so what we see so this is index you know zero one two three four which correspond to numerical values like just plus one since indexes start at zero and uh actually no that's not true just correspond exactly to the actual values and uh and we're seeing that there are two uh different you know values here so that is what we'd expect we have like this is basically like empty so like null nodes because there's no path uh at that point like uh at Key zero there's no we don't have any anything uh that lives at zero right we don't have anything that lives at one we have nothing to lose it two but starting from three we have an actual path and we see that complete path here we also have the same for 41 which is you know index 4. and then we have nothing all the way down an interesting thing is we also have a value already here at address you know that's basically test key and hex so a branch node is not only an intermediary node it can also contain values you know itself in the case of keys which would always have the same length you might not see like values at certain intermediary node because they all leave them Leaf nodes but you can still use that data structure for other purposes where you know the length of keys wouldn't always be the same all right yeah so that's exactly exactly uh what we see and we can uh we can take the value of that node and see if we can like the value here we can yeah we can parse it to string let me find you the code so it's more revelatory of what's actually going on so yeah we we found a path we found a node we take that node we look at the value at that specific point and it should be the the value that we've put at test key now if we were to take a uh the value of a of one of the nodes that is a child of that parent node we would get also like test test value 0 and test value a so it is what we're doing you know a bit further down here so let's look at how we're you know retrieving that we are taking you know the third branch and the the second element that's just the that's the value of the the of that leaf end node converting it to a string and then we get we retrieve the the value back is that somewhat clear breast nodes are a bit trickier but is uh is everyone sort of following along yeah yeah yeah so let me think we're there's a bit more clarity about that after so I think the next example is going to clarify that for you and if it doesn't we can come back to it and play a little bit more with it it is like gang like nodes and how they're structured and how they they operate within one another is the trickier part but uh yeah Branch nodes and extension nodes which are you know somewhat similar in structure are the more complicated part of that so once you get that and it kind of clicks the way they work together you're pretty much you know done understanding that that data structure so it's definitely something that's worth you know coming back to and making sure that we understand somebody yeah if you see that array of 16 buffers and two of them have have keys in them every every parent as soon as that branches out has automatically 16 children regardless of how many values are actually there and like where they go if there's only one then we can compress it down and call it an extension node but here where there's like two in that array you just automatically have the rest rest of its siblings are empty buffers uh and like I said if there's only one child to that parent we can collapse it back up but if there's at least two then you're going to have an array of 16. um regardless of how many actually have actually have a leaf yep yeah absolutely so this uh clarifies this is a bit like in in the other example but I think this clarifies uh you know what's going on so it might look a bit confusing because we're using very similar keys and values so this is actually the values and they're also you know similar but we're not really concerned with this similarity you know of the values we're concerned with we went all the way down to a branch node we had two paths that were defined and we had uh also a value that lived there so your question is basically well why is it an array that lives there right so the area contains the two pieces of information that we need to finally like get the value at the leaf node so this is pointing you know to a node and it's telling you well actually the the remaining part of the path is going to be 3 0. and then the remaining part of the path is going to be you know tree one and then the value you're going to retrieve at that you know n endpoint is going to be you know that whole thing and this is the thing that if you parse it to a string you would get like test value zero and test value a and it's the reason why when we're um trying to retrieve you know the values here we are you know taking the corresponding indexes but uh then taking the first uh not the first like the second but index number one this this is exactly that's the value now we're working with like fairly small values so the values are directly inside of the tree if you had very large values it would Point like back to another uh node that would have an encoding of the of the value that will actually well at that point it would be like the end node so it would only be a leaf so all the leaf contains is the the the last remaining part of the path that was that led there and then the full value and then again that'll be the root of yeah yeah let's do that actually so we can we're gonna create uh so what would you suggest sql1 yeah let's do that it's going to be test value you know I want as well and actually let me put like some fairly like different values so that we're not confused by the similarity of the values themselves I think that the values themselves don't determine where it is in the dream yeah so we're gonna run that again and we're gonna all that we're interested in at the moment for you know this example you've suggested is that the branch though like what does it look like at that point and then it's going to have a child that's also going to be a branch note right that's what we would you know expect so let's try I need to save it first let's try running that all right so what we see is it's actually quite similar to what it was before but instead of getting an array we're getting a larger larger buffer so what is that larger buffer that larger buffer is uh now there's two kinds of keys in vertical trees that's just a hash that points to a different node right so it's not about you know path path is still like path you know number three but to know like what's the hash of that other node that we're trying to retrieve this is going to be that so that's just the hash of the the the of the the child node that is going to be the one that contains you know zero uh what was it like zero and zero zero one right so now yeah yeah so let's see how we can go about what I'll do next is look at the path at test key zero right and we're going to look at what you know that actual node uh looks like I can also remove that all right so what do we have here what am I logging okay so if we look at those keys you have a common path that is test key zero and then you have a slightly like longer path that is that's q1 so what we should expect again is a branch node at that point it's going to contain the value itself because test key 0 is actually defined you know as a valid key that contains a value but it's also going to continue at one and now obviously we're dealing with like text conversions of this so it's not going to be at the actual index one it's going to be at a different index but for we do see that there's uh exactly one uh valid you know branch that points to uh another node and then there's an actual value here and if we were to uh you know convert that actual value to a string we would expect to get back uh whatever like gar badge I typed in there and this is actually exactly what we retrieved here and if we look at this this branch we're going to try to retrieve that you know number three thing here I can just do it so what's the index of this it looks like okay index 3 I have to do actually branches true and then this would be the remaining part of the path and this is going to be the value so if we do to string we should expect to retrieve that uh number three you know thing that we had above let's see if that works and yeah we're getting back you know uh number three uh well I kind of messed this up I should have commented this help foreign not necessarily this is just because of the uh the actual uh but very well like if I choose excited to here log in you know I don't expect people that would not index number three can you can you repeat that and you have referring to the branches in the terminal right like we have buffer placeholders and the value of the key is being shown as 0 1 2 3 on the third element is that right yeah so in that scenario the total number of uh buffer placeholders are fifteen one five is that right uh yeah it's actually uh 16. we have 16 uh elements in the array I believe it ends up the end index is 15 but it starts at zero so we have 16. the next bite got it thank you foreign so zero is actually like it's encoded as like two hexary you know uh number is only like not like a single one so we're seeing tree because that's the like second number of the zero at which point uh you know we have a value like directly there but we have we're branching out so I think if I created like another one might be a bit tricky to actually create all the cases that we'd want we might end up with the same sort of issue yeah so here we're getting again uh like you remember how we were getting like a path in the value that was because that was the only valued F now we're again getting a hash pointing to the common path of like the next one it's going to be a branch note again we could you know again query uh find the path to that and in this case there's no value at that node that's just pointing to child nodes yeah well there's a value like if I query test key O2 there's going to be again a value here but uh yeah I'm not actually sure why we're always at this index I'd have to look at the the way this is encoded I suspect it's like the always the the latter part of the number two is what's used here instead of tree itself um I can recall exactly what that is but uh yeah we in the normal like setting with like keys and stuff we would expect like every basically level to to Branch out and and the fact that it's three at the moment there's just a peculiarity of the test case I've come up with yep and lowercase uppercase yeah yeah it's not lining up perfectly too yeah exactly so if we wanted to do like if we could natively like compute you know buffers and hexes that it would be much easier to see what's going on now we're using like human readable keys so I mean they're broken down to that they're you know they're converted to hex so at each uh each part of the way down that we go it doesn't line up exactly with the end of the key there's often like one next like character necessary to to finalize that the number zero for example um all right so I'll go over so I I think maybe open up to just like general questions or um comments or anything um you know we're we're building this for you guys so if there are things that are not working or confusing or that you'd like to see where we're very open to feedback and suggestions and help yeah so like most of what we've done so far has been like working on you know just Merkel Patricia trees uh themselves a bit further down in that tutorial like I encourage you to just keep going at home and ping me like on Discord or telegram or Twitter if anything like doesn't work as you'd expect uh but there are like we're working also like with blocks and with transactions and rlp encoding uh which is quite I feel like it's how I learn about ethereum initially like to learn about these data structures and the first draft of that tutorial was actually like me learning you know about this stuff and figuring out what's going on and um and yeah um and yeah we're we're an open source project you can find us on GitHub you can find this on Discord and chime in or ask questions yeah we have a massive number of uh external contributors who've helped you know over the years the repo is uh fairly old I think it's like six years old or perhaps like even more than that sometimes I'll work on a part of the code and I'm seeing like the get blame like five five years ago or something like that so it's really like a pretty old repo we we are extremely open to external contributors like sometimes we'll have people come up and just help out and then we we you know we include them in the the team like not in the formal like team itself but we do like chat with them and are always happy to help people you know help the project we're working on uh our future projects are we're trying to improve the client thinking at the moment we only have full sync it's super slow and you know you know that would never use that you know in production obviously uh uh we're trying to do you know General like optimizations as well so if anyone like is competent that that we're really happy to like uh get you started on that or improving like the Json RPC endpoints we don't yet serve all the RPC calls so that's uh it's an excellent place to start if you want to help out just implements a new RPC endpoint for us exactly you can just go through the list of what we've implemented and just you know uh come up you know with easy ones that you want to implement and it's a good way to get started learning about our repo uh my side I'm working more on R D for vertical threes and statelessness which is you know sort of related to the Merkle tree stuff we've been uh exploring Scotty works on ultralight amongst other things and yeah we're just improving the gold base as well making it a nicer with nicer types and a better performance and the last questions that's a good point yeah I didn't think of adding that to the link tree I will uh that link tree linked above all update it with a link to our Discord so that then you can come in it's the ethereum.js Discord probably fairly easy to find as well but I'll link it nevertheless yeah I feel like one last question I had a friend who actually worked with ethereum India asking who was like telling me uh about like he also used that um is this actually interconnected just for a 3mds or it can be like interoperable in other like I don't know uh proof of proof of History like Solana or something like that I don't know if you're interested in nonsense but he was telling me like he'd use that for our RCP support uh kind of the thing how does it work because I was kind of confused like he was actually using a 300gs for connecting with Solana yeah so it's uh interesting question so there's there are we've increasingly made the our packages uh configurable so one of the things we've done in the past year is we allow you to uh provide your own VM or evm implementation so you could have a chain that is not like strictly evm or maybe that has like peculiarities or that are ECM like but not like strictly the same and you can just like parse that in when you instantiate for example the client you can provide your own like whatever like rules you have for your blockchain there's obviously like a limit to that like there's a point where it's probably better just to build something else if it's like super different but it's still quite um quite configurable so you could also like there are chains like seller I think which has like different rules for computing transaction hashes and stuff like that uh I'm not like I haven't worked with that so I'm not sure how easy it would be to configure it but you can definitely adjust some parts of the code and provide your own like hashing algorithm and uh use that instead same thing with like the Myrtle Beach trees thing we've been working with you could provide your own hashing algorithm it defaults to caca but I mean you can use whatever you want okay thank you other questions thanks for coming yeah thanks for coming [Applause] we didn't cover vertical trees here no no a preliminary learning for eventual vertical trees is what we went over we didn't cover ever oh yeah yeah this thing I really appreciate it I'm happy to hear that yeah uh yeah there's a lot of information today realize how it doesn't mean yeah I was actually getting into basketball what part of this changes when you end up with vertical trees I'm like uh that's why I guess yeah I mean we we're trying to avoid it and workshop where we just launch people through the stack because it's but I think it's just like [Music] foreign [Music] foreign [Music] [Music] [Music] [Music] foreign [Music] foreign [Music] [Music] foreign [Music] [Music] foreign [Music] foreign [Music] [Laughter] foreign [Music] foreign [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] foreign [Music] [Music] foreign foreign [Music] foreign [Music] taking change [Music] foreign hello uh welcome to the ERC lightning talks it's 1pm in Bogota in case you are still a little bit hungover or whatever um my name is Tim Annette is currently still in a podcast interview but I think she will come also later I'm quickly gonna give an overview of what's going to happen in the next I think we have like one and a half hours you can already see a bit on my like uh drawn slides I don't like PowerPoint that much um like what will be the what will be essentially like the the the content of of this entire session we have uh lined up uh as like six seven speakers including me um we are going to Center all of these uh talks Around The ethereum Magicians and specifically we're going to talk about um ERC proposals so ethereum requests for uh for for comments right so basically everything that didn't fit into uh Annette and Tim by course earlier session I think like it was about two weeks two days ago about the ethereum core roadmap so how this works each speaker has roughly 15 minutes and then we have a usually like a five minute break where we can set up the next speaker and maybe there's even like time for questions I guess um we will have some talks about timestamps in ethereum get locks from Ronin that just entered the room by chance we will have some talks about Soul Bond tokens about music nfts about yeah d-soc we will have two people speaking about the the problems in the web 3 music space about content types in in nfts and then we'll also have a very recent EIP namely I think it's for the domain separator in EIP 712 so um I I wanna I Wanna Give A before like we start with the speakers I think I wanna I Wanna Give a quick talk myself though kind of kind of like my own like lightning talk and and it I want to make it about kind of this weird thing that the ercs are which are essentially just like immutable um contracts that are almost like as immutable as a transaction in ethereum and uh the problem that comes with it which is that like we don't really know how to upgrade them and you know throughout this whole year of you know bull market and and everything especially in the uh nft eco nft ecosystem I think um you know there was a there there's starting to be this debate basically around like how can we actually do Innovation with these uh contracts if you cannot change them anymore right and so like what can we do about it and I've tried to kind of like Express that where you know like this contract uh this this document this proposal so that once you once you put it into the the final status then it's really like locked like this like this locker and we can't really unlock it anymore and so we have to find ways of like still upgrading it and that's that's what I I want to try to motivate that actually and I want to try to make like an optimistic case of why it's actually cool so but first of all I think we have to backtrack a bit and and this so this is a comment from uh I believe the the GitHub thread on Erp 2612 the uh the the permit standard that allows you basically it's like a replacement for erp20 tokens where instead of sending the approval on chain and like kind of like wasting all of this cars for the transaction envelope you you technically could sign a transaction get that gives the spending contract uh the permission with your signature and so the idea I guess would have been that new use cases are kind of enabled and that also um that also we can save a lot of gas especially like considering that you know each erp20 transfer is essentially like two transfers right today and so if we could already condense that to one I think the gas savings would be uh quite significant considering like how much we are transacting with erp20 tokens so this comment is actually a critique though on that standard and basically it I I don't even like fully know the entire history but I know that I think the the standard has like some issues it's not really in in final mode either and then you know like many uh companies have like kind of diverged from it and and they're like non-compliant like I think with this standard so it kind of shows I think maybe a a a bear bearish case for for this kind of um standardization approach and then um the other place which I had to deal with myself personally because I I crawl nfts this is the interface for the Zora M nft contract and m stands for media nft and you know I I think my first exposure to this was that I was kind of like disappointed because essentially when you call the token URI like the regular token URI you are expecting a Json and uh but what I'm getting back is the media file and so I have to actually have to actually go to the Token metadata URI and that's where the metadata is right I mean the name is descriptive of that and and so I was a bit disappointed because I couldn't like I had to basically build like this uh this like custom logic around it but on the other hand I'm also empathetic with that because uh in the regular nft the media file which has been like traditionally the image is literally in a uh Json object that we call metadata so I I mean in my opinion that says a lot about how we think about nfts and that we see the image or like the media that is attached to the nft kind of like as metadata to something that is the nft that is kind of like a maybe like a financial instrument then or whatever and so I I think it's actually beautiful that they that you know that they made the case that we should actually use the token URI to embed the media file directly and to Center really the nft around the media file and not uh make the media file a mere uh metadata field so foreign and apart from all of this uh like pessimism I think there's there's another good reason for uh submitting and and being active on this forum and it's because you get a ton of exposure to uh to your ideas so this is a threat here that I made I think around in in April and it's about uh like a specification for soul bound tokens or we now call them account bound tokens and this threat has gotten 9000 views and if you would sort by the replies it's actually the top uh the top controversial threat on the entire forum for the for the entire year apparently so I mean while that is uh concerning to me because apparently a lot of people have opinions about this it's also on the other hand it was a like a beautiful chance of of receiving feedback and also like of receiving constructive feedback which with which without that this standard wouldn't wouldn't have gone where where it went today so I initially started this um as a non-transferable token uh specification and basically now we have we have like moved into consensual minting um and into like yeah basically like having the the signature being checked by both the sender and the receiver and you know we are actively talking about all of the Privacy challenges of Soul Bond tokens and so this has really become basically like a space where this entire standard all the silver and token things everything is like very verbosely documented and and I I think it's awesome because I I wouldn't have had these ideal ideas by myself so I think this is like a community effort and it's cool um and so by the way I'm like basically these slides are all a um Eve magicians blog post essentially and I need to find a bit more right but so the so so basically one of the but kind of like one of the one of the problems of the EIP uh standards process is that it's it it's it's truly permissionless and it's open to everyone essentially because you you can just go to like the uh you know like github.com ethereum eips and you can submit your own EIP and as long as you are uh complying to the uh the formatting rules and you're like you know you're like um receptive to the to the feedback of the EIP editors and you're not like mean to them or whatever you you will actually get your document merged and that document will show up on eips.etherium.org so that's really cool um and that's really a strength but it's also a weakness and I think this uh I guess it's like a bit of a famous cartoon in the in the uh in the standards uh community at least where you know like there's like the this XKCD comic uh you know where there's like 14 competing standards for a use case and then there's this one guy saying hey that's crazy like why do we need force in standards we should have one standard that has all of the uh that addresses of the use case and suddenly we have like 15 standards right so so it's kind of a problem in the ELC process as well that we just have like a lot of verbosity and and duplication and and so on so it's like you know on one side we have like the strength the openness and also this like uh yeah it's almost like a Spam problem or whatever but I wanna I wanna I wanna still motivate and I wanna I wanna say that I I find this actually awesome and I find it awesome because I think that there's a difference between a a temporarily emergent consensus and a consensus that is more like spontaneous and probably like from this kind of like uh you know like group or a committee of experts and so I I've tried to visualize that with the two different kind of approaches the two different extremes so to say where you know on one side we have more like a market driven adoption where the individual kind of uh makes the decision by themselves they they do all of the due diligence and and they come to the conclusion that they want to use the standard and then on the other hand and this is maybe true for uh yeah like more I think like groups that have to make decisions rather quickly and and like uh yeah like close to time I think you have this basically this this spontaneous committee consensus where you know 51 can basically overrule the uh 49 and I and I want to make I I just want to uh kind of make this argument that you know I I believe that the temporarily uh continuously emerging consensus is actually the the cooler one the the one that has like a that ends up having like a stronger signal over time and that's because I I mean there's one hecky way of just like proving that and that's uh that if you consider like how organizations are run today then it's probably mostly in like this 51 51 consensus style right and then on the other side you have this totally chaotic evolutionary kind of thing that that is the market that somehow also figures out like what is the best decision but completely different and not by talking to each other and so I I think and I mean by no means is this uh Financial advice but I I would always bet on the market and not on like an individual uh uh committee actually and and so I I think that's that's actually the better uh the better approach and and and also I mean I guess it's also the reason why like much of our critical infrastructure is like running that way like I don't think there's like a you know like a central planning for the Food Network in a city or uh stuff like that um and so so the question is though like how how can we overcome this this uh this immutability of of contracts and how can we actually still innovate on those standards and and this is especially true with uh with all of the like this uh you know all of the eyeballs that that have have like went into the nft space and and you know kind of this difficulty of of innovating with the standard and and I mean sadly also with being non-compliant to the standard and just trying to grow uh externally from standards and and so I think immutability does not necessarily mean uh stagnation I I think actually there is now we are starting to see a pattern emerged where people are starting to really upgrade the standard and they're doing it in a way where they are basically like um yeah basically bolting um kind of this one lock to the other almost like a like like in a I don't know on these bridges that sometimes you can see as a tourist kind of thing so so I think um over the last half a year that has really happened so uh for example we now have a standard uh event for emitting a uh an event when the metadata is updated in in an nft standard and that's uh the one on the top right it's the 4906 that essentially just emits an event we now have a very uh interesting standard for that basically splits the user and the owner into two different groups and I think especially with you know with d-soc kind of making us aware that there are only that that there are like subsets of ownership where kind of ownership represents this bucket of right and then you know you can have fructose and your kind of users and abusers and so on um this this is starting to become really really interesting right we have like different kind of roles that could interact with the nft and then this could have like different economies and so that's I want to give a shout out that's 4907 and then I guess maybe like a a more Infamous one is the is the royalties one and it's the 2980 81 and that's basically an optional uh an an optional royalties location mechanism for nfts that is implemented I think in uh in many nft marketplaces and and again I I just want to highlight that I think it is definitely possible to upgrade uh these things and like we are we are doing that I just think that probably the time Horizon that we're looking at this and where you know we're like drawn to being a bit more pessimistic I think maybe we or I mean personally maybe I have to be more patient and just like trust in the process and um yeah I guess I have five more minutes so I'm also gonna uh of course I'm gonna shill a uh a standard that I did myself which is the minimum uh Soul Bond token and it works in the exact same way where basically we are extending and even breaking the EAP 721 interface and essentially uh we're allowing people to lock an nft so you can emit a locked event and an unlocked event depending on whether the transfer function should be should be reverting or not and then we also have this view function that allows you to always check whether a token is locked and the purpose for this is that um that if you were if you were to just use like the plane um 721 standard which actually it has a kind of like a small uh line in it where it says like that these uh nfts can also be they can be used as a reader like a read-only registry the problem is that indexes and wallets and so on wouldn't really recognize it because a computer cannot reason from let's say you know the transfers rewarding to you know this thing is like locked because it could also be that you have done like something else like something something else wrong you know and so therefore the error might be referring to something else so I I personally think that's useful and that's final now also and it's building on uh uh 721 yeah I mean now I'm at 17 minutes the next we're gonna have the next speaker um thank you for also giving me the chance to give this little talk and um I want to ask to Stage Ronan I don't know if the exact pronounce it thank you Do you have a um because otherwise we also have other things and then so you have it I will update it if you want and then this words we are a bit before times like so I think it's fine it's fine I'll turn this on foreign okay thank you for coming here um so I it's a yo I'm going to present a very simple proposal and kind of to explain it I wanted to show a demo and I wanted to show it in real time but the Wi-Fi make me so made me realize that I should probably uh have it already done and show you the result um so basically the proposal is to improve so what I'm building I'm building a indexer so that kind of take all the event of a contract and contract the state which is our most a smart contract system under State for the claim for yeah for basically having um that's all about it and most projects use a backend which is at odd with the vision of of decentralized application so yeah my idea was simply let's index in the browser and of course uh it doesn't work for everything um because of the scale of some of these of these systems so for example if you wanted to index or the nft uh you could do in the browser but it will take a while um but for some other case it actually worked very well um and so I was doing so I have this game so the whole state of the game is actually here so you have all the fleet is this game in space you have planet and fleets again there's two main things and it's like I think this state is around seven megabyte but it's not actually I didn't Implement a full uh so I have an index I have the same index of running on the graph um and I didn't finish to implement it fully here that's why I expect maybe to get to 20 megabytes of State um and I can on a normal Network I don't know what normal means but it cannot it took five seconds to think the whole thing and if you can obviously um uh but I made an assumption that uh in my in my game there it is notion of time so every event um so the state the the contract will kind of lazily update per time and I think it's quite a common thing in it's my contract and unfortunately when you fetch the logs which is a mechanism by which you index and manage to get back the state all this event basically with um you don't have access to the timestamp at which they open it's just some reason they didn't so to add that so there is a blockage block number but there is no block timestamp and so my game actually when I uh I need the timestamp and so because I don't have the timestamp in the logs I get like 20 000 events here and what I need to do then I need to request 20 000 times um depending I mean a bit less because you can have uh same event an event in the same block but you I have to request that on top and because it's a in browser indexer it use eip119393 which is like the the wallet interface and I cannot do bat request I have to do all these requests and so uh I have this version we actually still running from last time and sometime here I would because the RPC is not a piece that time so the RPC of metamask because again you have it's a juicy static web page there is nothing no back-end um and it all only rely on the fact that the user have a eip1193 wallet in that case it's metamask and if you if you look at my settings It's actually an RPC uh somewhere else but uh so it's still querying all of these to get the timestamp while the other one had been finished a long time ago and only actually you see 580 request is actually 300 because the other one now is just to get the latest block and nothing is really happening in that game right now um while this one is still like fetching the the state so it's going to reach probably 20 000 to sync or maybe even more um um yeah so so the proposal I wanted to show you a kind of a really example but the proposal is um is basically to add this to the Json object so it's a very simple change you can do in a in your node so in goatorium or what whatever and so actually finally enough uh like team pushed me to go to the core Dev meeting the other day and actually I'm going to and so we are doing interesting discussion about it but um so I kind of you must so what I could do is that I could add the timestamp to the to the event itself uh but obviously when you do your contract you know that there is a block information so there's no need to add the timestamp to the event it's just a waste of gas um and time is an important aspect of many smart contracts and block number cannot be a replacement for them and the reason why is because uh block number timings can change across chains but also there is no guarantee that a single chain will not keep it and you could probably emulate an average block time using smart contract itself but it's kind of a ugly work around um and black block times them already easily available like the block cache or the block number and another so I've been discussing about a few people here but this is extra data you have to put in in the log object uh but it's small and the alternative is to to fetch all of these anyway um so of course for the one we don't care about timestamp then they they have an extra a small but I feel it's small enough uh I would also consider alternative but I will not consider as alternative actually I could consider them as complemented uh so when I mentioned them I'm not saying I don't want them actually I want them um but I feel they they will not replace thank you um so yeah basically when alternative is to add batch um about API for Erp 1193 it was actually part of the conversation initially but it was dropped but I think it's it's a valid one to have and but my opinion it doesn't offer the same Advantage as having the Block timestamp in the log um and another EIP that I didn't see yet uh is to have a great graphql API uh so basically an alternative to eip1193 and with graphql you can ask what you want which make it more efficient as well uh for transferring data so if you don't care about the timestamp you don't need uh and actually this one could really by actually solving the first one so this one is really an alternative but I I don't see any reason to just um add another one especially I think graphql is not reported in all the node implementation today um and so as I say I went to the call Dev and we had the feedback and the main feedback was that hey there is no point to do it because we are going to make uh the logs uh not being accessible after a certain time and so the argument was like you will never have that many log and so requesting the timestamp anyway won't matter uh and so my reply is that uh so it's an easy change uh so my next section would be to make a PR I guess for goiterium um and and the number of log actually can still be significant um so even if we remove pass log we still want to to have access to them but actually the main issue with that with that feedback is that we need to really think how we are going to solve the state access about um if we we don't have access to past logs how do we are going to index uh in a decentralized manner um because of course if you have a backhand you know you solve your problem but we we don't want to have a backend right you want to be able to use tornado cache from your browser without relying for with only relying on your node and so so I think I don't know for me that I would like to to have discussion as a community how we can so solve that like I know there is work on the uh around like right now over portal since portal Network um and so but I think it's important we um we understand like the point of view of application developer that don't want to be involved with our application once it's launched um and um another thing yeah so I mentioned like most systems are already rely on the log events so we need this system anyway and even some EIP have been using it to kind of speed up the the need or kind of minimize the gas cost which is eip1155 like you can't query the balance of all the token that the user owned from the smart contract and so you're always a smart contract to be more efficient and it's because it has been the result of everybody acknowledging that we use logs and event to reconstruct the state um but that interestingly one of the things about in the code of meeting was that that was not the vision initially but now we evolve we understand what we need and so I think yeah that I I would land with right with like yeah let's discuss about how to solve this being able to rebuild uh the state from from the client it's kind of all for me yeah any question thank you thank you Ronan thank you for close uh do so we have uh we have time for questions uh do we have any questions Getters in the contract what are your thoughts on using Getters in the contract as opposed to events to get the data for a UI yeah so so far I I can talk about my game actually on that one so the first version I really wanted to launch the television without any back end so the first version of the game the first Alpha uh I didn't have an indexer using the log and I was fetching all the data and it is not actually is not efficient either because uh especially list of things and and you are wasting gas to support that in many cases like so this is uh what I mentioned eip1155 not having access to the balance and we could also think about um yeah seven to one um innumerable extension which add actually a lot of gas costs overall um so I and I think from what we have seen everybody like even to to do that role so I think that's what we should do and minimize the role of the yeah minimize the gas costs we basically that was when we minimize the things that happened on the Chain if we can do it of Shane but these assume we have a system to retrieve it that's why I think it's important to discuss because maybe the conclusion is like oh actually we cannot and we have to pay gas to do that but I hope it's not the case any other question no no can I go speak okay questions thank you um okay uh hi everyone um I'm Annette and I would like to quickly just say um hi to you uh and I'm sorry for being late I was recording podcast uh so I just ran downstairs from a recording uh but I would love to welcome you guys on this session uh it's been a pleasure to host this one with Team um who is a huge um like uh who is yeah no uh wait um you're very involved in the nft ecosystem um and I'm just going to quickly introduce myself um so I'm in it and I used to work or I used to create the nft standards the WTF uh documentation for all nft related erc's I did a huge research on that I wrote many articles which are up on my medium I'm sorry I don't have a slide uh because I wasn't really not thinking about this um also this session uh we like put this together when I was literally on my flight down to the Bogota from Europe um so this was like extremely last minute and I'm so grateful for you all to be there uh as this was like totally like last minute we literally put it up um like a couple days ago um and I'm just going to probably quickly uh just tell you a little bit about like erc's especially is there was a lot of misconceptions uh between like what is EIP and what is ERC and I'm just going to use my article that I released coupled weeks ago you know like September 14 which was like a month ago uh which was the guidelines on how to write an IP so I'm just going to quickly guide you through this um a specialized I noticed that there isn't many misconceptions of like what the heck is like AP and what the heck is like ERC and what is like the difference between AIP and ERC um so EIP stands for ethereum improvement proposal uh and um it's sort of like a standard or it's like a way how uh standards or like improvements or like the ethereum itself gets improved uh there are many categories of eyepiece itself uh one of them um is the ERC ear systems for ethereum requests for comments um and that's sort of like uh the main thing uh and the erc's are also the application layer aips so if you guys are building anything like the application layer like decentralized application if that's uh not a like a familiar word with you um so that's what ERC stands for and then um oh my gosh what I'm even gonna talk about I'm sorry I did not like prepare anything for this uh but um what I'm just going to talk about is probably just check out the wiki there are many uh cool things in the wiki itself but there are many cool standards uh also ERC um 1155 is probably my favorite ERC is that something that people ask me for oh my gosh I'm talking so random um sorry uh but also huge could also attempt to like putting this session up until like inviting you all to speak uh and to have a lightning interview you guys all opportunity uh to just tell us a little bit about your ERC itself um and especially I'm very excited about the development uh that steam has been sort of like pushing from the cell bound token perspective uh but also from like a is from nft standards Community we just started like a in like um I don't know two years ago I think um many different communities emerge one of them was the music nft uh Community which is a very huge one uh and I'm not sure if we have somebody from music NFTA industry here okay we have the two speakers there awesome thank you guys for uh presenting music and if this here uh it's amazing to see a music NFD space involved as well from the standards perspective but then also the soul bound tokens which uh for me feels a little bit controversial like are salmon tokens even like nfts itself I would say probably not even but that's maybe too controversial take um and then like a bunch of different um how much time do I have okay um no I'm like talking so Random uh but I would say um just go to my medium and then you can like find a bunch of like other stuff there um yeah my recent article was unlike do's and don'ts of the AAP writing um or like how to write AP which I highly recommend you all to check out I can like share the QR code afterwards with like the article itself uh if anybody is interested in that uh but then yeah definitely check out the wiki uh that's where you can find all information um I don't think so I if I have like cell bound tokens there because I literally had no time to like maintain the wiki lately um because I just learned another mind like a month ago uh but I'm very happy to see more people to get involved in the community and like um taking like sort of taking care of my baby and like pushing it forward and I'm very grateful for even like as I see Ian there from Zora and he was one of the first people who got involved with the NFC standards community and he was like very happy to like answer all the questions and like in like get engaging the discussions in the community and I'm extremely grateful for you all to have you there until just like speak up and like represent the AP itself and like improve the ecosystem from the uh ERC like the ERC ecosystem and like building up on the nft erc's and I think yeah we have all of them uh should be like uh the NFC related erc's so thank you all for um taking the baby that I basically created the nft standards Wiki in the community I'm like I'm building up on and um to all of you for like showing up to this session and representing and um especially this was like extreme last minute like guys like wow thank you thank you thank you Annette and uh yeah next speaker please Raul uh Raul is actually going to talk about uh a standard that I have co-authored so I'm very excited about this foreign [Applause] hello everyone I'm gonna start my timer so I have a reference point here uh yeah this is my first time actually talking at Defcon this is my second Devcon um I'm super happy to be contributing back and sharing knowledge and the sparking debate and ideas so thanks for having me and thanks Tim for organizing this as well Annette so today I wanted to talk about uh eip4973 Badges and de-financializing towers and Beyond as well uh so firstly a little bit about me my name is Rahul I'm co-founder of this little baby company that we started called autospace uh and I've been in the crypto ecosystem since 2016. I started off with my journey also with music I was building nfts to assetize music royalties back in 2017 did not work then moved on to SoundCloud got fomo with those and I got back to crypto full time now um so I think I want to start with uh how this year had started actually like uh we think that there's this paper called decentralized Society uh and it centered our attention on this notion that web3 centers around uh expressing transferable Financial assets rather than encoding social relationships of trust uh when everything is transferable things can be sold to the highest bidder so you know we wanted to challenge that uh and that's that's what that problem is what gave to this idea and working with Tim on this EIP uh what we call account bound tokens not to be confused with soul bound tokens or you may be but semantically speaking we kind of uh you can Define this as non-transferable tokens bound to an account and then our goal here was to really it's very semantic based again like to create special ownership Deeds or creating like permission Primitives but really to create a new ownership experience uh through this primitive you can read more about this uh we have written a more extensive uh article on this uh however ever since we started we saw we noticed this account on tokens uh debate had kind of like exploded you know there's sold out tokens there was Community bound tokens ens name bound tokens now human bound tokens uh what we're actually seeing is this non-transferable tokens is a spectrum and you you can Define what is being bound to and what is that binding strategy and you can kind of uh this is this is where the explosion of ideas are topic and as a builder I feel like some of the nfts nft spec is kind of over optimized for what we actually express our ideas through so we're kind of like craving for new tools and new uh new instruments to kind of like uh build our ideas right and at autospace we we call something smaller something simpler we call them badges which is powered by eip4973 accountable tokens so uh I want to dive right into it like because because ever since Soul bound tokens was kind of like really a Hot Topic it kind of did sparked like a lot of hot debates or uh and it's it's debates are great like because uh it really helped us intellectually navigate the space and like get like a pluralistic opinion uh from various uh parties uh one of the first things uh or concerns they put out like I think was permanence you know what if I don't want a sold out token or an account about token you know anymore and the second one is a lack of consent what if I get an nft like that's non-transferable airdrop to be with my uh personal details you know what would happen you know and key rotation you know like I I what if I lose access to my key wallet or I want to like I mean uh to my wallet or do I want to change my wallet and lastly this more popular active debate about like uh verifiable credentials and abts on Chain versus off-chain identity uh so lots of things uh very simply put uh there we've written again lots of uh detail on this but I can kind of summarize this uh these were the design decisions that helped us the input into erp4973 so permanence when we talk about uh in general what we baked into it is uh burning and dissociation from the so the owner of the Soul bomb token or accountable token can dissociate from uh from the token itself and then lack of consent uh non-transferable tokens through or commonbond tokens cannot be air dropped you need to have a two-way consent which I will dive into a little bit later and with other space we're actually actively looking into recovery mechanisms like Community Based recovery especially if you lose access and you have all these non-transferable tokens and lastly avts versus verifiable credentials use both really it's not mutually exclusive uh they have like good use cases and it's really we're in the early stages of kind of like the debate and application so I'm kind of excited of what would actually come out of this next year uh so like on a very high level like I'm oversimplifying this but like you can see the key differences like if you look at like various uh angles or various uh Dimensions right if you like a transferability consent removal issuance uh exploration and fungibility but I think uh I want to bring Focus to where consent and issuance uh that's that's really what we wanted to like did not want to compromise on there when it came to a non-transferable token design so let's Dive Right In like so this is the erc4973 at a glance you could just npm install that very easy so that's a very uh very light interface right like it's just expresses so we can kind of like dive into what this uh actually does so firstly this top section right this transfer event balance off on or off this is this was mainly to ensure backward compatibility backward compatibility to nft in general so we actually implement the ierc uh 721 and my metadata uh so one of the things that building this EIP actually it was super amazing learning experience uh we actually didn't have the transport event first and then we were kind of missing all these stuff like etherscan was not showing the log events for example or metamask was not showing the uh the the interesting metadata so we we actually started using the transport event which is such a simple change everything started working automatically you know like uh the support the interoperability actually came came for free and that's one of the reasons we went back to the transfer it although in a non-transferable event token you can argue that transfer has no makes no sense but this was one of the design decisions that we learned like to kind of Ensure backward compatibility uh and the next one and this is really the where the consent really comes into play so if you see the function there's like three three parameters right like the from the URI and the signature so we call this the take flow so you cannot actually mint in a compound token unless it's two parties involved so it's like a peer-to-peer fully mutually consented protocol right so you can think about this as like okay Alice designs and ABT described by aspect which is hosted by the token URI Alice then wants to issue the ABT to Bob uh Alice can only do that if this if if he signs using aip712 signature and provide that's capturing her consent so now that one party consent is established Bob can now take the SVT he would then basically authenticate by providing the circuit URI the signature from Alice and then prove that I can take this uh so this is in Auto space we actually call this the allow list flow so I'm just like adding people to an allow list I'm like signing uh people for to a badge and the give flow is actually its inverse uh it's uh it's when the when Alice designs an ABT Bob wants the ABT so signs it and then Alice can now give the ABT to ball so this in all the space we call it the airdrop flow so if you if you give a badge you can just like basically I want this and 100 people say I want this you can actually do an airdrop through uh through an account Bond token and the last bit is this one it's uh the unequiv this basically means complete dissociation from the account balance token so only the owner of the token can dissociate so that these are like basically the fundamental building blocks that kind of like help those uh create this very bare minimum uh very simple very highly functional highly utilitarian uh EIP 4973 and then Auto space we are kind of like building more flavors or more layers around it but this all the what this had served at the fundamental has been working really good for us so far and I also call uh actively contribute to the EIP and uh yeah it's been super exciting and learning in general so moving on to the other side of what that the topic I wanted to chat about as well which is the financialization right at Auto space where like the badges we see this in like six six areas how we can use a non-transferable token a membership model non-financial rewards uh and recognition onboarding quests to end with the badge assess the reputation uh more nuanced governance models and then unlock access permissions of these batch holders but I want to bring attention to this script this bit of uh that's non-financial uh rewards and recognition I mean I think we can all agree that uh the ecosystem is like hyper financialized uh and we want to challenge that status quo like you know you if you're in a position of wealth and influence you can buy tokens and if your community is basically to design their governance on a one token one vote system so person of influence can basically assert their entire influence through that power so it's basically plutocracy right so we want to challenge that and we want to move towards more towards the one human one vote but uh for us we see the one account one vote as a necessary step to kind of get to one human one goal uh and then this is really Fresh Off The Grill right this happened like a few days ago uh the mango markets uh the hacker exploited mango for 100 million hacker turns around uh opens to return the funds and he used 32 million of those votes to say yes to his own proposal because he had those and then executed that proposal and I think we can do better than this right like uh it's a that's a no-brainer I feel but really the takeaway that I wanted to kind of uh here have here is uh let's move away from the one token one vote system and away from plutocracy and uh I think let's let's let's explore new forms of governance I think it is no one-size-fits-all I think we're in a stage where the ecosystem is growing so so fast and we as Builders we we definitely need more uh instruments at our toolkit we need to spark debate yeah apply rigor get feedback so I'm glad that I'm kind of like getting a lot of that here and they've gone so that's uh that's a lot that's it and that's a Dali otter we are uh we don't work we just create these value orders most of the time uh we are as surprising my team is surprisingly good at creating daily orders uh you can scan this uh it'll give you more information about us uh yeah that's that's it thank you thank you Raul um we have some time left three minutes do you have questions ah yes okay hey um can you elaborate a bit on the account through the recovery part yeah absolutely so um so one of the things that account recovery uh it actually came up pretty actively in the debate like hey if I have badges in my account if you have non-transport work tokens what if I want to rotate my keys uh then how do I do this and that's one of the criticisms that were pointed at sold down tokensen initially uh quite frankly I feel this is a this is not a soul bound problem or a soul bound token problem this is a entire protocol ethereum program and I feel like we need to wait until we need to do this better and then we can absolutely adopt it but we are looking at two ways of recovery one is a proactive recovery and a reactive recovery but we are offloading this to the community in our protocol at least so it's basically like moving from moving your phone like if you're import you're putting your number uh from one phone to the other so you're actually doing a proactive action so you have to kind of like prove that you are the owner of this account and the account that you're porting over to but the way we're thinking about this is uh you can't transfer these tokens but you can burn all the tokens as the owner of the current account and you can get it reissued through the the issuing authority which is generally the communities or Dows the other aspect is reactive recovery which is where like I lost everything then you know that's a tricky one you have to establish with your uh like your dial for example that hey I'm the same person behind this new wallet like you have to re-issue it and one of the models we are looking at there is reassurance but the community perhaps can revoke those badges so that's that's how we're kind of thinking about it thanks more more questions we have time for one more question hey here oh okay um uh just a quick thing regarding um uh recovery through burning and then reissuing it would be awesome if there was a way to do that atomically yeah right but the other question was what is the status of the EIP is there a time to still make breaking changes uh or is it already like so widely adopted and this kind of relates to the stagnation discussion but I think it's yeah that's a good question I should have actually uh put the stats on it I mean uh people are already using it we've seen uh I don't know maybe like a 150 300 hits on probably somewhere on GitHub so we are actively thinking about backward compatibility when we're adding but the EIP is in review stage at the moment uh yeah when and now we're kind of talking about expiration uh as a as to be baked into a badge where you can give like a 30-day expiration badge for example especially if you're like joining a dial you get guest badge for example you know you can do some interest action so expiring badge is something we're looking at but uh yeah like we are this is one of the forums we're hoping to get feedback on like you know where should we park it should we get feedback or have invest in extensions and like uh because there's a lot of utility this can deliver in its current form you know and then uh it would be uh strange to perhaps like you know stretch this timeline because I think uh I've seen aips go for years thank thank you Raul uh Applause please thank you uh yeah um I'm just gonna while the next speaker Sweetman is um going to set up the uh the laptop and so on I'm just gonna walk you through the rest of our timetable which is by the way here so uh next up is uh sweetman.eath and he's going to talk about uh music the music nft engineer uh then we have Andres who is going to talk about uh web3 the web 3 music nft multiplayer problems I'm very excited about that I think it's uh like it comes out of water and music research then we have Ian who is going to talk about uh Rich content types in nfts and then finally we have Francisco who is going to talk about a uh like a very recent EIP called 5267 I think which uh I think it defines the domain separator of EIP 712 so yeah if you're familiar with that I guess it's you you kind of understand what this if not then I recommend going to erps.etherium.org and reading up on it um uh yeah okay just um so give a warm welcome to sweet man thank you like sting testing first quick question can I get audio out of my HDMI too yes or no thumbs up thumbs down yes no see foreign while we are setting this up I'm just gonna talk uh yeah okay audio function okay got a little background music I'll keep going just so that uh it's not just me up here talking no okay audio is only going to come out of my computer so we won't be playing that but I do have a lot of music nfts for y'all today so first I'll ask a couple questions who has a music NFC okay who owns any nfts on optimism who owns nfts on arbitrum who owns nfts on polygon my goal is by the end of this you will have your hand up for all of those hi I'm sweet and daddy aka the music nft engineer and today we're going to talk about music metadata first the problem you're going to see QR codes throughout this the ones on that side are from musicians in Latin America if you want to support creators here in Latin America scan that buy the nft support local creators on this side you'll see cc0 music nfts 100 free mint on different chains and so they'll be scattered throughout if you want some nfts momentum the problem don't worry the same QR codes are going to be a little bit hidden in here music platforms are not creating music nfts this is a very spicy take that I like to hold you'll see on the your left side these are metadata from the top nft platforms up top you've got Zora creator in the middle you've got catalog and down at the bottom you've got sound you'll notice that they each have different metadata but honestly there's no real differentiation between the metadata of a music nft and a normal nft in most cases over here on this side you'll see the music metadata standard this includes the same attributes as a normal nft in addition to attributes that matter for music attributes like lossless audio attributes like BPM attributes like duration these are things that matter when we're talking about platforms like Spotify or Zora wanting to index these nfts and to be able to differentiate between a music nft and a normal nft why does this matter when we talk about ethereum congrats we're in the ethereum Wizards room we have merged and so now the next kind of goal in our identity crisis as a community is how do we get Global adoption I see music nfts as the Trojan Horse for ethereum adoption while a lot of people don't care about nfts most people do care about music and so if we can build platforms that allow music nfts to plug seamlessly into the existing infrastructure we can allow for more and more people to be consuming the ethereum technology that we know and love the Big Challenge right now is that musicians are using these platforms that don't really differentiate metadata between normal nfts and music nfts next the opportunity another set of nfts oh yeah the last one I'm sorry I didn't I didn't shout out the Creator so the last Creator this first nft is caspiel we've got Colombo in the audience um manager of cast peel and so that nft is from a musician named caspiel who dropped on Zora Creator and that is a music video of her latest music video reflejo and uh all of my music nfts are cc0 from a musician named Sagrado based out of Mexico my favorite because he does everything cc0 this next one over here we've got another Zora nft um I think we've got tranky in the audience who helped a Buenos Aires Creator named uh well created a platform called unun and so if you scan this it'll take you over to Unum to Mint some music nfts from local Buenos Aires creators and this one is another one from Sagrado and this one I believe is on polygon last one was optimism this one's on polygon the opportunity we have an opportunity right now to standardize music metadata right now it's been in discussions you might have heard about telegram groups you might have heard about different chats that are scattered amongst the music nft ecosystems maybe you've talked with Hi-Fi Labs about their music nft standards maybe you've talked with Zora there's a lot of different standards out there we have not really reached consensus and I find that awesome because there's no gatekeeper there's nobody that's telling us this is how it is it's very much a bottom-up what does each Creator want to use when they're making their music nfts and again the full music metadata standard over there on this other side how you can help again the music metadata standard is not something that we're gonna have Sony or Warner or some record label is going to come down and say this is how it is it's going to be bottom up from the engineers that are building from the creators that are choosing what platforms to build on each of us as individuals is choosing which memes we want to propagate in order to make the mess the best metadata win the final set of nfts we've got this is a catalog nft from a Creator named hey Bella who is also based here in Colombia in Medellin and this one is an arbitrim nft the same nft um by Sagrado spread the memes all the ethereum Wizards all of you Builders we are building um it's important that we propagate proper music metadata when we're building if we're giving these musicians poor metadata we're setting them up for failure in the long term as Spotify as iTunes as these other big platforms the future tapes the spin amps are indexing music nfts if we're not putting beats per minute if we're not putting keys if we're not putting the credits on chain we're missing out and so what I've been working on is I cloned the Zora metadata render which is an architecture that allows us to decouple the ERC 721 the erc1155 all the tokens we know and love from the metadata that they represent and so we have a full music metadata standard that's fully on chain deployed on ethereum mainnet polygon mainnet optimism mainnet arbitrim mainnet as well as test nets for all those Chains It's live the contracts are verified it's fully running on a platform that I built called decent um and so what I'd like to ask the community here I'm not very familiar with the IPS I'm not really familiar with what we do as a community the formal way I'm really used to building with the musicians on the ground I don't know if we need an EIP for like proper music metadata for us to get aligned I don't know if we just need to talk with the Zoras to properly plug in the music metadata render into the Zora stack so that musicians can use it maybe it's just me writing an EIP with Hi-Fi labs and getting it plugged in there there's a lot of different ways we can propagate this meme out into the ecosystem I don't really know what to do and I'm not going to claim that I'm like the king of all this I just would like to have the conversation more um and so I'd like to ask for help in propagating these music metadata memes so we can help musicians adopt this technology so that musicians can start leveraging these web3 rails that make us and the technology that we love so powerful and groundbreaking and like fundamentally changing the world that we know and love that's it Viva La Musica these are all the music nfts that I showed throughout and then these are a lot of musicians that are based in Argentina and Buenos Aires in Argentina as well as Colombia that I work with on a regular basis and so if you want to talk to some musicians that are based here in Latin America and you want to like get their thoughts or help them out or talk to them about the music nfts that they're making I've attached all their Twitter handles above so please reach out to them they are the people that are on the ground doing this I am just some random engineer that's up here talking to y'all so uh with that we've still got 10 minutes so I kind of zoomed through that I will leave the rest of the time open to any questions from the community thank you sweet man Hannah for clothes [Applause] so do we have any questions in the audience raise your hand if you have any questions yes hi um I was wondering like uh how what was your process in navigating to to the EIP like how did you gather information about like music metadata is a very complex structure right like uh and there's not having consensus over metadata this sounds like a classic music industry to be honest so I was wondering like how was your process to getting to the the stage and the EIP generally to be clear there is no EIP right now this is this is a bunch of blank data I copied I took a screenshot of eip721 and I blanked out the data to just kind of like put the meme in your head as something that we can do I don't question back to you do you think this is something we could do with an EIP or does this feel like you say like the music industry is too decentralized for us to come up with an eip4 music metadata standard I think yes uh there is one part that's probably up for uh like off Chain versus on chain I think if you have that perimeter very clearly uh I think this is this is exciting yeah in in an attribute I didn't talk about all of these uh all of these decent nfts 100 of them metadata is on chain so one of the awesome Parts about l2s is it's incredibly cheap to store all metadata on chain and so we can store that entire music metadata on chain for less than a penny and so musicians that are based in Latin America cannot afford to do transactions on each mainnet um but by offering them these rails to be able to create music metadata we can also offer them the opportunity to put it fully on chain so that there's no trust needed in apis like what sound uses or even like the delay you get by uploading to ipfs if you're not using a dedicated Gateway when you store it all on chain you get that instant availability that you get on optimism arbitrim polygon and the other l2s thank you more we have more time for questions if there are yes um it wasn't clear do you want to write any AP for this or do you not want to do that I'm very open to it I'm I'm here in the community I my entire life is music nfts and so if the community decides that we want an EIP I'm about it um I'm I'm very much of the belief that I don't I don't want to say like this is the way I like hearing like the music metadata standard I didn't come up with that that came out a catalog and I'm just propagating that Meme because it's in my opinion the best meme yeah no I I think um a great first step would be to public like it seems you've done a lot of research to publish that in some written form maybe in the ethereum editions form uh to just kind of keep it make it visible and someone else can then maybe pick it up and formalize it and learn EIP that would be very valuable and I I want to offer a counter I don't think that you specifying something and standardizing something would be like imposing your view of things in the world it's just offering an option right and whether that's adopted or not depends on on the on the rest like you've said but having an option that is uh there and specified and like standardized is extremely powerful and I don't think it's imposing anything in any way thank you do you want to take more questions we have more time love to especially if it's from Dan hey um it's quite funny uh because obviously I wrote they bought a music report yesterday they came out on this subject have you not read it yet I have not interested because there's definitely points of conflict between how we're seeing this um and for me having worked like Russell has inside the Beast as it were um one of the biggest issues in music industry comes around multi-party consensus around data points and also conflicts and that's always been my hesitance about putting everything on chain um because it it makes things much more complicated to and it also creates friction around how much you can actually trust something versus if it's housed somewhere else in some kind of on-chain registry that can be updated by multi-parties and so that's why my feeling on this has always been that music nft data should be minimally viable and contextual Rich data should be kept elsewhere but in a fair way if that makes sense so just interesting what you think about that what are your thoughts on the um the metadata render architecture that zores put out where the Creator is able to there's a trusted party um a role that is able to go back in and update that metadata when they choose does that make a difference or you still think the best solution is fully off-chain well he decides who the trusted party is the creator but what if there's multiple creators I'm excited to hear Colombo's talk on that yeah this is the challenge right and then you've got different marriage providers Publishers uh producers um all these people who are part of this Rich soup of um influence that creates a piece of art at the moment the music industries were in a pretty nice place but it's usually being one person putting something out um but gets complicated as soon as like that expands right um and I think like it's really important that as we're thinking through this we need to be you know thinking for like Mass adoption and how to deal with that Point well taken nice we uh yeah if you are taking more questions we have two more minutes yes okay yeah tranky um this is more just a comment about whether or not you want to do like an EIP or something I was in a talk yesterday that was like see something called like c a i p it was kind of over my head I'm not gonna lie like Captain but it was a different type of like Improvement proposal sort of like Coalition about self-related like l2s and things I mean and addresses so it could be they have the GitHub that's like set up so I think an initial interesting step could just be Fork their GitHub and turn it into like a music metadata IP thing mmip or something I don't know but yeah just a suggestion yes so here's the catalog standard um and you're talking about cap 19 is like cross chain assets in here we have references to other uh types of assets and so you'll see in fields like artwork you have a URI and a mime type which is very normal but then you also have this nft field which can link to other nfts and that follows the cap 19 standard of cross chain so you can actually link different nfts like for example all the nfts I just made from Sagrado are derivative nfts of an original nft I did not link the original nft and that's a downside on me and I'm going to publicly say that like I could obviously do better but the standard is already up to date so that if we want to link other assets within our nfts we can and so when we're thinking about composing nfts as music that's built on top of stems or music that's built on top of other music or a remix that's built on top of music that's built on top of stems the metadata can link back to those underlying works so that we can always be pointing the credit back to those original users did I miss the point of your question I heard cap 19 and I wanted to show this mainly referring to the structure they have like on GitHub for like organizing Community like input so I think just like forking the GitHub they have would be a great place to start if you were trying to like start the process of figuring out how to like you know just like coordinate between a lot of people forking their repos seems like a good place to start just start housing that information in some place thank you yeah that's it we don't have more time so thank you very much Sweetman [Applause] and next up is Andres and we are staying actually in music and now we are talking about um the web 3 uh music multiplayer problems and I'm very excited about that talk as well yeah exactly take a water and you um so can we can we get the picture of the we have to do it in front so I think I'm not sure how to know I think because you're on the broken mirror in the screen so you you have to move the window to um wait go to the Sea level sorry I didn't see you where is your mouse foreign do we have to go to this place right and then mirroring or get the windows you have to change the arrangement I think I think if you mirror on the screen then uh okay yeah that's why they usually say you need to you need at least five minutes before a talk to just figure out the monitors and stuff so but we managed and yeah here's Andres here's a microphone thanks hey not a lot of experience presenting but um here we are so we started off a few months ago a in the whatever music Dao researching about splits and um we basically got two or three main conclusions some of them are very obvious some probably not that much one is that a blockchains can serve as a login as a log of information and hopefully look into the future even like a global jurisdiction notary system with a legal validation the second one is that a blockchains have uh the the abduction architecture is a based on a single a singular point of uh connection or entry for the user and the third one is that a splits protocols as we understand them in blockchain are focused on distribution of funds but us creators think about splits more on visual so what is the problem the problem is copyright right we all know it's the problem and it is the solution and copyright law has been used and has been abused but it's still the only a or the or the most widely used form of monetization of intellectual property right and if we're looking to the Future where each time we have less and less a jobs available we have a growing Creator class we need to keep copyright as one of those essential uh ways of monetization for creators and the the copyright industry is big is played with with problems but to narrow them down it is mainly a human problem like it always is and it is that people do not register their intellectual property as close to the moment of Genesis as possible which is actually the the best way to protect intellectual property and um so and this is maybe because creators think that registering or then speaking about legal aspects in the moment of creation kills the Bible so uh that actually gives birth to a lot of problems I like I've been up you know like I've had problems with uh a processes in which I have been in a studio I'm a music producer so I have been in a studio uh We've made a hit song everybody is super excited right the process as it is done it is that um a at least in music creators get together in a studio and uh they songwrite they beat make they record and then they they bounce off the audio program which is a a WAV file or an MP3 and then that MP3 gets shared among the the co-creators and it's either emailed to us or it's uh WhatsApp and we can listen to the music or what we made and vibe to it and uh hopefully the next day know if what we did was whack or if it's a hit record right um so personally I have been in those situations and I have been muscled out or cut out of hit records because the more Savvy people will head out and register the the copyright of the song and this is a story that kind of like repeats itself endlessly in um in music making so what would the ideal process be the ideal process B would be to register to have a mechanism to register the IP as soon as possible Right in a nutshell a in a nutshell it would protect the creators and hopefully in consensus be able to register this IP in consensus right so we have a solution right we have temp temporarily called it a copyright wallet and a copyright wallet it allows it's a tool basically it's a tool that is inserted in the job to be done it's a you know like a small sharp tool that is inserted in a job CB down process and it allows for in multiplayer mode deploying uh registry time stamping or registry on the blockchain of that intellectual property so this is the sign coming from a musician right but in essence what it is is a an application an extension an extension lab that would uh register the title of the song let's say in this case the ownership splits of the participants and a mechanism to drag and drop the media the same way the uh a a a chat with you know like have access to to listening to a voicemail or or a shared audio the mobile wallets of the participants would receive that audio and they will receive a notification too accept or deny their participation in the in the in that creative process and if there is consensus then a smart contract is deployed and the non-transferable nft is minted as registry so and before we go to Future iterations I would like to obviously uh I think this is time better spent if we if we open up a discussions because I mean this could be a a tool that uh obviously expand and is composed on but I would like to basically just open the two questions to see if uh if uh if we can get to a technical solution because the question that like the questions that we have is in the main question we have is does this really need to be a wallet or can it be a can it be um built in a simpler way so thank you Andres um do we have questions feedback raise the hand please yes you thanks um maybe we could go back to the previous slide I just had a question about like what you're saying in ownership splits and it's kind of related to what you were saying where like ownership splits are more than just like who's getting what percentage of like mint revenue or something like that it's much more so when you're in that top left corner when you say ownership splits are you already like envisioning this like breaking down into like mechanical and like publishing royalties or are you trying to not necessarily be skeuomorphic and instead do other types of ownership splits or what's what's the idea here I guess a greater question not just how much of the current music industry are we trying to recreate on Chain versus maybe moving to stuff that's better in some way not that I even know what's better but yeah yeah that's a good question and and the answer would be a either we um one of two answers I'm guessing the the Dynamics uh the current Dynamics are more of like you songwrite and you fixate on a on a recording immediately right just because the tools are available so people are not writing songs with their guitar but they just fix like they just record them immediately and that is just because we have the tools to do it uh unlike before we used to like Write Sheet Music or or write song lyrics on paper uh so but the but I guess the the answer to that would be we could either do two Registries or just split uh percentages because at the same time you know like writing and mastering is basically a master like or like recording is like a 50 50 Endeavor right so we could um split from just one big chunk of 100 of ownership or mint you know specifics any more feedback we have more time yes so is the biggest reason we want it to be a wallet so that we can have that kind of signature based approval like like the question from Dan in the last talk of um deciding when the metadata would get to be updated or if a piece of work can be included into a movie or if the rights could be included like you have that signature step from each of the participants is that the reason kind of thinking of it as a wallet or what what's the reason uh to have a wallet be the mechanism for controlling the rights so that is one reason a and the other reason is and this is very personal you know like looking into the future what I think that would happen or would would happen would make sense if it would happen is that this contract is like the master contract of all the IP that is derivative from this original registry so from this original registry and we spoke about it briefly on Twitter uh we could also have some form of progress nsts where everybody is for example we go into the studio and then we somebody's gonna come and feature a song right that it was not he was not or she was not in the studio on the on the first day of the recording then there's a way of tracking the progress of the intellectual property obviously you could go like even deeper with a Content ID mechanisms and whatnot but but I think that this smart contract would probably evolve to be like the master contract where you would mint the one of one of the song or the 10 editions of uh the the video and all the derivative works and the cruel the value in one contract basically hey um something I'm very interested in is easing time as a constraint to force kind of consensus between a group um and this feels like it could be quite good that could be quite interesting to bring into this that I actually wrote something about this in like February or something um about making multi-seq wallets in a similar sort of way but when I was when I did that design I was I proposed that you have like a time period that can be defined in which data can change and at that point is finalized and boom it goes and that's that how do you feel about that in terms of like the this workflow like um you know do you see that you've got multiple parties kind of putting their information in do you think that should be locked down at certain point or how are you thinking about time as a concept within uh within this kind of a formalization foreign I think Dan I think the the ideal scenario is that creators get agree on percentages of ownership immediately I wish right yeah we wish but if the tool is available that might be an incentive right and if we fulfill the promise of value through these uh specific type of um a creative product then we might be able to take it a step further because right you know like 20 years ago split like splits were non-existent basically Publishers and record labels were the ones actually doing the paperwork but it has evolved in the creative mind that they own their their their creation said that they want to be a part of split so more and more you see like producers and artists and songwriters be like okay like let's you know like let's show me the splits right or let's negotiate the splits hopefully as soon as possible and this is kind of just like inserting it in that moment of you bounce the song you share it is there consensus how do we how are we you know like splitting the ownership of this let's log it on the blockchain and um and it should serve as a proof of work in case there's like legal challenges on on on the process uh yeah I have a question so I understand this um or I my mind tries to abstract this like um the concept of self-sovereignty in intellectual property but then I see this like conflict between the existing structures and the structures the social structures basically and standards that would have to evolve If This Were to actually come and have any chance at becoming like the dominant form of of um you know managing um creative IP I'm wondering how you see like the end game of this playing out how how can this actually um win out over the structures that we have right now which are very strong power structures well the the grand idea would be to finally have a global copyright database right if that makes sense it has been tried several times I know a lot of people are accepted into that or I don't know if it if it even it's a good idea but um but there has been efforts in you know like like just sharing the information but the power struggle between Corporation makes it makes it impossible right they don't want to uh just um have that be one entity and um and that's that and that's where the efforts have died is it good or is it bad I don't know I mean a probably haven't thought about the the the consequences but just transparency on data I think should be publicly available and should be um you know like uh just like a public good last question thank you um are these splits renegotiatable at a certain period after a set time um what does that look like what's the current kind of discourse regarding that yes so copyright law actually states that you're right in of an idea is immutable nobody can take that away from you so a hypnosis can buy the the Bruce Springsteen catalog but you know like Merck could never say he sang those songs right even though he he owns the financial exploitation of of the IP so and that's like a like maybe a super example but having the possibility of making you like the immutable having the immutable record of you were there even though you might see the financial retribution of that IP you have the right to be credited as the author thank you thank you Andre thank you for the talk I think I really liked what you there was like this one quote that you said like copyright is immutable that uh it's definitely something I think we can uh probably all take home and think about for a while uh next up is uh Ian and Ian is going to talk about rich content type types in nfts and yeah if you are new here basically what we are doing is the ERC lightning talks we are the youth magicians and we are talking about ethereum requests for comments proposals so not the call Dev consensus layer stuff but the solidity interfaces application um like these standards um yeah thank you thank you uh warm Applause for Ian uh thanks for having me Tim it was wild we met at youth Berlin a while back and see you back in the space yeah um I'm gonna give a quick talk on canonical media and EIP content type so the notes are basically I'm just going to split through Json and talk about it uh the notes in Json are on GitHub if you have questions beyond the talk or you're watching it recorded make a GitHub issue probably the easiest way to respond and I'm just going to open a conversation about kind of what we've done previously in organization at Zora What I've Done personally for certain nft projects and rendering so if you go to the original EIP 721 the metadata schema is pretty lightweight you have a name description and image it was designed an era of crypto punks crypto kitties where you tracked ownership and the image just kind of showed a cute item or like the thing and then that became more and more important with time I think it was left pretty open-ended for people to build out from here and I do like that idea of a very minimal standard and people can run with it but I think at some point that standard can also be improved so an example is and I've had co-workers ask me this all the time most recently somebody asked how do I made a presentation and the easiest thing to do would be to export your keynote or figma as a PDF and then mint it right well unfortunately the metadata standard just as image so what people have done openc kind of added animation URL to show an animation which could be a web page gltf audio a bunch of random grab bag of content and the great part about an image is if you want to render it as a consumer you just pop it into an HTML image tag or you put an image viewer images are pretty well defined on how to render animations get a lot more complex what we could do is we could convert the presentation into an HTML viewer and upload the HTML viewer that becomes pretty cumbersome and a little bit difficult because the original content is a PDF it's not the HTML viewer and the way Zora approached this with the Zora protocol in 2020 that I didn't really work on that was before my time was to separate this concept of metadata and content content was one thing metadata was another an idea here is that the nft represents you own a particular ID and that particular ID represents a canonical off-chain content so I highly recommended to use ipfs which is decentralized distribution layer but as a future proofing also used a hash function sha256 which fits really well into a standard solidity data type the Zora core v0 solidity has a function for the token URI which is not the metadata as the standard defines it breaks the standard but is actually the canonical content so if we were to Mint a presentation it would be the PDF and then the metadata is defined also incredibly simply as name description mime type inversion the mime type is useful for rendering as I said you need to have some idea of what you're going to render before and fetching it from the server just to figure out what the mime type is is a little bit frustrating so this year calls the token URI it returns a ipfs file and then here that file is just text of these two icons the token metadata URI is name description mime type text plane so that tells the Zora platform to render a text plane image of that text plane of that nft and I don't think there have been a lot of platforms that support this so when you try to look at an open C good luck um and that brings me to my next point of thinking about going back in Computing history of what people have done to solve this problem this is a multi-part form data it's used for email kind of and used when you upload files in a classic web form it has content type and it has certain set of attachments you can kind of think of this as an email attachment so I think having content type is quite important content like maybe we can talk about that a little bit later and then the body of that exact content here you have an example um sorry got out of weight so an example of what we could do is add a new field to the metadata standard either through a secondary proposal mechanism or the EIP standard that represents what we just talked about and there's a lot of details here to unpack so one of them is maybe you'll want to include the content directly should it be body or should it be encoded in a data URI in that case the content type is redundant but when you have an external pinned file you really want that content type for rendering it just makes life so much easier from a platform and indexing standpoint if you have a really obscure file type let's say somebody loves to upload Illustrator files you could use an indexer to find every illustrator file with a very simple content standard and I think the idea here is you have a token ID represented by a file and the metadata describes that file as that file when you need to have a file with your nft is the highest resolution the most um the highest resolution the most well-known version of that an example is Zora was brought on to work with the Warhol Foundation to Mint one of the original computer nfts and it was made on an Amiga with a beta version of software an art collector is really frustrated that the nft was a tiff file but it was built with the Zora protocol meaning it did support tip files however nobody else did so what we had to end up doing is use the external URL which is the openc extension to link to something to link to the Tiff and then switch the image URI to become a PNG that renders everywhere and this is after back and forth with conservationists and with different protocols as to what they expect the nft to be now if we were to use the content standard we could Define the image that renders as a preview with ipfs and then we could use the Amica mime type or just a binary blob with some notes around it in the description to refer to the original media and I think that would help conservationists feel better that the nft is representing what it really represents and not needed to be converted into a new format to be an nft a second example of this is mirror so if you were to Mint a mirror Marketplace essay this is what it shows it just shows a cover image of the text of the title a description which is a link to mirror and that's it I think there might be like the author information in the properties but it would be really cool if quixotic has a relationship with Mir and they could download the canonical markdown file and start rendering it on their site or at least say hey there's a canonical markdown file associated with this and like GitHub it would just open a markdown viewer if it understood it and we can take a look at the Json here so if mirror currently what they have is they have a Content field and it goes to an are we file which is a custom content type they defined it's quite and Rich has a lot of information but it has the body the author information signature information and stuff they use to run their platform if we're coming at this from a perspective of an indexer this is not very helpful we could try to expand that content field but that could be any file type as I said before it could be some binary blob or it actually could be useful Json so if it's defined as Json or maybe an extension to Json you could use that but the ID here is would be the markdown and if Mirror Has extra information they could use their own fields to refer to that information within the content file or outside there's a way you can actually add Json headers to markdown files so you know the file itself is an abstraction is really powerful in this case but if you were to rewrite the season content you could use text markdown and then quixotic could easily parse that not just for mirror but from Zora tools if somebody were to Mint a markdown file and this has happened before when Matthew ball wanted to Mint his original metaverse essay on Zora but we wanted compatibility with more marketplaces and we wanted parts of the metadata to be fully on chain the solidity contract renders the metadata Json on chain but it links to an HTML file of the markdown content because that's what animation URL supports so we're having to change the media type into something that fits within an nft an easy way to avoid that and also if you look at an open C it doesn't properly parse an animation URI with an ipfs colon slash right now but you can see the metadata is getting loaded in but the essay experience being a tiny box is really frustrating and links don't work for security reasons here it's slightly better but also links don't work due to security reasons the sandboxing on an iframe is actually pretty difficult to work with If This Were A markdown file you could just run it through whatever markdown renderer or even provide a link and just show the preview image associated with the nft a final example of this is the dead ringers um it is a part of the Ringer's art blocks collection and it is a follow-up limited time Edition where funds went to charity and it was a very large seg megabytes and megabytes SVG and I believe manifold helped with the mint and the original file for image was an SVG but that SVG broke wallets and people were not happy because an SVG is text and for you to encode text you actually have to turn the SVG into some sort of bitmap format and then convert it again and resize it so it's really difficult to resize an SVG and most marketplaces pass through the SVG but this particular scg was so large it started breaking stuff so what they had to do is they actually had to update that and change the image to a PNG that did render well but it was a 12 21 000 by 43 000 pixel PNG which also caused some problems um because Marketplace has taken the PNG or whatever image file resize it to reasonable size and display it so what we could do now with this particular proposed standard would be to include the optimized image that renders well within marketplaces and then have the canonical content be the super high resolution file the artist intended so if you own that to your wish to display it you can then download that original file and work with it as you will and if you were to take the content type you could then encode the image SVG XML and then a URI and then optionally include a shot 256 if you're using airwe that's actually a really nice way of verifying that the file is what it is because airweave doesn't use content addressable hash so the the link to ipfs for every file is unique per file but for our weave it's different so the idea here is the sha-256 is a really standard way for a very long time of verifying that a file matches a file and can be included in this so overall the idea of this proposal is to add in a Content field and the idea with content is it's quite simple it doesn't have any underscores and it's the first time I think there's going to be some proposal or thought process around creating nested structures in the metadata but I think it's quite useful because content underscore type content it just doesn't like we already have Json we can Nest this um but type URI shot 256 and potentially potentially body for those that want to directly put plain text in but I feel like a URI encoding is also usually a fine option and I'd love to hear what different creators of Standards or media have another thought was you could have some sort of attachments Associated say you have an image that a product you're selling as an nft and you have a slideshow I recently worked with the team to show a product and the slideshow had five images you could theoretically include this as attachments in your um and then that would be rendered as like a generic attachment on media I think that's a little out of the scope for this project though and I would like to kind of focus on um I would like to focus on this idea of a single canonical file instead of a set of files because it makes sense to have a single file and a single nft ID relate to each other and to not really focus on banners and colors and multiple sizes kind of on the side of open graph where you have this media how do you render it well on a Marketplace or in another context I think that's out of scope for this particular Focus um and the media canonical is to have a standard or primary authoritative body on a subject so the URL is the authoritative idea of what that nft is and it's left up to interpretation of the Creator or the platform to figure out how to best Express that and use it my open questions are should this be an EIP within The ethereum Magicians group chat it's a pretty widely debated topic of metadata is included in the original proposal but it's not really defined beyond that and it's defined quite Loosely so one thing I like to do is try to stick to proposals and I'll typically use the Key Properties instead of whatever has been defined otherwise because it's in the 1155 spec but I am mixing the 1150 by 5 spec for the 720 ones back the non yeah and then multiple files just an open question so I'm going to wrap up if you're interested in asking questions from the recording or want to continue the discussion um I have a GitHub of these files and this is my Twitter zoom in a little bit and then the one last thing is there was an on-chain version of this EIP content type that used mime content URI and hash and this is kind of the inspiration for the off chain version of this proposal Unchained ideas if you have dynamically generated SVG it's more composable it's easier just to return a struct but I think now kind of working on more projects and finding more examples the off chain example is more compelling and you can still generate a Json blob on chain including the content field so it kind of works both ways I just think this is a better start to the approach a way to approach this project then including a new getter function as an EIP within the solidity world this is all off-chain metadata we're talking about I have a little bit of time so be glad to open it up for questions yes thank you Ian thank you for Round of Applause [Applause] we have one question hi I'm Marcus nice to meet you um if this was implemented as an EIP what do you think the second and third order effects of this would be I hope the very first um thing is indexers platforms would include it in minting so manifold actually does really try hard to include a lot of metadata they do image image underscore URL image includes the hash and the URL and the content type and some other data so I think kind of thinking with them to figure out what their needs are but once you start having stuff minted in this format I think it's going to hit indexers and then once indexers can understand this people can say oh I can upload Illustrator files I can upload webgl shaders I can upload some binary form like you can actually now mint a solidity contract and when somebody buys it they'll feel more assured that they're actually buying a solidity contract rather than somebody or the file of a solidity contract rather than somebody saying oh here is a solidity contract and what I typically have advised creators to do is actually explain it and link in the description the ipfs URL of the canonical media it's Packy but it seems to have worked um and that would kind of remove that and allow for use users to see like a link and I've seen artists on Twitter talking about using unlockable media and openc to include the source files and if the artist is comfortable they could just include the source files and it would be a link or some sort of description on pla marketplaces and since this is relatively easy to implement once a few start I think it would start spreading thank you we have another one here hi hello congrats for the project um so content type is a response header on HTTP right thinking about you know the second order effects have you thought or worked on the request headers equivalent like the accept and then having some specific wildcards such as Text slash and then wild card so the one problem when you're indexing is that a lot of times ipfs is really slow people's servers go down if you're able to get the metadata on the client a lot of people hot link directly to an ipfs Gateway and pulling the content type out of the headers really allows for a better set of expectations when you're indexing and rendering the nft but your question is to kind of use the HTTP response conversation to define the Mind type rather than put it in the metadata yeah sure so there's the content negotiation step right so and then you have from the accept request header and more often uh you have like some sort of wild card there okay so that can help uh you know more generic applications to accept let's say image slash column uh wildcard something so I think a lot of the off off chain nfts go through a decentralized Gateway provider and those Gateway providers are not very like you're out the control of the server retrieving decentralized media is out of the control of the user in most cases so you can't rely on a server negotiation you're thinking of a world maybe where there's a server that is connected to the URI of the nft and that's becoming a lot less common because that means you're now having a centralized point of failure so the idea here is if you put it in the Json there at least be some intentionality if you're on some weird version of ipfs like node that doesn't understand the media it's serving or there's a bug in it you'll still have something that kind of works or have an expectation of what the original intention was thank you do we have more questions maybe one last question okay otherwise ah yes okay we have fun here you define the um content type inside the Json um to like save some uploads could you define the data in the collection as well that's actually a great question that I didn't have time to address but Mir and Zora and a few other platforms have editions and I think utilizing a singular nft metadata in the contract URI which is an openc extension is a really effective way to handle that and right now I know most platforms that do additions support the contract URI so for dead ringers and for um Zora editions the contract URI is actually generated on chain and sometimes we'll put an ipfs depending on how big the content is and that includes image it includes animation if every single thing in the collection is the same and we use that internally in our infrastructure to give a preview if there's no mints yet or like what that whole collection is supposed to be there's no standard around it but this would also slot quite well within the contract metadata if you wanted to have a canonical contract um content field it should just work thank you Ian Round of Applause thank you very much thank you everybody next up is Francisco from openc thank you which is gonna speak about Erp 5267 and I have been saying the entire time that it's a it's about the domain separator so yeah okay gladly uh yeah I I just uh and I'm gonna be all right so yeah Round of Applause for Francisco hi um yeah so sorry we're gonna move on from nfts now um it's gonna be about erc20s which are boring now but okay um I'm correction I'm not from openc I work at open Zeppelin uh maintain and develop open sampling contracts which obviously uh maintains uh many ERC implementations and so this is a really important topic to me um so this EIP that I'm going to be talking about is really quite tiny um but I want to use it more as an excuse maybe to talk about the process of building an EIP and what the kind of steps that I think uh one should follow so because like eip1 which it's not here but maybe you've all seen it kind of defines the series of stages like draft review last call and final but it doesn't really say what should happen in each of those stages so I want to share how I personally I'm thinking about that as I develop an EIP so the problem at hand here is the erc20 permits anyone that has used a amm a decentralized exchange before knows that in order to do a token exchange you need to approve first and then transfer and this EIP permit is one way of foregoing the initial approved transaction and replacing it with a signature that allows you to allows you to do it all in just one transaction by just including the signature in the first transaction so this saves gas it is one less transactions and agent uses the signature instead but it's kind of weird if you use an exchange or an aggregator you don't really see it as being used very often um I think uh main maybe it's just like usdc exchanges supported but there are many other tokens that have this and don't so the question that was in the back of my mind is like why is this why is that so weird so the this EIP underneath uses uh this other EIP 712 which is a special kind of signature um it's a signature not of a blob which is what we see uh often uh most most usually but of a kind of typed data structure so it's kind of important because it allows you to get more structure to it in the case of permit you will include the amount that you're allowing um you will include and expires uh timestamp and a nons and so on and this is an important uh standard because wallets can Implement support for it and show the structured data to the user in a nice way one of the important things in this EAP is the notion of a domains so when you make an approval for say usdc you don't want an attacker to take that signature and kind of send it to die right you know want an attacker to reuse the signature in a different domain so every signature has this domain separator inside of it that makes sure that the signature is only valid in one domain so this is the um right so the decentralized exchange has no way of knowing um given some arbitrary token what domain they want to use um and I think yeah I think that is the reason why this hasn't been really adopted so you will see that um the erc20 permit ERC defines a getter that gives you the hash but really the 712 RPC endpoint requires the entire domain object and there is really no way to find it here so this is where eip5267 comes in um now we will see now it's a very simple function that literally just allows you to obtain the domain this is the domain object that you will need to pass into the 712 sine RPC call and and as you can see like it's extremely simple now what was also at the back of my mind is that this was this is not also a failure of the spec uh 12 2612 so permit but it was also in a way of failure of the process because if the 2612 authors had kind of gone all the way and kind of talked to decentralized exchanges and thought through uh what it would entail to adopt that they would have realized that this was missing so I didn't only want to tackle the technical problem here but also think about how can I uh carry out the process for the CIP to make sure and and other erc's to make sure that the sort of failure of the process doesn't present itself so the question is how do we get this now which is in a review stage how do we get it now to final what needs to happen in order to get it to final so some of the things that I've done um and that I would recommend you all do when you build your VIPs um so you should reach out to all interested parties and like applications and companies and uh projects that you think will be using this and really you should be kind of bothering them to give you feedback to look at it and give you feedback so I've reached out to uh one inch and unit Swap and kind of seen try to get from them is this useful to you would it does this solve a real problem from for you um and generally the answer in this case has been yes um in the ethereum magician threat there's also been a couple of interesting comments and common questions I have taken some of the questions and documented them as part of the EIP as well and also some concerns that have arised uh so many of those concerns in the case of this EAP were about the backwards compatibility uh section which is here but um most of the discussion of the ethereum admissions threat made me realize that even though I wrote this section kind of thought about it there really are many more unanswered questions so I wanted to do some more work to figure out the real backward compatibility story so another another thing that I've started doing which I think is a really good exercise is to implement it and not only like the solidity part of it but also the many parts of the stack again so I've just uh started this EA repository with the implementation and most importantly a little app which is just a front-end app which is what I imagine that a the central X exchange will kind of be doing behind the scenes and here I'm putting myself in the shoes of I am the UI for one inch and this is what I'm going to be doing and just kind of really figuring out if it works if I can actually produce the signatures that they will need to produce and also to use this to figure out the backwards compatibility story and I still need to develop this a little bit further but I'm hoping that I'm going to come up with a good and kind of uh comprehensive answer then I can then go back in the EAP and document it there um to make sure that it really answers the concerns that were raised in the ethereum Edition thread so I think uh yeah that's it again it was very quick but uh these are some of the um things that I've been experimenting with in order to get this to a final stage um I think there are we see many eits that take more of a fast track and get to a final stage which is you know it's better in a way because we know that these processes can be long and it's really annoying but um then you get to a final stage and it doesn't necessarily mean anything if it hasn't been thoroughly tested and then you're really going to run into some issues when say open Zeppelin implements it and people start deploying it and you realize oh this this isn't really enough um so um then you need to start thinking about like a follow-up EIP and it's all uh really much more complicated than it should be if we do things better before we get to a final stage so anyway those are some of my ideas thank you um happy Tuesday questions if any yes thank you very much do we have questions yes hey really cool uh first uh comment it reminds me of uh like the Amazon six page written narrative way of you have to like sharpen your point or your case and then you go around and get feedback from people and then incorporate that in a fact at the end of the document to like because you know other people have those concerns or objections so that's really awesome um do you can you just speak a little bit more about that process and how you've followed up with people maybe on this one or something in the past so it's one thing for somebody to say it looks great maybe give some feedback on The ethereum Magician's posts but really an eip's success or failure is like people using it like you just spoke to so have you have a good example of like following back up with protocols and actually getting them to implement the EIP as part of your kind of is Dev work if you call it yeah so uh good question I haven't thought about that too much yet um but um one of the things that I personally struggle with is that I feel like I'm in a bit of a conflict of interest position because of being on opens up and contracts maintainer it's like it's going to be really easy for me to put this into contracts and make people use it but I don't want to force it down people so for example one thing that I uh could do and now that I'm thinking about I think it would be a great idea is to talk to this one-inch developer that I talked about and maybe uh try to get them to to uh walk me through do they really see the do they like really see themselves implementing this and maybe what is the timeline um and kind of yeah just trying to get more concrete data on on their plans and try to try to get them to commit um maybe that's what I I would do thank you uh more questions feedback maybe uh people that have used this or or 712 raise your hand if you have a question okay then thank you very much and this is called Round of Applause thank you thank you yeah and that's essentially it that was the ERC lightning talks from The Magicians I hope you all liked it um you can find each and everyone hopefully uh on the East magicians forum and I'm looking forward to all of the posts that are coming out of these discussions I'm I want to thank you all for participating uh like so much in this conversation and I I really appreciate that we were having like a back and forth between the audience and uh and the presenters and so on and yeah it was great to be able to host this and yeah thank you very much and see you around foreign [Applause] [Music] [Music] thank you 