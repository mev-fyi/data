foreign [Music] team at ethereum foundation and um this talk was originally about what's next in the evm but uh we shorted it a bit because lightning talks um but what I want to tell you about today is uh quick to give you a quick introduction to eof evm object format um but we have to start with the the current VM we have so one of the design goals of currently VM was Simplicity and uh the thing is that we kind of overdone it um and uh the the current VM can can just execute whatever buys the it's provide you will provide to to it and um that's why I kind of sometimes thinking about it as a garbage heating machine uh so it's it it brings some success to evm but uh must also bring some inefficiencies uh to it so um one of these inefficient aspects of evm is that uh you need to do a lot of work except above the the actual work the instructions are doing internally so this is like the checks that uh every every step in The Interpreter you will need to perform to make sure that the AVM works as a specification wants it to go um and uh this is kind of the motivation we want to do to clean it up and the cleanup of that is to introduce a container binary container for the for the programs in evm and so that it will kind of translate the the mixture of different features and some Miss features in the in the in the Legacy VM to something that is a bit more um structured and uh and and Polished so the the main aspect of eof is to provide some metadata about the program uh including the version number and splits the the bytes into code and data sections we can also do a bit more about that this is the kind of the the continue like the next proposal that can be applied to the Mev of eof which is to introduce functions so we can partition the code section into more pieces with additional faction type information and to to work with the functions in evm we will introduce two new instructions one is to call the other uh code blob and uh and one is to return from the from the call to the to the caller and uh this like um the calling the functions internally works like allows you to move you between the different code sections in the code sections you can use uh relative relative jumps which would replace the existing Dynamic jumps and uh yeah so this is the the control flow instructions that will allow you move it around in the code sections and it won't be allowed to actually close the boundaries of the of the partitions and as I mentioned having to do this uh control flow features we can deprecate the existing the existing jumps semantics in particular this is really useful because we can drop the jump this analysis which has to be performed about evm programs before every execution and if we kind of add up all of that we can with additional code verification that will happen we can eliminate the this like first three checks in the evm so uh this is the additional aspect that can be added to that which we can like verify the how the functions behave internally with like simple algorithms but um to sum up all of that um uh yeah that's kind of improved version of evm that has some nice control flow have the code and data separation and support native functions um yeah so that's that's mostly what I had to to show you today these are Pointers when you can find more information I think in particular the the FCC talk from this year it's kind of the extended version of this talk so uh yeah you're invited to to see it after it um and yeah the the five bullet points in the end are that all the aps that kind of specify the the the broad aspect of of eof yeah I still have one minute so if you want you can shout some questions from the audience that's hard question I mean we're kind of competing with the like proto-dunk Shard link and withdrawals right now um so yeah it's it's hard to tell actually uh some of these aspects were prepared for uh for Shanghai but not like not all of the features I I talked about today foreign so in one of the slides you said you you you strike through um stack on the floor and stack overflow uh and we get busy yeah this one and only okay can you give me uh can you give a bit more details around that yeah this is done by code validation so when you want to deploy a code it will go through additional validation process and in particular when you don't have Dynamic jumps you can you can statically check if the if the function will never stack underflow and stack Overflow is a bit more complicated but you can compute like the maximum stack height the function reaches and then whenever you call the function you can check if you still have enough stack space available so that's the the second one is a bit more complex and it has some uh trade-offs um I think it's it's my time so thank you very much thank you 