the problem we're gonna be discussing is what needs to happen for smart contracts to make meaningful events happen in the real world and how those smart contracts can know that contractual performance has happened this is really important because without contracts knowing what's going on in the real world and without contracts being able to effect real real events they're limited to tokenization and they don't really reach their full potential in our opinion so to grasp kind of the full value we see in solving this problem I think it's useful to take a look at this from from a historical context so from historical context we all started out with kind of multi signature as the model for smart contracts back when you know basically Bitcoin existed then we moved to a protocol level or op code level version of smart contracts where smart contracts were written into a protocol in the form of up and so you couldn't really go beyond what the protocol allowed you to do it took months to get new functionality into a protocol and if you wanted to write a new contract you were kind of out of luck unless the OP code for your contract type already existed so this was called you know the Swiss Army knife approach and so there was a large incremental gain when we went from just signature multi signature type of contracts to an OP code based contract then aetherium does deserve a lot of credit for taking contracts from the protocol op code level over into the world of scriptable smart contracts which is the world we're now becoming more used to in this world of scriptable smart contracts provides a lot of flexibility and a lot of new features that have pulled a lot of people and created a lot of useful use cases right where you you no longer need to ask somebody to add a smart contract type at the protocol level wait months for it to get merged in you know experience a heart for possibly to get yet it working you can now code up a contract without having to do anything at the protocol level and you know this conference and the wide kind of panoply of projects building different things speaks to the benefit of these additional features so smart contracts in our view keep getting up did more and more the more useful features they have right so this is the most recent development in for how smart contracts have left forward we feel there's another leap forward so the next leap forward is taking scriptable smart contracts and allowing them to meaningfully interact with external information and events so basically you could write a scriptable contract right now and it'll look very similar like the one I have here up the screen where it's basically tokenization and movement of tokens among parties and that's what your contract will be limited to today now the next leap forward in actual value and features and capabilities that we're hoping to help people attain is the ability for scriptable contracts to know what's going on in the real world and for those contracts to also be able to do whatever the application or the decentralized application wants them to do whether that's sending payments notifications affecting real world events we think this is the next large leap in value that's going to take us from ok smart contracts seem only to be useful for tokens to smart contracts are the standard form of agreement for securities derivatives prediction markets insurance trade finance you know all these all these industries that require their contracts to know what's going on and require their contracts to be able to make useful events happen now to get to that value we basically have to look at the smart contract connectivity problem or the Oracle problem or kind of whatever you want to call it it's it's basically the problem that neither aetherium nor any other change basically work on right now is gonna allow you to reach out and know what's going on in the real world so if you have a contract for delivery your contract can't know that a delivery happened if you have a contract for something related to market data your contract can't know that happened that's why everybody's building tokens because that's the out of the box functionality they have to work with and when they start to try to go beyond that functionality they hit a wall that wall is basically the smart contract connectivity and the Oracle problem and we are very interested in seeing if we can get people get the space on that wall to see a lot of useful use cases actually do useful things in the real world right so that is kind of the body of work we're engaged in and that we're hoping to see see moved forward to the point there's actual practical implications of real-world events being triggered by smart contracts now the solution for this problem sounds sort of mundane but it's actually very important so the solution is essentially blockchain middleware so what you need to do is you need to designate essentially a trusted third party that acts as the source of data inputs and acts as an off chain agent for executing various events on behalf of the contract off chain do to do to the way that decentralized consensus arrives at blocks and putting data into blocks it it isn't really possible for the current mining schemes or the decentralized consensus schemes of today to enable this right so you basically need a middleware you need a third party that's responsible for giving your contract what it needs to know and that's responsible for acting on your contracts behalf to do what it needs to do in the real world this can be called an Oracle blockchain middleware a chain link that those are essentially synonymous so this would allow contracts to know what's going on in the real world perhaps to generate real world events of significance such as bank payments whatever other events and whatever other system the end user cares about and it also allows contracts to sign and send transactions to other chains now I think the really important thing to keep in mind whenever evaluating or looking at a system that's responsible for making sure your contract gets what it needs to function and and that's responsible for making York making sure your contract effects real world events is the reliability of that system right if we have a secure middle piece kind of the smart contract language network is where the state is and then we have an unsecure triggering mechanism the end-to-end reliability the total kind of average determinism and usefulness of a smart contract remains too low in our opinion it remains so low that it will not be used in in many use cases that require that that benefit from the value of the deterministic and highly reliable nature of contracts so if you're gonna trigger contracts using whatever system and you're gonna use have contracts do meaningful events and other systems the mechanism by which you do that needs to maintain the overall reliability of your contract if it doesn't do that then essentially your contract devolves into something else it's no longer a deterministic highly reliable digital agreement right it becomes something that is easily basically taken down by other messing with the method of input or however the output completes the contract so I think what it's useful to do is to quickly look through what are the ways to approaches what are the wrong ways what are the right ways one of the ways we don't think people should approach this is we don't think there should be a single node right we don't think that we're all saying that smart contracts are highly reliable because they're redundant Lee executed on thousands of nodes according to a protocol and so because thousands of independent node operators have executed the contract code you know what we call decentralized computation that has made the highly reliable highly deterministic kind of digital agreement that we're all excited about if you have that highly reliable agreement triggered by a single node all you have to do is you have to take out that one note this is kind of the fundamental problem that basically needs to be solved because knocking around the data providers that have been around for 30 40 years is is is really difficult knocking on the smart contract network has its own challenges but taking out a single node that triggers your contract and tells it something is not a particularly difficult proposition right so the the logical approach from our space is perspective to this problem is basically the essential just like you've paid thousands of nodes to do redundant computations to guarantee Turman ism of your contract code you should be able to pay hundreds or however many nodes you want to pay to guarantee the quality of an input and to guarantee that that input is going to reliably trigger your contract essentially that's the basis of our approach the basis of our approaches would be able to pay for however much decentralization they want to pay for to reliably trigger their contract right however it to be comfortable about triggering their contract they should reliably say I want this many notes to reliably trigger my contract on the basis of this or that or whatever collection of data now I think the useful thing is to look at how this would function in practice so in practice as an example if we took contract for payment excuse me we'll see that basically we can even today we have multiple chained up two of those chain links can verify that something has been delivered verify that a contract indeed bill fulfilled well you can have them both verify as a condition excuse me you can have one of them verify and another one be a fallback or an error checking system basically you you can reach out to multiple data sources to make sure that the event contract is about actually happened that you verified that the event the contract is about has actually happened you commonly need to calculate a price you're gonna pay you need to know market data you need to know how much should I be paying for this contract to be finalized on that dimension we basically even today can provide you with three or more separate independent independently run notes notes that provide market data and those those market data kind of inputs can be aggregated into a highly reliable proof of what the price actually is so in this example you see highly reliable proof that something has happened that the contract really cares about essentially what the contract is about basically delivery and then you can see that there's multiple data providers and multiple node operators providing a highly reliable input about how much the contract should pay and then you would need some kind of note that's responsible for paying in the relevant system in this case if you wanted to pay out the contract in Bitcoin you would calculate the price of a point at the time you would know how much you have to pay and you'll be able to sign a transaction that pays out that contract in Bitcoin or dollars or yen or whatever whatever currency you want so you know fundamentally this is kind of the base use case of I've reliably proven that an input is true and I have functionality to pay people and enact contract outcomes in places that people want me to have those outcomes happen right so this is kind of the fundamental initial value and the focus of our work at this point is basically creating hundreds upon hundreds of chain links present every service that a smart contract develop want so the way the world really should look is very similar to the web development world so in the web development world if I want to build Ebor I write my corporate code and I go to a GPS API and SMS API and a payments API and in a week I have some VP of uber running right you can't do that today in smart contract land we're basically saying that's the problem the problem there's a lot of people that want to build great things that are alike or better or you know fantastic applications but they're at the point where they can write their core code and they don't have a GPS API or SMS capability or a payments capability and they have to figure all that out and that's just too much right so if we can just give them all the inputs and outputs they need to combine around their core code we can get to a place where smart contract development happens as quickly and as high level of quality as web development and then we can just see a lot of interesting use cases come to life in in you know days weeks you know how long does it really take to build an MVP of uber with some api's right it doesn't it doesn't take that long if you have the necessary building blocks so that the basis of our approach is the centralization and then making sure that smart contract developers have the large collection of inputs and outputs they need to build something R'lyeh was build something that truly provides value and the second part of our approach in addition to decentralization is the use of trusted execution environments so trusted execution environments will provide an additional level of reliability and they will basically harden each in the individual chain link No against many a different attack vectors and this hardening and additional reliability basically makes the entire system more well more reliable more more something that can provide provable security guarantees that it can reliably trigger your contract right so it's a very early technology but we think it has a lot of promise the approach that that we've been using and working on together with people is something called town crier so town crier was developed by Cornell and ic3 and it was put together by you know some of the best academic minds in the block chain space like like re joules and a lot of other great folks that basically put a great approach together and put it out on production over a year ago so this is a functioning well made secure approach that reliably triggers high quality contracts like the gas token so it's it's it's in our opinion the best trust use of trusted execution environments in the blockchain space today because it works it works on production and it's made by by some of the best academics in in the field now what we're glad to announce today is that due to our very successful collaboration with the folks at Cornell and town crier and ic3 the town Town Crier is basically going to be joining chain link so what we're doing is we're combining two of the best projects that are focusing on getting data to contracts and we're basically combining them into one great project essentially chain link now the way this really looks from from a value perspective is that Town Crier and the academic minds that are put that together have done a fantastic job and making trusted execution environments useful practically immediately useful and secure on production right that's not something many other people could say and chain link has a unique and high-quality approach for making sure that the centralization is a key part and is is a way to provide genuine guarantees about reliability so the combination of Town Crier and chain link we basically arrive at a provably secure decentralized oracle network so this this combination of features is is basically allowing us to arrive at a place where reliably triggering contracts and solving the Oracle problem is as close to solved as it ever has been right so I think it's useful to you know in the time we have left to consider what the actual value of this is and maybe diving into into the approach where we're talking about here so the fundamental value of an approach like town-crier and the use of trusted execution environments is that you have a much smaller trusted computing base you have a much smaller attack surface area so instead of an application going into the OS or the hypervisor and then injecting malicious code into your application you now have something that has a separate memory and processing capacity that is at the hardware level so now you have hardware level that basically talks to your application through separate call gates and and basically a separate hardware level that doesn't touch the OS doesn't touch the hypervisor code and provides a new level of security right so the the fundamentals of the approach can definitely work there's a lot of smart smart people working on it and in our specific case I'm just gonna quickly walk through the key some of the key benefits we gained from including something like town-crier in chain-link now one of the first things to do is to quickly understand how it works so town-crier basically works like most Oracle's it provides an unchained contract that's queried by user contract then there's code running in the Enclave that retrieves data and uses the TLS scheme to prove that something is happening and then it sends the signed data from this secure hardware environment back into the contract right so you have the ability to prove that TLS works you have the ability to sign from a secure reliable trusted execution environment now one of the first great things this does for us is it makes chain-linked node even if it's run by an independent third party even if it's run by somebody we don't know or just an anode operator who may or may not be malicious it gives them something that is much more secure than if it was running and sums in the standard standard set up with docker or something like that basically it gives them a hardened a hardly P basically a hardened set up with its own hardware that they as a node operator cannot even get access to so in the scenario we're channeling node operators are running an SG X node they they they no longer have access to what they're running all they can do is shut themselves down which immediately shows them to be a bad bad node operator so what this does is it hardens it creates confidentiality basically against even the node operator so that you can have thousands of node operators and all those thousands of node operators could be doing computations retrieving data but the only control they have over how that computation actually turns out is is is 0 short of just shutting themselves off now some of the other large benefits are things like credential management so if you want a chain link node to sign Bitcoin transactions or to send payments into Bank systems that's gonna require credentials passwords and usernames and all kinds of credentials that basically affect payment the more secure and environment you have to hold those credentials the better off you're gonna be because those credentials are worth a lot those credentials are worth the money they control so this basically creates an environment that adds another level of security and increases the overall reliability of the network the other really interesting thing is that this gives control of private keys to third parties that can use those private keys to sign those to sign transactions on other chains or other infrastructure on behalf of the contract so now a smart contract can have a chain link node that holds private keys that it's responsible for using on behalf of that contract which is is a pretty unique piece of functionality that we don't have time to go into all the benefits but if you've ever thought about using that you'll see it's a it's a big deal so the other thing that this provides is it provides an off chain code execution environment so basically you now have a place to execute smart contract code privately you have a place where you could take smart contract code and you could run half of an on chain and you could run half of it off chain and if you run it off chain you run it in this secure environment in this environment where you could send it out to 50 notes and the off chain code you sent out encrypt it to the 50 nodes those 50 node operators won't even know the code they're running and you'll get the scalability benefits and the kind of identity confidentiality benefits of being able to use a system that isn't you know the very costly on chain on chain system right so you basically get an environment where you can do some computation in in a layer 2 system that initially is focused on the data but can expand to whatever computation you feel is usable now the other really really big benefit of having a trusted execution environment how is your off chain agent I mean really that's probably the best way to think about this it's there's an off train a gent that's responsible for making sure what your contract should do actually happens and we want that off chain agent to be as reliable as possible now one one good example just to put this in context is if you had something like a lottery contract which was a large amount which is a large amount of current main net traffic and you wanted randomness you could have that randomness generated right in the trusted execution environment using the most common best tested libraries you would generate that randomness and you would send it back into the contract from this highly reliable environment which would give you the randomness that the contract needs to basically function I mean a lottery contract is basically just taking people's money and guaranteeing them some amount of randomness now let's say you you worry you you were able to get this set up and you had the randomness number going into your contract and and generating the randomness you need to prove to people that your lottery contract is reliable but realistically you want it to have a level of decentralization that provides even more guarantees those additional guarantees is basically we're the chain-link approach really really comes in if you want multiple independent node operators to guarantee the quality of a critical input into your contract such as randomness you can now purchase however many independent node operators you feel you need to have the security you need about an input right this is a big difference this is a big difference from I can only use one node or I can run an Oracle or I don't know what I'm gonna do something not gonna build the application I want this is okay I can give people a reliable contract in this system over here and now I have a system that can reliably trigger that contract in a way that maintains its overall security and then I have systems that can reliably pay and affect the contract settlement and outcomes in all the places that I want it to happen right that that takes us from let's write contract code that moves information and tokens around - let's write contract code that reacts to valuable external events and effects valuable external events so the fundamental gist of the approach is the centralization multitude of inputs and outputs the application of this of trusted execution environments through Town Crier which we're very happy about the fact that they're able to join us and that we're able to together work on a much better and much stronger approach and fundamentally speaking the the next steps for us are continuing to include other great developers in the project continuing to build out the the core functionality a large collection of chain links and making sure that when a smart contract developer sits down and wants to build a complex externally connected application they can do that in a day somebody can sit down write their core code and in one day they can get all the inputs and outputs they need connect it to their contract code and broadcast and have that contract working and then also turn around to whoever they want to show that contract as being reliable and just say to them here's why you should believe that my contract is reliable it's triggered in this reliable way it runs in this reliable system and then I can provably and reliably tell you that it's gonna act the concluded payout the way it should so that's mean yeah that's the party of work where we're very focused on basically getting people to the point where they can do that as soon as possible and you know if you if you folks here need need some functionality like that we're thrilled to talk to you we're doing all of this basically so the community and people in the community can build great exciting applications really that's what our team is excited about we we want to wake up and we one day and we want to see like hundreds or thousands of great contracts that that do something really meaningful in in in industries other than token movement that that would be a great thing in our opinion so thank you you 