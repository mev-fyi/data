all right so my name is Yuri I'm a developer from Montreal Canada I'm daughter of embark as well as some other projects more recently transaction dealer a relay you might know me in read it as a liam craft so today are going to talk about embark you and so embark was the first framework for Freud cerium DAPs and to give some background on some of the features it's so it's completely compatible with any build pipeline you can use it what grant or meteor or whatever pipeline you're you're used to embark to welcome with its own pipeline for convenience purposes for development but you will still be able to use it with any any pipeline it's also supports you can't test your contracts using javascript it also keeps track of the the contracts that have already been deployed and it it's smart about it so you can even we factor a contract and so long we don't change something that effect the decks you know the external of the contract you want you want to deploy again so you can refactor say an internal variable we can change the name it will not redeploy because you haven't really change anything but if you change say a public variable then it will redeploy because there's a code change you can also manage different change with it you can deploy to the development change can go to the production chain and you can also use both solidity and serpent's you can use it either you can use either of them or you can even use both of them at the same at same time so another thing that embark is pretty good ads is is dealing with multiple concert the contracts that are dependent on each other so to give some example of this so let's say that you have three contracts and they each dependent on each other so in this case you need a token to be deployed first and then the Dow and once that's deploy you need to deploy the liquid democracy so in in that case you can see you can specify in a configuration file that on the Dow you say okay dollar sign token and that will that will tell in work that okay this contract is dependent on the token and I need to I need first to deploy the token and then pass the address to the to the Dow and you can have a galaxy of or Nats if you want to call it of of contracts each depend on each other and embark will determine what is the right order to deploy the contracts you can also have contract instances so this is the case that you have a sort of factory kind of contract that has all the main functionality but any of you have an argument that specifies a particular change so in this example let's say you have a back token contract but only only you know you want to deploy two contracts which is a USD token and a euro token so in that case you can specify instance of peg token so he knows what is the parent contract and then you and then you see here in the arguments you have requests Oracle yes the JSON so I imagine you're you're calling Oracle like Oracle eyes and so the two differences in arguments is what will make the contracts be different and also if you are using you can also interact with the existing contracts so let's say we are interacting with the dgs contracts they can specify the address and import we'll just use that that's address and it's also a support for deployment commands that there are executors once the contract is deployed so in this case i have an account manager i want to manage my gold tokens and on deploy then i transfer from myself a thousand tokens to that to the recently deployed contract now nor embark as so as a new set of goals the the goal is in inner bark one was to was to provide good deployment tools for this kind of complex contracts now embark two will focus a bit more on the client side and focus more in integrations with storage layers such as swarm and communication layers such as whisper and as well as providing easier ways to distribute applications so embark to is actually read done from was redone from scratch by default it comes with this dashboard you can actually override this if you don't want to if we want to old lock I just found that the the look and could be a very confusing if you're dealing with a lot of contracts because it was hard to know exactly what was the status of different contracts so I did this dashboard so it's it it's us for example does this section that says okay the particular contracts you can see I have they've been deployed where are they was there an error what is there or still deploying there's another section that you have the current chain that you're using in this case they development chain what embark is doing right now and available services so let's say if your tap was using IP FS and ipfs was unavailable it would show up right here and it finally also comes with a console so you can use that console with to inter interact with the existing contracts or to tell embark to do something like redeploy in I will deploy another contract or add another account etc in park to also introduces a client-side library which is called embark GS so that library is meant to aid the developers interacting with contracts it makes things a bit more simpler and also provides api's to abstract interaction with those layers such as storage in' and communication so you can easily switch the technology if you need to because different technologies generally have different trade-offs and your your your tap might have different needs depending on on what you want to do so so the library introduces promises which is long overdue it's also it's also introduces named parameters so you can still pass a list of arguments if you want to but you can also specify the name of the of the argument and I know I think it does also that it's actually automatically calculates the gas cost and puts that in the call so because it sometimes happens if you're working in a method and it changes it suddenly becomes very complex and it just stops working because it didn't have enough gas so important tries to take care of this so it doesn't happen it does some it's also times to do some automatic type of conversion so if you have a big ain't it will just do a to number if you have say an axe that was supposed to be a string you've also converted to a string this is all also configurable because you might have different use cases of course and it's also does the same thing what's struct usually call a struct you will it will return you a list of the parameters and and if you change the order will also affect that order so now no it's just a converts automatically to an ash so you can just convert it by say you can refer to it as dot outer instead of position zero to get the outer and it's also supports client-side deployment so you can devote the contract only only bark just like you do now but and but you can make it available on the client side so you can dynamically deploy contracts there are certain type of applications that require that sort of functionality or very dynamic adapts example this is if you wanted to do like a font app like create your own token you would use this sort of shanell arrival of a form the user would put the name with talking some parameters like the supply and then that's what that's the command is pretty much would run on the client side now for the communication communication layer so so in part Troy's nota app tries to provide an abstraction on on that layer and you can see here an example that ok put in party s messages send message you send that on a certain channel with certain data and then you listen or you listen on that topic so that that's useful to make the apps communicate with each other if you're familiar will whisper you can see this is actually pretty similar to the whisper to whisper a P I and so that the reason that you would use this is because that's why you can focus on behavior and not in an implementation details especially because if you want to try out with different technologies the implementation would be different and and this way you you just worry about the behavior you don't need to worry about the actual details underneath so if you change your technology you don't need to change you don't need to change your code all over again so so it does have provided functionality and you can just you can just choose the provider that you you want so a sign party will support this three providers which is whisper a contract a contract for the messages kind of replicates the this kind of channel function functionality and also will support tell ash now regarding for storage it does a similar type of abstraction so you can't just say okay I want to save text and then I got a particular in that fire it's usually a national a PF fast for example and then when he passes that she will get back the data that you requested and it also obstructs the functionality to upload files so presented this in this example if you have a this HTML input you can just pass it the Dom element and it will just take care of taking the file doing whatever it needs and it will upload the file it's pretty useful because different technologies actually have slightly different ways they actually deal with the files and and and upload them so if you just use this you don't need to worry about all those details and then again again you can just do get URL ash and you got your your a lot of the that will point to the content of that file so this is this pretty useful for you know human upload cat pictures or profile pics or so on and just like before you can also choose a provider you can choose a configuration default for now will be ipfs mostly because that's what I was actually working on but the default will there be swarm and so there's actually five providers supported the first three are a swarm RP FS and and a storage contract and again there's different trade-offs to this you might actually want to store something on the blockchain which in this case we'll use a pre deployed contract to do that it's very expensive but dark use cases that might actually be be worth it there also be supported for made safe and store G so regarding not that distribution so in part right now there's two ways you can distribute your your DAP would embark one is that you do impart build and it will create a directory that as your old your DAP all the needed files and it can just copy paste it and put it on your web server for instance or you can also do embark deploy ipfs and and this command what it does is that the it deploys or contracts if they are not already deployed build your app and uploads it uploads your your def for to IPF and then it shows you okay it will be available and this URL or this URL in that case it's a gateway so that's why I was supporting a part one and in part two will support swarmer PFS made safe and store Sergi as the centralized storage for for distribution so finally the other way that I'm park also true this was also support that distribution will be as a desktop app so it will have a command that will automatically create a full desktop app with the DAP for Windows Linux and and Mac it will also include the binaries that are necessary depending on the configuration that you choose so in this case if you distribute app this way and your app uses a ipfs you don't need to worry if your customer or user as a PF yes because if it doesn't end then the app will use the binary that it comes included with it all right then and that's it more information you can find it in in github if you if if are passionate about that development please join us at that's our gita channel I thank you very much for your time thank you 