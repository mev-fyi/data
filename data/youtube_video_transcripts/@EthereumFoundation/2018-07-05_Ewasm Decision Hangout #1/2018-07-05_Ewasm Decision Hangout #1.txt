from everyone to the first-ever he was indecision hangout which would be a prototype to the prototyping the decision process on changing anything and it wasn't and we for every one of these calls we record them and we will try to livestream them but at least published recording anybody is free to join and of them is usually announced two weeks prior and we have a github issue to track all of these details as well as all their proposed agenda items which everyone should propose agenda items prior to the meeting preferably a few days before the meeting so everybody is ready to read on them for this meeting we already have it seems like seven agenda points to discuss and I think we haven't done the groundwork to make a decision on what kind of order we want to go through these agenda items anybody has any anything to add to this or any questions so far [Music] Alexis here I'm glad to be on this call and I've looked at the agenda in there I probably wouldn't be able to contribute much to any point apart from the pre compiles and I won't be able to stay for the whole call I will probably need to drop off in about half an hour so if you could get that point like the pre-compiled point earlier that would be great all right so the have is one of them is the pre comprised discussion and we have one other tinier issue which is just proposing to change one of the exposed function names which should be a very simple decision to be made there is one bigger one to discuss how certain exported functions can stop execution and three of these would be a self-destruct a revert or returning data and finishing execution that probably is a bigger discussion and the last one of these extra changes is a versioning discussion which probably we should just give work for this call I have three giant topics I would say proposed by panel one of them is how agree to kind or maybe discuss the process of how have you defined the interfaces and have can be changed interfaces and I guess as part of this is a proposal to maybe offload some of the discussions to each research as opposed to github and the last proposal is it is again probably a really big topic discussing different metering options so I guess based on that and based on Alex's request does everybody agree to start with the discussion on the pre-comp eyes all right I can I can give it a bit a bit of intro to the precompiled discussion so basically this idea came based on a couple of face-to-face discussions at the etherium client Developers Conference of which I think all the recorded talks and videos should go up soon I'm actually looking forward to it and there was a quite a big block about introducing it wasn't and basically what this pre-compiled proposal means is so far there was an understanding so initially the understanding was that would be introduced in the maintained parallel TVM and at some point later this idea shifted to having it was introduced through sharding but it seems like the charting still will take a couple quite a bit more time to be more finalized and be in the stage of discussing it wasn't more execution engines however there is quite a big need and push from the community to have more features in the main chain and most of these features come in the form of a pre compile because the EVM wouldn't be like flexible or speedy enough to introduce certain features and some of these features for example would be new hashing algorithms when you algorithms regarding crypto mostly so the idea here is to maybe introduce a subset of e wasn't which the subset would be enough to implement recompiles and during this process we would we would gain a couple of things with a reduced exposure to some of the risk risks already identified ooh he wasn't so basically if we decide that these pre-compile follow the way pecan pies were designed so far that means they have some kind of a gas calculation logic in them it wasn't at all so basically this reduces the entire process on to introducing a wasn't VM into the clients writing these pre compiles once in a language which can be compiled - he wasn't testing them fully and that that should be it this reduce this removes one of the other concerns which comes up quite frequently is the problem of JIT bumps this should be eliminated because well fairly eliminated because the we don't need to test for well for any kind of contracts we have this limited set of contracts yeah I guess this this is a very long intro to it so if anybody wants to speak up and raise any concerns for yeah please comment on this proposal if we're talking about user deployed recompile install the main chain another concern that we might have is a implementation specific owner ability with the jet engine for example if we have every single person on the chain executing a user deployed we compile that exploits a vulnerability in the JIT that allows it to execute arbitrary code on every single host basically every node on the main chain could be compromised because of that if they're using well every node that's using this change in of augmentation with that Willner ability concerns that house and if they I think probably this exploration wasn't clear enough I can clearly see that this is kind of like a limited proposal so it was wouldn't be wouldn't enable and open up the door for anyone to deploy contracts it is really to introduce pre-comp eyes as they are today in a much more quicker fashion because right now if someone if they need to entry is a pre compile we need to first agree what's the the API had a pre compiled words then all the clients have to implement the own version of this pre compiled with native libraries so the go client would do it and go the see fine put it in C etc and tests have to be created for all of these and then somehow it needs to be ensured that no consensus bugs are there so this is quite a lengthy process we could save here quite a bit of time if there's only and probably to do this other kind of risks if we have a single kind of implementation and we wouldn't need all of the other clients to see implemented natively yeah so I completely agree with this if we introduced it as the like a first step and we don't gonna open it up completely for at least in the beginning I think it's very useful to just introduce it as the first step we're still the core developers we'll be adding the brick house but it's simply going to happen much faster and they will be less Lockton do adding any freaking pounds yeah for me this sounds good even even better than good so think that would I think that the the so are we going to actually use metering contract to estimate the gas cause for for pre-compose or that would be something for later and for for now we just provide arbitrary formula for calculating the gas goes right just to reiterate that's one of the challenges with this approach is that if people are running an e an e was a reference implementation of a precompiled then there's no problem doing the gas math but on the other hand if the one particular client decides to implement the same pre-compile natively then we're going to have trouble getting the gas metering to line up and I think the the gas metering probably opens a lot of different questions because it's a for example we have to come to I guess an agreement on on the gas metering and that may delay the process but on the other hand coming up with random gas calculation rules as we have today is a challenge on its own so I don't really as least for myself I don't really have a preference for either of them but probably we need to explore both of these options a bit more depth than we have done so far well I think if we're using DM you want some kind of precompile system as a way to simplify a deployment of pre compiles on main chain then we shouldn't be thinking about well each client implementing its own native version because that wouldn't really be much of a difference from the way things are now what I'm saying that the pre-compile implementation should be well I guess what you're saying with the US and reference implementation make sense but at the same time it could also be beneficial to steer away from native implementation of recompiles that are well initially implemented and wasum because we could figure out the gas calculation and it would really be kind a agnostic to each comment in the sense that the only thing the client would have to implement if they want to is is their JIT well yeah I think if if we do the pre compile in the first step just for with the introduction of the new kind of primitives then it makes some sense to somehow inject it in the decode because then you have to have run exactly the same code as everywhere but then the question is how you do that you do it by your function calls or you just have a like a counter inside the your code which is you know incrementing through and that's something when it which is a certain point which is kind of more efficient I would comment on the table if the so following up from Jake's thoughts if we allow clients to still choose their own native implementation of the pre-compiled as well as we allow clients to use the e wasn't version then we lose one thing we cannot use metering we have to come up with these random gas calculation rules but second we gain something which is we don't require all the classes over T wasn't we can have at least initially we can have a subset of points which tui was am and the rest may decide to do it natively and then it's a much more slower process to expand that support base but on the other hand we may be able to push this through much quicker I'm not sure it makes more sense I mean it's far sorry Google okay in the case of sorry hit just go ahead yeah I just I mean I don't know much about the II wasn't but I read a little bit about it and apparently you can construct basically the the study graph of the program flow in it wasn't so it allows you to essentially post-process any candidate implementation and just in you should inject something and there I thought it would be quite simple and then it doesn't really matter whether the client in implements the Divas in natively or not they the the actual code will be there but yeah I mean if they want to be compatible with the like in a consensus compatible so if the client wants to do the Nativity without a bottom and they want to be consensus compatible then they will have to do it in other way otherwise they will just work from the year from the II wasn't supported client so I don't think it's a big problem that's similar to what I was going to say basically in the indicate of just trying out the e Osman compile system it does make sense and not require all clients to support that you wasn't bring compile system at the same time that introduces much more surface for consensus failure because you have some clients running their native version and I'm running the D Watson implementation and that requires a much more I'm kind of like wide service for reviewing each pre-compile basically that's the drawback of not requiring all clients to use the Watson recompiles because then you'll have to vet both the universe and implementation of the pre compiled and the native implementation this is Paul here there's no way really to force people to not have a native implementation they're gonna do whatever they want if they have a speed-up I think we should are we at first exit are we talking about issue number 104 for awasum design correct yeah I think we have to also I think it would be wise if we can just compute autumn automates computing an upper bound on gas use to do this we would also have to restrict what we can do and Wasson for example we wouldn't allow wild loops we would have to you know be able to know how long each loop is going to run but you know statically before it runs we would have think you know but finite you know the you know predetermined loop number of loops you'd also restrict these call indirects and then we will prevent recursive calls if we can do these three things I think we can compute as statically as alexei was speaking based on the abstract syntax maybe we're going to be able to compute I don't know for sure but but we can maybe compute an upper bound on gas use once we have this upper bound that would be our automated automated computation of gas metering perhaps we would you know sometimes have some error of cases but we would you know use that upper bound no matter what happens and I think we should precisely do this automate this gas computation by doing some static analysis I wouldn't go as far as restricting the loop account I would agree with restricting the recursive function in indirect I think but restrictive restricting the loose it's it's probably a bit too harsh and I wasn't thinking about actually pre calculating the upper bound but simply post processing the there wasn't binary just to basically inject a counter in every loop and essentially that will just increment it you know yeah that'll work there will be a little bit of a slowdown because you have to compute the metering oh yeah that works I guess yeah but you basically can do it in the in in in a kind of in a way that it doesn't require you to have some sort of trust checks because as you you just post process it in such a way that you introduced a new variable and then just increment it instead of calling some sort of consuming gas function and in the end of the execution you just basically bus this variable back yeah there are many options to compute gas into you know meter things one is to have an internal variable maybe a global variable WebAssign so up assembly another is to call out to use gas I don't know if there are security concerns for one or the other but yeah there is overhead certainly personally I would like to see fully static analysis for static analysis we only allow for we followed the Viper model where we only allow for loops of you know a certain number of iterations that are known beforehand this type of thing but if we want to be very generic with our pre-compiled sure we can allow while loops and arbitrary you know we'll let them let the gas run as long as you know as much as use as much gas as if you want to use so actually with asked a question here what would be what would did the process over the best way to propose this and i guess on what forums i would think probably all core devs will do one of those forums to propose this idea i also think it would need a bit more description substance surrounded then then the current issue has and but i'm also wondering if we should kind of spend a tiny bit more effort on looking at what kind of become past people want and maybe maybe even implement one of them and and just have some kind of more information around this idea then we have right now and we could probably prototype that with CP material because that should be working and you know what kind of like x or like my stones you're shooting for yeah just in general probably discussing the process of of proposing this to the wider audience well I think we can is an example precompile we could take something which is going to be the right things like a BLS signature verification which will be useful anyway for the future process or something that Nick Johnson has asked about which is the sum of the works for the DNA DNS verification or something like this so yeah you could get a couple of examples like this which have some some practical use in just implementing yeah I would I would choose something that is waiting for a long time already so one is one I remember is play crash and the second one is what Lexi mentioned this elliptic curve or some other kind of yeah that's also useful deny them and there was some team that I wanted that really very much and they they implemented I think that in in every client so that that would be like my two candidates for that but maybe there is this more in EAPs that I'm not aware of yeah I guess we need to have like a really good understanding off of half our clients are regarding was of support and we get some kind of update about that last week probably like one of the t blocking parts were like one of the decor parts we have to probably wait for is supporting go aetherium but I think that's like really in a good state and then probably writing one of these pre comp eyes as were mentioned and potentially testing them and and looking into different kind of metering options at around the time we proposed this probably would be like a good good way to take it but probably this this metering whether we would want to have like random gas rules or we would like to use a more deterministic process probably that is one of the bigger questions to be answered you know I will this deterministic process of you know precomputing gas an upper bound on gas before it runs we need an algorithm we I don't you know my sort of hope that we would use this would need to be supported by some evidence an algorithm a runtime of this algorithm and I have done nothing like this I haven't provided anything so I think it's one of my jobs to sort of write that on an algorithm implemented in PI webassembly show that I'm computing an upper bound of gas may be proof some something that I'm doing what I'm what it's supposed to be doing so I guess that's one thing that I owe you guys if we're gonna do it with the pre computing and upper bound way so it's that bound which would be charged the user yes no matter the run even if it sort of errors out early for like an invalid input it would always be charged up or he charged the upper bound yes do you think that would be like a good incentive we're all kind of freaking biased or a certain types would would be good to be done this way certain types yeah certainly uh if you need a while loop for example this would be bad because if you don't know how long it's going to run before you run it certainly you wouldn't you would have to give a guess limit so certainly you have some idea of how long it's gonna run but certain maybe there might be some algorithm for your doing some search and sometimes it might find something right away whereas other time you know and you would like exit early with just used a little bit of gas other times it might run much much longer yeah so it you lose some flexibility with this deterministic way because you have to you have an upper bound I argue that you will have an upper bound one way or another because you have to have a gas limit anyway and if you need a higher gas limit or some algorithm with more you know that has more iterations then you can make a new pre-compiled for even you know do whatever but yes certainly this limits the the algorithms you can use to be all not torn incomplete but almost or incomplete there's a Brandon Ike Twitter thread about maybe almost tearing completeness is enough obviously this is bad for marketing because cos or someone might say yeah well we do have turing-complete but I think it's worth at least leaving this as an option among the other options yeah so if we look at some of the the hash functions I think pretty much all of them have a fixed number of rounds and in each round you have a fixed number of operations I think that might work well in that case so maybe there are like the whole class of free compiles that would for for which there would be enough but I'm thinking if we decide to do that we would be able to extend it later on if we realize that actually that wasn't enough for other cases you know I think we should explore whether we can put it put this limit now and then you know the remove it later on if it's really needed I think it's not enough for even for hard functions because it works like it has a constant cost for a single block but most of the implement pre-comp eyes we have I can can hash arbitrary length of data so it's not it's linear it's it's proportional today it's the input date in input length so I think that breaks this model already I just what I meant it mentions to be conscious about time because this was scheduled to last 20 minutes more from now and probably we we're not gonna answer all of these questions we have the probably it would be good to some kind lay out a plan how we can work on this communicate about this and have maybe more calls I think everyone on this call is as part of the Decatur channel so prob that would be a good way to to quickly discuss matters but probably we need to to figure out who is interested in in writing some of these actual proposed pre compiles and in the language crying to awesome and and who would be interested in figuring out appropriate gas costs for its better through some kind of deterministic process or whether to other means okay let's take a discussion to duty to the guitar because yeah yeah I guess anybody who is I mean anybody from from us on the call or even anybody on listening tests from recording please also check out the there should be a link I guess on YouTube but please check out this Gator issue and maybe leave a comment and also joined together channel I suppose this also ties into another decision we should make this whether to move some of the discussion over to eat research I don't have any particular opinion on it but I suppose that um that idea there also ties into another decision we were supposed to make almond skull you know I wonder how much hmm how much of this would qualify under the the research category and whether each research is the best going to have discussion about this or is this a more practical discussion which is usually part of the whole core Deaf's process but or the third option SSF to date you have it on this he was in repository what are the proposals and what kind of parts should be moved to each research I think that certain topics such as well more like high-level design discussion would be moved to even research for example the yeah I just find in things that are non-trivial example an example of something trivial would be the name of a method and the an example of something non-trivial it could be moved to e3 search is probably more like how how did the EDI should be designed and what it should support in a way Pavel you were the one adding these three proposals to the agenda do you want to create appropriate issues for them on github for the moment and yeah I mean personally I would be happy to move certain things to the east research forum if that brings us a lot more response and discussion because probably that is the thing you're lacking at the moment yes that was one one of the the reasons it's likely exposed the issues we are heading but I only meant the e I for that because it somehow also effects account abstraction and maybe something like that and I don't have for peak of this ideas and yeah at the moment not this wharfing yeah what's with the countenance abstraction considered seems like a good idea to move yeah the topic of the EEI to ethan research just because it's also kind of bottled up in the design repo at the moment come on i think we should maybe enumerate lists of option we'll spend some time writing things down in a way that's easy for people to understand if we start posting things on each research that is sort of not sort of organized them ad and in might the discussions might not be you know what we should discuss okay so i think we should spend some time curating and writing things nicely numerating all over our options and letting people sort of a high level would it make sense to for each of these discussions to have an entry on our github design repo and then maybe iterate there before it goes to the beach research or at least for any any each research topic there would be some kind of cross link from there so it still could be tracked through yes design repo yes and even more so we can maybe try to build some prototypes whenever possible accumulate statistics whatever the case you know anything to sort of you know so we can you know give people that are going to make you know the rest of the community some sort of information and some sort of clues and hints on what what's better and that kind of yeah so let's iterate first do you know since you posted those you want to create an issue for each and you just listed the EEI design process redesign process as one of the points do you have them can you give an overview about that with any kind of proposals already or it's just like high-level i can i can fight about so my idea is to actually review current AI methods one by one and some of them are kind kind of obvious and probably just put a lot of discuss about and some some are not like that but like what I wanted to do is to actually create separated threads about each one of them may believe some alternatives and some yet mostly have some on um in text discussion about each and when we finish that I would propose the whole document as another version of a draft and that could go to yeah bigger peer review so depending if there is this actually something that it's not very clear we can read for if research in some cases but mostly I will keep it as github issues actually I created I think two Pro requests which like each of them then tries to address some basic AI methods improve documentation a bit and that as I will see it to proceed with that yeah but that's all I can describe this as well as a meat matter issue describing the process idea yeah please do I think it's really important to have a Venetian pivot this and have more clarity and probably that would also give us like a framework had to make decisions yeah I cannot promise this framework yeah but however you have a good description of that do you also want to give like an overview of the alternative gas counting implementation the proposal or is just them yeah it's probably better just keep it this time [Applause] so I wonder if we should them so one of these easier ie I changed proposals we're falling into the category of a simple name change which I gathers like the sentiment that may may be okay be there for the discussion on a tree search but like one of the other points here is this anything we're gonna sell this track that probably something we cannot make a decision on this is anybody interested to try to make a decision on something as part of the first goal the easiest one is the return to finish it doesn't matter to me do whatever I used to return underscore whenever I needed to not conflict with Python return and I think a lot of people will do like return underscore or whatever there's in wobba sanity well well can you hear me I think you were picking up if you could just repeat please yes for the return to finish if it doesn't matter to me I use return underscore I think in webassembly the return there's no key word you're just using utf-8 strings for the imports so I think it's fine to use return for what in terms of webassembly but there might be some conflicts in are you still there I think we lost Paul yeah for me this changes its improvement so I would go with that there's there's the idea for different name dumb names and finish yeah but it's improvement of what we have at the moment so I agree to to merge this one yes I agree with that I think we need to change its name because we have some conflicting in many languages that uses these as a key word the only thing I see is that for example right now for each one of the AEI methods we have we we see that each one of these methods is related to to an opcode and if you already know the doctor who can guess what the middle metal is doing so maybe for the mute when we change it to from return to finish that I know we are talking about something like the return of code so maybe we could change it to something like return data or something like that so we can still know that it is related to something like the return opcode yes it is a potential issue return data probably is is is a relevant name but unfortunately I think it would be I'm not sure if it would be confused with returned data copies nice return data size but probably this is something we should actually discuss and so do you go if you want to leave a comment on the issue that that could help in and sparking the discussion and I also also think again looking at it that I think it depends on issue number 72 which is just self destruct clarification self destruct / rebirth / return which was another agenda point because if we call it finish and actually the execution it isn't finishing we could still up to the contract to to finish the execution then probably finish is misleading right so yeah I would say we cannot really make a final decision on this but please leave leave comments on whatever was said because I think it was useful input and I hope we can make a decision on it and probably end in the next call but before the next call we should we should think a bit more about the the process of how we make decisions and and how we whether we move any of those into each research so what do you think what would be the best way to discuss this and what time should we have a second similar like core devs it wasn't court have scholar it wasn't decision hangar should we have one sooner or should we have one in two weeks or even three weeks and have more of this other discussion but the process done or should we have this call to discuss the actual process based on the process rather I like the motto that the etherion foundation uses for AI piece where you submit a proposal you do some background on a some you you have some like good pros cons and things like this and then people will respond and then you'll have a text discussion where people have time to think about things and then then I don't know but I thought I liked the model of VIPs yeah I like it too I mean I would say like it can be some like introduction given on some of these meetings but then it should go to some some offline forum in text or something like that to actually accumulate pros and cons on paper and if that's it's kind of like reach some any stable point then we can come to the meeting again and discuss like maybe some yeah and and make like some final decisions on that but this this middle middle middle term process which is quite long it's think it's it doesn't suit online meetings for a while well the idea of an EIP process is that the discussion happens asynchronously offline and then you know once a proposal is deemed to be technically sound and has been merged and stuff and you know someone can bring it up on a meeting and champion it at least in theory the vote to sort of approve it should be quite straightforward at that point I think that model is pretty efficient so can we create these proposals as an issue on on the design repo for the moment yes but it's important to say this that sometimes you have some sort of proposal when I had students I will tell them write it down like clearly write write it down exactly every word is important and sometimes when you do that the issue sort of disappears because in the act of writing it down or in the act of writing down it down you have no idea so I think that we should have that in the design repo but I think if you're proposing an idea or you have some sort of something to write just write it down clearly if there's some something unclear say I'm not sure about this part but you know it should be written down not some vague thing that is sort of interpreted differently by everybody then we don't know what we're talking about that's it if they are think we're coming to an end to the allocated time slot and I personally need to leave roughly at the end of it but if there are any last minute comments or proposals please say it right now Alex when when do you think you'd like to schedule the next to these calls or maybe how often should they be scheduled I was shooting for every two weeks strictly every two weeks I think we can try to do that and but in in a few days in a week we should we should know that it makes sense to make it or not I wrote up some of these comments we have made at this call as a as a comment unto the decision hangout issue but basically most of the comments I made were like we need to create issues for all of these and we need to discuss them there and if they they are kind already we have to bring them onto the call so I hope we can make a call in two weeks if if everybody is is laying out these ideas more clearly in a written form actually Lane have you did you keep minutes no I haven't but we have a recording on YouTube so we can submit it do we want to to publish minutes or just published recording and have this summary there I think you'll find not having the minutes were for right now yeah I think at the point where we're actually making decisions on these calls having the minutes is pretty important so I'm happy to do that thank you everyone for being here today and sorry that I want this like really strict schedule for the moment um I think I think we made some good progress and probably realized some of the limitations we have so far I'm really optimistic that this gonna be like super cool and be good we're gonna make all of these changes really really fast thanks Alex thanks for organizing yeah thanks thanks Alex thank you thank you bye everyone [Music] 