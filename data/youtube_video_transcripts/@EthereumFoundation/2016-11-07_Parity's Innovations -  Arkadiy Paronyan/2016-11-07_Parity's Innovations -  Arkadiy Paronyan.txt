hello I'm on one of the court developers behind parity and today I'm going to speak about what we have been working on the past few months and what we have in store to come so parities you know is it fully featured if your own client has everything you need to run a full no ordinary theorem network can sync the blockchain it can do mining it has the API compatible with other implementations but it is also so much more so yesterday we've seen what the user experience might look like with parity and it will look like that soon and today I'm going to focus on technical features that are would be interesting for tap developers or watching developers in general so parity is written in rust rust is the relatively new programming language out there which is particularly well suited for system programming and building fast and reliable software it has memory safety and concurrency safety guarantees know that without sacrificing performance and it works very well for whatching applications where reliability and speed are equally important and it worked very well for us or Tim was quite happy with this choice and yeah we saved us a lot of time so for all the developers out there I would greatly recommend to take a look into it and it's also one of the reasons that we believe parity is the fastest a theorem point out there but more on that later and from day one we designed parity to be modular and configurable so you can use it as a library we have what we documented internal api's then there is a ton of command line options to tweak various as aspects of paratus behavior and soon we'll be providing configuration file so that you could easily manage all these options and then presets so that you would have a particular set of configurations optimized for usage scenarios such as mining or Runyon and the Raspberry Pi or during that development now let's get to performance a bit I'm gonna show you just one figure here 20 1910 sections per second you know that's how fast parity can handle sink in the bottom that's the main homestead watching first 2.2 million box with nine and a half million transactions in them and that includes full work and transaction validation and that's how fast is the that's the average transaction rate at parity can do and there is still room for improvement and we're still working on optimizing this even further now we also take a great deal of effort into optimizing latencies to work and transaction import times when the new box arrives from the network it gets imported and propagated in the least possible time and all of that comes without using too much memory so that you can easily run parity on a second generation Raspberry Pi and it won't break a sweat and you can even use it as a DEP server now let's talk a bit more about security probably heard all kinds of security issues with a few memory recently so one example is if you expose your RPC to the external Network and you unlock your account even for a short duration you will probably get your phone stolen and nowadays most of the clients work around that by duplicating unsafe api's and we took it one step further by introducing the secure transaction signer architecture the idea is that all the api's that work with private keys such as send in a transaction and they become privileged and they no longer execute immediately instead when I DEP sends a transaction it is added to the confirmation queue and it stays in the queue until user confirms or rejected and that confirmation is done over an additional secure channel that is not exposed to the external Network and it is isolated from the abscess run runs in the sandbox isolated environment and it also requires additional authorization which comes in the form of the observation token which usually needs to enter first time before using it and yeah I can show you the UI for that so that's a bit outdated version but still so there's a UI for confirming transactions so this is a version which is the Chrome extension so when it's absence it's transaction and I can pops up and there is the list of transaction to confirm and you can do that informations action now we have further plans to I saw is even further to move it to a separate process or even to a different machine the one with the key store so it can be secured and would communicate with a node over a secure IPC channel again there's a lot more features parity start with state tree pruning this is something that can greatly reduce watching database size so it works by discarding the all watching States so that the state is preserved only for the last thousand walks and the rest is discarded this means you won't be able to say query parents that account had thousand Watts ago but not that many users or applications needed information anyway so it is discarded by default and that saves a lot of disk space no the database I'm size for the way the swamps that network is under five gigabytes that feature turned on but if you need for both data you can still have that there is an option to keep it transaction Jason that's the API that we've introduced recently it's an extension and it allows you to query extended transaction information for example you can pick an account or a set of accounts and you can query transfers involving these accounts or what the hell watching and this will include transversed originating from smart contracts something which is very hard to do using the standard RPC and if you run this query over the whole work chain it will still work fast because we use a lot of optimizations to make them work past this small to have a boom filters and so on and this is something can be useful for writing something like an action Explorer or for any adept it needs extended transaction history okay it's an app shot in this is something simple basically you can save state of your watch into a file that file contains all the state information of the recent state information and a few thousand of the recent Watts and it is heavily compressed so that the current snapshot for the way this homestead is under 150 megabytes and then restoring from the snapshot takes only a couple of minutes yeah use run restore command and in two or three minutes you're good to go now as I mentioned it doesn't contain all the blocks at first you end up with some of the blocks missing the older blocks but as soon as the node starts working let's sink to ready state it will download of the missing box in the background so you end up with the whole watching after a while so this doesn't compromise the network security now we'll be taking this even further soon by introducing the snapshot sync or as we call the work think the idea is that every node well every parity note for now on the network will take a periodic snapshot every eight ten thousand walks and that snapshot is the same across all nodes and the nodes that start syncing and download these snapshots from other peers and sync from them so yeah basically you start from stretch and in two or three minutes on a fast Network you you can start working with the theorem doing transactions and all that okay private chains private chains are extremely easy with parity all you need is one files it's a JSON file that lists all the private chained specification we have a few examples basically it contains of it all you need so theorem protocol parameters such as the target walk time Genesis board data network parameters such as network ID or a list of good nodes you can even replace proof of work with proof of authority which is basically a list of notes that are allowed to produce walks without doing any mining and something which is not here but which something that we'll be adding soon is the ability to include building contracts written in native languages such as C suppose first for rust basically you just declare a dynamic library and an entry point into that paraty we'll call it when it's time to have a smart contract so there are a lot of more smaller features but I'm gonna focus know what's about to come so the private proof of a forest change that have mentioned earlier they're quite basic at the moment we want to improve them by making them Byzantine fault tolerant so that you can have a full-blown industrial grade permission box in solution build on top of that stratum protocol something requested by our a miner's community also coming soon this is the product code to push what work notifications to minor over TCP wide find so initial work has started on that and it is coming out eventually and of course metropolis transition as soon as this specification is ready we'll start working on it and be sure to release it as soon as possible yeah this is para team we encourage you to go check it out check out our wiki if there's features that you might be missing in other clients and if you have any questions join our discussion and guiter will be happy to answer them all yeah thank you thank you very much agony 