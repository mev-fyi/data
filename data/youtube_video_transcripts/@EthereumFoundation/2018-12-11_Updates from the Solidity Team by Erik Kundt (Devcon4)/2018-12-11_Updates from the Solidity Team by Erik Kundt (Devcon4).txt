[Music] so hello everyone welcome to my talk I wanted to give you some updates from the solidity team so my name is Eric and I just joined the team half a year ago so it's a nice opportunity to actually be here and talk about what we did so far so first of all I want to quickly give you an overview of what I'm going to talk about so first I want to introduce some of our new tool team members to you then I want to talk about the audits that the compiler got also want to talk about solidity zero five zero so which is yeah probably what what you are going to be here so and then I want to talk about what's coming up what we're currently working on and what will be released and coming upcoming versions and also how to contribute possibly to the project so okay first of all what happened to the team you might know that for the last year's almost like Alex and Christian were working on the compiler and on infrastructure but now we grew the team to seven people in total so we have another Christian the joint who cannot be here unfortunately then we have Christian you might know him and then we have another Christa joined and he is our technical writers so he is mainly working on the documentation and then we have Danielle me and Leo and we are all working as software engineers and the team next one what happened with the audits so last year the compiler was audited by coins back for augur so and this happened in the end of 2017 and they discovered ten issues fixed 9 and the last if she was part of the inheritance changes and you can also find a report on medium so the second audit that we got started in June and was done by the people from Zeppelin I was sponsored by the foundation and by auger and they worked very closely with us and they audited a specific compiler version but the issues are being fixed and developed already and so most of them will be part of zero-five-zero and there's also an interesting talk about that about the audit itself it's going to happen tomorrow at 1:40 p.m. at ultraviolet room and it will be done by manual from open zeppelin and he will talk about the outcome of this audit all right so solidity zero-five-zero we're almost there so this ulti is ready but salty Jas there are still some things to be done but we are hoping to get this done in the next days so yeah watch out for the new version and yeah now I want to talk about what actually changed in the new version so we had some design goals there so we wanted to improve safety that was the first and foremost goal and we wanted to do that by requiring users to be more explicit by removing dis ambiguities or weird behavior and also by adding runtime checks to the compiler so I picked some of the language features some of the most important ones so first of all we now have explicit types so and explicitly the visibility explicit data locations new scoping rules for function local variables we have a new constructor syntax we also introduced emit for events then also the address payable and some others and now I went to go through all of them in detail so explicit types what that does mean so here's an example of a contract so we have a loop there and this example still uses var for variable type and here it's an issue because the compiler did used the type of the variable I to an unsigned 8-bit and so the maximum is 255 so this condition will always be true which means that this will result in an infinite loop so now you have to be more explicit about the type and virus now disallowed which means you have to declare the type of the variable I and now it will be fine so next thing are explicit visibility's so for another example here so we have a contract here and it has an owner it has a constructor that calls an initialize function and here in the initialized function the owner will be said the caller will be the owner the caller of the initialized function so and now if withdrawal is called there's the require that the owner has to be there at the caller and then the balance gets transferred so the problem here is that functions are the visibility of functions is public by default so anyone from outside could call this initialized function and then also the requirement would hold the withdraw so capir then also withdrawn and we changed that so the visibility specifiers now mandatory what doesn't mean so here the constructor got visibility public and the initialized function is now internal which means that can only be called internally so that's and then here you can see that the with the requirement of someone from a if the with Ron is called then the requirement will be true here all right explicit data locations so I've got another example so here we have a contract and you have a struct called data and we have an array of this struct and the function f and here we're going to access this this array and stored into the variable called member and as I said the location specifier is now mandatory so you have to use storage here in this case okay so storage references it's the same example that I had before so we still have destruct we still have this every year and we have the function and we are initializing your member and setting the name that was given as a parameter to the function to the member name of the data and then we're pushing this into the array and now they have to be initialized so the background of this is that we have a component and the compiler that tried to find out if I've storage references were initialized before and because in some cases that was not possible so the decision was made to make it explicit so that you have to initialize storage members storage references before using them alright so scoping rules before 0 5 0 we had JavaScript like scoping rules so in this example you have to revive arrival I and it's declare and and there the 3 is assigned to to it before it was initialized and because one of the goals was to be more explicit we also changed that to block scoped c99 style scoping rules yeah and so here for the two for loops that you can see the is declared also in this the for loop and it's visible only for in this block so that's the reason why you can use you have to really clear it in the second in the second loop then we introduce new constructor syntax so what does that mean this is an old example so I took the I took the contract that you've seen before so here you can see and the contract is called old and before zero-five-zero to define a constructor you had to use had to declare a function with the same name as the contract but again to be more explicit about that and to prevent mistakes we introduced a new keyword called constructor and it has to be used to D to declare the constructor and it's not allowed anymore to have a constructor that has the same name as the contract what next so emit for events here again the the example that you've seen before so we have a contract here and it has an event called withdrawn and so we have the function withdrawn it's from from the example before so we have to require again and we have to transfer call and then the emit the event is submitted but this can also be confusing because it could also be a function call I mean there are coding guidelines that say that you should start your function with the lowercase letter but if you don't do so this can there there can be certain mistakes be making and again to be more explicit event and vacations must be prefixed so here we introduce the mid keyboard and if you want to invoke this event emit has to be put in front of this all right next one address payable so we split the address type so in this example you have a target and you want to transfer one ether and call transfer on this target and now address payable is required so that means that if you have an address type that is not payable the transfer function would not be available on this type then there's a second example or explicit casts so if you want to convert this to an address type you need to be explicit about it so you have to use a for work function payable fallback function so that this such that this example would compile so and then there are few other things that we changed so with the IV I encode and decode changes and also some changes to the call family so called delegate call hijack 256 now take a single byte parameter and if you want to if you want to use it then you have to call have to use the API encoder before to encode and decode the arguments there and also would change something to your view pure and view pure functions now you study call with the exception that for library view functions they use delegate call and we also put together a list of breaking changes you can sign it our documentation and we also put together our compiled the list of how you have to change your contracts such that they will compile with zero five zero okay so what's what's coming up with the next versions we have fuel which is a very interesting topic I want to talk about we introduced some formal verification and form of the SMT checker we're planning to do some inheritance rule changes then also contract metadata and to avyayam folder v2 so what is you I don't know if who have you attended to Alex talked yesterday and the prism room so you will is an assembly language and it's an intermediate representation internally in the compiler it aids auditing the code base and generated code it allows for a lot of optimization and it also allows multiple backends so solidity could compile to you and then in the end to a VM and also solidity to you to you was that will be something that might be interesting in the future and also Viper could and that's empathize use you to also then support EVM or it wasn't back-end and if you want to find out more about you you can also consult our documentation or yeah and I also brought a short example so that you get an idea of how you'll just look look like and here's the power function and we have high level high level keywords like switch case default but we can also but as you can also see multiplication and also dividing there it's a representation of up codes and a more functional style so like I said before this helps this increases readability and also helps auditing the code and if you want to find more about find out more about Yul and also about the optimization that I talked about then I would highly recommend you to join the talk today by Christian it's a 4:30 p.m. and prison and he will talk about the optimization that we put in already and also some things that we plan to do in the future alright so coming to formal verification so we're using technique called SMT satisfiability modular theories and this helps the seamless verification of safety properties such as under flow overflow division by zero trivial conditions or unreachable code and also assertions so verifying runtime checks at compile time and we have a component for that and it's called the SMT checker so this is one example so you can able the SMT checker is an experimental feature right now and you can enable it using a pragma your pragma experimental isn't it checkered and so if you compile this example with the Santa tracker and abled you will get some warnings so first warning is that the for loop condition is always true so I is initialized with 200 and that means that as greater equal zero this condition will always be true so that's the first warning and the second warning is an underflow resulting in a value less than zero and this is a I then gets incremented so at some point you will get an underflow here let's give this example and there's also talked by our colleague colleague Leo and it will happen tomorrow at 4:00 p.m. on the ultraviolet stage and he will talk about some details on how to actually use the SMT checker what's coming up so we're planning to do some inheritance rule changes and so inheritance is a crucial part of solidity contracts but there are some open questions so what about explicit shadowing can visibility our state mutability levels change and there's an open pool request right now where a lot of discussion is happening and so we're hoping to get more people join this discussion so that we will come up with a cohesive cohesive set of rules that we can implement what else or contract metadata contract metadata is generated for each contract and it stores as a JSON object and it contains all details needed to reproduce the compilation and as form hash of this metadata is appended to the to the byte code unfortunately it's not used by a lot of verification tools that are out there yet and you can find the documentation about the meta that also in our documentation and this is how the contract metadata will look like so you have a contract version you have the language so solidity you have the compiler version is included and also some settings like compilation Target EVM version and if the optimizer was enabled or disabled because this will result in different output and here you can see the hashes that I mentioned and this is then included so then the IBI encoder v2 what is the IV I so we have a contract a V I am and that's the specification how and to exchange data with a contract and for each public function a decoder or encode and encoder is generated currently that's handwritten C++ code and it's it's very error-prone and it's hard to test so that's why we introduced the ABI encoder v2 and this is written in Yule and it ensures safety properties such as short input to short input or invalid values and it also supports complex data types such as direct multi-dimensional arrays and you can also play around with the new avi encoder and enable it via pragma a very experimental program alright so and then I want to quickly tell you how you could potentially contribute to the project so there are many ways to contribute so you can always request a feature we have discussions on existing design issues and also including documentation improvements and also the examples that we have in the documentation we an or issue tracker we have introduced some labels for example Help Wanted or good first issue so if you go through all the open issues and see the labels then you can probably directly start working on it if you want to and also you should watch out for get common boundaries or and if you have any questions about them about that you can always reach out to the solidity deaf Channel yeah and now we have some time for questions if there are any so I think there are two microphones here in front of the stage okay that doesn't look like there are any questions so don't what if they thank you oh that's a question so currently if you declare that your parents near me and looks so well toy BBB hello okay okay okay sorry so currently in solidity functions if you declare a returned variable that the function returns something and don't explicitly declare return there's no notices or errors about that are there any plans to change that fertility not that I know of I mean my the team is also sitting there so if you want to add something to that yeah I mean there's an I think there's an open issue about that we do warn if the variable is not used at all so if you never assign to it and do not have a return statement then you get a warning yeah there's an open discussion about how to how and whether to change that I have one more question so currently the function identifiers for the way that like how they're identified when you're calling them they only check the the only have the name and the parameters and the identifier hash right but this can allow where you can call a function that actually returns something or doesn't return something when you expect it to and even though it should error in that sense it doesn't because that identify only checks the name and the parameters are there any plans to include the return variables into the function identifiers no yeah that's something that hip to some people at the point where the compiler was changed to actually enforce the return size okay that's a very tough thing to change yeah I mean the ABI is something you don't really want to touch than that like that in the beginning but yeah okay all right thank you hello I'm currently using a by encoder version 2 to handle complex structure which is a very nice feature traveling solidity you say it's on your roadmap for the next next step however I my question is how dangerous it is to use a current experimental version and how long do I have to wait to have a proof solution for that and for the a bi-week encoder which I mean yes so maybe like one one part of your question was missing because like can you can be able to repeat the question yeah just I'm using it right now but it's still experimental so I want to know if it's dangerous to use that in production and if it's dangerous and it might change when will I have a good version that I can deploy on the main it um I mean that's hard to say so it's an experimental feature so I wouldn't recommend to use this in production at all and because we have so many things going on it's hard to say when this will be ready but maybe christian has in addition to that yeah so we're pretty confident that it's not dangerous to use the one of the main reasons it's still experimental is because it's much more expensive so the ABI the new ABI coder was built an extremely modular way where we have tiny functions for very simple tasks and that helps ensure that it's it's correct but it's more expensive because the EVM jumps around all the time and if you want to so and we will take it out of experimental as soon as we have the yule optimizer that will yeah remove these inefficiencies basically right so 0.5 has a lot of breaking changes right that's got backwards compatibility I've got contracts that are already deployed to the chain using previous versions of solidity and I'm running into some challenges trying to interact with those contracts using 0.5 because of the things the way that they were written back in a day using you know constant and you know various other bits and pieces do you guys you thought about how to write code in 0.5 to integrate to interact with existing contracts is that the thing that you've thought about or are you expecting the effluence that's going to write all in your contracts going forward mmm no I mean of course we're expecting this that you have contracts compiled with different compiler versions and so I mean there there is a plan for that so okay sorry Eric I just have one addition to that probably the best way to do it if you write an interface for your contracting that the interface is valid in zero-five-zero that's probably the best way hello thank you for the presentation so currently it is 0.5 which is alpha software what do you think will will it take to force ready to become 1.0 software and you mean in terms of time or I mean that's that's that's really hard to say I mean because like I said I just joined the project half a year ago and I joined it when it was in version 0 for 22 so now we're 0 5 0 so it might take a while but it's really hard to say when it's like in version 1.0 but thank you I mean yeah I joined the project only four years ago and I think it might still take some time to get to all right time is up but maybe we have so one more question and no ask about the capability of the language in terms of returning multi-dimensional ways like a way of struct or array of strings and also about the capability of the string datatype that has limitation in terms of getting the length or doing some sort of concatenation so and the question was when this will be changed yes I mean yeah at the point like your question about multi-dimensional Aries this will be included in the new API the encoder so if you want to interact with the contract and then if this component is finished should be and you should be able to use them and how about adding the capability to the string datatype you mean regarding the length and concatenation yes yeah I mean is there anything that we planned for for that in the future sorry I have to refer to is it working now yeah we're kind of reluctant to add features that have unbounded gas usage and string concatenation would be one of them but you can use ABI dot encode packed on byte arrays that will do exactly byte array concatenation which is something we discovered by accident or yeah it's a neat trick all right cool yep thank you a lot [Applause] you 