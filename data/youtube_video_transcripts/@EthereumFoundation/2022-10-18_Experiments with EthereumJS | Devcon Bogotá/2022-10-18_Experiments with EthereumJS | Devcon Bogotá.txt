foreign [Music] yeah welcome to this uh ethereum JS Workshop uh I'm Gabriel from the ethereum JS team my name is Scotty also from the ethereum JS team yeah so today we're just going to be walking you through our model repo called you know the ethereum JS motor repo so we're basically the JavaScript team of the ethereum foundation and what we do with the ethereum JS and mono repo let me actually bring up the slides it's going to be helpful so yeah what we do with ethereum JS is we basically build a set of tools that people can build upon so we're used by lots of uh you know JavaScript tooling that's here I'm sure you're familiar with and um yeah and it's really a great set of tools for people to learn uh about blockchain in general because JavaScript is a you know really easy to use language that a lot of people a lot of web developers are familiar with and um yeah we're focused on you know helping out a lot with research as well I mean we have a for example a client going but it's not a production ready client like like get and and others and that's kind of an advantage for us because we can jump in early for you know in your eips and Implement stuff because we're not constrained by the maintenance of like a production ready client for example so yeah we've been helping out with lots of you know newer eips so yeah that's just you know an example of that so yeah three of the latest like PRS that are in progress in the modern repo or you know a stateless vehicle State manager to help out with vertical trees that game and a bunch of other people are working with Erp 4844 which I'm sure you've heard about like Proto then charting EIP and uh yeah Beacon chain withdrawals which are going to be uh part of the Shanghai uh hard folk hard Fork hopefully I think Community would be pretty mad if that doesn't get in so yeah you want to sure I'd also like to just say hello and if you get a sense of who's with us today um people used our mono repo yet or you adapt developers um just get like a sample from the crowd of like who what what brings you guys to this Workshop raise your hand if you've already interacted with the ethereum JS motor repo okay so this is relatively new to most of you awesome awesome um and that's good it's um part of our focus is having these tools available in a language that devs know and are building in and you know as you're as you're learning more about ethereum and about how all this works uh hopefully our library can help you get there so yeah I've been with the team since the beginning of the year Gabriel's been here a little bit longer um and yeah yeah so we so I'm gonna go through that slide quickly just to give you a sense of the kinds of like packages that we have so we have an implementation in typescript I mean we're calling from JavaScript but technically right at the moment everything is typescript we've migrated to typescript about two years ago uh so we have a typescript implementation of the ethereum virtual machine uh we also provide you know building blocks like transaction block block blockchain we also had to have a bunch of like smaller scope-like utils like for example if you want a rlp uh like recursive line prefixing like encode things decode things uh we have a typescript implementation of uh Merkel pituitary as well which is you know the data structure that ethereum uses uh we have a Dev p2b package and an experimental client uh it has sync magnet there's been a guy who was was able to sync magnet up to the tip of the chain it's not really performant so I mean you wouldn't want to use it in production and we don't have like the mitigation that are in place for more like production ready clients but it is able to run all all blocks from mainnet so yeah I was just mentioning it's used by a bunch of tooling so all these are some of the you know packages that I'm sure you're familiar with like hard hat truffle metamask remix uh webster.js and a bunch of other you know projects uh use us as a dependency for to to build upon so yeah let us give you uh an overview of how the um ethereum uh JS packages kind of work together right so at the very bottom we have the client now the arrows pointing to the client mean that the client is importing you know the packages uh all these other you know packages so at the very bottom we have client which Imports basically everything that we've built in the model repo or as common is just going to be more uh like General things that you probably wouldn't use uh by themselves but are going to be helpful for uh like for example in common you would have like specifications for hard forks and stuff like that which if you wanna you know build a block you know you need to know like which hard Fork You're Building you know a block for same thing with a transaction same thing if you want to run a block in the evm and stuff like that so that all lives in common we've tried to modulize it in a way that's more that makes more sense and it makes it easy to to Import and Export things without them being all intertwined so yeah you might have heard like the term VM evm eei we also have you know a state manager so basically uh VM is like a higher level like virtual machines virtual machine which uh sends you know you would provide that like a block you would tell the VM hey I want you to run a block or I want you to run a transaction that it would forward uh an individual like message calls to the evm which would deal with like the op codes and all that sort of stuff then the evm would report back and communicate with a state manager that's going to update like whatever state you have uh in your Miracle particular tree so it's much easier to interact with the state manager because then you can just for example update an account balance rather than like finding the proper key in the Merkel particular tree updating that and recomputing the route which would be you know super tedious obviously so we've abstracted most of that away with the the state manager yeah I'll leave here discarding to talk about the portal Network which is another thing that we are working on right portal Network um it's actually a series of of networks that are peer-to-peer networks special storage networks and this is all in under construction and under design at the moment but we are implementing portal Network clients in typescript using ethereum JS libraries um there are two other teams working in rust and Nim at the same time to implement this so essentially if you if you want to interact with the blockchain right now you either need to run your own full node which is a very heavy process requiring a lot of your resources and most most people aren't going to do that and most devices aren't going to want to do that I have some most reach out to inferior which is a centralized access to the blockchain which works fine but it is a centralized access to blockchain which is kind of the thing we're trying to avoid so it people have been working for many years trying to figure out what goes up in that top left box where we can have something lightweight accessible but also decentralized and the work on Les light clients has eventually led us this concept called the portal portal Network um portal network is it's an in it's an independent peer-to-peer Network it's almost like a bittorrents it's working on that principle where um if you need access to some amount of information from the blockchain you don't need to actually sync to the entire blockchain to retrieve your you know your block history or your account history or many of the things that human driven wallet interactions um need so that's the idea we we're building networks to support the users of this protocol not necessarily building up the protocol itself the way a real full node does and therefore this can exist on very light resource constrained devices you could build it into the back end of a wallet app and it can just be running in the background of your phone or your watch or your anything and um potentially the more more devices hooked into these networks the better they will work and part of that is that you don't have to sync to the entire blockchain because that takes a long time and doesn't really make sense for a small app or a small device to want to do that takes a long time it's very heavy and doesn't really get you where you wanted to go so with the portal Network you could just Reach Out get the tip of the chain get your account balanced and all these things and be immediately immediately serve your purpose kind of explaining the same thing with interior everyone's reaching out to the same thing with the Les you get this kind of pile up where the more nodes involved in the system the more clunky it works and the harder it is too actually return anything but a distributed system every everybody's got a piece a little piece of responsibility of the network and they hold as much data as they're willing to as they serve much as they can or want to so for a practical example in a you know just a Json RPC call for each get balance right now if you're running a node you have to maintain all of these databases where you can look up the the canonical index you can look up storage you can look up State and return these things calculate them and then return the balance portal network is going to work exactly the same but instead of looking into your own databases your own huge piles of state and history you can reach out to these light networks you can to see if your balance receive the history receive state and send it and return it in the exact same way so for for the user using a Json RPC call it feels exactly the same but it is possible with very very limited resources and uh ours is called ultralight there's two other teams one's called Trin they're working in their rust and a client called fluffy that is working in nem um so the cool thing about ours is that we can we have a CLI client but we also have it working in a browser so we can open up a browser page too and we built like a stupid uh just a small block Explorer but you open up your browser page to this thing and the browser itself becomes a portal client using the same kind of uh same kind of memory and and storage as anything else and you know can both can both look up uh look up and serve yeah what else am I saying yeah essentially your your app can be a portal client if you if you were to bake this into bake it into your app it can basically just be running in the backgrounds you don't even really have to think about it but it's Distributing the data among a large large network of pockets and phones and laptops um essentially taking a lot of the load off of Full clients and and making a lot of this data available in a much more lightweight way uh we have been building the history Network for the last year or so and that is imminently operational and then the idea is that the other networks can just build upon that but they will be independent networks so as a portal client you can participate in one or all of them you can be there as a freeloader and not contribute anything and it really doesn't take much away from it if you think about you know BitTorrent most people are most people don't really go into their torrent apps and change a lot of configurations to be selfish about it most people just download the thing and use it as it comes essentially you don't even really have to know that it's happening but you are serving the entire network yourself so that's yeah that's a side project but it's very exciting and is definitely part of the future of how these things will work yes sir so it's a distributed distributed hash table both of content and user addresses so for the most part you're going to be randomly assigned and addressed in that in that sphere and you can sort of configure the radius of of data you're willing to be responsible for [Music] so you you would be up here on the network you know if you constrained yourself to only holding like a tiny bit of data then you're not going to be asked for it very often and there are certainly malicious ways to just you know put a bunch of nodes up that aren't doing anything but um I don't know the it just kind of means that we've built something worth attacking first of all and that there are solutions to those problems that can be worked out and just I think we're counting on the General laziness of users that are going to download a wallet app that somebody made and not necessarily configure it to be like weirdly malicious there's no incentives here it's all just it's all just there because it benefits users and by benefiting one user you benefit all users um so yes there are ways to attack it there are ways to be mean about it but I think for the most part as long as as long as enough users are just kind of passively participating then that's not as this isn't this isn't crucial to the protocol itself like portal that we're going down does not affect ethereum in any way so we can build this thing that's lightweight and hopefully just working on it's working on like natural natural law essentially nobody really has anything to gain by trying to shut it down and it doesn't really affect anything [Music] yeah you know problems that we're working out we're uh we're trying to steam ahead with like building the thing and then like uh solve all these problems along the way but yeah please uh our it's Ultra late team is just two people it's me and me and Andrew from our team so uh we're always looking for help or for whatever kind of contributions are out there cool other questions on that before we move back to more like the actual htmjs motor repo so we uh we have a concept of a bridge node which is something that is um is synced to the net and is or synced to the chain and is just feeding feeding into the portal Network if we have enough of those it just kind of saturates over time we also have kind of ideas of how to I don't know maybe like a babysitter node that kind of like circles the network and looks for gaps and and kind of helps helps fill in the gaps uh but yeah it's these kind of bridge nodes that originally saturate the network and maybe maintain that I put around with the field the boot nodes are a H we have devops just put up a bunch of nodes for us that that are acting like boot nodes there's no real difference between a bridge client and a just regular client it's more uh are you are you doing this extra work to like add to the add to the network or are you just helping to gossip around the network yeah all right so we'll we'll move ahead with a demo uh video m.js so as you know the next hard for hard Fork is going to be named Shanghai and there's a test net running at the moment it was down for a couple days but it got back up I think this morning or last night uh it's uh it's a test net that basically implements a subset of the uh of the eips that are going to be part of Shanghai so there might be additional ones the one on this list at the moment but that like tentative like list of VIPs that are going to be included at the moment is is the one you see on the screen so the beacon chain withdrawals and the the activate self-destruct aren't deployment implemented yet in our uh in our client but uh yeah the shandoned testnet is up and running we have it running with lodestar as a consensus uh client which is like the typescript you know consensus client and then we have it there with uh ethereum js's uh the execution client so that testnet is so it's live uh you can look it up there's a block explorer that I think we just put up this morning uh and as far as I know like the only execution client that's actually running that at the moment is ethereum JR so the JavaScript uh client so what I'll do is just uh I will not like run I will not access like the actual you know Live Test net but I'll run like the test net locally to give you a sense of how you would go about doing that and you might be interested in running that yourself when we go into the more like interactive part of the workshop so I just need to check out the proper pull request from our molar repo so it's just that here so yeah as we said our mono repo is broken into you know packages can you see the DS code yeah cool awesome so we'll just go to the package client and I have you know a couple of instructions I've I've done here so basically what we first want to do is we want to create you know data folders for about you know the execution layer data and that consists data yeah zoom in I'm not sure if I can zoom in notion actually but I can definitely zoom in vs codes at least that's going to be that is that better yeah cool no worries oh yeah yeah they're actually available on that pull request and in a couple slides there's a link tree with all of these outlines so you definitely can access all of these nodes and yeah it's it's a good exercise as well to uh you know run that yourself you will have time for that and we'll be happy to help everyone get that running so yeah the first thing we want to do is just create some data folders where the the state of the you know where the consensus client data and the execution client is going to live so we're gonna put that in the data yeah Shandong so we're going to create an ethereum folder and we're going to create a load star folder as well so now we're good to go for that part so the next step is we're already going to start our execution like assigned and it's going to use a Genesis that's been done by by one of the guys on our team usually likes Shandong at genesis.json you'll see that more clearly here here in packages what now you're in packages oh yeah yeah you're right thanks yeah and there we go hopefully that works live coding is always a bit uh sketchy and the Wi-Fi is pretty good actually if you haven't noticed there's a workshop specific Wi-Fi network that you can access because they're the global Wi-Fi isn't working that well so yeah we see that we have a Json RPC server started because we started you know our client with the RPC RPC engine in giant flag we have a Genesis that we've specified and the data directory is ethereum.js which we've just created so that's pretty uh fairly simple so by default when you run the ethereum JS client it's gonna consider that the merge hard Fork has been activated because we've specified you know a Genesis after that so at the moment it's just waiting for a consensus layer client connection without that it's going to be not going to be able to you know obviously execute blocks because it's not getting getting any so this is exactly what we're gonna do we're gonna start the load star uh consensus client so the the first thing we need to do is we're going to need to specify the Genesis hash to the um to the consensus uh layer client so to that to do that I'm actually going to bring up you know inferior and we're just going to query uh the hash of the uh I'm not going to bring up info actually I'm just going to query uh the local RPC that we we've seen specified here you see somewhere up here start Json RPC server localhost 8545 so I'm just going to do this is just a tooling to like visualize you know requests a bit better so let's see if I can recall how to do that by heart we'll see so we're just going to send a standard like Json RPC request to get the data of the you know the very first block in that you know exit execution client state so method then is going to be what is it it's eat get blocked by number and if you see me make a title be sure to point it out so that we don't break our execution live client by sending him like bad stuff and um so we're just going to specify you know the very first block we could specify earliest uh as well uh this second option is just if we want the transactions we'll we'll say yes but it doesn't really uh matter all that much then we need to specify an ID I think we'll just go with one can you see properly yeah cool big enough so let's see if that works cool yeah so we've got you know the first Genesis block we should expect like the parent hash is going to be zero uh this is post uh merge sort of mixed hash is zero it's uh it's unused and denounces one two three four not sure what that is but that is probably like a default value or something so we're just gonna take the hash and uh yeah we're just gonna copy and paste that so then the only other thing that we need is we need to specify like an initial like timestamp so I'm just gonna quickly get the timestamp like in seconds and we're gonna add like a few like seconds to that when we do that you know right after so I'm gonna start the consensus client here and this is a fairly you know long command it's running with Docker like I've already installed Little Star in my machine I didn't want to do that you know here but we can help you you know set that up later if that's what you want to do so all that we're going to need to specify is we're going to need to specify the Genesis eat one hash and we actually have that from here so we're pasting that and then we are going to specify a Genesis time which is going to be that and I'm going to add a number of seconds to it so let's see if this works so we should eventually start you know producing uh blocks oh we see publishblock that looks pretty good and then if we go back to the execution layer client it should have picked up on you know the consensus client starting to run producing blocks sending them back to it so let's see if we yeah it's uh assembling blocks build block that looks perfect so we we are seeing that uh we have a local shangdong blockchain running with a bunch of newer eips now one thing we can do we have a test Suite I think for like it's so we have a bunch of tests here that we can run to see if the you know eips have been properly implemented so I won't go through all of them feel free to go through them yourself so EIP like 3670 is a like the eof uh code execution the code validation so if you try to publish like a contract code that doesn't conform to the eof standard it will get uh you know rejected we have a bunch of related tests so we have uh can't exactly recall what this one is actually a bad there that label here just fix that and yeah so we can try and see if we can run the test I think it's in the SIM all right so it should oh I have to specify actual run through yeah right so this is going to interact with the chain that we have running locally and check if uh everything seems good so we've been able to make a transfer that's already you know not so bad and then it's going to test eof and a couple of other you know eips this is a bit slow maybe because I'm sharing the stream I'm not sure but yeah we see that test uh running and yeah I'll keep that running while I keep it up and go back to the presentation slideshow it's all right all right so this is a where we're going to start like the more interactive and I feel like interesting part of this Workshop where I mean we encourage you like to bring actually your laptop style and if you have if you don't have a laptop or you don't feel like you know coding yourself I would really encourage you like to to meet up with someone or to pair with someone who actually has a a laptop going because I feel like that's probably going to be the best way that you can we can show you about the mono repo and if people have like different degrees of uh of skill levels or familiarity with like blockchain in general we have a couple of like suggestions as to what we suggest you to do so if you're and that QR code is uh the link tree I was mentioning earlier so it has links to all all of these things along with the like Shandong test net instructions I also I want to mention the structure of our mono repo you can clone the whole mono repo and it'll come with what is it 12 packages however all of the relevant packages will come in the mono repo if you clone that from GitHub but each individual package is also installable on its own um so you can you can install just the transaction package or just the block package and you don't need to have the whole mono repo as a dependency you can have each individual each JS package yeah yeah because I would encourage you today to maybe clone the whole model repo so you can see everything and and get a sense of how they all connect to each other yeah yeah clothing the model repo is probably the way to go if you want to experiment a bit especially since some of these packages are and they're dependent on you know each other but if you were for example building a set of tooling and you only need to build blocks from data or build transactions from some piece of data that you have you could only import like app ethereum uh Block in that ethereum transaction and that would be you know all that you need you don't need to you know import the whole model repo it's just package based so yeah what we have like sort of prepared for you in terms of uh like paths if you're more like uh I would say beginner but like if you're more novice or if you've never really learned about you know Merkel Patricia trees uh a good way like to explore that is with a tutorial that uh have been written like two years ago and has been like uh updated recently and it basically goes through it uses our tree package to teach you about the very fundamentals of that data structure so it just starts with you know uh putting a value inside the miracle but you should try database getting the value uh Computing a hash looking how you can you know make proofs from these hashes eventually all the way up to uh you know querying data on the blockchain and uh and interacting with it more dynamically in a way that's more similar to what you'd expect in the real world context so I'm super happy to help you as well answer any questions on trees it's the package I've worked the most on uh in the more I guess intermediate track although I mean Merkel pursuites are certainly like not super easy so we could have put that in their intermediate track as well uh you can experiment with like rlp encoding or decoding so this is the serializing uh algorithm currently used by ethereum and we cover a bit of that in the Patricia trees tutorial but if you want to experiment with like oh what does a an area containing a dog and cat strings look like when you are all pin code them that's the package you would go for it contains two methods rlp.encode rlp.d code super simple and you have a bunch of helpers like to convert hex to Strings and stuff like that another I feel like exciting thing that you could use are packages for is uh the block and the transaction packages one of the things you could do for example is query uh you know just like we've done here we've query the block so a good exercise would be to recompute the hash of that block from that data we have helpers that can do it for you uh like super easily where you basically just paste that Json object and it's going to recompute like the hash or a block object for which you can get the hash but it's also it can also be interesting to just take those fields like manually and try to recompute the hash yourself and we have all the helper methods you would you would need to to do that and if that feels a bit a bit hard you can look at how we actually Implement our helper methods and you know try that out go back to the but yeah but yeah all right in the more uh Advanced I guess track one of the things you could do is invent and Implement your own EIP that might look like super hard but we have an example here of a super like minimalistic EIP and I'm actually gonna show that to you just so that you see how small like uh potential EIP can be so I think it's 18 for yeah right so it's adding like 92 bytes of code removing two pretty simple it's in the IP that goes into Shanghai just warms the coinbase address so if you take this as a as an example your I think you're easily going to be able to you know reproduce at least the scaffolding for an EIP and you can like invent this perhaps not so useful but like easy one where it just modifies the way maybe a block is rounded maybe modifies the the name of field or something like that and uh yeah that I think that PR can serve as a guideline for how to do that and yeah most of the implementation is actually like it's basically just that line here in addition to like the scaffolding and a bunch of tests that are let's just confirmed that the EIP has been implemented properly in terms of other things that you could do you can run the local client as we you've seen us do and you can run the Shandong test net with lowestar as the consensus client so yeah now it's of to the races as return always says so any uh does everyone raise your hand if you don't have a laptop well I have one so I won't raise my hand so everyone has one awesome so was everyone able to scan that uh link tree thing all right cool if not the link is just linked linktr.ee slash ethereum.js let me just bring it up all right so do I'm wondering how to best like structure this so either I can go through one of those myself for those who want a more uh follow along but I think what would be helpful is maybe if we just help everyone you know set up a local environment and if at some point you want to follow with what I'm doing you can do it or if you want to work on your own thing you can do that as well does that sound good to everybody yeah all right cool [Music] all right I'm just gonna walk around might not be best for the live stream not that interesting to to watch an empty stage but uh I will be walking around and just raise your hand if you have a an issue of setting up your local environment just clone the model repo it's linked at uh so if you click on internment yet it's going to bring you to uh the monorepo itself all right all right and once you've cloned the model repo the way to install it we use npm so just npm install is anyone running on the windows very happy to hear that yeah there's the door here for Windows users so he's I assume people are on uh Mac OS or Linux or yeah yeah okay the the workshop Wi-Fi's password is uh build it 22. uh lower caps build it and 22 the the number so just npm install from the mono repo itself make sure to run npm install in the you know mono repo instead of in packages themselves so that's going to build the whole thing which is what we want is everyone good raise your hand if you need additional help okay so I think you just entered so yeah just uh you can clone the ethereum JS motor repo uh the second link intermediate Link in the uh in the link tree that you see here and then uh yeah just uh make sure you're on the you're on the master branch that should be default and then uh yeah just pull the latest and npm I've to install the model repo that should be all that you need so just just so I that I do something that's relevant for most people who's thinking of doing the uh Merkel Patricia trees tutorial awesome okay cool I wouldn't quite recommend it it does cover some of the stuff that were uh we would be doing in Block transactions in the rlp but it just guides you through them rather than just showing you out there uh who's thinking of just going straight intermediate and building blocks transactions all right and who's thinking of trying to implement their own EIP is anyone motivated all right awesome and uh what about running the client or running the Shandong test net okay yeah so I'll just be going through the tutorial as well in front since everyone is going to be doing that and it's going to be more interesting for people who watch the recording rather than just looking at the link tree for one hour yeah so this is the folder that you should go in if you want to do that tutorial and the readme is is you know the tutorial itself what we also have is a set of examples like I had uh written this tutorial in JavaScript just so that people who know wanted to learn about ethereum didn't know about typescript didn't really have to you know learn about it so those are like GS files that you can just run with a node let me check out yeah package is named uh try so once you've uh let me actually just reinstall since the Shandong thing is a bit uh a bit different yeah was everyone able to install successfully cool no issues huh you're waiting for the installation all right cool yeah it takes a while because it's building every package so uh yeah uh are you trying to run uh from the monorepo itself npmram test uh yeah it might be just because there's some modules indeed like a lot of the uh a lot of the general tests we have depend on that those sub modules foreign yeah they're pretty big they're pretty big I can't say for sure like depending on the bandwidth how long it's going to take my own machine at home it doesn't take that long but uh if you can just leave it running and see if oh oh that's singular test okay uh let me give you an example of running a an individual test I'll just go okay the the the principle is going to be the same for all of the packages themselves so if you go within the individual package that you're trying to run the test in just do npm run tape and tape is like the testing you know framework that we use then you do uh double I think those are called Dash in English I'm not even sure uh then test to look at the test folder and then you just select the file basically that you uh that you want to run right so if I wanted to run for example the I don't know the the proof that spec test I would just do that and it's going to run that test individually if you do npm run tests it's just gonna run like a massive Suite of um of tests including like integration tests that depend on browser integration stuff like that and that's typically like super long we only do that like in the CI once in a while but locally it's a bit tedious so and yeah then you see the the result of the test it passes so let me close that up all right so let me open up the tutorial again all right so there's you know a bit of preliminary info that you might want to read um uh you know data structure of ethereum is called a miracle pituitary it's a basically a combination of a myrtle tree and a picture should try a try is a data structure in which Keys represent the path leading to a specific node and the mergle tree is a structure in which a parent node the key of that is the hash of the all the child nodes uh Miracle 3 is interesting because if you want to prove that the certain value is part of the data at the large Market restructure that you have you can do so by providing a bunch of like sister nodes we'll see uh that super clearly in the tutorial itself so yeah the instructions are here they're the same that you've just ran so clone the model repo um install it and then go inside of that try package so I'll Bing going through these like fairly you know slowly so feel free if you're you know want to go a bit faster to just go forward and don't let me like slow you down but the so the first example we're going to use the try you know library before is uh creating and updating uh a base Drive so what does that look like so first of all we're importing the try uh class from the the try package and we can look at what you know that looks like it's probably like try file yeah so try is simply a class and uh you know it has a bunch of properties that you would expect uh on the you know database like structure it does use like uh checkpoint DB is a as like a database and then you can provide options for the tree so some of the options are uh do you want to use this specific type of keys you want to use like plank keys or hashed Keys like are what is used in ethereum then we instantiate database you could provide like your own database here where you're instantiating a new like map DB and um yeah instantiating a new tree when we you know construct a tree with the tree class and you can see you have a set of methods here you can for example you know get the root of the tree you can verify if a certain route exists you can get those are like these two methods or the ones we're going to be using the most so we have a get method to retrieve a value by providing a key and then we have a put a put method which stores a given value at a specific key so fairly standard you know database stuff but this is going to give us insight into how you know the that actual data structure works because it's not like a simple database so let me go back to the tutorial so the first thing we're gonna do is like instantiate uh the tree so I'll go to I think it's example one a yeah I'm just gonna comment that out so yeah to run a specific example you're just gonna go uh node examples and for example example one am I doing yes typo oh it's within Merkel trees and then example one a there we go so this all I'm going to be doing here as you can see is instantiating a new tree uh with you know the the try package from the model repo and then logging the root of that tree and this is going to give us the the root of the tree which is uh you can look up in the Docks but it's basically that uh the the the encoding of uh I think an empty array um rlp encoding of an empty array so yeah we see like pretty fast we see we output a buffer which is a uh which is that now that doesn't tell us a whole lot but we could look up in the docs and see that this is actually exactly what we'd expect in uh as the root of Genesis like root of a of a try like data data structure so then we're going to move on to a more you know a more interesting test I'd say we're gonna we're gonna try to just put a value in it and see if we can actually retrieve it another thing we're also gonna be able to see is uh how the the route you know has been updated given that so yeah what do we do here we're creating a key I mean a try natively uses buffers so we're doing like buffer from for for all of these so we're having test key that's going to be your key and we have test value this is going to be our value and then we're doing an asynchronous operation like putting that key value pair inside of the try and then we're going to try to retrieve that value fairly simple what we should expect here is a uh so what should be the value well it should be the you know the encoded version uh the buffer from version of uh test value and the value string we should expect to see value and if we don't there's there's been an issue either you know in the library or in the way we've used it it should also update the tree root so one thing I'm gonna do is I'm gonna also log the try route before and what we should expect is uh like each Merkel Patricia Street like each state tree should always have a different uh hash if it differs and if it's the same it should always uh have the the same so let's try running this again so what do we have here we start out with a empty try route yeah we had logged that before actually so the try route before you know is the same we just logged the same thing twice the value that we've retrieved is it's this if you are familiar with the you know this just uh the hex correspondence for all of the all of the characters and then if we uh convert that to a string we get back to this value this is exactly what we expect then we see that the try route has you know massively changed as you would expect from uh any kind of hashing if it differs slightly totally different random result all right that clear to everybody does that feel intuitive okay yeah any questions I know we're always at so a normal tree so this is the actual Myrtle Beach history like data structure that we'd be uh that would be used like in production with ethereum the the only slight difference is that uh Merkel Patricia trees use like hash keys so instead of using the key we'd use like the the hashed version of that key and this is only to balance out the tree so that there's no Vector of attack where you always update like values in a similar region and make it more costly for those to run operations uh the so what I think your question is is you know there are there's a if you had a normal little structure like this you would always like Traverse every single loan would only give you one hex right because it's a 16 like width tree so if you have a key of like uh you know 32 bytes then you would Traverse like all these nodes on the way down there now Merkel Patricia trees are more efficient than that because if if they know that given a certain path there's only one possible path down they're gonna create what's called uh an extension node which extends all the way down to the to the leaf so this allows you to shortcut unnecessary paths what you'd see if you didn't have that is there would be a bunch of layers in there Merkel pituitary where there's only like one specific branch that has a value and then you go down and there's only one specific Branch so for like sparse trees meaning like trees that aren't filled like with data all over this is incredibly more you know efficient because you don't have to store like all these unnecessary nodes and just collapse collapse those back up into into one leaf instead of tree with only one leaf yeah absolutely so yeah I'll go ahead and check what example two is about yeah there's a couple of additional like notes Here that you might be interested in some of them I mentioned while while doing it it's also talking a bit about the rlp you know encoding uh function this is a actually not up to date that link I think it's probably here yeah yeah so there's some very nice ducks in uh on ethereum.org for developers like if you're looking to learn a bit more about rlp you would just go there they have a bunch of examples and you couldn't even like use our library to test it out and play around with it uh so before values or so there's a bunch of values you could want to store in the miracle Patricia tree right and those need to be serialized before they are you know put inside of the tree uh this serialization is done with the recursive lamp prefix encoding function uh and and yeah as I mentioned uh Keys also go in additional additional transformation uh they're not used like raw uh they're used uh we we first take the keca 256 of the key before we we update the tree so here we're basically going to do the same thing but we are going to use the hashed version of the key so how we're going to do that is we're just gonna you know import the kick to 56 that we have in you know ethereum jazz slash util package and the only difference is we are going to uh as you see here put the value at the Keck of the key instead of the key itself so everything else is going to be uh you know exactly the same so let's see yeah similarly we're gonna get you know an updated tree root so that until nothing surprising here uh it's basically just you know we we had an alternative key which is the key we got the same value back no difference there any question on that performance industry okay so the the values themselves are enhatched because otherwise we wouldn't be able to retrieve them since you know hashing is one way the only thing that we hash is I mean this is like a key value you know data structure the value we keep you know native we just rlp encoded for you know serialization so that it's compatible but the the key itself that we're hashing we could very well well have a miracle but surgery like data structure without hash keys and however at the you know early days of ethereum it was chosen that the keys are gonna were gonna be hashed uh the main reason why that was done is so that it uh evens out uh the tree uh naturally so it mitigated like vectors of attack where you could have people like constantly update like a a part of the tree like very easily and now if you wanted to do that you'd have to like pre-compute a hash and since it's like non-deterministic well it's deterministic but you can like predict an event what the hash is going to be obviously you basically have to do like proof of work to like uh this target like a specific part of the tree it imposes some Randomness on the the actual address and so if you have keys that are related they won't cluster in a part of the tree they'll be dispersed evenly and your key can be a short string and it ends up 32 bytes yep yeah so in our case like keys are always like how this is like in the case of the the state tree Keys would be like the the account addresses but uh yeah the like hashing something obviously also has benefits of making everything equal length which you want in like data structures like this all right so as we said like fairly fairly straightforward now we're going to do something you know a little bit more interesting now what we've seen is that the the like we've used the kecac 256 of the key but there's a you know there's a property of the tree that we can just use in order to do that natively that property is called use key hashing it's a Boolean that defaults to false but as you can set to true if you want when playing around with a tree is just more convenient to set it to false or have it you know default to false just because you you don't have like to to all do all that additional computation it's also easier if you want to debug what a value uh you know if you if you only have the the hash of the key you can never know like what was the actual key that I used to update this you cannot retrieve it back which uh is actually an issue that has also come up when making the transition from Myrtle trees to Vertical trees but that's a different uh that's a different topic so let's see what example 1C is about so I think it's basically the same thing but just using the use key hashing so what we should expect unless our yusuke hashing Boolean is implemented improperly is we should expect exactly the the same values that we have here including the updated tree root given that we're using the same yeah testing this valued that should work so let's see and yeah as expected we've created a new tree but we've updated it with the same key value pair and we are getting the same updated try route okay now we're going to do a a different operation so among the operations that are possible you can retrieve a value you can update the tree by adding new values you can also delete values from the tree so let's see what this looks like the as I as I kind of mentioned before every tree that is similar that has all the same data should you know compute the same route that's how we get you know the security properties of these uh of these trees so what we're going to do is we're going to update the tree it's going to update the route and then we'll we're going to delete that same key and it should give us back the exact same route that we started with let's look at the code all right yeah create it update it then delete using the weight deal helper method get it again we we shouldn't be getting uh a value when we try to you know retrieve at that key I'm not exactly sure what we're going to get I'm not sure if it throws or oh it looks like yeah it's going to be null fair enough and uh let's see about that all right so we are starting out with the M3 empty try route here it starts with 56 E8 then we are updating uh the tree we're getting an updated tree root which is uh similar to the like unhashed key one we had before and then we are delaying that value again and what do we get back when we query that that tree for that key we uh we get back now which means like empty no it's not there and the tree route that we get back after the deletion is the same that we start with so yeah I kind of demonstrates that every you know same tree is going to have the same root yeah so now we're gonna take a bit of a deeper look at the actual you know data structure of uh the Myrtle producer tree so it has you want to go for this all right you want me to take over yeah I feel like I've been talking about it no you're you're a good communicator you should do it all right all right so there are four kinds of notes in uh Myrtle Beach trees so there's the null node which is the one we just queried accidentally by you know deleting the tree that's a non-existent note you get back now when you query for something that doesn't exist there is a branch note what a branch node does is it's basically an intermediary node that points to a bunch of child nodes there is then the leaf node which is you know this is called the tree the leaves are the very end these are the nodes that contain like the you know the final values and then there are extension nodes extension nodes are the shortcut uh I was kind of hinting to so if if you have a key for example I mean we're going to see examples actually so it might be easier any question before we dive into looking we're going to look at all these four different kinds of nodes individually yep yep yeah how how is that initial route created yeah good question I'm I think it's the rlp encoding like it has basically still uh you know it's it's the hash of the value at that root because it's initialized with a value if it wasn't initialized with a value would just be null you know initially uh the way they're defined I'm sorry are you asking about the extension node like how how that route comes to be the very first yeah yeah yeah so how how would we able to calculate ourselves like manually the hash of the the root node and the empty root of an empty tree yeah so so yeah we can actually look at that directly in the code uh we have uh we set empty try route that's like a specific like constant property when so when we construct uh when we initialize a new tree what runs is like this Constructor function if we don't provide options and we we have like default options that we provide we instantiate the database and then the very next thing we do is initialize the empty try root which is exactly the thing you know you're asking about uh this is actually quite simple so what it is is uh the rlp encoding of an empty string which uh yeah Constance okay so it's buffer Ox 80 and that's that's like it I guess sort of a universal for empty tree yeah all right so we empty rlp well it there's actually the idea a desirable property yeah that all you can know if and you could identify all empty trees from exactly that right like the same tree should always have the same route same with an empty tree every empty tree will have the same route yeah and if we let me take that example file actually and just compute that you have so we're gonna need what we're gonna need something from rlp let me do it in the rlp package actually yeah I'm having a bit of trouble navigating with my screens so zoomed in feel free to throw out questions or call me over if you want to chat individually all right so this is importing the encode method from the rlp library so what do we should expect to get back uh from you know an empty string rlp encoding would be Ox 80 which is you know the buffer we we just saw before so I'm gonna have to move out of that repo going to the example solder and then run this am I not in the right or it's test okay so why is it not a logging always interesting when you do live coding so figure out how to cancel log something thank you very much yeah I switched package there before the can just actually import they all just import it directly from there this oh it's actually in bin for that folder all right let's see if we can get something going now let me just rename that to address file actually right it is not working at all all right okay we're finally yeah I'm getting about something and we're getting back uh 128. is that ox80 in HEX let me actually end in 20 minutes oh yeah it's gonna be hard to import packages in a JS file like that foreign okay yeah so 128 we we got back the decimal value but 128 is like ox 80 in decimals which is the the value that we're using inside of the tree to compute the root hash so we are basically just to to compute that you know root hash we are just hashing ox80 so if we take the kecought hash of the let me look back at a place where we were using KitKat so I don't have to re-import manually so if we're doing the kecought 256 of a buffer from like ox80 we should expect to get back to the exact same like empty hash that serves as uh the root of an empty Miracle pituitary so let's see if we can reproduce that ourself we'll just comment out the rest to remove some noise navigate back to the tree package maybe I have to that as this string all right so we're getting back a uint array I just need to convert that to hex then we should be getting back to the same route that we initially started with so we have a buffer to hex util in the package now the way my testing thing is set up might not allow me to import that yeah yeah so I would need to do buffer to hex here uh well since I'm now running on a like JS thing I would need to build it before I'm able to run this so I will not do this here but those are we can trust that you know the values that are output here if you were to convert every one of them in you know in HEX would be the exact values of the the root of d of the miracle pursuitry that we had in uh the example d like get 68 nothing here is that a satisfactory answer to your question are you yeah yeah [Music] cool any other questions before we move on to going to all uh specific kinds of notes we're good all right cool everybody's following along all right nice so yeah we're just going to start with creating and looking up uh null node so how do we we're not actually really going to create a null node we're just going to query for a key that is not present in the Merkel particular tree so it's basically the simplest like test case you could imagine so what we're going to run is to to a right let's look just at the that's here yes we're instantiating a new tree we are trying to find a path you know to the uh to the key test key and we'll see what kind of node we'll get back now what you will see now is that we're using findpath which is going to provide us with the actual node and then all the object instead of just providing us with the value so if you want to query the the three four actual values just do get but if you want to get more information as to you know what the path is and what the node looks like you would just do a fine path so we're running example eight this provides us with uh yeah a null node as we would uh expect we could change that to uh pretty much you know anything and uh we would get back now as well no difference now one thing I'm going to try actually is if I query buffer from that I'm not sure if that's going to be a null node as well yeah okay that's another note interesting oh yeah the thing we were using before yeah I think it's still null it's since it it's like defined as you know the initial hash is defined as that but there's no actual node that's present uh and that key from what I can recall of the specs so so there yeah yeah it's basically a way to bootstrap the tree so that it starts you know with something uh you could Define like a new Mercury patriotary data structure that uses like something different obviously from rlp encoding and also has a different like root hash you don't necessarily have to use it it's useful in the context of ethereum because we obviously want to be consistent throughout like implementations but it's not it's not a necessary part of the data structure like that you could Define It Anyway any way you want so yeah the null node is a bit you know boring it's not as interesting and the ones that are to come uh it's also like slightly more complicated to to create because if you think about how you know these kind of keys work right you have a key and to retrieve the value for it you just go down each note is a hex value right so let's say the next part of the key is like seven you go branch number seven and then if it's uh you know four like in this example you take branch number four and you go all the way down now since like murder trees are like optimized with extension nodes uh you wouldn't get a branch every part of the way down what you would see is you would start at seven let's say you only had like one of the keys it would start at seven it would give you straight it would go you straight to the end because there's only one value that starts with seven so it would like kind of compress the tree for you uh so if we want to create a branch node that's like acts as an intermediary node you would wanna you know we want to store keys that are all basically in the same spot and then Branch out at some point and that's actually interesting because it's super easy to do that you know with what we're going to do in this example but if we were using a hash tree then it's basically you know impossible to do that do that voluntarily and that gives you a sense of why that was chosen in the first place right why we're choosing uh to Hash keys in the context like a production you know database in ethereum to prevent like dos style attacks with uh you know just putting keys are always in the same spot all right so let's look at that actual example example 2B foreign yeah I'm not saving any of that is what it is that like native format that this tree accepts like you could do it like we could have an implementation that just basically allows you to input anything but it would still be converted into something that's natively adjustable by the tree so the tree is defined as a like hexary hexiratory meaning that every key must be like hexadecimal for it to be like conformed to the data structure if we didn't have small values we'd have to convert it anyways so that I mean so that it maps to like a 16 uh 16 width key so yeah yeah absolutely yeah so and also like rlp encoding encodes things in Exodus mode so we're all like working with Native like hexadecimals here it was in that tree uh so yeah if we like unlike like hashes uh buffer is going to be it's just like the the hexary like encoding of the these keys so we should expect these uh all these values do still be quite similar and that is what we see here so right we have the prefect test Keys come in for all of them and test key is basically that part you know of the uh let me zoom in a little bit yeah that part of the of the buffer now we have 30 which is a 0 and 41 which is capital A which are you know the the last parts of it so what we should basically expect right is uh would you agree that we should expect like a branch node at 79 at which point you know it branches out so what we would see is like there's going to be a value at 79 a branch that you know can have a value but then there's going to be two bats there's going to be path number three and path number four like in indexes of the array then it's going to go down all the way to you know a leaf node because it's basically the end of the path for that part of the path and then 41 which is going to be the another part for that you know other path does that make sense to everybody Aviation yeah yeah that's uh that's really the idea of the the Patricia tree is that you're following the sort of following the keys along that path and everything that shares shares bites [Music] yeah yeah and something like to mention here this is only keys right this is not the values themselves and like later a bit in the tutorial we see how you know the hashes of every like parent is computed which is like different you know from this but uh yeah so if we had like uh also a a key address T we would see like that that would be only 74 because that like lowercase T is 74 uh in HEX and uh we would see a branch note at 74. there would be value already there and then there would be like nodes uh like paths to uh all the way down to you know 79 it would be like we'll see that after but it would be like an extension node for optimization purposes and then you have well branches as we've said to 30 and and 41. so yeah what we're going to do is update the tree with all those keys we're going to find the path to test key and we're going to see what that no you know actually uh looks like all right so that's actually a pretty nice like visualization I think of what uh of what's going on so we have you know for the three buffers then we're updating with all those three keys so we're updating the tree with desk key test key zero test key a which all have the same prefix we query the the node that lives at Key test key which is the the common prefix for all those so what we see so this is index you know zero one two three four which correspond to numerical values like just plus one since indexes start at zero and uh actually no that's not true just correspond exactly to the actual values and uh and we're seeing that there are two uh different you know values here so that is what we'd expect we have like this is basically like empty so like null nodes because there's no path uh at that point like uh at Key zero there's no we don't have any anything uh that lives at zero right we don't have anything that lives at one so we have nothing that leaves it two but starting from tree we have an actual path and we see that complete path here we also have the same for 41 which is you know index 4. and then we have nothing all the way down an interesting thing is we also have a value already here at address you know that's basically test key and hex so a branch node is not only an intermediary node it can also contain values you know itself in the case of keys which would always have the same length you might not see like values at certain intermediary node because they all leave them Leaf nodes but you can still use that data structure for other purposes where you know the length of keys wouldn't always be the same all right yeah so that's exactly exactly uh what we see and we can uh we can take the value of that node and see if we can like the value here we can yeah we can parse it to string let me find you the code so it's more revelatory of what's actually going on so yeah we we found a path we found a node we take that node we look at the value at that specific point and it should be the the value that we've put at test key now if we were to take a uh the value of a of one of the nodes that is a child of that parent node we would get also like test test value zero and test value a so it is what we're doing you know a bit further down here so let's look at how we're you know retrieving that we are taking you know the third branch and the the second element that's just the that's the value of the the of that leaf end node converting it to a string and then we get we retrieve the value back is that somewhat clear breast nodes are a bit trickier but is uh is everyone sort of following along yeah yeah yeah so let me think we're there's a bit more clarity about that after so I think the next example is going to clarify that for you and if it doesn't we can come back to it and play a little bit more with it it is like getting like nodes in how they're structured and how they they operate within one another is that trickier part but uh yeah Branch nodes and extension nodes which are you know somewhat similar in structure or the more configured part of that so once you get that and it kind of clicks the way they work together you're pretty much you know done understanding that that data structure so it's definitely something that's worth you know coming back to and making sure that we understand somebody yeah if you see that array of 16 buffers and two of them have have keys in them every every parent as soon as that branches out has automatically 16 children regardless of how many values are actually there and like where they go if there's only one then we can compress it down and call it an extension node but here where there's like two in that array you just automatically have the rest rest of its siblings are empty buffers um and like I said if there's only one child to that parent we can collapse it back up if there's at least two then you're going to have an array of 16. um regardless of how many actually have actually have a leaf yep yeah absolutely so this uh clarifies this is a bit like in in the other example but I think this clarifies uh you know what's going on so it might look a bit confusing because we're using very similar keys and values so this is actually the values and they're also you know similar but we're not really concerned with this similarity you know of the values we're concerned with we went all the way down to a branch node we had two paths that were defined and we had also a value that lived there so your question is basically well why is it an array that lives there right so the area contains the two pieces of information that we need to finally like get the value at the leaf node so this is pointing you know to an old and it's telling you well actually the the remaining part of the path is going to be 3 0. and then the remaining part of the path is going to be you know tree one and then the value you're going to retrieve at that you know and end point is going to be you know that whole thing and this is the thing that if you parse it to a string you would get like test value zero and test value a and it's the reason why when we're um trying to retrieve you know the values here we are you know taking the corresponding indexes but uh then taking the first uh not the first like the second but index number one this this is exactly that's the value now we're working with like fairly small values so the values are directly inside of the tree if you had very large values it would Point like back to another uh node that would have an encoding of the of the value that will actually yeah well at that point it would be like the end node so it would only be a leaf so all the leaf contains is the the the last remaining part of the path that was that led there and then the full value and then yeah that'll be the root of yeah yeah let's do that actually so we can we're gonna create uh so what would you suggest this key one yeah let's do that it's going to be test value you know I want as well and actually let me put like some fairly like different values so that we're not confused by the similarity of the values themselves I think that the values themselves don't determine where it is in the tree yeah so we're gonna run that again and we're gonna all that we're interested in at the moment for you know this example you've suggested is that the branch note like what does it look like at that point and then it's going to have a child that's also going to be a branched out right that's what we would you know expect so let's try I need to save it first let's try running that all right so what we see is it's actually quite similar to what it was before but instead of getting an array we're getting a larger larger buffer so what is that larger browser that larger buffer is uh now there's two kinds of keys in Myrtle Beach trees that's just a hash that points to a different node right so it's not about you know path path is still like path you know number three but to know like what's the hash of that other node that we're trying to retrieve this is going to be that so that's just a hash of the the the of the the child node that is going to be the one that contains you know zero uh what was it like zero and zero zero one right so now yeah yeah so let's see how we can go about what I'll do next is look at the path at test key zero right and we're going to look at what you know that actual node looks like I can also remove that all right so what do we have here what are my logging okay so if we look at those keys you have a common path that is test key zero and then you have a slightly like longer path that is that's q1 so what we should expect again is a branch node at that point it's going to contain the value itself because test key zero is actually defined you know as a valid key that contains a value but it's also going to continue at one and now obviously we're dealing with like text conversions of this so it's not going to be at the actual index one it's going to be at a different index but where we do see that there's uh exactly one valid you know branch that points to uh another node and then there's an actual value here and if we were to uh you know convert that actual value to a string we would expect to get back uh whatever like gar badge I I typed in there and this is actually exactly what we retrieve here and if we look at this this branch we're going to try to retrieve that you know number three thing here I can just do it so what's the index of this it looks like okay index tree I have to do actually branches true and then this would be the remaining part of the path and this is going to be the value so if we do the string we should expect to retrieve that uh number three you know thing that we had above let's see if that works and yeah we're getting back you know number three uh well I kind of messed this up I should have come into this help s not necessarily this is just because of the uh the actual uh ewts so it put very well like if I choose let's say I do two here let me go back and just logging I don't expect can you can you repeat that being displayed and you have referring to the branches in the terminal right like we have buffer placeholders and the value of the key is being shown as 0 1 2 3 on the third element is that right yeah so in that scenario the total number of uh buffer placeholders are fifteen one five is that right uh yeah it's actually uh 16. we have 16 uh elements in the array I believe it then the end index is 15 but it starts at zero so we have 16. [Music] the next bite got it thank you can we oh yeah it works okay I know what that is so zero is actually like it's encoded as like two hexary you know number is only like not a like a single one so we're seeing tree because that's the like second number of the zero at which point uh you know we have a value like directly there but we have we're branching out so I think if I created like another one might be a bit tricky to actually create all the cases that we'd want we might end up with the same sort of issue yeah so here we're getting again uh like you remember how we were getting like a path in the value that was because that was the only valued F now we're again getting a hash pointing to the common path of like the next one it's going to be a branch note again we could you know again query uh find the path to that in this case there's no value at that node that's just pointing to child nodes yeah well there's a value like if I query test key O2 there's going to be again a value here but uh yeah I'm not actually sure why we're always at this index I'd have to look at the the way this is in code I suspect it's like the always the the latter part of the number two is what's used here instead of tree itself um now I can recall exactly why that is but uh yeah we in the normal like setting with like keys and stuff we wouldn't expect like every basically level due to to Branch out and and the fact that it's tree at the moment is just a peculiarity of the test case I've come up with yep and lowercase uppercase yeah yeah it's not lining up perfectly too yeah exactly so if we wanted to do like if we could natively like compute you know buffers and hexes then it would be much easier to see what's going on now we're using like human readable keys so I mean they're broken down to that they're you know they're coming to hex so at each uh each part of the way down that we go it doesn't line up exactly with the end of the key there's often like one next like character necessary to to finalize that the number zero for example um all right so I'll go over with three minutes so I I think maybe open up to just like general questions or um comments or anything um you know we're we're building this for you guys so if there are things that are not working or confusing or that you'd like to see where we're very open to feedback and suggestions and help yeah so like most of what we've done so far has been like working on you know just Miracle Patricia trees uh themselves uh a bit further down in that tutorial like I encourage you to just keep going at home and ping me like on Discord or telegram or Twitter if anything like doesn't work as you'd expect uh but there are like we're working also like with blocks and with transactions and rlp encoding uh which is quite I feel like it's how I learned about ethereum initially like through learning about these data structures and the first draft of that tutorial was actually like me learning you know about this stuff and figuring out what's going on and um and yeah um and yeah we're we're an open source project you can find us on GitHub you can find us on Discord and chime in or ask questions yeah we have a massive number of uh external contributors who've helped you know over the years the repo is uh fairly old I think it's like six years old or perhaps like even more than that sometimes I'll work on a part of the code and I'm seeing like the get blame like five five years ago or something like that so it's really like a pretty old repo we we are extremely open to external contributors like sometimes we'll have people come up and just help out and then we we you know we include them in the the team like not in the formal like team itself but we do like chat with them and are always happy to help people you know help the project we're working on uh our future projects are we're trying to improve the client thinking at the moment we only have full sync it's super slow and you know you know that would never use that you know in production obviously uh uh we're trying to do you know General like optimizations as well so if anyone like is competent that we're really happy to like uh get you started on that or improving like the Json RPC endpoints we don't yet serve all the RPC calls so that's uh it's an excellent place to start if you want to help out just implements a new RPC endpoint for us exactly you can just go through the list of what we've implemented and just you know uh come up you know with easy ones that you want to implement and it's a good way to get started learning about our repo uh my side I'm working more on R D for vehicle freeze and statelessness which is you know sort of related to the Merkle tree stuff we've been exploring uh Scotty works on ultralight amongst other things and yeah we're just improving the gold base as well making it a nicer with nicer types and a better performance and the last questions that's a good point yeah I didn't think of adding that to the link tree how will uh that link tree linked above all update it with the link to our Discord so that then you can come in it's the ethereum JS Discord probably fairly easy to find as well but I'll link it nevertheless yeah I feel like one last question I had a friend who actually worked with ethereum yes and he was like telling me uh about like he also used that um is this actually interconnected just for a 3dmgs or it can be like interoperable in other like I don't know uh proof of proof of History like Solana or something like that I don't know if I'm just telling nonsense but he was telling me like he used that for uh our RCP support uh kind of the thing how does it work because I I was kind of confusing like he was actually using a 300.js for connecting with Solana yeah so it's uh interesting question so there's there are we've increasingly made the our packages uh configurable so one of the things we've done in the past here is we allow you to uh provide your own VM or evm implementation so you could have a chain that is not like strictly evm or maybe that has like peculiarities or that are evm-like but not like strictly the same and you can just like parse that in when you instantiate for example the client you can provide your own like whatever like rules you have for your blockchain there's obviously like a limit to that like there's a point where it's probably better just to build something else if it's like super different but it's still quite um quite configurable so you could also like there are chains like Cela I think which has like different rules for computing transaction hashes and stuff like that uh I'm not like I haven't worked with that so I'm not sure how easy would be to configure it but you can definitely adjust some parts of the code and provide your own like hashing algorithm and uh use that instead same thing with like the Myrtle Beach trees thing we've been working with you could provide your own hashing algorithm it defaults to caca but I mean you can use whatever you want okay thank you other questions thanks for coming yeah thanks for coming [Applause] 