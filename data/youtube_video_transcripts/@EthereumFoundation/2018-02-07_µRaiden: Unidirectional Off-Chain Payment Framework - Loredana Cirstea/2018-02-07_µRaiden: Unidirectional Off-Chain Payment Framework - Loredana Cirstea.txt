I think we can get started now I was supposed to be the interesting talk but 20 minutes ago plan a demo didn't work plan B demoed Android fancy demo didn't work because of poor internet connection I'm have to run full okay out I'll try to speak louder so I had I have to run a full chain for the demos to work so that's why I'm not sure that I can I'm I will be able to actually show you something so I am Loredana I have been working with brain bot developing micro rating so I am one of the developers now how many of you have heard about rating network or a micro Radin okay that's good how many of you have heard about state channels or payment channels okay so both Radio Network and micro Radin use payment channels as a scaling solution the difference between them is that micro Radin is a framework for off chain payment channels but unidirectional from many to one as opposed to rate and network which is many to many so reading network is more complex in the sense that it has it needs routing it needs fees to incentivize nodes in the system so they can route payments without having to always open channels between the sender and receiver so that's why micro Radin is actually free offers free off chain transactions because you open a channel and it's only you and the receiver are you sending tokens to the receiver so that doesn't cost anything Micro readin is available now on the main net and the test nuts robson ring B and kovin the version is zero point two and it's a another bug bounty release so after we see what happens now please if you want to look at the contracts and we actually had a very successful bug bounty release version 0.1 and we actually changed some of the code that was we didn't we didn't find any important bugs but if there were some some advices that we took into consideration so please have a look as use cases you can have a vault content so paper use this is one of the main use case and I can actually show you a demo now hopefully okay so I have my micro raid and server working here and this is the option chain syncing and we have a paywall here that wants us to open a channel we have metamath connected and we already have 39 tokens as a deposit here we can deposit nine tokens this will take a bit because this is an on chain transaction so opening the channel happens on chain and we can follow the transaction we'll have to wait a bit we can see that the micro rate and server already received the the create channel event but we are waiting for some confirmations first it has seen that the channel is open we're still waiting a bit here okay and now we can make our first off chain micropayment this is actually so that the token that we use has 18 decimals so that's why it's so large here and now we have our content if we refresh the page again we are prompted to sign to pay another time for the resource and this is how the play world content works if we want to we can also tap up the channel if we one will remain out of tokens but let's close the channel for now this again is an off chain transaction so opening a channel topping it up with tokens closing the channel and we have also added a withdrawal function so now the receivers can withdraw their tokens from the open channels so that's why these channels will will be long-lived because the service providers can actually withdraw tokens yes while the server the micro Eden server is closed the receiver that or the service provider needs to keep this micro rate and server opened if it's closed it cannot receive payments it cannot receive events so it's the the sender's or the clients cannot access the resources [Music] since reaching after you have paid for the research [Music] yes for example even at this point if we store the temporary channel data in the local storage of the browser but we can also retrieve the channels from the blockchain because opening that opening the channel topping up has events on chain so we can look at those events and retrieve that channel data and we can query I'll get this later bit when I actually explain how how it works the receiver always has the last balance proof of the the client so the client if somehow loses the channel data it can get even the last balance proof from from the receiver so this is the channel closing and we we can see that the two tokens have went to the receiver the two tokens that we have spent and the rest have come come back to us in our account we can forget the channel and then we do the process going back a bit to the presentation so one use case is the paywall content and another one is machine-to-machine services api is for whatever you you would think for example we have a video demo online and we have an example of querying the ether price and US dollars and we do this constantly and we can see that we're sending payments these sending new balance proof is the actual payment and yes you can look at look at that I also prepared or what wanted to show you a more interesting demo today not sure if this will happen just a moment [Applause] [Applause] and then I'll show you the code that you need to actually do this demo because the nice thing is that you don't need a lot of code if you know how to control the drone that was actually the harder part so up here you well we have the microwave and server for the drone so the drone has an e theorem account and there has been some a bit of activity before I almost forgot I have to connect to the Wi-Fi of the drone so we have to wait a bit until until I can see it okay oops try this another again okay if this time it doesn't work so just so the the idea is that we already have an open channel with the drone and now these commands just are done I mean you you actually pay a fee for for each command and then you can fly the drone however you want hopefully next time I'll actually have a nice interface interface for this yeah these are here we can see that we are sending the requested price and then yeah it's alive [Music] and unfortunately I didn't prepare it for this for this room yes yeah it would have been more interesting to actually pay for for each request but I have to be honest I didn't have enough time to to do it like that and we actually have it should have made some snapshots of the room so we can also make it mmm I mean we can we can also pay for for for each picture but now for for the code so there's a lot of code here because but it's it's it's something else so don't don't worry about it this is the micro raid and server that was used so we import some some helper classes from the server and then this is the resource for which we we pay and I just put in the all the commands here so it would have been nicer to separate the commands and do separate api's for them but I just wanted you to see how easy it is to actually set up a machine to machine a server and client for for this type of use and then the client yeah well we'll probably have this online so you can actually look more okay and this is this is the client so with just two files we we made this okay yeah I should have shown you this before so we have we have the repository it's open source at Raiden Network micro Raiden I told you about the off chain payments so the channel data is contains the receiver address and the sender's address the block number at which the channel has been opened and the last balance because the balance is always increasing so we we keep the last glass value and the sender also and the receiver keep the channel data the receiver also has the last balance proof received from the sender this data is signed by the sender and this is the actual balance proof we use now sign type data as a standard which is still in work so that's why we are not able to actually have a stable release because we are also waiting a bit now for the standard to be implemented and the nice thing about it is and you saw when we are actually signing the balance proof that we actually see text so we can see how much how many tokens we are paying to whom what's the contract address and so on until now this wasn't really that nice when when signing transmit when signing messages so the sender sends all of this data to the receiver and then he gets the resource we also support we support the ERC 20 NERC 223 tokens up until this point I know there are some more standards coming out why we decided for year C 223 mainly because of lower gas cost because we only do one transaction for opening and topping up channels instead of two transactions so we only do a transfer and this actually the same transaction opens the channel the ERC 20 you have to approve the tokens first and then you can create the channel and this is it's the same for topping up about closing the channels so what what happens the best-case scenario is when the sender and the receiver actually agree about what amount of tokens are owed so the sender queries the receiver and sends him his his balance proof and then the receiver signs the same balance so he the receiver sends his own signature to the center and then the sender can close the channel for both of them and that's instantly there are two two more cases when the receiver let's say he's not online or for whatever reason he doesn't want to sign the sender can close the channel and then there's a challenge period in which the receiver with the last balance proof that he has stored he can close the channel himself or after the challenge period has finished then the sender can settle the channel himself and that transaction is also instant next time we may have maybe a demo where you can play with the drone yourselves just being optimistic here so yes you can find the code and please please participate in the bug bounty we have given tokens in the previous one that's it you 