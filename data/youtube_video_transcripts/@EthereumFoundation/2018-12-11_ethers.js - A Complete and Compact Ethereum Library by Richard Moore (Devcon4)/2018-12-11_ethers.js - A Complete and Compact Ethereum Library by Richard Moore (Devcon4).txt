so I wrote ethers j/s the ideas is a complete simple tiny library its replacement for web 3 and aetherium je s if you use either of those you can use this instead so some quick history I was writing an in-browser equivalent of meta mask but this was before madam asked existed I want some like in browser adapt browser so by the time I included all the libraries that I needed the this page was 7.4 megabytes to download there's a lot of bugs back then I think somebody was mentioning and the other talk earlier that one out of 128 addresses were computed wrong from the private key so I just produced unspent able monies the other big thing especially back in the day if you wanted to build a DAP I mean it was really simple so all you had to do is download death wait three days for it to sync and once that was done connect to it and do all other stuff and now it'll probably work you might have to blow the database away a few times and like resync from scratch but it's easy no worries so I was really trying to get around that the other big issue is all the libraries web 3 etc were LGPL GPL like random weird licenses that were really not conducive to proprietary software which means that if we have things that eventually occurred like hyper ledger that start making their own sort of versions of it which would be weirdly incompatible just because we didn't let them join in the first place so that was the idea is basically that sort of idea also documentation was like nil so the highlights of ethers j/s so it's tiny over the wire it's about it's actually about 89 kilobytes right now not 88 but it handles pneumonic pneumonic he's private keys JSON wallets it tries to really do anything you could do if you were trying to build a wallet or framework or basically anything you want to in aetherium it supports it's ready to use one thing that the other options didn't offer especially at the time was like a dist package that you could just like jam in a browser and be off to the races you had to browserify all these libraries to make things work test cases most libraries around the time again even today have between like 83 and a couple hundred test cases I'm currently clocked in at 20,000 give or take maybe 50 or 60 test cases all of them are procedurally procedurally generated love to talk with that for anybody afterwards who wants to find out more about how to like procedures gender test cases providers going back to the sinking of full node providers you should be able to use anything you want so you can use JSON RPC but there's things like ether scan and technically my crypto you could just like kind of tie into their their back-end there's no reason why you can't just use these other sources of truth so another big difference for people coming from web 3 is that signers and providers actually go more to this in next slides but as a quick we'll review signers and fighter providers are very different but there's different types of signers ENS support is a first-class system go more to that in a few slides ABI v2 this ABI v2 has been available in ethers j/s for over a year now I was kind of talking up last year at the previous Def Con again lost documentation and everything all dependencies are MIT licensed which meant a few of the libraries that existed like our LP encoding at the time again we're only available as GPL or LGPL so like those things were rewritten so that they could be MIT licensed ok can't read the clock anyways so yeah going back providers there's lots of different types of providers ether scan and Fira json-rpc IPC web is coming soon there's a web 3 provider which you can if you have a currently current existing web 3 app you just jam that provider wrap it in a web 3 provider and now you have an ether is compatible provider you can use for any of these sorts of things fallback provider we're coming with a smart provider soon which will for example get quorum against multiple backends because right now you're trusting API is you're trusting ether scan tells you the truth what if they're hacked or you click that I accept turning off SSL protection basically when you're at Starbucks so that's the age of providers providers are very high level very only talking to what you'd expect a blockchain to be able to tell you which is very separate from signers signers are where your private key lives the idea that your private key should live in the same memory space as the thing that's just talking to the network and doing crazy things just seems inherently unsafe so we let waltz be a private key a mnemonic for example the Firefly the hardware wallet we design or Leger nano wallet these are just other types of signers you want to be able to use to to carry and do your work this was a weird decision I'm actually curious why this was originally designed basically when you send a transaction in web 3 you get back a transaction hash so for example if you send a transaction to the goth node and you say value this data that the Geth node is figuring out the gas price for you the nonce all that extra stuff but all you get back is opaque hash so you actually don't know what it chose for you especially in the case of like gas congestion you actually don't know what was used so you can't even know if you need to replay the transaction a higher gasp cast importantly all that information was signed by the Geth node so it knew all that information it simply just hashed it and threw all that stuff away and gave you back the hash so I think makes a lot more sense to return the hash this gives you a lot of advantages the biggest one being that if you deploy a contract you can instantly know what the thank you you can instantly know what the the contract address is going to be once it's mined right that's kind of what this slide explains I'm getting ahead myself but yes the last thing I said apply to the slide 2d this for me I often go on record saying like if ENS is the only thing that comes out of aetherium that aetherium has been a wild success like E&S people again talk to me afterwards like I I will talk for hours about how ENS is like the biggest game changer in the crypto space like I don't even care about yeah exactly yeah UNESCO get your stickers later everyone the so es is really cool because you get these named things it's kind of like dynamic linking it means that if your app depends on a contract you can actually and you can choose static if you want put an address in there or dynamic people use an ENS name but it means if you update your contract all those places you've deployed code including maybe e and s where there's a hash and you can't ever actually change it just continue to work your upgraded contract goes off to the races it's happy and functioning so you can use it anywhere if you're sending a transaction if you have a ERC 20 token contract and you've got a to address in amount that to address can just be Rick muta Firefly eath and it will be parsed for you and figured out at deploy time calling a contract is already a synchronous there's no additional cost oh yes Hugh and real api's okay I'm at three I guess so I was also a strange idea we have this machine readable code in the form of solidity so we've all these signatures that are machine readable and actually sort of human readable and so we take that that machine and human readable code and we turn it into this like machine readable code it's complicated so this is a simple API it's six kilobytes worth of JSON which is kind of ludicrous as opposed to like it's human readable and machine readable just use the solidity contract so if you look I can't point the thingy but this is like all you need you just need the signatures we can parse that for you and figure out what the ABI should be and the nice thing is if you look at the source code like you think you you understand what this contract is doing most the time you pull this big opaque piece of JSON in and now the rest of the code you totally don't really know what's going on whereas this is very obvious what the api's are available to you if you just use them makes code readable I think readability is very important especially in terms of audits and like just trusts oh oh sorry I think I'm almost through my slides sort of but ABI v2 so like I said we've supported ABI v2 for over a year now that's basically you can pass trucks in arrays of strings it's actually kind of cool web 3 now supports it if you take a look at web 3s implementation it's require ethers slash utils slash ABI coder it's an awesome solution and it means we have like one good working solution that everyone can use and we're off to the races extras promise friendly you can basically pass promises in anywhere you could pass a thing in a lot of blockchain things are asynchronous and so for example if you have a transaction one of the things you pass in is a nonce well you can just pass in a promise that resolves to the nonce as your nonce and again everything is asynchronous it can be resolved a bit 39m onyx we support English Spanish French Italian Japanese Korean and both simplified in traditional Chinese yes utilities we've got lots of utilities for dealing with one minute okay avi yeah so basically stuff these slides will be available online I try to make everything as possibly available as I can and the rest are just examples I was not really planning to show these off these are just in the slide deck so when you look at the slides afterwards you can kind of get an example of it's easy to use you just pick it up and start using it there's no sinking nodes there's none of you don't need meta masks or anything it just works out of the box and done so questions I think I have a minute maybe half a minute you 