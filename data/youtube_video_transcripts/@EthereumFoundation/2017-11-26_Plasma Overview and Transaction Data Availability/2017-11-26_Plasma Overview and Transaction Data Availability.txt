um hello that's loud hi everyone I'm Joseph Cohen I'm here to talk about plasma and this is gonna be sort of an overview for about the first ten minutes so if you already seen the other presentation a little bit a little bit of this might be review so the second half is going to be sort of exploring the narratives around you know in from data availability and the data of eligibility problem you know Vitalik has been talking about the state of availability problem for the past several years and is very critical when it comes to aetherium base layer scale abilities such as sharding and today I'm gonna be talking about the implications of data availability when it comes to building transactions when we're talking about plasma in particular so plasma was is a project that right now is being architected and after that will be written and it's co-authored by being vitalik and hopefully you know a lot of people in the etherium community can contribute because I think this can be you know this could be a lot of fun so plasma at its core is about building a blockchain on top of a blockchain so you write the smart contract in it in inside aetherium and you initialize it by basically taking a library and modifying it to whatever's particular use you need so for example you can build you know some social network some decentralized exchange or even some private private blockchain I think the private blockchain example is pretty interesting because you can build a private system with your own rules with your own participants with whatever terms you want but also enforceable on the public network that's pretty effective because right now a lot of private blockchain systems are role-playing right a lot of the systems they're building today can be modified by the operators of these systems if it's these five people then you're sort of like well all my money is sort of at the whim these five people if you bond your activity in a private chain to a public network that allows everybody in the world to sort of say okay this allows the etherium network to sort of be this base layer for all of these private chains interacting in the future and that could be an interesting aspect to develop on and the way this works is that in the smart contract you make it so that the consensus rules are defined inside a theorem itself where you upload the smart contract and it's enforceable via fraud proofs and each individual plasma chain has its own consensus mechanisms defined inside the smart contract and it could be written in solidity or in the future more likely Viper and the goal is to build decentralized applications at scale where you can create you know transaction like billions of transactions per second is sort of the goal you know given given certain security constraints the presumption is that you're not really trusting them and the way you do that is that let's say your Alice you have 1/8 held inside this plasma chain and this plasma block periodically commits block hashes on to aetherium so it's you know very very small measured in hundreds of bytes and which can encompass perhaps two gigabytes of data this is not proof of existence proof of existence is another form of like role-playing that people use when it comes to building block chains inside block chains this is actually enforceable the notion is is if you create an invalid block if a block is invalid it can be penalized and rolled back and what this allows you to do is allows you to create a lot of transactions inside a system this is of course assuming data availability and data availability is an interesting problem that we'll get into in greater detail later and essentially this is an example if someone submits an incorrect transaction an incorrect block rather and then what happened this is someone submits a proof onto aetherium and you can submit a mark lies proof and it's actually very similar to the previous presentation about true--but where you know you have merck alized enforcement and Merkel eyes data station and by having Our client Stata station you can you can represent information a very very compact way so for example if you know the this very very specific let's say hundred bytes within a block inside this plasma block is invalid you just say okay these hundred bytes are invalid here's a proof that these 100 bytes were inside this plasma block and then you submit that inside aetherium and it's very very compact that allows you to say okay one piece of this entire block is broken let's roll it all back and then in that moment that individual that the individuals that created that block get penalized and that allows you know some measure of honesty and when it comes to propagation but the core notion of plasma is not around the notion of Merkle ization of information the core notion is about exiting in the event of data unavailability data unavailability is an interesting problem because you can't prove when someone produced when someone is withholding data it's sort of like if Alice and Bob says Alice says oh I gave the data to Bob and Bob says no Alice didn't give it to me who do you know is right you really can't be on like having trusted this trusted third party and then you know in aetherium we try to like reduce that as much as possible and what you can do in plasma and this core of plasmas construction is this allows you to exit in the event blocks are withheld so plasma blocks in this case so it's saying that if you if let's say block number four is is committed so this hundred plus bytes is committed on to aetherium and it's like wait I don't have this data I can't prove this as false I can't prove this invalid so then what you do is you then to submit it and then when you when you are not submit it you exit and basically you exit from that chain because you're like well someone's not giving me the data there could be bad data in there there could be bad state transitions it's sort of like if a party starts sucking you just leave you don't try to make you know like it's like a party's a disaster you're just like well you can try to make it better but you could just leave and join another party and it's much more fun that way for everybody and the fun part is when you do blocks blockchains you could do block chains and block chains and block chains and block chains and that gives you even greater scalability where you could do like potentially billions at this point representing a single use case for example you know like fun posting in some live chat you could you could do that and like you know build a system where you could you know and make that enforceable in some way and that gives you a great deal of computational scaling this is not just computational scaling of financial activity but potential anything you know this could be a system or you know you you move from you know a centralized data services well you know like Reddit or Twitter or whatever it may be and you could credibly decentralize this since capacity is significantly increased to an incredible degree this also lets you do computation using MapReduce so you go like okay map and you so map out all the block chains and block chains they do computation across many many different block chains and you reduce the results back down is sort of like returning variables so you just have one way of splitting up the work in one way of returning the work and that's sort of how you reach incredible computational scale so the design goals is you know one block chain can encompass you know all world wide computation maybe not all is in everything but all is in like you know there's no necessary constraints given given the security properties of the system and the goal is to do trust minimization where you're not trusting the people operating these plasma chains because you can ultimately go to a theorem and enforce invalid state transitions and the goal is to payment electro scalability ledger scalability is interesting because ultimately you want records and that's it's sort of like state channels gets you like you know an X percent x time scalability this can give you you know many many x and you know aetherium Chardon can give you many many other x's and then at that point you can reach an incredible scale and I believe that you know this is very much in the near future you know measured in you know you know very short time frames not like ten years plus but closer to like low digits amount of years but you know transaction data is I think can give you an example of the problems that we're dealing with this may be a little bit you know more architecture so for if you're a little bit you know it may be a little bit hairy this requires some knowledge in the way you know atomicity it works but basically what we're talking about is that you know you want it you want to create a transaction and you want it you know and then let's say you just broadcast it inside this plasma block you're done right not really you can't attest to this payment if the block is being withheld remember like that block number four I was going over earlier if that happens then if you know there's you make a payment you don't really know if that payment is in there and like you don't know if the correct amount is in there you don't know if like the current state is correct it's just being withheld from you and you can't even prove that it's invalid it's sort of like you all you can do is just say well maybe my payment is in there maybe it isn't in there or maybe it's wrong and if it isn't there and you try to withdraw an old state then you get penalized if you try to withdraw and it isn't in there well then that makes no sense that won't work and if it's incorrect well you have a big problem right and normally when an incorrect state is attested you you just exit but in this case you may not have enough information to exit so that's that's sort of a problem that needs to be addressed within the context of data availability and you know you you're not sure if that that those funds are even spent even further right someone maybe that transaction went in to this plasma block and maybe later it gets withheld because it gets spent a separate transaction Spence's so that could be a big problem and this problem also exists when you put funds into a plasma block as well so how do you address this you address this by creating this two-phase commit process this is a very different different way to do it this is not a hard necessity for a lot of problems but if you want a hundred percent certainty this is sort of how you would do it in the event of data withholding we don't have this problem on the etherium base chain right on aetherium all you do is use broadcast a transaction it gets confirmed you're done the reason it's not a problem in aetherium is because it has presumptions of everybody having the data available aetherium works by I receive blocks I don't trust anyone else right anyone else on this network and when I receive it I compute it I validate it and I just make sure that it's true according to the consensus rules on my computer and what happens is I can process the current state but you know you could also do a full replay of the entire blockchain history in order to have you know 100% assurance that's not necessary but it you're capable of doing that because you have the data available in this case when you split up into all these different plasma blocks that are only committing very small pieces of data on to the etherium main chain what happens is is that in this plasma block there could be information you don't know about and this when you when someone's withholding you could exit but what happens if you know like you don't have you don't have all the data so in this case what you do is you create and broadcast the transaction much like you do normally and in this case the plasma block it's signed by a validator so it gets included into a plasma block and then step three is where it gets weird Alice commits that she saw her transaction get submitted into a block and she can give that to Bob and or she can submit it onto the plasma chain so that there's like a second record so it's sort of like I submit a transaction and I submit another transaction saying I saw the first one and then at that point when Bob sees that second step whether it be directly from Alice or from the from the plasma chain Bob now has assurance that the money is his why do we do this right Alice needs to be sure that the transaction has occurred and she's able to reference it remember that Merkle eyes proof stuff so Alice now is able to reference that that transaction existed and now Alice is able to be assured of it and now she's willing to prove to a test that okay this money is no longer mine and this is sort of the one weird trick to make this all work and as Bob you're only willing to accept the funds when you receive that second step because at that point alice cannot claim the funds according to the consensus rules written in you know solidity or viper on the base chain on a theorem basically it says like okay once the second signature happens alice no longer has any claim to the funds essentially we're dealing with three parties here Alice Bob and the plasma chain itself so let's go over these four steps there's Alice there's Bob this is the chain and that's sort of the state so that's the third thing I was talking about Alice has 1/8 the parent of the the plasma chain is there and then in theory I'm on the base layer which periodically gets commitments and exits and deposits so Alice signs a payment so this is like very similar to how aetherium works you just send a payment into the plasma chain ultimately a plasmid chain creates a block and then it sent it sends a commitment onto etherium and it says hey I made a block here's a couple hundred bytes Alice and Bob then get the data of that plasma block and it says like okay I see this block is this legit okay there is a payment going on Alice and Bob both see that there has been a payment from Alice and Bob Alice to Bob notice on the top right it shows Alice or Bob because either Alice or Bob can claim this according to the Shane itself step 3 this gets a little bit tricky but you know it'll it'll it'll it'll make sense so Alice then submits a commitment sign by herself that she has seen that previous transaction and essentially she's able to prove it because she's sort of like can see the data there and sees the Merkle eyes commitments so she's like okay cool this money's no longer mine she passes it off into the plasma chain and Bob and now from her perspective it's not her money anymore if she tries to claim it bad news for her because she's not able to do that or gets penalized for Bob it's sort of like well okay if he hasn't received it yet oh there's a slide skipped oh well anyway so for Bob he let's say Bob hasn't seen it yet but should be a - then then Bob doesn't yet know whether it's Alice's or Bob's from his perspective it should be Alice's and for the chain it sees it as Bob's because you know it received that transactions and confirmed in this case now that should be a - line - Bob did not - saw the line - Bob so we're correct here now Bob now sees the funds as his because he has that commitment and the original transaction so Alice now has no claim and in the top-ranked you now see Bob as the 1/8 so creating this two-phase construction allows Bob to know that Alice no longer has any claimed the funds and Alice has assurance that she does not she will have the half the funds available if the block is withheld at any point in time so as an example let's say Alice tries to maliciously withdraw the funds if Alice tries to withdraw the funds during step three what happens is that the when it's not fully committed to Bob yet she submits a transaction on to the etherium main chain the etherium root chain I you know basically what we call a theorem today and let's say the holding period is 14 days before she could correctly withdrawn she has to put up a bond assume that Bob believes that the money is his because he has the information available to prove that Alice has committed to the fact that she saw her original transaction then what Bob can do is take that proof that says Alice says hey I saw this transmitted transaction hit the block here's a proof that this transaction hit the block and here's a commitment that I have submitted this transaction Bob should say okay that's money is mine now but if Alice tries to take that money Bob can't submit to a theorem that says okay I'll just try to submit this Bob sees it on the blockchain and he says okay Alice I was screwed up or is trying to take my money here's a proof because Alice gave it to me and I saw her on the chain and now what happens this Bob is even happier because she takes her bond and it's about his money back so this type of construction by constructing a two-phase commit process your Garin you're basically making a test station on information availability and this is going to be I believe be an emerging theme when you're dealing with states where not everybody in the world has information right we're not dealing with global state anymore how do we deal with this right in channels the way we deal with it is we can only move forward if both parties have it available but you know we're dealing with perhaps thousands of parties billions of parties maybe eventually and you know different people have different sets of data so you know the goal is to be able to make it so that you can have attestation correctly and to scale and you know perhaps you know the blockchain can be the ultimate arbiter in this case aetherium can basically be the Supreme Court of computation across the world thank you [Music] 