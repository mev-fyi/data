alright so I'm Joey Krug from auger or prediction market on athyrium and I'm just going to talk about a few kind of weird things that we do it's may be different than other other contracts on athyrium and kind of why we do them and I'll keep it keep it short so maybe we can get back on schedule so when you're updating contracts there's like there's a few things you have to decide one is like how do you decide whether to update the contract you know you could say you can have one private key which basically says this private key is going to be the one that updates the contract you would have em up in the so that's like multi signature where you say you know three out of five of these keys have to agree and if so will update the contract you can do other things like in auger for instance the way we're going to decide updates is will have the reporters vote on it but I decided didn't make sense to talk about that too much because you know having something like reporters in your system may not be too relevant so the other problem you have to solve an update in a contract it's basically how do you actually do it without like losing your data or paying a ton of money to transfer your data so the simplest way to do things is you basically just set up a contract it has basically your data in it has functions and all the functions to do is basically forward the call to another contract which has your business logic which you know actually modifies your functions so an example would be like you have a contract that has like some money in it or something and you want to be able to update your sin function and so what you do is you write another contract and the first contract always forwards the calls to the new one and your first contract keeps the second contracts address so if you want to update the contract all you do is change the address the problem with that is you basically cannot really change the parameters that send uses you cannot you know make an entirely different function so it's kind of limited and how you can upgrade things another thing you can do is there's this thing called call code which is an opcode which allows you to basically run other code from another contract as if it was in your contract it's similar to delegate call the only difference is call code you can't have state and second contract which isn't really super relevant to this talk the problem with doing that though is you can't really change that what's called the ABI in any easy way so every contract has this thing called the ABI and basically all it is is the data that tells you what functions your contract has what parameters your contract functions have in them and so if you want to be able to update your contracts and change the gay bi using delegate calls not super good way to do it there's one kind of happy way you can do it where you say well if we pass the message data to the contract we're calling then we can basically set it up so that you can call any sort of generic function on any contract you want provided that the user you know inputs the proper data the problem with that is one it's very confusing for people trying to audit your code or read your code try to understand it it's very confusing from someone trying to interact with your code because it's just this generic function it's like pass the message data to to whatever contract we want so the way we actually do updates for contracts is we separate the data and we separate the business logic so all the data is stored in separate contracts with getters and setters and all the business logic so stuff that modifies it are all in separate contracts as well then what we do is we say okay in the data contracts will have a white white list which allows these business logic contracts to modify it and so what that allows you to do is it allows you to update your functions that are actually modifying state in a relatively easy way and it allows you to add new functions allows you could change the parameters allows you to do basically almost anything you'd want to do when you're updating something without many limitations and if you want to add new data you can basically just create another data contract that's kind of the way we update things as opposed to using the you know the more traditional recommended way of delegate call another interesting thing is we use serpent as opposed to solidity the reason we use servant is because it's stupidly simple if you look at solidity as it has quite a few complicated features in it there's a lot you can do with it actually serpent is this really basic and so it makes it kind of easier to find flaws when you're looking to serpent code as opposed salinity code the other reason is when we started slowly didn't exist which is it it's a good reason but one thing I'm really interested in is when you look at like like how we're trying to approach like formal verification and things like that for improving security of smart contracts we're really kind of almost starting from scratch we're building on top of solidity things like that yeah they're using using like y 3 which is good because it's you know building off of existing work but what I think would be really cool is it's like you were able to like right smart contracts in a basically so i made it tweet about this kind of as a joke but then I looked into it more and it actually seems very interesting it once the evm supports web assembly you'll be able to take a to code compile it to using the hell lvm and compile that's web assembly which means you can write smart contracts in ada which is very interesting because that's the language that DOD nasa all these super super mission-critical systems use an interesting thing about it is they spin and hundreds of millions of dollars into writing Suites of software that allow you to do form of verification very easily so if you write a program in ada it allows you to do tons of formal verification stuff automatically for one is that even happen to do anything and then if you write like assertions and things it'll also automatically prove things for you very easily so what I think it'd be really cool is people started writing contracts in a tub so if you look at like this theory on web assembly github page they have plans to make it so there's a library for see a library for rust and instructions on how to kind of use a cerium right right athyrium programs in those languages and could be cool if they have one for ADA so what we'd like to do is basically like an announced like basically ten thousand dollar bounty where if someone does that for ADA you get 10k and Bitcoin or ether or whatever you want and basically not super relevant right now because the web assembly stuffs not that far along but in a few months once they start doing it for C and rust shouldn't be too hard to do you'd basically just look at what they're doing what things are adding and write a library for ada that allows you to write 3m contracts and ada absolutely very cool because you wouldn't actually prove quite a bit more about your contracts in ada than you can in any other any other language the only other thing i have is where people ask me all the time about what we're doing with Rep when's the rap launch so basically bunch of people mess up their theory and by end so we're going to do it another test run this week and then after that launch like in a week and that's that's the idea that's it 