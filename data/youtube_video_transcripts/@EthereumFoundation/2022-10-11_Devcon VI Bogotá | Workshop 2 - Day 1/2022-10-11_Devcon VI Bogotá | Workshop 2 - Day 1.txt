thing let's get rid of only owner because like to have a like a function that only owner call might be useful for like if there's funds there or like you're trying to do some kind of like high level thing but for like someone just interacting with a smart contract you want to just allow anyone to do that we can still use ownable and we can still kind of like inherit the ownable and like transfer the ownership so that we still have access to the the smart contract and we still own it because we might want to use it later um but instead let's do like a different required statement let's do require uh message dot value is equal equal to uh some kind of variable we're going to set we'll set price okay and then otherwise we'll say not enough okay so there's that and then uh what we can do is set that variable so we can say units US public price equals 0.001 ether okay you can see like it tells me exactly how much weight is equal to Ether but we can you could Define it as way there or you can Define it as ether it's just it's going to work either way right so we can set that save it and then we have to also because we're trying now we have a function where we want to accept some value there and we're going to check against the the value that comes in that transaction so now we want to make this payable right so let's do that so now that it's payable and we are requiring some value there so our deploy is successful and we can come back and now we can see we get a new variable right we got this new uh variable for price it's in way so you know obviously if you're like building an app you don't want your like user to have to like type in these crazy long amount of ways so you want to like in your UI you would kind of like do that calculation with like ethers uh because ethers is part of the component and we'll get to react in a little bit and I'll kind of show you guys around what that looks like um but we'll see that our our purpose now is here like you can set up a a name but you also have this new value for the for the value right you have to send some value so if I come over here and say like uh Foo like this and I put in 0.00001 right the wrong amount you'll see there's a little green button which is kind of cool it just does the math for you to like convert to way so you just it it's going to do time uh basically to the 10th 10 to the 18th power or times 10 to the 18th power sorry uh and it's going to convert it for you so if I was to try to do that it's going to tell me that not enough right I didn't add enough value so you could just uh copy paste the price that we know exactly what it is right and then it lets me right so we're able to do this kind of like cool like vending machine right we're actually our contract now you can see it has some value right it's got a dollar 29 in there so you can start thinking of like your smart contract is like this way for people to be incentivized to interact with your function uh and then it can store value but there's a problem here uh the problem is now the money is locked in the smart contract because we don't have a withdrawal function uh so the next thing you would do is probably do a withdrawal function right um and so we could do something like that we could do function withdraw um public and then we say only owner for that one right because we only want to set the owner right and then we can do something like um we set up Bool success uh otherwise we won't set a bullion uh equal message dot Lu dot call password and then value equals or value is uh what is it um this dot address uh balance I think let's see if that works I think I do this I think that's right see if that works if I wrote that right oh address dot this balance yeah coaches oh here like that balance thank you thank you see not enough coffee [Laughter] [Music] foreign like this anyways but let's just keep going but you get the idea you would have well next you would have a function we're not actually going to worry about that uh let's keep going though um so I want to show let me reset real quick um I want to show a little bit of like the kind of react code so that you kind of can get a feel for like what that's like um inside of the The Source directory we have the app.jsx file uh this is kind of again this is like well you have like your uh app GSX is kind of like where you're gonna like um have like the main component sorry earlier I said it was app.jsx app.jsx is actually like the main uh component it's also where you can change like your network right so if you want to deploy to a test net uh eventually you'll you'll also want to update your UI so it reflects that so you can just come in here you could do something like type quarterly um and it would update as well just save that um um so we can save that and then inside of the views directory we have like the example UI which I didn't get to yet I'll show you and then there's the home GSX so actually this is where in home jsx is where you would build your dap inside of scaffold thief and then there's also a subgraph support as well so if has anyone heard of the graph right I'm sure you guys heard uh what's really cool is there's a built-in kind of installation of uh that runs in Docker so the additional step is that you have to install and set up docker on your machine but uh once you spin up the graph it's like a local graph node and then you get access to the graph API and then you can actually access the API data through like this kind of like graph iql like internal um uh kind of browser um and then you can kind of like toy around with like using uh the graph as opposed to using like events because it's if the minute you start getting lots of events in your smart contract it can get kind of clunky and so the graph is a good solution so I highly recommend too if you guys are like uh looking at ways to optimize the graph as a good as well the hints is just like kind of going to walk you through and like explain to you like some of the stuff that I've been explaining to you tells you where to go and certain things so your front end is going to be here in app GSX tells you like to explore the hooks because there's inside of let me go back to that real quick inside of Home app jsx you can see that there's a lot of inherited stuff already available to you one of those is ethics which is also built by Austin Griffith and the build Guild and it's got a lot of components that allow you to like really just easily access your your smart contract um and then the example UI has like kind of examples of how you would like to react like my crutches react I'm not really great with it so like this is great if you're like building something you can like kind of copy and paste it's got like ens support uh like it shows you what to do like an ens ens example how to like get your address how to see the balances um you know how to do like those little buttons that allow you to call certain functions right so if I wanted to set the purpose to Cheers I didn't set any value but yeah you get the idea it's this kind of like example there's also an instance of the mainnet die contract that's there as well if you're going to do anything with stable coins um we're gonna go from there okay so now now that I've showed you kind of like a basic walkthrough of scaffoldeeth um let me make sure this deployed we reset it okay so I'm actually going to stop this one um let's go here and we're gonna stop this one as well and I've just got another tab basically open where I've kind of already done the same thing it was like really hard to read you guys see that okay um so I'm now I'm in the uh the challenge zero directory so basically what this is is I told you earlier that there's um different builds of scaffold teeth if you go to the GitHub and you go back to like the root of scaffold Heath um you'll see there's two other kind of repositories it can get a little confusing there's there's cavalithe which has like a lot of like examples for like like I said nfts you know different implementations of that stuff the scaffold youth examples folder has some additional ones that might not be there and then you have this challenges so the challenges is basically everything that you do with speedrun ethereum is available there so the first step that you do for a challenge is you actually check out that repository so the very first one you come to is the challenge the simple nft example so we have access to it here and I've already checked it out and this is all available in computer and ethereum as well but it's also in the readme I think it just pulls from there actually so it's the same kind of a setup if you're going to do challenge zero which I would highly recommend everyone here uh as soon as you get to a stable internet or if you can like wait through the yarn install and get checkout after you do that everything is pretty much functional so I've already done um the checkout here I've already done the yarn install let's just make sure done uh oh and the other step is you do need to check out the the right Branch because this root Branch it's a little confusing at first is the master branch is just a basic readme and you have to actually check out this Branch so you'll clone the repository and the extra step is that you'll check out this simple nft example which again it tells you that here so you just have to make sure you follow along you can pretty much do this like um in probably like 10 minutes it's pretty easy and then we're going to kind of walk through a little bit right now so I've already done that did the install so let's do the same thing let's do yarn um you're in chain let's do yarn start I close this one close while we keep that one open actually okay all right so while that loads uh let me just come over here and do a yarn deploy so now we're going to deploy this new instance and let's grab the um uh the config file as well so let's do atom Dot let's take a look at what's different with this basically so um let's see if it deployed successfully it did and react started uh so let's first let's look at the UI so what do we got localhost 2000 and you'll see that we get like a whole new kind of experience right we have the the your Collectibles and we have this like transfer function so we can call a transfer um we can also upload to ipfs like metadata and also download and then we also have our debug contracts folder so you'll notice the debug contracts is a lot more involved and that's because we are inheriting the open Zeppelin smart contract uh for ERC 721 so let's take a look at that real quick so we go to contracts your contracts and we see that we have just a different version of solidity essentially we're in in importing all of the erc721 standard stuff we inherit that stuff and then we have like these overrides we're doing on minting and it gets a little more complicated but uh really all we're doing is just setting the URL for the nfts and then we're minting nfts here and keeping track of the counter for the index of those there's a bunch of stuff here there's like we're just setting the token URI and we also have the ability to like burn nfts as well so this is already written for you so you have this starting point and then you can change the name of your nft to whatever you want so especially for hackathons it's great because you can just if you're doing an nft project you just use this as your starting point right and then we can come over here and just with the button we can see how easy it is to make an nft oh we need to grab some funds and let's just start mining some nfts oh no that's not good it's probably my internet connection because it's trying to like use ipfs yeah let's try new ipfs so this might not actually work sorry guys um but normally what you would do is you'd be able to Min an nft because what happens is uh there's this like kind of like Json file that's already created for you um I don't know exactly where it is let's see it's in uh Act uh source it might actually be in one of the uh let's see Okay so I'm trying to remember where it is index oh yeah sex so yeah there we go so there's this uh there's this Json structure kind of already created for the nfts so what you can do is you can come in here and edit the URLs so all these nfts are actually created by Austin Griffith uh they're like little paintings that he did on Nifty ink so if you guys aren't familiar with Nifty you should check that out you can like draw on there and like basically create an nft on there so he has all those on his website so these are just like nfts and you can see here how we just like have this Json file you can customize it with the name description the URL uh maybe if you want to add treats to those nfcs you can do that and then with this mint button here is doing if the internet connection would work is just basically grabbing that file and then creating an nft right um and then if we look at the actual code again for the actual smart contract um you can kind of get in and kind of like learn exactly how ERC 721 Works uh and kind of explore so if you're yeah if you're just getting started again I think what I would recommend is uh you know obviously check out the repository uh Toy around uh just with like kind of copy and pasting stuff from uh solidity by example into your smart contract uh if you get more you know as you get more um kind of knowledgeable on understanding solidity and understanding you know how stuff works then start going through the speed run challenges the simple nft one is really really easy again it takes like 10 minutes but as you get further down here like they get a little more complicated um and you kind of have to start like uh like even like the dice game you have to figure out a way to like game uh game the randomness of the smart contract and kind of like hack it a little bit um and then as you get here like when you get to build a decks I mean you're literally like building index on your own like it's really really difficult so um as you get down you'll you'll find that pretty much after you get through all the speedrun ethereum you'll be pretty much ready and set to go and get hired as a solidity upper right that's the goal and you can be part of the build Guild so um yeah so that's my demo um I'd like to just see if you guys had any questions or if anyone wanted to yep yeah uh so there's a typescript build of scaffoldeth that you can get you just can come here to scaffold Youth and I believe it's let's see here so scaffold youth and then you can do a search for typescript there it is so it's a next JS typescript implementation and it is a lot faster actually it's um it's really fast with next JS so if you're good at typescript that's definitely what I would recommend yeah yep okay good question yeah so the question was what's the difference between storing nfts on ipfs versus R weave um ipfs is is good if you're like paying for like pinning service of like your assets um that you or if you're running like your own ipfs node and you can kind of guarantee uptime that you know obviously the benefit for something like our weave and there's like another decentralized protocol where you can like pay up front for your storage they use just a different kind of like decentralized algorithm ipfs is all hash based and it's all based on like um the hash being like distributed across the ipfs cluster but there always has to be one node that has the original kind of hashes otherwise it's not going to get properly it won't be available and so that's why you see sometimes with like some nfg projects where you just don't see the image anymore it's because they've launched this thing with ipfs and then they haven't pinned it properly and it's pretty much gone and then you have to like update the the your URI in the in the nft and that usually doesn't happen because you have to pay for gas for that so yeah something like are weave is good or again if you're using something like pinata or some other like ipfs pinning that's that's advice yeah yep oh tmux yeah so the question was what do I use for my uh my my terminal so this is tmux yeah it's really great um and you can kind of just like you can create sessions you can store your sessions um it's really useful tmux another question um your recommended learning path the UI then maybe when you're ready yeah yeah I would have totally deployed if the internet connection wasn't so great at my next plan was to deploy to a test net and then eventually do a mainnet there's some things you need to do so the question was basically was like um for the UI I think it's a two-part question learning the UI components for like react and stuff like that there's a lot of like traditional like react kind of stuff you can do um I don't really personally have a feeling because I'm not a react expert maybe someone else here does but I would just kind of look at like react like introductory courses because if you just get a basic understanding like I said most of the react stuff's already written and you can kind of copy paste and stuff like that but as far as um for the the second question um if you're gonna push your app to uh production or even even to a test net you probably want to get your own instance of the inferior key so we use an uh inferior so you'll want to generate your own inferior key and put that in before you launch to mainnet that's one of the things we ask because otherwise our API key gets bombarded and then you also want to set up an etherscan API key as well so you can verify your smart contract and then as far as like publishing to um you know like a mainnet I would just consider like abstracting away as much of the scaffolding stuff as you can pulling it out because you know you want your app to look right polished but there's a lot of cool apps out there that are actually still using all the little components and stuff like that too as well I didn't really get into it but let me actually real quick now that you say that I do want to show one thing if you're going to deploy to um sorry if you're going to deploy to a test net you're going to want to use a yarn you're going to use a deployer account you're not going to want to use the hard hat account because everyone's private key in the hard hat is the same I think so you'll want to do a yarn run generate so what that's going to do is it's going to generate a mnemonic and it's going to store it in your base directory for scaffold eth we can see it it's right here somewhere somewhere here there it is mnemonic.txt I think in the newest version of scaffold eth it's actually the the public address dot text so it's whatever the public address is but I'm not going to click on it because it's the password there but basically um it's going to use that special mnemonic as the deployer account so that there's no chance that someone can gain access to your smart contract uh and then what you can do is you can do yarn account and if you're on it if you're on a gonna deploy to a test now what yarn account's gonna do is going to give you the QR code for that account and then what I do is I just use a punk wallet on my phone Punk wallet.io it's a way for you to like create a like kind of a little like toy wallet uh and I just have it as like an icon on my on my uh desktop here on my phone and I'll show it real quick and then I just scanned that uh that QR code and send my funds through my through this little camera reader so Punk wallet.io and then at that point if you're deploying to a test net you'll have test net funds that you can transfer easily Rush by scan in that um and obviously if you want to deploy the main set you need to do the same thing you got to put some deployer funds on there it's not working because the internet but normally what it would be doing right now is it go through all the networks and tell you on what your balance is so you could send some funds and then run it again right and then see that your balance has been updated and then you can do a yarn uh sorry so normally you do a yarn deploy it's just using whatever hard hat is using for the deployment so inside the Hard Hat config so if we go to hard hats trying to see where the hard dock config is oh there it is so inside the Hard Hat config you can see it's configured as localhost so if you were to plan to like go early you could just type Gorly right there or you can just do um I think it's during deploy dash dash Network squarely I think that and it would try to deploy to Gorly okay so it's either War you can just update it in the hard hat config or you can just do a manual command there so hopefully that answered your question sorry it was a long long-winded answer but I I just realized that I forgot to explain that so that's useful all right what are the questions you guys got yep yeah yeah there is there are uh there's actually a website my internet worked I would I would tell you what it was um there's um juice box juice box I think it's called is like a kind of like a grants um application that was all built on on scaffoldeeth um Nifty ink was built on scaffolding Punk wallet was built on scaffold Heath so there's a lot of like uh people actually using um scaffold teeth in production you got a question yep that's a great question thank you um and I didn't get to that either so the test the test folder the question was there was a test folder here and we can see we have this my test so um all most of the builds come with a Associated test file so that when you deploy it you can run a test this test is actually part of the speedrun ethereum you have to this test has to pass before you can get your thing approved and you can rate these it's basically hard hat chai tests so you can write it in JavaScript and you can test against and definitely that's advised and to do that you just run yarn test like this and it's going to fail because the internet connection well maybe it didn't oh it's good okay so we can see here that we did a challenge zero simple nft and it worked and it was deployed uh and then you then if you start building your smart contract you can start modifying your test all right as you go good question yep great question so the question was can you use Foundry instead of hard hat um there is a Foundry built so I think I earlier um if you come over here and you do a search there should be a Foundry version yep right here so when I first got in here I was on The Foundry version it's I think it's rather new I don't know how 100 functional it is but I I think it's it's been tested and I think it's working good question yeah another question I saw on the other hand somewhere [Music] awesome thank you guys so much for coming and let me know if you need anything I'll be around so thank you [Applause] thank you that was awesome he's not yeah he just had a baby yeah yeah foreign [Music] foreign [Music] [Music] [Music] [Music] foreign [Music] [Music] thank you thank you foreign [Music] thank you [Music] [Music] thank you [Music] afternoon [Laughter] in their left or right on the left okay [Music] um [Music] that's it sorry [Music] um yeah no I think we need what they do right no no sorry what you're saying um [Music] um okay let me see okay oh no it's all right honestly test it [Music] well now we know it it works same so how do I put it on or you put it on let me make who puts it on the microphone okay you control it all right okay good now we'll be good okay yeah okay all right thank you man what no no no um [Music] [Music] though Orange [Music] [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] [Music] [Music] foreign [Music] foreign [Music] questions videos [Music] hmm [Music] Workshop if so emotional chills um [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] oh wow wow nice [Music] [Music] [Music] um this this everyone my name is developer a CEO founder and previously I worked at open Zeppelin and co-founded D5 startup called Baby on finance today I'm excited to present you a workshop titled unlimited size contracts before we jump in the action you might want to download a GitHub repo for this Workshop either use the QR code or just Google GitHub while we Dash IO workshop and you'll get it we also will need a Foundry for this Workshop if you have it great if you don't have it just install it using the link in this slide and then run two commands Foundry up and Forge build I know internet is pretty bad here and so for some reason you can't download it and install it uh don't worry uh the repository will stay up and you have access to it and I'll pause the slides tomorrow and I'll be doing some live Demas so you can just watch and get the idea what's going on uh let's jump right into it all right who has ever deployed here and written a smart contract please raise your hand okay who has ever run into the issue of a contract size limit here please raise your hands wow it's way more problem than effort so yeah this picture it illustrates my personal pain and why I work in baby on finance we pretty quickly ran at the issue of a contract size limit and it's not easy issue to address and it causes us a lot of pain and one file developer I know in a solution space called with limitation I quote bane of my existence so this is how big this problem is and we are going to talk about today so there is a few solutions for this well you can reduce byte code size using various techniques and essentially it's like alternative sport to guest golfing I called it byte code golfing I certainly do not recommend it because it's like a diminishing return Sport with each optimization you have like less and less space left for each new function and it even May compromise the security of your project so I would be very of using this technique and I suggest to try to design your architecture from Day Zero in the way it supports your contracts to be unlimited size uh other Solutions are external libraries static pre-compiled rotor and a dynamic rotor we'll cover them in this workshop and hopefully have some time for questions and discussions all right we're going to use a simple contract as a baseline contract for this Workshop it's called a counter it has a few functions a set function which sets a invariable to a new value a get functions which retrieves this variable and finally accounts functions which just adjusts a constant these are good functions for a baseline contract because they essentially utilize One S load operation One S store operation and returning the constant value and these examples are quite um well spread in real smart contracts all right um let's jump into the code here we have um our counter contract again I'm not going to spend any time on this it's a pretty basic what is important about it it's rather small so if we look at it byte code size you can see it's under one kilobyte which is great and we have a lot of space left but let's say a product team says oh actually we need to implement this new core feature quote quote function and call function is a function which returns just like big string which takes all the space and then if you look at this big modeler it like takes almost all the space in the contract with a few left and if we try to implement it in very new way using solution inheritance so we just okay for our counter the big modeler like done job done and then we discovered that no the counters over the size of the limit we can deploy it which nothing can be done it can be optimized so how we can solve it the first solution is external libraries external libraries is a is a feature of a solidity so how it works is that in your contract in your methods you just call a library instead of implementing it in the contract in this case we have a two libraries one is called storage leap which contains our original counter methods such as set get const and finally we have a quote Loop which contains the only quote method which contains this big string and if you look at the implementation details the catch here is that you need to pass this parameter which is canonically called self and has a storage type and this like a special syntax in solidity allows you to modify storage in external contract and essentially external libraries stability is just abstraction layer over delegate code and that's basically it is not much to this and if we go back to our presentation uh we can quickly sum up all the ups and downs this approach so the good part about it it comes with some security guarantees by solidity the main important one is the library can't call self-destruct so a library can't destroy your smart contract which is important because it's not the case if you use diligate code directly essentially proxies where if a proxy contract also distract your contract is done it's somewhat easy to add one more leap you can always reduce one more leap and it's gas efficient to a degree but a bit later on this and the main down downside so this is that it's not truly infinite because if we Define to add one more function you need like external wrapper function which stack up quite quickly and eventually you run out of space in your surface contract and it doesn't matter how many ellipse you can write more which is normal space and the final downside maybe for some projects external libraries can be used can support upgradable contracts so once you deploy your external libraries it's like set in stone and you can't change it okay the next approach is a static pre-compiled rotor this work was pioneered by Alejandro Santander from synthetics he also previously worked at open Zeppelin and he is known as a funeral out on Twitter and if you look at like if you want to take a look at production ready like stable code I suggest you check out hard hat router package at the synthetic zipper and what they're gonna take a look at the simplified example so so the idea um for the static router is pretty simple uh it's a smart contract which has no fun no external functions and it only has a fallback and receive functions and what it does it calls a forward function inside both of them and the forward function consists of two parts the lookup part for the implementation address and the assembly part for delete Jade call I'm not going to spend time on this I'm just going to say this is like a canonic implementation of a proxy Jade call in assembly which is used by all the proxies and what it does it basically sends your function code to whatever the implementation contract is and then returns its results and the interesting part is here so in solidity each function has a signature and as you can see here we have a switch for a signature method and based on the signature of a code function we pick up an implementation address which is later used for diligate call and as you can see here we have four functions registered for a counter modular which is a get set const and one function registered for a quote modular because it's like so big and based on a function signature we do pick up a right implementation address and then use it for delegate call and again if you go to our contract sizes why it works because these are three separate contracts we have a big modular which is within the limits then we have um counter modulator which is also in limits and finally uh static router itself is pretty small because it just with one function though the more functions you have the more its bite size grows because you have to add each function here as a new line though it grows way less than external libraries example and if we go back to slides we can see what are the benefits of using it it's extremely gas efficient why because it's all pre-compiled in byte code so you don't need to waste any expensive operations as HS load on the rotors so you don't um your different models do not so you don't um your different model is do not write to the same storage and then finally develop and maintenance overhead can be tricky because you need to pre-compute always signatures and addresses up front and you don't want to do it by hand which is I recommend check out again heart router they built a plugin which does that for you um well this like a second approach how you can achieve infinite size and compare to libraries it's like better in the way which gives you like more control using like assembly and low level language features the next idea is a duration on the static router it's not necessarily better not necessarily better it is a different approach it depends on your project I call it Dynamic router uh if you're interested in a product level better tested implementation of this idea I highly recommend you to check out Eep 2535 by Nick March um the vcp is covers far more things than just unlimited contract size but one thing it certainly does achieve is unlimited contract size through a dynamic router I've written a simplified example of this Dynamic router so let's get to it so we can see how it works it's quite similar to a static router in the same way it has a fallback currency functions which just forward every function Call to um to our forward function but the difference comes in this line if in a static router function we have a switch case which just goes or have this for easy which I have this address in a dynamic router we are using a smart contract storage mapping which is called modulus and using his as you can see here we pick up an implementation address using a message signature and then the rest of the limitation is function is the same we just provide uh with implementation to diligent call and essentially it works in the same way the essential difference between static routine Dynamic is the static router has all the signatures and all the implementations and races hardcoded in its byte code where Dynamic router use uh mapping on the storage of a smart contract to track them and that adds pluses and minus to this approach so the pluses is once you deploy your Dynamic router you can add more modulus even it's already deployed or you can like fix bugs by updating it here I have this function update modulus and it's also pretty straightforward as you can see we just iterate and add selectors to implementations the downside of this approach is you have to manage access rights you you can't allow anyone to update functions of your router that would be disasters a critical issue in security terms and there are different ways to use it you can use open Zeppelin access roles or some like other techniques but that's like out of the scope of this Workshop but you just have to keep this in mind and if we go back to presentation Dynamic router is the first router which is truly infinite because all the mappings between function signatures and implementations are inside the storage which is as we all know very big in solidity then you can literally add infinite amount of functions to this router so it's very good for a complex system which would require upgrades and have like long expected lifetime then another option another plus I just mentioned it can be updated anytime well I mean it can be a minus if you're getting hacked but generally it's a plus has no external functions so the main downside always is it's I guess expensive with function is essentially here is a regional storage which is extra s load which is about 2000 gas and the set part you have to pay it for every contract call and then another downside is you have to manage access rights who can update this router if you want to build a truly Unstoppable contract maybe you don't want to have any upgrades and them can be many solutions like governments and multi-seek but you eventually have to figure it out for yourself and um these are the three main approaches uh which you can use to tackle uh infinite size contracts and then what's like important what's the difference between infinite size contracts and normal contact business approach it comes down to a gas overheads essentially um here in this table we are campaigning our base contract with with three approaches in terms of gas and why gas is important uh like a short story when was like a bull run and guess prices were high we were seeing the the function calls for the users in the price ranges of one hundred dollars twenty two hundred dollars and even three hundred dollars for some projects and a lot of these gas costs were coming from using proxies because proxies has a gas overhead a dish function call and if you really have a complex defy system where protocols call each other and they all have there are all proxies with amount of overhead Stacks pretty heavily even within your own protocol and it's like important to keep an eye on this gas overhead course so let's dig down a bit in these numbers the first base contract are the numbers for our base course so it's like no delete code involved and then if you look at the base call for a constant call you just returns a number it's a very small and the first number in red is just what's the overhead and guess and the second number in red is in percentage and you can see for like a simple return call of a constant value the overhead is actually around two thousand percent which is like insane and you may say oh it's not practical you know to return a constant value but you'll be far from the truth because the famous ec20 token has a member a function called decimals which returns how many they came also talking has and you have to call this function if you define developer because in order to handle ec20 token you have to know how many decimals this token have and one of the most common uh uc20 tokens like usdc their approxy contracts so every time you call decimals you overpain roughly two thousand percent or probably more but anyway let's take a high level look at this approaches so as you can see indeed static router is the most gas efficient approach so if you have to build a gas efficient infinite contract and you are and you know what kind of functions you're going to have and don't plan to upgrade then it's like a great solution and then Dynamic router is make more expensive even more expensive than external Library um the reason I wouldn't recommend external Library as you can see it has unusually high overhead for quote more than double than it should and I think it has something to do with how solidity pass with such big amounts of data but I haven't dipped the byte code yet but just be wary if using external libraries and you pass or return big amounts of data then your gas expenses may surprise you and to take a look at this uh what would be the high level uh conclusions of this overview is that uh your gas overhead obviously is more significant for uh low for fractions which are low in gas essentially if your function has only a single s load then you would pay a lot of gas so what it means in Practical terms which I also encountered is that if you need to build a function which returns some like data around your protocol smart contract you may want to bulk them all this data in one function call so you don't need to call five functions in a row because you would pay a gas overheard on each call essentially batching view functions might be a good idea then again the bigger the Baseline as the guess is so important I spent some time thinking and trying to figure out the trick how we can improve this and I came up with solution which we use successfully in production to reduce the gas cost of our contracts I never found anyone using it somewhere on the Internet or on GitHub which is why um I had to coin the term for this approach so I'm going I'm calling it's like loaded router and so the approach is pretty simple because like if you go back to a static router so the static router in our case um it doesn't take much space and even it grows there's still a lot of space left and what you can do essentially is again using solution inheritance you can inherit some functions of your contact to a static router which allows them to be as guest efficient as the contract itself because it's essentially a contract itself so in other ways if there is some space in terms of byte code size left in your static router you can put the functions there which either people use the most in your system or the functions which has the highest gas overhead like calling decimals and this allows you to save quite a bit of gas because um just to give a bad explanation of this if you combine static router with a counter modular we don't get to this forward function because static router now is counter modular and that results in a quite significant gas savings and the same approach can be applied to Dynamic router I'm just gonna show you the call but it's a pretty uh straightforward you again can hit counter model but here this is the cage with a dynamic router because in Dynamic router we can update implementations of a function if you place a function like get a set on the router itself you will never be able to update it so that is why it's like rather risky and you should be very mindful which functions you put on Dynamic router because you don't want to be in a situation where a critical back is found in the function and you can't update it and it's just like a terrible situation to be in and with this approach we can crunch some guess numbers so now here we're using routers themselves as a base line and then the loaded version essentially as Improvement and as you would expect because we move a constant function from sitting behind the delegate call back on the router it results either to 95 Improvement or 97 Improvement for a constant function it results around 54 or 68 Improvement for a get function which is a single s load and singular slow function is not dead and common as you might think because for example ec20 balance of function is just a single s load and again this function is called a lot and I don't really expect it to be changed and then finally for a single s store operations uh the savings amount is about 11 or 18 so it's like not that much but like still sizeable and what you could you like looking at these numbers my suggestion would be is to move um logous function on the router if they use a lot so this is the most best saving or just the functions you expect uh user Fade to be user facing so the in the functions people will use the most again as a transfer function a deposit of withdrawal or claim reward and then finally the pure functions is just just a constant have the biggest impact on this foreign just to give you some practical meaning let's look take a look at the two most common uh contracts essentially you see 20 talking and here c721 which is an nft we can see surprisingly many functions of pc20 function 20 token such as name and symbol in decimals in most implementations they really return a constant you know just like name is like migrate token symbol is like three letters and decimal is like 18 number right and in most projects really with functions will never change and literally if you write in you'll see 20 token which has decimal functions which will return different values I might have a problem with you please let me know and um even going back even on later so total Supply many FC 20 tokens has a fixed total Supply right so with again no reason for this function to be upgradable or to be sitting behind the daily Jade call um and then things get tricky so I can see how transfer allowance or proof can be changed in the future maybe standards change but it's like up to every developer you have to make call on yourself whenever your project uh View encounter these issues in the future or not and um the same logic more or less applies to ec721 but these are just two common contracts I really wanted to show on them kind of logic I would fall if I would build a complex system where I would just sit down and look at my contracts and look at which methods are uh not going to change for sure in visual X save to put on the router itself to save the gas and which makes the most sense because for example at Babylon Finance we had this like admin model which had like a lot of admin functions but it's pretty much only us or governance we're calling them so we really didn't care about the gas cost of this so I was a confident just like putting them behind the diligent call and being upgradable and let's let's uh jump back to the code so here you would see once we put these functions on our routers they do grow in size so a loaded static router is slightly bigger than just a static router that's because we merged all these functions on this contract and eventually you hit the size of how many functions you can put on your router which we did and that is why you also should be like mindful that you have to put the functions on the router which like your absolute top priority in terms of gas so if it's like questionable don't do it and the same applies to Dynamic router so it's higher but to repeat secure my security you can see on concern once again [Music] um Dynamic router is a different from static router in that sense that if you put a function on router itself then it can be upgraded later and you should be like super careful doing this um the code uh the repo is already public and it has all these examples as well as the test which I just made which actually makes sure that all we discussed is worked so here you can see that creating static routers is simple because it has everything encoded in it while to create a dynamic router we need to build all these modules so we need to dynamically fetch all the selectors for the methods and then we create a model definition which is an array of selectors bind it to a certain implementation and finally we can use with modulus to initialize our Dynamic router with update modulus and this is the same way you can update existing functions or add new even after the deployment and here we have tests to make sure that all these functions work and if you will be checking out with report later you can run the following command test guest report to see all the guest numbers we just looked and speaking of these guess numbers um these numbers are produced on 0.8 solidity compiler with optimization set on and about 200 optimizations run on let's get back to our presentation and that will be it thank you for your time I hope you find it useful I hope you build unlimited contracts successfully and never experience the pain I did please follow my Twitter I do Post development stuff there and I would be honor it if there's any questions or discussions yes so the dynamic router whether it's sorry the loaded router whether it's dynamic or static it inherits from the counter module and then from either Dynamic router or static Road because the counter has the all the functions except for quote those function selectors will match to the functions on counter module and will never hit the switch statement on the static or the the rest if you were really doing this though would you not you would have you wouldn't have the dynamic module with the same functions uh defined as modules that would be hit and they would just be superseded by other function selectors because that's you would leave those off yeah yeah yeah just for our example though yeah I can tell you before in Workshop great yeah I didn't do it in my repo because I didn't want to just produce like more quality and to get in this optimization game because yes but yes it's like exactly correct so if you're making your order loaded then the functions you put in the rotor yourself you remove them either from the static part of the router or you never put them on the storage of a dynamic router because why do we need the same function twice yes anyone else yes the space yeah I mean uh both hard hat and the forge allow you to run different commands so the forge you can run Forge build sizes and it just shows you um sorry I mean the bite size well you can have as many modules as you want for either dynamic or static router but each of them is kept to the same size 24 kilobytes because it's still smart contract oh yeah it's a good question yeah so what I did in in our times is that maybe it's like wrong but it's a security hack I would just like delete everything inside the function and I see what how much it drops but it's fast and it works I don't know maybe with some automation right now but that's the truth okay anyone else I saw some hands yeah yeah I mean it's like with only one compiler right now and I mean I I'm grateful for features we have so I'm not gonna I'm not gonna go in these directions okay anyone else yes so for the users as I say unfortunately if you don't use like the loaded technique it gets its more gas expensive and then you should be you should like estimate how big is your main functions like let's say if your deposit function is really big like 200k then maybe you don't care about 5k overhead it's like nothing but I've seen some protocols which have like really small functions you know like just like claim my rewards right a small function but because it has overhead it made it more expensive for users but what is more important that you should like Define build your system from Day Zero understanding do you need infinite size or not because there's nothing more ugly than like building that not infinite and then you have to deploy extra extra contract and they call each other and in the end is the users who pay for that right so essentially if you need really big protocol you should go infinite size from Day Zero in the end it will be cheaper for the users but if you don't need it yeah just don't use it more questions uh not yet but I'll post on my Twitter tomorrow oh sorry uh yeah it's um it's a pretty Advanced topic the reason I decided to skip in this format you can get some ideas from synthetic hard hat package it has come good explanations but a quick answer is that it depends on what you do but the most gas efficient is there you have this sorts of mixing functions which are shared between modulus because uh essentially each module can access any part of the storage and what you what you what you don't want to do you don't want to call from one modular function of another module through the whole like routine uh process because it's a highly gets an efficient what you want is you want to break your fishes in that way that is kinda each model just like does its own thing it doesn't really need to call other modulus but even if it does it's better to use mixings where with some shared code which allows like gas cheap access well at least it's my position on this that you are saying thank you Lord yeah try to avoid it at all cost yes um I see someone yes please sorry yes it's truly infinite because again all the mappings between signatures and implementations are on the storage and selective storages pretty big you will first run out of money than anything trying to fill it out yeah I didn't do the math but solution storage is pretty big yeah well to be super energy precise no it's not truly infinite it is only as big as a leadership storage yeah all right if no more questions thank you everyone for coming it was super lovely [Applause] foreign thank you foreign [Music] thank you so much [Music] this is awesome thank you foreign foreign [Music] [Music] [Music] [Music] no no no no no no no no no no no no no no okay [Music] thank you thank you [Music] well um [Music] [Music] foreign [Music] thank you [Music] everybody [Music] [Music] [Applause] [Music] foreign [Music] [Music] [Music] thank you foreign [Music] thank you [Music] foreign [Music] [Music] [Music] [Music] [Music] [Music] foreign [Music] [Music] thank you [Music] [Music] thank you [Music] [Music] [Applause] [Music] [Applause] [Music] foreign [Applause] [Music] [Music] [Applause] [Music] [Applause] [Music] [Applause] foreign [Music] [Music] [Applause] [Music] foreign [Music] [Music] thank you foreign [Music] foreign [Music] [Music] thank you [Music] foreign [Music] [Music] [Music] thank you [Music] foreign [Music] foreign [Music] [Music] [Applause] okay buenos Tardes good afternoon hello everybody welcome to uh building blockchain products for unicep how to get involved um my name is Shane O'Connor and I am an innovation manager with unicef's office of innovation which is based in Stockholm in Sweden but I'm very happy to be here at devcom with you guys uh probably a lot of you know UNICEF as an organization you know you've heard of us you know what we do maybe it's not so clear exactly why and how we work with blockchain and Technologies in general so unicef's mandate is really to advocate for children's rights and to try and make sure that they achieve the best outcomes and make sure that their health education protection is is maximized across the world and UNICEF operates in about 190 countries around the world but UNICEF also has an office of innovation and within that office of innovation we have a ventures team and we have a a special team called Giga and we'll be hearing from them a little while go to the next slide so actually UNICEF has been working with blockchain since are looking at blockchain since about 2014 2015. um and UNICEF is one of the larger un organizations so big bureaucratic uh sometimes slow to move so um it takes us a long time to try and get UNICEF to move in this type of space and to get us up to speed on how to properly use the technology that's out there in the real world to support unicef's programming um uh in my own team that I work with the Venture fund we have been providing kind of seed funding to support what we call Frontier Technology Solutions that benefit children and the world and we have some people from a few of the companies that have benefited from that here in the room today but really from the slide there you'll see we're looking at the intersection of the needs of one billion people and 100 billion dollar Industries so we look at AI um drones 3D printing machine learning and also blockchain and cryptocurrency we've actually gone through three rounds of blockchain um funding cohorts we did our first cohort in about 2018 which was more of a kind of a thematic um call for submissions and you'll see that we had um submissions from Supply Chain Solutions digital certificates and badges impact investing we did a second cohort back in 2020 which was more focused on financial inclusion um and and that kind of particular not not so thematic but more focused um and some of the kind of products platforms and companies that came into that cohort were focused on humanitarian cash transfers remittances and decentralized decision-making tools we have a cohort that is about to be announced in the next one month or so and this is some of the our third cohort around blockchain um and you can see some of the um kind of solutions and companies that have been involved there and uh yeah I think we'll hopefully people can see those uh coming out pretty soon excellent uh this is really exciting and Santa is going to be giving a talk later on at about 5 40 uh on the uh the crypto phones I won't take too much of a thunder here uh but in 2019 uh UNICEF launched uh crypto fund and we were in fact the first UN agency to be able to receive hold and disperse cryptocurrencies so this is a a big big thing for the un uh and certainly a big big thing for Unicef and this has really been able to help us to build digital Solutions and particularly digital public goods to help us ensure kind of Equitable access to these Technologies and these tools to really try and support human development obviously through the lens of unicef's focus unicef's mandate on supporting children uh one of the new applications again new for Unicef new for un and using blockchain is uh cache based transfers both kind of in a development context supporting social protection schemes but also uh possibly more interesting in humanitarian situations so responding to disasters trying to get funding funds out to communities who've been affected and we're actually at the moment looking at blockchain for cash transfer where in fact I don't know if they're here in the room yet but we do have another cohort graduate that is supporting us Room San from Nepal but using blockchain for cash transfer to really increase transparency of these um processes so everyone can see the movement of the funds all the way to the beneficiary and this is interesting for us as a UN agency but also particularly interesting I think to donors too and of course saving costs compared to the traditional aspects for this um this particular space um UNICEF is also looking currently we're using blockchain to support the um the cash transfer programming it's not cryptocurrency at the moment it does get converted to Fiat but we are hopefully looking at um using pure crypto uh cash transfers early in 2023 I think it's what we're looking at um yeah next slide ah so now we're on to project giga so I'll introduce my colleague here thanks Shane [Applause] so my name is uh Herman I lead the blockchain work for Giga at UNICEF um gigas kind of like operates as a little startup within the office of innovation at UNICEF um we were started we started in 2019 um and we're sort of a joint venture between UNICEF and the itu the international telecommunications Union and our goal is to connect all the world schools to the Internet by the year 2030. um so we have quite a lot of work to do uh and we operate along sort of three uh pillars of work the first pillar is uh mapping uh believe it or not we actually don't know where all the schools in the world are so we're using machine learning uh algorithms to analyze satellite data and identify schools and actually help governments find all the schools in their country uh so that's always an interesting conversation with the Ministry of Education um the second pillar is about financing so we estimate that it's going to cost approximately 428 billion dollars to connect all the world schools to the internet which is quite a lot of money so we're really investigating uh like Innovative financing models uh to find sustainable ways to uh to make this happen so there's two types of expenses that uh we have to we have to solve for the first one is obviously sort of capital expenses you know putting fiber in the ground uh uh putting putting Towers up that sort of thing but the second is you know once you connect to school you have to pay for ongoing internet connectivity you all sort of have subscriptions to that that's kind of like how it works you have to pay your bills otherwise you get disconnected so we've got a team sort of focusing on on making that happen um and the third pillar is about actually connecting so we operate a team called the accelerate team where um we work with governments to investigate different kinds of business models for different kinds of scenarios you know schools in urban areas need a different solutions than schools in super rural areas so we work with governments to try to figure that out and advise them on sort of the best way to go um so that they at some point can take over the financing and the rollouts of these programs and do sustainably so like I said uh we launched in 2019 our goal is to connect all the world schools by 2030. uh so far we were joined by 90 countries um we have connected 5 300 schools we've mapped about 1.1 million out of an estimated 6.5 so there's still like quite a lot of work to do um and we were super happy to be joined by 14 partners that support us including Ericsson Dubai Keras musk Foundation uh dell recently joined which is a really big deal and we've raised about 210 million dollars uh towards his goal so as you can see we're still quite far off from the 428 billion required um so I'm gonna talk also today a little bit about some of the projects and the products that we're developing at Giga um so the first one is what we call gig accounts which is like a accounting platform and a sort of monitoring platform for the people who uh are actually controlling the money to pay for school internet connectivity so the way it usually uh happens is that um a country government or a UNICEF country office will write out a contract for like 100 Schools or a thousand schools in a country uh and have very little tools to be able to actually monitor whether this uh internet service is delivered uh so what we're developing is a way for them to make it super easy to monitor that so we um we have our own sort of real-time data uh application that schools can install on their on their networks and Report data back to us so that if data is subpar or connections get disconnected we can actually hold internet service providers accountable so that's uh that's our thing and what we're hoping to go with this is um right now the tools really sort of to support uh support these people in their in their their work but what will be really cool is to actually uh connect this with smart contracts and monitor whether internet quality is delivered and if it is automatically pay in 10 service providers so that comes super easy for people to uh to connect schools and to to get paid for that um the second product we're working on is uh called connectivity credits it's kind of um kind of similar to the carbon credit market so we're building a Global Marketplace for uh connectivity um to make the connection of schools sort of more Equitable so what's currently the case in the free market is that schools in rural areas get connected and the ones in urban in urban areas don't or if you're a school in the rainforest an internet service provider isn't gonna like lay a fiber optics cable there so what we're doing is we're um providing a marketplace where we put tokens on these difficult to connect schools and allow internet service providers to redeem these tokens for benefits from the government like for example tax breaks or special deals when uh bidding for uh Spectrum uh bandwidth and that sort of thing um so that's currently in progress in in Botswana and we're looking for other countries to uh to implement this um another area that we're investigating uh is nfts so we've launched uh in the beginning of this year uh the first uh first the largest I could say the largest sort of collection within the UN for this called Patchwork kingdoms uh it's based on all the school data that we have so for these 1.1 million map schools that we have uh we worked with a data uh artist data analytics artist to create these 1000 unique art pieces uh and raise funds for Giga so um we sold all of them raised about 700 uh thousand US dollars for that which is really cool and um looking to sort of build upon that uh with our follow-up collection uh currently title in progress called nft2 uh uh where we're basically uh looking to build the world's most comprehensive decentralized database of school data so the idea will be to create an entity for every single School in the world um give this nft for uh to the schools themselves to own and give them the ability together with their communities to edit the data for their school keep it up to date and and own this data themselves so right now it's sort of on our Cloud Server in Frankfurt uh sort of locked up uh and for for us to use but it'd be really cool if schools own their own data so that's where we're hoping to go with that so we're looking to use nfts as a sort of a portal into into making that happen and the last uh projects that were uh actually uh really Keen to talk about uh at this event it's like we're finally allowed to talk about this in public which is really cool is a staking experiment that we've been running uh in Rwanda so um we've been working uh with the ethereum foundation and the the government of Rwanda to create an impact investing product uh using ethereum staking to pay for school connectivity so that's um currently live and uh we'll also be talking about that more in the panel discussion on Thursday if people are interested I think that's it and then I'll hand over ah there's one more so I mean Rome wasn't built in a day uh and these products aren't either uh we're still you know iterating on these uh so we're asking you guys uh do you want to help us build um so Antonio Gutierrez um yeah mentioned us at the previous sort of uh General Assembly so there's really sort of been a global call now for governments to step up and uh and and help with this help with this course uh now I'll introduce you to my colleague thanks everyone yeah [Applause] to finish with the with the talk before we go into breaking sessions is that we we cannot do this alone we are relatively a fairly small team compared to all the things that we do and all the products that we are building so we work with companies with people on different ways uh one one is that we have a tech team an internal Tech Team of program product managers data scientists software developers and we are continuously searching for that so if you are interested in joining our team keep an eye in our website because you have different jobs that go out there at the moment we have one for a blockchain developer that's open I think it's going to be open for another week or so so if yeah if either you're interested you know anyone that might be interested please spread the word there will be another one for a blockchain product manager Road as well that will be coming out soon and others will keep coming out so definitely keep an eye on that and and apply we also especially for blockchain work because many of the things that Urban was presenting are shown you and they are experiments and prototypes that we are building we work with external companies and with vendors to to build them and then we take them and we scale them internally but we first work with companies to to build them so again if you are a company that's working in the blockchain space either on the nft space staking tokens and and others and you are interested in working with us there will be again few calls for companies to apply to help us build the things that Urban was presenting so there will be a one call to help us build this nft2 that doesn't have a name yet so we'll be working with a company too to build that the same for the accounting platform that he presented kik account we have a working prototype at the moment we'll again be looking for a company to help us build the next version of that and test it pilot it in couple of countries is so again if you are in that space of smart contracts Etc feel free to apply and then the last one that will also shortly be coming out it's on the connectivity credits we are building that at the moment in Botswana about looking to Pilot it in couple of other countries so there will be another call looking for companies to build that a token Marketplace for for connectivity and then uh yeah I think those are the main course that will be coming out of course then we also work with companies as partners so not so much Contracting them but we work with companies like that they must plan well that's not a company but the mass Foundation Erikson IHS towers as partners where these these companies give in-kind contributions either funding monetary but also sometimes they give us tech support either through their developers through their team so again if you are interested in helping out every child to us and they'll find Ali at the last one it's the Venture fund so if you are a startup in the blockchain space there are continuous course that are coming out for that there will be one that will go out soon around climate Tech Solutions so if again you are building something on that uh 20th of October it's coming up so so again that will be out and it's an investment of one hundred thousand hundred thousand dollars more or less with that I would also encourage you to check this QR code so that you can register like that you can also keep you in the loop and if we have something that we also think that might be relevant to you we can keep you in our Network and reach out to you um yeah I think that's it I don't yeah yeah so for the yeah for the rest of the time we'll be standing each of us in one of the corners so you can come to us if you have any follow-up questions and we'll we'll answer them and we'll tell you more about the work that we do uh [Applause] thank you foreign [Music] [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] foreign [Music] [Music] foreign [Music] [Music] foreign [Music] [Music] [Music] thank you foreign [Music] [Music] [Music] [Music] thank you [Music] [Music] foreign [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] [Music] foreign [Music] foreign foreign foreign foreign foreign foreign foreign foreign foreign foreign foreign foreign foreign foreign foreign foreign thank you foreign foreign foreign thank you thank you foreign foreign foreign [Music] [Music] foreign [Music] [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] foreign [Music] foreign [Music] foreign [Music] [Music] foreign [Music] [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] foreign [Music] [Music] foreign [Music] thank you [Music] foreign [Music] [Music] foreign [Applause] [Music] see the ground [Music] foreign [Music] [Music] [Music] I love you baby [Music] everything is too much [Music] [Music] thank you [Music] thank you [Music] foreign [Music] [Music] [Music] [Music] thank you [Music] good afternoon [Music] thank you [Music] thank you [Music] thank you [Music] thank you [Music] foreign [Music] [Music] of polygon but before that we were working on the roll up that was a basically a Decay roll up that you can only transfer tokens and ether so basically what we will do is like we'll introduce you the this project this general knowledge project that was done in tircom and then we we make a little project interacting with Hermes basically well you will see basically you prove that if you made more than 10 transactions in RMS you will get an nft and all of these is proven by circum and basically is the project that we will explain to introduce you so let's start specific language for building zero knowledge proof right so basically what you want is like you you have some kind of models kind of problem that you want to solve yeah you want to express this in arithmetic constraints that is what will be the job of the turcom for sure then using some tools and in our cases there's an RCS who you you will convert these arithmetic constraints in polynomial identities that at the end you will have a cryptographic Brewing System that is what you want at the end you want to have some input and some witness create some proof and then have some kind of verifier in ethereum right and with approve and an input uh see that the verifier is able to accept or resect the proof so I as I say before as you see here like circum will be at my specific language and basically will be uh when you have some kind of model you write this model of this problem in Silicon language with a DSL description and then with the Silicon compiler you will get the arithmetic constraints later on you can do it the verifying system and we see before so for a quick example I don't know if you see any zero knowledge stuff but it's always the Fibonacci example so once again uh we have the multiplicative one so it's like the same as Fibonacci but the numbers instead of summing uh you multiply them basically one is the series of Fibonacci so as we see here we see a little example um basically I will explain a little bit What's Happening Here the here we have a template that that's how to use the finest circuit and silicon template and then you have a inputs as a signals uh and by default the signals are private if you don't uh if you don't Define it afterwards you will see this weather in the example that we did and we have an output that way the fold is public basically what it does is circuit is like Computing the femininity multiplicative and put it all the values in the EM that is intermediate signal as you see in the line seven and at the end we like assert we put a constraint that the one of the uh one of the values of this multiplicative Fibonacci series is put it on the output signal and and bottom up we see that we Define a component Main and basically how it works field commas you can create like multiple templates we see this afterwards but you calculate like multiple templates let's say it's like there are little circuits that you can connect them all together in order to make it more modular and at the end you have to have a main component that starts the that is where the input will start right that will connect with the circuits that you defined before so as a simple how to use steelcom basically you have to write a circum circuit that we seen before the first you compile it and you can see the link the constraints and whatever once you compile it you have the circuit compiler and the everyone CS constraint that it's what we see before that are the arithmetization of the circuit that is what we needed for for the for for make approver afterwards then you can generate a witness once you compile the circuit that basically all the intermediated values that you need for afterwards create approve and basically is what we see here in the schema well this is I will I will get this pretty quickly is I say before silicon is a very modular language you can create like templates as we see before and you can in the correct template so it is very useful for example we have template for verify an American proof and you can just use it like connect them connecting with the miracle proof and use it the output for very fine things right so it's easy to audit and easy to write a larger circuit and this is like a full schema of everything let's see how it starts so uh what I see I say before you have a silicon program and you compile it and you have the the constraint system then what you will need let's go to the here you will need a verification key and approving key in order to do this you need like to do I don't know if you know but you need to do some kind of a trusted ceremony and depending on if you are using a one proven system or another 16 or plunk you need to do a trusted ceremony for every circuit in Clash of group 16 or in case of loan you have one universal trusted one universal ceremony that is multiple computation the point is you have some kind of computations to create a trust uh you have like some distributed compute um distributed computation to create a proving key and a verification key and this is what uh we'll have basically the verifier and approver and down here we can see that uh we have an input and with the silicon and a circuit compiler and with this we can create the weakness that basically is already intermediate um signals and basically with this we can end up creating a proof surely because this is a lot of doing things but I think with an example will will be more clear Maybe and this is the state of the art and how the like DSL language like circum is are going around as you see but still come is one of the most used right now and now Carlos will explain a little bit however mesh works and how is and how when how it works yes foreign there is a tool that you can use is a web app that you can use in order to play around a little bit with a circum so you don't need to start anything to just go enter and then according to the computer it compiles so you can play around with it a little bit okay so uh what we're going to do is a circuit in order to prove that a certain account has a not has made more than 10 transactions in their Metro Lab okay for that purpose at the very beginning I want to explain a little bit um what is uh the Hermetic circuit uh probably you will already know that but basically are a lot was like you make a transaction in Layer Two okay so there is a coordinator that gets all these transactions it Aggregates the all these transactions in a batch and from this batch you uh the coordinator is that the entity that gets all the transactions it accumulated transactions and basically it makes approves that uh verifies the correctness of these transactions in one single layer one transaction okay this is why it is called roll up basically now I will focus a little bit on the Miracle tree that we use and the parameters that are inside in the state ring so it will be very useful for later on in order to go to Circuit that we're going to code okay first of all I just this is just an schema of all the secrets that are involved in the air method lab as you can see that a lot of them um you can check the repository in order to see all the fieldcom language that uh all the work that has been done over there we will focus here in the last one which is the hash state and this is how the Stray state tree looks like but you can see um when we the account that we are we add into the state tree it has different parameters one of them is of course ethereum address second one is the baby top tab you have a balance you have a token ID and you have a nouns okay this is very important and how you compute the hash of the state okay so basically when you add a leaf into the miracle tree you need a key value so the key is an index which will be enforced by your smart contract and it will be incrementally okay in order to not have a lot of levels in the medical tree and we need also the state the value so so we need to Hash the state in order to hesitate so basically we just hash with position for field elements the first film the first filterment contains the token ID the nouns and the sign you can notice here that the dominatry has three little bits the nodes has 40 bits and the same has one bit the second element is the balance the third element is a coordinate of the baby top Tab and the fourth element is the theorem address I think it's worth to mention that I showed previously the baby tap tap here is divided into the sign and the y coordinate okay Okay so you already know how to Hash the state of the Metro Lab so what we are going to do now is to so get hands a little bit dirty so we are just going to code the secret from scratch it's a small circuit not so difficult so let's grab your computer and let's go it a little bit okay [Music] perfect could you hear me well nice Okay so let's start so basically I will create a file okay that I will name it uh depcom Workshop dot film so the first thing to do is to specify uh which version of philcom are we going to use okay yeah it's better like this more yeah okay nice so what we're going to do now so in that case we are just taking the token ID the nodes and the sign we are building the element zero and then we are putting the balance into the element one we'll put in the y coordinate into the element two we are putting the acetylene address into the elementary we are performing a position hash and at the very end in return what we will have we will have the value okay and this value will be inserted in the smt verifier okay so first thing to do what we want to assure now so we need to assure that this account has been done more than 10 transactions okay in order to do that we are going to set up a variable over here and we are going to the final component I will name in Minot for example we'll do the greater than we will comparing all possible bits between them and this component you can check the component by as I did right now just by opening the hash State component and see what is going on inside you can do the same entering in the circum leak in circuiting operators and seeing which are the inputs and the outputs of the regulator so but those are quite simple I would say because there is just two input up okay and one up okay so basically we are comparing the nouns and the Min nodes okay and the output basically you can reference it as and here we are just setting a constraint so these are like a a very important constraint for this circuit because it basically assures that the nodes that you will be used in the smt verifier indeed needs to be more than okay so now what we're going to do is to use the template of the smt amplifier but before that we need to Hash the state so we are going to do first is to reference another component which is this one it's the hash state wait I'm sorry perfect so I'm this component you may see that the inputs are definitely non-signed balance uh ethereum address and the Y coordinator so basically what I'm doing here okay thank you I'm just setting up all the inputs that I declared at the very beginning of the circuit I'm just inserting them okay into the component and the output and the output will be the value of the state okay so here comes the norms here comes the sign here comes the pollens okay comes the Y and if you're constant ethereum monitors okay so now we have the value of the state so perfect so what we're going to do now is to prove I mean with the smt verifier as I mentioned before we are just providing the route providing the siblings providing the index providing the value and this component they basically will verify that the siblings provided and the value corresponds to that truth okay as I mentioned previously I have done this circuit uh before I don't remember all the smt verifier inputs and outputs so I will just copy paste and the other ones uh are a little bit easier than this one but this one datable tricky but well basically uh here I'm declaring the smt verify component with with and leveled plus one uh there is a signal which is enabled which is basically the constraint will be I mean it's equal or zero the the sorry there is an input signal which is the enabled in order to use the smt amplifier the functionality the simplifier has different functionalities which is could be um adding a leaf the letting a leaf updating a leaf so in that case if we put a zero here it will be basically uh uh no this is the smt professor so regarding the center verifier the zero is just verifying that as I said previously the road will match all the siblings so here is the root which is the public into the I declared at the very beginning of the circuit uh we are setting up here all the siblings okay this to sign notes no sorry these three signals are not used for this uh circuit so we are just setting to zero and this is very important the key and the value of the medical tree so basically the key will be the index and the value will be the hash of the state okay that I um calculate over here okay now I notice that I just renaming this component okay thank you foreign 15 minutes that basically proves that a certain account belongs to the state tree and assures that this account has been done more than 10 transactions okay simple as that I mean it's that it's a super small circuit okay and it's very easy to call to code it I mean of course you you need to you need to check the components that you are using the comparators the smt verifier probably is the most complex one but it's it's not that hard at the art it's super easy and everyone can read it that's also the the beauty of VidCon okay so what we are going to explain now basically is what to do now you know with this circuit uh basically what we're going to explain because we're going to explain it basically what we're going to do is to generate all the trusted setup and we are going to generate the verifier we're going to see the smart contracts are we are going to perform some tests in order to see that everything works fine okay so Maybe okay I will get get away from these okay so uh well basically what we will doing now like now now that do we already have a circuit uh the the first thing that we have to do is like uh combine the circuit and maybe I should run the script well it will take a while but maybe I I could run it until we explain it so basically what we are doing here is like executing all of these commands with uh basically with the XX Inc uh if you are more interested into details you can check in the silicon.20 documentation basically we're following this but we are in here is basically first compiling the circuit and then when we have the constraints what we need now is I don't know if you remember before in the schema but we need um you need a verification key right we need a approving key verification key in order to to make the proven system so in order to do that basically what we are doing here is like a multi a multi-party computation that we Market ourselves because this is not a serious project this is just a like a workshop project but this will be like the central decentralizer this will be done in a multi-party computation but in this case we just donate that all sets right so basically what it's coming here is like uh we create a new powers of Tau uh we continue we have some entropy that is tools then we prepare the phase two and then we make another contribution and basically at the end we end up with a with a key that it basically is a the verification key that we need with this key we can generate the verifier of the solidity and also we can basically we can generate the the groups to to send to the smart contract right so basically all of this is just for getting the the compiler circuit and the key so I don't know how much it will take like it will take that long but I don't think it's like a it's able to just wait I will continue to explain it at the end you end up with this key with this key and with one one file there's a key and one file there's a the compiler circuit and with this you can like do whatever you want right like create a export the verifier that is this contract that is created automatically and then basically you can like start interacting with this uh so um once we have when we run the script that it will take so much so so long and we get the verifier and what we can do now so remember that uh in our in our circuit uh let's find this a little bit this one right we have three public inputs so we have the root right the index and the other address so uh somehow we must to take this with the remote contract now we will see the smart contract and see how how we interact with this but basically as you see we have three inputs right so the verifier as we can see basically these are some internal functions and basically what the the all the function that we want is like the verify proof right this is basically verified with a function that we take from input the like the proofs and then public input and we'll and we'll return either true if the proof goes well or fast if the proof wasn't right so as we see the array of input S3 because we have three public inputs the root the index and the three mattress so let's build a smart contract to get along with this so I don't know if you are like you you know a lot of Solitaire law I will make like a just a quick overview and that's it basically we are we are like presenting everybody that wants to interact with this and nft so and using the open tapping nft library and basically that's it and then you need at least one private input but yes but the private inputs are not in the let's say I'm not in the input when you you see input in the verifier in the you are talking about the Solarity verifier contract right when you see the input you only pass there the public inputs are public then anyone can generate definitely um yeah let's get back to it maybe in sitcom uh 2.0 when you define the main component there you are the family which are the first of the ones are private so in the smart contract you only pass it the public ones yes sir thank you no so uh okay so basically we will be an FD I use a nft library and while it's important here is like we said before we need a snapshot of the Hermes so an air mass Miracle root uh an address of the verifier in order to call the verify function and an only fire in order to not let people to take like 100 nfts with the same proof right so basically is what I'm saying here the the Constructor basically said the FC 721 with a parameter that token name token symbol and we set the root and the second verifier and then we have like the all the function that is important that is a climber Ms nft that's basically what it says is you you pass as an input an index and and the proof that you want to and the proof of the zero knowledge basically it says if you already claim it and then it calls the verifier which is the contact verifier that we see for with the proof and this is the public input as we see we have the the merger root the index that you want there will be one and the message sender this is done because like uh to note that you cannot claim like another nft that you don't not own right it is how you you secure that only the message sender can claim his own entities and basically this will call the the verifier uh if all goes good the proof will be will be will be receiving correct and the Notifier will be set to true and you will get your nft so you do have questions about this or someone like when you deploy this kind of systems you'll always deploy uh this this contract that basically is like a library right and it's just very fireproof and then you create a contract that that interacts with it right in this case you verify the proof is it correct means you understand okay so uh in order to do a flow we do a test and I think I will get a pretty that is not this one is this one uh that I will do a very quick overview basically what we are doing is like using or Irma as a library so maybe it gets a little bit confusing but anyway I will explain I I will do a quick review and I think yeah you will understand so first we create three accounts basically and then there's a function that creates a new state that basically what we are doing is like creating the Merkel root right we created this state that we want to check against so what we are doing here is like creating two accounts and then doing Trend transactions from account 1 to account two basically we do this we could remember that we need that the nodes of any account needs 10 or more in order to be able to generate a bulletproof and claim the nft so uh somehow we we managed to somehow we managed to create the the state with the 10 with the with this account and one of them will have like a non-stand so we can claim the nft so afterwards uh basically what we are doing but this is I don't know if you're familiar with but basically we are deploying the verifier and then the player the cki drop that is a the contract that we made uh and then basically this is the and then we start a test and basically this is the input right as we see here uh we have uh we have a lot of inputs uh some of them will be private and some of them will be public and we will check against a smart contract right uh so we create an input and we create the snaps.js library that basically is the the library that allows us to create the proofs and basically we pass an input and the directory of the circuit go pilot that is this one and the directory of the verification key that is this one and with this we are able to generate the proof and with the proof where we are able to basically connect the you the user that has this address and be able to clean the nft with the flow input and I can run the test it's worked easy I will run all the tests Maybe it's well I don't know if you I mean it has been able to open test sorry being able to like do what they like take the report don't want the repo but uh and and well since here right since here we got the demo so this basically we will eat you can take the repository you have any questions don't hesitate and that's it thank you understand the board of towel ceremony yeah so as I say before I wanna at the end of the talk like depending on the Brewing System that you're using if you use plonk you can reuse the the ceremony if you use a growth 16 you have to like one of the part of the ceremony it is like you have to do it for every circuit you have to so in this case because we use secret 16 we have to like make a multiple computation for every circuit it should in the presentation I'm sorry if you don't get it here maybe we could start with that right thank you sorry ah we have more one more slide yeah we have a thank you slides all right foreign [Applause] so thank you so much thank you [Music] [Music] thank you [Music] thank you [Music] thank you foreign foreign [Music] [Music] foreign [Music] thank you [Music] foreign [Applause] [Music] you know [Music] [Music] foreign [Music] [Music] [Music] thank you foreign [Music] foreign [Music] [Music] [Music] [Music] thank you [Music] thank you [Music] thank you [Music] thank you [Music] [Music] thank you [Music] foreign [Music] [Applause] [Music] foreign [Music] [Music] foreign [Music] [Music] [Music] welcome back [Music] [Music] [Music] [Music] foreign [Music] [Music] thank you [Music] thank you foreign [Music] [Music] foreign [Music] [Music] [Music] thank you [Music] thank you [Music] thank you thank you [Music] foreign [Music] thank you [Music] thank you [Music] foreign [Music] foreign [Music] thank you [Music] [Music] thank you nice it's working that's so loud I hope everyone hears me so hola and Welcome to our Workshop um about running the beacon chain Explorer on your own um we will go through how we came to the idea to make the beginning chain Explorer and then we will explain how we how you can actually run the Pickens Explorer we this is Stefan my colleague and me Patrick we both work for the company bitfly so yeah first we are Stefan will introduce you to our company and how we actually came to the idea to make an explorator for the next stage of the ethereum project then we go briefly into the through the architecture of the project and finally we will show how you can run the Explorer on your own but before we start with anything everyone who everyone who wants to participate like interactively we need you sorry I was on the wrong laptop yeah we will go first to how we came to the beginning expert and um what what the architecture of the project look looks like and finally we will show you how you run the Explorer but before we go to anything we need your anyone who wants to participate we need you to to download a few things so are there any anyone who wants to participate on this laptop um do you have install Docker and talker compose if you if you don't if you don't it's like a one-liner yeah and you need to clone this this Repository so can you basically try and see if you can access the repository if we made it public or not then I'll quickly we'll jump back to that and I'll quickly introduce um kind of who we are a bit more in detail so um the company bitfly was founded 2017 and we've done a range of products um the we've been basically active since the beginning of ethereum in the space we actually created one of the first log explorers but kind of let it slack a bit so that was etherchain.org it's one of the older ones and then later on we kind of regretted not putting more effort into that Explorer and then we kind of decided now that there's uh gonna be ethereum 2.0 or um basically the merge we decided to create another Explorer specifically for phase zero and that Explorer kind of ended up being the beacon chain Explorer and it started out where everyone could basically see all the information about the beacon chain uh maybe you saw of hands who has used the Explorer before maybe just to kind of get a feel so about half of the the people have used to explore before so maybe if you want to show off hand who's running a validator okay quite quite a few of the people that are using it so basically we we wanted to create a nice place for you to understand what's actually going on with the validator uh to see the different states of the validator to kind of make sure you don't get slashed and we also operated uh one of the bigger mining pools called ethermine.org that was now retired since the merge and we kind of shifted away from mining a bit and focusing we're focusing a bit more on staking so kind of to shill a bit our other products we have staking.ethermine.org now where you can stake with less than 32 each and we have eat pool if you're too lazy to run your own validator you can just upload your validator key and we'll kind of take care of that for you um uh and then a brief history I kind of already touched on that so um it started out in 2019 end of 2019 with the first test networks so even before um the Genesis of the beacon chain here you can see a small or kind of nice picture of the Genesis event we kind of created like a slot view so each one of those rows if you don't know is an EPO and in one Epoch there are 32 slots and here you can kind of see the green part is when it was proposed the red one is when it's missed and the yellow is if it's orphaned and that's kind of a nice overview of the first few epochs when the Genesis happened and we also have like a checklist below how much finalization we have uh no our participation we have and if the EPO has Justified and finalized and a nice rocket for like the countdown when Genesis started which is also pretty pretty nice so that's kind of uh how how this whole project began and it kind of exploded a bit more and more and with the merge we uh tried to add more information not just um the phase zero information and it kind of grew and grew and this presentation will also be kind of about how we kind of handled the scale and also give a kind of a workshop where you can help us with with kind of finding ways to scale better um yeah so let's go a bit to the architecture so in the beginning this is kind of a very simple view what uh the beacon chain Explorer looked like I also presented this a similar slide I think it was etcc uh a year ago where we had just the prism node we had infuro node and the funeral node was mainly to get the deposit data from East one and then we had an exporter that just basically wrote everything into postgres database and that worked really well in the beginning it was really easy to work on and then we just had a golang front end with some templates that kind of served everything to the end user and even when I presented it back then we kind of can see that prism already needed like a 576 uh 67 gigabytes of data Erica node already 1.4 terabytes and cause postgres already two terabytes of data and then I looked at these numbers again how it's running today and kind of the reason why we had to scale little bit more so the numbers now are that we switched to Lighthouse and we have a 32 slot sync so there's different kind of sync versions that you can choose and depending on what amount of starts you choose the more information is stored but the quicker you can retrieve information and we basically want to store everything and that's already a five terabyte disk that you need for that Lighthouse then Aragon is 2.1 and our postgres database is huge so uh kind of the tables and the indexes that we have in the postgres database they just don't scale that well so it's already 10 terabytes big and we don't only run the mainnet we also run the test net and the test net is just that amount and even a bit more for different test Nets so it's a huge amount of data and it's getting a bit expensive running that in the cloud so we're going to talk about how we kind of started migrating away from that um and basically the the scaling challenges uh during the merge so this is kind of a analytics view that we had so we had um concurrent sessions of 2267 uh people that were looking during the merge because we had like this nice slot view that you saw before where people could see okay during the transition um what was happening uh it was a nice visual way of kind of tracking it and we had a lot of people um we kind of were kind of prepared so you have this Super Mario mushroom that should power you up but that mushroom was kind of overpowered by the people looking at it because uh the way the architecture was designed it just didn't scale well we have front-end instances that kind of have to query the same stuff like if we have five front-end instances they do five times the same queries because we don't just have like one layer that updates our cache we just have every front and instance that has its own cache so these are things we kind of try to try to improve and then again we have very expensive indexing as well in bigtable and big I know a big table that's going to get to later in past Chris and pascals also has to get a lot of the table into memory to be able to query stuff um which is a lot of the times not very efficient especially with huge amount of data um and um so what we try to do is we have we started out with one big binary where everything runs and we try to strip away things from that big binary and kind of isolate that in microservices that not every binary does everything and if we duplicate one binder we don't do uh unnecessary work um and kind of the migration is kind of a bit challenging for us because then we have to kind of make sure that we manage a lot of the technical depth that we uh kind of have and are maybe adding through changing Technologies um so maybe we can jump back to the beginning of the does it work now yeah it works here okay maybe you want to should be public now foreign maybe say if they can access the repository yeah you have to enters the docker file in the docker compose file in it and if you just run Docker com uh Toko compose tool it will pull all the images and when we later get to an interactive part everything will be done so we have all these things ready perfect yeah some things yeah okay great I hope the internet is good let's pray a bit because uh when we tried it or tested it before uh it took a while so um here you can see I kind of touched on that um the scaling and large table so in postgres in the beginning we didn't have any partitioning uh at all so later on when oh yeah two people um foreign thank you um foreign minutes foreign thank you thank you [Music] all right thank you happens so guys if you wanna submit something I guess five minutes to uh to draw something up otherwise we're gonna continue um [Music] foreign so I think everyone is finished now someone is still writing outside yeah thank you [Music] foreign so if anyone is is ready and wants to present in front you can do it or we We Gather the papers and and just read it you guys want to present I mean yeah let's go let's go for it it's perfect yeah it's gonna be fine okay um should we present General you can just maybe hold I can hold it up and you can baby um again lots of assumptions that we made without knowing too much of the spec or or your uh specific use case let's go so Cloud first I think still makes sense especially for like the Dos or whatever you guys might need that for in terms of front end I don't know if this is a bottleneck but we mentioned a thought about clustering or some Auto skill for this or even if we're going to the web 3 ethos of let's put this on ipfs or like distribute it somehow um and merely make it un undeniable Service uh scaling that way or it could be just some some Auto Skilling surf Some Cloud run or gcp or whatever I use for that so I don't think this would be the bottleneck anyways the front end itself I think that and if depending on what you have here this could be heavily statically generated so it might be something that you wouldn't be a problem then uh second layer we're talking about cash so I imagine most people are our team imagines that most people are looking at past data so you probably don't have to have uh direct access to the database you don't have to do like real queries against it you like cash heavily previous data that was already from previous blocks that will never change so things that could be like pretty much Frozen there because it's not it's really static and and and and stale deal it's called like that um so this depending I guess there's probably lots of ways of getting this catch layer this could be like a DB level this could be some like redis cash flow or something like that but yeah really really something before the database itself then on database um our friend I forgot his name but our friend there gave idea of maybe we could start sharding this maybe some sharding based on transaction hash or something like that which um same thing since this is mostly data that will live forever and not touch it again we probably have a part that's only read only so it's there um very high output for reads uh not that much in terms of Rights and a part which will be the right part which this part here would have uh more direct access to the actual nodes and then the nodes um probably make sense to have multiple archive nodes if if the RPC calls might be a problem I don't know if it makes sense to have lots of different machines running those instead of infuria inferior for us in our company is always a problem and for now if there's anyone from these companies talk to me please but um yeah maybe just run your own archive notes for these not sure also if the actual RPC calls are a a bottlenecks no it's good to have a backup okay so at least yeah maybe to like archive knows you guys are going to run for that um and then this part here would just be like the heavy right part which everything that you you check as a new you will just update database based on that thanks so much okay thanks for participating [Applause] I'm gonna hang that up okay so um this is the solution we came up with so we switch kind of the solution we have right now yeah this is the solution we have right now with which we part of the of the of the of the data set we now store and pick table instead of impulse quests so we thought like it's not really necessary to have a relational database for this kind of data set and bigtable scales really well so I think that we we were able to to indexed uh all of the current uh each one transactions uh in five hours so it's like really it scales really well depictable so we now store the blocks the balances of the validators every transaction all of the attestations in bigtable um and this resulted in a really much more stable um in index time so now you can see it takes us like really Stables 30 seconds to export all the data of one epoch yeah this is where we come to the interactive part of this of this Workshop um for everyone who wants to participate hmm I think it's like two or maybe three um good night so he's just resetting everything he's done to kind of start fresh with you guys so the first thing we we want to do is to initialize the databases so we turn on postgres where it is in Peak table and initialize the the post press tables and picked the big table uh what is called tables database so the next thing we want to do is to start it one indexer we called it that because we're not really creative but it indexes like I think it it first um gets the blocks from the execution glands and encoded in protopath and stories into big table encoded in protobuf and then we index as after that we indexed the blocks with all the the fields and values and then transaction as well so one one big thing is like we're actually not using bigtable from from Google chart we are using a big table emulator emulator from the company PT thank you it just emulates the the peak table API and stores it in sqlite database and I think like for for just storing and then analyzing the data it works well it's not like it will not scale for uh for a thousand requests per second but for analyzing the data it's a like a really good solution solution in our opinion so the the thing here is we are not able to to reach the nodes we we think before the the workshop in the cloud somehow we don't get access we have this python so we are now running the nodes on our laptops and that is where you see some errors because the nodes are not synced and it it's not like doesn't work well but tonight so now we have the databases and date one index around me the next thing we want to run is the exporter the exporter is like truster and the export we had before the merge but now it will index the the blocks from the from the from the big table that we just exported in the in the 81 induction again we have some errors because the nodes are not synced the next thing is like the the statistics module module and this is also a really important uh and integral part of the whole project because the indexer will aggregate the data of one day and store the aggregated data of the one of of one Beacon chain there in the database and so it all the queries become much faster the last thing we start is deflantern and we'll get started with the with the cache updater and then the front-end itself which is a calling web server which just queries all the databases so all the things are running now and we can browse the content Explorer on localhost 8080 the thing is since the nodes are not synced um it will take some time until any data will show up um one there's some extra extra scripts we we wrote in into the into the into the main script um the thing is like we we understand like this repository not as we want to to to make it the big change for available for everyone who wants to to explore the big engine not so you don't have to trust us by going to Beacon chain uh we can we can change Beacon that in between dot in you can run it yourself it will take some time until it's like synced and we will we will try to make it more easy but the thing is we really um what I'm saying We Stand by the decision to make the secure open source so it's not we will we will try to to make it available for everyone it's not like we made the decision to go into bigtable from from Google and to run it in gcp just to to make the scaling issue like gone but that doesn't mean it's it's not available for everyone thanks to such amazing open source projects like from bitly the gcp emulator so the last script is now you have like a postgres database where you can think with the data we made just some hmm the script is not uploaded no it is yeah okay okay let's restart the services I don't know if I want to do that has anyone followed a lot is anyone following along is it working okay it's working yeah ah yeah okay okay okay yeah so so the thing is like a repository we show really how you can set up the text wrong and we we know it's not like there's a lot of technical technical tip that is like we need to solve it but it it's working for everyone not just for those who have really gcp account and everything um I think we can go to the next slide yeah okay so for anyone using um our mobile app or the website we've got a discount code Bogota 50 if you want to use it you can get our Premium app Services uh if you have a lot of validators it's nice uh among other things or if you want to use our API Services you can use the code over the website not directly over the mobile um and yeah if you're running a validator the mobile and you don't know about the mobile app it's pretty nice it lets you look at your validators on the go it lets you get notifications when you propose a Blog um and kind of see if you've gotten uh those 30 East block Rewards or something like that um yeah okay then um yeah if you want to contribute um here's kind of the overview um of kind of the resources so um we have a Bitcoin Grant that's linked below uh you can tweet at Peak and chain if you see any issues or something create issues uh on the GitHub repository that's also linked there um and oh did anyone still want to take a picture or no thanks yeah that's basically it from us thanks so much for participating and listening if you have any questions Maybe um yours right now that you purchase uh sepolya it's called so it's one of the test Nets it's a bit smaller so it should be able to think in a reasonable amount of amount of time the Wi-Fi isn't the best here so here it could take a while but it's a lot smaller than prata or which is girly or mainnet which are pretty huge right now okay any other questions um I'm not sure if I if I should answer that but um it's it's quite a lot it's quite a lot so it's um what is it five figures um do you have a databases we looked especially especially but we looked also at other DPS but in the end we took something that also fits in our team like we don't have so much resources I was like so much take so much man hours to get into a new technology and for us this looked at the best fit and right now we are really happy with it so yeah we basically went from an export time of uh 30 plus seconds for attestation assignments to like five seconds which is a lot better and there was less contention between different queries uh on bigtable now that we moved but that can change if we have everything on bigtable we're just starting to migrate so I hope it stays good yeah and layer 2 is coming okay uh anything else then thank you very much for listening and for participating again yeah thank you so much okay this is foreign foreign [Music] [Music] [Music] foreign foreign foreign [Music] thank you [Music] [Music] thank you [Music] thank you [Music] [Music] [Music] thank you thank you [Music] thank you [Music] thank you [Music] foreign [Music] [Music] foreign foreign [Music] foreign [Music] foreign [Music] foreign [Music] foreign foreign [Music] foreign [Music] foreign [Music] foreign [Music] foreign [Music] foreign [Music] [Music] huh [Music] [Music] [Music] foreign foreign foreign foreign [Music] foreign [Music] [Music] [Music] foreign [Music] foreign [Music] [Music] foreign [Applause] foreign [Music] and you're worried [Applause] foreign [Music] foreign [Music] [Music] foreign foreign foreign 