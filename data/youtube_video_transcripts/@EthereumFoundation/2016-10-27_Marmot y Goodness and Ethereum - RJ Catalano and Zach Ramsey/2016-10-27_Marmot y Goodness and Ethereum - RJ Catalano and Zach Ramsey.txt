okay so hi guys I'm RJ um for those of you who have not had to endure my Chatty Cathy pneus and had the misfortune of that a little bit about me I helped develop solidity and work on the etherion package manager and right now i'm going to go hand it over to zack my colleague right so our Jay and I are on the platform team a terrace and today we're going to talk to you about chain orchestration tooling which is what I focus on and it's a smart contract package management which is what RJ focus is on on next slide please okay so what is eros eros is tooling for developers we offer a chain maker and this is a it's got an interactive wizard and it helps you set up your chain essentially for different accounts and the account types are an abstraction of our permission experimenting scheme comes out of air is DB which is our blockchain client that endermen proof of stake can everyone hear me cool and then we have the package manager and it's all wrapped up in a command-line tool that's heavily daugher rised next slide please to two things don't work all right so this is what it looks like so at errors were providing what you see in green and so through docker we can control all these different requirements for a blockchain application files for example we have an IP FS integration keys we outsource that transaction a consensus engine that's tender mint and etc next slide okay so here's the demo the internet gods were not so nice so basically the way that you would run eros and certain errors chain you run errors chains make that will generate a key or several there's a whole slew of flags to do that and then you start the chain posit the directory where all these files were generated and then you grab the address that you need or key and you can see there that you've got your keys service running so the keys Damon is in its own daughter container which makes it nice and modular and then the chain which I've named DEFCON 2 is also running and then the third command basically that you would run would be eras packages do you give it the chain name you give it the address that would have a contract deploy permission on that chain and you're off to the races so so that command eras packages do would be run from a directory that will have um you all your smart contracts and then the EPM yamo file which rj will be talking about eventually next slide no forward let's go forward one more yeah great okay so here here's just to show you a little bit about how we think services and how a blockchain application platform should look like so I stopped keys which was started earlier by the chain maker I've started at PFS and I've started the compiler service and when I run errands LS you can see that Keys is not running it's got a Dodge compilers and I PFS those are running and the chain is also still running so with a PFS running we can do something simple like arrows files put some random file and that will spit you out the hash which you can then get up with arrows files get and give it an output rename your file or share it with your colleagues next slide right so I'm on a road map and this is where docker really shines is uh being able to modularize the client type and also the consensus type so like I mentioned eras TB uses tenormin under the hood as a proof of stake consensus algorithm but there's been a lot of talk here and some interest by the various developers of getting gas / TMS P SOT MSP is the tournament socket protocol that can communicate with any arbitrary client and so this so you know would be interesting and I would like to see as many different clients blockchain clients oh I forgot to mention eras DB has a full reimplement a shin of the evm so all of your solidity code that you've written and can deploy on the etherium test net or main that will work on an eris DB no go back uh what was my last point here yeah basically so I envisioned and we're working towards this to be able to choose any client type B it gasps CPP parody and choose any consensus type and mix and match and so you could start 5 10 chains of any combination and and do your benchmarks with that and to see what works best for your application and I want to make one final point here uh yes we make permission chains we're not we're not necessarily in the private chain space and there's a crucial distinction there that the media hasn't noticed and so yeah we hope that you can try out our tool and up next we'll talk hey guys can I get the next slide please alright so here I'm going to be presenting the eris package manager and I would like to go ahead and frame it as the ease of NPM the simple coordination of Chef all running through solidity now this runs through the simple workflow right here there is a disclaimer though in it and installer on the roadmap they're not yet implemented but is simply just this you just go ahead and is your project install your dependencies and deploy and run your code on your running chain next slide please why do we need another package manager why do we need to go ahead and have this when we have so many others to go ahead and handle ourselves well there are specific problems inherent in utilizing block chains and smart contracts there's the problem of single versus multiple parties what do we mean by this in the top right right here you have the old traditional model this was one person executing code in a file system that one computer and only that computer controlled as nickel I'm asheghi in from dapple explained in his talk yesterday we are in a completely new paradigm where about a code is not meant to be run in an isolated setting but rather collaboratively acted upon as can be seen and displayed by the many smiling faces over here this calls for a specific design to handle this new paradigm secondly a terrace a we don't believe in a one chain to rule them all design and believe that the world will inherently cater to a multi-chain mindset even for those that do believe in a maximalist one chain to rule them all world can agree that there is a high amount of utility and separated test networks for chains this calls for package management that can coordinate and maintain smart contracts over multiple chains and distributed ledgers thirdly verification simple enough we want to make sure that what we had exists on the chain and works as expected and expect that we're going to be working with them and upside forth finally we have to keep in mind contract reuse as we now are acting in an environment where economics is actually a factor in your code and calls for using the least amount of resources AKA gasps as necessary next slide please moving to where EPM chef like qualities shine it's a little thing right here the EPM BPM llamo file is on the right and on my left is a solidity smart contract that I thought would be good for this example you can see right here that we have numerous different jobs running we can go ahead and set an initial value that we want to go ahead and pass in you go ahead and can create a deploy method call the contract GS factory that's soul and name an instance of it and then go ahead and call that instance further on then you can go ahead and continue to call the contract function for create at that deploy GS contract and for those who have been in the UNIX system that should be very familiar you have a little dollar sign to go ahead and call back what you already set and you have to set storage which will go ahead and call the set function and input the data from the set storage base made at the top so passing in the number five and you have a query contract which now for now forces the the chain to not be altered and next slide please alright and for finally further on our road map we are going to be looking to go ahead and integrate I PFS and swarm because the kick-ass that's enough said we are also going ahead with a lifecycle management contract and what that is that that is a contract that functions as a single point of communication to deploy update link all your contracts the best way to go ahead and frame this for those of you who are familiar with NPM would be it's like the index jsf aisle it is the entry point for all of your projects thirdly chain runs we are going to be going ahead and with that llamo file you could go ahead and set out set jobs that go ahead and define how you think your project should run and then you could chain them all throughout the dependency tree to all move up through and interact and fourthly of course dependency management and with that the next slide I'm going to let Zach finish us off great so if you want to get started on any platform it's a quick out of the box so Bruin choko work out of the box we just choko got approved last week and app get if you want to run it on Linux just check out our documentation and finally join our slack it's open and there's lots of users in there and they can help you get started thank you thanks our Jane Zach 