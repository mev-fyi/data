thank you sir I'm going to talk about a hybrid construction for vdf provers a hybrid between two previous rivers that were already mentioned this morning which we'll call the the vessel a steep river and the pH aquifer which I'm going to present in more technical details and what was just briefly mentioned in previous talks um so first as I was already said it's a scheme that works in a group of a known order so we're going to fix our Group G I'm just going to write the G but imagine an RSA group or a class group whichever you prefer and basically the vdf is a sequential sequential amount of squarings so the input of your VD F would be an element G from the group and then you have to square it T times until you obtain the final element G to the power 2 to the power T which is the output of your VD F so you could just pick that I've as your VD f but then the problem is can you efficiently verify that the output has been computed correctly so say you're given a pair G and H that Alice claims is the out is H is the output of the VD f on input G can anyone verify this claim without having to recompute everything so can we can Alice convince the entire world that she did the computation properly without having everyone recompute the whole thing because it takes a lot of time so here's the primal trying to solve Alice wants to prove that H is the correct output and other way is going to be done is thanks to some auxiliary proof so Alice when she's evaluating the vdf not only she's exponentiating g ET times to obtain h she's also computing some kind of proof which is a helper for everyone else to verify that the computation has been done improperly we will call this by the proof and now given the triple G H and by anyone can efficiently verify that H is G to the power 2 Authority so to mostly two methods have been proposed to provide efficient proofs of the statement one which will call the Vasilevsky prover provides very small proof spy so the proof is essentially one element from the group G and the verification is very efficient it's going to be too small explanations in the group that's computing the proof by we'll take a little bit of time it's going to add some overhead to the whole video computation so it's not going to be as long as the vdf computation itself so you're going to have to do t sequential squarings to compute your VD f and then you're going to have a little bit of extra work which will be around maybe 10% of the time it took you to evaluate the video then person can be a lot maybe reduce that so a second construction proposed by AP attract proposes proofs that are longer around 40 times longer for reasonable parameters and the verification is also slower by the same order of magnitude but computing the proof by is extremely efficient it adds pretty much no overhead so you do your vdf computation you do your t squarings and then the proof comes pretty much for free with a negligible cost so for generating the Paycheck proof efficiently you're going to need square root of T around square root of t memory and for the velocity proof it's more tricky it depends on how fast how optimal you want your prove it to be you can get pretty close to the best speed apasa with square root of T group elements ya-ya-ya-ya-ya it's a square root T pre computed values so values that you've encountered during the computation I'm going to say a bit more on this when we go into the technical details um so your question a natural question is can we gates can we get somehow the best of both worlds can we combine these constructions in the way that we get small proofs efficient verification but also computing the proof is fast for do you simplify the presentation I'm going to present everything in an interactive approach so originally we say we have Alice that wants to evaluate the vdf and convince the rest of the world in an interactive setting she just wants to convince a verifier Bob and they are allowed to interact this will be simpler to present and then you can use some standard tricks to remove the the interactivity of the scheme and get some non interactive vdf so first the vessel of ski prover so presented in this interactive setting so it's a discussion between Alice and Bob Alice claims that this pair G H satisfies H equals the correct output of the vdf and now there's going to be an exchange between Alice and Bob Alice tries to convince Bob that is correct so it's going to be a challenge response exchange the challenge will be random rather large prime number L large means not as large as RSA parameters but something like 100 bits or 200 bits so Bob sends this random prime number to Alice now alice is going to compute the Euclidean division of 2 to the power T by this random prime L so you get the 2 to the power T is the quotient Q times the random prime L plus some remainder and Alice sends to Bob the proof by which is the element G raised to the power Q the quotient now Bob can easily compute the remainder of this division by L which is R and then he's going to accept the proof is this equality is satisfied so the proof Pike the power L times element G to the power the remainder equals H so it's very easy to see that if everything went correctly and everything everyone did his job honestly then the Equality is satisfied just have to replace by by G to the Q and then you see that you get g to the power the Q times L plus R which is just e to the T so then it's correct it's a little bit more tricky to see that it would be difficult for Alice to produce the proof that satisfies this equation if the initial statement is wrong I'm not going to go into the the security reduction but we can say something like if alice is capable of producing misleading proofs she's able to solve some supposedly difficult problems in groups of unknown order so this is the interactive version you're going to make this non interactive by replacing Bob by a hash function and Alice to provide a non interactive proof which will just speak the prime l to be the next prime of some hash of everything that is in the input of the protocol yeah no this is this is the entire proof one round yeah yeah hmm yeah yeah yeah yeah exactly you have to you have to repeat only once because the soundness is very low it's very good um so just to sum up the construction in an in non interactive fashion so if Alice wants to evaluate the video phone in PG first she's going to compute H by T sequential squaring this is the slow part and then she's going to have to compute the proof and to do so she's generating the next prime of the hash of everything she computed then she's going to compute this Euclidean division and compute the proof pie which is G to the power the coefficient and the output of the VD F is the pair H which is the actual output and pi which is the proof so need to group elements yeah yeah yeah yeah true then so the question is you can you can have a nonce in the hash so that the nouns necessarily gives you a prime number and then the verification doesn't need to compute the next prime yeah so you get a small output only to group elements and the first verification because you essentially have two small exponentiation x' in the group now the big question is how can you compute this proof efficiently because it's D to the power of Q and Q has a pretty big bit length it looks like it's going to be as expensive to compute PI as it was to compute H now you want to go a little bit faster so what are the main methods to compute PI so the trivial method would be to just do a long division to compute your equation Q and then you compute Pi which is the Q but this will take essentially time and space Big O of T because Q is of bigger of T bits so it's going to take a while and a lot of memory so first you have a no memory variant if you observe that to compute your exponentiation PI to the Q you are going you're going to use the bits of Q one at a time so you can just instead of computing Q at the beginning just compute it on the fly with this formula which gives you the bit the binary expansion of Q so now no memory but still time Big O of T now you are faster variants if you use some pre computed values so when you're computing H which is G to the two to the T you encounter a lot of powers of G on the way you encounter all the powers of the form G to the two to the I where I is between zero and T as you can store a bunch of them and they are going to help you in computing the exponentiation by Q much faster so if you store around square root of T intermediate steps you can compute the proof and time essentially two T divided by log T so here's the first challenge can you do better than that the problem can be expressed very easily it's just suppose you're given a bunch of pre computed values of the form G to the T to the I and then you're given a random number Q of T bits how fast can you compute G to the Q so with the current methods you can go as fast as T divided by a B or a B are any two parameters that you want now sorry using T divided by a be pre computed values you can compute the exponentiation in time T divided by a plus B times 2 to the a so then you can tune a and B to minimize this and this is how we find this possibly 2 T divided by lochte runtime so our first question is can you go faster and the second can you go wellmaybe as fast but with less pre computed values this is a pretty fun pretty fun challenge if you liked you if you like all kinds of tricks to do very fast computations so now the second the second prover is a PHX prover still I'm going to present it in an interactive setup so the idea behind the pH activist you take a recursive approach I always wants to prove to Bob that H is the correct output for the vdf and your observed that the output of the VD f is essentially you take a you take T squarings so it's a long sequence of squaring so you can cuts this sequence in the middle and then you have two sequences of half the length and the idea is can Alice prove simultaneously the two pieces of the can you prove simultaneously that G prime the value in the middle is the first value raised to the power 2 to the power T over 2 and that's H the last value is the middle value raised to the power 2 to the power T over 2 okay and if she can prove both of them simultaneously you can take a recursive approach and / to the length of what we're trying to prove at each step and in fact you can by using some random linear combination of your two equations that you're trying to prove so to obtain a random linear combination we're going to let Bob choose how to combine them so Bob chooses a random integer R and then we consider the two new elements G 1 which is G to the power R times G Prime and H 1 which is G prime to the power R times H and now the statement that ice is supposed to prove is the linear combination of these two statements very recursive things you have to store a bunch of values and essentially in the end you can see that by storing square root of T intermediate values the whole proof can be computed in square root of T group operations so a square root of T group operations it's totally negligible next to the Big O of T cost of computing the VD F so the proof comes almost for free so completing the proof is very efficient but the proofs are longer why because each round of the of the of the of the proof every every recursive round you increase the length of the proof by one group element so in the end the proof consists in around log of T group elements so for realistic parameters log of T will be around 40 and if you're using an RSA group of 2,000 bits in the end you get a proof that is around 10 kilobytes which is a bit a bit more than what you would like so now you could try to combine the two approaches and get small proofs that are easy to compute so the hybrid construction is pretty straightforward it's not so difficult to figure out a still same problem Alice wants to prove the statement to Bob they can first do a few rounds of the pH approver and after K rounds they end up with proving a statement of the form h prime equals G prime to the power 2 to the power T divided by 2 to the K because it's round divides by 2 the length the statement you're trying to prove so in the end you have a length of T divided by 2 to the K so each round divides by 2 and at the end you have this kind of statement to prove where H Prime and G prime are not the same as the original H Prime and G prime though but then instead of continuing with your paycheque proof until you reach a thing that is trivial to prove you stop there and you use a visible ski prover which can produce a proof for this statements which is only one group elements and can be computed in time bigger of the length of the statement 2/3 to the K or faster if you're trying to use some optimizations we're using pre computed values ok so how how efficient is it so if you're using K rounds of paycheck and invisible ski each round of PA check adds one element to the proof so in the end you have k plus 1 group elements so that's the length of the proof and now how difficult is it to compute it so we can neglect the cost of the pH I crowns because they are very efficient and if we look only at the cost of computing the final vessel of ski proof it will be bigger of T divided by 2 to the K so you can tune your parameters like it like this depending on how fast you want to be you can go faster by having longer proofs so it's a trade-off now you can use some optimizations using pre computed values for the visit Alaska proof and essentially if the number of rounds you consider it a constant then the cost of computing the visible ski proof is essentially bigger of this fraction there when I say it K are constant I mean that in the bigger you have some dependencies in K the constants in the bigger um so why is that why having a too many rounds will be a problem it's because do you compute the visible skew proof say for the statement H equals G to the T to the T as fast as possible if you want to use all the optimizations you need to use the pre computed value of the forum GT the tree to the eye and these are readily available you encountered them during your initial computation but now once you've done a few rounds off your checks proof you don't have GNH anymore we have H Prime and G prime which are new so you need to update all your pre computed values so if you have a lot of pre computed values this will be very costly to update them all we can do it we can transform all the pre computed values of the form G to the T to the I into G prime to the 2 to the I it comes with a cost essentially the conversation that you have to do is something like this so this is another challenge try to compute this as far as possible so you're given K integers are 0 or 1 up to RK minus 1 these are the random numbers that are issued by Bob in the interaction and then you're given 2 to the power K group elements C zeroes you want to see this type of there C 2 to the power K minus 1 and then you have to compute this big product which are a product of it's the product of all the values C n raised to the power products of our eyes where you pick your needy our eyes where the ice bits of n is 1 now if you can compute this super fast then you can update all your pre computed values super fast so this is another challenge to you this as fast as possible currently we know how to do this in time 2 to the K minus 1 exponentiation by RI values plus as many group multiplications but it's not clear that this is optimal so can you do better or or can you like prove that it's optimal somehow no that would be interesting that's it [Applause] yes QL plus R and you're worried about the bits of Q we can control the size of Q by making L like just big enough so that Q's powers are like much less than T like square root of T so can't you just use this to control the number of okay so the question is can you if I understand properly can you make Q smaller by choosing L bigger yeah except they are really like different orders of magnitude L will be you don't want Bob to generate a prime that's pretty much as long as half the length of two to the T there will be an enormous number yeah this is what Justin referred to as reiterated visible skip over yeah so the question is can you like do a velocity proof or say the first half and then a visible ski proof for half of what remains and then something like this using the fact that computing the proof is anyway shorter than the entire the whole computation I guess this is an approach that we explored yes and one of the possible problems will be that it's unclear at the moment how much faster it will be to compute the proof because here we give counts in terms of number operations in the group but multiplications will be maybe twice as expensive as squarings and you need to do a lot of multiplications in your proof but you don't need to do any multiplication in the vdf evaluation so you could get maybe a factor a new factor 2 in the time it takes you to compute the proof just from the fact that you need to do multiplications instead of squarings but maybe if if the multiplication is fast enough compared to the squarings maybe that's an approach that should be considered yeah yeah I guess that's many directions to that remain to be explored you know work for this afternoon yes yeah so the question is it's not Bob's job to generate a random L because we're going to use a non interactive version anyway so it's it will be Alice's job but in any case generating an enormous prime will be so costly you cannot and the verification becomes expensive if L is too big because you have an expression of shake and exponentiation by L to do yeah I didn't gets here like a really minimal advantage to pick a big L because their IQ is two to the T bits and then you subtract to that the bit length of L is going to be extremely close to you two to the T unless you Big L to be outrageously big [Applause] 