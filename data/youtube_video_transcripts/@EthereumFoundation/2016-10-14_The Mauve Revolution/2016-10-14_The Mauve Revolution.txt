so you say you wanna a revolution how about a mob revolution metalic cool yay okay um where is the clicky thing of there it is perfect so in the house work in the interest of prop nests I'll get right to the point so okay maybe I won't get right to the point where is the clicker thing so I'll first what people won't read the comic that the most paper is named after I love sure lots of you have already seen it which color do you want the blockchain I think mo has the most Ram so let's scale the blockchain what's out some more RAM let's make the watching move so if your aim is obviously I can play terrible system it's as Jeff Coleman said it's a smartphone from 1999 world was trying to process hundreds of thousands of transactions a day and for some reason we're trying to convince people to use this thing they can only process fifteen or hundreds of thousands a second rather and we can only process fifteen transactions take 14 seconds to get into one block and minutes to finalize so when a payment is uh when a payment normally takes seconds the blockchain is minutes away variable privacy at base protocol layer so queerly not good for anything fortunately that's what the research team is for we have solutions we have solutions for most of these problems so our main focus on in research is basically figuring out we are exact with your iam platform falls short and seeing if we what parts of this we can improve so there's different parts of this problem so privacy tsuzuku means wonderful presentation on c-- cash and we're going to be integrating lots of that stuff over the next couple of months years will see scale but here we're going to focus on three things one of them is scalability one of them is cost and with a bit of latency so and there's also a bunch of other smaller problems that we have to worry about mining centralization selfish blinding vulnerabilities interface is unclean I'll talk if people want me to talk about this I can but not here so step one proof of stake so basically what is the point of proof of stake the intuition that I generally use to describe it is what I call virtual mining so proof-of-work you have a thousand dollars you use your thousand dollars to buy a miner you take your miner plug it into the internet plug it into electricity and your miner has the ability to stochastic we generate blocks if you have a miner of a thousand dollars you might produce like one block a day if you put two thousand dollars into your miner you might produce two blocks today but in general put money in blah and you make blocks and rewards for you come out proof mistake take a thousand dollars convert a thousand dollars into eighty-three ether and then convert the idiocy ether into a virtual miner and the virtual and the then the pro inside of the protocol there is a rule that says if you have a virtual miner you have the ability to stochastically generate blocks so the protocol itself basically defines you it gives you the right to create these blocks and it gives gives you the right to create these blocks in proportion to sort of how big your virtual miner is if you get a thousand-dollar virtual miner then you can maybe create one block a day if you have a two thousand dollar virtual miner you can create two blocks a day and so forth so same thing as proof of work but without wasting any actual electricity so that's the kind of dream now proof of stake it's existed since about 2011 what solves with the electricity problem so here's the approach that we're taking in cat in at least my version of Casper so in the state there is a there is a set of there is a set of bonded validators the people here remember what the state is it's an evil entity that's the also third of your money and bombs people in third world countries no it's a a stateless state is the set of sort of current information that was things like balances and nonsense that you have to keep track of and part of the state now is basically keeping track of some set of sort of bonded validators so bonded validators are kind of active participants in the protocol and they are active participants in the consensus protocol now if basically the state is the set of people crowd miners the miners are virtual and we are we are exactly are these virtual miners kept track of old or kept track of in the state of the protocol itself anyone can join the set by sending a transaction to this contract that's called the Casper contract so this Casper contract has a special address in this case it's the number 255 and if you send a transaction to it in this transaction calls the deposit function then you basically and if you along with your call you send some ether in then you can become a validator so you specify a bunch of parameters called validation code Rand L withdrawal address we'll talk about those later and if you call this function during epoch n so one epoch is like a period of about 12 hours then at the start of epoch n plus two is so like between 12 and 24 hours from now your validator joins the active validator pool and at that point you basically your virtual miner is active now while at our data is inducted they will sometimes be through a randomly assigns the right to create blocks is the probability at any given time that you'll be pseudo randomly given the rights to create a block is based proportional to the amount of ether that you've deposited now in proof of work a block has to contain a nonce and that non span of prove is a solution to a proof-of-work puzzle and that's a wishing the proof-of-work puzzle basically proves that you in the proof of work lottery you got lucky and you have the right to create this block here instead of doing that blocks have to contain a signature now what is then the signature is basically in simplest forms the signature is signed by the validators private key and it's checked against evaluators public key but one thing that we want to do here is we want instead of having up just using a public key we have this notion of validation code so what this means is that okay well the validation code is a function and the function says it takes a signature and it takes a hash as input and it returns 0 or 1 now normally the validation code might be something as simple as a signature checker so validation code basically says take a signature as input check it against the public key and if the signature checks out return 1 otherwise return 0 if let's say us a validator are concerned about let's say quantum cryptography let's say you think that the NSA secretive as an arm the pervasive arm of the state let it is up has access to quantum computers and it can break public elliptic curve signature is in an instant then you might want to switch to Lamport signatures Lamport signatures or type of signature that's quantum resistant and if you care about that then basically you can you don't have to wait for the protocol too hard fork you can just switch to it yourself tomorrow so a validator can also call start withdrawal to withdraw so one of the differences between real miners and virtual miners is that with virtual miners once you're done mining you can actually sort of can unfreeze the miner and sort of turn it right back into a liquid either so it's not a one-way process if you're done mining you can call this function called start withdrawal and you will draw and then one to two epochs later you're you are no longer part of the active validator pool you can check your note off you can stop creating blocks then you have to wait a bit more and after waiting a bit more you can withdraw your deposit plus any rewards that you earned minus any penalties of the protocol assigned you for acting incorrectly so this is basically your experience as a validator take ether call the deposit function after 12 hours you become a validator you have to keep your note online make sure create blocks to when you whenever you get assign the right to create blocks keep that thing online then when you get bored call withdraw then after another 12 hours you can check your node off and then after another some point in time this might be something like a few months you can take your ease you can call schwa and you can take your ether out nice and simple so people according to some people there are supposed fundamental flaws in proof of stake so let me go through some of them so one of the main problems is validator selection so the challenge is how do we choose which validator creates the next block now in proof-of-work the problem is kind of solved automatically because well one validator just like randomly solves the puzzle and gets lucky here we don't have that here we have kind of virtual mining and so we have to simulate randomly assigning validators the right to create a block so the state grunting problem basically says there may exist an economic incentive for a validator to perform computations do various things to try to manipulate validator selection in their favor so if let's say us a validator you have 1% of like the total active you are 1% of the active validator set if the algorithm is fair you should be creating 1% of the blocks but if you can manipulate it maybe you can manipulate your way to like getting 1.4 percent of the blocks and if you can't do that then you have the incentive to spend anywhere up to 0.4 percent of the total block rewards in order to get yourself that privileged position so here are some examples in like one old NXT algorithm validator was sued a randomly sample based on the signature of the current block so the attack vector there is basically to just grind a bunch of signatures let you find one that favors you in other there in some other older proof of stake algorithms the incentive was actually to find a favorable address to move your coins to so you can figure out which address you can move your coins to you know we are that address we get assign the block here we soon move your coins to it get then get make the block and then immediately move your points to another favorable address and so forth so these issues are fixable so for example the address moving issue we fixed by just requiring people to kind of deposit their ether well in advance and by kind of having a sort of long lockup period and the long withdrawal period so you can't just like move coins around quickly so the other problems are solved by basically having a kind of by having a validator selection algorithm that actually is fairly economically robust so in general this problem actually is solvable so you might hear arguments that say things like marginal cost approaches marginal revenue or whatever but the point there's several different caveat to this the most important one is that it's not enough to say that if you can't exploit the people will you you have to show that you know the algorithm actually can be exploited so the arguments that I can make is we have this approach where basically the random number generation is for validator selection is based on information that's not yet available so information that validators have committed to buy basically submitting the hash but we the validators reveal the information while creating a block while creating their block so block n contains basically IC contains this random number that gets revealed this random number can only be one particular thing there's no choice about which number you reveal because it gets checked against something else to be submitted previously but once you submit that value then that becomes a source of randomness for the next block and then whoever creates the next block is going to reveal their value that's the source of randomness for the next block and so forth so the argument here is yes you can manipulate it but there's two ways to manipulate it one of them is while you try to like manipulate what your original commitments are the problem is that when you're choosing what your original commitments are it's like so far back and the validator selection is going to be based on so much future entropy so you have no way of kind of predicting sort of which direction of manipulation is going to be in your favor the other way you can manipulate it is by not producing a block so you get the chance to produce a block but then you see oh well I might produce a block but I might not producible I can that'll benefit me but the problem is that that has a cost in the cost basically as if you do produce a block you get the block reward if you don't produce a block then you don't get the block reward so the number of opportunities where manipulation actually is more profitable than the cost is very small so another problem is let's say we select a validator let's say the validator is not present so what do we do well obviously the blocking can just stall and we can all go home right okay if you REM is done go back to with your M classic so what we do instead is we baste instead of selecting one validator we select the sequence of validators so basically we select like an infinite sequence where if value to zero doesn't show up then save then after some point of point in time validator one can create a block validator one also Softline the evaluator to could create a block and so forth so this is actually fairly standard so like NXT works this way a lot of existing pro se algorithms work this way so this is not particularly novel and generally sort of is the standard way the sort of stuff is done in my opinion there are some sort of incentive issues that remain that should be researched more regarding whether or not sort of timing is incentive compatible but in general this at least in the in practice this has worked fairly well so next next point let's talk about nothing at stake so nothing at stake is this other reason why proof of stake is terrible I can never never work which is why we should just like give up and go back to proof of work um so basically here's here's the problem so in the normal case you have you as a miner have four choices let's say there exists the fork let's say there exists two two blocks a and B let's say you as a miner think that block a has a ninety percent chance of winning and Block B has a ten percent chance of winning option one is you just mine on neither of them and if you do that you get no reward option B is you vote as the option one is you vote on either option two is you just create a block on top of a now 90 percent chance a is going to win your integrative block on top of a and you're going to win with them of the option three vote on B B only has a ten percent chance of winning if you create a block there then you have a much smaller chance of getting a reward option D is to split your vote between both but if you split your vote then you get hug because you have to actually split your work in half you get only half of one and half of the other and that so it turns out that the best choice is to just vote on a now this is actually good because what this says is if a block is winning it's in everyone's incentive to help it win even more so this is basically the proof of work as an economic consensus game has a nice convergence property so this is the sort of thing that we wants to have in virtual mining as well now naive proof of steak economics so this is how the older proof of steak algorithms worked okay vote on either zero you can make a block on top of a okay 0.9 you can make a block on top of B 0.1 problem is now you can create a block on top of both and the problem is because you no longer have computing power as a limiting factor you don't actually have to sort of split your vote in half you can literally just make a block on one side and make a block on the other side in whichever one wins your profit yay so everyone actually even if there are no attackers everyone has the incentive to create a block on every single chain at the same time and therefore in an economic incentive model thing just never converges so this is the problem so in we've had the solution that we've been thinking that we've had like as a core concept for about two years but the basic Princeton called it's been called different names like there's slasher now we call it now we call them Dunkle's and there's a reason for calling them Dunkle's that I won't go into there the general principle is if you make a block and if you make a block that doesn't make it into the main chain then instead of being rewarded you actually get penalized you lose an amount of either equal to the block reward now what does this do to the incentive structure well it does this actually this this is slightly wrong that the green thing should actually see is 0.9 minus 0.1 equals 0.8 but it's still the winner the point is if you look on the third one on B vote on B there's a 10% chance B's the right chain is going to win and you've got your block there's a 90% chance a is going to win and so the fact that you made a block on the other chain actually means that you get penalized and it hurts you so unless you think that a chain is going to win you actually have the incentive not to create blocks on it if you think a chain is going to win you have it you do have the incentive to create blocks on it so the consensus game is convergent so this is the basic kind of principle now let's talk about finality so there's c.a.p theorem so vlad talks about FLP impossibility which is the Floyd Patterson result as opposed to FTL impossibility which says you can't travel faster than light that was a joke I'm going to talk about the CIP theorem so it basically the c.a.p theorem says in the event of a network partition you can either have a consistency or you can have a fail ability but not both now if you want to understand this EAP theorem like this is one of the simplest ways is so just like a look at the sketch proof so it basically says if you have a decentralized network then if the network splits in half we're going to send transaction a which sends note n ether from me to Vlad on the left half and on the right half I'm going to send the same ten ether from me over to Ming now let's say there's two possibilities one of them is on the left half my transaction to Vlad is accepted on the right half my transaction to Ming is accepted that's called inconsistency because now you have two parts of network that believe different things the second possibility though is at least one of those transactions is blocked so at least one of them would just doesn't go through now this is called being unavailable because basically try to send a transaction does it go in the network is or the protocol is unavailable to you so ours now proof of work is availability favoring if there is a partition it favors availability most traditional Byzantine fault tolerance algorithms our consistency favoring if they're if the network splits in half unless one of the halves is like more than twice as big as the other half in which case is not really a half it's basically the thing just stops in our case we have a kind of availability favoring base layer so like the concept of this sort of proof of stake chain that kind of looks roughly like like that this sort of basically your proof of stake chain is availability favoring if 90% of the nodes go offline the other 10% will carry it on but we have this notion of a finality gadget and the finality gadget is consistency favoring so basically what the what the finality gadget does is it tries to kind of get stronger confirmations on particular blocks from inside of the protocol so how do we do this so one of the principles is a sort of fortress rule so in proof of work we talked about the blockchain that has the most work that proof work packing it sort of winning right longest chain wins chain with the most proof-of-work wins in Casper what we talk about is the blockchain with the most value out lost backing it wins so the blockchain where people stake sort of the most either behind it wins how do you stay either behind the blockchain now one of them is by making a block in it if you make a block in a blockchain and basically you stake your ether behind a blockchain because in every blockchain other than that blockchain you lose the you lose one block reward worth of ether so if you if the block reward is 0.2 ether you make a block you make a block on chain a you have actually staked 0.2 ether on chain a now against what we do basically we let people stake even more ether so we have a separate mechanism that basically gives people the opportunity to make what we call finality claims so in this case you have a finality claim that says this block has some particular hash with probability 99.9 percent now what does this mean to you as a validator in practice it means in all histories where this is the case you get a reward of 1 you know history is where this is not the case you lose a thousand now of course it's sort of easy to mathematically see you only have the incentive to do this if you actually believe this block will have this hash with 99.9 percent probability so now basically bets start off sort of being very conservative so let's say if I now any cycle begins for some block validators start off making sort of very low odds bets they might say oh this thing is going to be finalized with odds 4 to 1 5 to 1 6 to 1 10 to 1 then over time as validators see that everyone else is betting let's say 10 to 1 on a particular 4 on a particular block they're going to be willing to bet 20 to 1 once everyone sees that everyone else is betting 20 to 1 they're going to be willing to bet 40 to 1 and so forth and the third of hope is that value loss on a particular block will increase exponentially and eventually it's going to hit what I call economic finality and economic finality basically means validators make these beds to such an extent that they're they are willing to lose all of their either in all all histories except for those histories that contain a particular block why do they do this because in the history in the history is that you have that particular they get some medium-sized reward so in over here sort of the right side of the chart you see there's a medium sized reward and there's a pretty huge loss but if you if you really are that sure about the block then you'll take it so that's if then if one particular block gets finalized then the finality cycle sort of starts again so why finality basically because it makes even Forks and rollbacks that are backed by 51% valuator collisions so expensive as to be impractical once a block is finalized it can't be reverted like even if two-thirds of the validators are evil look they can do still do quite a few mean things but they can't revert the block and this is a really nice property to have another nice property to have is it really benefits like client sinking because when a single transit when a single claim on a single cryptographically signed claim represents a million basically like a million dollars worth of value loss on a particular block then it's actually very easy for white clients to sort of like verify that a particular block is correct because all they do is download a bunch of these of these claims and they see oh look people are betting twelve million dollars that this block is correct so I'm just going to assume it's correct I'm going to then assume it's correct and it's download the new state and then I see what what blocks in the future people are betting in another twelve million dollars on and so forth and so forth so sharding so all that I've talked about so far is non sharted not particularly scale while sort of simple proof of stake that can it basically keeps everything fairly similar to proof of work except it makes block times a bit faster it makes the system more efficient it means the amount of ether that has to be issued in order to pay for miners goes down a lot and so forth shorting so the dream basically is to achieve unchanged scaling to tens of thousands of transactions a second but it is through a fully decentralized peer-to-peer networks like can if needed run on nothing but consumer laptops sounds like a contradiction how do you do it answer rails every node in the network only keeps track of a small portion of transactions but it can nor it use morkul proofs to verify everything if needed now BitTorrent scales like this with BitTorrent you know it has huge like petabytes of data but somehow it's still a decentralized network and the answer is because if this happens because each node only stores a tiny portion of the say of the data so basically we want to do this for block chains as well the challenge of doing an involved chain wind is that you also wants to make sure that on top of all this you still have a robust consensus so sharding basically the idea is that instead of having just one shard you would have multiple shards and these multiple shards are kind of sort of mini block chains that sort of grow in parallel and these shards also talk to each other so there's sort of one shard called the home shard and on the home shard restore the validator set and that's sort of the shard that still kind of works as before all the other shards at any particular point in time you only have about you randomly select or pseudorandom we select 100 validators to be able to validate that short at any particular point in time so during each epoch and you at the start of an epoch you say you choose for each shard pseudo randomly these hundred validators are valid shared one these hundred without danger to these hundred or thousand or three and so forth why do we do this well number one because the if the random sampling works well then it means the mechanism can be secure reason is if you're an attacker you can't choose which shard you're gonna you're going to validate on so an attacker will still need to take over the majority of the Internet of close to the majority of the entire network to take over even one shard so this is sort of the basic principle if he wants to find out more read the most paper which will be really soon and we have a proof of concept not for shorting but we sort of for a lot of the earlier proof of stake things and you can feel free to play with it yourself so thank you 