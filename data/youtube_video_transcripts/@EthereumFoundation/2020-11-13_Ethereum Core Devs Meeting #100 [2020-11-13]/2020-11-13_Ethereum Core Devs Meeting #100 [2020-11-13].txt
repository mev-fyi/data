[Music] [Music] [Music] [Music] [Music] [Music] [Applause] [Music] so [Music] [Music] [Music] all right hello everyone and welcome to ethereum core developer meeting number 100. woohoo that's um an accomplishment of sorts i suppose we've been doing these since well on a cadence we've been doing them since about january 2017 with a few before then so this is really cool that we've been doing it this long and it's been you know helping ethereum so thanks to everyone who's been attending and has kept this going all this time the first thing we have up on the agenda is yellow v3 and berlin client updates and uh there's also some subtopics in there so i'll have uh james hancock take it over james yep we could get a an update on actually i guess yolo v2 is running in is running can you just give the update that you gave me martin earlier on sure um as far as i know there's basically nothing happening on it there was a there was some happenings when me and marius um so i took the old jolo b1 transactions and the reround then maurice did some resealing around the one you will be two uh which uh yeah it bumped these offline because it turned out that they their node was you'll be too compatible but it was not actually configured to use the auto v2 rules uh after that was fixed uh everything worked fine um and marius did some new trans fast transaction vectors that they played put put out on the network and everything worked fine for me the the best point about it was not so much the network but the ability to fuss the clients and i ran i run about 100 000 test cases targeting while doing a lot of subroutine stuff and cross cross contract calls which heavily heavily hits the 2929 rules um and yeah those fasting test cases have been a mix of geth bisou and open ethereum which i built of one of the branches from adiabatic i don't think it's in master um but that's we are looking pretty good great the thanks for moving that along doing those tests the for yolo v3 if we just go through the clients and we talked about last week the actual list for yellow beethoven decided on so just like an update of where we are as far as um integrating for each client and ready to sync or just where you are in the process we'll start out with basu sure um so we're in the progress of implement in the process of implementing the eep we got 29 29 25 65 done uh we're doing 2017 now uh rai on the team is doing that and he can speak to how how that's going um and we're we're we're obviously you waiting to have that done before we get 29 30 started uh so i suspect by the next call we should be mostly done okay and get can you go yeah peter you want to go i mean go go for it since you [Music] okay so um 2565 is merged but not in a state where it can actually be activated but the change is in there and uh once we define yellow v3 we can just activate it 23 1 23 15 no problem 29 29 is in and the the ones that we work on are 18 and 30 and yeah that's why we raised a few issues today on the agenda so once we clear out those question marks i think we can kind of go ahead but there are also as far as we see it probably there needs to be some some more agreements about the network components like how how do we communicate these transactions to go for new eth protocol or do we use the existing one um yeah so there's not only implementation work left i think there's a bit of specifications that need to happen uh sorry i i think there actually is a spec for that i totally forgot that that needs to be included if we're going to include 29 or 27 18. i'll let me find it for you oh well you're grabbing while you're grabbing that let's have uh another mind are you here sure um sir 2565 we've compiled the libraries have to connect them apart from that it's uh just the gas price chain so not a problem 2 3 15 um so we already have it i believe so this is subroutines right yeah so we have subroutines all tested based on the consensus stats that we had before 29 29 so i implemented that overnight and ready to test so want to try to synchronize with yellow v3 when ready or if ready um 2718 similar yes so i don't know if you know but dmitry regenerated the state test general status with the euro v2 definitions so if you run the berlin test you can get pretty good coverage of all the 2949 stuff okay that's perfect so we'll use it after the call to um to test if everything behaves as expected um thank you 2718 i have the same feeling as as martin mentioned that i'm a bit confused about how it touches the network so i'll wait for mika specification on the networking also a bit of the how the legacy transactions will behave and how we actually decode from from this new format because it will be like um i think it may conflict with the with the rlp in some situations and 29 30 so this one was probably the simplest and it's more like um as long as 2718 is clarified it should be fine i just need the serialization everything else it works so i do pre-populate the access list just do not deserialize transactions yeah so hopefully get everything ready for berlin on the mind yeah great thank you let's get we'll get back to 27-18 i want to give open ethereum a chance to give an update first are you guys here uh yeah yeah we are here uh basically just much told that peace for your v3 on our dev branch yeah we have some basically just as thomas said about if we're going to if that's actually going to be merged in the list if it is going to be merged as the separate entity it is basically called a different way but i think that small changes that need to synchronize basically on ip and that's it we are basically ready for lv2 awesome thank you um so the hudson do we want to go into 27-18 now or or let's go into it since that's kind of on topic of right now i can answer half of the questions i'm struggling to find the network eip i created but the other question i can answer with a pull request that is outstanding um against 29 30. so that pr that is focused in the chat um once that's merged 20 or 29 30 should now be 2718 compatible it was just an oversight in the authoring of 2930 i believe um i there's also in the discussion link i have some other comments um i'm not a huge fan of the current format of 2930 but this is the minimal change required just to make it compatible with 2718 uh because everybody is correct that right now it's not okay so that's that's you said that's half of it is the other half what what peter posted in the agenda as a comment the other half is um actually there's three have sorry so the second path is for legacy transactions here is the eip oh thank you light client i don't know i couldn't find that so the one i just posted 2972 is a proposal for wrapped legacy transactions which we could which i do think we should add at some point but it is not critical to add right now um the separate question is well if we're not going how are people converting between legacy and um wait let me take a step back so there's there's two things do with legacy transactions one is the thing we need to do right now which is when you get a legacy transaction you need to um oh sorry sorry my head is in 1559 because i've been thinking about that all day okay so legacy transactions for now please don't do anything with them they're normal they're just legacy transactions they have the first byte for legacy transaction will always be in the range c 0 to c to ff i think because of the way rop encodes a list it always uses the height basically the height those high bits and so we don't need to worry about it conflicting with a 2718 transaction these 2718 transactions are defined to always be below the c0 i believe and that i think is specified in 2718 if not mistaken i'll check it might be in the rationale section so if someone missed it i do not blame them yeah so legacy transactions will always start with 0x c0 or greater and 27 18 transaction types only go up to 7f so there is no possibility for conflict which i believe is peter's issue is that correct no or concern did i misunderstand that explanation is that we have actually two ways of uh of encoding we have the legacy transactions which is just whatever we have now without any encoding and the eip also mentions a wrapped version where you prefix it with i don't know zero or a one or something ah yes so that's that's ip2972 it doesn't have to be part of berlin if we don't want it to like in the future we might want that because it gives us some consistency around transactions in the network and makes signing tools easier to write but it is it is not necessarily required unless we want to is that something people want can you specify what you mean by it like or do you mean wrap format parts yeah so 2972 basically just takes legacy transactions retains the same signature format so the signature will be backwards compatible but gives them a new format for when they're included in a block or when they're included in a in gossip or whatever and so we can have consistency within a block or consistency within the network protocol if we if we think that's that's a valuable thing to have uh it isn't i would i think it's nice um i would definitely be in favor of including 29.72 along with yellow i just haven't been pushing it because it seems like we've been really struggling to get berlin out and so i haven't i don't want to add more to the plate of people now but the 2972 is the iep for that okay so the reason i brought it up is because i think it's uh then maybe it's important in in 2018 or whatever is the original one to just specify that legacy transactions aren't touched in any way shape or for way shape or form and then this second vip i think that's a valid debate honestly long term i think i'm also in favor of including it just because uh it's weird to have uh two different representations however i think it's also super important so i haven't tried the cip because i haven't seen it until now but one super important part is to uh to somehow avoid any ambiguity because the problem with the legacy transactions is that even if we add this extra wrapping around it there's no signature so from protocol's perspective a wrapped version or a non-wrapped version is essentially the same thing it's cryptographically the same so when you include it in the block uh we need to define which version will be included in force to you so you can't rely on clients trying to figure out whether it was original this or that yeah so yeah so right now um i believe when you say included in a block are you referring to in the transactions route and then therefore the the merkle tree that's associated with that yeah um so the when it when you get a batch uh what you can do is look at the first byte if the first byte is c0 or higher then it's a legacy transaction if the first byte is 0 to 7f then it is a type transaction you can use the type so you can think of the that type byte is still there in legacy transactions it's just like it's a range because of the way rlp encodes down to like that first byte is always going to be something big good yeah but so i'm talking about the wrapped version so as far as i understand there was a suggestion to have legacy transactions also having this zero prefix yep and that would be the 2972 and if we decided to include that and leave legacy transactions includable in the block so part of so it's a little bit of a story around this if we include 2972 we could choose to in a hard fork say that legacy transactions in their historic form legacy format are no longer allowed to be included in a block and only the wrapped ones are in which case we wouldn't have to worry about anymore and like i said i'm totally okay with that if that's what what everybody else wants um i think that's very reasonable so in my opinion that would be a hard requirement otherwise [Music] so the problem is that clients are free to represent legacy transactions however they want within their code base so it's it in my opinion it would be super easy to to mess up where so you can have transactions coming from the network from a block from rpc and uh it it's super sensitive if you can actually push them into a block into consensus format in two different ways because i'm certain that somebody or i'm actually i'm certain every client will mess it up somehow and just not use the correct one in one place or not that's why i i would really be in favor of having only one consensus format for it yep so so right now we have a single consensus format um assuming we do not include 29.72 legacy transactions are only one way to afford to provide them there is no other there's no wrapped way at the moment if we decide to include 2972 then i agree with you that i think it would be wise to say the old format is no longer allowed in block and maybe even not even not allowed to be broadcast over the peer-to-peer network but i understand that's a little bit more complicated because you can have multiple versions live on the network at a time um but yes i i think i agree with you it's just up to the group whether we want to do 2972 right now and make it that hard switch today or do that sometime in the future so can i uh just clarify for basically my own understanding if we were to do it as peter says then the uh when we put together the the transaction route we don't have to make differences between is it this type or is it that type we just put the type and then we put the rp encoded transaction into the hasher whereas if we yes do it like currently specified we would have to look at the transaction type see oh this does this an old style transaction do it they just hash the rfp or alternatively concatenate a byte with the rlp is that like the core of it yeah i i believe that's the core of it yes so if we um if we include 29.72 then everything is a type transaction that's in a block if there's a transaction to block it is a type transaction just flat we're done there are different types of transactions there's now the 2930 type and there's also the wrapped legacy type so the 2972 type and so you'll still have to do the code for 2718 for just uh distinguishing on type before you decode the rest of it but everything would be a type transaction if we went with 2972 and followed the thing that peter just described would uh and i i also have not read this third app you were talking about but it sounds like uh could couldn't that one be couldn't 2718 be updated to include that and make the smaller so rich originally we did include 2072 and 297.18 were one uh thing where 2017 defined um the structure so the new type transaction structure and along with that it defined the first type transaction which was just a wrapped legacy transaction um it was split out because there was some i believe there are some pushback so two reasons one as everybody knows i'm a big fan of smaller independent eips and two there was some push back over against that originally where people were like well we don't really need the raft ones yet we could just do 29 30 or we could just do 1559 or we could just do 2711 we don't actually need that and so by splitting it out maybe we can choose to not do that i'm still like i said i'm still in favor of doing them at the same time um we could merge them into one eip i don't know if it would buy us much really um but it's it's a possibility yeah we're not people feel very strongly yeah i actually quite strongly think that we should keep the legacy transactions and never touch them and keep them always available for the blocks as long as possible but so not as long as long as we don't i mean we still we're still not talking about i mean users won't have to actually sign rap transactions they would they don't have to update their signers do they that is correct the signature is the same for the the new 2 9 72 transaction as long as it just wrapped with the number in front and it's fine yeah yeah there would be talking about this just a different way to we can shape it differently in the consensus engine but not actually making the changes for the user yeah so the in if you were to do that in a client then your json rpc endpoint would likely still accept legacy transactions in the legacy format and then on receipt like as soon as it received it over that like json rcpc it just immediately wrap it internally because the signature is still valid for raptor versus legacy and so you could do that just on receipt and then everywhere in your code base you could deal with 27 18 transactions only if that's the easiest way for a particular client to handle that yeah that would be nice and thomas that does that change what you just said yeah well what i meant was if there is any transaction that's already signed but not broadcast then we should keep it valid so if it can be later just wrapped in a different uh civilization format by adding i don't know zero in front as the type of the transaction and it's perfectly fine yeah yeah i guess that was the plan right yeah so as long as the signature remains valid then it's fine yep that is a hard requirement of this uh 2972 was to make sure the signature remains stable between legacy and wrapped legacy um something to keep in mind since we're talking about this and i suspect we'll then move on to talking about whether this will be included in yolo v3 or whatever um the 2972 as currently described does specify a slight change in the receipt format as well because i believe 2718 specifies receipts and so just be aware that that is code that needs to be written it should be pretty easy if you've already planned on playing 2018 anyways because receipts are just typed just like in 2718 um so i don't think that's going to be hard but i just want to make sure it's on everybody's mind while we're talking about this specification for the receipts in f63 as well uh so yeah so then getting into the the third half of that discussion is the link that light client gave just above um to 29.76 and 29.76 is yep and can i just figure out where we are in the conversation and then like so then as far as peter's comment like either use one or the other but never both was there like a do so we want rap transactions but we also want we so we don't want both but is there a sense of one or the other so far so i guess um this boils down so yeah this has multiple fronts or multiple halves too um i'm also discussing at the consensus level so stuff that's included in blocks or whatever else consensus format there my personal vote would be to bite the bullet and just roll out the wrap format and just drop the legacy format because it keeps things simpler otherwise if we're going to if i mean i think most of us would agree if somebody doesn't feel free to shout out but i think most of us would agree that it's better to have a single way of encoding stuff than two ways so it's probably if we want to go down the type transaction approach it would be nicer to encode all transactions as typed and not have special cases and if so if we're going to do wrapping for legacy transactions in a future hard fork then we might as well do it from the get go that would be my my initial suggestion i don't know if there are any tools out there or dapps or systems or whatever that uh directly poke in blocks and that would maybe not survive uh changing the block format so that's that's a question for example ether scan if we do this will ethers can die or not i don't know so this is something they should answer for possibly so those would have problems even if we introduced new transaction time then those tools would fail anyway so then taking a second deposit this decision here is there so is there people that feel strongly that we shouldn't have the the rap format introduced at the time of doing 2718 or is that something we can just decide here and then have the later discussion i'm convinced now we can with seven two sorry two nine seven two two nine seven six nicaragua uh so just uh because i would rather this come up sooner rather than later i'm gonna bring it up now um there are contracts out there that receive block proofs and those block proofs include transaction proofs and receipt proofs and those would break and those cannot be fixed i don't know how many there are i don't know how used they are but i i've seen code out there that exists like people have written contracts to do this but i guess that will break even if we just introduce a new transaction type so this is true um depending on how they use it like if i guess there's a question of like if they can still submit legacy transactions in the legacy format then they can still prove that transaction they just can't prove the new transactions where if we say those transactions cannot be included in the block anymore then they can no longer get a transaction into the blockchain that can be proven by their contract so i i i have a feeling that we might not hear a lot about that and they notice that it's happening i'm not sure their true folks are hey martin you sound really far away from your mic okay i'll try to reconnect this is really quiet he said he's going to reconnect so that would that would tend to uh it's one of those things like we don't know if anyone actually does this but it is a thing that i have seen code for because i happened to work in the space a little bit and i kind of copied some of it like i was using as a reference that someone else wrote on some random github repo somewhere so i know someone has written this code so uh that's that's a bit better yeah did i interrupt someone right now nope keep going guys yeah so what i was gonna say or try to say is that i think we might not hear from uh those people who are might be effective from this until this hits until we actually roll it out on rops on a ring could be gurley because they might not be active in the i mean there are two people might not be active in the discussions here so maybe we should just do it and see what happens and how bad things break and how important it is cross our fingers that they actually test on robson and go really girly yeah yeah well worst case scenario we're going to have a show like we had two days ago [Laughter] nice okay yeah so then i would say it would be good to have a little more time on on test nets to give the chance like spend a little bit longer on a test it might be better make given this change but it sounds like like a basic or open ethereum do you have thoughts on including the wrapped format in in berlin and just it sounds like eventually it's going to happen so we might as well get to it is this yes it seems more elegant um i don't really understand the the block proof transaction proof uh contracts that micah was talking about i'd like to learn some more about that but from the consensus standpoint yeah i think it'd just be easier to represent them with in the type format okay i can agree with that do you agree basically yeah biggest problem is if you're going to break something with the tooling or something like that but for the client perspective we are fine to pm1 encoded the coding scheme yeah it's better cool so probably also wants to talk to people who use ip186 because they use the proofs of transactions so if something changes with transactions that might be the first ones that will notice what kind of problems it causes is there someone i could ping about that i use 186. okay i'll talk with you after mike uh that's actually why i know about this i use it in a slightly different way but i that's why i happen to know um so then let's say for now that wraps that wrapped the wrapped format is going to be included if it's in 2718 or in the other eap i don't really care however you want micah is fine uh but then commute barred community members coming and figuring out some things that it should that it should go in and we can count that as a decision and then move forward to the next part of the conversation yeah so do you want to keep it in two separate eips or just have one i i like i said before i have a preference for separate eips i like more modular ips that can be picked and chose choose like if we decide for example we need to pull out 2972 it'll be easier if there's separate ips from 2718. so we keep so we keep them separate yeah so that would mean you add it to the spec sheet for v3 right james yep okay so i said i'm sorry about harping at this i i don't actually see what 1186 has to do with transaction formats since it's about words you're just saying it's a way to it's just a way to identify who might be doing um using proofs in general and people who are using doing like rock proofs tend to also do account proofs and storage proofs like the same is it kind of if you're just looking for an easy way to find people look for people who you see that if you have some finding them so basically the people that would be would be affected by this is if you have like a a relay like the btc relay or a c cash relay so on the other side you have a you want to verify that the transaction was included in an ethereum block so you need you get the transaction you hash it and then you follow the rlp um try basically to try to get the route and yeah yeah i don't i don't see the direct connection with 1186 but they might be the same folks sure um and real quick uh thomas you said um and cubed uses it is that the slock at blockchain's llc project uh yes okay that'd be interesting to talk to them then to see how they use it um whoever's talking to people about that maybe james or mike i forgot who um okay uh sophie yeah go ahead there's a the third half that we put off yeah the third half is the net we're letting me get to that the network side of of this which is eip 2976 and it defines basically a fairly small change to the p2p protocol um interestingly the wp2p protocol was sufficiently underspecified that we actually don't need this technically but this change makes it more clear what happens uh which ap again it's in chat i think nine seven six so you're saying this is something that is not necessary but a nice to have for clarity of the clients building right um it depends on what you define as necessary i believe so the the spec for wp2p is just like a wiki page basically it's not super detailed and it was vague enough as currently written or at least as last state last night looked at it it was vague enough that technically these new transaction formats were allowed only because the dev p2p spec didn't actually specify what a transaction was it just said there is an array of transactions and it didn't say what that meant but i believe there's enough clients that kind of assumed that a transaction means a certain thing and so we felt it was valuable to more clearly specify okay this is what it means to be a transaction and p2p so i think this part is kind of fairly important because uh so this is something that we all want to bring up the networking wise because there's a so the thing is that all clients currently are in so even if the spec allows if the client implementations assume that the transaction is this oral think of the thing and um and the thing here interesting question is how are we supposed to support new transaction types so any code currently running if whatever 63 456 will drop the connection if you try to send it one of these types of transactions so one approach can be to backwardly upgrade all the protocol versions so that these fields can all of a sudden handle a typed transaction too so essentially we are just doing uh if63b64b etc and that seems like not the nicest thing to do because then you're kind of overloading the protocol version just trying to hack this thing in felix's suggestion was to just roll out east 67 with the new transaction format which from geth's perspective is fairly easy to do but if client x doesn't support e63456 then that's going to be a painful thing to do so it's not obvious what the best choice is i think we should just roll out 67. i mean it so so the thing i actually i just realized that there's a second problem we could roll out e67 which supports uh transmitting transactions but we need to change the block format too so all of a sudden if we have a block that contains a typed transaction that cannot be represented on any of the past if protocol versions which means that not only do we roll out e67 we also drop support for everything else so we need to stop supporting 63 456. and that should be fine if everyone upgrades yeah if everyone upgrades went really well in class well they're well they've brought one before so you see the problem was that basically parity was very much behind on the on the protocol stack but very much behind on the current beat version so that was the major blocker before now i believe open ethereum is on a track to support it already support 64. there was at least a full request support 65 it should be fairly easy to support 66 and 67 is very easy as well so i don't believe we are as held back before as held back as we were before so i think 66 which is identifiers yeah that can be implemented pretty easily by just pretending to have identifiers but actually ignoring them and keep using whatever method we have before 65 for a client which have not yet started implementing it and 65 is the you know transaction hashes and announcement and fetching and i think that's a pretty big thing actually i don't know where what's the status on that for other notes so so right now uh the both in trouble gap both ghost entry and last century so our baseline protocol is 65 64 but we also support 65 and a 66 should be fairly easy to support and 67 as well so i guess the important thing to know here is that with the 864 the thing that that defines is transaction announcements so that the network doesn't uh shuffle around transactions uh and doesn't send the same peer doesn't get the same transactions uh 50 times rather it just gets transaction hashes this is a bit of a special protocol version in that it's not just adding some new extra feature but it's also taking away it's taking away the the default transaction propagation where we just send it to everybody so the complexity here is that if a client starts speaking 864 without actually fully implementing it then there's a chance that they will not get all the transactions simply because most of the transactions will be just announced that hey here's a hash if you need it retrieve it and then they actually need to implement this retrieval logic otherwise i mean transaction propagation will not work for them will not give you transactions otherwise you mean e65 right yes so one option one option would be to retake to basically uh insert transactions back into 65 and 66 and 67 and remove it in e68 so everyone could just implement e67 and when they are ready to change the transaction management logic basically uh they would also operate to e68 i believe this shouldn't affect gas because gas would quickly implement e67 and e68 and you still wouldn't have to rebroadcast transactions to every connecting here but it would allow uh forever why yeah but in that case essentially you're doing the what i said previously that you're releasing e63 b64b65b so then you might as well just extend the currently running protocols so there's not particular i mean that would probably possibly be less messy than uh so the thing is that if if for example i mean we decided we want to upgrade all the protocols yes i can roll out 67 8 9 10 but will i immediately stop talking three four five six because if yes then that's kind of partitioning the network if no then i think that's a bit weird so that's that's why i wanted to bring this issue up as it's not that obvious there are a lot of solutions the solutions aren't particularly hard to do just uh we need to figure out all the implications what is sorry what was the argument against just you know letting the rlp decoder decode the transaction message that comes over the wire or the block that comes over the wire yeah i was gonna go back to that same question um because if if we are changing the consensus definition of a block then logically is 63 should transmit so you should use that definition um so what what do we say i mean what what's the benefit of having 6386 of all these instead of just changing the rule rlp so we can change the i mean we can retrospectively change or extend the protocol the only thing will happen is that if somebody didn't um so if i for example i implement this in guess one point i know twenty whatever it doesn't matter if i implement it in a new get and roll it out and this new gap will send such a package to an old guest then the connection will be immediately torn down because it's a protocol violation so all right right but but in this case so what we do is we need to ensure that geth will not transmit any new transaction format until the fork actually passes and then right because but when the fork actually passes in that case that other side won't be able to handle the block anyway there's no use talking to him yeah but then the question is what happens if uh let's suppose we're already past the hard fork one month in the future and um and then you have a new node that is syncing and it's for some reason it's getting new format transactions from the network from somebody what happens then it's a bit murky again we could say that well we just discard it and we don't care about all nodes i mean we don't care about all those but um yeah possibly that's a cleaner approach to accidents we just need to handle this scenario too i think someone correct me if i'm wrong on a client team but i think we actually would would want a 67 to go out before the hard fork block right like we want people to be talking it so they can transmit new transactions over the network before the fork block actually lands is that correct so if you roll it out as e64 sorry x867 then it's completely fine to roll it out whenever the problem is that when the fork arrives you need to stop talking 6345 and i don't know get at least doesn't have such a functionality that all of a sudden at a certain block number you stop a networking protocol so it's not uh if the things start to become weird so that's why i kind of also see that maybe martin's suggestion of simply uh baking it into the currently released protocol versions might be less invasive because then you don't need to do these version jugglings during runtime if i understand that proposal correctly it's basically enshrining the under specification that we had previously so right now the specification just says this is the transaction message it's just an array of transactions the specification doesn't actually say what those are internally it's just there's an array of transactions and so technically again this is maybe just pedantics but technically the specification as is is what you just described however like you said earlier i don't think anyone actually implemented it that way i think all the clients implemented it as it expects that array to be an array of very specific uh structures well the thing is i remember we've talked about this in a prior breakout room and i thought that was the case but you know i don't know if that is actually the case i think that most clients have one representation of a transaction and whenever they try to deserialize something over the wire they use that and so if they didn't extend that transaction type like we've done it in go ethereum to support two transaction types all of a sudden whenever you read transactions over the wire you're reading both of the transaction types so i don't think that clients have two representations one for wire transactions and one for you know operating transactions and the rest of their infrastructure so maybe help me let's let's go back a little bit and help me understand there's the option of we go to e67 and then stop everything previously or there's this other option that martin was suggesting that peter is kind of warming up to so having upgraded the the uh open ethereum's network in 2004 from 63 to 64. then the curry goes to 65. basically the major blocker here really is that it's 65 uh it's it was a major upgrade to the networking protocol that which required a very specific change of behavior from the clients basically the clients can no longer rely on the transaction propagation on the gossiping but they have to actively pull transactions themselves so this is like the major problem with implementing 65 because it's not just an ordinary protocol by changing the model or the data structure like that or implementing support for a new message type it requires actually changing the uh the way transactions you actually have to pull transactions from the network basically not rely on gossiping so like my idea is that we should really split 865 into two parts uh basically retain like the the new messages uh in e65 but uh still and provide for the fact that the clients that speak at 65 they still propagate the protection themselves and respond to the propagation requirement this way we should make it very easy for everyone else to upgrade so just so i understand what are what clients aren't on to each 65 we still have a bug in our implementation so we have not turned on e65 by default yet ethereum does not have 865 yet only if uh that's correct fine yeah penetration still needs 65 okay so then the there's develop there's more development that would need to happen for all clients to get to whatever ends up being 67 if we were to make that choice of implementing all the stuff and forgetting the rest of it yeah so in that case my suggestion is to just um just use the overloading approach and not roll out a new protocol version because it it doesn't make sense to start rolling out multiple versions hacked in various ways just so that it's easier for clients to roll out i mean overloading it is a bit murky but it's still a lot simpler than than rolling out three more protocol versions just so everybody can implement whatever they want um i think that everyone should implement e67 and then as soon as possible so unblocking the clients is it's the maybe not the best approach to the theoretical perspective it's not the most elegant solution but it's the most practical and workable one we will propagate transactions even basically if we had that and everyone could just partially implement e65 as is and be compatible so open ethereum wouldn't have to to test and to implement immediately the logic to pull transactions from uh from the network it could just it would still rely on right but so would the just overloading method be as well right yeah because if i understood that arthur correctly he's saying that we should roll out 67 and then like three more variants so that we can have old style transaction behavior in a more recent protocol format and what we're saying is that we could just use this ambiguity about what is a transaction and not roll out new protocol formats and those who have not yet implemented transaction fetching can still you can mate with that if they want to so i think both ways forward here means that no one has to implement 65 immediately are you agreeing with what martin's saying thomas with your comment one idea but uh just just thought of it and not sure if it will work what we can do is that during the handshake we can specify the protocol version and stabilization version now it might be very strange so you would say your externalization version 1 or f65 serialization version 2. yeah but that would still require exact same i mean you would you need a new protocol so then you're ending up with e67 and then no no no you wouldn't need a 67 or 65 or 66 you could connect to 63 old clients and just during the handshake um tell them that you'll be broadcasting things in the old serialization form there's no such thing in handshake how do you tell them yeah that's what required a change of handshakes so e67 um no is it yeah we're getting kind of close on time on spending more than we than i think we should on this just a heads up yeah one thing we can do is take the entire thing to a magician's thread if someone would volunteer to write up these outstanding issues um and then we can talk about it on there would be one solution because i don't think we're going to figure it out today until we think about it more uh did anyone have cool but could we can we consider it decided than the hashing format slash consensus format as being type and then the blob it sounds like yeah that was already consensus roughly wait what were you saying yes and no so the problem is that we've kind of decided that we would go with the wrapped format but the problem is that the eip defines two wraps formats and they are interchangeable is that micah's vip or a different one interchangeable in what way so in so 25 29 72 as far as i see it it defines a zero zero type and a zero one type i mean a zero and the one type yep and it just swaps the signatures they shouldn't be malleable between each other it's basically eip 155 or pre-155 it's like if you were signing pre-155 so you did not include the you're only signing over six fields then it's type zero if you're signing over nine fields and it's type one we basically already have two signatures correct because unless you resign you they are not signature malleable they are but they are basically sending the same information just one has a chain id essentially okay then it's perfectly fine i i was just afraid that uh they are somehow interchangeable you can convert between them uh no that they should not be if you someone discovers that is the case please let me know because that would be a mistake i agree okay so then is that sufficient martin for answering your question yep i think so okay so uh can we repeat the for some for the note taker for the summary what what is the answer or the um yeah the conclusion for that piece that it will include that the 20 set the the the 27-18 will include the wrap format under the the other eip number 29.72 29.72 and 29.72 will be added to the yolo v3 list yeah 2072 is added and then micah you said legacy transactions won't be valid in blocks anymore right that is my understanding from this discussion i will update the eip 2972 to specify that i believe right now it does not specify that explicitly okay uh and micah when you're done updating that if you could let james know just over discord um so he can update yellow v3 because we don't want to update v3 before you get done with that piece uh sure sounds good at some point we should probably spend some time and actually look at the serialization format of 29.782 because it does include some things we've talked about in the past such as the ssd uh additional coding there and the ss ssz like i believe ssd-like encoding and it does have the prepended signature scheme which i know has been a topic of discussion before yeah we do need to finish that discussion uh the discussion actually started on 29 30 and we need to finish it there as well okay um if someone could just that or james or someone in chat can just point to like the magician's thread that micah posted uh in the zoom chat and posted in the discord sometime later today or next week so that we can jump start discussion on that in there would that be a good place should we have a breakout session for this topic yeah this might be a good one to do that if we want to get out berlin out quickly then the faster we can solve this yeah i kind of agree on that that this won't be solved by writing on the chat okay we will get that scheduled sounds good all right so light client uh work with the cat herders on that um i think usually pooja organized some of them before so uh that can work out there anything else on that that we have hanging out that or that people are concerned about beyond what's going to happen in the breakout session okay i think it was good that that discussion happened because it yeah it's making um it's making things a little more complicated for berlin but it's important that we get it figured out um so the next thing is final no go or go for berlini ips i don't think we can do that anymore james because we kind of have a lot of stuff in discussion well we can say the bls one is out of berlin and we can say this one is but the 2718 plus this the rap transaction formats are they're pretty much just split out versions of the same eip so i i think that still we just need to resolve that piece but that's like the final piece to resolve okay so that's that's almost no final no go go okay and after we have the yellow well yellow v3 implement implementing all this and yellow v3 will actually be the if we find a critical thing we can say that's out for berlin yes okay but do note that in order to implement this and launch at the yellow v3 we actually need the networking too otherwise there's no way to actually send this stuff over yeah that makes sense um i think we can i think we can discuss the networking and e65 to e68 in this course okay so the networking piece can that be a sync over text or do people think that needs that that needs to be included in the breakout session uh let's do ac first and if we don't have the solution instance then we could be protected all right that sounds good all right next up uh we have network upgrade process update um puja wrote a blog post that is in progress and that they posted uh in the in the uh awkward devs chat to get feedback on it's a in the all core devs chat there's an ethereum magician's link to the contents of the blog post and um pj i think you wanted to go over just some of the high level stuff a lot of the stuff is are things that we have talked about in the core dev calls previously but have never been codified or written and we've just been kind of flying by the seat of our pants with how we're doing some of these procedures and stuff like cfi and yolos and things like that so pooja if you want to go ahead and kind of do an overview and see if people have any comments or if we can take them to the magician's form either one yeah sure so uh i would just like to give a quick summary of whatever the process we are actually following right now for the berlin upgrade um so there is this document if it is fine i can share my screen to show the diagram that would be helpful yeah the diagram would be great okay so um earlier this year the eipip group started discussing ways to decouple the process of eip standardization and network upgrade we are in process of documenting these recommended outcomes that came out of the eipip meeting to make it easily available for community uh we are we will be posting it in a form of blog on ethereum cat hurdles the part one was the eip standardization process that has been added to eip1 recently uh with the help of this merged pr so people can find it here the the process is here the part two is the network upgrade process for this a repository is created at one dot oh specs repository so um as we see in this uh diagram the first stage when a proposal is ready ready by ready i mean that it's a like in review stage or more from the draft so it and and they intend to get included in any for in any future hard fork they have to first go ahead and make a request i mean create an issue in the at one spec dot o repo that would be considered for inclusion and this will be also added to the i mean i'm just going to share how how it would look like so you have to just create cfi applied once it is done that would be added to the project board which is available here and the eaps will be listed this network upgrade process is broadly divided into three phases consider conclusion devnet and mainnet so once it is um applied for consider for inclusion then it moves on to devnet phase cfi approved is the process when it is approved by the uh people here in the code f meetings all these terms are explained in the blog ci devnet waiting room is a list of buckets in which proposals are there people are still trying to figure out if that should be included in the developer's test net for for now we have yellow test net ci devnet active is a list of uh eips which are actually being tested uh by different clients testing green light i think james broadly spoke about it in the meeting today and then it comes to the public test net phase uh that would be pow test net like uh rapston and the final deployment phase that's the mainnet phase there is this recommendation of eip statuses as per different phases of network upgrade uh though this eip standardization process is now separate from the network upgrade but we highly recommend that people should be following it the places to go for is like for the network upgrade process and list of proposal the best place to go is the f1 spec repository to track the process of any individual proposals we can go to this project board and for question answer yeah james james hancock is the hardware coordinator cat orders uh are also supporting them so you can always reach out to us so that's about the process we have this at magician forum if people have any questions that can be answered uh quickly here i'm happy to do that otherwise feel free to leave questions comments here in this fellowship of ethereum imagination and something that i'd like to do is move so there there is a list of of the efi meta eip and i'd like to move that list into the specs repo and so that it's not just a project tractor but we have like an actual document that tracks the things that are cfi um and then update the documentation around cfi to include this kind of stuff okay any other comments from anybody i wanted to bring it up here before i did those changes so we could agree if it's a good idea or not sounds like for something like that i think you can just go ahead because otherwise someone would have brought up something okay cool okay um thanks to axic for being one of the early people to help try to separate this process and organize it through some meta eips and thanks to tim puget and james for organizing the post pooja is referring to that will be posted eventually and pooja for writing the main parts of it um okay so if that's done we can go to other eips let's hit up account abstraction get an update and see where we're at it looks like they're using the process already and if you go to the specs repo you can go into the issues and see that they are already cfi applied for their cf their cfi applied in their quest to get fully cfi so go ahead with the update i think who's here from account abstraction uh hey i'm here hey sam okay great hey so um not too much has changed since the last all core devs meeting on the eip um we've been trying to solicit some review i don't know if you've noticed the post i made in the awkward devs discord channel a little while ago we were just wondering if anybody had a chance to look at it so far i started reading it same here uh sorry right but were you gonna say anything else no that's it yeah after reading it i've only actually managed to do the single tunnel thing and it's a lot of complexities around it so i'm thinking um yeah it's going to take a while to figure out all the corner cases and quirks and potential ways that things can go wrong yeah of course i was just going to say that i mean on a high level perspective i have no kind of obvious objections well that's good to hear um is there any part that you find particularly complex or um no i think there are a lot of there might be a bit of lack of describing error states and like what happens in certain conditions when um things don't go according to plan things like that and it references also some other eeps and like sets indestructible and have to read up on something destructive a lot of stuff work what happens if i run a set indestructible uh in the init code or whatever and um yeah there's a lot of complex mechanics uh both on the evm level and kind of how would this be used and what are the possible consequences in there too when this is used and um yeah awesome well it's it's great to hear that uh you guys are reading it over and uh we really appreciate it okay great uh is that the end of the update sam uh angela was there anything else you wanted to mention or is that uh uh no i think i think that's that's basically it maybe the question would just be um is there any way we could basically uh actively kind of um and i don't know if there are any like questions and in discussion you you would want to have maybe when reading that or where the best what what the best communication channel that would be or if it just basically once you you've got through all that or anyone interested gets thought of that we can we can continue discussion on one of the next calls or something yeah um so because uh we're kind of heads heads d or really heads down in berlin i don't know if we're gonna get into a lot of advanced discussion on it um i know there's a full chat channel on the r d discord that people can pop into with their questions and i know that's really helpful um but because this won't be going into berlin um it will it probably won't have a lot of advanced discussion i'm guessing until after the holidays but um i mean we can definitely keep putting it on the agenda and getting updates and pieces of feedback and i'm open to other people's suggestions yeah backpedaling here so i just realized remember that i have one actual practical question about it um which should would be good to be clarified so you are overloading the nonce of a contract uh to use it as the kind of the norms for executing this incoming abstract transaction and i'm wondering what if there is a creation being done from this contract wouldn't so so um we thought about that and so far like uh from our perspective we didn't see an issue with that so indeed the behavior as specified right now would be that the noise increases both if a transaction and aa transaction starts at the contract and once the contract uses create or create two um we thought about like [Music] the disallowing that or something but but we didn't see any any issue with actually this this dual purpose because the of course the kind of repair protection and transactions uniqueness properties would still hold um i think you should mention that mentioned somewhere deep that this is a fact so that the casual reader can think a bit about it and see if there is some actual yeah if there might be some consequence to that that makes sense maybe then like and and then that that would be the last the last thing for for connotation on this call but like one like uh connected question that we were actually having is the one corner case we have to protect against is um for the a contract to to to self-destruct and then be redeployed and then basically nons also begin it at one again and so then you could actually have a the same transaction with the same hash sent again and then be included again with the same transaction hash which would violate transactions uniqueness so one of the options we saw were to just enforce something like this set indestructible again that's in another independent erp the other option was to look into maybe changing and self-destruct behavior in into not resetting the nonce of a contract but we we just don't have don't don't have the knowledge there if that is something feasible or not so it just in case anyone on this call happens to like i have any special insight into that because i do think that back when self restock was introduced or not when create two was introduced there was discussion if if that was desired behavior or not but i'm not sure if that if anyone has like any any thoughts around um if it would be okay to for basically for self-destruct not to reset the amounts of a contract or if that would have too many side effects or something but if there is no one with any any immediate reaction that's fine as well i mean it would it would change the semantics of self-destruct in a way that would uh screw with potential like upgrade patterns or whatever so it's obvious it's not obviously a safe thing to do i mean that was obviously a dangerous thing but it's not an obviously safe thing to do yeah absolutely that makes sense though we definitely had that as like a thing to look into if we were to to to to push for that so that's definitely not something yeah yeah that makes sense thanks okay regardless we do have a community call coming up on november 20th uh if you guys want to join the information is on the uh ethereum cat herders um github yeah i think it's at noon eastern or one eastern yeah it's noon eastern ipm utc oh and i'm running that call i think all right i'm i think i am um there is also an episode of a peep and the cat herders did just on this a week or so ago or was it this week well this leaks feels really long yes uh the the episode will be released on monday i will share the link publicly on monday and also the detailed information about the community call a blog post will be published on monday providing the information how people can join that community called great i think that's wrapping up just about account abstraction unless access you said you had something yeah i'm trying to i'm trying to say something regarding the the replay protection um so as you mentioned that's like a crucial thing which has to be fixed before aa is considered and there is an eip for the as you mentioned the set indus tractable and there was another eip for removing self-destruct um and that was i think proposed by alexa but it didn't it wasn't even merged as a trap because he he abandoned it um but i don't think the the set indestructible is championed too much um so maybe sam and anskar if you if you if this is a prerequisite for aa um maybe you could consider championing one of those two um options and yeah so just for clarification i think at least the set indestructible actually came out of this consideration so i think that that was created by vitalik as part of our um uh work prior to releasing the aaa eip so so i think so basically if if a were to move forward that would definitely be yeah we'd be part of that and then we would also um champion champion that one as well and i think there were some people in the community just asking for the said indestructible to maybe be championed even in the case that a would not be considered just because it might also just be a nice thing to have to be able to to them basically and create indestructible contracts optionally yeah i wonder the other eip which just removes self-destruct all together i'm not sure why it was abandoned um but it would be interesting to see because this self-destruct has been like a such a mess since it was headed i think that was alexisy but i think that he just decided that he didn't want to pursue it any further i think it's like one of these things like unguess where it would probably be nice to have but it might break so many things existing things that it might just be too too too big of a change to to push for and that's that's just my opinion though um but yeah i i do think like looking back would have been better to never introduce self-destruct but yeah if you do have the time i would encourage you guys to maybe look a bit more into that and um i personally would be happy to see uh save this track to be gone okay thanks everybody um i think the next thing we're going to do we'll have one minute on eip2666 because it's just a really short update and then i want to skip to the gethbug and responsible just to close disclosure discussion from geth um because we've had a lot of previous meetings about bls 12 381 and there isn't the agenda a link to an explainer on uh the the i guess comparison between evm 384 and bls 12 381 from um alex vlassov it's the second comment down it's a pretty good explainer um as far as like content-wise i was able to understand um why teams need it and stuff like that this this pre-compile curve or whatever we end up putting in um so definitely check that out and then alex if you want to talk about 266 real quick before we go into geth's discussion uh yeah well basically it was just cleaned up and merged it's now even in a smaller scope after improved inversion was merged into gas to so we can eliminate repricing of uh bm edition and multiplication compiles so just basically three changes of the constants for shadow five six ripenbs 160 uh precompiles and keychaik or shastri opcode very simple ones just the constants numbers are based on what clients has provided as a benchmarks it's just like low-hanging fruit to implement and give some extra performance and also kind of ensures that resources which are paid for are actually like like that you actually pay for resources which were actually spent okay thanks for the update if anyone has questions just reach out on discord to alex and again check out the explainer if anyone has any comments or rebuttals to that explainer post about them in the discord in the all core devs chat and we will continue the discussion there um so for the last six minutes let's have geth go over kind of what happened the other day uh where part of the network went offline uh due to a bug that was revealed in a few blog posts the other day uh martin or peter if you want to go ahead sure so um before i dive into that i just wanted to give a quick heads up here too that yesterday so about two weeks ago we found a pretty serious issue in go and reported it upstream and for the past about two weeks we were going back and forth with google on getting that fixed and uh essentially that was fixed and released yesterday uh into uh security releases for upstream go and uh we also did a release ourselves yesterday mostly to to rebuild all our releases docker launchpad etc with go one five one fifteen.5 i just wanted to highlight it here too that uh this is actually an important release because it can be used without it uh notes can be taken offline remotely i won't go into the details on exactly how currently i can do that maybe in two weeks or four weeks or whenever when a decent chunk of the network is actually upgraded so anyone running get notes please make sure you are running with go 115.5 okay so with that out of the way essentially just a quick recap of what happened i think two days ago in the morning essentially there was a block appeared in the network which uh did a small chain split uh within a theorem now it was a bit unusual in that it didn't do the chain split across different clients rather the chain split was only between older versions of geth and the rest of the network plus your versions of gas so new versions of gas and the rest of the network were on the correct chain and all gets dropped off and essentially what happened is that about one year ago we did some optimizations which uh which introduced a consensus bug and that consensus bug was dormant in our code base for i know seven months or even more or eight months or something and somebody reported on the backbone to list that they found this consensus bug and we've patched and silently released a hot fix for it of course this also meant that all of a sudden since we changed the consensus we fixed the consensus bugs old versions of get the new versions of gas were not compatible with each other given a specifically crafted attack transaction and uh usually we've did this a couple times previously too just a disclosure and usually what we do whenever we discover one of these bugs is that we try to evaluate them what their impact is and what the probability of actually hitting them and this particular case the probability of somebody accidentally hitting this block meaning that people just using ethereum and just hitting this bug is more or less impossible so unless you very explicitly found the bug and very explicitly crafted an attack transaction there was no way to to abuse this and because of that we've decided that it's better to to silently roll out the fix and just get the network to eventually eject old nodes than to raise awareness to it and uh yeah and uh and have a potential attack so the thing here to know is that it's essentially a one-liner fix so if you announce that hey we have a it's a consensus issue this is a consensus release and here's the one-liner fixed then that's a fairly large target that's why we try to avoid it in general i kind of feel it that this was the correct approach to take the problematic part which i i agree was that even though i don't think we should have announced it during the release so i think it was the correct choice to keep it hidden uh people on the internet are right that retrospectively um we should have made a actually really strong suggestion that there was something wrong in a previous release and people should be on the new releases now since we didn't do that a few people and projects were using old stable releases and since infrared was one of them um yeah that kind of blew up in our faces so that was kind of the issue as for we've uh in the past couple days we have been talking about this on and off on essentially what better way we could have handled it and uh as i said i i'm still convinced that uh it's not um you can't just unilaterally say that hey here's a consensus bug this is a consensus release everybody upgrade now you have five minutes because that would be extremely strainful i mean people who cannot we cannot expect people to be in front of their computers so one possible solution that we're thinking about it will put a bit more strain on people but maybe that's the correct solution and anyway is to still i mean this is something a fluid so i mean we're open for suggestions and inputs but the idea would be that we retain the right to to silently fix issues but uh we try to commit to for example if we do such a such a fix in the future then let's say we release it at one lesson date and then we could commit to uh revealing maybe a month later that one specific release was a consensus container critical consensus fix so that anybody not upgrading within the last month they would have somehow an emergency notification that you might want to release it sorry upgrade and then maybe after one additional month we could also simply say that okay this was the bug and at that point if anybody didn't upgrade then that's probably going to blow up so we this is the the best thing that we could come up with that we could do but it does so people are one of the reasons so people were kind of really angry at us that we didn't admit that there was a consensus issue and what the consensus issue was we are open to to disclosing these issues but what everybody needs to be aware of is that these disclosures will act as so the same barriers every time we do one of these disclosures that is an active risk for the network and for anybody who didn't upgrade so that's essentially that's the dilemma okay so we're a little over time but i do want to have people chime in on this especially james prestwich who actually added this uh in part to the agenda i think you're here james right hey how's it going hey um so uh i uh respect the amount of work that has gone into this especially like this week with two major issues uh coming out of the geth team um i think that the uh you know the interesting thing about this bug that caused a consensus failure is that it was found by a downstream team uh and who decided to go and test it on mainnet the optimism team discovered this specifically and tested this because uh they were using a stable geth release as the base for the ovm and were not notified of the consensus issue privately typically in open source software there is a disclosure policy that is a specific document that says who will be notified privately how and when on a you know discovery of a severe vulnerability like this and i think downstream projects like the ovm like cello and like other people based on geth should be pretty high up that list because we tend to use older stable releases rather than newer cutting edge things to minimize our engineering overhead early notification of downstream projects would have prevented this specific instance of a consensus failure and early notifications of major stakeholders like infrastructure providers would have mitigated the impact i'm not saying that we should go to go ahead i think it's just i just totally do not agree because you're saying it like if we had notified downstream then it would we would have avoided it and i mean if some of these are the ones who exploited this particular instance it kind of shows uh yeah i don't agree with that reasoning um so downstream notified me on tuesday night and i gave them a teardown of the bug and what it would do but that wasn't communicated to all of the engineers and so another person who did not have this knowledge was testing to see what would happen um if the knowledge of the bug and how it worked was communicated to him this likely would not have happened but i don't want to get into like the specifics of this kind of weird circumstance right now you know my overall point is that it's common to have a disclosure policy that says you know based on risk and based on responsibility who gets notified in what order yeah so the problem here is that for example um this in theory sounds nice but in practice um okay let's suppose i'm going to say that okay i'm going to notify infera and i'm going to notify uh i don't know one of the mining pools then all of a sudden people will get angry kind of quick note and alchemy that i didn't notify them so okay i will add them to the list too then cello and obm and whatever will get angry that i just notified them okay i will add them to the to the pool then uh three other smaller mining pools will get angry that it's not fair so i will add them too and eventually i will notify 100 projects and i might as well publish all the details because at that point it's so many people know about the consensus issue that it's what's the point of even keeping it private anymore so the problem here is i think that there's if i notify let's say i have three mining pools or i have i notify 10 mining pools then actually there is an incentive for one mining pool to to produce a block that breaks consensus simply because they will have the next 100 blocks or or something so how can you control it once the details are out how can you how can you see if there's somebody actually abuses it what do you do how do you avoid that yeah i you know definitely agree that there's a lot of like judgment that the guest team has to exercise here about who gets disclosed to and when and who can uh you know use this information responsibly and who is unlikely to uh but you know the impact of these issues on other people is very large and could be mitigated by early disclosure to people that you believe can responsibly handle the information yeah but in that case we will still have some backlash from the people who didn't know about issues yeah um i think that you are likely to have backlash regardless unfortunately uh and that really does suck because you guys put in a lot of work uh in order to keep things stable i i don't think that avoiding backlash should be a significant motivation in uh security policy so our whatever we do i mean the the basis for our security policy has got to be towards the third mainnet and everything else is secondary so that's like number one i do i mean we could have some kind of downstream agreement but we wouldn't i don't think there was any better solution than what you've done at cats i mean we can improve the notification like how the bugs are reported so we can advertise security at ethereum.org and tell everyone if you notice something risky send it over there so it can be tried humidity and fixed silently it's almost like a just come back to the back bounty program from the past and people stopped using it because they assumed that everything will be stable um there is a difference between what the actual situation is and what people claim it is i mean there was lots of people who are just complaining because they use it as an opportunity to make you feel worse even as most likely this was the best solution fix it silently and then slowly wait and observe and see if everyone is switching maybe maybe paying more attention all of us that like who is on a very old version and and just suggesting it very delicately that they should have upgraded recently because there were some very important performance changes or whatever and it will be harder now but it's not the time can you versions which have valid and everything else you call duplicated and say we don't guarantee anything like the standard way uh i mean you you cannot obviously you cannot force someone to upgrade but at least if you do if you like publish such policy on the front page well most likely people will pay attention so uh earlier in this call you know we had a very nice polite a security patch dropped and you should go and upgrade your nodes i'm not asking for any more information than that in early disclosure but you know that amount of notification would have to infura two months ago would have prevented most of the impact of this specific consensus failure uh so for that amount of uh disclosure to optimism would have prevented the specific consensus failure there's also a chance it would move it two months forward i mean if if that's what happened i would say if the team does test and exploit one main net and it actually warns you against disclosure of those downstream i mean this is other misresponse irresponsibility to do something like that uh it is extremely irresponsible to do something like that and it should inform disclosure to that team in the future but not uh to the general it should not affect the general idea of downstream disclosure it sounds like there's an amorphous list of what who would want to know at different levels of detail these kind of security things maybe if those people got together and said we want to be on this list it might be easier to talk about it well um that's one of the problems that if it's a list that is maintained externally and it will probably be the most horrible list because everybody will be on it who shouldn't be on it right i definitely agree is that the geth team should uh is qualified to choose you know like who is trustworthy to handle information like this yeah but people can signal that they want to and not have the guest team have to figure it out like like them have them having the like be able to choose but not having to make the list like it might not be as yeah don't not putting the burden on the geth team but at the same time having it available to them of people who are interested if they do decide to in certain circumstances that might not be as dire as the bug that just happened but in certain circumstances say hey update so uh just a quick memo which people are going to hate me for this uh people i think in general the ethereum community is not really aware of how serious updates are so uh over the past well we've been releasing i don't know we did about 200 guest releases give or take i have no idea how many i am fairly certain that a lot of them are super serious in that day maybe this one fix a network where you can crash it the other one fix um fixes a memory leak where if again if you know how to crash it you can crash it so generally all of these fixes every time we fix some bugs a lot of them can be exploited maybe it's super hard maybe it's super convoluted but they if you really want to they may be able to be exploited and now either our code is super which i doubt or my guess is that the same thing holds true for other clients too in that um when you are fixing bugs those bugs have some effects and the effects can be pretty bad so you kind of people kind of need to be aware of that the updates are useful and i think what i'm looking for is a communication channel where people can opt into becoming aware of that much more quickly a lot of people running infrastructure prefer to stay on older nodes to avoid new instability bugs so i spent a lot of time on the phone yesterday with infrastructure providers like four different companies running significant amount of nodes ensuring that they update to the new golang version they were largely unaware of the severity uh of that issue and were uniformly on older nodes so i think like some sort of communication channel where you can you know tell these people that upgrading is important directly would help a lot with that well the cat herders have a list of so in the event of an emergency or a hard fork or something that has to happen very quickly that's very public we've used a list of exchanges miners and infrastructure providers to reach out to them to make sure they upgrade so we could have that list be the same list for any client not just guest who would want to reach out just you know poke the cat herders and say hey can you send this out to you know these subgroups of people whether it be minors or exchanges or stakers or whoever and let them know is that kind of what you're looking for james in a way at least like part of partly uh was that list activated on wednesday or thursday this week no because um we were not we don't have that system in place right now to be poked for that unless there's a very public like this this has this like how needs to happen right now to upgrade your node otherwise the network's going down kind of a thing um so if it wasn't activated on wednesday or thursday this week i don't think that it meets our needs okay so we still i mean we're still going to have that list especially for eth2 stuff coming up um where it comes to like exchanges and stuff not knowing about um when or actually not even eth2 eth1 also where if exchanges need to know about an upgrade coming up we use that list for even longer term like this is coming up a couple months from now or have you updated yet and stuff like that so we're still going to use the list but i understand your perspective that it might have not helped on wednesday so just to clarify a bit so in this for the critical fix we did do an announcement a couple of days before and that went out on reddit discord twitter uh and this is an old skype group with a lot of exchanges in it and then the message was repeated um when we actually have made the release if there are if we have if there are other channels where we should do announcements or sound the the alarms yeah that of course that would be good good thing to note that for example yesterday's release that was not directed by us that was scheduled by google and essentially that's i mean that was our part of the responsible disclosure in that we cannot take the lead off it faster because that issue affected an insane amount of infrastructure over the internet not just ethereum and yeah definitely and [Music] the moment they gave us a public day i mean the moment they actually announced that there's a security release coming that we also try to maybe announce it half a day later that we are going to do uh again a security release and it was a bit weird that uh this is kind of uh overlapped with the consensus issue so that made things a bit funky yeah that is a unfortunate synchronicity so just to wrap this up so we can all go are there any final uh comments on this i mean this conversation was more to have a conversation about it and to get word from geth about how their policy works today and how they've kind of thought it over since getting feedback from the community um and so we've accomplished that are there any final words yeah i have one thought so if if geth did their suggestion of they like a month later or two months later said that this was a security release make sure you do it and there was like a way to publish a way to subscribe to that message being published does that like fit in kind of the middle of what works for you james like so there could be so you could subscribe to that list so you you might not have gotten the day zero because it wasn't determined to be significant enough for that but you would have found out way earlier yeah uh it would be helpful um you know we're in somewhat the unfortunate position of having to coordinate validator upgrades when issues like this happen which can take a significant amount of time but any amount of like notice that a security release happened would be very helpful okay cool anybody else have final comments i have i have a one sentence thing for people to chew on if you don't mind sure um just keep in mind that any sort of private list that we create creates a competitive advantage for large actors in the ecosystem and disadvantages small actors who can't get onto that list because there's a competitive advantage to being more less likely to crash in a consensus failure than someone else and so any private lists that we create that people can get into we just need to be careful of that like we do not want that because that increases centralization or has potential to i should say yeah and it's just related that the drug noting infera also mentioned this in their postmortem blog post so you know they seem to agree that they shouldn't get the preferential treatment over whatever the community gets oh yeah that's a really good thought i think that that should shape some of what the cat herders do including having that list even if we the list needs to be either public semi-public or only used in situations where they're warning about an upcoming fork that's happening like a planned fork so it's more not an alert system for emergencies but more of a system for for times that things need to happen that are very public and that you might not hear about yeah like a pub sub notification system yeah that's coordinated a little bit yeah something like that well this was kind of the reason why we're trying to to go the path of um just doing for example if we do a silent fix then doing a public announcement some time later that this was a pilot a private fix or a silent fix but the idea of this opposed to reaching out to individual projects was specifically so that we don't end up in this weird situation where essentially the reason people use infuria is because they are surely not crashing because they have the insider information not to crash and i mean it's definitely really horrible if in between pure crashes but but yes it is also unfair that that the small operator who's not infured but infuriator they they have no chance of competing on this front it's i don't know so essentially yes we are i i would say we're open to suggestions we agree that we could have handled this a lot better and we should have warned people or notched people more aggressively towards upgrading so that's something we need to work on but we're kind of open to suggestions on how to do that fairly in a way that it's it's open to people without creating creating a possibility for abuse okay thanks peter um and thanks the geth team for you know working through all this and getting the fix out quickly and coordinating all this and i know a ton of people at least privately and publicly have said that y'all y'all are heroes for that so keeping the network up is always a good thing um thanks everybody for coming we are well over time so the next meeting is november 27th uh 1400 utc and um again daylight savings time change so that is an hour previous and a lot of places to where it has been the past months so take note of that thanks everyone for coming have a good day thank you cheers [Music] [Music] [Music] so [Music] [Music] [Music] foreign [Music] [Applause] 