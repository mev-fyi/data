all right good morning everyone it's great to be here it's my first I've con super excited and today I'm gonna talk about like basically build and operate a Internet's Quixote apps on Saturn Network but before I go to the technical content I just want to say that we have a test net up and the tester is not a black window that we say awesome numbers but an actual app you can download and try today and you can play some board games in yet but we only have it in android available right now so we're just gonna show like basically a quick demo here that what this is about is this is like a game is running on generalized state channel it's a board game it's basically connecting five and you can create a game and you can bear with your friend for point one test at ease and now you can off you go you can start to play and you can the important thing here is that we want to show that state channel is actually going to help in terms of user experience because you can see that each of the state transition in this kind of game is already implemented as generalized a channel or offering smart contract that's what we call it so this is kind of the other experience you can experience and we also have the dispute protocol and fousey was opened I implemented now with this we launched this personal app including this application on if you miss San Francisco and after about after about three weeks we have 900 installs of 15:15 sound in the payments and and amazingly 17,000 a game is played over this 900 people and we the interesting thing I want to highlight is that this is all on test not if we put all these like transactions back to back into this entire about blockchain it takes 57 days to finish all these transactions but amazingly we have a 15% you know user retention ratio for seven days or retention ratio even if like people know this is fake money they still stick on it so this is like kind of amazing thing that we think generalized a channel can bring to the table that is real mass user adoption that is pending and we have the SDK already released a day and multiple teams are already building on top of the SDK with off-tune prediction market some more poor games and it's some even some I sell a micro payment or like basically a micro services and solutions so you your Vericut welcome to a look up or a github and there are tutorials about that so jumping to a certain network what is there a network is a coherent of chain scaling architecture what I mean by all we mean by that is setter network has two parts one is the technology part called C stack we propose a layer technology architecture and the other part is economics which we propose some crypto economic construct to solve some challenges in the state channel networks and you know for C stack we basically solve the question of how to support generalized options skating how do that route radio transfer efficiently in this caliber of things gaming networks and how to bring mass adoption to offering the apps by providing a better user interface and developer applications so C channel is the lowest layer what do you see channel is basically basically our generalized a channel construct we came to this generalized channel constructor from the concept of a conditional payment and the conditional dependency so let me just like give a quick overview here this is like a channel spat you can write so when you're writing a generalized a channel application what you're writing is first part is a smart contract so to write a generalized a channel smart contractor you basically need to implement these kind of functions and also have these kind of you know States in it so I'm gonna not talk too much in detail about that but we have a separate talk I will refer to later but a key part a key part here is that this kind of construct enable generalize the state-transition generalize the conditional state transitions that is like you can make your transition in your state channel and continually depends on some other transitions in some other state Channel and ultimately you can build this rather complex conditional dependency tag to implement the complex you know generalization or application logics and to just make it a little more concrete here to talk about like what we did in the game for example so let's say Alice and Bob have the channel and sorry Alice and more have a channel more and power have a channel and and it's one to play a game with Bob and while patting on point one is right so or pending on five dollars here okay so what's gonna happen is that alice is gonna send Bob a conditional payment of $5 related by a mole and in the beginning the conditional payment will be like you know a pooling and the condition group there is a pudding and condition group on top of it what it means is that only if condition C 1 C 2 both evaluates the true then this condition and payment actually goes through right so there are two conditions in it one is the standard multi help intermediate mediated transfer HT or registry condition and so basically we generalize that HT l part also as a condition and also the address in the ballgame after this kind of a pass start up you know the the you will see only one we peel off the first condition and the only one condition last work which is like the Alice and Bob said game condition and you know when when the game finally finishes the Alice and Bob's you know a condition or state is entirely a pure often objects that you translate entirely off chain and when this entire game finishes this game gets resolved at you a unconditional payment so this is kind of like a process of how you can think about the generalized state channel in the conditional payment sense so in C channel we have a bunch of out of box features including often draws translator to achieve this kind of a pure often object meaning that this kind of a you know often often smart contract doesn't need to be exist launching unless there's some people happening we have cooperative settling we have single channel setup which you can set up the entire channel with just one transaction you know we have some direct the final state claim functionality dynamics deposit and withdraw and for the conditions we implement some you know our pulse condition groups core pouring and pouring circuit condition and find a fun assignment condition groups and they are all talk limiting or read talks now this is like a quick overview of the generate a channel construct we have and the second layer of sellers technology architecture is called C rot so the reason that we need a routing architecture is because we really want this kind of mechanism or semantics to connect to this off chain stage channel network once and use it forever right so now what why this off chain payment routing is soldier right we took a raisin guy a focused house bought like a basic day why this we need the optimal writing but why it is challenging the reason is that the stage channel network is very different from a data network so for tailor network the internet will give stateless if you say it's 100 megabit per second link it's gonna stay a hundred miles per second and no matter how much data delivers through it but for a payment network that capacity actually changes as you deliver a payment through each direction and using simple algorithms like shawl his fast routing can break down the channel very quickly and when the channel within this internet what apology is constantly changing there's no way a decentralized routing algorithm can actually work so what we proposed is called sea route and the principle of sea road is to basically use the follow the congestion gradient or basically try to figure out ok this channel this channel is to imbalanced and ok then maybe we shouldn't go through that path and we should maybe not following the shortest path but follow a longer path to basically you know try to mean things as overall balanced often network and the second kind of a principle is that it will keep the channel balanced and the key part here is that the sea route is still at the center decentralized algorithm basically you talk to your neighbor about like the pressure you're delivering to each of the piers and the pressure information gets propagated through the network and we can basically construct a routing algorithm on top of this now the interesting thing about Sailor sea route is that it is the first ever prove what a optimal routing algorithm meaning that you know we we can prove in theory that given any kind of arrival process of their payment there is no other algorithm that can exceed the performance of the route in theory but there are a lot of implementation you know challenges and the things we need to do to carry this forward in production and there are several layers in the serial as well but that's the most important part in the simulation we have observed zeros can achieve the more than twenty times the higher performance comparing to naive rotting augers like a shortest verse writing okay so cos what in cos is a developer frameworks for the apps it is basically the protocol layer you know Liam also talked about and it is handling all the complexity for the developers to hide away conditional payments Arab state channel setup and the resolution protocol is among them and it is also bridging the own Qing and offering bytecode meaning that today how to write a of chain smart contract or our state channel application is that you write a smart contract first and which which support all these interfaces also of Jing applications and then you write a native app which also contains similar logics now we are aiming to achieve is that we hope to write one set of code right so you can just write one set of a vm code like EVM code and let the EVM also running on mobile devices and web applications to act as a real back-end for these applications and mobile devices so there's no need to write tools out of application to create a box at the same time so it is also easy to use user runtime which is a see what it I just talked about so this is like oh we talked about how to support generalized conditional payment and high performing and also the operating system side of center network now we'll move on to the see economic which is a crypto economic construct off seller and you know of change scaling or say channel achieves a huge amount of scalability but it comes with trade-offs what are these trade-offs the first day thing is a state of variability challenge which is how to make opting state always available for launching this pure right so this is like basically Chinese so Alice and Bob are transacting each other money and their newest alien sequence - with sequence 49 and Bob goes offline and what's gonna happen is that Alice can go to the channel be malicious and Sadoway oder state which is more favorable to alice centralized monitor is that that's definitely a bad solution right but what about transferring monitoring well transferring more you can do right basically by letting Bob submit the current state to a trusted frame monitoring services and the transferee monster research is trust fray because the transferee monitor serve is they will also deposit a honestly bounded choosers our contracts and you know when I submitted just malicious in terms of the trust free monitor services will submit the you know most current state buddy for the trusted free monitoring services in Mauritius the user can go online afterwards and basically claimed the honesty phone but the problem about this is that it doubles overall liquidity lockout for this interstate channel network because now we not only need to ever want to lock up money on those state channel but also need them these monitoring services to lock up money on the channel as well it creates a heterogeneous interface for state guarding because maybe sometimes you're guarding this kind of token and other kind of tokens or some other kind of intermediary state that is hard to reason about what is that the actual value underlaying does take and it is very obscure and expensive pricing model because it involves locking up your liquidity and also we need to kind of it to peer wise negotiating with the the monitoring service it's about the price and it increased incur some complex engine offering interaction and gave you finally originally inference model you're basically insured with X percent for Y price right so how do we solve this we solve this by introducing something called sellers state guardian network a state guardian network is special kind of sidechain you become a guardian by staking your seller token into the sidechain now when you're when user is going offline or a device is checking in his state what it will do is that it will stop me a state point and the state proof can be anything it can be a game state it can be a signed agreement that can be auction and acknowledgement all that stuff and the first question to figure out is of who is guarding this state that so now a randomly selected a set of state guardian will be guarding the state and the amount of state guardian or the amount of Sara talking at stake for this state is basically determined by the income flow generated by this particular user comparing to the income flow generated by this internetwork so in this case this user is paying one dollar per hour and in the internet works to receiving $2.00 per hour and the seizure is basically have a half of the state guardian covering for him and of course if you have like a more token state in this you got more work to do and therefore get overall more income as a state Guardian to perform the job to a health user card state now how this works in practice done so and it's become measures against I'm a dollar state now each of the state Guardian randomly assigned that will have a desk and a DSP lot and there is the anti-corrosion build in English process meaning that if the first day Guardian is malicious and the second Guardian can jump in and submit the state and the incentive for the second Guardian is not only just take the fee from the user but also taking the you know state guardian who didn't do his job properly all his seller tokens away basically and you know in the worst case all the state Guardians can be malicious and they can basically not dispute for euler's state and what will happen finally that all this all this so when user comes online later on you can submit a proof of malicious behavior and all the others that are talking will be compensated for the other now what is this this is actually a very very efficient the pricing mechanism combined with and you know kind of insurance model right so you know because user when user is trying to submit a State Euler is also trying to submit what is the payment associated way state so EULA can increase the level of payment to have more say Guardians regarding for the users or user can truly try to choose to like use a small amount of payment to have like a smaller amount of the Guardian coding for the state now the reason that this is a new car being insurance model is because what is started talking here is basically representing the income flow if you do the work in the state Guardian network and therefore user is not insuring against X percent but insuring with a speed to recover potential loss and if you know there is a kind of a state this kind of a worst-case happening even with anti-corrosion so this is how we solve this state availability challenge using a size gene construct effectively now the second challenge is called state connectivity challenge what is collective Turrentine challenges this basically you Alice and Bob playing a board game on state channel and and it's descending the winning proof to Bob right so basically I just made a winning move and send the proof to the Bob but Bob is refusing to science and rich quit now what do we do should Alice just um in this state who are the main King and try to punish Bob at the same time well no because blocking cannot differentiate between these three scenarios the first case is a Bob bridge quitting the second case is that alice is actually malicious they trying to submit at stage two let's say to the ethier main chain or there's no one's fault it's just in England in the in the middle there is some natural problem between them so we need a full back data exchange fabric that is a reasonably available and actually actually be able to have attribution of state availability of time and it's also cost effective and doesn't require large amount of which source from the end users now blogging as data availability service is the most straightforward answer it is definitely available like it's basically we're assuming that everyone has some availability to that's blocking infrastructure and it also have attribution of but it's time but the problem is that it incurs on gene storage and we cannot even like a you know basically purge that storage rats the efficiently and it requires oh and monitoring so we can basically piggyback the Stata guardian that's what we just mentioned also as a data availability service our data connected scissors it is reasonable available has attribution of availability time because it constructed the like sort of like a plasma and Montaine storages and therefore it solves a kind of expensive problem we are facing and it requires to actually oh I made a typo basically it actually requires a log and monitoring we can introduce similar ideas of plasma cash for this kind of a state guarding our data connectivity problem which I'm not going to detail too much so basically how it works is that it if a distinct Bob is offline Alice would just submit a state probe to Allah says they got in and that's work to and wait for timeout and later on Alice will just go on Ching and start at Ruby like one bit claim challenge with my bond if bother just respond with actual like with this if Bob respondus but a challenge was also money bond what else can do is they basically pull out the state ability attachment from the side chain and the bubble was my so and if Alice's malicious and similar state proof before the timeout actually run out Bob will observe this state and respond also in the state Guardian Network for this kind of a data connectivity challenge now we talked about the state Guardian which is compact side chain created decentralized trust and it has some corrosion resistant expose a very simple unified interface there's no additional liquidity lockup I'll create a very flexible economic dynamics for pricing and also for kind of an insurance model for your state and it also piggy back with a solution for data connectivity and your stakes that are talking into the state Guardian network and earn some service fees basically now a third challenge we have is naturally crudité challenge we envision in the future state natural state as a channel that will look like this you have a bunch of a big node which are the option service providers and smaller node which are the annuals and how station works like this right so you basically have some Deposit form each side and the problem about this is like an offering service provider can run out of money pretty soon and sometimes there's a mismatch between the offering service providers technical capability and their capability to wail out like your capitals and there will eventually result to a centralized zation which is something that we don't want and how to solve that is basically we construct something called a proof of liquidity community mining process that is to say we we try to first incentivize a stable and they'll abandon a liquidity pool for this entire network there are some recruited backer has some idol equality and they can just lock it up in the setter network and for example some lock up thing is for three years time or alcohol for three years for the 22 years and their virtual mining power is basically the multiplication of these two and the newly generated instead of talking about participated proportionally according to that now when someone actually needs liquidity they were just a start an auction process and different people will just start with bid in this auction with different kind of interest-rate ask and also with different a number of sera Tolkien will rank the these bids by interest rate first and also then by amount of serotonin so Sarah talking here in this process also act as kind of a frequent flyer mileage token kind of thing and for example this guy will finally win the bid and this entire bidding process will be a second price auction to get enough liquidity for this offering service provider to wrong and there are tons of details on how to ensure security or enhance the security of this which I am NOT going into today now we have the proof of liquidity committee mining basically my seller token by locking idle liquidity in the option platform and incentivize an abundance they pour liquid at the pool and also this is created Viking auction to actually finish this process so again we have the seller water running feel free to download it cat cat cat app but before my talk and I just want to also throw a quick vision of what we call seller network 2.0 we have seen a lot of like these things popping up of arching scaling technologies right so we have a state channel we have plasma we have a sizing which is not quite plasma like state channel state Guardian network and also we have troupis like interactive computing protocols so each of the team is kind of a working separately in different domains what we think is that often scaling solutions are sharing you know high level similar high level philosophies and they can be combined as a coherent solution as where we are already starting to see in the Saturn as well as constructor we use the sizing as kind of a part of the crypto economic construct so that ends my talk we have a you know a very good team of researchers designers and also engineers on board and we are always hiring feel free to send email to hiring at Saturn at work and it will go directly to my mailbox basically all right okay thank you very much oh yeah any questions yes yeah so I have two questions first you you have implemented an EVM here in your platform I saw it in the white paper is that still happening yes that is in the in the process you know we're thinking about doing you know you awesome actually it's okay so the UVM party is basically how can we make one set of coding sort of to a set of code for offering applications we the reason that we are doing a VM inside of like the mobile devices you can really innovative us today but what's a challenging part is to use that EVM as a back-end for all the front-end the interactions for the mobile platform right so basically we click a button it talks to not the Java code but actually the VM code so that's kind of like the processor we're doing and that's so in progress yes okay so you're not gonna implement a VM in the near future or you are going to implement EVM in the future so okay so let me just clarify that it has it has the capability to wrong generates the state channel applications implemented a as a EVM so we are in the process of like combining these two things together basically the mobile platform or a user client part and also the EVM so yeah okay all right thank you 