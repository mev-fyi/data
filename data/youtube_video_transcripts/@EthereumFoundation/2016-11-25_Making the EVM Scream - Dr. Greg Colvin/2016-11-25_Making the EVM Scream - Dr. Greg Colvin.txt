[Music] [Music] hello they're subjecting me to this again and the title was supposed to be a placeholder but George he liked it so much he made me keep it louder louder I was supposed to have a headset too so I didn't have to do this but here we are my job when I got here was to take this interpreter and make it go faster I wanted to make it scream like this this was exactly the image I had in mind there was a kid in junior high r2 just drew pictures like this over and over I love them the art teacher didn't and there's a little video you can play here this is the chip that I'm competing against there's no sound it's screaming oh well you don't get to enjoy the sound well I had it was a jet this is a plymouth belvedere it's a comfortable family sedan compared the digit it looked like this it was pathetic it was really pathetic and what was I going to do okay to make it faster the first thing I wanted to do is I didn't really know how the code worked I couldn't really understand the yellow paper some people tell me it's wonderful but I'm a machinist not a mathematician so the idea was a small series of correctness preserving transformations assuming the code was correct to begin with I make a small change and I run a test and Dmitry here had a wonderful suite of tests I'm not sure how many how many tests are there Dmitry I know at one point I broke thousands of them and I wasn't looking to make any structural changes to the machine just make just get out of the way anything that was hurting the performance a lot of it a lot of the instructions were using infinite precision arithmetic almost none of them needed to I was able to get away with 512 bits the gas calculations were being done with 256 bits the Go machine had already switched to 64 bits to the de 256 is approximately the number of atoms in the universe which I thought was probably more gas than anybody was ever going to need so in general also there was one routine which was doing all of the gas and memory computations it was doing it for every single instruction that it ran and that routine was generally more expensive than the computation itself so that was a matter of breaking it into little pieces and running only those pieces that were relevant to the routine that I was trying to run doo doo there it goes and so when you're done you've stripped out everything from that Belvedere that was in the way of making it go faster and you have the roadrunner which was Plymouth's attempt to compete with the Dodge Charger and it did pretty well yeah and this is the interpreter which is shipping in today's code the loop test it's hard to make much faster it just goes in a circle and the jet sees that circle and reduces it to almost nothing the R&G test is a little random number generator old-style news generator just as a lot of computation that's respectably faster not where I wanted it the RC 5 interpreter is the old RC 5 cipher so it's not much used anymore but it's a good example of an actual program and to get from there the approach was to start making more actual changes to the structure of the interpreter so I wanted some new faster op codes I wanted a constant pool that is currently if there's a push instruction the constant to be pushed is laid out right in the byte code it's a most significant byte first order and it has to be loaded up into the stack one byte at a time so I create a pool of pre-loaded constants I can index them with one byte and move the Bandhu to stack with a quick assignment so that's specifically a new push see instruction that just has that one byte yeah so I can just index in the other thing I did which Jeffrey is also done in the go interpreter is that all of the jumps in the evm are computed go choose how many Fortran programmers left in this room Wow three I make four that's scary it's the only language I recall besides assembly with computed go choose trouble with the computed goto is at runtime you have to check as to whether the go-to is going to somewhere valid or just landing in the middle of nowhere and that takes time so what we do is at load time we look to see is the place is going to constant is the place that's going to correct if so I replaced the jump with a jump V or a jump V I and I can just do the jump at runtime and the both the go and the C++ interpreters have found that to be pretty advantageous and so tomorrow's interpreter which is running on my machine right now and not anywhere else we're strong you look pretty good the loops a little better still not wonderful the random number generator is starting to get pretty competitive with the chip and our c5 is really doing pretty well Paul's got some work to do to catch up with me and here we have a race we have the JIT is the charger on the left and we have the interpreter on the right and make it scream roll it burn soup go there it's a video to play here somebody knows how to play it no no this guy he's a video he plays [Music] it's where a magic that's a quarter-mile deck Vitesse list they don't burn enough alcohol so that went backwards so where to go from here yeah well then to get from here you have to start doing completely different this is a blown ham I that burns alcohol instead of gasoline and these are ideas on the table we're gonna work with first just some fine-tuning right now we're using the boost library for the 256 bit arithmetic it's really designed for much bigger arithmetic so right now it's using five 64-bit words to do just for 64-bit words for the verythe mid-kick so I'm gonna look at the GMP library which we'll use just for it's written in assembly language instead of C and we'll see if we can do better with that if nothing else those four words will line up on cache line boundaries and that's always good and 64-bit arithmetic we've got to get some op codes for 64-bit arithmetic because calendars especially nobody's gonna count to the number of atoms in the universe the interpreter can only make a little bit of good use of this but the JIT can really really be helped by knowing that it's only got 64 bits to work with Cindy an awful lot of silicon on the chips right now is Cindy operations and a lot of crypto stuff can take a really good advantage of Cindy registers so we're looking at that and more structural changes right now DVM is a stacked if you want to add two numbers you push a one on the stack you push a two on the stack then you say an ADD it adds two pulls two of them off the stack it pushes another one on the stack and off you go this was like really great for hand calculators a very good way to do hand calculators real chips anymore or register machines the problem here for a chip that's the way you do it but jets tend to run in the background they can run slowly so I'm looking basically for a very fast order and algorithm to get me from stack code to register code I've done it before for a different VM a Java VM so I've got to find a way to make it work for the EVM and probably would go with just 256 registers I think that'll be enough for most purposes again I can index them with one byte so I don't blow up the code too much and the code becomes basically three address code so one byte for the operator three bytes for the source the other source and the destination and that goes backwards but gee I like that I want one of those and that's that who's next [Applause] [Music] 