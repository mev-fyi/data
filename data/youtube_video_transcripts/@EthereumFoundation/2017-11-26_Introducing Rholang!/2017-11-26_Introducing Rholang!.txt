[Music] so first of all I want to thank theorem for inviting us how this is a third year that I've been speaking at the etherium DEFCON and I think it's remarkably open-minded since since Rho lang is running on a completely different network it's a completely different approach to contracting languages and a completely different approach in general to to the whole blockchain architecture so I'm really really exceptionally impressed by the open-mindedness and the inclusiveness and that general principle within the blockchain culture I think that's awesome I also I also want to say that today is All Saints Day right Halloween is All Hallows Eve and today is All Saints Day and I want to give a shout out my 14 year old son is here today and and and this is sort of to all the young Saints who are inheriting the planet that we're leaving them and what they what they have to face and I think that the blockchain is is very much about that so with that let me introduce Rowling and the message is is it's gonna be really simple I'm keeping this as I was writing the slides I was thinking I'm gonna make this a super boring talk so so the aim is to be boring but clear and maybe you know if we can figure out a way to have fun while being boring and clear let's see if we can do that so so I'm you know instead of hello world let's do hello arithmetic and I'm gonna do like this simplest stupidest contract in Rowling and I'll just walk you through that and then and then and then I'll talk a little bit of I'm gonna introduce some non-determinism into that contract and talk about how caspere addresses the non-determinism and the concurrency inside the language and then we'll look at a more sophisticated contract and I've actually got Kent shakaama here with me on zoom' and he's gonna he's gonna walk us through the the ERC 20 contract implementation that he's done can't joined us in the summer and took over the work that I was doing on the row line compiler and has done an amazing job taking it further and then writing sample contracts to test his code so he did an example of an ER C 20 like contract enrolling which is running now and you can go play with it there's also rolling org so you can go check out that website right now and Kenta graciously put up a video of this the demo he's going to give today so if you don't don't catch it now you can also go back and look at it at your leisure and then so that's kind of the order and then we'll talk about some other things towards the end one thing that I will ask you to ask me about later is the behavioral type system right now we're going to be focusing on the untyped portion of the language or we're just not looking at the types because you type the entire language because if you get the the conceptual apparatus the types are easy okay so here's here's a simple very very simple contract it's actually a contract scheme because I've left some holes in the contract where you could put additional code right so this contract is very straightforward what it does first of all it's parametric in a set of channels Laporte so if you heard martin bzees talk earlier so he was talking about port based or channel based computational models right so that's what rolling is and it for enrolling there are basically only two things in the world there are ports and channels there we use those synonymously we also call them names sometimes and there are processes that use ports channels names to communicate right that's it as the entire ontology in this computational universe so contracts are just processes that are parametric in some ports or channels so this contract see is parametric in four channels and it does it does a couple of things in parallel so I'm gonna stand over here I like pointing at the screen I hope that's okay with you guys so so one thread of activity way at the channel x4 something that it's going to call Y and at the same time it's also waiting at the channel you for something it's gonna call V and unless it gets both of those inputs in any order but unless it gets both of those inputs the rest of this doesn't happen okay and the rest so you can see this as a kind of sequential ization and this vertical bar here represents another thread of activity okay and this threat of activity waits at the channel Zed for something it's going to call W and then does this so that in the top thread the rest of the computation is to take what it received on Y and what it received as as V so what it receives us Y and what it receives as V there's one tiny little piece of information you have to know which is that whenever information comes in this way it's treated as a reference you could also think of that as a port or a channel but it's treated as a reference and so you have to dereference it and that's what these little stars are doing and we're kind of expecting the whatever we did for dereference it's gonna be safe to add those two things together so this this operation here has to be interpretable for these two different values that are being received at these ports and then it's gonna whatever the result of that edition is that's gonna be sent on the Zed port okay and then in parallel with that that output operation there's something else that might happen that uses X and Zed okay over here it's a similar kind of thing on the a port it's gonna take whatever it received on W multiply it by two and send that send that out okay and Q runs in parallel with that output operation very straightforward nothing magical here easy to understand and in fact I've made a graphical representation of this same flow okay so all I've done is to map out graphically the lifetimes of the ports as far as we know right and you can see one thing that happens that's kind of interesting is that Zed is handed to two threads so we can see this resource is being utilized by two different threads now in in this particular example you can also see something straight away that our compiler can also see that even though there's an illogical parallelism there's actually only one thread of activity which is that this is only gonna activate if it gets something on Zed and there's exactly one thing that's sending on Zed so this is really a sequential flow all right so there are lots and lots of things that you can see just by staring at the code and in fact that's what makes rolling kind of cool you stare at the code or you let a computer stare at the code and it does a bunch of analysis for you so in particular if I remove all that pesky syntax right and just look at at the graph that that is is evident in the in the flow here I can see some really cool things one is that every contract is actually just a braid or a tangle right here that here's one a set of strands right sometimes the strands can fork right and there's another set of strands that weave across these that have to do with the information flow this making sense let's make this as interactive as possible if you if this doesn't make sense shout out I don't get it okay and then so whenever we have a weave that goes like this across that's a possible contention of resources so we can see that in fact there is a tangle across this collection of names right and so we have two in and it's literally spans the entire collection of names so we can see that relative to this set of names we have to make sure that transactions are ordered right we have to be careful about the order of transactions names outside of this set we don't care about the order of transactions and let's taste touch this set right and we can actually see that yes please yeah yeah yes know if you'll if you'll notice that this is nested inside this scope here right so it's blocked until you get both of them yeah exactly it's a graphical way of representing that barrier yeah exactly right good question yes yes the vertical bar is here that that's exactly right no it's it's it's actually true it can be interpreted as true parallelism it can be it can be interpreted as an interleaving or it can be interpreted as true parallelism thank you that's a very good question awesome okay so moving right along so we can now make a test harness for this so what we're gonna do to test this code or to at least understand what it does is we're gonna set P and Q to just be 0 don't do anything right for this and then we're going to make some fresh channels right that's what this new does and we're gonna supply them to the contract I want to supply them to things that could interact with the contract okay so here is our input section which is going to input we're at X and u and here is our readout this is going to interact with C at a and whatever the result is it's going to print that out is that making sense awesome okay so what well what you can you can immediately see from the code is that that will print out the resulting value is 6 and that's that's immediate from the code yes oh thank you that's a typo yes good good good eyes thank you I appreciate that so here is the picture of that just just in blocks so here's the input section it's running in parallel with the contract here's the output section it's running in parallel with the contract right and so the contract interacts with this test harness in this way and there's the new scope that allows us to see the origin of all the channels it's that making sense okay so we have a nice clear graphical interpretation that allows us to to just inspect the concurrency behavior of the code and just see what's going on so let's let's move right along and introduce some non determinism we could see with our eyes that there wasn't any real non determinism except at the edges right so there could have been hello just just to make that point very clear there could have been non determinism here if there were contending inputs right and there could have been non determinism here if there were contending listeners for the output but the the contract itself even though it has parallelism in it is actually deterministic in its in its execution so now what we do is we modify our contract and we add another listener on Zed okay and now these two are contending and all we're doing is if you if this listener wins you get an even value and if this listener wins you get an odd value right that's that's all that's happening this is so boring why is this guy talking about this stuff it's so obvious so so again pictorially we now have a source of non determinism because this output can either line up with the input here or the input here and that raises our interesting question with respect to blockchain semantics right how do you guarantee if I had many many instances of this very same contract running how do I make sure that they all win the Ray exactly the same way and that's the answer okay but I'll get to that in just a second because there's another important point here so I can now generalize Kay right so I can generalize my test harness and what I do is here's here's the test harness bit and that's where I put C before so I make I make a K in the literature of process calculate use the and in fact in programming language semantics in general it usually is used to range over contexts which are programs where you've knocked a hole and in general we want programs to be equivalent exactly when they behave the same in all contexts right so what I'm doing is I'm kind of sneaking in just a tiny little bit of programming language semantics on this side to keep the talk from being totally boring all right so so here's here's the context with the whole the whole the test harness with a whole knock in it and now when I apply my test harness though these should have been commas I don't know what happened there sorry about that when I apply my test harness again to see we should get the deterministic six when I apply my context to C Prime now we either get six or five non-deterministically so all I've done is just restate everything I said before in symbols by the way what should be happening is in your mind you start thinking huh this notion of contextual equivalence should line up with things like do my types and sure that my programs behave in a nice way so this should be this nice correspondence between how might the types constrain the behavior of my contracts and how the contextual equivalence or substitutability constrains the behavior of my contracts they should they should fit perfectly why so that if I were to do type checking I don't know maybe it would be the same as if as formally proving my correct why would we want to do that okay so first I want to talk a little bit about what Casper is doing and or what any consensus algorithm is doing in this setting what the consensus algorithm is doing in this setting is it's guaranteeing that all the instances agree on the winners of the races so the i/o events are the only transactions addresses as you know and love them become channels this making sense right okay and then and then our consensus algorithm needs to just worry about those kinds of transactions and it only or if you remember back to our art angle description it only has to order those transactions where you have these tangles and you can clearly see those right you can you can actually automatically observe those tangles and see where you have isolation and then and then your consensus algorithm only has to worry about schedules or orders that make sure that things are ordered in the tangles and and relative to a / - two different disjoint tangles they can be in any order yes yes the short answer is yes okay so so effectively what we what we've just done is we've now related our computational model to scaling and it's not just sharding it's actually compositional one thing I didn't agree with when in Martin's talk and I love this kind of debate and disagreement is Martin suggested he'd never never know why or when you might break into more than one level well all you have to do is look at you our eyes or DNS to begin to see why you would ever have more than what more than two levels right there's lots and lots and lots of examples on the internet for why multiple layers of nesting is a good idea and if we grow and grow and grow I don't know maybe we have a Mars colony a colony on Alpha Centauri maybe that namespaces get even bigger asked me about main spaces at the end okay so in so let me just quickly hang on one second cuz I've got a leave enough time for the demo oh yeah yeah so we started a little bit late but I'm gonna have to I'm gonna have to hold some questions because I want to I want Ken to give it to give some time to talk so I'm going to quickly just reiterate what I said and then move into the next part of the talk which is it which is a er a more realistic contract and a demo okay so yeah the the important point is that consensus ensures that every VM agrees on the winner of the race that's the computational model here all right so now let's have Euclid take a look at ER C 20 and see how that works so I'm gonna see if we can get Kent on the screen here can tu they're awesome so I don't know if the audio is coming through but if not I'll just hold the mic up to the device it's so-so so Kent and I were talking last night we didn't hang on one second I just want to introduce you we there was a miscommunication on when the talk was so that's why we he was supposed to be here physically present he's not flying in until tomorrow so we're gonna give give him a chance to go through zoom so let's see if this works now go okay girlfriend okay so just I'll repeat it people can hear okay and so as you can see here both contracts have a relatively similar structure the top here in solidity is roughly equivalent to that in relay the variable declarations here roughly correspond to the productions that you see on the right here and both contracts have these sort of function like structures that describe the actions they take on the token and so just focusing on the role and version the main paradigm shift is to understand the use of channels so greg was calling them ports earlier but they're the same thing and so as an example on here we have the channel called balances channel and we're sending an empty map through it and then on my eleven we immediately bind that mapped balances and we insert the updated balance is such that the message sender now has the total supply this is for when betoken contract is initially instantiated and so to keep things short I'm just gonna run through the transfer action here and then show a demo that uses it so in order to use this nested transfer contract you need to send a message on the transfer channel here yeah I'd receive sending it to the amount and then the return channel in which you will listen to see whether the transfer succeeded or not and so again we have a for statement here that bind the map balances and we create two new channels then this is in order to essentially get the order for the balance of the message center and I just sending it to and then in the match today admit dear we some preconditions and essentially here which I think that balances the sender is greater than the amount they said day the amount is greater than zero finally there's just overflow check this is equivalent logic to be salinity implementation and so if the preconditions succeed we go into this case and in this case we simply update the maps such that it reflects the appropriate balance is post transfer and then we return true on the return channel to signify the transfer succeeded and if the preconditions fail we go into this case in which the map back into the balances channel and then sending false on the return channel to signify the transfer feel is there any questions so far sorry any questions so far sweet okay just just show an example oh can you make the view bigger can't sure okay so is that good good better okay yeah send - so here we're instantiating the token with the with me as the owner so to speak a hundred as the initial supply and return as instantiated here that's the channel that we're gonna receive back be bound from and so once we bind the the result back into the token contract theater we can retrieve yet I'm using this get call is an area index into the Kirkland contract and we get the transfer channel and then we send from me today 50 tokens and so the important thing to understand here is that the name of the nested transfer contract that I just described here it's not actually globally accessible and so what we're doing here with this area index is we're actually going into or we're having the transfer name here the returned out of the token contracts so that it's accessible from the outside and so we have this like nice scoping kind of thing going on here and so I mean just back to the line up here 22 we just do the same thing by we call the balanced although this queries for the balance and then we just put it out here and this stuff here is essentially doing the same thing I just wanted to demonstrate that you could do this or you can instantiate multiple tokens in parallel within the same session and so we on scout using the NFC Java Cub and J labs and so on the bottom here have an SPG console session and I'm just going to run the compiler on the token contract file that I just explained here and boom we see here the output and so what you see here is called rbl rosette base language and in the future we plan to just bootstrap relay but for now we find a convenient just to you know compile it down to this intermediate language because there's a nice VM for it which or an interpreter I should say right here it has maybe an unusual syntax but it's just like any other interpreter and so what's important here is that or what we're interested in here is pasting in the compiler out of the token contract in here and that's what I'll do right now actually one second let me just have to do is have to break the mostly because of the rebels maximum input length requirement and so once we do that and copy it in you can see here this is what I just copied this is equivalent to the output here and if we ignore some warnings and debug statements we can see here the value 50 that gets outputted in 500 and so what these two numbers are correspond to the print statements here right remember we transferred 50 today so they shoot at 50 and the way they balance two should have 500 because that's what we transferred over here and pretty and so that's essentially the Burling demo of the your c 20 contract in a nutshell thank you Thank You Kent I really appreciate that so so obviously you can see that this is work in progress we're in the midst of building this let me quickly just close this out because I know I want to give back yield back time if I can okay so so - so what you saw was a side-by-side comparison of ERC 20 like behavior in row lang which is gives you a sense that the language scales up it scales up why because it's at least as expressive they're more they're more or less the same line count but you get all of these features that we we talked about before so the things that we haven't talked about and I would love for you to come up to me and talk about after the in breakout sessions and other kinds of things is the behavioral types so you kept hinting that we can just look at the program and start to see things like sharding and concurrency kinds of opportunities or behaviors the behavioral types catch that at compile time so for example the dau bug we would have caught at compile time the principal bug that caused the problem we would have caught before the code was ever checked in namespaces our our ports and channels are describable because they have internal structure they're not just flat addresses they're actually paths or algebraic there's an algebra on ports and because of that we can describe sets of names so we can we can constrain it that way and that gives us a sharding solution ro Scala is what plugs the gap that you saw there where kent was compiling to our BL and then pasting it into a Rosetta interpreter which uses the rosette virtual machine so the ROS Scala is the Scala re-implementation of the rosette virtual machine which would allow Kent to directly feed that code into the the VM and execute it and then also please come and talk to talk to us about our chain itself which is where all this work is happening and and our we're very 