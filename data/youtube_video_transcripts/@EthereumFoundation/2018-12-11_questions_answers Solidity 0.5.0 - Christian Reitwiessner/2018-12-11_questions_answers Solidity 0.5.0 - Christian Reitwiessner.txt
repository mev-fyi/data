let's see Molly's smallest tricked me into this yeah so we want you really certified zero in me something like that but then some things came up and some other things came up but we finally released it somebody to go and we even release tarah51 in the meantime so we're making progress I don't know are they already some questions otherwise oh yeah for that but I was saying maybe you should for those who were not in Def Con maybe summarize what what what is new in 5.0 yeah so most of the changes were already part of the previous releases and you could I mean zero five zero is mostly just enforcing you to be more strict more explicit about things and most of these things you could already activate in older versions with the pragma and among these are explicit visibility for functions a special keyword for the constructor or a special keyword to emit events forcing you to provide the data location of variables so either storage memory or coordinator because that was always a little bit confusing because in 54 it was different depending on the context of the variable I mean maybe I am encode an API decode that's more like features so you can now get access to the ABI coder from within your code so it time you can turn a byte array into structured data and back so yeah we have c99 scoping for Mario's now and not the weird JavaScript scooping anymore [Music] yeah but I think there was a question I really like features the only thing because yeah I try to pork my product 2:05 and there were some and why am I not allowed as a developer to cast but yes I'm not about the casting from evidence that was available so address paint was something we that was not part of the produce releases and the reason we edited was because so contract types they have public functions and the four big functions can be payable or they cannot be payable and depending on that property you can send to the contract or not so the send of the transfer function is only available on contracts and one change we did is we removed all the address members from the contract member from the contract type because they would just I mean you might have a function that is called transfer on your contract and that would conflict with the function that's part of the address type and so if you want to use transfer this is a little bit needs a little bit working out so and now this is this effect of whether the former collector is payable or not that is lost so yeah so remove the members from the contract type so you have to convert the contract to address first to use the transfer function but if you convert it to address then the fact whether you have a payable for by French or not is lost and because of that we introduce the address payable type and so contracts with the payable for work function can be converted to have is payable contracts without a table format to ensure chemical checks okay that's the reason why we introduced it and we did some testing so we we run the compiler against quite a lot of existing projects and we needed to make these changes to the existing products before we could run the compiler against it and while updating these contracts we noticed that there's not too much you have to change and the reason is that [Music] usually you use the transfer function or proton if used if you use the with dropper and then you call the transfer function or not not on a dress that is stored in storage somewhere and if you convert okay but I have one specific use case where I need to pay something to this address that was specified in the library that it was one thing where I wanted to self destruct something to the older and I had some part of the code where it says self destruct order and why do you know yeah this is the fridge okay so in general you probably know that okay most people who write compilers write them in a self-hosted manner which means that the compiler is written in its own language so in the language the compiler is to compile this creates tons of problems and just yeah but anyway even without these problems we can't do it because running the solidity compiled inside the agreement be kind of weird and this leads to a situation that we as compiler engineers don't really use the language a lot and because of that we always are happy about any feedback that we get from the people that actually use it I think I talk too much right there was another question what's there so walk first up guys all right you explain to the point of view what you what about y yl with dewpoint so that's something I notice in your talk yes you are saying something like F or perhaps I got it wrong but it's something like we still need the EBM and so UT due to some reasons and whoever sembly will not destroy it yeah and the thing is the reason for you is to be able to compile welcome right okay so so we're preparing for I've been already over a year now to compile some identity webassembly and you see to be good step to go there and yeah I mean if you say you will and you mean solidity in that assembly that this is another use for it which allows you to write more low-level stuff that is not language yeah the other use of you is as a intermediate language inside the compiler and the cool thing is so with zero five zero we get impacted on topic with zero from zero we disallowed the so called loose dialect of inline assembly or of U and the strict version so the difference between loose and strict is that we lose in the Neuse version you have direct access to the stack you can run can use op codes that manipulate the stack and in the strict version we only have variables and function actually and this fully abstracts a way yeah whether or not there actually is a step and whoever simply does have an expression stack but it's yeah different than so yeah it also has native function calls that because if that stack is different from the one that is used in EDM and if we introduce you all as an intermediate language then everything will compile to you and there we don't use any features of the EBM and exactly you don't use the stack and because of that we can easily compared to both webassembly and yeah I just want us to be having this lesson this license file serial - which replaces your point four point whatever or are they going to get along together always my part was meant to take over through my wife as well so we have no plan to maintain older releases I'm not sure I understand you're left with your question so so your boys over there won't be any pet releases for 0 for X and we had no release for six months and that was because we were afraid of preparing for the record range so that was one of the media tactics release but that was just to fix a very important so more questions so to use say something how did inheritance structures just worried because this changed quite dramatically [Music] I saw that you're now able to inherit the generator so it used to be that automatically generated kettles don't comply but what I also didn't see is that you can inherit we didn't make too many changes to inheritance actually so the getter functions might have been one of the smaller changes and actually in zero five one we added another change that about more function overriding I think that the main reason that allowed getter functions to override interfaces was that interfaces are now required so interface functions not external and cannot be public anymore and we allow a public function to override external functions but that's only I thought that was only part of the fun does we have some more question maybe one last question the perhaps one word on inheritance in general so we plan to do an overhaul of inheritance at zero six zeros and this and the idea there is not to change inheritance model in itself too much so we will still keep yeah Python easy three linearization multiple inheritance model it's more like it will be more restrictive so especially when it comes to over writing so you can't just have two functions in coming from two different base contracts for function of the same name and you will have to solicit estate whether you want to be most of what you just said so what is sustained or what's going to happen with represented I mean I heard fasted there was some plans that in the end we will have different charts on there and some will run on the EVM and some will run wasn't because I guess converting serenity contracts into wealthy is not really an option so I just would like to know how it will all work out like the coexistence so on the silliness aside the plan for next year is to be able to compile to it wasn't so that's not a problem on the same side so I mean the compiler just will generate some bytecode and you can use it on on every chain and on every side chain whatever you want yeah I can't really say much about the adoption of web you mean it or if you're into Punahou yeah I'm personally but worried about claims about performance because that hasn't been really British yet but we'll probably be faster due to it having native functions and yeah yeah but you said like yes they are from four to five there's quite a lot of changes in the language and I would be interested to add a couple words of wisdom how you handle you know like potentially compensability working changes what how did you handle that how did you yeah how did you manage that I don't know so I'm not sure if I really have a question but I can say something about breaking changes I mean there there are different types of breaking changes there is the one breaking change which is it just makes so a contract that compiled before does not compile anymore that's a easy breaking change but there are so there are some breaking changes also between four and five where the contract complied before and it still compiles but it's behavior changes and these are tricky and they should be kept very very based minimum and everyone using language has to know about them I hope that's the case yeah what's that basically a question yeah as far as like did you document those changes for example that those second kisos there's a we have a dedicated page in the documentation that says these are the changes and this is what you have to do to your source code to update it to the compatible zero-five-zero so I hope that documentation is enough for anyone if not then please talk to us we didn't get too much feedback on that yet so I'm not sure a particular at that time when perhaps also some new tech information that came out of the audit we lose a hand made whatever that was made they said we should make breaking changes more often we don't have a specific plan yet but we think about perhaps every two to four or six months yeah let's see how that there are there is at least one contract that does not compile anymore or at least one contract who is semantics change it's just about the source code so if they have to deploy it and it's not source code anymore it's byte code and the error breaking change is a hard for visit so that's out of the scope do we have another question okay I think the question answer session is over for now thank you so much Krista 