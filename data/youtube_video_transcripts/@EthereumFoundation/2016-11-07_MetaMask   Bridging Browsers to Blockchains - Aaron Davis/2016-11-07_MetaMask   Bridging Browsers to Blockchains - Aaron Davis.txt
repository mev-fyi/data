hey how's how's everybody doing I'm Aaron Davis I also go by Kumho vez whichever you prefer and today we're gonna be talking about meta masking and how we get aetherium into the browser so our core our core goal is ease of adoption and one way we we sort of measure that is time from first account to first ether to first transaction and I'm going to bring Frankie and Kevin on to talk about that yeah hello dear devs let us make you roar about medam made by us for I'm sorry okay this is not good okay oh yeah okay sorry a browser extension for Chrome and more but there's even more browsers and mobile coming up in store meta mass index pages what green your page is real lazy webbed apps running in a normal browser that's crazy there's no need for a local full node first-time user you've hit the mother lode we protect you with contravenes so that you don't lose your ether like spilling the beans on top of that here have some wallets to hold all that either so that you can haul it we love the apps ether needs them in stacks give us more of them like flapjack I don't have anything else to say so here's Frankie yay um thanks Kevin hi guys I'm Frankie and I'm going to talk about meta mass from the user experience from first installation to dap use to first transaction louder even louder god okay we are live on the chrome store so user goes and downloads meta musk and we create a vault it is a deterministic keyring I had to remember this this morning after copying the twelve words C phrase to a safe spots we now head over to token factory which is a DAP that generates your own tokens we go through we fill it out we hit create token and our beautiful meta mouse confirmation screen will pop up and you can either accept or reject it now in the case that you don't have enough either a by ether button will pop up and you have two options if you're in the u.s. you have coin boosts or you have shape-shift very simple just enter your email in confirm your email enter your phone number confirm phone number and then enter your credit card trans or credit card information this has a five dollar a day limit very and goes straight to your account unfortunately when you get there you can accept and reject once you've gotten your either will hold the transaction and voila you've created your token unfortunately though if you are not in the u.s. you don't have access to coinbase so if you guys know any products or are working on something that offers fiat to ease that would be amazing please come talk to us we would love to hear from you our status right now is public beta we have we have done 44 releases since March we have weekly updates we have over 2000 users and 14 million RPC requests per day thanks to and Fira we are chrome live opera edge and Firefox we are pending and ready we're just going through the process of getting it into the extension storm unfortunately we won't really be pursuing Safari they don't follow the extension standards and as far as mobile goes it's hard to get we really don't have any mobile browsers that support extensions and now to talk about how it works I'd like to pass it off to Aaron no no no we're cool so minam asked how does it do that so yeah you wanna you want a theorem in your browser so just take an F theorem client and throw in an extension right unfortunately that won't quite work you're blocked on networking the networking uses TCP UDP you don't have access to that in the browser even in extensions so what are you gonna do inside oh yes also for the kind of adoption flow we're looking for the mandatory sink time is kind of a non-starter I mean the light client protocol has improved that significantly but so what are we left with we can do RPC against a trusted node where we'll run the nodes for you and so you have the zero sync time what do you do for ID management we do RPC interception so anything like send transaction or said signing a message that involves usage of private keys we intercept that sign the transaction and pass that on it's a raw transaction to the trusted endpoint so here's a little chart of how it works you have the user at the top they're looking at the gap in the browser and the meta mask UI the DAP has the UI code in it as well as the web 3 injected by meta mask much like you'd see in mist the web 3 generates RPC requests that are forwarded on to the background this goes to the provider engine which I'll explain in a second and and onwards on to the trusted RPC so the provider engine is a tool for making your own web 3 provider it's basically a stack of RPC handling middleware might look something like this you have a cache layer for example if you're asking for the balance of an account twice in the same block it's it's going to be the same you don't need to hit the network for that then you got your idea man you management that's where your private keys are and then the rest of the data lookups fall back to the right to the node a node on filters and load balancers filters you install them and then you check them you pull against them as soon as you start using a load balancer like we do where we have a bunch of get nodes you'll you'll end up installing on one machine and then checking on another but this turns out to be something that's pretty easy to simpl pretty simple to solve in the provider engine level so meadow Maps has a bit of a different trust model then say myst because we provide out of the box by default these the trusted nodes the yeah the trust model is different but we could add optimizations and new features quite easily using custom API but we want you to be able to switch over to your own local node at any time if you want so we use 100% RPC to maintain that standard again if we use custom api you'd kind of be locked into our metamath servers and we think the lock-in sort of devalues the product and now Dan's been talked about the lessons from working with Def developers thanks Aaron hey guys so since we make a product that injects web 3 into a browser we get to talk to web developers pretty much all day and that's great not just web developers web developers and so we hear cool projects and that makes the job very inspiring and a lot of fun and also we end up being kind of the front guard of questions and and completely you know frustrations and and things like that so I'm gonna talk a little bit about the lessons and things that we've learned about the expectations of a web developer in the context of writing aetherium Web Apps so web 3 right now it's your portal to the blockchain so it's so cool but right now it has a very constrictive API surface so it's we we want to find ways to make that do what we want a one way that it's kind of opinionated right now and it may not reflect the the truth of a blockchain is that it kind of has a single callback nature right we we've got callbacks we've got pudding to wrap things in promises but these these paradigms that work well in web development where there's a single resolution aren't completely representative of the the kind of statistical certainty of a blockchain where you might have a single confirmation but you you don't know how many blocks forward it is or how many additional confirmations there's a lot more there's kind of a gradual trust process so so yeah if you if you want one callback you're kind of trusting it but what else could that look like well coming from JavaScript and node sometimes you might want like an event listener so this is a kind of suggestion this could be done as a layer on top of web 3 but it could be optimized much better if it was implemented at the RPC layer so in in this case you might get an additional callback whenever there's an additional confirmation or whenever there's an additional block or maybe there could be a callback when there's a fork in the blockchain because right now the RPC doesn't really give you any indication when there's a block fork short of you querying the latest block and going back because you're querying by block number not by hash so so for an RPC trust and client like like a web browser you you you have to you have to pound your server very hard just to answer these very basic questions and these are things that the user interface should reflect anyways also web developers always want to just query the database and some things are very simple questions in you know relational databases but end up being very difficult on the blockchain you might consider the case of a decentralized Twitter you just want the 50 latest tweets the current basic model is somebody basically querying all the tweets in the in the blockchain you know a lot of developers are coming in and they're saying oh the cheapest gas thing is log so I'm just kind of use logs as my database and then the method is basically logs since the Genesis block and now the server gets every tweet of all time and then sends it and it all gets loaded up in the browser which is the interface thread which then does all the sorting of its it's impractical right so so what are solutions to that one solution is to write your sorting logic in the contract layer and so now it's it's kind of inflexible and it gets a run on the chain it's still one batch but you know you could write some some kind of pagination logic maybe there's a cool I pee out their 144 which would let you send some custom bytecode some evn bytecode up to the server that it would run so you could actually request like a custom results for the state tree that's an interesting one I encourage you to check it out there on your two cents oh there's also a another idea like maybe there could be an additional method on the RPC like a sequel like query method but this kind of requires like indexes so maybe we need you know incentivized indexes because you know logs aren't incentivized indexes maybe they could be a contract maybe we should have standards around those those could be helpful sometimes people ask us why is this method not acting like death and it turns out that there isn't really a standard right now we go to the wiki and then if that doesn't do it then sometimes we have to go to the individual github repos or oh it turns out they were using parody there are fine distinctions and there isn't a singular source of truth right now so I would just kind of like to take this opportunity to say hey how about we develop a web three standards body maybe we could be decentralized and cool on a blockchain or something have boats you know have a may be signing keeper implementation and they could say we definitely support this implementation and maybe they could be on chain validation I don't know whatever I'm sure you guys have lots of great ideas about that mgn is a great implementation a great example of a standard documentation so that's the the time I'm gonna spend on that now to talk about the future of meta mask here's Combe obvious Thanks hello-oh the future in space so one thing we've been asked for a lot is multiple account types right now we just do the deterministic keychain and that's nice really easy to backup and recover but people want to use a proxy contract identities like those being developed by you port maybe remote key stores like you have coinbase hold your private key and we use an API to get it get over there that's that's in the near future also there's some some experiments coming from the ether mgs community like turning the browser into a light client by having a separate web RTC based peer-to-peer network and some bridge nodes little experiment we've been working on this they if they're in transaction visualizer visualizer yes it looks a little something like this this is one of the dau attacks and so when you play this one you can see it spiraling in this circle using that that attack vector and so my favorite project right now is this little thing we're calling mascara and it's a sort of a polyfill for meta mask so if you have meta maskings oh yes so it's it's a little JavaScript file you just drop in your DAP and if you if you're using mist or meta mask it works fine if you and if your user doesn't have met a mask but you have mascara installed it'll work just as if meadow mask was there you'll get a little pop up with your identity management the keys are stored in a separate context of the DAP can access them we still assume the DAP is is a you know potentially evil actor and likewise you can any DAP that that uses that polyfill can have you know send transactions that thing in your accounts are already there so thank you very much Thank You team Mehta man 