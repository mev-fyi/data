so I guess we all agree that it's really really hard to write 100% correct code regardless of whether this is a smart contract or any other piece of code and but what does it actually mean to write correct code what is the word correct mean and I think that the best explanation is that code is correct when it does exactly the same thing as the the programmer intended it to do so the mental model of the programmer about smart contractor about the program is the same as the what the the actual machine does with the program and for aetherium this extends even more because we do not only want the the expectations of the programmer to match the actual program but we also want to match want to match the expectations of the user to match the the actual execution of the program and so how do we get to that point and there are of course several well-established techniques and one of them is to - yeah right use testing unit tests and that's quite easy - easy to do you just think about a certain input and make up your mind about what you're expected to happen and then run the program and see whether that actually happened and that's good - to check whether desired behaviors actually there but it fails to show that undesired behavior is absent so you cannot use unit testing to show that it's impossible to withdraw money from your smart contract by a malicious actor and the reason is because you would have to check all possible ways to call the contract and that's an infinite number and yeah testing can only do finitely many cases let's let's so yeah and but there's solution to that and it comes in the form of formal verification and let's take a look at an example there so this is an this is an easy token contract which has a balances mapping and a function that allows transferring yeah balances from one account to the other account there is a tiny error in there I'm not sure if you see that and I would argue that so yeah testing can detect that error but most people probably won't think of this specific input that is required to trigger the test or trigger that trigger the failure so you know what's the problem here it looks correct but it probably also will work correctly for most of the token contracts out there but what it fails to test is whether there's an overflow in the in the in the to field so if if the amount you want to transfer and the amount that is already there in the target account sums over 2 to the 256 then we get an overflow there and the the mechanics don't work correctly yes so and form of verification allows us to ask questions like is the sum of all balances unchanged by the transfer function considering all possible states of the contract and all possible possible inputs of the function next so how does it work in general so you you provide formal statements formal mathematical statements about the behavior of a contract and then you use mathematical proofs to show that the code satisfies these statements you can do that manually but since we live in 2016 there are all there of course automated prove us to help you there and find the the mathematical proofs but so one thing I want to stress here is that form of verification is not a silver bullet the reason is that so the source code so a programming language is already a formal description of a program so and adding adding formal statements in another language or completely formalizing the behavior of a smart contract will not really help because as I said in the beginning it's all about the mental model of the humans so the the key goal in using formal verification is to reduce the complexity of the smart contract we use source code to describe how an algorithm works and how a smart contract works and then we use formal verification to describe what it does and the idea is that this what it does is easier to understand and how it does it and another another great thing about form of verification is that we can ask questions about the behavior of the program so it's not only about formalizing it in a kind of a specification but we can also just add to that and ask questions like is the sum of all balances fixed and if there is some way to modify the balances so that the sum is not fixed between two calls then the system will tell us or yeah we can also ask questions like will a smart contract gets taxed so is there any way to to send messages to the smart contract to call functions in a way that at some point it's not possible to move forward in the in the states of the smart contract or it's not possible to get the money out at all anymore so yes former applications coming to aetherium there are already a lot of research papers on that topic and the reason for that is that block chains are actually a paradise for form verification because yeah the the model is that simple but you eg later will tell you more about that okay and for verification tools also exists for kind of common languages like C and Java and adder and these there are and the way it works for these tools for framesi for Krakatau and for SPARC is that you write your your program in the the ordinary language you're used to like like C and then you annotate this source code with formal statements so like some of balances is fixed between two function calls and then there are tools which compile both thought the source code and these annotations into a language that can work with the annotations this is often why three and more recently we have F star and then automated provers are used to verify these formal statement on the translation of the source code let's take a look at an example so this is this is from a C and you see that no no pointer so you see that there at the top there is a block of comments with these formal statements and then at the bottom you have regular C code and you also have comments inside the C code where you can refer to the state of the program at that point so yeah and yeah now yuuichi would take over and so he which is a form verification engineer who recently started at the etherium foundation and he will focus on extending the follow verification features of solidity how do yes so Christian started the solidity to wine 3 translator that see me that framesi but for the smart for our smart contract language so ready tip I extended the framework so that it can deal with arrays and it can deal with a simple token contract with just one transfer function the contract itself is it has a transfer function you can specify the from address to address than the value some balance is changed this is the same thing as Christian showed before it has the same problem with the buffer no integer overflow the to correct the complains if I don't specify that the total balance is less than a certain big number otherwise that complains next slide please when the smart contract has a problem which window like this this is why 3 GUI y 3 is front-end for dozens of automatic and manual theorem provers on the left side you see lots of conditions desired conditions like no integer overflows no buffer of those and so on you see many green ticks the green ticks on the verified conditions and wise we can automatically verify most of the properties but you also see some blue question marks the blue question marks are on unverified conditions was the still doesn't know if these questioned properties hold or not when you click on one of these question marks on the right pane you see yellow highlight on the suspicious piece of code the code is a translation of the solidity contract into y 3 y ma language that's a language for wisely and here the highlighted dyeing is subtraction so in this case this might underflow and when you see such a problem you can either modify your program or annotate your program more and more annotation is direct putting assertions in the program and if you put enough assertions to satisfy the automatic reverse the automatic reverse a green cheek but in many cases you just find problems in your specification so it's about adjusting your own mental model next slide please so before finding a theorem I was looking for a place where formal verification actually makes sense before the university I joined a Research Institute my job was to spread the formal methods into the industry but I didn't have any access to any company's source code so it was hard for me to do that so I joined a company that hired formal verification engineers that was a US company I had eight colleagues write improves we're a wonderful environment but I was not happy because our proofs were not about the weird thing the fundamental program is the real CPUs come with documentation two thousand pages done and nobody has ever translate translated the whole thing into any theorem provers so that was a huge problem we couldn't solve I found the theorem I saw yesterday on virtual machine I saw the yellow paper the specification it has only 32 pages drawn and I thought I can actually translate this thing into a theory improvement I can write proofs about smart contracts I was doing that and I was posting the partial results on reddit and the christian found me and I ended up here so different virtual machine is wonderful because it has a small specification and this more specification really matches the reality because all clients try really hard to match this specification otherwise one of these clients would behave differently from others and that the worst thing they want so they really want to be component to the specification and a small definition that matches reality is the fundamental necessity for former village engine engineer I found it in a theorem next slide please we have some future steps so when I'm extending the solidity wise reframe welcome there are some immediate problems like oh we don't have the chorus instruction yet in translation or we cannot deal with mappings to mapping in wisely in short on that account way because of this we are thinking of moving - if start if starts something similar to y3 but it has more advanced features I want to thank Microsoft for open sourcing if and also g3 SMT solvers we all extensively use it thank you very much but each item we have more problems to solve than just verifying one solidity contract I think we are moving to many small contracts than one monolithic big contract so we have to be able to reason about much cooperating conduct contracts and then just reasoning about solidity code is not enough because what runs on the blockchain is not a solidity code but a compiled by the code and sometimes the compiler has bugs so somehow we have to know how the bytecode behaves whether it's EVM or the IBM it's the second one so somehow we have to do that but that easier than most CPU architectures out there so I think this is a solvable problem the next one is much transaction conditions so currently the precondition post condition invariants on the contracts just on one core it can already did with the re-entrance II but from the first quarter dust return and that's the range of verification we need to extend that and then yes combination with off chain protocol this is harder because the moment we get off the blockchain behavior or you are not constrained by clear words so what's good for people is not very very defined but somehow we have to define a game where it's in the players interest to coordinate with the rules and the formal methods can help because it can explore all possibilities of interactions the last point is rather practical so you saw some question marks but just a question mark is sometimes not enough for me to understand the problem so it would help if we can see counter examples like with this input with this state this is broken and then it's more easily understood but I see I believe many more formal verification researchers are coming to the verification of very smart contracts because of the reason I mentioned the 3m virtual machine is with a paradise for formal verification engineer thank you very much thank you you 