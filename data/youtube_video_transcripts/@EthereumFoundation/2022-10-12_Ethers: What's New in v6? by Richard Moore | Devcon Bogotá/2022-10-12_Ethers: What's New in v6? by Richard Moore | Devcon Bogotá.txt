foreign [Music] okay so my name is Richard Moore I go away Rickman online and so I write ethereum a library called ethersjs um so what is ethers it aims to be a complete compact and friendly ethereum library that developers can use but also part of user friendliness is safety like you don't let user don't let the developer do things that like bites in the ass without realizing it um so one of the cool things is the default provider I don't know where I should stand so with the default provider will haul basically it lets you just connect to ethereum um historically you had to either run a node or you have to like sign up for inferior you have to do something to start using ether ethereum right away so we've got like a bunch of relationships with these third party providers and right off the bat you can just connect to ethereum start doing Simple Things it's heavily throttled but you can at least do something before deciding whether you want to like get your own inferior ID and all that this is all the old stuff so I'll just go over quickly it's written in typescript now very few dependencies um 26 000 in growing test cases ens is a first-class citizen everything including all dependencies are MIT licensed and there's extensive documentation and in V6 the documentation is getting much better um and an important thing is to understand like I made ethers because something I needed and something that I use a lot and so I mean it's in my best interest to keep it getting better over time and that sort of thing I think dog fooding is very important to keeping a library good otherwise you get a library is very good at hello world but very difficult at anything more complex so modern so getting into the new things than V6 that's coming out there's currently a V6 available um both on npm and GitHub uh it's still very beta but it's there to try out so one of the biggest features is modern es features um currently V5 it targets ES3 so if you are trying to run ethers in IE 3 from 2002 it'll probably still work mostly but that's no longer a priority and so the goal is to start adding um kind of like new age JavaScript things heavily reduces the code size because rather than having this big class for big numbers you can actually just use the built-in big numbers that JavaScript now provides you um so uh I mean you can now use like the equals equals equal sign which is super exciting if you want to use a big number you just put an n on the end and that tells JavaScript this number should be treated as a big literal uh don't go doing IEEE or yeah IEEE 754 truncation to it and and that sort of thing um I'm trying going to try to go through this faster ish if I'm talking too fast let me know but basically it'd be nice to get to the end so people who have questions can ask questions so another really cool feature that uh modern JS offers is proxies for those that don't know proxy is basically and are are an object and if you call a property that doesn't exist code gets to run first and decide whether or not it should let you think something exists and continue so this heavily improves how um the contract object Works historically you had like a ABI with multiple different um signatures for for different methods it really required you to understand all the rules for how formatting Works to normalize the signature in order to access it so now you can do whatever you want so like basically you can have all sorts of white space extra little letters and and whatnot in there and this will all figure it out at runtime and map it back into that and get the right thing for you basically for all those people who've ever had duplicate ABI definition errors and have filed an issue saying how to get rid of them this is for you typed values are another cool thing so going back to the same situation where you have uh two different methods Foo and Foo and they take in different things in V5 there's no way for it to know which one if you pass into parameters an address looks very much like a number of 160 bit number but it looks like a number there's no way for ethers to actually know which one you meant to call and so now you can do uh so you yeah so this would be an error it doesn't know what this is this looks like it could be a number this is a perfectly valid u in 256. so now you can force it and tell it that it's a typed object of an address and then if you do this it'll automatically know oh this is the one you wanted so again really cool things we can do this is sort of related to proxies but kind of its own thing likewise if you have um if you're doing programmatic things sometimes you just have a bunch of keyworded objects and so for example you've got transfer from it's got an from a two and a value so this is how you would do it in V5 you can still do this in V6 this works fine using positional parameters for those that are used to python they call them positional versus keywords but now you can also do types.keywords and pass in a from a two and a value and it knows that those things should get deconstructed into the from to some value this order doesn't matter either if you wanted to construct this object from a bunch of other lines of code reading stuff in you can just build an object up and add a two if it's not null and out of this if it's not that um and then it's Off to the Races okay another big thing uh is things are now classes okay I'm down to 19 minutes um so things have class basically um oh yes so I'll dive into this a bit more because I think this is a really cool feature in general of something we should be doing more in solidity this is kind of steering away from ethers specifically into more solidity generically if you're using V5 a signature is literally just some dumb object it's not a class it's just an object with a values r s and V and that's all you get by making it a class it can take in anything whether it's a like a raw signature or whether it's an RS and Y parity r s and v r and Y parody are are y period s whatever random combination of things you have feed it in it'll figure it out give you back the signature you want and then if you do something like update a value if you said for example Sig dot y parity equals zero and it used to be one it'll also change the V for you it'll update all the why parenting s it'll it'll reflect all the changes so that the signature stays consistent which means so you can get all the stuff out of it and that sort of thing but the cool thing I want to show off is um maybe I'll come back to this in a second that's how things are done today um maybe I will explain this quickly so those are the things are basically done today so this is basically people that pass a new signature for um first solidity for doing easy recover on they pass into bytes or they deconstruct themselves so that'll be the third slide for now but they'll pass this bytes object in and then you've got this expensive weird byte manipulation Library I mean it's well written it's by open Zeppelin I think but you're doing a bunch of string manipulation on byte arrays to figure out where the RS and V sit it's also a huge amount of data otherwise and then this is what your code looks like the cool thing with these new things are classed you could for example in your code have a signature that has an R an S and a v and then you can just use the Sig type from the struct and this is your EC recovery so historically you might have also seen a verify that takes in a byte32 digest a bytes 32 V bytes or sorry bytes you went eight V byte series who are by Sergio s and go off the races but with this you can kind of pack them all together this is the same size for the ABI point of view and then you just pass in the signature and because it's a class when it's starting to build out that encoded piece of information it knows to take the r and pack it together with the S impacted out the v in a nice compact format and then you're off to the races so one important thing to note with this the next slide is this line here bloop does not change and so you see you're still creating a signature you're just passing the signature in verbatim and um yeah basically it's because the ABI is encoding it it can look at this object and figure out okay I need to take the difference in this case is the r and the Y parity and S for those that aren't familiar with um uh EIP 2098 basically this allows you signatures are much bigger than need to be so basically you're used to RS and V that V is actually just one bit and thanks to Homestead uh every s value in ethereum is actually always got the top bit set to zero so we kind of just like slot that in and now your signatures are 60 30 smaller and uh yeah again feel free to ask questions because these are going to be a little complicated but you need a little bit of more math to help decouple that I'm going to bug the the um facility guys to see if we can kind of get this built more into solidity so you just pass in the signature directly but in the meantime this is still much simpler than the like couple dozen of lines of bite manipulation byte manipulation libraries that's going on um if you pass into bytes um so quick comparison so if you use the raw bytes like most people do today it's 160 bytes which is by itself just for the call data is 144 gas expensive so if you use decompose that's 96 bytes but if you use the compact representation it's 64 bytes um yeah I'm not gonna go to more than that uh that was just a quick thing for people who are looking at the slides afterwards transactions are also now an object so if you decouple a transaction if you just feed in a bunch of raw like a raw transaction object or a bunch of stuff if you start updating the stuff it updates the other parts of it as well um yes basically when you have just an object and you set some property on it you're only opening that property but with this when you set a property it sets that property but also updates all the all the entangled properties for example if you set the gas price then the serialized version of that transaction should update um and you can just set things you can set them to anything that's valid you could so in this case I'm using a bigint but you could pass it a string you could pass in a hex string pass in pretty much anything you want that makes sense for a Max fee per gas and it'll be reflected uh 13 minutes bits so this is just a little odds and ends of like random things so pausing providers so for example a lot of people find that people keep their their customers keep their their app open in a tab that they're not even looking at anymore which means that their events are still firing it's still hitting the inferior gobbling up all their all their requests um well because there's now these visibility apis available in browsers you can tell ethers by the way when when I'm not visible anymore pause the provider um that way if they go to another page for a week and then they find that tab that's left around from like a week ago or a month ago or we all have really old tabs um this way they haven't been consuming your your bandwidth every time that you've been they've been doing nothing with your site so you can pause your provider and then when it comes when the tab becomes visibly visible again you can resume and you get the choice of whether you want to replay all the events that would have happened during the time that was paused or whether you kind of watched you just drop them and keep keep on going both situations have like valid use cases so up to your own personal use case um uh the cool thing with this feature is because we can now pause and unpause uh providers all the underlying API and framework changes that went into making this happen it means that if you have for example a websocket and the websocket disconnects it can now reconnect and re-subscribe to all your events before it starts feeding you the new events that start coming in it can actually get the events that happen from the time it disconnected from the time that is now and so all your events come back in order and you don't miss a beat and you don't even know that your websocket crashed um and ordinance um I'll just go to these quickly basically networks are now a plug-in they have a plug-in system there's a lot of really strange networks out there and I always get like requests saying like oh my network computes hashes in this strange way or my network doesn't doesn't have an author in the block or this sort of thing in the other so this makes it possible that ethers can stop capitulating to each of these individual things and all those all those Oddities which are fine I mean you know competition ecosystem is good but then we can like push all those differences into the uh the network object and let it handle it foreign package exports I'm moving away from a mono repo which uses a bajillion sub packages all by ethers because it used to be like at ether's project ABI Addie's project providers and that sort of thing package exports are awesome they're supported by all major bundlers now and it means that there's no complicated weird process going on for ether's build for those who've used ether's or tried modifying ethers at all the build process is absolutely insane because I try to Target again ES3 and react and I try to build for everything and as a result people who are using more modern utilities like uh people complain about Vite a lot or if you're trying to build a bundle for node it just fails so the nice thing is by using package exports instead of all this crazy custom scripts it just kind of works with all these tools and everyone's happier um I hope we'll see that after I launch the non-beta um there's better and fewer dependencies I'm actually going to grab a bit of water um so yes there's basically I think I'm at five dependencies ish right now but down to four authors um which is an important thing I feel like we've all seen we've all like recently been pretty worried about like uh supply chain attacks going on from mpm installing a bajillion things and so right now there's four well-established authors that are responsible for all the library so there's me I actually myself well established there's uh Paul Miller who does an awesome library for hashing and for signing and Microsoft writes TS lib it's a tiny little thing it just helps save some space and websocket there's a popular websocket library that works in node if you're using a browser you don't have to use that one so now you're down to like three authors and and four dependencies um and it saves me a lot of work as well because there's so many times where like elliptic has some bug in it and I'm trying to track down on him to get him to update things and once that's fixed I now have to update everything and put a new build out so the fewer dependencies the the happier my life is as well and that's all I've got I've got nine minutes for questions if anybody's questions oh and come find me afterwards I've got these little like ahiva I brought one up for anyone who's like curious about V6 I've actually started to write oh I should explain that so yes basically I'm trying to write a bunch of little apps right now against V6 to help test it um so this one's actually found quite a few bugs already um it's an nft it's got a little scratch off hologram when you scratch it off you can scan it and claim it and you can you know fold your little papercraft robot up and like do this and then take pictures of him and post it into the contract and you can like I'm thinking more of like that little gnome from Amelie you know you can take it around and show you those things visited different places um right now it's only deployed to Gourley for anyone who actually like goes through the effort of like submitting this I will be migrating your tokens to mainnet um if you want to wait till the main version launches the same QR codes will work on mainnet and you can claim it there um so that's just like a little demo I'm flirting together to to test and make sure V6 works and it's definitely not ready for production as it stands right now but it's getting closer and I'll probably be doing a few more little weird projects like this just to kind of like find those little foibles and and things that happened during the last two years worth of rewriting and rewriting and rewriting so I've got 7 Minutes 49 seconds left for if there's any questions out there I don't know where we'd be without you like open source hero thank you at this point in the state of ethereum at this point in the state of ethers what kind of support are you getting in terms of like uh audit help especially as we see more like front end attacks and things like that right where it's like you know smart contract auditing is important but the interaction layer is equally as important especially now as people are getting more clever like like you know not to not to throw shade but you know like when I saw uh you know string normalization for for ABI it calls you know I instantly thought like just made me like uncomfortable in my gut of like different things that could happen so just curious like um like who's helping you audit who's helping you kind of like comb through this code and go through uh different edge cases and things like that right so basically the auditing is all done by me which is terrible right now one of the cool things though is between I've got like oh sorry the EF helps sponsor me um I get GitHub grants get coin get coin grants a few sponsors and so now I'm starting developed an endowment so I am hoping to be able to get like a proper audit at some point there was one team at one point that was going to formally verify a bunch of things um I I've heard from them in a while so I don't know if that's still a thing but uh I think foreign verification like it helps in some regards but it's not a Magic Bullet I think absolutely like proper auditing would work and I'm also a big that's why I'm a big fan of tests I don't want issues to happen um so I feel like test I mean tests can only find the presence of bugs not the absence of bugs um so I mean it's a great question talk to me afterwards if you've got some ideas uh I'm starting to get some money off to the side now that I can actually start throwing if you know any like auditing firms that do typescript um what you mean should definitely pay for auditing those people are so skilled and valuable oh okay sure well I mean you kind of are I mean you think you get coin uh bitcoin's been awesome so I was wondering if you are gonna add um this version uh do you sorry it's a little bit hard to hear with the echo are you guys know about batch Json RPC but transactions sorry oh bash transactions um what which means by bachelor's actions like via Smart contract wallets like by you mean through smart contracts or yes yeah yeah I mean that all already Works uh you just need the ABI for it um there's not currently in ethereum an official like batch standard um but you can do with smart contracts like smart contract well it's like a gnosis safe for example allows you to send mobile is that I'm sorry is that what you mean like being able to send multiple transactions at once an atomic atomically I have an application and I was I I want to to send a bachelor structures in my node application not through contracts okay after contracts um so that you can't currently in ethereum in general send multiple transactions atomically or at once um you basically if you will have a bunch of transactions you're trying to send serially um so the Nots manager already does that uh basically it's a wrapper that goes around assigner and you can just quickly fire off transactions and it will automatically bump up the nonce from the initial amounts of fetched um there are some issues with that as well if you just you know flood the mempool with a bunch of transactions from the same address that are all serialized uh it could be seen from the Network's point of view as a Dos attack and so it might drop them so that's a feature I want to add to the nonce manager in V6 as well is kind of the ability to rebroadcast or whenever something succeeds kind of like have a callback that lets you know something succeeds succeeded and so you can kind of nudge or tell it to rebroadcast the transactions that are still around hey Richard uh can't understate how useful what you did for the whole ethereum Community we use what you do every single day back in front of them everywhere so uh thanks for that thank you thanks so yeah more than deserved um one question about philosophy and this is this is going very specific on being that guy um but one thing that ethers has a philosophy is really the how it returns undefined and actually it doesn't return undefined for waiting for transactions and we actually talked once in one of the PRS of typescript really giving the option of of returning undefined money transaction you wait on it and it doesn't return anything for example um and you mentioned that that's not really part of the philosophy of how you're building the types for for ethers so I missed that last part so we mainly set a transaction and you get back to null or um let's say let's say it's a hash that doesn't exist okay um what what is the philosophy of ether's returning that would it be undefined because in their case the type script for that doesn't contain undefined it always says oh I know you're talking about now okay so that's okay that's a big thing in V6 as well I should probably put on the odds and ends okay uh so we four came for exactly right so right okay so for background basically ether's V5 was started two years ago I was still kind of learning typescript it did not have strict null checks enabled which basically means anything that returns anything I'll turn that anything or no and so in V6 I've got strict null typing in some strict null checked type whatever you know that what the plague is it's disabled and so for example the provider's method for get transaction it will be the return type is null or transaction response whereas in V5 it was just transaction response and I just trusted people knew that uh it could be null but don't worry about it so yes uh yes V6 has been fixed um it helps fix a lot of other people's libraries as well that are like dependent on it and are kind of crawling into the ethers tree to like run their linting rules so yes that's absolutely changed and will there be backwards compatibility between those new big in type and the old big number type like will big in be big number-ish sorry will it will what be big numbers at the new Big in time oh yes too big I mean for input types you mean yeah yes there's no there's still a big number-ish type because uh like so for example the the slide up there that demonstrated I lost the clicker um the slide that shows you um uh like the transaction dot Max gas equals uh so that takes in a big number-ish so you can pass in a bigint you can pass in a string that happens to be decimal number you can pass in a string that's a hex number um that'll all be munged into a big int type but you can still pass anything anything that's not ambiguous ethers will accept it will not accept things that it can't possibly interpret like uh for example non-zero X prefixed things because if it did that it wouldn't know whether one one was hexadecimal 17 or binary 11 and so it requires you to be completely non-ambiguous um so if you pass in a string that's one one it's going to assume as decimal but yes it's uh it's still a big number it's still a big number-ish um and there's functions as well for your own purposes that will convert any big number-ish into a big number or any numeric which is another type that it now has into a number thank you thank you 