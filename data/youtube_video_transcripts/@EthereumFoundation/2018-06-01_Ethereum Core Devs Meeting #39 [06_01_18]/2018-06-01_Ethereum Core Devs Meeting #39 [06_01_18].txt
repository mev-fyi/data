[Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] you [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] you [Music] [Music] [Music] [Music] [Music] so I opened that EAP proposal two weeks ago there was not much discussion I mean on Ankita the one I wonder suppose I God said we need to cross tracks like really good scheme of houses Genesis format should look like this is actually it might be a lot of work because of the obvious communication issues between client developers yeah so yeah I I weighed in on this in getter and I don't think it's a ton of work and I don't think the problem isn't necessarily the communication problems between implementers it's more we need to agree on like a driver for this project so if you told me right now hey Frederick you're responsible for this I take it on I'll try to come up with a proposal for a schema and it takes it it'd take me a couple of days or a week or something but I think we need that driver otherwise it's it's just not gonna happen because like there's a lot of differences between the different formats and you kind of need to actually dig in and understand all those differences so basically we need to dedicate a person to work just on that issue and I don't think it would be a ton of work like I'm imagining like a week of work or something yeah I also waiting on that and I would I totally agree that we need a schema because otherwise we will again wind off in the case where we have some kind of non-formal description and differed a you can entertain planted in different waste and then the consequence being that's yeah five months down the road there is mismatch and there needs to be a lot of coordination again to resolve how does stuff apply from your contention differences so it would be a lot simpler if we have a proper schema proper definition so basically we need adjacent scheme he's a full description of every field field name and field value what kind of well you could take and what is the meaning of that field on schema if needed because I just wrote a bunch for or some of the other the other test subtypes with the schema part that is who is talking now sorry this is Everett I alright just in the last couple days I've been making some PRS in the test repo yeah that would be awesome so should I just go with what's on the pull request now make a schema for that and I mean what's on the 108 v port the issue want to wait five right now the common Genesis format one yes that sounds good to me and there are some other I mean more for clocks that need to be added there are a few features that currently uses that might be the night makes sense to have and there's things like max code size which I don't think any other client has implemented in the Genesis some things like code size in a hard coded into fourth when so basically when you say that the design team for a Kulak is this number after that number all of their rules agreed with Byzantine applied things like code files are also apply it visit visit fork well yes okay well I'll just go with what's there now and make a schema like that and then it can be modified as we go but if we just turn on if we just start enforcing it for C I and then we realize it's not flexible enough that people be forced to change it when needed does that make sense yeah so open a pull request is at least beginning as starting doing this schema now I have a discussion but more active sounds good yeah could I talk about this issue what is she I mean starts it up then we can iterate over it only give each other like we did last week so I make a schema and the port request and then and then I guess let me know just let me know what to do from there cool sounds good it sounds like the next steps are pretty clear here any final thoughts on yeah T 195 yeah I have a call I heard the call and on that call we discussed how could an existing project Thunder gasp Thunder to use our existing blockchain test and then I actually think it's not about that maybe some people trying to use a serum in the private chain as they use them it's slightly different prices and stuff and would it be possible to also encode those gas prices for up course into the genesis format or some maybe is you could think of I'm making you to do that because if you manage to do such things like that we could use existing blockchain tests for other easier implementations so the question is could gas prices for up cause be also included in Genesis format somehow I bet a good idea that we will prefer not to implement that for gas because I think the compiler can optimize better I guess I would I wouldn't argue for that but I would also argue for maybe a slightly different approach to testing which would be every client fills the tests and then you compare the resulting JSON so in that case you wouldn't even have the gas price in because right now what we do is we have CVP etherium fill the tests and then the clock the other clients run the tests instead and there's no reason we can't just have you know every client fill the tests instead and other than you know all the engineering workers can take to make that happen every client fill the tests in the report the resulting JSON then compare directly the JSON and that frees that really makes it a consensus test set instead of do I conform to CVP etherion test that I don't really you don't have to fill the test once the test is created there is no need to review it actually any any client could just run it it's more safe because when you regenerate the tests you might change something you even don't notice but once you feel the tests you have like a set of instruction and the result and every client could tech record for every client what filled and that's what would happen for CPP aetherium it's just that instead of storing things like the final gas and the final balances of accounts well you just wouldn't store those you would only make assertions in the expect section about the storage and then the final gas and stuff like that you would I just look at the filled version of the test and then you'd be well I don't know I also like that it would give you more fine-grained assertions because you might have is right now it seems that a lot of it is done based on you know hashing the resulting state and then preparing hashes and not really a block contest has a set of blocks and the result post state this is a main type of test for the clients so basically it repeats the procedure of importing blocks and just comparing the post state after importing all of the blocks it's not about hashes and about feeling yeah it will be a good if other clients could do the test filling process but as a client if they don't have to create their own test tool which reads the test filler and the create final test all the interest from from having a tool that reads the filled tests honestly like you read the JSON you you know figure out which parts of the Free State you run those to set up your client and then you run the code and just drop state apart and just generate the post eight it's called easier about Genesis format is because I wanted other clients to be able to generate the test of what to do that I have to have those earpiece emitters which I transfer the instruction how's that change should be initialized because it's Costas has different chain options at the beginning so basically I'm trying to past as a blockchain inform a blockchain test informations through air pasinetta's were that sounds like more implementation effort by I mean now they have to pull up on an RPC library that can speak your protocol cool instead of just having instead of them just having their own way of invoking their program on the command line so they could read those tests from Jason themself as they want was their PC added those RPC I mean that common Genesis is a first step will be purposing added business common Genesis Foreman's and I could initialize any client axiom to run this specific speech that speaks your RPC don't speak the RPC but I well why should speaker PC it's like negotiation protocol so then by using those RPC method I could tell the client to run the test for generator whatever it's just it's it would be a series of methods for exporting and importing blocks and transactions running those tests wouldn't be possible okay well I'll make a schema for it and then we'll uh I guess we'll see where it goes from there thanks guys Demetri any final updates on testing stuff other than this particular question so I started working on blocks in test over RPC and I plan to ask for some changes and on serum get blocked by hash method I need blog signature and transaction signature as a field and not is there any question or action item for the core devs Dmitri about that or that just FYI yeah I wanna solve issues one by one so the first dish is to come to this Genesis standard after that I think I'll focus on other issues I just took a head great thank you very much that's that's helpful okay let's go on to client updates Hudson suggested moving these to the beginning of the call because the calls I'm getting longer and we don't want to miss them so let's start with parody no real update from us I think there hasn't been any major release we have a Casper test nets in the works like not a permanent Testament just something to play around with and test our transaction pool and networking code so if you're interested in checking that out reach out to us thanks Frank cool I guess yeah I think Peter can thank itself and take this so I our latest two releases I think the mainly fix some issues around transaction where we have the first memory block and then we had races which made the client lock up we're doing some interesting work actually Peter is regarding his memory crooning we do on the state and it's implemented a streaming memory crooner which performs a lot better that is really tangential to some other work is doing which I mentioned two weeks ago about a new model for fast sync a new protocol which he is experimenting with them we have high hopes for that and yeah we're hoping that within the next month or so make some really good progress with how gets performs about it Cheers Thank You Martin do we have anyone here to speak about CPP aetherium it looks like we don't have Pablo with us okay we'll move on with fixing some stuff so we're about to release in a week or so this release is about performance you have to and drugs to be now it reads faster from five to ten times and another thing is stability because we had to protect from eclipse attacks because they are happening on the main Network and we also have reduced the memory footprint so this version is more stable than previous one and is able to run on the main network without any tricky stuff like restarts or something like that so yeah it's pretty stable until you see none of them so like something on the main Network yeah it's like you know Martin we had we hadn't been protected from many connections with the same IP address and there are some addresses that it's like it's like you know a lot of such addresses like maybe about 10 or 20 maybe 50 addresses I have noticed that does a lot of connections from different ports and they just do no handshake so this is just like looks like an eclipse attack the primitive Eclipse attack we hadn't been protected from so now we are and very interesting you're more than welcome to send me any information you have about that okay okay I will okay we'll try to find those logs with this connection so yeah and I will describe your tales of attackers behavior and River also attacks like you know with the malformed RLP and yeah we didn't count how many bites in LP before allocating a memory like that could be in a lens of array with about gigabytes like let's say a 10 G give at so we try to allocate such big array before understanding that our LP is much shorter so this was another kind of attack like yeah but we had to protect it from that tall so so what acts are are constantly happening and that's good that we are that we will not protect it because here we can notice that there are happening thanks McHale do we have anyone from Pegasus today ok we'll keep moving Trinity I'm not from Trinity but I I know they released an alpha which is super exciting and I know they're focused on performance primarily performance and some kind of in bugs that might cause their system to crash but I know they're working very hard I expect them to how thanks Danny I saw the announcement about the Alpha as well also very excited so if if Piper and team were listening Congrats guys great news X theorem this was brought up on the last call ok do we have anyone from Nimbus yeah I'm around that's it from status so I can give a quick update of what we've been up to we've been experiencing both the pleasures in the pain of working with a with a less known language pain being obvious feel that we have to develop a lot of base components like big integer support cryptography we're working on networking making sure that that's solid all those things the pleasure being obviously the enthusiastic support we've had from the NIMH community so we managed to produce the number of libraries that supplied these base components for anybody that wants to write a like a crypto plant as far as progress on ethereum ghost we're putting things together we're working on the EVM very much appreciating the test suits available we're working on the DEF p2p framework and and I'm sort of starting to implement the wire protocols to enable us to start syncing King soon so yeah that's a good work they're looking forward to getting an executable together that can actually do things thank you for the update attic okay did I miss any clients okay let's go to research updates I think I'm the only one here on the casper side of things as the clients have begun implementing AIP we've been kind of iterating and worked through some of the finer details mainly around executing transactions in parallel and kind of handling the transactive o transaction cute we're on the development side we're opening up some more helper functions from the contract that allow the clients did some confirmation but generally he in a parody areas does great work and I got this more time when I'm gonna slide to death we're going to begin working on the application play again harmony has previously ended up just kind of put all the pieces together hopefully getting a test snips with more than just parody up in the next few weeks thanks Danny that's really exciting yeah as for sharding stuff justin Drake and Vitalik have a series of posts around signatures and beacons on e3 search I kind of exciting new developments there that are interesting except no starting subject y'all are interested in that check out each research awesome great thank you for the update okay let's do ye Hwa's um Mexican friends is one of you guys want to give an update from the it wasn't team update would and that we are working on finalizing the need for a public test net and we are shifting focus from one part of the project which is called IBM to what them to other parts more important for it test net um I think that would be the quickest update you could do are you planning on starting a new Testament for this or like making one of them he wasn't um no it would be a brand-new test net and and it would have both EPM and he was an enable man changing any of the existing tests nets would mean and to update all the other clients and right now so for example we could change I guess rough stone or rinkeby and and doesn't mostly run by I go eat cereal and that would mean we would need to support he wasn't an inchoate areum which isn't the case at this moment yet and so this new test net would be run with CPP theorem and hopefully shortly after that it may be joined by the assyrians it was an implementation but we have no ETA on that yet cool sounds good keep me up to date because like if you do start one parody like it would be interesting to see what it would take to parody for parody to join that testament as well sure that sounds good thank you oh I've seen in some of the awesome channels and I haven't done research but the EVM to be Wasson is that some sort of tool that trans files by code or what is that um yeah it is is it a tool which can be fed with even a bytecode and it would put any Muslim bytecode is that in an attempt to eventually just be able to pour the entire ABN over to you awesome yeah I mean this tool could perhaps ever use cases one of the use cases we have been using it before is to use the etherium current state test on any was some implementation future use case could also be if someone implements a client from scratch and they make it the native it was it wasn't client they wouldn't have the need to write any implementation they could just use this tool to translate contracts before execution watch oh and the so it's quite a big project and it is passing quite a few tests at the moment it actually has been written probably two years ago and at that point it was like 90% passing the frontier tests but since frontier we did have moved on quite a bit and right now it isn't passing everything in Byzantium but the plan is to finish it to a certain level open it up to the public give some guidance on how to use it and how to fix some of the the remaining state tests and maybe the hope would be that we could we could get there coming more involved in and finishing those question only in your new fresh client like what kind of issues would you expect trying to do that I mean let's assume that we're a new client which we are we don't have an EVM which we kind of those if we wanted to go you as emoni what what would you be looking out for there's a problem so it well I guess the only only real problem right now would be this TVM tourism tool isn't fully finished yet so you cannot just I try to use it and run every single contract you would want to run it can run a subset of contracts and we do plan to finish it to a level where it would ran some common patterns of contracts and but definitely it would be missing out on some other edge cases sorry yes that's a minimization at the moment there's a lot of help needed in finishing that up otherwise I don't really see any any major issues blocking this kind of design what about security concerns or gas cost concerns or anything like I like attack vectors that they're open up and weren't possible before so this compiler is would be kind of like an ahead of time EVM to say x86 compiler it would be pretty much the same concept it does so the output itself what it generates would be following the the as of today at least it would be following the gas cost a hundred percent how it works in EVM and the this EVM tourism tool itself should be compiled into awesome and should be metered so when you execute that you would have a an actual upper bound of how much time it should take to do the translation yeah that's really interesting thanks for the update Thanks thank you Alex Alex is the CBM 2 C compiler still just barely sort of straightforward translation hampt to generate very hi equality has encode out of for instance taking every opportunity to use 32 or 64-bit registers rather than using the library or I'm asking whether whether EDM tourism intends to be an optimizing compiler that can take the encode down to 32 and 64-bit register it's going to keep on doing everything with a multi precision of grigory it does everything as the current EVM requires so it does operate on 256 bits stack items but it should be possible to act in I mean it's it's open to you positions and it should be possible to implement even 1.5 and they're the same the extensions as well yeah I'm sorry looking I don't know if it's important nobody's funding just one last remark on that Greg actually it should be possible to say support even 1.5 with the same the extensions and if it would detect EVM input as such it could make a decision to to optimize the entire output to 64 bits and that might be that might be an interesting idea to explore in the future yeah if the lime we get into this later it could be down at either end yeah it might be easier at the first end Minh is still clear what the wasm structure is but the details no need thank you for the update Alex Greg just a heads up that we're having a little bit of trouble hearing you I'm getting about 2/3 to 3/4 of what you're saying yeah it's a little distorted so I don't know if there's any okay different place you can stand and maybe get better connection or something but just as a quick heads-up about that let's I'm up in the mouth with AT&T HMA they'll talk louder thanks Greg I'm sure it's very beautiful they're cool okay let's but the source is lousy sure let's move to the first item on the agenda after the client and research updates that is e IP 1087 which is net gas metering for s store operations this is Nick Johnson CIP his nick presence I think not I think not as well does anybody else want to sort of champion this or speak to this okay will table that and keep moving all right back to awesome the next topic here was some concerns expressed by Greg that using native browser VMs for running Azzam is not dos hardened greg do you want to kind of kick off by expressing some of your concerns here the basic principle is simply that if you can cause it to do more work um then let us being paid and gas then you've got a service and there's a number of ways to make that happen he laid on the National um you can that's the cash to become used was the reverse you know you can pause it to think that things are hot and compiled they uh you know and any other number of plug thanks to Mike to and past at the KC er I put a link into it it was it was pretty late so Casey can summarize what he's doing ok say are you there oh yeah can you guys hear me louder Casey is it too loud yeah so I opened I opened a control okay so yeah Greg has been reminding that II wasn't team continually we've sort of been saying we'll cross that bridge when we get there and been focused on building the interpreter the JIT compilation issues the basically there's two ways to execute waz encode interpreted or compiled and well I mean as so average here he's on the call and she says that there's literally no difference between interpreted execution compiled execution Paul points out the yeah that is technically true except for the two orders of magnitude and execution speed is the only difference one of the one use case for switching from EVM to us on is to is to sort of be the pre-compile that ends all pre compiles so it would allow users to deploy their own pre compiles but that will only work if the II wasn't gas costs are calibrated that to the two native execution speed not to interpreted interpreter speeds because the benchmark we did was using a the EC pairing pre-compile and when running an interpreter it takes 21 seconds to do three calls but when run with a JIT compiler it takes 100 milliseconds so it's over two orders of magnitude difference but we didn't know we were kind of hoping optimistically that v8 for instance the the Watson jet engine in chrome and in nodejs because the validation pass over Watson code is linear there is we were smoking some opium that maybe the jet age it would also be linear you know have a linear time upper bound so finally a couple weeks couple weeks ago again so a couple weeks ago when we tried to ask bury it we tried to reach out and ask various jet compiler expert experts and know them could really give a nobody could give a a confident answer on whether or not there would be a denial of service attack as a Greg suspected there would be so finally a couple of weeks ago guido vronka hooked up a fuzz tester to v8 and found some compiler bombs they there are 20 kilobyte pieces of web assembly code which is even smaller than the current say I mean the current maximum contract size you can deploy on the main net for EBM it's like 32 kilobytes so these waz um these pieces of wasone code are even there's even smaller than that and took about two seconds to instantiate or compile and in v8 and they're kind of funny to look at because you can you can see the the like the highly nested loops and different features that that might be tripping up the legit the JIT compiler so so yeah Greg you were right and so and so now we know that now we know for sure it's a problem and we're at the phase where we're thinking about potential solutions or approaches to solutions and the besides using a JIT the other solution that has that's often discussed is using a äôt ahead of I'm compilation and I was always I've been skeptical of that because to me peyote sounds like a big P ITA with a lot of plumbing and I mean you can imagine now might work where there's a directory of cached Tod exe files so every contract when it gets deployed the waz encode gets compiled ahead of time to exe file and so the client instead of maintaining a state tree of where it pulls the VM bytecode interprets it it maintains a cache directory of exe files one for each contract that it executes when eaten when each contract is is called and it sounded really difficult to me but then Paul who's also on the call is Paul there I hope you can hear me I hope I'm sitting next slain I hope we don't have neck oh yes yep you're coming in clear yeah Paul explained the I was able to explain to me how how ahead of time might work and I guess I'll just let him take over now just to introduce myself 10 seconds I'm on a grant for the darien foundation working at pi web assembly i am trained in mathematics and I'm reading the lab assembly specification it's reporting typos and so I'm not an expert on Ange it's in there how things are implemented but I know that to implement a web assembly there are a lot of things you have to do in there there could be a lot of things I didn't hear Greg clearly I think the question so I don't know how to answer exactly to Greg's question but I think the question to me was ahead of time yes so we take alluvium the compiler and we compile it to webassembly so WebAssign so LLVM so there's sort of a a compiler compiling a compiler me i'll LVM to webassembly we meter that and then we use that metered LLVM tool chain to compile smart contracts to x86 64 and arm binaries and perhaps over time we'll have wool we will support different binaries so that was the big idea and we'll meter this compilation so that's that's it for me i hope that answers yes did the issue is the yasm setup so you you can traverse it in linear time which means it's possible to run through most of your optimizing compiler tricks and n log n tight um typical compilers don't do that um they go ahead and go for the gold that are willing to go quadratic to get there yum so it's possible to write a good wasm compiler that stays and log n young people aren't doing that because for webpages it just isn't a requirement if a web page goes walky the web itself does fine and whoever weds whoever's web page it is has to fix it um but when a contract goes wonky it's a security hole so i don't see any real answer except that somebody has to write bomb-proof has some compilers that we can run ahead of time now in the c++ compiler it's an almost trivial change you know in one file to move the spot where the code is compiled by the JIT to the spot where the code is first loaded and to take the output of the compiler and stick it into the existing state database and pull it out and run it and eat it yeah so it just doesn't seem like a big deal there the big deal is getting our hands on a bomb-proof plasm compiler and given that the foundation has a truly astounding amount of money at their public but their areum address I just don't see why financing that effort could be any kind of problem I respond I know at least about a year ago I don't know if it's still the case but Firefox actually does have a one pass a single linear pass compiler to binary from web assembly to binary and in the background it has the eye on optimizing compiler but perhaps if we can wrangle out the single pass Firefox to web assembly to binary compiler we have what we want and even if we still have the eye on things going on in the background that's still okay I think because we'll still keep executing the single pass version so this might be a solution another a solution I might be interested in in writing a pioneer web assembly to binary compiler said that there's no solutions these are two possible paths exactly I can also chime in and say that parody is working and has a great interest in writing one of these compilers so you know there there's also that possibility I'll also add that you're great you're talking about compilers doing optimization work and there's actually really good reason to not do that and for the web we can't expect that people writing programs like naturally optimize their and code and a browser has a very legit reason to do all sorts of crazy optimizations on the wasn't level I think we can push that to the users so if you're writing a smart contract and like if I'm writing it and rust I'd expect LLVM to output what is already optimized wasn't code and the compiler from while isms a binary doesn't actually have to do any optimization when you have a smart contract that's responsible for hundreds of millions or billions of dollars and it's a tiny little piece of code there is no excuse not to put absolutely huge amounts of work into it from every angle um so I don't see how was an optimization makes that more secure though if anything it makes it less secure to change around what the bytecode is exactly so you're right right right incredibly efficient bytecode and look for something like an old-fashioned C compiler that doesn't almost one-to-one translation that that's what we would be looking at it party if we're making X's and Y's um was designed to allow for fast streaming compilers that's why the instructions are so very low-level well then the question is why are there vulnerabilities and the standard wasn't jet engines it was because they're they're trying to do a bunch of magic optimization stuff to make really low performance shitty code run faster yeah you're you're talking legacy graphics code I mean what would be ideal from an ethereal client developer perspective would be if these off-the-shelf engines came with a flag that said do school línea aérea compilation and not uh you know fancy stuff that that opens you up to won't get bombs as you know I don't trust third-party code and this just isn't that hard of a project you know find something open-source or write it ourselves you know see what parodies got I give Pavel two weeks if he had nothing else to do I also actually don't think it's that massive of a job I think we could have multiple implementations of this and in all the teams and not be too encumbered as someone who is writing implementing the web assembly specification it's it is a lot of details so I I think way more than two weeks yeah but problems really good I also think more than two weeks but I mean we've written an interpreter and that was not like a year project it was it was a lot of work but it's not something that is you know considerably much more than writing an EVM interpreter and compilers yeah yeah yeah I'm exaggerating but it's just not that hard well how about compiling about doing something like compiling Albemarle LLVM to wasum and then using it as a bomb sniffer it was would that take more or less than then two weeks or more like two weeks bombs the bombs efforts the worst idea I've ever heard why is that that because there's too many ways to slip code pass the sniffer what ways are you thinking of finding the sniffer doesn't do a good job on like the next version of the PM you were sniffing or God nod off version you weren't aware that some client was using well then so I mean if somebody implements a crappy bbm you know etherion client on maintenance will nervous so I don't see how that's any worse than the present situation oh I president situation is probably much worse than we know yeah we were lucky a truly concerted group of hackers hasn't gone to take us down yet can I add one thing I think just the JIT bombs isn't the only concern there are a lot of concerns with the denial of service attacks once when you're implementing the specification you can do it several different ways parts of the spec are left to the implementation so just sort of this compilation time is one thing but there there are a list of other things that we should sort of like what oh how how the the branching the control flow is implemented how to escape from a trap I made a list actually of different things different concerns that I have that a lot of implementations deviate from the spec for optimisation reasons so there might be asynchronous execution that would be sort of unusable for us resource exhaustion concerns that I have non-deterministic behavior all these things when we validate the spec says that should be validated at the very beginning when you're instantiating the module but then a lot of implementations waits to validate function until later until right before they run so I have a list of maybe perhaps ten ten concerns that I have so far and a few others that I work oh I saw that list yeah yes and that's not to speak of hardware bugs when we're so close to the hardware level of course there are Hardware bugs and if someone knows you know how did how its going to compile then they may trigger one of these bugs and they might you know hack half of the network so this would be a monumental devastations will you be posting that list somewhere oh my github username is Keowee mmm and it's one of my repository as well awesome security concerns maybe Lane will post it with the notes Thanks and the list is growing by the way I guess the the question for me isn't how to make the most bomb-proof virtual machine in history but what's the easiest path to enabling users to deploy their own pre compiles since nobody's answering the easiest ways to use some off-the-shelf software the safest way is maybe to inspect a single pass to you know compile JIT or maybe ahead of time and to check all the different things in the spec all of my concerns and other people's concerns to make sure that what to identify the attack factors to tax it properly with gas so us I think us what's the easiest the easiest is just use off-the-shelf that might have security concerns well thanks Paul you okay let's keep moving thank you very much for the for the points guys okay so the next topic is Constantinople hard fork timing and what to include this has come up on the past couple of calls I think it was it was pushed from the last call again any further thoughts on timing and what should be included is there a running list of VIPs that are essentially gonna go on there's no link on there yeah there are a couple I can try to pull these out of the agenda from a couple of meetings you go sorry if we're not doing that ahead of time I feel like block hash refactoring is one of them and maybe a couple of others let me look yeah so shape-shifting is and look at refactoring and I think there's consensus about that what else is there so recently there's cropped up a few suggestions there's a skinny create two by vitalik which is really nice in my personal opinion because it allows you to do counterfactual contracts basically you know where a contract will wind up based on an init code because the address is derived from the end code then there is a three that nick has proposed very recently the Neff gas mate ring yeah well these three we haven't really discussed in the court I'll call one other is X code hash and there was one more are there another which have been discussed for inclusion in the Seville there is a meta which is e IP 101 three are post this link in it as of this moment only contains the two we mentioned which are the shifting in the block hash refactoring I don't know if there's been a discussion about skinny kraid - I think there at some point should be a discussion about that unfortunately with Alec has a new champion with this came up on meeting 37 so about six weeks ago Vitalik was there at that point to talk about it just reviewing the notes here we left it off by saying yeah this is a good thing it would make it easier to do counterfactual state channels as you mentioned and there's no EIP for it yet let's create one and discuss I'm not sure if one has been created yet if anyone oh it was yeah it couldn't well I think yeah the same day or the day after so yeah recently just I don't think it has ever been discussed after actually becoming an EP right but it will be good so I don't know maybe it's not possible to discuss it today but it would good if the people Orion is called look into it I personally like it well table this as well and bring it up again maybe when metallic or someone else can speak to that particular AIP is there any final thoughts on on hard fork timing just sort of not not the specific question of what to include but sort of timeframe a you know short-term medium-term weeks months sometime this year or do we really not really have any consensus at this moment yeah I think personally we should have hard for this year in autumn Danny is there any sense for when we're gonna need a fork to include stuff for sort of FFT not at this moment need to get a few more clients when I run it together you know before we have a test net with multiple clients running I think that this the other hard work should be considered outside of it yep okay make sense okay all right so the last I think Peters not on the call does anybody want to speak to this or speak about this I'll just briefly summarize here usually chained rent is brought up in the context of the main net where we debate whether contracts etc cryptokey should be allowed to pose large storage overhead on full nodes but he's making the point here that that this is an issue on on test nets on rinkeby there are many contracts with over ten megabytes of data at least one instance of over 82 megabytes of compressed storage it poses enormous overheads and synchronization limits the usefulness of test networks for the entire ecosystem is there any possible solution may be a limited form of chain rent or other limitations on contract storage that might help keep these abuses more manageable any thoughts and the storage usage for run contracts what prevents users from creating multiple contracts they use different storage yeah so that would be something that needs to be addressed by a schema that has blockchain ranks I mean yeah that's a problem that needs to be solved so how do how do we exact rate from which contracts at what time and there are a couple of different proposals for storage rent and contract rents that I've seen over over time but is there anyone here who has who knows about a proposal that they can deliver so like so I've talked a lot with Phil dying about rent topic and the way that he and and I from him think about it is so the latest model being that you had you set some gas amount some costs per time units for keeping the data in states and then every user who makes a transaction to this contract would pay to top up the contracts lifetime to five years so when you deploy a contract you get five years and then any user who interacts with the contract pays to top it up to five years again so if a contract is used a lot and you would just pay them super small micro fee to top it up like an hour or a day or something if a contract is very rarely used then it costs more to interact with it and after if no one uses it in five days it gets removed from states and then if someone wants to reinstate it it would cost that five year fee again and I think that's a reasonable model and it's pretty low overhead on the user's the only like real effect would be that things cost a little bit more yeah so but it sounds like there will also be one more data consensus critical data set to maintain for the client developers right yeah so whether or not something is in States would be consensus critical because yeah like what you're actually paying in gas will depend on whether or not it like yeah what did what that status I'm not sure if it's adding all that much I mean it's it's definitely another factor but it's a feels to me I mean you would obviously not base it on on actual time you'd base it on number of blocks so I'm not sure yeah I mean I haven't looked at this into enough detail like a nun implementation level to say how easy or hard this is or what it introduces but sure that you now have to agree that whether or not something is in-state or not as well yeah I mean if if it would be really nice if you guys could write this down and we could maybe we could try it on a test note yeah do you think Phil would be interested in reading any AP or at least like a limited spec I think definitely you'd be interested but I'd have to ask him stateless clients would also solve this problem and might be easier to implement versus storage rent so Phil would argue that it doesn't solve the problem and you're just moving the costs to the witness and and sort of moving the cost bandwidth and witness generation procedure data still has to be somewhere sure a storage rent would give us a way to eventually forget old parts of the blockchain which would be convenient for all sorts of reasons but stateless clients also enable you to forget old parts of the blockchain I mean unless you go and call into a contract that's you know super old then suddenly you have to remember it so yeah but at that point is the users problem not the clients problem I mean with studious clients the user would have to supply the account data of the contract they're trying to call in - yes and that's also interesting that is kind of like storage rent but where you pay the stored rent yourself by storing the contract you're interested in then people can prove that it was the correct one but then the other problem with that is people still have to maintain old implementations of EVM instead of allowing us to eventually forget those yeah I think of stateless clients as very similar to storage rent with what do they call it reincarnation but without all the complexities of the rent part I mean all the red Braca second layer the problem I would still have with it is my goal would be to be able to evolve the evm over time better and the only way to do that is to make it so it's impossible to execute old contracts well the only way to do that without you know some sort of irregular state update I mean you would still require a regular state update but cool yeah so obviously rent is an important topic I know there's been a number of sort of proposals related to this topic on the ìiî search forum it sounds great if yeah if Phil or someone else would like to kind of turn this into an APU I'd be interesting to bring this up on a future call I think that's everything for the agenda today so thank you guys so much for for your time hello everyone yeah yeah I totally lost um connection just at the end of the Ewaso ng discussion case he started into something and then it went blank so someone could summarize like the very end that would help probably case he knows if any conclusion was reached I don't know what it was the last thing on the topic I remember saying is that my concern isn't so much designing the safe the most bomb-proof virtual machine in history but determining what's the easiest way to enable users to deploy their own pre compiles which requires a a reasonably bomb-proof system right so just reasonably bomb-proof but not make it perfect but we can make it good and be prepared to deal with the US is when they happen but there's no point going in knowing that were wide open agrees okay thanks thank you very much everybody as far as timing for the next call goes I'm not aware of any conflicts in two weeks so it looks like the next date will be June 15th you know speak up now or post on the github issue if there's any conflicts that I'm not aware of mmm-hmm thank you everybody thank you very much everybody have a great day thank you YouTube yeah [Music] [Music] 