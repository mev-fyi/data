let's talk so peter Sailaja good morning everybody so unlike many of the crypto projects out there aetherium isn't really an end-to-end product it's it has always been a platform by developers for developers and as such our kind of our primary task is to make developers happy so that in their turn there can make their end users happy now for to achieve this one of my opinion one of our most important roles is to either aid the existing tooling developer tooling out in the community or maybe fund or create new ones that the ecosystem is currently lacking and my talk would be about one such tool that we wrote but before we dive in let's see what the actual pain point are usually when the developers approach even for the first time they start playing around with remix it's browser solidity playground they get the hang of solidity they start prototyping their contract now unfortunately quite fast they realize that developing in a web browser is cumbersome so they switch to more sophisticated tools such as truffle which can do automated repeatable testing and also aided by proof of authority change or instant transactions now after developers actually finished writing their code usually the procedure is that they deploy it on a test net either option or an alternative because that's really nice it's a real-world environment many users etc now the problem is that this perfect testing environment often goes belly-up and the reason is one of the reasons is that the test networks are can be really heavy either due to spam attacks or to large projects such as radon doing intensive tests these can be unstable from time to time usually because somebody figures it would be fun to reorganize the chain and lastly it can often be unfriendly because you have this awesome project you want to deploy but you don't have tests either and that's annoying and the truth is that if you are a small project then running testing on the test that is fine but if you're a bit larger projects such as Rayden or maybe have many projects such as consensus or perhaps you want to run a hackathon then the life does not or isn't really ideal so the ideal solution is actually to run your own network now this might seem like a good idea at the beginning since it's live stable you have unlimited funds you can share with everybody but when you actually start configuring your private network horror strikes in so it's actually quite a nightmare to configure because it has gazillion of different moving components and so we've been working for quite a long on a tool called puppet and the goal our primary goal with puppet was actually to run the Rinka we tested on it but we kind of realized that it will be an amazing tool for at least we hope an amazing tool for other projects too so we kind of polished it up and gave it out to the community and for the rest of my talk I'm going to do something really crazy I would like to demonstrate what it takes to actually create an entire a theory or network with bells and whistles live on stage so first up if you want to actually start your ethereal network obviously you need to configure the Genesis block the shared initial accounts the balancers and you have to define what precompiled contracts you have what fees they have now there are different for crews that you need to take care of and if this wasn't horrible enough if you have to do this for the five primary clients that's about four hundred and fourteen configuration values and that's just a snippet from parity is really extensive list so that's not really a pleasant experience however if we try puppet now puppet is a command-line tool but kind of a command-line wizard to help you so the first thing it just greets you with a nice message and asks what network would you like to manage well just type Def Con that's a nice network and then as what would you like to do well we don't have network yeah so we don't kind of shown that for statistics but we can configure the Genesis block so let's just switch that and what kind of concerns this engine well we have proof of a 34 click but since we want to actually across client that's what last stick to et hash nice do we want to fund the initial accounts No and do we want a space it's a nut work change right if you run a public network maybe it's worthwhile no for now we just do random and that was about it we actually managed to configure an entire jealousy state for five different clients without doing anything now of course if you actually want to run your own network then the genesis is just that one you will need to get some nodes online but one of the biggest problems that we see with people getting those online is that they have absolutely no idea what the nodes are doing so you really need to monitor the node somehow and really want to do that via them each stat surrounding each stats which isn't really easy to do but I see how puppet can help so what would you like to do puppet asks us what we'd like to deploy a new network component it gives us a choice not stick to its it's fat and which server well that's connector server we have a server called DEFCON Network it's a registered domain name oh yeah sorry connecting server network and yay Wi-Fi works awesome so we managed to connect yeah that's why you don't do live demos do we yes we trust the remote host now what where do you want to deploy it hash since we want to deploy possibly multiple web sites here let's deploy it on port 80 and do we want to share the portage with others yes sure now when we actually say we want to share port port 80 purpose will deploy a reverse engine X proxy automatically configure everything without us having to do anything and what domain do we want to host this it is that's patience test dot DEFCON Network okay and what's the East as password hello hello it doesn't matter yeah it's fine now it in theory puppet now runs in the background starts up entire ETS and everything and now not only will it start it up it also lists us that yes we have a were connected the IP address and what services it's running and now if you load up a web browser and look at the actual domain name then hopefully yep we have a nice test running and you can you can see it is actually not an image it's alive that page okay now we have a stand come on is our the thing but we actually have to boot up the network so let's deploy now boot node yeah that's sometimes the console is funky now again we have a small scan so let me know what we're up to and that's deploying you that for component yeah and where do we want to deploy it well usually don't want your boot not to go down if somebody's dusting your website so let's just switch to a new server let's call it boot DEFCON Network and yes we connected a new server that's fine we can manage multiple servers at the same time where do you want to store the data directory let's call it DEFCON on the server what UDP port one we'll just you go with the default configurations they aren't even that interesting and what we want to call the boot node on the stats page let's call it that seems about as dumb as it can get and again pop it does it's funky magic in the background and if we I think we can i can't even close this yep and if we now stack I checked our stats page then yep they're fair enough we have our boot notes register maybe it's not tiny but we have a boot code running and it's immediately linked to the Status page we didn't even have to configure everything cool now we have a static chain that doesn't do anything obviously we need to mine on the chain to make it progress so we can again ask startup puppet ask it to connect to our new little network and let's see how what it takes to deploy our mining node now we want to deploy a new network component let's deploy it remaining order sealer again minor kind of takes a kick out of the net form machine so let's do put it on the minor dot DEFCON Network machine yep and yeah yeah where should we store the data DEFCON minor and where should I store et hashtags DEFCON yeah and the remainder can be the connectivity strings can be simple and we want to register it on the ETH page sorry stats page as the minor now what ether base should ooh that was fancy what address to the minor use we'll just copy paste this here and what gas price and gas targets we'll just stick to the default it's not that important and again puppet is pushing out the mining note to our remote server and it should finish booting any moment it does a quick health check it actually checks where the ports are reachable we have a nice dump of everything we configure until now and if we look at the start page finger criss-crossed yep we actually have already four blocks mind and not only that I'm really hoping that the boot node will connect soon to the mining node but since time is limited we'll just check it in the next slide yep they've connected cool so of course and now you actually have an entire network up and running but if you tell your friends that here I have this awesome Network they will just go okay and how do we use it and then you kind of start scratching your head so it would be really nice if well first thing first you could see what the network is doing so for that obviously we need kind of a block Explorer which currently for example there is no open source block Explorer that support Goethe reham as a back-end but however there is one that supports parity now can we actually deploy a parity notes that easily well sure let's try you want to deploy on your network component let's do an explorer where do you want to deploy it well we will put everything all our websites on the same machine so let's do use DEFCON Network as the machine yes we want to poach share port 80 and let's do DEFCON Network where should the data be stored and the default yeah let's call it on explore on the Status page and again it's pushing it out fairly fast hopefully I'm just waiting for the node to finish booting yeah I'll just close it and that's it does it actually work fingers crossed yep we have our block Explorer up and running and we have already 11 blocks mind and you can check that our miner already has 42 ether that's a nice number and of course if we check the network stats then again we already have three machines running without actually configuring too much okay now we have we know what the chain is doing from the inside and from the outside can we ask our friends to use it well sure but it's kind of hard to use it for a simple client so let's try to give them a web wallet now of course everybody knows the most sophisticated web wallet currently out there is my ether wallet so let's just deploy my service to our little custom test Network so that's just deploying you network component you want to deploy your wallet to our website website server yes you want to share port 80 and call it Network where should we store them and just spice up the defaults a bit and that's cool our wallet on the Status page that's in that one's also back and now let's just call it wallet and the campus is just configuring everything in the background for us and it is pushing out the data and if we check our wallet now this is something that takes usually the most time to boot up yeah boom we have our wallet and that you can as you can see it is actually configured for the DEF CON Network it deployed the backend node to connect to we have the front-end and everything seems to work nicely cool so that one kind of was easy enough to deploy all the components but if you share this with your friend then he'll say that ok I want either and you will be the one who has to be for them either all the time which gets boring really fast so we really need a faucet that you can just start up and it just runs there and everybody can request ether and to do that we have actually go a theorem has a faucet built in or support for it based on the light client so let's ask Papa to deploy that yep we want to deploy a new network component and let's do faucet that's our sixth on the list and we want to deploy it again onto our web server we deployed everything there faucet Def Con that work domain name sorry port 81st and thank you okay how many ether do we want to the faucet to release well one if there is fine for 50 minutes we want three tiers if you wait more you get more ether do we want to recapture protection against bots no it's the best Network here for DEFCON we don't care about robots where should we store the data DEFCON Fawcett sounds about right and just different port for this one what shouldn't possibly code on a static page of course if I run a faucet I do need a private key so that the faucet can actually fund its stuff out of so we have a private key paste it in here we have to unlock it for the faucet boom it's unlocked and do we allow unauthorized requests well since it's a Def Con and we don't care about the lifetime of the this whole network so much yes we authorize anyone to request funds and now comes the moment of truth can we actually as you say again we have a nice dump of all the configurations now can we actually load up the faucet yep why is it yep we have a Def Con authenticated faucet and if we request funds now into an ether address give me one ether yep the faucet accepted our funding request and if the mine are manages to mine us a few blocks yep we just mined it and we have our account funded and we can also track the stats page that everything that we deployed on till now have indeed appeared on the stats page now finally you deployed everything but you don't even know what your Genesis block is you don't know how to connect to it and it's just a mess of different websites on different domains so you really want to deploy everything on a single host or at least on a single place that your users could find it and the only way to do that is to have a nice dashboard and that is actually the last thing that what that can do currently let's just try to do that we're just having a nice yep deploy a new network component and find a piece of the puzzle is a dashboard let's deploy it to our website and let's use the root domain DEFCON dotnet work for it and then it will ask which services do I want to list yeah I want to list the stat page I want to list the block explorer I want to list the web wallet and I want to list the faucet and we want the East a secret to be public yes let's make it public and pop Ithaca and crunches everything makes the configuration files deploys a web server for us and if everything worked correctly I should be able to load up nice dashboard yep and we have the first page we have the eat stat and on the left hand side we have a nice sidebar many where we can switch between the each stat we have the block Explorer that we just configured we have our web wallet that we can play around with we have the faucet to request all the funds that you owe people are requesting funds amazing and and beside beside all of these services that we configure we also have detailed guide on how to connect go theorem in archive node fool node like client or embedded for embedded machines we have details on how to connect missed and theorem wallet we have details on how to connect Android and iOS devices and finally if you really don't prefer go aetherium as your client of choice then we also have details on how to connect c++ c theorem the theorem harmony parity and by app and ladies and gentlemen that was the popper network manager [Applause] good morning let me see where are we next up we have Marcus leggy with his presentation and introduction sorry to wall F the etherium Android wallet [Music] [Music] [Music] no that's that's not my screen and that's the wrong presentation but my screen is connected yes that's the right one yes greetings each and every one great to be here like bright Sun bright minds what a great combination in this talk I want to present to you Wallace the Android ethereal wallet and we will focus on three things why it is what it is and where do you find it basically as many of you I am really fascinated by the idea of a world computer like I love this world and of computers and the combination is like really awesome and I also think that we can protect this earth by managing the resources way better by using etherium as we add an ethereal conference I don't have to preach to the converted and tell you why a theorem is awesome I just want to add one thing what I really like is the upgrade path to proof of stake so that we don't have to burn so much energy to have the consensus that we can have it without hurting the environment so much I really love Bitcoin for the spark it brought to the world but I really don't like it for how much energy it consumes and I want to quote the great Greg McMullen from a conference this year because it's often for yet forgotten blockchain is about people the technological paths are really exciting the tools are powerful the engineering challenges are huge but first and foremost everything we build is about people one really nice way to bring in cerium to people is Android this is a screenshot from this year's Google i/o like there are two billion monthly active devices so it's really nice vehicle to bring etherium to these people and it's also good for emerging countries because often you see people don't have pcs anymore they use phones I'm doing mobile development that's a long time I've a really dark history of Java for micro additions and Android was basically my savior and saved a lot of problems so I'm really huge Android fanboy and one of my apps is passport for Android and there it's a nice connection to your theorem because if you treat tickets not as passwords as it is currently but as tokens you get really really nice properties I gave a talk about that at the etherium office in Berlin if you want to look that up please do but when implementing it I found out there are some building blocks missing to build what I wanted to build so that's why Wallace I need to build that first to basically get where I want to go and why one big reason why I didn't want to use walnuts that are out there is they didn't fulfill my constraints the first and most important constraint I had to and wallet is that the keys have to be in the hands of the user and not on server because I think that doesn't really fulfill the purpose and I could not even sleep having having all these keys from other users and I really like to sleep so and you think that's quite obvious that the keys should be had users but then you see the most-used wallet currently something like that and you obviously see the keys are not at the users and then you have basically a centralization again that's really not what we want and and I also think it has to be Libre software and not closed source of because even if the key are in the hands of the users but you have closed-source software the keys are not really in the hands of the users and it's not only small parts like some apps have only small parts open but like to it has to be it the full app has open and I want to get even further not only the app has to be open source but also the platform has to be open because it's basically the weakest link and chain like on iOS if the Apple Apple could steal all your keys and in Android there are no movements to really open up everything like for example prism phone where like there's no more clothes blood or nice movements like if they are phone so let's dive in the effort I have a drink but that's how you're greeted because I think the user experience is really important and of missing in towards today so basically a guide to users in that he can get first his fans and after pressing there you see an ESC 67 QR code so you can't can transfer fans to that for example from the nice GUI theorem faucet and then after you transfer something there you see the incoming transaction there and you might have wondered a lot of other wallets ask you for a password first but I also think that's a stupid thing because it really hurts the user the face because often you just want to try out things at the beginning you don't have accounts that have huge value you transfer to try out things but then basically things force you to enter a password but I think you should the user story should be different the user story should be that you basically can try out things and when the account gets real value then you secure it and then I even think you shouldn't secure it with a password but you should usually real Hardware wallet because that's real security because the past we can discuss it in the break it doesn't really add much especially on Android where you have a sandbox you really need that on a PC you wear every app can see the data of another app but an Android all the apps are sandbox so a password doesn't really help and often gives a false sense of security another thing you see in the app there is this game button it's the floating action button from a theory Android design and it brings you to different places you can scan your c67 from for example another app you can import a Jason UDC key or rocky or plain address unfortunately a lot of people don't use c67 so raw addresses are like really a pain but they are out there and you can scan signed an unsigned transaction IP that helps for offline transaction mode so I will talk about it a bit later a bit more field it looks like that basically on the left its the incoming role under the incoming button and on the right is the outgoing role because I love for it to be a balance I think very you should not pile up where you should flow in and flow out I'm breaking a bit dammit with user interfaces of other wallets but I think that's okay actually try to keep concise visual language there you see different transaction states you saw before always at the icon there there's unsigned transactions when you don't have a key you can have watch only accounts you have signed and confirmed but for example not transact because you're offline then you can even delete them but only locally they might be already sent and then through black assigned and confirmed on the blockchain you cannot delete them for sure let's look in the navigation drawer you can edit your account very important always your keys your account not your keys not your account import and export keys some settings of nine transactions very important and debug at the moment it's alpha so debug is very important so you can see it ago a theorem you saw this left eye before I don't really use it like the blocky items so I really want to use Peterson Aggies flame IDs but there are same thing with the building blocks because to calculate these lame ideas takes a second under 1070 GPU so we need to true bit and stuff first to get that stuff secure because I cannot calculate that on the phone here you can edit your account basically with the camera h @ watch only account with the key generated key and trans are very important I think that's the first wallet for a serial support I think hardware wallets are the key for security and are also an option to be a metaphor for useless because they know if they have a hardware wallet it's really their key because only if the key is on your device you're not really sure if you're in control but half of all it can be a nice metaphor like UX metaphor I try to use common symbols these are from material design to always be concise all over the app that you can educate users that they have a nice experience so scan the code offline transactions trace or share private key and copy some content that's all over the place always the same that's how it looking when you add a transfer device then you have to enter your I don't know if a lot of people of you use Tressa so far there you don't see the numbers because the numbers show up on the trans oh so that your device can never access it you can that's optional at password and then you have also have plausible deniability really nice feature from Reza then you can select account from the tresor with the derivation path watch the speed up a little bit sorry for that yeah you can export the keys important import-export keys always check for that and here very important the settings I always use in my apps today and night theme because it's also you don't want to be blinded at night and it's day you be able to read something so in all of my apps are used a night on the bottom you see you have the option to enable light client I thought at the beginning you always have to have light clients but like clients unfortunately are in a very early stage and not really usable they make your phone really warm that might be nice and burnin but it's really bad it's so warm so at the moment I have it as an option but later on I want to have it on by default but currently it's it's not having a good user experience and I want to get to user experience nice first and later on if light lines are really really usable I make it on by default yeah these were the problems with but the go team big hands to the go team because there also report a lot of bugs but they get fixed that's really good and we need these light clients because currently the world leaders it's crazy and were the world we are living in and the problem is with we have a lot of centralization in the theorem also and we need to fight that because all the infrastructure we have currently and we take for granted could be gone in the second just really bad and also please all I want you all to survive please install the offline survivor and you're just in case you know yeah and also please everyone activate lights off because a lot of incentive structure yet and people don't activated please activate it on all your notes so we have a better experience all the tools I support g20 and all the total support is coming from my ether wallet if you want to add your own talk please make a pull request against this repository and also a big shout-out to the my support team is just awesome what they are doing there what you see here yeah platform is bonus yes sorry but we have to hurry yeah longer but we have to hurry here is very important the keys are in the user data directory and the cache has authorized landed and you see how big the light client is like 500 megabytes so you can safely delete light client data but please never delete the user data because they are your keys and I don't have them I cannot secure them even if you ask me I have no chance I don't I don't have them very bad where to get your stuff from there's a trade-off between convenience Google Play very convenient but very centralized and not free and get it github is just like and syndromes also centralized but I mean you can better it's always build from source and something in between is f-droid also really nice project it's in between basically and don't get it please from because I didn't catch the instrument is a very sad story there is Kotlin like everything is written in Catalan there's cotton stuff emerging I wrote a library aetherium it's the cotton it's um library and I have to stop now I have a breakouts and at Android things I have a breakout session at 1650 in the breakout room so I hope to add some stuff than there thank you very much here's a follow-up Ligety is my thought ok we have jared hope with presentation status the edges of the network cool yeah hi I'm Jared I am the main organizer and thought leader on open source mobile therm client called status show hands has actually heard of us amazing cool for those who don't know status is something like a hybrid Instant Messenger and mobile dab browser and really we have one goal and that's to take ethereum technologies and put them in the hands of people what I love about the etheric immunity is we've taken this further for crypto but we've tempered it with pragmatism and this is my book chain technology palatable for organizations banks and governments alike however this pragmatism has been somewhat of a double-edged sword when it comes to taking this technology and putting it in the hands of people and I'd like to start off with a short story that I think illustrates this point so on October 1st an autonomous community of Spain Catalonia held a referendum of independence leading up to the event they used a superb decentralized file storage technology called ipfs to organize their votes however non-technical people were using a centralized HTTP proxy and access this information through the comfort of their own browsers leading up to the events on the September 26 I believe it was Spain issued blockade of 140 domains one of which was this gateway politics aside disrupting a vote shouldn't be that easy at the same time the Tor project saw a surge in the downloads of their messenger this is the Catalans hardening their communications and one of the many things we can applaud the Tor project for is that they understand their need to package and make their sophisticated software easy for the average user to use without compromising on the integrity of that software because when push comes to shove decentralization matters and so how we package disseminate and present these technologies to the end-user enables them in ways that we haven't been able to do before and this is really the core problem that we aim to solve at status so since our last step con we spent a lot of time thinking about the overall user experience and design of the perfect ethereum client and nothing matters more than that first run together with our community we've decel discovered what we think is the typical emotional narrative that's a new person coming into the crypto world is likely to experience and on that first run we want to make sure they feel safe in control not overwhelmed while at the same time connecting them with their goals and allowing them to explore therem how they wish well at the same while at the same time we don't want to overwhelm them or demand information from them unless it's absolutely necessary for example we don't need them to backup their key phrase until they actually have real value in their in their accounts and at which point if backing up their key phrase does become completely vital and they have a reason to do so and so that's when we educate them we're also introducing an omni bar into status which means that you can access anything you want to do with an ethereal within just a few taps whether that's accessing taps finding your friends opening new tabs or signing a transaction we've also worked together with our community to develop what I think is one of the most visually stunning and intuitive wallet experiences that frames your digital assets perfectly we've also wanted to make assigning transactions as less intimidating as possible while at the same time bolstering their protection against phishing attacks with a signing phrase of three words why will building out that that signing phrase we actually found out that many of our users want to store sums of value and control them from their mobile phone which are much larger than what I would fit in their normal analog wallets and we realized that a software key pair is just not going to cut it so today I'd like to introduce you to our new initiative which is the status hardware wallets this is an open-source of Java card that allows you to take the trust safety and security of a hardware wallet but use it on the go it has two modes of operation the first of which you can sign transactions directly on the on the card of arbitrary sizes however this requires the vendor specific hardware namely to support catch act 256 and proper EC point multiplication it is in the 305 spec but finding a vendor that properly supports it is somewhat an interesting problem and also to support Bluetooth as another communications protocol aside from NFC and contact the second mode of operation of which science transactions generated off card ultra all signing is pin bound however we do support key pairs and HD wallets with the HD wallets having two extra features the first of which is to a store and export your whisper identity and the second of which is to actually make one derivation path pinless and therefore this account becomes balance bound but allows you to have frictionless transactions but signing transactions doesn't really mean that much unless you've got someone to send transactions to or something and so with discover we really want to connect you with people and apps and communities so we're solving a research problem in a decentralized manner and this is what we do with the discover discover is basically a naive epidemic protocol in which users publish public statuses with the use of hashtags and this is propagated to their friends every user then collects a case of messages that they've seen and periodically they generate a preference list and then share that subset with all of the all of the contacts this preference list is generated by a bunch of different weighting factors for example if their mutual friends that they're like how recent it is if they're online there's a bunch others oh yeah like if they've been chatting with that person or interacting with that DAP for a long period of time and if they trust them and so in status we're actually going to be building multiple layers of trust and this is the only the first layer which is basically automated because when the status is shared it is signed by the propagator this allows us to build chains of propagation to see how far something is propagated I hope by and the same with moderation and reporting so as you may know status is built entirely on ethereum protocols and therefore we use whisper as our messaging transport whisper has amazing privacy features built into it however it does it isn't without its problems and one of these is essentially both peers need to be online when communicating in normal usage a sender will send their message to a recipient it'll bounce around the network eventually arrive at its destination and this recipient will send an acknowledgement of that that message however if the recipient is offline the messenger the sender will send out a message and periodically resend it but the recipient is both unaware that they've received a message and they need to be needing to come back online and wait for the sender to rebuild their chat history so we are introducing status nodes which act as offline inboxes of four whisper as well as helpers for external services such as push notifications it basically works on a promise challenge deposit and it allows the sender to sent these messages outs they get collected in these nodes there recipient that can be then informed come back online and rebuild their history with a note even if the sender is not available well you may be wondering well who is going to run these nodes and of course if somebody has a server they can run it in a headless way but really we think we can do a bit better than that and so we actually think you can do it because we're actually expanding our platform reach so we're not targeting Android and iOS anymore but we're also targeting Linux Mac offs and windows and so with this you are we're going to make it dead easy for you to set up a status node and integrate with our external services whether there are other chat protocols or push notifications and at the moment we have an internal friendly competition we do build status on a single code base and that rests on top of react native so on the the more developed version there is actually using react native web and the others other one is another fork of a Conoco project where we're actually building react native from the ground up for desktop based on QT and currently we have 60% component coverage on that so exciting times for us in addition to this another problem that we've we really faced in growing our organization is that the talent pool in the crypto community is exceedingly small so we want to take the strengths of being an open source project and help incentivize contributions and this is what we're doing with open bounty this allows you to assay to to take any github issue and create a bounty for it that anyone can then contribute to whether it's earth or any RC 20 tokens but we're actually taking this a step further from just the general mechanism which we've had for a while and we're actually building out our talent scouting and human resources around this so we can help other decentralized organizations build their build their software just like we are and in fact we also have a million-dollar bounty coming up to help other organizations get involved so please come join us at our open bounty dos datastore I am if this is interesting to you in terms of our next steps well now we need to focus on optimization we're pouring our security audits which allow us to move into production we're also supporting identity standards and we're experimenting with the swamp messaging service Pierre says for more convenience so that's it for me I thank you so much and I hope you're all using status [Applause] [Music] hello hello okay next up this morning we have Felix lunch with evolving dev p2p Oh check check hello guys oh thanks yeah hey guys so many people here yeah I'm Felix what is it should I use this okay hi guys so I'm Felix I work for a theorem foundation on the Goya theorem client and my role there is mainly bug-fixing in feature development but I guess there's a lot less time for new features lately and my passion and this project has always been you know like taking care of the way that no it's talk to each other and this is also what I'm talking about today hmm so def PDP wasn't came into existence I guess three about three years ago and at the time the vision was to as you can read there provide the lightweight abstraction layer that provides low level algorithms protocols in services in a transparent framework so you know like it was a pretty grand vision in 2017 though def PDP is just this thing that you need to implement to talk to the ethereum blockchain and it's part of all know any theorem implementations so all of the 6-7 implementations that are alive on the network have an implementation of def PDP and all of the stuff that's in it and there have been very few actual protocol changes since 2014 so if you wanted to you could count them on one hand basically def PDP has a bunch of elements to it so the first one is no discovery protocol which is a way of finding other nodes to talk to then there is the RL px transport protocol which is what it's spoken on the on the TCP connections between nodes and finally there's an application layer protocol that sits on top of the RL px transport protocol and this one is somewhat confusingly also called F P DP so both the overall system and this particular protocol are called FPTP let me just walk you through the protocol that's in use on the network today and then maybe like we'll come to the part that can actually be improved about this so this dark circle there that's that's us so that's where node that wants to connect to the theory of network so how do we do that so we'll join the DHT first and the DHT is basically the part that is this thing where you can find the other nodes that are on the network yeah so there are some other nodes they are also registered there and then basically we walk to the HT at random to find someone to connect to and then we try to establish a TCP connection to them and the TCP connection might actually fail so this happens quite a lot because the node you know might no longer be live or you know it might be too busy handling all the connections but let's just assume that it works this time so once the connection is established we actually exchange capabilities with the other side so basically this is now the part where like the def PDP application layer kicks in and in this particular case we see that the shared capabilities or is it there's just one shared capability and it's it's the eath capability in version 63 so now once each version 63 is running we can exchange information about a blockchain that we're both on and once that matches we have a new pia yeah so that's the current system and it's not super efficient and well there's a whole bunch of details that I haven't really talked about but you know I guess you kind of get the idea so what can we improve about this though so first of all you know it's kind of annoying that there are so many round trips just to figure out whether someone is on you know the right blockchain I mean I guess that's kind of obvious and then it would be really nice to just sort of know that like before even connecting maybe and then another issue is that the whole system is basically frozen so making any change to any of the protocols requires like really tight coordinations requires implementation consensus and any changes we make needs to be backwards compatible and to achieve upgrades at all what we've done in the past is we we've made all the upgrades by cross-compatible and we've tied them to a theorem main that hard Forks because well everyone has to upgrade their node anyways and then once the hard work is successfully launched we can start phasing out the old stuff and just you know only speak the new protocol but you know hard folks don't happen all that often and we'd rather you know make changes on an accelerated schedule but it's like really not that possible and then finally because no discovery only relays information about the oral TX protocol there's really not there isn't like any sort of room for experimentation because whoa we essentially stuck with ROP X and the crypto system that it uses so improving these things is the no discovery version five effort and with no discovery version five we want to make two changes in particular or rather we want to achieve two things in particular so the first one is we'd rather you know be able to find notes more efficiently and then the second one is we'd rather know more about those notes before even connect so the first part of our solution to these issues is called E&R which stands for aetherium node records so earlier in the v4 overview you saw that the DHT holds all those in ode addresses and then a node address is really just a public key and IP address in two ports if they're in node records can hold arbitrary information about a node so that's the main difference so this arbitrary information that can be information about the capabilities of the node it can be information about other transfer protocols spoken by the node it can be initial key material photos for those transports anything really like as long as it fits into 300 bytes we're basically like almost anything can be relayed there and the limitation of 300 bytes is important because E&R is a separate form at a separate spec event and it's not at all connected to the DHT so you can relay those records through any other means if you want to including say a DNS record or something like that and then finally node records are signed and also versioned so if you have two versions of the record that described the same that describes the same node you can determine which one is newer for example and we think that you know is a good solution for the transport legality problem because again information about arbitrary transports can be related to this protocol and well yeah because there's just a lot more room to put you know information about anything so we still need implementation consensus though because you know in order to be able to talk to everyone everyone kind of has to agree on you know what the language is that they're speaking to that they're using when speaking to each other and it is very likely that for a considerable amount of time the lowest common denominator will be ro px but eventually once enr is launched we can actually try out different transports find a viable alternative and then you know maybe like at the end of 2020 like delete or LP access so in order to get in our launch though we need to upgrade the discovery protocol this is something that needs to happen once and it will be a backwards incompatible upgrade so likely what the way this will work is that the discovery version 5 DHT will be a totally separate DHT that will run in parallel to the current system and because this is kind of a unique opportunity for us in addition to you know just including support for enr we want to make a bunch of other changes to the protocol in particular one problem that the v4 discovery one problem that that v4 discovery protocol has is its reliance on absolute time so maybe you know some of you have actually experienced this so if your clock is off let's say bye-bye to minutes you won't really be able to connect to the network and we've worked around this by like alerting users when the clock seems off but that's a really ugly workaround and you know like we might just fix it in a protocol this time and then with many of the notes in the DHT you'll find that the information that's listed there isn't very accurate so you might you know not be able to connect to this node at all even though it's listed there and in v5 we want to introduce this concept of endpoint proofs where the DHT ensures that if if nodes record is listed in the DHT you there's a pretty fair chance that you'll actually be able to talk to it and then finally we have another we have another improvement which is also which can be considered an extension of the of the HT protocol and this is the this one is about finding notes more efficiently so in a classical THC so to say the DHT is an index of nodes by by their public key and it maps public keys to know the end points but well so the nodes in the DHT though they're not in any kind of useful order so you'll find an if there are may not note next to an a theorem classic node next to a node that doesn't really participate in the affair and blockchain at all and there isn't really like an efficient way of like knowing about you know just in those that you care about and contrasting that the the topic index that we have in mind is sort of like in index of all the nodes by by that by the topic or the service that they are providing I don't have a lot of time today to really go into the detail of how this works but I can give you an overview of the design constraints that we set when when when making this protocol so the first big constraint that we had is that we don't want to split up the DHT because the DHT it's bigger is better right I mean fundamentally the security of the DHT depends on the number of participants in it so you would want to like always have a very large number of participants and another design constraint we had is that these topics kind of have to scale to an arbitrary number of participants so there might be topics that everyone is advertising like everyone who's in the network but then on the other hand there might also be topics that are very small and only advertised by let's say five or six different nodes and these topics shouldn't really compete with each other so you should be able to resolve both equally quickly and then finally what with all of these systems there is always like the danger of you know people spamming it with like arbitrary registrations that nobody ever cares about and those particular registrations should not drown out you know the actual useful ones that you really want to see and to combat many of these attacks the topic advertisement protocol includes this thing called advertisement inertia so this is really just you know an artificial delay and forced by the protocol before a certain registration for topic can go live and we feel that you know in addition to maybe reducing misuse of this in addition to you know combating these attacks this also reduces the misuse of the topic index because fundamentally topics are meant to be used for announcing big decisions like way ahead of time and those big decisions can be something like which blockchain you're on or which chart of the blockchain you're on or well you know things like that and not so much like let's say the URL of the video chat that you know you're just starting so there's a we really want those things to be used you know like four four four facts that will have meaning so to recap the note discovery version five is about finding notes more efficiently and knowing more about those notes before we connect a prototype of the system although without the ENR has been in use by the gaslight client since early 2017 we're still working on the e IPS so nothing is published yet but once it is we will have like a separate spec for ian's or a document that goes into detail about you know like the semantics of the topic advertisement protocol and finally a description of the actual wire protocol that's spoken by UDP but there is really nothing set in stone yet so if you feel like you know there is a certain change that absolutely has to be made or a certain feature there to really be an clue were not included just come talk to us that's it [Applause] hello up next in stage we have power Blitzer with EB MC portable API for ethereum virtual machines [Music] hello everyone yeah so I'm I'm I'm palpable Itza and this talk will be about EVM and EVM C which is portable API for a three-on-two machine I'm software software developer I am specialized in C++ and currently I'm working mostly in the CPP aetherium project and I also am of the author of EVM jet which is alternative VM implementation that translates evm bytecode to native machine language and and I also try to come up with the API for for EVM and that is called TV MC so this talk will be will have two parts first one I would like to explain what exactly am I talking about and what I mean by by EVM API and EVM interface and in the second part I would like to show what what have been done so far what we wanted to do in the near future and explain some design decisions we made so far to be able for you to better understand why things look as they look at the moment so evm the etherium filter machine one of the most important components of ETM software and through ecosystem so it's in short words virtual machine that actually can execute small programs or small scripts called smart contracts and yeah where it is every every atrium client at least four full notes have a VM somewhere inside usually there is one implementation of that but we have some examples where EVM clients can actually have more of them and and CPP atrium is one of the examples here but the problem I would like to address is the fact that EVMS are somehow embedded inside the client you can have more or less indirect access to it to ezm through JSON RPC some test RPC systems VM tracing storage backlog and and so on but what what I try to address is I would like this this composition to be look more or less like this one so this thin layer that actually connects EVMs to theorem clients to be to be very well specified very well documented and to be also usable in from different programming languages and also what can can add to this to this scheme is to be able to actually plug in the same a VM implementation two different clients okay so if EMC is one of the possible solutions to this problem and it's it's exactly what I what I what I mentioned before it's a VM API that uses C language to kinetic the this to now separated components the the EVM in virtual machine to be connected with a Syrian client and YYC language was chosen not because it's the most beautiful one but it happens that C is actually accessible for many many programming languages the obvious examples are C and C++ but for many popular languages that are around you can actually at least use some C libraries and use execute functions from C libraries from that languages I tried all this stuff with with go using the C go tool and also in python using c FF i library but I'm sure there are examples when you can at least use C libraries in in more more high-level abstract languages and the second important part of that is we want to have polymorphic interfaces there so we would like to be able to use different to switch between different evm implementations and runtime not that we want to build a client with this one and decide on on the build time what what actually implementation would like to use yeah we wanted to have a switch that user can actually use to decide what kind of back-end they want for its tasks and and the third third important part we we took account of to make some design decisions is composability so the composability means actually we could do something like that when having some concrete implementations of vm we can add more and more layers on top of that that actually delegate the execution to the lower layers but on the upper layer you can make some additional decisions where actually wants to send your code to so for example if we can consider interpreter and get like a VM you might want to actually have and top layer that actually decides if the code should go to that the JIT one or to the interpreter one and the top layer can actually for example count the number of executions of particular code if if we have some hot code that is executed in many transactions you might want to actually translate that using the GT VM to some native machine code and speed up the execution but that might not may not have sense if if you want if if the code is not frequent enough to actually pay the cost of overhead of doing the translation upfront and not having my may not make a lot of sense the second example of such such a composition can be [Music] having actually different languages in smart contract if we consider the proposed EU azzam and EVM 11.0 we can just add very simple liar on top of that that actually can recognize if the smart contract uses the web assembly like language or EVM one byte code so how actually this EVM C looks like this is actually the single file a single C header file and includes declarations of functions and structs and also all the documentation is is this file in in form of of comments so this is actually the the only source you should care about and I paid attention to actually have good enough documentation to understand how it works just reading the single file and at the moment this is part of my EVM G project were and as long I'm experimenting with that and the API is not finished yet we it's included in this project okay so the whole whole design has some kind of to two parts two sides and the one is related to the client to the client side and one is related to the EVM itself on the client side what have to be done you you need to implement implement some context class and contact class provides virtual methods and can answer questions coming from from evm and these questions are something like get me the balance of given account or get me the storage at the given storage slot for forgiven contract all this information cannot be provided to the AVM upfront because we don't want to send the whole state to the AVM to execute smart smart contracts but DVM need either way to actually extract this information on demand on the second side on the AVM side there is AVM class and EVM class it's quite simple there is a way to actually construct the AVM instance and there is a way to are to destroy it and the core function is actually execute function when the information what is to be executed is encoded in a new message object and also the context is provided for the execution and if EVM uses this context interface to to ask for a mooring for more data if needed so in case you would would like to implement new client but you don't want to in the same time implement a V ender you would like to use some of EVM C compatible EVM is available and what you have to do your job is to implement the context class and there are eight virtual methods - that have to be implemented and you have also encode your information what to execute in in the message in the message structure and if you would like to for example implement the EVM but you don't care about the rest of the etherium client like networks dark non storage database and so on all you need to do is to implement the create and destroy pair of functions and the execute one so not to be confused this design operates on the object-oriented concepts but on the way you will do that you will have to translate it down to the C so it gets more obscure and and complex so what we have so far with this so as I mentioned at the beginning the C++ client have actually to two VMs and one is classic interpreter and it actually does not use the VMC but we plan to do it in the next in the near future but evm get the treat like a vm uses the idioms the interface and it's it's compatible with the recent hard fork of byzantium there is also the hero project that a prototype of a tedium client with you as embark end and there is also a prototype of EVM implemented purely in C language I also prepared some time ago a prototype of GAF with the EVM duty plug-in and the Python Python client with EVM jet plugged in this to needs some work and it requires updates to the current status of the code but it's quite fun to play with that and what we wanted to do next the missing piece of EVM C API is it's VM tracing and this is a showstopper for a moment because we cannot replace existing VMs completely because this missing feature is important in other in other places we would like if this is in place we would like to move the TPPA interpreter to use the idioms EVM C interface as well and I also plan to to release experimental graph with a VM did as a victim on machine der recently also someone considered to using this interface together with fast testing project okay that was all from mine thank you for your attention and in case some questions I'm available for ya for how they've come around thank you it's not on hello it is No okay up next we have dr. Greg Calvin with the evm cleaner meaner and closer to the metal don't clap yet' getting the equipment set up I'm Greg Colvin we discovered we can't play videos off the USB stick from the back so I have to control my laptop from up here and hope it all works good morning that's sort of pretty but it has nothing to do with what I'm going to talk about this is highly highly advanced technology highly skillful technologists I think I was supposed to be here last night so we could work this out but our dinner was like an hour late so they kept bringing us free beers to placate us I usually drink one beer a week so three beers in one night is like a bender for me no that won't help it's live okay they put it in a different mode there's a little flicker okay [Music] I'm Greg Colvin I spend my time for aetherium working on the virtual machine working on improving its performance and working on designs for possible successors to what we have in order to solve some of the performance problems that we're running into if this works there will be another slide how about that um the first problem you run into in any sort of optimization work according to my old friend Jerry Schwartz is one all benchmarks are bogus you'll never have a set of benchmarks it actually represents the real world but if you don't have benchmarks you will just go in circles you'll you'll never make progress so the benchmarks I'm working with are a few algorithm kernels that are relevant to what we're doing RC 5s and old and useless cipher but it's a good example of a cipher that uses a lot of 32 and 64-bit arithmetic a lot of complex logic and Blake to be is still an important hash function it's also a lot of 64-bit logic blum blum shove is a cryptographic rant random number generator I think it's one of the slowest in the world it operates on big registers so we could use the 256 bit registers of the VM effectively an DC mall also can use big registers effectively and then I have a few tests of act individual evm operations and those are small EVM assembly programs to try to isolate individual operations and this is a graph of what I got with the whole thing and it's a bit complex but what you can see down along the bottom is the different benchmarks and along the right are the first three are some major clients EVM is our go client parity is Russ client ithi M is the C++ client Y the rest aren't clients yet but EVM to wasm is part of the azzam research it's a program that takes EVM code translates it into azzam code and then I fed that to Google's v8 engine which generates assembly code EVM JIT Pavel was just talking about it generates assembly code directly from EVM code and then the native C++ is I rewrote the benchmark programs in C++ instead of solidity or EVM assembly and compiled those two assembly so pretty clearly the C++ wins the race and pretty clearly exponentiation is pretty hard for everybody which isn't surprising but it's a little concerning there there might actually be possible exploits by writing contracts that do exponentiation and get charged only a few gasps but take a whole lot of time and rc5 looks pretty hard because rc5 works on dynamic dang and EVM does not yet have a shift operator and so it gets imitated with exponentiation and in between things are relatively regular and the speed you could actually predict by the language that the client is written in oh where did that come from next slide I can't see the screen these glasses on so to simplify it this is looking at one angle it's a harmonic being of the performance of each client yeah and it shows pretty much the same thing so clearly the interpreters are not as fast as as going straight to machine code by any route yeah and clearly some interpreters are better than others but they've all been good enough so far for our purposes and of course I love car races as examples last year somebody in the audience shouted out that instead of used in classic cars burning tons of gasoline I should be using Tesla and Tesla's are nice George Hallam here are you here George George would agree that rather than a Tesla this would be much cooler this is a 68 Mustang hatchback under the hood is actually some powerful electric motors and the trunk is full of lithium-ion batteries and if this works where's the button we will see how this does against Tesla it's ready sound just no such luck but there goes the Mustang Tesla doesn't have a chance I did just missing but after a quarter-mile it had gotten to 140 miles an hour that's a lot so what what keeps those interpreters from reaching native speed and the first answer is they're interpreters so they've got that overhead you can work hard you can reduce the overhead but generally you can't do better than about three three or four to one compared to native code um for our particular interpreter the 256 bit registers slowed us down because real hardware has you know 32 64 bit registers and the unconstrained control flow hurts us a lot and I'll get to that the 256 Hertz if you remember you know grade school math adding multiplying you know two numbers is pretty easy you can do it in your head if you have you know four numbers suddenly it gets a lot harder and it's quadratic so it gets worse and worse 256 squared there's a lot control flow the jump operator and EVM I mean you know go twos are considered harmful but at least you know if you say go to label it will go to one in exactly one label in the EVM you say go to whatever's on the stack so there's no way of knowing oft and statically where it's going to go so you can have a nice little program like this and F calls G and H and returns and it calls AI and returns etc nice clean structure no trouble no trouble to understand static analysis anything no trouble what's it actually looked like to the EVM that's what it looks like just the EVM so if you're trying to do formal analysis if you're trying to write a compiler if you're trying to do anything with it again the number of paths goes up quadratically and you're in trouble because pretty much if you can't do it in linear time or at least n log n time on the blockchain you know that deployment time or at runtime you can't do it so how do we do better well EVM JIT is already doing better I won't back up but if you look at the slide the EVM JIT is actually pretty close to the native speed you know it does very well on the wide arithmetic and not so well uh narrow arithmetic and complex logic but it's a very good chip I've told Pavel he gets to be the electric Fox he's tired of these little you know three and four letter names that don't mean anything this is a racing team out of Latvia that's a completely electric dragster and here it is winning the European world record there it goes to drag races are fast it's not impressive is it it's over hello 275 miles an hour just a few seconds love these things so we've got we've got two research programs who that have been going on how to improve things they've been nicknamed EVM 1.5 and EVM 2.0 which doesn't really mean anything except those are the nicknames and for 1.5 that's that's a suggestion to extend the current EVM by adding adding new op codes and requirements so we forbid those unconstrained jumps you just we will not allow you to do that and we we then have to provide a way to do the things that you otherwise do with those jumps so there's up there's up codes for subroutines and then we've got to get away from having nothing but 256 bit registers so we've got op codes for native scalars and op codes for sim D because real hardware has all this silicon devoted to assembly registers and if you go to google and type sim d crypto you get a lot of results so it would be useful to make that hardware available and at deployment time there's a validation phase that goes through the code and make sure that it actually does follow the rules what a concept and then 2.0 [Music] well gee it provides opcodes first Autry control-flow you know it's stricter than 1.5 it actually looks like a high-level language with if-else and such and it provides off codes for native scalars it Cindy provoke the Cindy's coming later but there's a Cindy proposal and it also has a validation phase where it validates control flow and stack discipline and type safety so they're very similar at that at that level so we've got some technically very very similar proposals um they both provide for for very fast compilations a native code it could be done as the JIT yeah we've come to realize etherium cannot do jets there they are actually exploitable that is if you find or write a contract which takes a long time to compile with the JIT but requires very little gas to run and you start hammering those contracts you can you can do a really nice you know do s attack so if you're going to do any compiling you've got to do it up front at deployment time and Martin's notion of transpilers I think is very important here um 1.5 could be transpiled to 2.0 y 2.0 can be transpiled to 1.5 1.5 or 2.0 can be transpiled to 1.0 either of them can be transferred to the JVM you can make up new ones pretty much you know you can compile any VM you wanted to some other VM and he also has a notion of gas injection so you put little pieces of code into the right places to count the gas and what this means to me is it doesn't matter what execution engine a client chooses because on the blockchain you can put a contract that translates into that execution engine so these are these can be completely independent choices and we could actually choose to support a number of VMS if we wanted to and independent parties could decide to support a different VM but a transpiler on the blockchain and away they go um gee I'm almost out of slides and there's no sound that's really too bad so what what is the big deal about native performance and what's the big deal about being lean and mean and close to the metal well we saw the electric dragsters here's like a real top fuel dragster they run on a mixture of diesel fuel and nitro methane and just about a month and a half ago not too far from Ming's place in Michigan this guy got the world record and it's over 338 miles per hour and a quarter-mile these guys pull about 5 or 6 G's which is about the same as an astronaut taking off in the space shuttle but there's a problem with going fully native in the save world we call it undefined behavior hello no oh that's the less come here okay play play there it goes what's going on my screen they'll try it again dudu the driver actually walked away unscratched I love this guy we'll give you one more and it turns out I'm done so I knew it audiences love explosions I'm done [Music] [Music] [Music] you [Music] [Music] [Music] [Music] [Music] you [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] testing [Music] this is the evolving the evm panel I did it works whoo-hoo find a seat panelist say everybody I'm chasing out for a half and I asked to moderate this panel because I've been working on EBM and he was him lately and I know there were there are no other experts besides these panelists so he saw Martin's talk yesterday and well it was on Crimea but it mentioned the precursor to Crimea which is he was ohm and that started in December 2015 by the summer of 2016 the first comment was in April but by the summer there was a pretty working prototype for the EVM to ewaz 'm transpiler then so that was the EVM 2.0 so after the 2.0 proposal came the 1.5 proposal from Greg and Pavel and you just saw hobbles talked earlier about EVM C which is sort of the the API to plug in and be able to swap between awasum and and EVM 1.5 and then came earlier this year was Julia yesterday also saw Alex Alex's talk about Julia which he and Christian designed to upgrade solidity and be able to make solidity target the EBM 2.0 the next versions of the EBM 2.0 and 1.5 and then and since then also Pavel has made a lot of progress on the legit VM so it's sort of been backwards where first EVM 2.0 was proposed then more progress on bbm 1.5 I hope this makes some sense so I I think I'll ask our panelists what is what is duis and we're just EVM 1.5 when I arrived I guess he was him had made some progress substantial and a few things struck me one is people were sort of excited because she was you could you could run you know C++ contracts in E was them and as a C++ expert I said why on earth would you want to write contracts in C++ haven't haven't people lost enough money on the blockchain already and the other thing that struck me was why on earth would you want to hand over to an outside committee the definition of anything to do with the core consensus protocol and I looked at you know the current EVM and said there's an awful lot of white space for more op codes and this thing's not broken it just bit needs a little work so I set out to say what what do we need to do to this to bring it up to modern standards and make good use of modern hardware and so I got to work on that and I got a lot of help from other people on the C++ team the documentation would not have happened without Christian and so the team put a fair amount of work into that we've got a couple the IPS Martin has put a lot of work into the EU Azzam proposal so they're sitting there and we'll need to make some choices and we might throw both of them away and say oK we've learned a lot what should we actually do we might choose one of them we might stick with what we have and ask and we advance our compiler technology to compile what we have into code better and pavo can speak better to how possible that actually is yeah I would be very happy to have any of these but to add it more constrained to the contour floor would help a lot there and I believe who can do much better in grid-like EVMS if you have that you know just a step back so last year when you came around and even 1.5 came around it was still in a point of time where webassembly was not finalized at all right and there was no knowledge at least we didn't have any knowledge when it's gonna be finalized and since then this year the first version came out so that problem went away and you know like back a year ago we had no idea when it's gonna be finalized and how it's gonna look like when it's finalized and so there was a big concern and I think because of that even 1.5 made a lot of sense to maybe bridge the gap or have like a you know back-up plan assuming that EVM 2.0 would be finished in time but we cannot release it because the valve assembly isn't finished and then if you could finish even 1.5 quickly enough it could be a good bridge between the two but that problem went away today well you know the earlier this year so how do you feel about the brokenness of EVM since did did anything change actually I think he was gonna die why do you think that because there's been so many attempts to get a binary format running in browsers and they've all failed you're saying webassembly is gonna die not gonna die whatever I said that's a bold prediction but we can step back and say what are the problems with the current evm 1.0 I mean one problem is that the gas limit in each block is not enough to do everything people would like to deploy contracts to do because one example is the Blake to be pre-compile there's a proposal for these native pre compiles and pre-compiled solve the problem of contracts that people would like to deploy but they might take you know a hundred million gasps when the current block limit is the current block gas limit is 6 million gas so how does EVM 1.5 or or webassembly solve this problem well simply allows you would allow you to congest compiled code directly to web assembly so you most likely don't need native native contracts because you would just write them and what assembly but it's partly just that it's too slow you know I mean Pavel was working I remember on one of the pre compiles that you were like pushing all the compiler flags as far as you could and trolling through multi precision libraries to find one that was mostly in hand-coded assembly you know we just can't get enough speed out of the VM for these free compiles and then how is 1.5 in in 2.0 how are those becoming faster than then 1.0 i'm just like my little grade school example you do a multiply and you're doing one instruction on a 64-bit pair of registers as opposed to the long division or long multiplication on a you know collection of registers I think the the current if you have is quite big difference in terms of speed comparing to native code so we we cannot actually effectively and code the algorithm we want there for example some hash functions and and that makes them if if you like to implement them in pure smart contracts that make them quite expensive and you have to pay for that you have to pay a lot for that because it's just the current EVM is not capable of Express enough to have comparable speed comparing to native code and I believe that's what for example web assembly gives like it's it's at least comparable like if you implement the same heart function in in C and web assembly at least you have comparable of them and not having like times time ten to two 100 times slower performance but actually if you if you take a step back to like the first version of EVM and look at why do we have or why did we had an identity contract just for achieve memory copying that maybe shows that we didn't had everything thought through properly and we started to introduce these pre comp eyes especially the one for copying memory and that means loading and storing memory was too expensive yet we still wanted to do it so we introduced the pre comp I'm and another bigger issue which Craig mentioned several times already is the bit with everything is 2056 bit and there was a proposal even before the 1.5 to have 64-bit arithmetic syn EVM and you have folded that into the same D proposal as I still there and but if if we if we just look at these two problems that it's quite wide for arithmetic and we had we started to introduce all these pecan pies just to get around that that prop probably shows that we didn't figure out the prices properly and bit where the assembly espousal said it's resembles the instructions much more closer to traditional computers so there's a much probably much easier way to figure out what the real cost for those instructions are and by figuring out the real cost and we can probably avoid having pecan pies it's worse than 10 to 100 but my graph was scaled by square root and the slowest exponential operation compared to the fastest native code was ten thousand to one but that was on EVM to blossom right action it was actually go versus C++ compiled straight to assembly so another advantage of another motivation for the II wasn't proposal was to be able to break contracts in other languages that target web assembly as a as a compilation target versus only targeting EVM so we have the the EVM to e wasum transpiler as a prototype we don't yet have the e wasum to EVM transpiler so the reverse which would make the EVM 1.5 proposal equivalent to almost the e wiesen proposal because then you could still write languages right of contracts in languages that target web assembly transpile those two EBM 1.5 have asked before how we what would it take to write the EVM the II was him to EVM 1.5 transpiler and craig said it would be easy martin said good luck good good luck hitomi would be it's not impossible I wouldn't and would never say it's impossible you said it would be it's gonna be somewhere it was a fire escape in Berlin I mean was I sober and also one of the motivations for just skipping evm 1.5 and just and because the original proposal was just going straight to 2.0 the evm 1.5 proposal came later and one of those reasons was because well it must be hard to write a JIT a compiled VM and then and then you know Powell wrote a prototype of a PBM JIT vm is what was that easy power so actually the prototype of that it's still a prototype it was it was it was done even before the launch of material it was one of the performance benchmark project that we wanted to have to actually assess what can we do in the future in terms of smart contract performance but yeah it's it's it still struggles with some some cases and as I said we can do much better in this case but and the required that is it's at least this control flow restrictions and subroutine support directly in the in the EVM byte code that would allow even more optimizations and but on the other hand like JIT compilers are hard I mean [Music] the network processes depend on that and like the risk is like we might might get hard or it might be never finished in terms of removing bugs and finding edge cases because thus that's much more complex construct comparing to interpreter I mean another problem with with just-in-time compilers is that I'm not sure if there is a just-in-time compiler that provides a fixed upper bound in terms of resource consumption and this is a very important guarantee that we need in order to do to do the the gas calculations properly right I mean usually just-in-time compilers generate code that is faster and takes less resources but we don't have a guarantee or do we well as I said we can't do a JIT it's it's exploitable we have to it has to be a compiler that runs at deployment time not at run time which means it can be a full compiler depending on how long we want to take to load a block then my understanding is storage is the main constraint there anyway but may I remember in my testing I came up with one performance bottleneck and you said it's not a priority I don't think I can get to it and the next day you had it fixed yeah this is a bit different issue so in theory we actually care about the worst worst cases because this is what what the cost must be for and and so this affects more complex optimizations but also the big big integer libraries that actually try to squeeze the easy cases first but this is not what what we point to like we don't care if we can divide quickly for small numbers because what we care is to have the worst case covered so yeah that would be much more much more difficult to control that within because it's like you have the beak at least in the in the in the in the in the EVM period that depends on LLVM you have a big buck and library that that does that for you and it's really hard to tell what it's actually doing but yeah I guess there are they are different approaches to that and for example he was and has some Jade prototypes that are not depending on of course one of my bigger concerns is not technical either of these either these programs technically does the job I'm much more concerned about who controls the specification and I really believe that the etherium community should completely control that specification that the web browser space is not the etherium space and I would not want to get wedged with the with the wasm group moving in the direction they need to move and I shaking our heads and going no we don't want to go in that direction yeah I disagree with that because I think I am much rather it's much more pluralistic to go with a larger community a larger body of people standardizing and coming to consensus on a virtual machine instead of just using a virtual machine that can only be was created to only be used in one Pacific use case and if you look at the browser use case is very similar to the blockchain use case we need secure portable and size efficient bytecode right it's exact same concern we have in the blockchain space probably I agree and and furthermore like it's an open it's it's open to participation you can go to the webassembly community meetings you can voice your opinions you can submit proposals on github it's very open and in you know it's easy it's easy to get involved that and within the blockchain space I know of least three other blockchain projects outside of aetherium that are already prototyping and actively have wasum running in in their systems so we're seeing a lot of momentum I think pick up around it in I think that's sort of just going to be the way it is because it's like once there is the we start to have consensus around a VM everyone's gonna be the obvious choice everyone's going to use it and it's going to be a recursive feedback loop right it's gonna be a feedback loop where since there's more people using it we're gonna get better tooling for faster we're gonna get better implementations etc but it's not like hypothetically if intra-syrian 2.0 it's not like that vasin would introduce a new update and that magically would work on a theory 'm as you mentioned in your talk both 1.5 and 2.0 have a verification code which has to run prior or deploying the contract and that verification code verifies the you know according to the EOS m specification which is the current list of op codes in web assembling and so if they introduce new codes they wouldn't work without us making this decision that we want to support them so I don't really see that as a risk that we would be exposed to random new instructions being supported by a Tyrian Baudette our review first I'm our concern so we come along and there's an issue with wazzle I mean bugs bugs show up in specs or if not a bug an ambiguity and we resolve it one way and it works for us and we can't wait yeah we if something's a little weird in a browser it's not a big deal and the committee will get around to it but if there's anything that breaks consensus we have to fix it immediately and then eventually it gets around the committee and they go no we don't like the way you fixed it we're going to do a different fix yeah and I just feel like over time we will wind up forking away from that standard and we will lose these benefits of shared design and tooling anyway in fact we're a fork to begin with were a subset so I I mean I spent a couple weeks trying to get C++ into Azzam I succeeded but it wasn't easy and that I think that's misleading it's a subset but the only subset being with the we don't let floating-point operators yeah that's the only subset but you have to convince the compiler not to do that yet it should be pretty easy I mean if you don't use floating-point inside the compiler can decide that it's gonna use the floating-point unit just because it feels like it fortunately we're out of time so we'll have to keep that's fine good loading Julia sorry what about Julia flexibility so what do you talk not too much I mean Alex talked about it and well it's a very active debate you can wind up five versi was them hopefully we can do the magic of translation come to a united front and move forward with the evolution of the with evolving the EBM thank you okay hello after the next presentation we're going to music after next presentation we're going to break for lunch but reconvene back in here at one o'clock next up we have martin's one day and he'll be talking about aetherium security [Music] [Music] hello my name is Martin Olsen de and I am the security lead for their Theory Foundation today I'm going to talk a bit about IBM forensics and managing attacks against the network and how we've been working on that so I've been security lead for one year I started just before DEFCON 2 in Shanghai last year which started off with the shanghai attacks roughly one day after I started my new role it kept on for a month we've also seen here in the last year we have done three hard Forks we've had one unintentional consensus split there was a DOS attack against specifically the client there's been thousands of ether stolen in more or less more and less sophisticated attacks both on chain and off chain we have the test nut totally brought to its knees and then resurrected again and of course there's standard IT incidents with leaked databases and someone taking over someone's phone number and their account and attacking our github it's stuff like that so we should all be very clear about where we're out at this is crypto land and we're all in crypto land and it's like Australia where anything with the heartbeat will try to kill you and if you make a mistake you're probably dead so meanwhile for attackers they have never had it better they no longer need to hack point-of-sales computers and trade carding details over shady forums they can just hack a computer and or somehow get some cryptocurrency and immediately turned into value and and it's so it's like a Wild West in Australia right now these are the Shanghai attacks I'm not going to talk that much about them the first Shanghai attack is that little blip down there and then it just kept on going for a month and it was a lot of different attacks mostly targeted towards gap but when the dust is settled after incidents happen then that's when you can actually do something about them and think about how can we be better prepared next time something similar happens and how can we prevent it so how can we improve the readiness and the resiliency so for readiness it's about detecting attacks and performing analysis quickly so we started improving that with some monitoring adding up some monitoring nodes that were running the cloud and adding some graphs turns out there was some inherent issues which hadn't been noticed before with transaction propagation inefficiencies which over the course of a few months in the beginning of from January to March we managed to bring down the overall network traffic with about an order of magnitude just by removing valid transaction propagation from the clients on these monitoring nodes we also added some interface so that we can extract very detailed information about what are the canonical blocks in the chain and if we see a consensus split we can get very detailed information about the receipts and differences in these and and quickly point out which transaction cost this consensus issue so here you see as a guest mastering death develop and the parity note and right in this image their differing on two fields marking red there and that's because parity or PC interface exposes a few different fields than gather now as we're going to analysis a few words about the EVM because this there might be conception that any minor difference in the implementation of the UM will automatically result in a consensus failure and that's not quite true because there are some things some parts of the AVM which are ephemeral such as the memory on the stack and which do not necessarily but they're very interesting because they can be used to trigger consensus errors and in order to really measure EVM side by side and detect implementation differences in idioms we need an kind of up by up view of the internal state so we push kind of hard to get common output format for EVMS so that after each instruction made in the AVM it would output JSON blob with internal state as you can see on the left and also a capability to use arbitrary state in Genesis configuration with the raw EVMs so one problem that can arise is if we hit pan attack which blows the note out of the water how can we analyze that because I now just died right how can analyze transaction if the transaction crashes my note well if we have a standalone AVM what we can do is we can just fetch the pre state about the sender and the receiver is just those two accounts and we can execute that locally in our EVM and then analyze the trace to find did we miss anything was there anything else we should here and external references and fits those and start over and if no crashes then we're just successfully reproduced the AP the transaction and for this we only need a web three standard API without any debug specialities sorry so I'm going to demonstrate quickly how we can do analysis of the jump test attack which we were hit by in on June 1 so I'm running this little reproducer here I pipe in the hash used in the attack the transaction telling it I'm gonna use my local EVM not through darker and it basically sets the right fork rules for that particular block and execute it and it has some intermediary traces here we can take a look at those so let's go directly and set for the final trace I'm showing this and what I call the OP viewer or retro mix if you like it's a remix like debug viewer for the JSON output format that I showed earlier and it's a good start for analyzing what's happening in a transaction so you can see this particular transaction it doesn't Xcode copy and the Xcode copy fills the memory with five B and it does it repeatedly and as you can see the memory is growing and it keeps doing this for about six hundred steps I'm gonna go a bit faster here until it has filled up the memory with half a megabytes all 5b which happens to be jumped us then it puts some more code in there and this is looks like actual EVM code 6003 56 5b and all of you I'm sure recognize that that is the push one jump jump test and stop so it it's just executed to create with that code and as you can see the size of the create is the full half megabytes ok so now we know that the attacker is doing creates and he keeps doing it repeatedly one part of the memory changes between each invocation it's a little counter down there and I'll skip forward wit so it's all just create and it ends on create number 105 it goes out of gas so by this time you can be kind of have an idea so it's it's doing creates lots of times with a large memory segment totally filled with jump tests it changes one little bytes each time so obviously bypassing and caching mechanisms so by reproducing it and viewing at the trace in this fashion we can do a very quick analysis of what happened and we can benchmark it right now it's running at 300 milliseconds and if I compare that to so this is the EVM get EVM with the patch applied after this attack I can try it against the EVM without the patch for the jump test analysis and as you can see it took nine seconds so this tooling makes it possible for us to do quick analysis and then to check does this patchwork and I can I can share it with the co-workers and they can try out various patches and see which one is the best I can also run this in a web-like format and do the all the same things and investigate other on chain events for example the that was the same pair 2 volt attack and there we have the parity wolves attack reproduced and you can run it locally or you can check annotate the trace of what happened there and the parrot attack and for example yeah so here's the fated infamous delegate call and the node attack if you want to if you want to analyze that more in depth so the EVM lab which I showed you a part of makes possible to do some EVM assembly pythonic lee and investigate these kinds of issues and yeah dissect attacks on a really low level we had two hard folks also and in preparation of those we ramped up the testing and introducing parameterize tests or generalized test which Dmitriy talked about yesterday in the breakout room and also put it all into high highly speeded Psilakis supercool framework for running notes and in a black box fashion and just synthesize the the environment the genesis and the blocks and everything and then you can compare the the expected post state after a sequence of blocks and this makes possible to run it runs about 24,000 test cases against my theory and parity against EPP and it runs it 24/7 365 it removes the dependency of the developers to perform tests as part of the test process so now testing can be a totally separate process which doesn't really rely on the developers per se the fall out however after the first heart sorry second heart fork is a very consensus issue which was yeah definitely not what we wanted manually crafted tests are great but there's no way to scale it due to the inherent complexity of the EVM we can't just have enough people know that much about it to to be able to scale it up so we wanted more coverage for Byzantium and started looking at the passing one way of doing that would be to generate test cases randomly execute them on each EVM use this shared output format to compare the internal state after each operation and just repeat it and this can be done fairly quickly you can do a couple of million tests per day if you draw binaries and you can use these for clients the second track is based on Lib foster where we got in touch with the Guido Rankin who has done a lot of flossing and is a real expert on live cluster so live foster is the core of American fossil op its foster developer McAuliffe scheme and it's a bit more sophisticated because it uses code paths and instrumented binaries to detect code paths for any given input and mutating those inputs to maximize the code coverage and says everything is instrumental in compiled into one big binary is an order of magnitude faster to perform these tests so I can do about 100 million tests per day and there was a spectacular and kind of unexpected success in this we've had seven or eight consensus issues found most of them before the hard fork one of them slightly after the hard work it has been fixed and patched and released and the clients today I would say are more thoroughly tested than they have ever been in the history of ethereum and we're still running Foster's 24/7 and it's been millions of tests done on the test stuff and billions of tests based on live posture naturally the Castella consensus issues or denial of service issues and if that's really really concern of you of yours then you should run multiple clients and try to detect mismatches and you can use the debug method in gif to find out if gas has tagged one of parities connect canonical blocks as bad and key takeaway here is that all everyone here are target's for attacker it's involved because it's important so be paranoid and be proactive and work on improving the security and your resilience and how he can handle attacks that's about it for me thank you [Music] 