quickly because I keep forgetting to do this introducing myself I am NOT a professional MC I am actually the direct executive director of the etherium foundation my name is Ming Chan and I take great pleasure in actually performing the duties of emcee every year since DEFCON 1 so very happy to see everyone here and now I introduce Hudson Jameson thank you good morning everybody all right a-all right so I'm Hudson Jameson I work on a startup called oaken innovations and also work for the etherium foundation part-time quick about me just for a few seconds but involved in blockchain since 2011 worked for a bank called USAA doing their blockchain stuff for a few years and then eventually worked for the etherium foundation and Oken which is what I currently do today I have one wife total on the top left and then I also have three cats is this is this for my wife or for my cats all right either way if you if you like cats you you would love Vivienne Fry and Leela so that's just a little bit about me so solidity is a high-level language for the etherium protocol what what I mean by that is usually when you get down to like the low-level parts of programming languages you have a bytecode you have like assembly and stuff like mips and all this other confusing stuff that people generally don't know how to like right it's not human readable so what we've done is the etherium Foundation has created solidity which is a human readable language for smart contracts so if you've been coding in solidity or been involved in the you know aetherium community for a while this talk might be a little bit boring so I've decided to add a trivia question the question is how many high-level languages does aetherium have we're counting defunct languages but we're not counting things like yah so like you can't say rust and si and other ones that would compile to ewaz them so be thinking about that and we'll get the answer in a few slides so solidity looks like JavaScript but it has types and the contracts kind of seem like classes so it's a about two years old maybe a little bit more than that and it's very easy language to pick up because it has a lot of the qualities that web developers might be familiar with the code that is written in solidity is compiled to the theory and virtual machine once it's deployed to the etherium virtual machine it's a closed environment that runs on every node on the entire a theory of network so you can write a smart contract and deploy it pay the miners to mine the contract and when you deploy code it's deployed across every single node in the etherium network which is really really cool the issue with that is you can't have outside sources of like information so you can't have like sports scores unless you put them in manually and have to trust the source so if you want to get more information on that look up Oracle's or trusted data feeds into blockchains so contracts and solidity are easy to write but they're very difficult to make secure there's a number I'm just touching on this briefly because there are many flaws and contracts that have caused a lot of lost funds it's a very nuanced thing to understand and there's growing resources for creating secure contracts but it's not it's it's not completely there yet everyone's doing a really good job trying to come up with best practices and create things in the language to provide security but we all you know have to keep up with that and I encourage you to look at the solidity documentation under some of there's a section about security considerations that you all can look up if you're interested so here's the answer to how many high-level languages aetherium has it is six there's mutant which is a c-like language that was deprecated around 2015 serpent and Viper or Python like languages serpent is deprecated lll is either called low-level language or Lisp like language depending on who you talk to and that's one of the lowest level high level languages we have there's solidity and then there's a new one called bamboo which is supposed to be very safe written by yo Ichi and some other contributors from the community if I got this question wrong please go online and yell at me on reddit because I love feedback and I love internet trolls so please tell me if I'm wrong about this one so contract standards are beginning to emerge we have ERC xx which many of you have heard about it's just a set of standards for having a token on the blockchain that's interoperable with other tokens there's also security or smart contract security best practices I put the URL on the bottom and I'm going to publish these slides to Twitter so you all can look it up after but this is from a company called consensus and they have this on their github so I'm gonna walk through a contract from creating it to deploying it to looking in a blockchain Explorer about it just really quick in order to do this all the tools that you need to do this are online right now the Fox logo is for meta masks which is an online plugin for your browser I believe it's in Chrome and Firefox right at least it's in Chrome and what you do is when you have a transaction that you need to push to the etherium network it acts as a bridge between your browser and the etherium network we also have remix which is an online facility integrated developer environment what that means is that when you want to write and test code it provides a lot of debugging features you can run static analysis on it you can call functions it's a really helpful tool for writing contracts and then finally we have ether scan ether scan is a blockchain Explorer so you can see the contracts you've created and the transactions you processed so first let's go to either scan so this is an example of pulling up contract code on either scan that's been verified as you can see we have the contract source the amount of ether that's in the contract and how many transactions have occurred so let's just dive in and write our first smart contract so this is a very very simple contract right here I'm calling it simple store and the only purpose of this contract is to store a an unsigned integer or to retrieve an unsigned integer so it's very easy to start a contract you just declare it as a contract you go in and then you declare your variables at the top like many programming languages suggest you do and then you can go in and create functions and events events are just like log files so as you're going through and debugging your code on the blockchain you can have these log files spit out events whenever something happens in your code so in our case we have the set function we made the set function payable so we're able to send ether to it that's another important security consideration in the old days you would have to have some a lot of workarounds in order to prevent your contract from keeping ether and not letting it be able to be sent out but now we have this payable modifier that makes it so that functions have to have a payable modifier in order to receive ether which makes it a lot safer if you're accidentally sending either two contracts in the set function I'm calling an event after I've stored the data that says the data that I've stored and then on the function get I call something I add something called constant on a blockchain you can do a transaction where you pay gas and you pay transaction fees in order to change the state of the blockchain there's also something called a blockchain read or a constant function there's now newer grammar I guess or newer function keywords around that I think it's pure and a few other ones to look that up but you can still use constant for the time being what it does is when you have a constant function you can do a free blockchain read to retrieve your data which is very powerful because it's just like reading a database and I don't want to spend money if I'm just reading a database so that is the smart contract in a nutshell what I'm gonna do now is I'm gonna hit the create button that I had on the other screen and when I create the contract a meta mask confirmation box pops up in your browser again this note that you didn't have to download anything the only thing you had to install was a chrome plug-in and open up a web site so we're opening up this meta mask box and we're hitting submit we're putting in a gas price that kind of sets up the transaction fee and now we go to either scan to see our transaction being mined so it shows that the contracts been creative it gives the input data how much the Gaspee was and a bunch of other neat data for you to see now we're going to go and to the contract itself before we were just in the transaction that made the contract now we're in the contract itself and either scan provides a lot of other really cool tools so we have transactions where you can see transactions that are happening between the contract and the user or the contract and other contracts we see if there's any ether in the contract we can see who created it and we can even go and publish the contract code so say I have this simple store contract and I want other people to be able to look up my contract and see the code I can go into ether scan and publish that code inside of ether scan in a way where people can read it so now when I go to contract code it'll actually show me the code that I wrote and you can like lookup functions much more easily in ether scan it's a really really powerful tool that's widely used for transparency purposes so going back here after that transactions mind we have a log basically a blockchain log under there and what it does is it shows you that you transacted with the browser that you had a transaction mined in block one nine four six nine to eight and it shows you a bunch of other details a lot of other interesting things if you look here we're gonna go ahead and set a variable so on the right side of the screen from there before you can call the set function so we're gonna set it to a hundred so again we call meta masks in the transaction and now when you read the smart contract on either scan you can see that instead of having a value of x equals 0 we have a value of x equals 100 so we've successfully stored an unsigned integer into a smart contract we have many integrations inside of solidity remix is one that I mentioned we also have Visual Studio we have IntelliJ them Emacs sublime I think that's Adam basically I went in and if you're using whatever IDE whatever kind of browser you want you can go in and you know plug it into whatever is comfortable for you and it has a lot of things like syntax highlighting it has a lot of things like yes syntax highlighting we have tools like soul graph and solidity repple selenium and a disassembler and then at the bottom there's Papas embark and truffle those are really cool tools they're programs you download they're usually under over NPM so you it's like a node.js program and you can write tests for your solidity contracts and things like mocha you can also have them automatically compile your contracts and redeploy them on the blockchain there's just so many cool tools in there aetherium package management was a collaborative effort by a number of aetherium software developers that involved having an NPM like interface for the etherium contracts that are very widely used such as ERC 20 we also have a soul graph so contracts talking to other contracts are very very hard to visualize so soul graph takes your contract code and your functions and it tells you all of the inputs and outputs and potential things that can happen within your contract selenium is a tool to use I think it's a linter for solidity I don't use myself but it's very very popular on on the on the whole sub line package manager oh man so that should be saying love solidity but it looks like something is unknown less than solidity and now it's covering up my slides so you can go to Jameson now go to Hudson Jameson comm slash speaking engagements to see my slides you can go to Witter at Hudson Jameson or edit you see tacular and you can find all my information on there I have a couple of minutes so if anyone wants to yell a question I'll repeat it back through the microphone and feel free to ask any questions who has one raise your hand yep I've seen some like like beta or alpha versions of Eclipse plugins it might be further along than that but I'm kind of unaware if there is a plugin for that or not just because it's not on this slide doesn't mean there's not a plugin for your IDE these are just the ones that I've been able to very quickly find so it's definitely worth looking up good question and the question was if I didn't repeat it already is there something in the Eclipse IDE that works with solidity next question yep what do I think is the biggest problem with solidity the biggest problem is that it is a young language and the problem with young language is in general across the board is that they don't have a lot of features that programmers are used to so that causes a lot of frustration there's a lot of basic primitives and a lot of things that make it easy to start out but otherwise there's not a lot of you know advanced tools also the safety of solidity has been brought into question and a lot of people are like solidity super unsafe look at all this money that's been lost but I mean this is all a big experiment guys like this is a super new language and if anyone's complaining about solidity being insecure they should come up with a way to make it more secure and start you know getting involved in these discussions and these tools so that's kind of the approach I take with that we have time for one more question yep what upcoming feature am I most excited about so if anyone saw the presentation on Zoo crates yesterday there are pretty new features to get cryptographic primitives inside of the EBM and therefore solidity to do ZK snarks which are called zero knowledge proof s-- zero knowledge proof sin Abel semi private and private blockchain transactions and I think it's a really really powerful thing for the etherium ecosystem I'm Hudson Jameson thank you all so much for listening to me feel free to visit those websites and I'm gonna have Christian come up after this Thank You Hudson before I introduce the next speaker I just wanted to say that today in the breakout hall there is a zero knowledge proof ZK snarks breakout session and it starts at 10:40 and ends at 3:20 so you'll be able to learn more in the breakout hall later today I'd like now I'd like to now introduce dr. Christian reasoner and he will be speaking on flexibility in solidity can I have the screen please I think it's open already okay thanks when you design a programming language you have to make compromises constantly there are people who request features and of course features are nice but with each new feature the language gets more complicated and thus easier harder to understand and it's easier to make a mistake the more complicated the language is so you have the constant balance between functionality and safety of course there are features that are safe but yeah that's the compromise you have to find and this has not been the case for general-purpose programming languages for several years now but in blockchain there's always the factor of cost so smart contracts have to be very cheap to execute and that also limits the features you can add in a language back in the days when solidity was started the initial goal was to create a usable high language high-level language as fast as possible and I think we succeeded in that but of course we made some decisions we now yeah which turned out to be not that not to be the best decisions and now is the time to change them and solidity is still a language that changes and that allows us to make the necessary changes to the design and yeah the the path you want to go is we want to keep features that are relatively safe and we they look like high-level features but most of them are actually quite low level so we want to have features that that look like look look like high-level features but are still cheap and we want to remove everything that can surprise users or has sums magic involved and then a third factor is we are adding formal verification tools that are easy to use and this I would like to stress this easy-to-use part because that is essential and we will see that later in the talk and then if there is not enough for you we provide direct way to access very very low level features of the interim virtual machine and the important point is here that we remove everything that is kind of intermediate level so for example address dot call will be removed in the future because it has some magic some some unexpected things involved that we would like to avoid so if you want to do such low level things you have to go all the way down to the ethereal virtual machine okay this is kind of the the path you want to take now let's talk about some new features we added in the last year this contract here is a simple database that stores people by an identifier a name and some flag that says whether they are owner of something and you have a function there which allows you to add one person to the database it already looks quite repetitive and but it gets even more complicated if you want to add a function that can append a list of people into that database the problem many people run into is that you kind of have to create an array out of these three things here and what you usually do is that you add three parameters which are each an array and this of course creates the problem that you have to check that all of them have the same length because you have an ID that corresponds to name and this flag this looks really really ugly but fortunately now what you can do now is hope sorry what you can do now is this and we added structs as a central feature to the ABI which allows you to actually put just directly pass this track from Java screw into the contract and remove all this these weird repetitions and of course you can also return an array of structs so this is not this is not yet available but thanks so we hope to get that fully functional by the end of the year so and the way we the way what this this was possible while was through a change in the compiler itself so we we could have done that the old way but we decided to do a full rewrite of the ABI encoder and decoder and this is a snippet of the code generator and how it looked before this change yeah this also this is also really really ugly the EVM is a stack machine and because of that you have these this pop and dip operations and in the coronary you constantly have to keep track which variable is where on the stack and because of that we have these comments and it's really really complicated to understand what this code does and also complicated to write new code and this is how it looks now and it leverages a new intermediate language we introduced called Yulia Alex talked about that I think yesterday or the day before yesterday so I will not go to into 10th about that but you see this is really really readable it has variables you know what happens you can use names we have for loops and so on and what you also see is you have these angle brackets here and this is because this is an intermediate language mixed with a very very simple string templating engine to make it more flexible what you see here is the full function to do any encoding of an of an array into the the ABI encoding so it does handle raise call it arrays storage arrays arrays of arrays arrays of constant length arrays of dynamic length and so on and the way it works is that for example here at the top we have length equals length fun and at the time of compilation this length furnace reproduce is replaced by the name of the actual function to retrieve the length of the array which is of course different for a static list and dynamically sized arrays okay and a language becomes more and more useful the better tools are available for that we already see that by in the questions that were asked in the previous talk remix got gigantic updates I think Jung will talk about that later today we now can track variables have breakpoints see references of variables and I think soon can also rename variables and so on we have an way to export the ast which is the result of the of the parsing step and these this allows many new features and one of them is a tool to do code coverage not based on syntax not just based on lines but on semantics so for example is a less than operator actually tested to do what it does and then a standard JSON i/o this is a way to get more fine control fine graph fine grained control about the settings of the compiler yeah then I have a very special announcement to make and this is that the solidity documentation that we only have in English for now is now also available in Spanish so please give a big round of applause to these five people who these five people who did that in their free time just as voluntary contributors I think this is really important to make if you were to the world and language is like so like like Chinese or Russian should also have a their own translation of the documentation and I want to spend the rest of the talk on a form of verification of solidity and whoops I think I showed this slide to you last year in Shanghai this is a smart contract and it has comments which allow a formal proof the the sum of the balances in this token contract never changes and the way it works is that the smart contract kannst gets translated by the compiler into a language called y3 and it mixes this translation with the with the comments you have here and then you run an external tool on that to create the proof that the balances are constant the sum of the balances are constant but what you see is that there are almost as many lines of comments in this code as there is code and you also see that the these comments use a language that is slightly different from solidity so it requires you to learn a new language it requires you to learn how to use these tools and this is this makes it very hard to use this formal verification tool and the harder it is to use the easier it is to make mistakes and also it is easier for so for Mara fication is only useful if people understand what is actually proven there so the statements that are proven there have to be understood by humans and if that is not possible then nobody will use formal verification and it's useless and because of that so yeah perhaps that approach was not so great so we took a step back and reconsidered how it looks now is like this we've replaced y3 by a tool called an SMT solver SMT solvers are less powerful than general theorem provers and because of that this smart contract in this smart country we cannot prove that the sum of all balances is constant but we can prove that the sum of the two balances that are modified is constant so what happens here is we have a require statement which is yeah doesn't have much to do with the formal verification this is just the regular solidity requirements require statement and then we store the sum of the two balances in the before variable we perform the modification and after that we check that before equals after and this is a regular solidity assert so if the sum of the balances is not the same then this will throw an exception at runtime but using the SMT solver you also get a proof at compile time that this assertion will never be triggered okay more specifically what happens is that so you can use this tool with required statements to have expressions that you assume to be correct and then the tool proves that there is no assertion that fails there's no overflow or underflow in your Matic operations no division by zero no constant conditions no unreachable code and whatever we will come up in the future and so let's take a look at a simpler example this is the experimental feature and because of that you need this first line that activates the SMT checker and yeah the function here it just takes two numbers and adds them of course there's a problem because we can create and we can have an arithmetic overflow here in this addition and this is exactly what the so if you run the compiler on that then this is the message you will get and the great thing about this isn't T solver is that it has so it's more limited than y3 but it has a feature that y3 did not have and this is the following so you if an assertion fails it tells you why it fails and I think this is really important because otherwise people say ah I don't know it doesn't work but okay let's just let's just comment it out or whatever throw something at it so that it doesn't complain anymore but this tells you why it fails and kind of forces you to think about this addition and think about why it might create an overflow and then take the necessary steps to prevent the yoga flow before it happens there are so currently what people often do is create runtime checks about overflow at runtime checks about overflow in in arithmetic but this can be really dangerous because if you end up in a situation where you you have an overflow because of some yeah internal mechanism of the smart contract then it will be that the the smart contract will be stuck because it will always throw this exception because of the overflow and you perhaps can't get the money out or whatever but if you already get the warning at compile time before you deploy your contract you can think about why it happens and prevent this from happening in the first place and how are you prevented this like this so you had a require statement which of course in the end has the same effect as if you would just check if there is an overflow but the benefit is that you see that there isn't there's an additional condition that is present about these numbers a and B and the SMT solver will now see the require statement take these conditions into account and then check again whether the overflow will happen and of course it sees that a number less than 2 to the 100 plus a number less than 2 to the 100 will be less than 2 to the 256 ok yeah let's take a look at another example this is taken this is an actual example from the underhanded solidity coding contest where there was a loop that used an unsigned variable and decreased it but checked against equal and zero and of course this Luke condition is always true that's of course something that can be detected from the type of of the variable alone and you don't really need an SMT checker but yeah I this was a simple example to present here and it can do much more complicated conditions and yes this is what we'll see next and yeah this talk was quite dry about programming language theory so I would like to end it with an exciting math puzzle so here we have a circle plus circle equals ten circle times square plus square equals 12 Circle Times Square minus triangle times circle equals circle or what is triangle and he kisses so yeah easiest pie we just write a small solidity program that is equivalent to this puzzle and we add the conditions as require conditions and then at the end of Sirte falls so assert false sounds weird why would we do that and the reason is if the SMT checker can prove so a failing assertion so assert false is not bad it's only bad if it's actually reachable code so false assertion will not be triggered if it's not reachable so the SMT checker has to prove to us that this assert false is actually reachable and it's reachable if all the three require conditions above are true and of course it doesn't just tell us that it's reachable it tells us how it's reachable so what are the exact inputs to get this failing assert and we see that triangle this one okay okay this kind of shows the power of the empty so we don't really know yet so it's not it's still experimental and not fully finished yet we don't know how it will behave and very complicated contracts but yeah we're we're optimistic and let's see how it goes thank you thank you for your attention [Music] Tess Thank You Christian a very quick announcement I've been asked to make there are items that are then turned into lost and found downstairs at the registration slash t-shirt sales desk so it's probably easier to go get them now than after close of event I'd like to next introduce aetherium miss developers Everton Fraga and Victor Maia they will be speaking on mists towards a decentralized secured architecture [Music] [Music] morning everyone an Everton Fraga I'm here to talk about miss project Alex when the sendee couldn't be here he's about to have baby so maybe next time well we're here to talk about meals project first of all let me go back here okay why missed what's the vision of the project it is to host the web three we have three projects the land of the decentralized applications where you could access websites that live actually in no central server using peer-to-peer technologies such as swarm and having the blockchain as the backend let's browse through the past versions okay at the first Def Con there were no missed so that's why people would execute transactions that execute smile contract methods only in command line tools so it was really developer oriented and well no graphic interface he had to be a command-line guru therefore know that by the time of the of DEFCON 1 we had a few Mollett which was the foundation of the dab space it was the first one we built it was more like an advanced tools for specialists you had to click around and get to know all the the all the application and it posted as a dynamic interface for contracts through an auto-generated base it on the VI of the contracts you could have executing contracts with all the parameters and it's like a boolean and you ain't and then you would execute methods well it was it did its job but for the general use there were some features missing of course such as that would require you to have either for instance then by the time of the DEFCON 2 we had released the mists better which was more like a Firefox or Netscape Navigator as the beginning of the internet focus on on the enthusiast user it presented the full power of the web for smart smart contracts so you would from your JavaScript application from your website you would trigger transactions and then minced would handle it here you can see a confirmation window about the execution of a method in a contract we we have these the parameters that could be parsed via an API directory built by Piper so yes that led you to many other things so you could create your own Congress Dow ad contract and then build an interface out of it but you know as the block chains started to grow in size it was becoming less and less practical for the users to have the whole sync the whole block chain synched so yeah this is one thing that we would talk later throughout this time we had the ecosystem has grown like you know like crazy throughout these three years we have we have been downloaded many many times as well so here proud to share with you that if you mullet and mist combined has been downloaded more than 2.6 million dollar signs so that's so that shows a bit of the site of the trouble we have actually because we are the most user forefront of Afyon projects and then we have to do with all those sort of problems that came as well well in order to solve that and organize all the the project we did a mist Summit in Rio where we get to have the whole team and we talked about lots and lots of things so it was sort of a whole week thinking and working so here's some proof of workshops for you notice that all those different clothing so it was really a whole week yeah and that was our team at that time so yeah we came up with really lots and lots of experiments you know there's only some interface wise experiments so let's get to the deliberate features this year first and foremost our main main concern is security because well we have a browser that handles private keys so it gets you know it's not so simple as would be a simple website that doesn't handle anything related to money for instance well let's put a ribbon this because it's so important so we've made an extensive audit by crew 53 which is a really really cool German company those guys are really skilled and they managed to found to find 22 issues work with Mariah severity levels so it has some critical ones high medium and low all of those were fixed by us as soon as they reach this we were ready to fix and we increased our time sweet so no regressions here and also we had some really important if you bow to program submissions and here I like to thank Juno and new Hawk in really you know thank you and we have also some other exciting features such as the swarm integration in better version so a user now is is allowed to click on file upload to swarm then choose a file upload it to this swarm instance that's running local in his machine then the fire is in this warrant space this form view compute the hash out of it and communicate with other storm instances copying the files over them well that's actually the speed of the web 3 right you could upload our website then access like this facing the same hash in your browser but well here's one thing swarm comes with DNS integrations so you could have this that's one of my favorite features and speaking of ENS integration we also did some of them in the wallet well of course you're able to transfer ether to a certain address if your foundation dot eath for instance or add a custom toking just putting the symbol of the token then he was search on a previous previously made list and get all the details then after so after these three years as I told you the sink was sort of a problem for the users we got many many people saying my balance is to zero I'm I'm seeking here for you know hours and I can't still see my stuff so we have now integrated missed with the like client still in better version but the there we are aiming to reduce the sinking times by an order of magnitude and it's to using the version one of the protocol the version two is about to come maybe right after it calm so keep posted ongoing theme Tim and miss we have also buting remix IDE so we're seeing Hudson Jensen we'll see young talk right after mine actually and now we have the the possibility to for a developer to write code run on the main ad or on the test nets and that's quite powerful the developers also able to debug transactions to see what exactly what steps that transaction made what were the state the states of the variables so we also did a really easy way for the developer user which is solo network you will make use of the very theme that flag so you can have your own private GUI theorem blockchain so this is not actually action is the real deal you run an empty blockchain from scratch in your machine and you can manage mining from the interface so that is mist aiming to for a larger adoption of developers we also had by the end of the last year windows installers so people you know got happier and now some planning features account management is one of those really really important ones which would leverage the power of standalone transactions einer enabling remote node management and easy to switch between nodes here's the deal if we want to use in food for instance for any reason we would sign those transactions from within designer all those account keys would be held at the same directory and we could even switch between notes could be going theorem by theorem or any other having all those keys managed by minced couldn't be even harder wallets so this account management would lead to having those boots pole with your clients so you could use their own favorite node having nearly support to your clients it's actually a JSON manifest which we already did so it only has gap for now all those accounts will be managed by mist so if you switch nodes you would see it's to still see all the same account so we're under actually a major refactor being led by mark please yeah maybe yeah mark share yourself he's not here hi oh here yes Marcus our new addition he's a Redux book author a really skilled developer so he is fixing journal state issues for now which is mainly the foundation for major features to come we're also thinking about having a sink jumpstart which is something really awesome in order to fix that zero balance issues so you would start connected to a remote node so you would see all your balances all your all your stuff like real-time then you'd have a background sync so that would progress progress progress when it comes to the right point you would switch over so you would switch to my client or foo note of your choice there is also this important news for the DAP developers that we're planning to isolate local storage between networks so you would have different scopes to work with so the DAP developer wouldn't be worried anymore about having main at storage and that's net storage and you know also transaction specter which is something you know it's time for us to have we would show pending in past no more prayer DAP setup because as taking the wallet as an example he handles all its transactions and pass in history so that wouldn't be necessary anymore always a bi look up so you'd see once that methods are on the directory search that would be so evident and you would see perfectly the transaction details and speaking of the IAM wallet it's time for a change so back then you would it was one of the most ideal ways for you to kick start on your solely the project but now we have some powerful tools like remix and maybe we don't need some features that we had in the past so now we see it as the ideal way of starting as a solidity development is having well in remix itself so we're planning to deprecate some features in order to have more simplicity and we're planning to have a new wallet wallet contract there are some other audited and solid work around so we're playing to in the near future to change that well this is about developers Rob yeah so we plan to have very integration with remix improving private net integrations kick-starts and purpose magic and of course we're totally open to suggestions so you can guys reach me out before before lunch or maybe something speaking of the ecosystem we're trying to build here I think it makes a lot of sense if we if we could have some that trust meter because there's a fundamental question about about this should apps have access to your HTTP if the apps could be run from swarm could be loaded from swarm would they does that make sense even sense to have access to HTTP we all know the web now is full of trackers from all kinds and those trackers feeds a multi-billion markets taking advantage out of all of our online habits and once that's our whole setting swarm users will be able to decide whether or not a certain that would have HTTP access and I'll talk about the blockchain has already proven itself secure of course such social engineering and trickery are important problems to deal with and we'd like to invest some time into ant efficient mechanisms and using some sort of reputation system or blacklist subscriptions that users will be able to easily manage so yes here at DEFCON 3 I present to you some this summary we've got harder than security this is marcher gas updates we're no longer having to release mr. shion's for each gas update E&S integrations for our better the like client remix integration so there's a key takeaway which is missed is a full browser that makes you run a full note you can be also a quite a light note but the thing is you should for the grid of the ecosystem run euro note well this is our current team and we also has some many in doses of contributors so I like to clap a little bit for them those guys helped us with translation with many bug fixes and lots of suggestions around and there's one more thing remember that I told you about the workshop back in June we working together for that whole week and discussed about many many things and Victor Maia kick-started a new track within the team so I invite him to stage to talk about his his new project so hello everyone now we are gonna show you show you something new so already I think everyone here dreams about centralized well our world of abundance there are no companies where nobody owns anything that I just public adapt and those that are easily resilient and free can you imagine that work well of course you can't if you is that thing but for backyard services so what about the front end what about using the face well it has been two years since your launch and yet most laps are Stooges centralized companies with tokens they are hosted on central computer they use centralized api's so where's the centralized web why it's not happening let's talk about mist what this is our code as you know it's not in a great state not right now miss Larry a little bit slow it has some bugs of course you're working to prove it and we believe you can make it much much better now with mark on our team but even if you miss it self was perfect even if that thing was flawless Oh that'd be enough well what about those browsers like Miss depend on a huge web stack there are millions of lines of code that we do not control and you already had two major vulnerabilities because of those things so the point is how can we those things should be secured well we can't and that's a serious problem for a browser that deals with real money don't you think so and even if that was not the case if those things were perfect what about those things above well let's talk about JavaScript okay sorry I think I have some problem with this controller so would use that code on your that no really think about it is it safe to use that finger and that well of course it is it's just a pure function it's as simple as it gets there is nothing potential safe about it so what about this one would you use that thing on your deck well of course you do not I hope you I hope you not I mean you don't know what square that is does it could do anything for example this is a belt implementation it's correct but there is something extra it also alters the global add three object so this isn't like it it's not who this is the kind of you can do in JavaScript so by the way it's not all about practice hacking the global scope of adapt can cause it to for example show misleading in for track user actions mind cryptocurrencies on your computer so here's a lesson you should never import jeaious code you did not read it's not safe but something just use the arrows but do you know that tap D that's with all their imports like there's not a real problem because that deaths are doing how that audit work by themselves right so let me show something these are least refer to that has dependencies each one of those lines is an entire package with a lot of files perhaps hundreds of lines of code this is the first is the second return all those are but that just depends and my question is have you depth depth are on here read all of them and of them hood behind in something like this anywhere so the point I tried to make is and for that and many other reasons that I don't have the time to explain the web as we know it was not made and not very for crypto so what he needs not another web browser but a brand new thing made from scratch for etcetera as well we need an answer to the question how would the web look like if it came after a few and to answer that question we started the moon project thank you so much so this is not another web browser but an actual decentralized at ancient that is lightweight and performant use the scripting language with Safe Mode alert so people can share code without needing to audit everything and that language is kind of like JavaScript but we thought that bad things his man off to be formally prove insecure and if those words sound a little bit scary and that just means a computer not on human can verify that the whole thing does not have a single vulnerability and that's kind of a big deal so in short oh my god sorry so short this is very heavy and this is very building by the way I'd love to elaborate on how those things are possible but sadly I don't have the time for that right now so sorry yeah it'll be for another day and finally some of you may be thinking but I like the web the web has so many things are you just like showing the whole other way of course not and not that insane everything is were compatible mooned apps also work inside a browser moon lang can be compiled to JavaScript in fact you could even use moving as a safe module system for JavaScript so for example here I import morning in normal JavaScript code then I use moon langage to import song library from ipfs or swarm and then I use that library inside no more JavaScript so you don't actually need to use meringue to benefit from it and it also works on other languages so you can think of it it's kind of like a safe coding sharing tool not an actual language you don't need to use it so demo time this is a video of the moon browser it's the web version of the moon engine this is a hundred kilobyte HTML file so yes it's really small you can use it kind of like a mighty wallet but if dubs so let's open an app by placing its ipfs hash as you can see this depths very simple there is an title there is an image and there's the black number it's connected to a film so let's see how its holes look like one of the cool things about me is that you can always recover readable cold fronts byte code so it's not actually plain text as we do on the web we recover readable code from the byte code above the we have imports with our jaws ipfs hash and that's good because with that you can make sure that those imports will never change we have the main components with some things like its name its local state and a title there is on fetch function it gets data for children since moons are pure language we need to use something called mana to do that but you don't need to worry about that because that's very hidden and finally we have the handy function it's kind of like react so I guess some of you may be familiar with that already so let's change some things here will replace moon by Def Con on the body we also do that on the title and now I want you to pay attention to the hash bar to the title above that as you can see not only the title but the hash itself has changed that means the new DEP is already posted on ipfs or in other words we just hard forked that that that's kinda cool don't you think of course it's a very simple app so let's open something more useful this is a talking wallet there are some there's no return on this account so let's some submitter to it as you can see the confirmation window is a little bit ugly but the transaction was silent and sent so let's select the previous account and see the code okay so one of the cool things about me is that it has a component based back shot architecture so you can like get inside any component that is inside ended so for example here we access a sub component of the wallets depth and we can also go all the way down to the most basic functions see how everything is fashion dresses so one of the cool things about module is that for example become application use that same function an equivalent function it will download the same thing so there is a lot of sharing and very good users of ipfs resource so okay let's go back to the wallet as you can see already has arrived so that's kind of cool and for a last thing let's open again the token table no there is a question these are component from the wallet step how hard would it be to use that component inside the hello Def Con that that we just made well let's see so we copy that's hash we go back to the hello Def Con that we imported by using that hash oh sorry and I'll actually go back so because I want to show something's and I press the arrow on the wrong timing so again here imports the token table I replaced the shoot component by the token table that I just imported I remove the moon image so it's the same place as the moon image would be and we click above that it's forked and as you can see that component is not working inside the hello they've come down and doing that kind of thing is always safe so we can always take a component from some other that and what eating of that and because moon is pure and may to be secure you can always do that without worrying at all so in short add App Engine that can be formally proven secure and a scripting language we're sharing code is always safe on a truly web that's the moon project if you want to try it we have a live demo at that you are how thank you [Applause] by the way just a smaller point I would like to make that whole thing is actually decentralized so there is no central computer anywhere the back end of the Deb's is a film called is downloaded from ipfs so like you can just write it do something I don't like and there's not anything that me or anyone else in the world could do about it because mooned apps are actually public decentralized resilient and free is acting like as much contract ah as I think that that should be hello good morning next up we have yarn and Rob and they're presenting dark developments using remix mists and guests [Music] hello everyone so today we will be presenting remix we've opted to pay here so I am part of the Berlin CPP team in Berlin and I'm a developer of the mix if you already have internet now you can browse the mix dot it I am NOT oh and we have - yeah and so there is also like documentation and you can also browse our chats or guitar charts / remix but you can also go to remix - dev and it's developer chat so today I will be most of the time presenting what remix is and what are the new features of timox we will go over like what happens last year after some guy we will go over all the new features that we have and we have one important features which is actually you tool its remix team and I will present so are we can use he mixed together with gas and mist then we can take a look to the link that we have between us this repeating remix remix and new community and a lot of link that's nice then hope here we talk a bit about new UI changes in remix that will be deployed soon and then we will go over what's next so if I want to resume a bit what remix is I would say this just a sweetie editor first that contain basic syntax editing that contain auto completion so you have basic idea features right so you can just write smart contract since we did it contain wrong time and the elements which is completely integrated in the browser we means that when you will create rejection when you will send transaction everything will be round inside the process but you can also if you like use remix with any external note like you can progress remix with gas or you can play remix with parity or client and then first important features of Hemmings is the code analysis so as long as you are writing code we will just analyze the code and then it means we just propose some warnings and display some warnings in order to improve the code and in order to avoid mistakes so this is remix and I will go over a basic use cases now so you can input contract here this is a default one but that's all you have to important stuff opening in the right panel which is the compiled tab and run tab so if you look at the compile tab you will have some informations about the compilation results you will have some informations about the static analyzer for example here you can see that the compiler gives you one warning and the static analyzer gives you two warnings so you can check any real-time what you could do and you can check if there may be some mistakes in the code so you just write contract and you compile contract then you might need to run contract so we'll just go to the Home tab and there are several options at this point you can use to integrate with VM in the browser or you can program it to any external node and for example in this slide we will click on create that we create a new transaction and you will be able to see the result in the terminal below so you can see that below I can see the new transaction you can see the from field you can see trajection ash you can see a bunch of other informations if you want more informations about transaction you can then click on the next on the tree details button here and you can see more informations like execution called transaction cost value the byte code deploy code and then important feature is the status field here this is a new feature that has been released with the Byzantium unit and if you want to have more informations about the execution of a transaction you can click on the back button here and you will be able to start a new session here and you will be able to go full execution step step by step and yeah this is a really basic use cases of gimmicks you write contract you verify contracts with Joe analyzer and then you can dip the contract you execute and be able to contract yeah so I will go a bit outside of technical stuff now we have here in remix which is very nice we have a lot of new users you can join the channel and we have a new interface where the interface is not completely new but then now we have at our guide text to Mina that allows to have more cleaner design and we are very proud of it now so yeah and you can just ask them questions there are Nina Bresnik Sara path and hope here they love to answer questions okay so I will go over some features that are been deployed in remix lately the interesting one is static analysis it's just a bunch of modules that will run along the computations and that will check if there are mistakes and if the code can be improved for example the second one on the top is check effect and that will check if there might be an entrance issue for example if you look at gas and economy the second one there is this on local calls that means that it's not very nice if you call a general function to use these dots it's better to just call a function with the name of the function because it's will consume more gas so it's a bunch of modules that are here to facilitate the tests of the contract the verification of a contract and that can as much as possible forbidden to make mistakes yeah thanks to Sarah paths we have this time which is I think very nice what you can do here you can see transactions as we have seen but you can also input JavaScript code so you can input script in this example you can see that there is a call to get block number like web 3.8 h2 number this is a script code by the way so you can just input scripts and you will have the result in the console you can also listen on network that means that either here will be displayed transaction that are executed from the remix UI or maybe you want to hear display any transactions so you will check this an on network and you will be able to see our transaction minds in the network and you will be able then to debug and inspect them the usual features you can see the state or the contract I mean the 3dt state the decorate state and you can also see the Luke our drivers one example here and yeah you also have also have bright points so you just put the right point in the code and you click on jump to network and you will be jump to the network yeah this is basic ad features but that makes life easier I think yeah one very nice stuff that we have since this mode if is the swarm integration very cool so you can then publish on swarm so you see that on the upper right of the image here you can see details of a contract if you click on position swarm you will just deploy this bunch of Reason staff in swarm which is the - the version of the compiler used to compile which contains some settings and which contains also the source code that is used to compile so you just click on traditions warm and everything will be pushed on swarm and then you can reuse it in remix or you can also use it in any kind of applications that use one of the scheme in remix you can use the swamp integration directly in a source code here you can see import token from and yeah so I think this really important features because that leads us there are more decentralized way to develop depth and yeah that's most of the one big nice feature that we have seen to humans so now we will go back to what mimics is Amex is a web app and as a web app is a bit hard to keep your code because the code is thought then in the browser and if you lose storage if you clear the browser then you will lose everything so it's very bad one solution will be to use violet are in your local system but using the API of Chrome or so on but it's a bit complicated maybe and many we don't want to do that so one solution will be to use remix team what MIT do basically it will share a folder between remix and a local computer so you will say to remedy okay I have this folder please let me access this folder from remix ID this is the basic use case of the mix tree the other use case is just why I'm here now today this is the integration between remix meat and gas now I will just say to remix oh gee please start gas start mist then use this folder to store chain data maybe load a front-end somewhere and that will just create a new development environment inside the computer that you can use so what I will do I will stand him extreme that will spawn and spawn a new block chain or you can use an existing an existing one you will share a folder between a local computer and remix ID you will maybe if you want say off folder in your computer so you can browse tabs and you will start gas or mist or if you don't want to start missed you start gas and you can then use your normal browser together with me to mask for example now I will just give here a small test case I am here I will listen on the talk I am in mist but I am browsing Linux inside East I will check listen on the talk I just point all the transaction will be displayed in him then I go back to the front end and I will just play a bit with the front end yeah I will input some value and I will click on give ya that will just quite root transaction until then is fine I will validate the transaction I will wait a bit and remix it by the way will automatic in mine and stuff so I don't have to start to mine everything will be mind automatically so I will go to remix the remix then at this point I can see in transactions mix and I can inspect transaction I can see the execution I can see some other informations about transaction and I can also debug it yeah this is one specific use cases that you may want to have I mean that you have your contract you feel that your contract is okay but then you want to test your contract and you want to use your contract in your front end and at this point you will have to go back and forth between the front end and the contract like okay you play with the front end and then you realize that you have to modify something in the contract so you go to the contract and then you go to the front end again but do we with that you can easily switch between and you can easily make modification in the contract and see the modifications in the front end but maybe you don't want that maybe you just want to have a contract and deploy to confer we learnt that and it's fine so this is this our resolve is very specific use cases plavix and the community so you can browse now you can access the charts you can discuss with us and you can ask questions and you can ask for new features of course if you go to a task and not IO you can also use you can also use with a mask with remix and a very nice feature that's been deployed maybe not deployed but that is currently in development is a way to develop condition from me Thomas so basically metal mask will be plagued the transaction inside metal mask and will give the trace to Enix so you can then debug a transaction from linked by or obtain or any info importance to this is another way to debug transactions if your eye is a bunch of nodes that I mean maintained by them and everyone can query those nodes but then you cannot now create debug endpoints we have debug transaction using if you are and I will really like this to be happening because that we are all a bunch of nice stuff so on yes integration you can now browse remix igg dot eth in swamp and this is very important to move more centralized way you're doing stuff mists we already saw that and NPM modules which is another important features or advancement I would say we really want to split up remix in different part so the community can use it because now if you want to use only static an item you will have to pull the world image and you don't want that you just want to pull the static analyzer so we need to split up into several modules what's next I think I will let speak now we will talk about some new life changes Thanks all that technology is kind of cool but we're going to talk about now is aesthetics and themes are coming to remix we've made a dark theme and like the idea of themes because they're gonna we're gonna be aesthetically flexible for both your eyes and your taste but also for your application so it's going to be easier to integrate remix into your projects so we've made a the dark theme is using the metropolis color palette and that's the compile tab and here's the run tab and in this metropolis edition remix we're gonna highlight metropolis changes as they get reflected into the remix tool and also solidity changes and the UI changes as they get reflected in the tool so you'll be able to be able to navigate remix better with these new updates and also because this is a great platform for learning solidity we're going to be having a lot of tutorials and instruction for beginners so you can start learning solidity with this tool because it's a test it has a test environment and you're not going to lose all your ether okay next up Andy milania's we'll be talking about dapple guess I'm too early oh there we go so I want to be talking about DAP hub what is Dabba Dabba is a self-organizing network of logicians research researchers designers and developers who have come together to think rigorously about gaps from first principles you could say that we are trying to solve the root problems that need to be solved before any interesting gaps can be created you're very inspired by the UNIX design philosophy to sum it up simply the UNIX design philosophy encourages developers to write programs that do one thing and do it well and to write programs that work together this is this philosophy underpins all of the UNIX operating system and it essentially is a philosophy of modularity creating small components laser focusing on them until they are right and then assembling them together and composing them to higher order systems these are not new ideas what I'm talking about right now is a proven approach to design and particularly it is something that we think it is a design philosophy that we think is underappreciated in the world of blockchains both on and off chain we are also inspired by the free software movement we think that the free software movement is the most important cultural predecessor to the modern day Renaissance in decentralized technology and because of this when we look out in the world and we see interesting dabs that unfortunately use have useless tokens that have been added we consider it a call to action we don't like useless tokens and we like free dabs and add a pub we are committed to freeing dabs from useless tokens yeah I knew that be popular today when people talk to the proprietors of these useless tokens they say aren't you worried somebody's gonna fork your project and remove the useless token it is my hope that in the future they will ask aren't you worried that a pub is going to fork your project and remove the useless token this is a moral issue it's something that we feel strongly about so you mark my words we are here on this earth to do this we are here to free the dabs we believe in free software in line with the goals of the free software movement we have created an ergonomic etherium tool chain to empower hackers everywhere we originally created it for our own purposes particularly during the development of maker Dow a stable coin project that I'm gonna be talking about tomorrow which you should tune into but we share these tools using the NYX package manager now unfortunately yeah give it up for the next package manager for those of you who don't know unfortunately I don't have any time to talk about it but I will tease it with this society is just beginning to feel the effects of immutable hash based data structures from git to blockchains to ipfs it is clear that this method of organizing data is having profound effects on the way that we think about computers and applications Nix OS and the NYX package manager is what happens when you combine Linux with immutable hash based data structures and I will leave it at that so on to the tools what do we distribute the first one is called Seth Seth is the ethereum Swiss Army knife if you it helps you use the etherium API if you've ever used the etherium api you know that it's a bit of a pain it's got curl it's got post you have to memorize all these RPC methods it's annoying using Seth makes it delightful if I wanted to send a function call to a smart contract using the etherium RPC right now it would be curl blah blah blah - ex blah blah blah encoding blah blah blah it's horrible with Seth it's Seth send address function name parameters boom you're off to the races it's that simple it reads like prose is delightful if you want to read from the blockchain it says TX hash boom and it's out there you can output it as plain text you can output it as JSON you can filter by field these tools they work together you can compose this into a more interesting tool on top the next tools I'm going to describe build on top of stuff at maker doubt we build many we build our entire feed infrastructure on top of Seth if you're doing anything interesting on the blockchain that's reading information from the blockchain and using it on the command line I guarantee Seth will make your life easier I encourage you to look into it if you want to get logs from a contract seth logs address there they are if you wanted to stay alive in report logs as they come in - - follow up you can compose some commands here we have seth sin address value sub shell and a nice little conversion is it annoying going from leads to way sometimes the next tool is called dap dap is our developer multi-tool it helps us use solidity and helps us develop taps tap build invokes the solidity compiler the C++ compiler which is very fast it's possible you're not used to using it you'll be shocked by how fast it is is much faster than the JavaScript compiler and if you're in a hurry to make your tap I you really want to invoke the C++ solidity compiler it has testing here's a native solidity unit test runner if you don't want to switch to some other programming language to write your tests you want to keep that context on solidity you can write your tests in solidity and it has stack traces isn't that nice never had stack traces before it's solidity so it makes debugging much much easier and it runs your tests really fast I'm talking 150 tests in under a second easy and the reason and it runs them so fast is because it has its own you know I'm sorry I talked about that as tap create depth create similar sort of trying to make using the etherium api a little bit more prosaic we've got debt if you want to deploy adapt to the blockchain it's tap create type name parameters boom you can see it's using seth in the background there like I said these tools they build on top of each other this is the UNIX design philosophy in action people there's very very nice way to build on top of your previous achievements by making things modular like I was saying the reason that tap runs its test so fast is because it uses something called H EVM under the hood which is a Haskell EVM execution environment we created H EVM for a few different reasons mainly around verification we're gonna link it up to other interesting haskell verification tools like quick check but what i'm showing you here is that it has an interactive solidity debugger if you want to step through solidity functions on the command line you can do so with dap using ATVM under the hood up top you can see all of the instructions as they get executed super cool super interesting and last is dab sis that's been the rest of my time talking about dab sis this is our provable standard library of smart contract building blocks a ton of useful stuff here and the reason I say it's provable is because it was built with an eye towards formal verification it is the truth but not all contracts are equally provable you have to build with the expectation that it will be verified in the future and that is what we've done with dab sus a lot of it it's gonna sound familiar to what I've been saying so far you have to make them really really small easily isolate able so you can check their invariants and then it can slot into a larger system the UNIX design philosophy this is a proven approach to design I told you this appears here in deficits there's a ton of useful building blocks here I could honestly have a whole talk about each one of these I'm gonna talk about two today but first let's talk about deficits at a high level at a high level there are two main types of gaps this packages boxes and mix-ins mix-ins will appear very familiar to you these are base classes you mix them in to your adapt logic to get access to interesting functions and modifiers here my DAP is mixing in D s and D s math Diaz auth is providing access to this off modifier and D s math is providing access to this w Mullen I don't have any time to talk about Diaz math but what I can tell you is that this is a very interesting safe math library probably the most interesting safe math library in the business it does not just do overflow protection it does interesting types of token mathematics and that's what W mall is doing there the second high-level idea are boxes this is a concept that we've invented to describe safe prefabricated components that you take directly off the shelf and put onto the blockchain without modifying them you think of them as boxes again I'm reusing metaphors here but what we're doing is we're taking components putting them on the blockchain taking more components and we're wiring them up it actually looks a lot like hardware design ma pre fabricated components wiring them up ended apps that was that's what we've got here on the slide we've got a bunch of boxes that have been wired up into an interesting gap most of maker Dow is made up of boxes that have been wired together there's actually relatively little custom code when you look at the whole thing you don't need to write that much and you don't need to change the code you don't need to inherit from it and add in your own logic you just take it off the shelf put it right onto the blockchain so let's talk about a mixin then let's talk about a box that enables this right here is the DES auth mixin if you don't take anything else away from this talk please consider using TS off so that means wake up in the back if you're not paying attention this is the only thing that is truly important in this entire talk D s off is a mixin that allows you to abstract your authorization logic away from your DAPs business logic what I mean by that is that your DAP can just focus on whatever it was created to do and it doesn't need to think about who is allowed to call it why when or how and the way that it does this is by by providing a DES thority object all dsr types provided es Authority member deeza thority is an interface just like ER c20 is an interface it's a function that different foxes are expected to implement and that function is can call can call will respond true or false if the parameter source can call the depth of function on the destination so here we've got Bob calling the finalized function on the auction and the auction as its des authority box if Bob can call the finalized function on the auction and the DSO thority will respond true or false based on any arbitrary business logic and this is what makes it interesting and this is what makes it important because that business logic could be as simple or complex as you want look at all this business logic the DSi thority could be a simple whitelist bob can call finalized it could be a time-locked whitelist bob can call finalized in two days it could be a role based permissioning system we have one of those indexes Bob is a member of group 1 which can call finalized or and this is where it gets interesting Bob can call finalized in two days unless the token holders veto him what I'm saying here is that D s Authority moves the conversation forward on governance this is blockchain governance right here this is what you're looking at your dabs are your tabs and your governance is your governance and your governance is the DSO thority interface if the entire community converges on can call that's it just can call I promise you 2017 will have been a good year for blockchain governance this is a germane idea this is a new idea and if we can think in this way abstracting authorization away from governance we will move significantly beyond the only owner modifier and we can start using the off modifier this is a big deal I'm gonna show ya thank you this is a big deal this is blockchain governance right here dsr write that down and I'm gonna show you now a box that is enabled by DSR that is the DES token box des token as you can imagine is it is a token it's an e rc 20 and it is of type D as off and the reason that is of type D s off is because it has 4 new functions stop which stops token transfers start which restarts token transfers mint which creates new tokens for the caller and burn which removes the callers tokens lowering total supply we have thought about tokens for a long time at a pub this is we're one of the most senior teams and all of it here Ian we've thought about tokens basically as long as a theorem has existed and we have decided based on our love of the UNIX design philosophy and our own needs in maker Dow that this covers the entirety of the token use case because we're staying here up here on stage to say is let tokens just be tokens just have them be tokens they're just a database of token balances they can only do a few things and here we can see this diagram but they can still be interesting parts of depths right we've got Bob here calling his claim reward function the distributor is authorized to mint tokens on mint tokens and distribute them to Bob right we've got fancy things we've got fancy business logic it's just not in the token contract and when you make a token contract only a token contract but you still make it flexible with DES often these extended functionality you can have interesting things you can think about tokens in better ways let me show you an old way that we used to think about tokens we used to think about tokens kind of in this front-end controller a datastore model this is a very common model to think about tokens whose called the upgradable token so what you had was you had your static front-end you had your static token datastore and then you had your controller which had some sort touken business logic whatever your token did in this case it's doing voting and then you would call the controller and sometimes you'd swap it out when you wanted to update the functionality the hope that you wouldn't swap out the data store but you can't merely make that promise when you're looking at something like this right you can't provably make that promise when you have everything quite so dynamic right we want to make credible promises to our stakeholders provable promises to our stakeholders and not only that this is too complicated this thing is huge waste gas and it's not being a token it's being a bunch of stuff it's difficult to reason about let's look at voting in a much easier way the box mentality here we have Bob calling vote on the voting box and it's just pulling tokens it's just pulling tokens into its box and holding them is literally like a ballot box I mean look at this thing it pulls the tokens it counts the votes when everybody's done voting it releases the tokens much much better way to vote the token is a token the voting box is the voting box and look the voting box can be an authority right this is what I'm talking about when I talk about token governance it can be a DES Authority for an entire system of taps and not only that it can be a DES Authority for the token you can make a cycle here where the token holders are governing the authority that controls the mint Bern start and stop functions on themselves it's like a cycle because they're governing their own token that's neat that's cool that pushes the conversation about token governance forward and that's what we do at a pub if you're interested in this type of stuff if you're interested in formal verification if you're interested in that old-school hacker mentality and esthetic I recommend that you come and introduce yourself come to DAP up calm all the links are there check out our tools check out our chat dat pub chat but a lot of interesting stuff we are here to create free software for DAP Tubbs thank you thank you Andy Minelli millennia of StubHub ion back by back by popular demand we have a rain revere speaking on real world smart contract development lessons please give a hand for rain hello it's so nice to be back good to see you all so my name is reine Revere and I'm a smart contract developer I am the lead architect at shape-shift prism and I'm also the co-founder of Maiden I've been doing smart contract development for a couple years and our team has learned so much along the way and it's really an honor to be here and to be able to share some of those lessons with you and it's especially an honor to be one of the few women up on stage I'm a trans woman and I love this work and and the community is so amazing and so it's such an honor to be able to share some of this expertise and really dig into the details so when I was thinking about what I could possibly share I wanted to give something that was really practical and so this talk is gonna be pretty straightforward we've got lots of things that we learn doing smart contract development in the real world so that means production level handling lots of ether on the live network which as you can imagine has a lot of responsibility that comes with that so what you can expect from this talk is that I'm going to go from low level to high level so all of these are pretty practical tips for all the smart contract developers in here and I'm gonna start with the code and we're gonna go over some details some patterns that I've learned and our team has learned from and then we're gonna end on some higher level patterns especially when it comes to being a lead a leader on your team how do you lead as a smart contract development engineer so first the low level patterns central logging is something that took me a little while to find my way to and when you design your smart contracts you want to modular eyes things right we all know that as software developers but there's some quirks in the EVM at least at this time that you may not think about ahead of time but actually lead to a system that is more maintainable and is able to respond and communicate with your server or whatever other architecture you have and one of those is what I call central logging in a multi contract system logs or events that are fired are really an important way to track what's happening on chain all of your off chain activity is going to be based on different events that are firing and when you are firing events from different contracts you generally have to monitor those events separately so each contract you're going to be watching those events and so if you have a multi contract system there's actually a lot of benefits to using a single logger contract and so when you have a single logger contract all of those events will fire from the same contract and are easier to monitor so let me just show you how that looks so here's an example of the logger contract and what we have here is a whitelist that map's addresses of contracts to a simple boolean that says whether it's been approved or not so this is where it handles multiple contracts so this addresses our of contracts and you have a modifier that's a simple requirement that the sender is indeed in that whitelist and so the modifier whitelisted is provided here and then you can have any event here the event is called registered so that's the red text with the two superscripts and the registered event is simply forwarded from the log registered function so if you have the owner which is provided with the owner super contract and then the only owner modifier pretty standard you can have an owner contract that is able to register of all the contracts in the system so contract a contract B contract C all of those would be an authorized contract to be able to register those and if that authorized address was set in creation then you know exactly who has the ability to register new contracts and then those contracts have the ability to call log registered or any event so that's an example of central logging and that's been super helpful for us to be able to handle large numbers of events from lots of different contracts in a multi contract system the next one I want to show you is the idea of modular libraries so libraries in solidity if you're not aware already are a way of deploying code once that other contracts can use over and over and when you have a multi contract system or you're deploying a new contract for every iteration of something there's a lot of gas costs in that and if you can reference if you can link a library that's gonna save a lot of gas compared to implementing and compared to deploying all the contracts again so libraries are known as well known to be to provide that gas saving mechanism and the idea of modular libraries is the idea that you can link multiple libraries together in order to provide some abstraction layers so these are all like architectural patterns for you to have more maintainable smart contract code so what does this look like the modular library is one in which the contract itself doesn't have to know about all of the different modules and so it's a way to encapsulate functionality within a library in order to have some separation now libraries are linked and all of the calls end up appearing internal so this doesn't actually provide is more of an organizational strategy and architectural strategy than changing the actual access levels so here's an example for the prism project we have a library called prism Lib and there's a lot of different pieces of and libraries that have functions that operate on that data and as a way to break it into smaller pieces one good method is to have a data instruct in each of the libraries that's defined in each of the libraries and then that can be included in the contract and so you have nested levels of data so the struct is defined you can see in the blue with the number one is the data struck and then that's being expected to pass into each of the functions so the rebalance function on the prism Lib is going to ask for the prism Lib dot data and then the nested nature is comes from the fact that portfolio Lib has its own portfolio Lib we can assume is that lit B that's being imported somewhere else so portfolio Lipp we can assume has its own data struct so portfolio Lib can be accessed the functions can be called in portfolio Lib and the data is contained within that Lib and so there's an abstraction there if you notice we're not passing the entire prism Lib data to the Reap to the rebalance portfolio Lib tree balance function we're only passing self portfolio Lib so the second red instance number two and so that way portfolio Lib dot rebalance or any other functions in portfolio Lib don't have to know about anything else in the data so this ends up being a pretty standard abstraction and hiding mechanism but something that we haven't seen a lot of out in the wilds with library development but we found it to be really great really great architectural pattern for prism so now we get to the last of the low level patterns and I want to share with you and this is a higher lower level pattern and this is an idea that has been shared in other talks here the idea of the blockchain as a court system and this didn't come to me until much later in the development of prism but the opportunity to save a massive amount of on chain computation exists when you treat the blockchain as a court system or an arbiter which means that you assume that parties are acting in best best in good with goodwill and best interest but you have a mechanism that if something goes wrong if one party says the other is not doing they're not fulfilling their obligation then you can run an actual smart contract as if you're bringing it to court and when you run that when you execute that smart contract then you're using the blockchain to orbit to arm it that to be the arbiter of that transaction so what does that look like so here we have a contract this is just a general you have some users and there's going to be a counterparty the other end of the deal and they're using you're using the smart contract the naive approach would be to execute everything on the smart contract when you have arbitration built in then instead as AI describes you assume that both parties are acting cooperatively and correctly but you have the mechanism in place for a dispute resolution process so the top interaction here is where the user through the smart contract interacts with the counterparty there's not any execution there's really nothing happening there there's not code that's being executed on chain maybe just a hash that's stored that both parties can can use to evaluate off chain what's happening so user a maybe send some ether to the contract after a certain amount of time the counterparty is expected to send ether back or some transaction occurs and at this level it's really up to the counterparty whether they want to do that or not now if the counterparty doesn't do their part you have a time window a week a month whatever the time window is where the user can file a dispute and that's all on chain so there's a time window the funds locked up and so imagine user B has a problem and says yeah the counterparty didn't do their job so they send a dispute resolution transaction and this time the whatever business logic needed to be executed which could be quite expensive is going to be fully executed and because it is deterministic the winner of the dispute will always win so the beauty of this is that the incentivization is such that if you know you're going to lose you you would never you would never do the wrong thing so the counterparty has zero interest and the reason you you force that incentivization to be aligned so strictly is that you say if if you lose the dispute you basically lose all of your money right so you punish a person for behaving against the expected the expected behavior and so when done right there's really no incentive to go against the expected behavior you have user a acting expecting a certain thing back from the counterparty or the counterparty doing their job the threat of the dispute resolution process incentivizes the counterparty to do their part and the beauty here is that you're not actually executing the full contract logic on chain it's just user a doing their thing and the counterparty doing their thing so I see this as a potentially huge pattern that can be used across smart contracts in order to optimize reduce execution time and this is something that could be put to good effect on a lot of projects okay how's everybody doing you still with me the developers are the developers are like yeah this is cool okay so we have some higher-level patterns and these are for you as well these are also for developers if you spend more than a couple years working in the software industry I hate to break it to you but you're gonna have to do some things other than coding you're gonna have to learn some other skills and some of those are going to be technical skills and some of those are less technical but what are the higher-level patterns that allow you to be successful as a smart contract developer not just when you're in solidity land but when you're working with your team when you're making judgment calls when you're making important decisions about the direction of your product that the rest of your team is looking to you for so one is something that I call role analysis this isn't a technical term but role analysis how do you analyze the roles in the smart contract and this is something that you can use this this is simply an approach to smart contract development and design and you can use it at any stage of the process so if you're designing a smart contract from scratch who is interacting with the system that's the main question you're asking here who is interacting with the system and what are their incentives and how does the behavior how are their behaviors going to derive from the functions that you expose to these different roles so I use this both in the design process but I also use this throughout the entire career of the smart contract system when you're iterating and you're adding new features there's always going to be adjustments to the behaviors of the different users and the different roles that are interacting with your system so to be a really good smart contract developer you have to understand all of the roles of individuals interacting with your contract what their different incentives are and how that affects the overall functioning of the system right this is like the essence of the game theoretic nature of decentralized smart contracts so just some examples the prism contract for shape-shift prism has a few simple roles it has a buyer a seller and an Oracle and with prism the buyer purchases a contract a portfolio of different digital assets the seller is putting up collateral to an sure that those assets can be paid off depending on whether the portfolio goes up or down and then the Oracle is another entity that's providing the prices that determines the value of the portfolio so different roles and even these simple three roles have involved a high level a high degree of analysis on ongoing analysis to make sure that the trust implications are well understood as the contract develops and becomes more sophisticated another example is a salt loan let's say you were doing a loan that was backed by by digital assets that was collateralized by digital assets in this case you have a borrower someone who's borrowing cash and then you have a lender who's offering that cash but then locking up the collateral and in this case you have salt as a kind of multi-sig arbiter to make sure that if anything funky happens with the other two salt is in there and can have the last word this is an example from a talk yesterday the liquid pledging contract was really I thought really a brilliant idea to combine fund management with liquid democracy and here there could be many arrangements but a simple arrangement is to have a giver who is providing some ether and they want that to go to a to a good cause or a good project they don't have time to do that themselves or they want to trust someone else so they delegate that to another role and that delegate is going to choose the project and eventually a reviewer is going to say yes these milestones have been accomplished and that goes through so this is seeming a simple concept but it goes really far and it really is what can separate someone who just knows solidity from someone who can design maintain and scale smart contracts on a live network context dependence is another skill that comes with experience and is something that is really valued on a team and by this I mean analyzing when one action is you in one situation and the same action might not be true in another situation I know this is really scary for a lot of you I didn't get into development to deal with fuzziness and ambiguity either I love really straightforward and deterministic systems but the truth is any complicated problem is going to depend on a lot of context so one example in this space is that you hear a lot of best practices best practices are great but when they turn into hard and fast rules you can really miss out on the nuances of the situation so one I see a lot is sand versus withdraw patterns and and the advice out there is to always have the user withdraw never do a send so there's like push versus pull never do a send and I actually don't like this advice because it's often just taken without much thought why don't we do a send well we don't do a send because there's vulnerabilities if you're trying to send to multiple people you have to be aware that any one person their fallback function could throw they could use up all the gas they could use up most of the gas so there's risks to sending to multiple parties okay I understand that there are also situations where maybe you don't want for the user experience they don't have another transaction you don't want them to have to do that transaction so maybe the send would be appropriate in those cases keeping in mind this dictum of it depends I had a professor in grad school who this was in my counseling program and it was beautiful every time anybody asked well what if you're working with this clients and they do this what should I do she always answered she thought about it and then she said well it depends and that would be her answer every time so with skill and experience comes an incredible awareness of context so I encourage you to think about context dependence and lastly I want to say leadership in blockchain at the developer level because contracts are immutable technical debt is much costlier so when you're making decisions as a lead engineer you have to make a lot of judgment calls because that code might be on chain for long time and that's something to keep in mind thank you so much I'm gonna share it go over the patterns just to name them we talked about central logging modular libraries and arbitration as architectural patterns at a lower level and then at the higher level I hope you can take some of these concepts away about leading your team being more dependent on context and then bringing role analysis to everything you do thank you very much thank you rain [Applause] next up is the meta mask team comethis Frankie and Dan and they're presenting meta masks dissecting the Fox [Music] just excellent can you all hear me alright excellent see what didn't like that very good hello I'm kuma vez from Metta mask and today we will be dissecting the Fox it's are there any meta masks users out there does anyone have it wow that's amazing so yeah we'll be looking at it's part pieces and figure out how it ticks to begin let's take a look at the eyes in the brain what we see what we know first of all we know we must be doing something right we have just shy of 200,000 users and growing at quite a pace we're in Chrome Firefox Opera and recently brave not in Safari they have not adopted the standards that we rely on they like to think differently over there more on brave not just brave support but actually brave integration if you go to a web 3 enabled app in brave it'll bring up that bar at the top recommending that you install meta mask in order to use etherium applications for all brave users this is fantastic [Applause] some other statistics despite its popularity metamath still represents about 5% of the transactions on the network by volume we had a peak at about 10% and I think the the other wallets are about the same maybe Meuse a little more but there's clearly a large amount of activity on the blockchain that must be automated perhaps exchanges or mining pools I'd love to hear if anyone's done some data analysis there in the past year there's been some fantastic gaps that have come out that play well with meta masks the new state of the DAPs website is fantastic and you can even search by meta mouse compliant depths by just adding the meta mask filter I encourage you to check that out to sort of gauge what is the most popular daps right now we have some data from in-furrow in first place is ether Delta and second is Oasis Dex both token exchanges obviously tokens have been very popular so no surprise there in third places meta mask itself we're a bit noisy and we are constantly tracking the latest block updating balances and whatnot after that is the ENS registrar ENS was a big hit this year after that we got token factory token factories a nice little demoed app you can create a token sending it around clearly we have lots of people experimenting with aetherium trying to get an idea of how to use it after that there's the sigh the simple stable token experiment and the wallet aetherium gorg this is actually the official aetherium wallet interface and you can visit that in your regular browser with meta mask and it works then a long tail of various other projects and experiments out there including one 2700 at one obviously many developers out there cranking away we also had a successful security audit this year they said in sum the madam asked project should be considered safe and secure and that's great to keep up with the rapid growth our team has grown from four to ten much thanks to the design by Christian he did the original logo Thomas has helped us out with testing and James has really saved us doing support answering user questions you send us an email he's who you're talking to also the the key oaken team has helped us out very much with a new look and feel and I have to thank consensus for for making this possible so yes let's take a look at the fur and skin the look and feel of minimize next and for that I bring on Dan from the kill contain also known as Dino Dan okay yeah what's up I'm Dan I am part of the Q can team we do apps and interfaces for blockchain companies you can find us at keo keo I will talk about version 4 of meta mask the new UI some token management features and our new responsive layout with multiple form factors so that as you can see the new UI here is completely redesigned shout out again to Christian for some great work it looks a lot better and it's quite a bit easier to use we hope you like it look out for the rollout in the next couple of weeks on the chrome store and several other browsers next up is ad token which is a feature that we've cleaned up a lot as you can see here you can do a stream search for your token name and token symbol this is actually an open source project you can make a contribution to called eath - contract - metadata right now we're searching for maker and we can add it as you can see here we can also add a custom contract token as you're aware of we're gonna automatically fetch the token metadata so this is the 0x token contract address all right after you've added your token you can send your tokens which is a new feature so I've got some shows here for our company you can I can send my tokens to to my friend and I've got a new gas tool tip to customize the gas price we're all about responsive design of course so you've got two form factors here mobile and desktop on the left hand side you have account and balances and on the right hand side you have transactions and on the top right you've got your familiar network drop down and account settings and next up I'd like to introduce Frankie to talk a little bit about meta mass in the browser and what the future holds [Applause] can you guys hear me Oh perfect I can hear myself hi I'm Frankie I am a court dev on meta mask I'd like to thank Dan one more time for coming up and speaking for us so let's talk about building gaps with meta masks we recommend this pattern today if you want to build it up as you can see it's quite a bit of code and personally I think it's a little clunky and that we can do better I've wandered too far from the laptop so I would like to announce meta mascara meta mascara is a module that you can require in your build system or drop in as a script tag like so and to use the CDN meta mascara finds the environmental provider and works with Miss meta mask extension and parity will extract it for you and if we actually go back here we can see how that works and you just call create default provider and it will get it for you if there is no environmental web 3 to extract the provider from meta mask will our mascara connects to the new meta mask web app at wallet dot meta mask that IO let me just hold for a second there guys that means your users don't have to download meta mask anymore to demo this I've built a little DAP here that we can see how the flow of what it will look like using mascara going create password sure we're all used to this of course we've kept our lovely Fox it's also a little slow sorry I didn't speed it up for you guys generate unique account ignore the beta notice as we always do also just scroll straight down and then do seed phrase get a good look at that seed phrase everybody and just as a little added bonus for our use to protect our users we've added a little game to make sure that you've backed up your seed phrase correctly I don't go through and click things yeah it's fun [Music] now of course I'm only human thank God I wrote my seed phrase as you can see it's not gonna let me confirm that because it's wrong so we can all awkwardly sit here now and watch me try to figure it out yeah there you go you're doing a good job it's okay yeah [Music] mm-hmm go on she gets nervous on stage you know ah there we go and of course it takes you to this deposit page which I'm going to skip for the sake of the demo and takes you to the account details screen and we go back to the top click bonk me and if you can see here in a second the meta mask window is going to pop up just like you would see in the extension so let's talk about how that works meta mask as you know it is an extension and provides a single background process for different applications to talk to so users can use the same keys we've created a very similar flow here by hosting meta mascara we'll Ingrid inject an iframe into the web page that talks to the service worker underneath wallet meta must add I know the Service Worker contains the meta mask or which also talks to the UI I would just like to remind everyone also that mascara is a developer beta and if you find any issues please report them we greatly appreciate it now I'd like to welcome comethis back up stage to talk about the evolution of meta mask yes let's talk about where this fox is headed just a small one to begin with debug.trace transaction if you saw the demo for a remixed out of theory 'm earlier it's a fantastic tool for debugging the transactions behavior in your contract but previously it's required test RB C or a specially configured guest node in order to use it and soon to be pushed to production you can use it right in meta mask against any network here pointing at another RPC method our first new one the first one that it's been implemented in meta mask and not yet parity and guess this is a sign typed data from EEP seven one two this gives us a human readable structured data signing format you can specify some parameters and their value and when they are intercepted by a meta mask here's a little mock-up we can display that sort of that form data before you decide to sign or deny and this is very useful for state channels moving on to some internal organs the heart really key management we've broken out the key ring controller and one of our key ring types the hierarchical deterministic keyring and and you can use these as modules if you're building a JavaScript wallet and if you build other keyring types that match that API they can be added to the keyring controller or added to meta masks if we build the requisite UI for them so they slot right in so yes wallet developers please feel free to use these modules take advantage of our security audit we know many people have been waiting for Hardware wallet support contract proxy account support and coming soon the account abstraction from the next fork they can be implemented using those keyring types another internal organ of meta mask is the blockchain data source the the provider we've been experimenting with a ipfs based 0 and light client and what would that look like it's well it would fit right into the network menu and meta mask like you're used to it's like hearing via IP FS and it works just like you'd imagine it would however since selecting an item from a menu doesn't really make for a great demo we have a data visualization of what's happening behind the scenes so this is still very early stage it's a naive it's doing lots of back and forth but what you see here is it's lazily loading nodes from the state graph in order to provide data for multiple instances of the etherium virtual machine running currently it's looking up some data on the oMG token a couple accounts bounces as well as the total supply the the blue is the state graph and the Green is inside of the contract the contract storage if you have some questions about that find me afterwards I'll be happy to answer them this is still very early stage experimental we've spun up a project called mystic Allah to organize some of the efforts to bridge interim and ipfs it sounds like many other projects have been working on this as well so we look forward to working with them and yes the foxes howl many many people ask you how how can we collaborate we're very open to this please just reach out in particular if you're doing a token launch and you are recommending meta masks to your users please get a hold of us we've had many many support questions over the past year and sometimes don't know where to direct our users to actually get the information so please take care of your users and one way you can do that is to reach out to us another how how to contribute of course meta mask is all open source we would love to have your contributions we're looking forward to integrating with the get coin get token in all these incentive schemes that the that the ecosystem has been creating if you really like meta masks we're also hiring reach out to us oh yeah we also would like to highlight a few other things in the peer-to-peer ecosystem as Joseph Puna said many times the blockchain should be sort of the supreme court we should only go there as often as necessary and there's many elements of this decentralized ecosystem that frankly don't need a blockchain and so I I think that we need to explore some of the some of the already existing projects that are doing a great job there I'd like to highlight the beaker browser this is an awesome peer-to-peer browser it's based on the DAP network which is comparable to ipfs it it lets you share and serve websites peer-to-peer as well as create your own websites patchwork which is a one interface on the secure scuttlebutt network this is a very highly featured social network that's completely peer-to-peer and doesn't use blockchain at all this is fantastic I think you'll enjoy exploring its community so please check it out oh yes and one more thing that mascara that Frankie demoed it works right now on Chrome for Android right in your browser so try that out thank you [Applause] 