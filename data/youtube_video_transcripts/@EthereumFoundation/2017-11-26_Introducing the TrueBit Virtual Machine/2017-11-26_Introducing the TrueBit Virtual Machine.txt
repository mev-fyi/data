[Music] takes everyone so I'm tasting toys can we talk about true--but I yeah so in what in what sense am i introducing the troop adverse in so some of you remember last year at Def Con to Christian right best nerve also gave a talk on true bit so I'm pleased to announce here today that troop it is up on the covent test net you can take a piece of C or C++ code and run a verification game up there all the code is up on our github it's all open source so dig right in and I'd also like to thank all of our in addition to our core team all of our open source contributors who have been making that into a reality we are especially senior Vivien and Harley swig so some of you may be old enough to remember before Bitcoin there was a thing called Big Data and you could actually store stuff on your computer you could use the computer to compute stuff and there was even some privacy features well etherium sacrificed all these for a property we called immutability and that's what makes blockchains amazing they're immutable they have some sort of democratic equality properties to them but we are so it's it's time to bring the big data back on to the blockchain so that's true--but is taking this piece right here computation and that's what we're bringing onto the blockchain so and there's also a communication component to it the just like you have the internet for big data where we're looking at something like dojo theory and bridge a way of bringing existing bridge take the tokens off dogecoin and put them on aetherium and back so that's that's the the functionality we're talking about here so true--but is a scalability solution and in terms of the storage piece so I'm talking about true bit as a scalability solution for computation but if you look at the storage situation there are a lot of projects already looking in that space already most of them are more focused on privacy than then data availability but there is interesting things going on in the storage department fact there's interesting stuff going on everywhere I guess that's why we're here but what what what is it about true bit what are we here to talk about today is a process which we called interactive verification okay and and what is it this is what are we focused on true--but is focused on large transactions so if you we've had a few talks just recently about sharding so we're true--but is not going to assume that you can take your transaction set and break it up into smaller pieces you have a massive transaction that's coming in and you have to process it so that's that's what true bid is all about ok so what's what's the problem what are we trying to solve here I guess I don't really have to tell this audience what a smart contract is but I do want to point out a sort of critical property of the smart contract is that they only this sign at the bottom which you can see now says small computations only you're not running computations that run for hours or even minutes I mean they don't even run for for a second so that's that's what we mean about scalability computations actually run so the length of the computation you can run is bounded by aetherium x' gas limit so the obvious thing let's get the elephant other room why don't we just dump the gas limit so first so what is the gas limit a theory a meter smart contract storage and compute resources with a measurement they call gas and the gas limit is the maximum amount of gas that you could allowed per block it's not per student transaction it's it's per block and so so why do we have the gas limit that's that's that's a question so reason a is it because every miner has to replicate every aetherium computation B it's because we're moving the gas limit would leave aetherium vulnerable to denial of service attacks is it C because the gas limit helps incentivize verification it helps incentivize transaction verification or is it just the metallic you trans secretly doesn't want aetherium to scale well I think we can quickly cross out D because it's not a secret anymore I told this same joke a few weeks ago at CES C so now what I do want to do is convince you that C is well I say all these answers are true but C is more true than all the others so this is this is what I want to convince you in the next three slides that C is actually the right answer to this question so let's see what happens without the gas limit okay so no gas limit you have a guy with two pointy horns comes in with a heavy transaction he incentivizes it nicely so someone is bound to pick it up you put a big nice big transaction fee so a miner comes in mines the block he says sure I'll I'll include that because he's got an incentive for it and one of the rest of the miners do they just get like completely confused right because they will what what why are they confused so this is a let's look it a little bit into their confusion so what are they confused about so this is this is actually a principle which we call the verifiers dilemma so in the case of a heavy transaction what should a rational miner do rational miner being somebody who likes to earn more ether so number one skipping verification affords an advantage in the mining race so therefore he has a reason to skip the verification mining on the wrong chain on the other hand means that other miners will ignore the found block so therefore you should skip the very therefore you should do the verification so it should be clear from looking these two statements that rationality doesn't actually help you decide what to do so the miners want to do whatever other miners are doing so so that's that's the verifiers dilemma so so so what is true--but true--but is a is is is a solution to this verifiers dilemma it's it sort of makes it so we we put everything off chain so you don't actually have to deal with with heavy transactions on chain what we've sort of observed in block chains and this is kind of the miracle of the whole thing is that miners are willing to do a small amount of work for free and then you don't have a verifiers dilemma so here with with true--but we are going to give it three I'm a computational boost by doing the heavy work off chain so the goals of the protocol is that anyone can offer a reward for performing a computational task anyone can solve a task in exchange for a ward the protocol most importantly guarantees correctness of solutions and here by anyone I mean anyone that means a smart contract soon anonymous identity or the bots that came up in the earlier talk this afternoon and so if you want to say formally what is true--but it's an aetherium smart contract that's one part of it but it's also a new off chain architecture so I'm going to walk us through these two pieces in the in the remaining time so let me try to explain what how they let's let's look at the architecture piece first just as an overview so trubin is a unanimous consensus algorithm unlike a theory in which you sort of have majority vote on the on the miners people to say like this anyone a true bit can challenge a computation by taking it to to court so to speak and they who sits in the court while it's your your your miners from the from the etherium network are sitting sitting in this court they're always right but they have very limited banned computational bandwidth as we just see because of the gas limit because of the verifiers dilemma you're stuck with that so what what can we do so you have a solver you have a solver who comes in with a data computation a challenger who comes in and says well you're wrong and the solver doesn't actually say let's play a verification game he gets forced to play a verification game he gets taken to court okay so what does the court do it tries to pinpoint the place where they're disagreeing so you have a solver and the Challenger they enumerate the computation states they do the all this off chain and then the judges are going to enforce a binary search to find the first step in the computation where they disagree so solve assess here he kicks out his obviously they agreed on the the green means they agreed so they agreed on the first step because it's the input it's it's just given and they didn't agree on the end or they wouldn't have been in the court in the first place so he says do you agree halfway through challenger says no I don't agree on that so we marked that as as red do you agree it's step at over for says yeah okay great step no for what about 3n over 8 so we're just getting now now we're there these are close enough you can actually run this one step of the computation you could do it on chain because it's small and it's important to note here that the computational steps have to be absolutely identical across all the platforms in order to rule fairly on the final check right there's no notion of one step if everybody's running a different set of steps so the judges we have to make sure that that's the key property of our architectures that all the steps are exactly the same okay so what happens here so here is this the last step where they they agreed and here's the step or they disagreed this is what the this is this step was of course provided by the solver so he's saying so I'm talking about this we there's a picture of a Merkel tree because you can sort of to optimize space on the on the on the on the block chain we represent these states and former Merkel tree but you can think of it as a Turing machine so you said your give a machine it's in state q0 it sees a one so then the program he's claiming if the program says write a zero change to state q1 and move to the left if you don't know what a Turing machine is that's fine just note that whatever the judge said he noticed that it did something different than what the what the solver claimed it would so it's there there there the solver is wrong so the challenge is justified and that forfeit is now the positive and it forfeited the deposit is forfeited so so now let's look at the other piece the smart contract piece which is sort of the crept economic innovation part of this project so how do you actually ensure that this verification actually occurs right what if nobody shows up to to take you to court then it's there's no it doesn't really work so so how do you make sure that people actually use the court the way it's supposed to be used so the second idea you offer awards for checking computations just pay everybody for who checks so now how do you know what they checked well you go back and run the computation yourself you I mean you check that they checked well you might as well have just done the thing yourself in the first place so this this incentivizes participation if you pay people but it doesn't incentivize correctness so I I didn't three would be that you offer rewards for finding bugs so this gives you correctness but it doesn't incentivize participation when there are no bugs so it's the opposite problem so essentially we have the problem that these verifiers stop paying attention if they don't expect to receive any rewards okay this brings us to our final scalability idea for this talk which we call forced errors and that is that we're going to offer a bug bounty and provide expectation that bugs will exist and so this is actually what true--but does we are occasionally the protocol pays solvers for submitting incorrect solutions you have to get it wrong so so the dispute resolution ensures correctness whenever forced errors are not in effect what do I mean by that since you're only having maybe one out of a thousand times you might have a forced error but the idea is that every verifier doesn't know when the forced air is going to come so they're just going to check everything so most of the time they're the the the verifiers think they're getting paid and the solver thinks someone's going to watch and therefore he gives the right answer so an ideally if we made our compiler exactly right on this architecture no one's ever going to go to court this subroutine is never even going to be executed so that's a lot of work for code that you're never going to run now if you only remember one slide from my talk please look at this one this is a picture of an illustration of Ruby Ayers Simon deliver beers panopticon pewter which which is based on Bentham's panopticon and which has physical manifestations in the State Penitentiary in Joliet Illinois the Presidium Modelo and his little pedo sand in cuba and it's it's it's a prison okay so you have in the middle there's a watchtower with someone who's who's looking around into all of these cells there's a bright light so they can't see what he's looking at but out of fear that the the guarding of the watchtower is actually looking at them they actually behave correctly so that's that's the principle of the panopticon pewter it's all about you imagine that these people sitting up here are all performing the computations and this this they're there they do it correctly because they think they're being watched so and and I just quote from Michel Foucault who was also an important figure in the ninth a book you know in the 1970s about Panopto system we have seen that anyone may come an exercise in the central tower the functions of surveillance so anybody can sit in there now there's no reputation this is exactly an illustration of true--but because there's no reputation and true--but anyone can can come in and and and do that so let me in the last few minutes talk about the the developments that we're going on with with with true right now so the de true--but virtual machine when I speak of the virtual machine I mean specifically this this new architecture that's offset not the which is part off chain but also you're on chain stepper which allows judges to participate in this mechanism so as I mentioned before the tasks have to compile and execute identically on all machines otherwise there's no notion of step and the judges can't really participate so they all have to be the same the thing is that you're single computation step on the TVM has to be running within if their mas limit itself so into this and not only I also have to the space required to describe a state change also has to fit inside a theorem transaction so we ideally use the Turing machine as I said before but there's no at least I haven't found any code that takes a bit of C code and turns it into a Turing machine so we had to do the next best thing which is go to web assembly and we even broke that down further it's we we have each web assembly step is broken down into basically sixteen sub steps sort of so so this is this was a we have these properties of our of our of our architecture so if you look at what does it look like overall the picture of the TVM so you have as your c and c++ code and it's coming in to you want to run this task so your smart contract needs some computational boost so you have a C or C++ code that says the task that it wants performed and it wants to ensure that it's done correctly you can use this property called in unscripted which which we use to transform the C++ code into the web assembly code now that web assembly code is used in two places it's used both off chain in this oft we use the Oh camel reference interpreter to to generate the states you list of computation steps that are going to go through on the computation that's used by the solvers and the verifiers meanwhile the task giver pitches this woz and tasks actually on to he commits the task to the chain itself so that it's enforceable so the judges can can can do their and then all this stuff about the incentives that we discussed before and the four stairs are monitored there and we have this this is what holds the money that pays out some of the incentives and here's where the judges live they're running this is where you that's on chain and it runs one step now I want to point out that we do have a new file system for true--but which is basically has well it currently has two two flavors one is you could if you store the data on the chain you still need a file system to access it on the blockchain so you can you can put your data on the chain and advantage there's that it stays there but you disadvantages you can't put very much ipfs on the other hand you can store whatever you want but data availability well ideally we want a system that that has both of these properties the data is available and you can put stuff there so to be continued so let me just wrap things up we are we're we're in the in the process of one one of the first applications of true--but is going to be the the Doge aetherium bridge and we've got the code ready on the etherium side but we need to reach out to the dogecoin community and get them to put in the new opcode that we need which is going to be something that allows people to take dogecoin off the dogecoin network and put it on to like lock it on the dogecoin side unlock it on a theory I'm use it in a smart contract whatever and then lock and unlock send it back it's a Doge again and in order to reach out to people we're doing where we are instituting a new public art project so I'm calling everyone who's interested in being part of this amazing movement this is a once-in-a-lifetime opportunity come talk to me after this talk where as I mentioned earlier we're live on Cove on test net and all of our code is up on github check us out on true--but follow us on reddit medium github Twitter and Facebook and thanks everybody [Music] 