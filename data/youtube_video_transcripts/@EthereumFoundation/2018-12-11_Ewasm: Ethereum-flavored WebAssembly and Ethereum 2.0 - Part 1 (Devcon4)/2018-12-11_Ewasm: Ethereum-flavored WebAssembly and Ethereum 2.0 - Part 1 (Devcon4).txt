okay so we this is the II was in breakout session that's our logo this first time we have shown the logo please remember it um if you want to take photos we don't have time for that okay thank you all for coming this is all the content we're gonna have here so I'm gonna start with some kind of intro high level intro and what was amazed it cetera and then we dive a bit deeper into the tooling behave the languages we have we after that we go into this really hard core part of edmc and ABMC is like a connection layer between VMs and clients and so if you are client in implementer you should definitely watch that and also probably going to deep dive a bit more into the interfaces that's the e I and that's a way to write contracts in it was em and then the most important part is the test net so hopefully we got we can I have a demo here and we gonna give you a glimpse how to use the test net which is already life is so good okay so we blend this part to be rough like 40 minutes and it's really strict in length and time so we don't have time during those to have questions but we did reserve a time like a ten minutes thought after these introductory parts to have a longer Q&A section so please keep your questions to that point and then depending on you don't have tired people are we can take like a five-minute break or we can go even deeper with the second block and the second block it's gonna be a lot of research questions and all the really interesting things are gonna have him there and lastly if we still have time we can have a QA part after that okay so Appetit was in itself it's just introduction and my name is Alex or actually gonna github that's have more people know me and I've been working on it was em for a while and I also work on solidity language design and a compiler but first let's just take a step back and this is just really just a high-level goal and vision we want to talk a bit about so today we still say that we are in a web 3.0 vert but I don't think your Vetri point over yet you're kind of like in a 2.5 stage and at this stage divides mine contracts in a language we write some kind of presentation and a client-side code like the front end and these are done independently of each other and then they are also independently deployed and nobody nobody has like any connection between these and usually the person working on the contract versus version person work in the front end is a different guy or different girl and they have maybe don't have too much connection between the two parts so it's not really integrated but I think in web 3 all of this should be very more seamless than it is today and I think that this is like an idea right this could look like so basically if you look at this this would be like the dot from from the front and on okay and there's one single part called the transfer function which is only part which requires consensus and so I have marked it with consensus and and if you consider this screen then if you have this in an ID or whatever the deployment time or the compiler and everything will know that this is only part which requires consensus that's only part which is gonna get to the blockchain and everything else stays outside the benefits we have here is you see all the data and everything in in one block you don't have to make these decisions you know where where it's like the consensus level data where it's like the front end data and hopefully it will be a much easier decision to see you know what belongs where because right now we do a lot of duplication and I think webassembly can help a lot in this there already is a couple of tools which try to achieve the same thing victory I made a presentation about Luna I think Luna is the name which has similar goals but we try to to get to there from a different angle now this is just like a high-level you know future vision but what we are focusing here today on is only the consensus layer and how do we get webassembly into that consensus layer so what it was and wasn't is executable binary format design for the web it is designed to be highly performant it really models a regular computer and basically if you take a step back how webassembly came into existence it starts with the web itself so we had JavaScript first to to create you know any kind of code which evolved into web 2.0 with a way more JavaScript and the people started to use other tools like in scripting to compile non javascript code into JavaScript and that was quite slow because JavaScript wasn't designed for this so there was this other step called a SMGs which the the javascript engines could detect certain patterns which are a SMGs patterns and optimize those now we can optimize this even more by introducing webassembly we don't need these special patterns so that's that's where this reason webassembly came into existence to improve the web as a result web assembly itself is designed to support a lot of languages it is really low level and a lot of languages supporting it there's this awesome was in lengths repo which lists I think pretty much all of them they're like 28 today but with various you know various level of integration C and rust would be the best ones today but go Haskell it's this assembly script are also usable because it originates from the web it is supported by all major browsers but ourselves we are not focusing on the web right now we are only focusing about the consensus layer and in a consensus layer we don't want to use any of the web engines and we are lucky because a lot of other awesome implementations we don't have to use their browsers to run Watson there are a couple of implementations in C there's an implementation in rust by parity there's implementation and go so we don't have to rely on all this browser specific toolkit so wait it it kind of sounds like Java and JVM right it is kind of but it it isn't fully one main difference is Java wasn't designed for the web it was designed before the web and it was tightly coupled with the language with Java itself so as a result it really had high level features and they don't have like a lot of low level abstraction it has these high level features which tightly coupled it with Java is a language now we don't have we don't have any of these in wasum but wasum is designed to be extensible so awesome can actually turn into what the JVM is doing so one quick example example I want to give you here is garbage collection today there's like no wasum level support for garbage collection and that means if you compile a language which requires garbage collection all this garbage collection helper code going to be in the output as a result it will be big and it will be slow but sense was amazed designed to be extensible and anybody can propose extensions to it their proposals to add like you know what was in level support for garbage collection so maybe that will happen and maybe we get closer to all these features Java has but we at the consensus layer are not forced to take these new features we can stay with the core level of functionality we have today okay let's talk it Heine bit about the EVM itself EVM had different design rules and different goals when it was designed it is really focusing on cryptography and it doesn't really model a regular computer I believe EVM really has its origins in Bitcoin script which is only focused on cryptography and you know public keys hashing all of that is so and we don't really need a lot of these things I think the reason EVM is kind of slow could be summarized in these two points it is 256 bits focused so that means all the instructions handle data with 256 bit precision we do calculations between 56 bit precision and we don't need that in most of the time it also makes this high-end low-level features which you know probably is not a good idea now I don't want to go too deep into EVM here but we're gonna have after this two hours session began I have a panel a medium so I encourage you guys to stay for that and learn more about the VM you know the past present and future of the EVM but the EVM itself does have one big benefit it is kind of small can easy to implement and easy to comprehend a single person can easily write in a VM interpreter and grasp the entire EVM you know specification I think the same kind of applies to awesome but there wasn't specification is a proper specification so it is long and it is extensive and explains every single edge case there's no such specification for the VM so if you look at the EVM spec it looks small and simple but I don't think they differ that much Paul gonna talk V more about this in the second part of the session okay finally we reached you awesome so what is he wasn't we are trying to Mary was him and etherium together but he was amazed really just wasn't we didn't have to change anything in it and that's the beauty of the design of extensibility it has so basically the extensibility we have to adhere is we have to expose DTM state access and modification and access features into web assembly and that can be done without changing web assembly because web assembly is designed to have a way to import external calls and we're exposing all these features as external calls to the wasn't bytecode that being said we don't want like regular wasn't bytecode to be deployed we do want to verify the debate killed complies to certain rules we want to enforce the good news is though that you can use a regular compiler which supports possum and you can compile the code with that you don't need any change there and most of the time you don't even need any kind of post-processing but we do have to ensure that nothing goes wrong in a consensus setting in a block chain so we have this verification step when someone is supplying deploying wasn't bytecode we run it to another contract which we call the seminal contract and this contract is looking up features which shouldn't be using wasn't bytecode so one feature which always comes up and which is the major one we have to restrict is floating-point numbers they cannot deal with floating-point numbers right now in in a consensus setting so we just reject any contract which uses floating-point but in most of the languages you don't have to use floating-point anyway for contracts that this is not a problem the other big part we have to do during test deployment process is to inject metering into web assembly the reason for that is we don't want to have specific was in VMs which do run time metering we still want to use you know generic was in VMs or at least have the ability to use generate was in VMs that being said I do believe that we have to have specific was MVM implementations in our nodes which you know are really designed to work in this environment but they're still compatible with it wasn't byte code okay some of the high-level design goals we have followed are it's really just to have an extensible foundation for code execution and it wasn't it's kind of like a blueprint for computational you know describing computation so you can take this wasn't blueprint and you can translate it to local machine code that's high it's design so I think it's a really good foundation for this we're also trying to tap into a very bigger ecosystem here until more languages but more or importantly a lot of more tooling especially regarding security analysis or Danang etc and there's this point of reducing complexity in aetherium and how if you're introducing this kind of more complicated thing at least some people claim it's kind of more complicated but there are ways to reduce the complexity in atrium by having wasum so one example here when I highlight is pecan pies so today with freaking pies every single client has to implant pecan pies themselves which was him you could just apply a single implementation of this pecan pie in volume itself and everything each of the clients say that's you know to be written but one really interesting thing which came up before defconn at the swarm summit shows from the light delight flying protocol what does Elia stand for but that's the light idiom whatever but he's the light client for the whole person he's designing the entire life line protocol for it cerium and he came up with this idea to use wasum in there the problem he's facing is in the light client protocol you have to make say you make one query to get like a hash and then you receive more data and then you have to make subsequent queries so it you know bubbles up into a lot of communities so what you could do is submit a computation in wasum do not know what the node executes that computation it gives you back all the results so you don't need all this data exchange you can get the note to get you the data you need exactly so I think that's really interesting you know direction we could go but lastly a really important point is with wisdom we do get a better interaction with other blockchains so I can I expand on those a bit later so with the languages itself we are tapping into a bigger pool of languages that being said we still wanna support solidity so the solid team is working on having awesome output and hopefully that gonna happen early mid next year no commitments here though but today we already have a lot of the tooling for us I'm in rust because rust is like the the most mature language do you have to link for wasn't but there's this last thing which we also gonna touch on today is a similar script which is a language similar to JavaScript and it is we are working on framework in assembly script to write contracts and so it's it's really looks like JavaScript it is easy to use and it's compiling - he wasn't just if you know it's about other blockchains a lot of other blockchains using or considering awesome and if you also do use wasum that you're going to have way more options - we have code sorry you have code shared between all of them so I think that's super exciting okay just two more things to mention because we haven't really mentioned like backwards-compatibility so if we have this tool called room VM or run a VM which is an AVM interpreter compiled Yui wasum and you can use this in a entirely wasum only client and you can run even bytecode on this was only client and why you VM is a similar tool but instead of having an interpreter it is compiling a VM to wasn't bytecode now these are early prototypes so if anybody is interested in working on these really cool projects please talk to us so the next steps we have now is we're launching a test net and then we are trying to get all of this into the main net but we cannot do that at once so we are trying to get a subset of pre-compiled only support into the manor and then I have the entirety of ewaz I'm in the main that even though it's said like a goal goal number four I think chess / / e 2.0 certainty work gonna happen parallel to all of this so that was the intro please check these back and all the code we have show and get er create apps and talk to us thank you sorry I didn't sort of do an intro in the beginning that was Alex Parrish I see he's our team lead one more round of applause for Alex all right up next I think we're gonna do demos of some of the language tooling that we've built Paul are you up first obviously one of the nice things we get with the e azam tool chain is the ability to develop smart contracts and a whole host of different programming languages Alex a moment ago mentioned some of them these include rust C C++ assembly script you're gonna we're gonna do quick demos of two or three of these right now and as a first framework for doing that we created alex created something called the WRC 20 challenge the w refers to wasum and it was just a challenge that we put out there a few months ago to build a simple ERC 20 style contract like a token contract using the various languages we've had implementations done in eight or nine languages so far I think you can find this in our github repository github dot github.com slash you awesome if you're interested in contributing one and Paul's gonna do C C++ right yes you don't like right yes we had this WRC twenty challenge to implement GRC twenty and I wanted to implement it in C and C++ so I think most people engineer x' many engineers learn C as an undergrad and seen C++ is as ubiquitous and people are talking about these languages like rust and assembly script but I'm sort of naive and I am stuck in my ways and I like C and C++ so that's why I wrote it in C or C++ so anyway I found some anyway this is just the gist of the code [Music] boy I don't know some reverse bytes stuff and I wasn't really I don't know what to really say we we have some functions that we were to implement and I implemented them and this is how it's it's like I know this is like you know a lot to just you know I don't know how I'm supposed to explain this in five minutes but anyway anyway this is the smart contract and C and C for is similar for C++ and we're hoping that you know if we're gonna on board you know hundreds of thousands millions of people you know a lot of seen C++ programmers might want to write smart contracts too so maybe we should give them tools to do it and some make stuff so I'm using this some LLVM back-end but there are some problems the toolings are the tools aren't ready yet but there are some people writing tools to do this kind of thing lien can you come and also I wanted to show another implementation of WRC 20 I'm not a MEK person that's why okay so if you don't so see is one option C++ is one option but if you want to handwrite it in in webassembly you can do this so this is my version and I think this is the shortest version of the WRC 20 the most efficient one and if you're going to use it this might be the best one it's like a hundred eighty lines of what assembly code no but I did have test cases in the past the test cases yeah so maybe I don't know maybe you won't trust it but 180 lines isn't beg your pardon okay right so we have a WRC 20 examples repository here it's you awesome slash WRC 20 examples and right now there's an issue open and you can see I think most of them are listed here so we have rust we have assembly script which I'll show you in a sec we have NIM which is very cool c c++ handwritten web assembly think there may be a couple of others as well thanks Paul [Music] alright I'm gonna show you guys what the assembly script 1 looks like now so I initially came up with a really clever name for this talk smart contracts in JavaScript no really almost let me explain what I mean by that so first what is webOS I'm sorry what is assembly script so assembly script is a subset of typescript which I'm sure many of you are familiar with right type typescript is a strictly typed superset of JavaScript and types are good for a whole host of reasons we believe they produce better code it's a better programming paradigm and in particular in sort of mission-critical applications like we're writing on aetherium we think the types go a long way - like I said writing better more secure better performant code as well and on top of all that of course webassembly itself is strictly typed so yeah so so there's a really cool project called assembly script which allows you to write in a language which looks and feels a lot like JavaScript or of course typescript if you've used it and compiled that down to web assembly and so sort of from my perspective I have nothing against domain-specific languages like solidity and Viper and all the other great ones I think that they're very important they've gotten us quite far and they'll sort of have a role in the etherium ecosystem for some time to come however my personal sort of goal for aetherium is I want to see millions of people developing applications on aetherium and personally I don't believe that way the way we get there is is by requiring people to learn brand-new programming languages and brand-new programming paradigms from scratch right let me just go over this point one more time because I think it's important there's a huge advantage to doing that right if you're writing mission-critical code if you're writing a piece of wallet software by all means do it in solidity do it in Viper learn EVM get that code audited right I don't want that process to change but if you're building something for fun right if you're building a toy if you're hacking at a hackathon I really think that having something that as I said looks and feels like JavaScript and uses existing JavaScript tooling tools like nvm and yarn etc NPM etc is will go a long way towards towards opening the ecosystem to millions of developers who are very familiar with those tools so that's my personal motivation for working on assembly script so I'm just gonna this is as Paul said a moment ago this is kind of a lightning talk I'm just gonna super quickly show you kind of what this looks like and the first thing I'm gonna show you here is my WRC 20 example code so this works this is this is assembly script it's valid it compiles it runs we've deployed it on the test net and I'm sorry if that font size is not super large I don't think I can easily increase it but hopefully you guys can get a sense of this you know it's kind of funny right it looks sort of like JavaScript it kind of has JavaScript syntax but we've got so we've got the strict types of typescript and then we've got stuff which looks and feels a bit like assembly so what's going on here is we have a single main function which is the entry point and what you see with this the switch here and these sort of hexadecimal strings this is a simplified version of ABI so we've manually implemented this the main function receives receives a call and it sort of unpacked the first few bytes and uses that to figure out which function is being called and I think I have the do balance function over here which is the one that returns the current balance and you see things which are basically more or less map one-to-one to EVM operations right so things like get call data size call data copy we're also manually managing memory we're loading things into pointers and stuff I think I have another one here this is the do transfer function so again this kind of reads the input data gets the length of it reads the input data at allocates memory you know moves pointers around etc and then there's no return because what has to happen is it has to store the return value into a pointer so this is a step in the right direction but this is not exactly the way I want to write code and so I want to show you this is what it will look like and this should look and feel a lot more like JavaScript like modern JavaScript we have you know some abstracted classes things like a contract we have decorators so we use it II was in decorator to indicate that this class is the class that is the entry point in this code we use a simple store decorator so this looks and feels a little bit more like solidity it's inspired by solidity we have things like maps and look how much less code this is look how much more readable this is right get balanced set balance or a single line the transfer code should be pretty pretty clear so this is the direction we're going the first part here as I said this works this compiles this code is in that WRC 20 examples directory that I showed you a moment ago this is like halfway there I've been working on this myself and could definitely use help so this is under the ether TS organization on github github.com /e 30's TS being typescript we're trying to build out some more typescript tooling yeah i was going to do a quick live demo of showing you how easy it is to to initialize this you can you just install a single npm module you run a single command and you've got the framework but I think we're running short on time so let's go on to our next talk thank you so up next we have Pavel so Pavel is a member of the EOS m team he's also on the Alif team and he's going to talk to you about EVM C hello yeah okay hello everyone I'm C++ developer within a team foundation and one of the project I was working for some time is called EVM see it's I would try to explain what it and give some quick updates what what has happened in the project recently and and well keep the lot okay here we go and in the second part of this presentation I'd like to go go from this EVM C and through EVM as well go back to awasum and some dis explained some design decisions we might and where they come from ok so let's start with this EVM see this is a project that has mostly one goal and it wants to define the API in the classical sense of the way the VM implementation can communicate with the full achieve on client and how we call it here we called we call it a host so it's describes rasa functions the both sides of this equation has to implement so on the hot side we require some some functions some methods the the client has to provide the EVM execution and on the VM side we just define what what are the entry points for execution and how the VM should be created and how can be used by Julian client implementations and if we can focus on the the host methods that are there there are 12 of them and most of the most of these these basic definitions are written in in C code however I decided to to show you example of what how they this this methods looks like taking the go part of of the project you don't you don't need to read it all it's mostly I wanted to show how how complex it is to to enable this EVM support in in achieving client implementation and so so to explain where where it was amiss is all this picture so it's not so I mean it it seems it's completely different execution engine but EVM see actually doesn't care about the execution itself it defines what actually data has to be provided to the execution so this product was started more or less the same time the USM idea was was brought up to the achievement community but it wasn't it didn't have didn't have the the wasn't in mind but it it's it turned out it's you can also implement it was an execution engines use exactly the same API to bring it was intuitive iam clients and here is one of the examples that actually support EVM see from the beginning and it's fully compatible with any Experian client that that actually has also the EVM support in the bank so within this EMC project they also try to have language bindings directly inside the project and we started well the first one was the Python prototype of of that to figure out if final fight on being scripting language is it is it the the C API is good enough to have Python Python support and that worked very well but now we have go support ready to be used and Jeff is using that does go bindings in the Indigo assyrian project and and i hope there will be more but mostly I try to keep them inside the project to be tested with all the changes were made in there and just before bath Def Con there was released six 0.0 0.0 of of EVM see we're using semantic versioning for that and also we describe a number called a bi version which is the first number of the full version and this number is exposed today to the implementation to check for basic compatibility especially we when we use dynamic loaded libraries for deployment and at the current moment I'll have the C++ implementation of of of a Tyrian client and GAF within the pre quest that was submitted supports EVM C and on the VM side we have a live interpreter which is part of a live product and also here that suppose that currently and there is there is a node that actually uses this gaff plus a live interpreter combination that it's fully production ready and can be used on the minute I have one node running myself and we using graph and here a combination to run the it wasn't test net and some of the plans but I chained it to wishes because there is no commitment to that it kind of works in the reactive way so if if you would like to have to bring this support to your projects or you need some other language bindings please express this its needs and we're happy to have and this is like way when you can you can learn more about the project where you can find documentation the implementation guides both for vm site and for host site some examples and chat room when we are available so from that I would like to go to this second part of the talk and spend very little time on explaining how this affect it wasn't designed to some sense so I'd like to put your attention on three three aspects of starting with Viviane that this kind of special opcode stir that I know it's many people but and how they map and I would like to explain how they map to be BMC design and both the awasum design so this special instructions I mean are from some some instructions that allows you from the car from the contract execution to access et on state and some other environment information about what's going on currently on the blockchain so you are allowed to put some data in this database called storage read data from there and check the balances of other accounts and many other things and just for this example I will focus on this float and Esther and so because this is this storage access is it's required for contract execution but it's not about the execution itself it's a way to access some data that is outside of this virtual machine that it's it's conducting execution so for example in EVs Eve EMC design we have to provide that so this is like one of the required methods the host has to implement to allow contracts to access that and we cannot provide this this this data upfront because that would be we don't know which exactly portion of data would be needed for execution so this is this is also taken from gold bindings of EVM C and this is there are two functions that this host class has to have to provide for four VMs and and when we go to USM and precisely to this material in the environment interface this is a part of us and that tries to describe very similar aspect of that so how code written in webassembly can access environment and information that are specific to aterial so here this is a snippet of webassembly text representation and mostly what it shows its first of all this notion of important functions in any web assembly so this these are functions that given webassembly binary specify and required for execution so every every contract with possibly written contract we need will have a set of these and probably will specify that okay I need this this function is provided by the ID the environment I'm running it to access some ethereal specific information and to learn more about that there is a section if in the design design repo of of it wasn't so I'm occurring to you to check out all other methods that are there and maybe leave some comments if you think we can do but I mean most of them map more or less directly to EVM semantics because I mean there's many reasons for that one of them was to have full compatibility with EVM that is now questionable if we want it or not but if you have opinion about that yeah this is the place you can find more information okay that's all for me thanks for attention [Applause] thank you Powell that was great what if you don't know does it work and you yes okay most of you don't know that without evm see we wouldn't have been able to enable to test Anton both Alice and gif so it's a really important project please check the repo pavel has shown and it is the way to get rapid support for he wasn't in any new client and now the the most important but you want to load the video the most important part is the test net so we have Jared welcome Jared so Jared started working on it to MJS he did a lot of the VM work at TT MJS and then he also did a lot of work in Russ on on the awesome team and he's also working on POA stuff before authorities stuff in rust but in last couple of months he has focused a lot on the dev ops side on iwo Sam so it's really due to Jared and KC that if dev ops team that he wasn't that we have a test net just one last note about the tested itself it is actually working it has been working for the last couple of months but it's the first time we share it with you guys but keep in mind if you're still making changes to it we're making updates to it it is a proof of our test net so we gonna just rebuilt it with the new updates every now and then but it's still it's already ready to be used so big applause for Jared again and you can explain everything to you guys [Applause] up is this working yeah it is thanks for the introduction Alex hi everybody I prepared a short video because well we know how live demos go so let's it doesn't have sound so I'll just kind of yeah so what we're seeing here is just the basic components of a test net I've created an empty account I am connecting to the RPC endpoint and getting some ether and now we wait a little bit okay so the next step I'm gonna deploy a contract I have here and this is actually a contract from our test suite and basically all this does is it just it's some deployment code to put up a simple web sembly contract and this is a simple tool we've developed that should make deploying contracts fairly easy so yeah one of the things that you should note about this is that you'll see that at no point before deploying there well actually I'll just let it be deployed in I explained cool okay yeah and unfortunately this highlights a little bug that recently appeared in our Explorer don't worry we're gonna hotfix it but you're gonna watch me scroll through the list of all accounts to find my deployed contract and I guess one of the things that I want to highlight here did once I once I scroll through all the pages but so I'm if you if when you saw earlier presentations you may have heard about metering and so if you saw the contract code I had to deployed before you'll notice that there were no metering or use gas calls and what's gonna happen is that when I've deployed this contract actually what's going on is we have another contract called The Sentinel contract which is going to take my deployed contract parse it out and apply metering injection to it so after I finished scrolling through some pages here don't worry this will be hot fixed it should be one yeah there it is okay cool yeah so yeah this is a little this is the block Explorer that we've modified now you can see the code now has this used gas import and the entire branch has been metered by so you'll see the the use gas statement is was applied by the metering contract it's applied to the entire branch and I believe metering as it currently works is applied by branch so I can't tell you much more than that because my job mostly involves breaking things on the test net and then fixing them I didn't actually write the metering contract so yeah so yeah that's kind of that's gonna it for the demo please feel free to go up I mean it's up now so go and try and break our break our stuff we are gonna be releasing later today some instructions if you want to connect your own node to the test Nets you don't necessarily have to use our tooling so yeah that's that's the demo [Applause] Thank You Jared for the demo yeah we're really excited to share the test night it's live as he said the RPC URL I think is just ye Hwa's m-theory org port 8 5 4 5 so you can actually plug that into meta mask you can plug that in your browser you can get testing it either already there are instructions up in the USM slash test at repository about connecting your own node but I think it doesn't include the latest like Genesis file so you probably if you were to try to do that right now you get an error sorry I've even other people in the room who have already tried to do that well we'll update that later today so cool we're gonna move into a QA for 5 or 10 minutes so we can have all the teammates come up and we'll answer questions CX are you good to go with the mic excellent and then after that we're gonna do a short break and then come back for the second half of the breakout so if you have a question raise your hand about anything you've seen I have a question about this EVM see you mentioned that it's running on one main net node what does it mean for me as like can I run evil resume code on the may net if you pick up my transaction a minor block or like what does it mean so it's just basic it's you note if you go to either stop it'll starts that dotnet there's one node called a live interpreter so it's combination with with the gate client and a live interpreter as a VM implementation so that's I did it just if you want your run your own node you can just use this this implementation I think so that talks from your experience like you have mentioned several languages solidity vast assembly script C++ which one is like a better or worse in case of like a using like having several languages is good in one the exit direction but also there might be some problems connecting with like a using one language or possible I don't know some drawbacks to do shared like your experience when you were actually trying to use different languages for the same thing yes I'll just repeat the question first so the if I understand correctly is that we just explained that one of the benefits of a well Simon wasum is that it allows us to write contracts in many languages you saw demos of two of them right now and so share your experiences you know which ones have been working better which have not been working so well are there sort of advantages or drawbacks to any of them you might want to take that question I'm just gonna put it out obviously solidity is the best to write contracts in but that's for the fact that you guys are familiar with solidity and you can take all the execs existing code and compile it wasn't once we get that done but it's not done yet so right now the the next best thing probably is rust if you know rust but it does have a steep learning curve but it has the most mature tooling around it and even our tooling around it is the most mature one if you feel extremely confident you could try C++ or C I wouldn't recommend it personally we do need a lot of help to finish the assembly script and so probably I would try to direct you know all the effort into that direction unless you want to work on solidity compiler to have us on so these are like the two main directions to to enable contracts easy contract writing to people yeah forget about it go we should do an introduction here though if you want to ask proper questions cause you want to start we'll just go down the line doesn't do them like I'm Casey and just to answer the question I think one of the advantages of webassembly is the interoperability between different languages so you can take library that was you know that's in rust compile it down to web assembly then you can call that from and it's some assembly script code so being able to mix these different high level languages I think is a good advantage you go hi everyone my name is Google I'm working mostly on writing test cases using the web assembly text format which is really really fun and yeah helping a little bit on the on the US and explorers well hi my name is Guillaume I'm a member of the go team and also of it was him obviously yes so just to wanted to say when it comes to gogo as a very limited support of well very experimental support of webassembly so and it's got all those features that you don't need in the case of webassembly like the garbage collector all that stuff so like binaries you get are very very big and its really not appropriate for for this kind of use case so far but have you seen that there is a embedded compiler for go which also supports was my output and shows out the GC and its GC no true said the GC of go so it's tiny yeah okay well if they that would be interesting no I didn't know it would be interesting to to have a look at it still don't think it's a great language for that but yeah yeah yeah Alex Cody gave the spiel on me yeah Jared party Watson team I've also in addition to working on DevOps I have written a few adapters for bringing DNS SEC more cryptography for DNS specifically edy two five five one nine two the as a pre compile three he wasn't yeah that's it well you know me I had to talk so just passi don't Alain Alain I have been working on tests with Hugo I've been working on the assembly script which you already saw and then kind of things like documentation and education let's call it like trying to organize events and get people excited about you also yeah writing thank you for writing writing code is easy building communities is hard so community FTW I'm Paulo and yeah C++ stuff maybe we just go back to questions what Paul won't introduce yourself when Paul trained in math I just do some basic stuff that helps everyone out Paul is very impulsive Airy modest but he's the cornerstone of the team all right sorry you guys yeah I thought this assembly script demo was awesome so like what what work is left to sort of get assembly script to a a good level and like so this is my first time sort of learning a lot about like Wazza mandy was um so like what steps are there left to you know write a contract and assembly script and be able to deploy it on the current etherium main net cool I'm glad you're as excited about assembly script as I am I mean I really I said this before I'll say it again I really think that this is a platform that we can use to get like millions of people excited about aetherium who may not be excited about solidity all due respect to solidity so I didn't have a chance to talk about this so assembly script is a obviously an open source project there's a small team working on it it's kind of a beta I would say so it works but it's volatile so they make breaking changes sometimes which has sort of slowed things a little bit what I've done is I've so they have a data compiler that takes the web assembly sorry the assembly script that you saw and and runs it through under the hood something called binary and which is actually a sea based assembly script compiler and then produces the assembly script code sorry the wasum code they love assembly code so what i've done is i've hooked into their compiler through what's called a transform step so if you know anything about the way compilers work you have you have a tokenized step and you have your parsing and organizing and then you have a compilation step and then so in between those two that they it hands us the AST which is the abstract syntax tree and we can kind of move things around right so for example there were decorators like that at UM decorators so in the transform step we can grab that and we can then insert things like the amid code that we need into the tree and then that gets passed back to the assembly script compiler and that gets compiled down to wozmak code so that's just a high-level overview of how this works so that's all working it's just all these pieces right so getting storage working getting the anit code working and then the other piece that needs to be done is hooking into tools like embark and truffle so you can easily deploy those things onto the chain so I would say the work is about 50% complete there's still a lot to do and as I said I've been doing this alone and you know working on other things at the same time so if anyone in this room is excited about this yeah so just check out the repository it's github.com /e 30s /e woz and - AAS I'll put that on the screen or something he wasn't - assembly script so the second part of your question which is kind of like how far are we away from being able to actually write contracts actually an assembly script and actually deploy them on the main that that basically is a question about the e azam roadmap I don't know you touched upon this Alex do you want to talk about how this might go to mean that yeah I don't think I have much more to say to that when it goes to domain say definitely can be used in the test net and they're regarding the main ant we definitely have to go to have all of this in the main net but that that's gonna take a while we do believe that we can accelerate that process by first proposing just a subset of he wasn't for the main net and that would be only for pecan pies and so that's one of the next things we're trying to to discuss with other teams how we could do that have you brought it up on one of those awkward F calls and and there was a good reception to it so I think we're gonna we can achieve like pecan pie support on the main net for was in next year sometime perhaps it also depends on how Constantinople goes right that's a big question and after that hopefully you can expand into you fullfil may not support but you guys can really try doing a test net and that's what matters right now and we have been closely in touch with other projects including parody polka dot it space meshes another example of a project that's really excited about about us and about things like assembly script so I mean none of these are like in production yet but the code that you write now and the things you learn now will apply actually across like a whole host of different chains in the future yeah I guess for one more question you know what what would it take to get past maybe a year a while awhile to an actual schedule allocated resources a series of tasks the kind of thing I would expect to see in a real engineering project so that other engineering projects can plan their work and have some degree of confidence that if they spend their thousands hundreds of thousands millions of dollars that they won't find out that oh no not this year next year oh no not next year the year after that you know what would it take to get a much higher level of confidence in your scheduling rather than what appears to be guess what you're asking a question about confidence yeah how can we get more than here's a road map but maybe we'll get there someday versus here's a schedule and assigned resources and a fairly high degree of confidence that we will get to certain stages we're not business people we're engineers we're developers we you know to define what confidence means you have to define what a human being is and how human beings interact with each other and I don't even know what that means I'm just a developer I don't know well then it bears where are the managers okay sorry Alex go ahead I've spent years it's kind of a question partially for the foundation and not only a foundation but okay I do think we have we have some kind of answers to this question and I'm glad you asked this question so in the awasum team itself video started to use in the last couple of months the project boards and github and set up projects and goals and deadlines for those and we do have all of that mapped out for the tiny tools we have for example Hera which pavel has mentioned we have a road map when which version with what features said it gonna be released so I think we're really improving and they wasn't project itself to have a proper road map and and and plans for those but the bigger question is really how we can apply all of this to the main net and the good news I think is that there recently there have been a lot of good discussions between all the different teams involved with writing main net clients and it seems like all these teams are interested in improving the process the non existing processes putting something in place of that so I'm kind of hopeful that this gonna happen very soon the first step has been made all these teams started to communicate to each other and realize that there is an issue which has to be fixed so I think it's gonna become better thanks Greg I think are we out of time for questions yeah I mean the question is already guys tired do you want to take a break what do you wanna make questions because we still have like another hour to to go and give them a glimpse of what's coming up in the next episodes or topics I think roughly we have like 40 minutes of content left and we gonna start which is the bottom engines is the first right yeah there was a man gene so so Paul gonna deep dive into how Azam actually works and how what some engines work that's super exciting then we have - which ins and how we could well actually tree visions the first vision is called tool Bo II wasum which explores ideas how we could speed up transaction processing speed and increase the throughput which applies to he wasn't but also applies to EVM on the main net so it's super exciting and then we have a really grand vision for the future titled was MOS which tries to pull everything together what I meant in the very first part of the talk as web two point five versus battery they are like this combined seamless system so that's the bottom of our talk and then we have a really big topic on how to do SH as per in a different way so that's like 40 minutes and we have one hour left like 55 minutes anybody wants to take a break you 