foreign [Music] I also can't see the slide so I'm gonna like also attack us on the trailer okay so I'm going to talk a bit about how we got to where we are today with you all uh by going through at least timeline of events uh in June 2019 I introduced the optimistic raw design Paradigm under the title of minimal viable emerging census and this kind of kicked off the whole idea that you can have some sort of scalable execution system anchored into ethereum for security uh moving on uh to December 2020. this was you know right at the end of the year but still in 2020 we did a Mainland launch of fuel V1 as the first optimistic rollout on Main and ethereum and through the style is actually the still the only system that could be considered a true roller that is trustless and permissionless uh since then uh up until January 2022 we were essentially heads down building out uh fuel V2 which was an evolution of the protocol from a payments only platform to a general purpose smart contract execution platform so we published our code and GitHub since then the code has been developed it has been open source and entirely developed planned and Etc all in public not a lot of projects I should do this entirely in public we ask you to all our development in public uh uh then um June of 2022 we launched a sway swamp demo sway swap is a part of Junior soft V1 to sway which is the high-level language that I imagine most of you are here excited about uh and a lot of the private tests now and then in September of 2022 so just a short month ago we we released the beta one public testing of the fuel protocol this is actually completely permissionless anyone can use that to buy smart contract run transaction and you can use it today and now we're here uh.com October 2022 and what do we have and where are we going to go let's talk about the three pillars of fuel and what makes the protocol so great to use and to build with Etc so we have three fundamental pillars one of them is performance uh performance through parallel transaction execution the second one is flexibility and waste reduction through the fuel virtual machine and the last is a superior intact unmatched development experience through Sway and fork and I'm going to be expanding unusual these colors in the coming slides so let's start with the first one performance through parallel transaction attribution this one is actually going to be the shortest of the three floors of Calvert because it's actually fairly straightforward to explain which is that you can see from the start here uh the well the number of transistors on CPUs has been increasing exponentially over the years you know this is Moore's law these single threaded performance in the last you know 10 plus years hasn't increased exponentially it's kind of stalled it's basically leveled off what has increased exponentially however over the years has been the number of cores right so if you have a system that is sequential that can only leverage a single core it's like you're running it on a 10 year old computer right it's not it's not exactly a very good place to be when you're trying to build a Global Financial access Etc system right you really want to leverage the same that is increasing exponentially year over year and that is this parallel execution multi-core uh multiple cores multiple threads running in parallel uh the fuel virtual machine is designed and the fuel protocol is designed to be able to run transactions in parallel as opposed to evm which unfortunately can only run transactions sequentially this will lead to a vast increase in throughput all of us being equal not because you need a more powerful computer but just because you're using all the resources of your computer that in in the VMware just kind of sitting there wasted so that's the again that's really all there is to it parallel transaction execution massive increase in Drupal now on to waste production uh an increased performance on the single threaded model oh I guess I didn't collect this and on laser function and improved reference within a single thread through the fuel virtual machine so there's also some QR codes uh here that you guys can scan if you so wish that link to some of our documentation around these things just in the slides will all be posted later on so if we don't if we don't want to scan them right now they'll obviously be available uh the fuel VM is fundamentally the evm but improved one amazing thing you can do in rollups is experiment with improvements enhancements Etc and there have been many many erps and just ideas that that didn't even make it to erps that have been proposed over the years for ethereum but that could never be implemented because of a need for backwards compatibility also limited developer resources you know just worries of too too much change too fast might be risky if you have a large code based on Randy with a lot of tech debts all right but people still want these changes they've been proposed uh you know if you take a roll up and you know you might say oh okay I'm an evm equivalent roll up I want to improve it I'm going to start implementing eips to improve it right I'm going to add a counter traction number we're going to add parallel transaction execution Etc that's fuel right the fuel of M is the evm but improved so if you're looking for the evm of five years from now that is the fuel VM next one uh stateless account attention some other projects give like an entire talks about this one topic but this is just one of the many things you get in fuel so it just gets one side uh fuel supports account of traction but statelessly uh State full account attraction is actually a denial service Vector so be wary if any project that says it has state state full account abstraction we have State lost account abstraction what does it allow you to do well like any account abstraction protocol it allows you to Define conditions under which a transaction is valid not conditions you know not logic of what the transaction will do but actually conditions under which the transaction is valid or not uh you know the most obvious case one thing you could do is use a different signature scheme I uh you know use snore signatures if you want to and this is actually what enables us to use any wallet whatsoever for fuel right obviously you know we're building a native wallet that has all the bells and whistles uh you know things like transaction simulation you know and uh a mode where you can like log into pretend to be in any public key or any address Etc but you know maybe if someone doesn't want to install a new attention because they use Solana right and they have assign a lot or they use ethereum they have metamask right you can use any of these things enzyme transaction on fuel because of a kind of traction that allows you to define the validity conditions that are basically well whatever signed message whatever log you want will do it checks out for validity and users are the ones that Define the spending conditions the validity conditions of this not the protocol not those anyone in the world can go in and just Define some new condition and you know it'll work with a new blockchain just like that no protocol change is required required no governance required just as a user you just write it and you're done uh we all know that transferring tokens are a really painful thing right there's like super extremely actually for real this time safe transfer from right uh needed because there's so many there's so many vulnerabilities and something as simple as just transferring a token properly uh fuel supports multiple multiple assets multiple assets natively so every token is a native asset uh so you have like a die as a native asset you could have used to see as a native asset you could have well either obviously is a native asset uh and this these native assets can be pushed with contract calls which means you don't need the notion of token approvals you can push them their first class citizens just like how in ethereum you can push ether with a contract call Noah token approvals so not only are you getting better security from not needing you know some sort of safe it's not transfer from function transfer from function we also don't need token approvals and this is actually a really big thing for users not developers because as users you know that token approvals are a really big ux pain point right it's due to approve the exact amount you want to spend if you do then you have to always add a second transaction every time before you interact with the protocol it's more expensive it's slower it's worse ux if you do internet approvals now the protocol has a bug they can train all your tokens all the time I mean whatever whatever you infinite approved right with us normally for NATO approvals I have no need for token approvals because you just push the native asset that way next is NATO state math because then you show them on the right track uh there's no need for a safe math Library there's no need for some runtime overhead or like add extra byte code to check for Save math the virtual machine itself support safe math natively by default which means you get overflow protection for free uh cross call shared memory uh again this isn't like all these things are either eips directly or like variations or inspired by EVS if you guys have heard of transient storage right transient storage is storage that persists across contract calls within a single transaction that's what this is right it's some piece of memory that is accessible across contract calls uh the fuel virtual machine all contract call frames share this Dynamic which allows you to do things like a completely in-memory re-entrancy card you don't have to set a storage slot for re-entracy card you can do an entirely in memory and in fact this is already implemented in the sway standard Library it was a function to do an in-memory reaction zero so it's not just theoretical it also allows you to pass large data around with contract calls so if you happen to do some data data computation intensive tasks you can do it just by passing a pointer to the data the next one is transaction scripts uh one of the pain points of a proven transfer from in addition to you know which the proves being painful is they have to be done in two transactions you need a transaction first to approve make a complete and then transfer fund and it has to be done in two transactions because an ethereum transaction can only call a contract it can't call two contracts or call two contracts then do some conditions and call a third contract or fourth one depending on the same condition the fuel protocol has transaction scripts which are basically byte code embedded directly in the transaction and that is the entry point for execution not the contract call and the script is by code it can do anything it could call one contract it we call two contract contracts they could do an atomic approve and transfer from obviously for fundable assets like I said before those you know multiple native assets so you don't actually ironically you don't need this for a proven transfer from atomically for Native assets but it will be useful for things like if you have a non-fungible token that does have a proven transfer from then you can use you can do that atomically in a single transaction thanks to transaction Scripts this also allows you to do things like you know add liquidity to a pool or for two different tokens Etc so basically anything that nowadays you would need multiple transactions to do just due to the nature of ethereum only processing a single contract call for transaction you could do it in a single transaction until uh we're getting to the end of the section and last but not least to reduce waste the virtual machine is register based and it uses 64-bit words uh the 64-bit words uh instead of 256 bit words like what the evm has means a lot less waste a loss a lot closer to the metal when it executes because you don't need if you integer math every time you do an addition you can just add two numbers together and this goes really fast uh and combining these things together including being register based means that you're executing a lot fewer instructions to do the same work in addition to just executing faster and that reducing the number of instructions executed to do the same work is very important because gas accounting overhead is a huge portion of the overhead of the virtual machine it's like enormous uh and you want to reduce that overhead as much as possible to squeeze as much throughput as you can on the same physical Hardware so by being registered based you greatly reduce that doesn't really affect like the end user at all because you know you as a user you know there's medium stack based but you don't care those Statics if you're a user or a developer it just is it just works right okay on just Man four and an unmatched developer experience uh standard Library so the language is very minimal a lot of things are moved to the standard Library one example that we'll reuse and subsequent slides is the EC recover right this thing here will recover the public key or the address does an implementation detail from a signature and a message hash right in solidity this is part of the language itself in other words the compiler developers need to go in and add some special magic method into the compiler embed it into the compiler easy recovery right that does not exist in swine this way you compiler and the sway compiler team don't know what EC recovery is this exists in the standard Library which is written the standard library is better in Suite although it's software not embedded into the compiler um here's a QR code I think to link to the implementation of easier government why is this good it's good because it means that the standard Library can move very fast because you don't have to get the compiler developers to do something this is in this way any if any of you can write solidity right you and you can write sway you can just add stuff to this movement submit a PR and just add stuff to the standard Library you don't need to know how a compiler works right you just might swag which is writing the smart contract code uh so it allows the language to move quickly because it's lean and it allows the standard library to move quickly because it doesn't you don't need to know how compiler Works uh to contribute to the standard Library and this basically almost every function that isn't actually like core to the language itself is in the standard library and not in the language itself next uh generics in some types uh generics is the diagonal brackets right so you can Define the type of assign later uh some types are you know either one or the other uh rather kind of like unions uh combine them together and you can get things like a result for instance which we'll talk about on the next slide but generics are very good because they they allow you to reuse code to reuse logic without having to duplicate code right there's a safe math library right versatility but if you want to use safe math for like a un 64 instead of a un256 you just have to like copy all that code and change the type right if you have generics you don't have to do that because you can just make logic generic over any type that supports some functions like say an addition and then you know instantiate instantiated with different types so it allows much easier code reuse without having to well it allows it allows code reviews period uh for things that are the same logic but in different types uh now why do we care about results specifically and why is this important we're going to go back to our example of easy recover on ethereum and solidity the easier recover function will return something special if there's an error can someone yell out what that something special is okay someone someone says zero perfect right so if the signature is invalid then easy recover will return a magic value of zero you know those address zero has you know signed over this message hash with a signature obviously that's not true because you know if you're new with it if you knew the private keys of the address zero the things would be very bad but the easy recover doesn't tell you anything explicitly right there's this magic value and if you don't remember to check this then someone can pretend they're from address zero right and maybe like do a bunch of nasty stuff and in fact just a few months ago a contract forgot to do this and I think about exploited or maybe it wasn't exploited at least it was still there as a bug in code uh with results uh you can actually wrap the return of things so easy to recover in sway which again the standard Library function does not return a value it returns a result over a value and an error right so if the if the signature is invalid is not going to return zero it's going to return an error and if you want to actually get into the value you have to unwrap the result and you have to do this in other words you have to handle that error and the compiler will force you to handle that error explicitly uh you know in solidity that's not the case you have to actually go manually remember to check the zero value and you know there's all the places where this happened so having generic in some types allows us to have results along with all the things and this allows for explicit error handling which means safer code because the compiler tells you you don't have to go and remember yourself okay next one type in front we probably all hate writing types of things especially when those types are long especially relevant when you have generics uh there's a left keyword now an alternative would have been a VAR I guess but you know there's been some bike shedding I think on Twitter I saw a fairly recently on the slack keyword so this one has a left keyword and this allows you to have type in fronts right we use the same type system as rust so you can just you know whatever's on the right it can be inferred uh you have to actually write out very few types and if you look at our standard Library I think sniper inference is used quite a bit throughout it so that would be a good example of how how you don't have to write that many types everywhere and onto okay next one is namespace storage access in solidity uh storage variables and regular variables are all in the same namespace and if you have a storage variable Foo and the local variable Foo and you go like you know Foo dot whatever you know which one are you accessing right likewise what happens if you have two variables that are close in name right you have like you know count and CMT let's say right you can use the wrong one by accident right you intended to increment something in storage but you incremented it only locally or vice versa and sway storage accesses are namespaced with a storage dot keyword which means if you want to access a storage variable you specifically have to write out storage dot this means you can just look at the code typos are not and you can see what parts of the code are actually touching storage versus not right so additional explosiveness and it means additional safety next one is exhaustive pattern matching this one was implemented quite quickly by one information compiler Engineers Emily uh for those of you who aren't familiar with pattern matching it's a match statement right and it allows you to exhaustively enumerate all the possible cases so let's say you're matching in a Boolean the exhaustive cases are true and false right and if you only matched on true the compiler would tell you hey you haven't matched exhaustively uh this means that unlike in solidity where you have to do an if else chain and hey if you forget to check a case and you're in the in your state machine right uh for your contract if you forget to check your case well too bad so sad the compiler tells you nothing right uh with exhaustive magic Expressions well not only is it cleaner because it's all like in a single thing instead of a chain and it's also exhaustive and the compiler will tell you if you missed a case next one is zero cost obstructions uh this is kind of a first class notion in this way language and this way combin binder uh that this little pilot doesn't really do one example of a zero cost attraction there's zero cost things in general it means moving stuff from runtime to compile time wherever possible that's what the ethos is really about one example is well what happens if you could check method payability at compile time instead of at runtime right it's a solidity compiler will actually inject some runtime code into every method that is non-payable right this is a runtime cost it's bad and that's why optimizers will actually just add payable to every public method uh to avoid that runtime cost and just say Okay read the read the documentation right read the docs in the function and then don't send either to this to this method right but you can always do it at a compile time which is what uh display will do right this way from highlight is that you actually check at compile time but someone trying to send some non-zero value of any asset not just ether uh to some non-payable method okay uh and another that's not least I think I'll Zoom through since I have one minute left is reagency reentions exploits are still happening to this day six plus years later after the dial tooling should pick this up but it doesn't that's why compiler will warn you if your contract has some potential reaction to Golden vulnerability because it violates the check effects interaction pattern or other patterns this way to Milo will actually warn you so goodbye other days of re-entracy vulnerabilities because we now have two of them that can warn us about that all right and last but not least on the language side but on the tooling side we have Fork the fuel orchestrator which is the equivalent of Foundry or cargo npm this allows you to do a variety of things including building deploying managing dependencies [Music] thank you so much okay it allows you to build apply manage dependencies in the same way cargo does so no weird git modules this is an Australian formatter test a language server we actually had a language server before uh so if you want to there's a QR code to link to the sway book if you want to learn how to write Sway and dive in a head first this will take you straight there I'm gonna leave that for a few more seconds and then with a few seconds left I would like to close out the slide by thanking not only you guys but each and every one after using 65 contributors in the fuel Labs team that has raw fueled where it is today thank you [Applause] 