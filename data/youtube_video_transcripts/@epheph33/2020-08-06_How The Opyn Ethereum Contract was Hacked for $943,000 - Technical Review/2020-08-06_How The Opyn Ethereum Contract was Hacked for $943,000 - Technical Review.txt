hello my name is scott bigelow and today i'd like to talk about an ethereum attack that happened a couple days ago on august 4th of 2020. an application called open was compromised for nearly four hundred thousand dollars worth of usdc a million dollars worth of usdc was actually at risk but a white hat hacker named samsung got involved and helped steal the funds first in order to return them to their rightful owners this video will be a quick but technical look into what happened under the hood we're going to be exploring ethereum transactions on the blockchain using etherscan we're going to be reading solidity code and browsing github history to see how an application which was audited by a reputable firm such as open zeppelin in this case was able to ship code that had a bug in it and for those of you who turn off a video after 30 seconds the spoiler alert here is going to be that open zeppelin was not actually at fault they reviewed a version of this code that was not what was actually deployed to the blockchain but first let's quickly go over what open is so we can talk more concretely about how this heist was pulled off open describes themselves as a decentralized insurance platform and this is a pretty decent explanation if you come over here to their website open.co this is the frontend ui with a corresponding smart contracts on the ethereum mainnet blockchain that provide the actual uh you know d5 logic that allows users to effectively buy and sell price movement protection to each other and we're not going to be going through a tutorial of how to use the system but very basically the system allows you to deposit usdc into a vault and and when we talk about this vault this is really the open portion of the smart contracts is a system that holds on to your usdc but by depositing this usdc it generates something called an o token this o token represents an option to exchange assets for this underlying usdc so as a insurance provider you deposit it mint the o token you can sell the o token today which gives someone else the future option to come along and exchange that asset for a predetermined price there's many vaults that have different parameters one of the exploited ones was a east put option for 330 usdc per eth these vaults also have an expiration so this o token only gives you the right to that exchange up until this point in time at which point if the o token is not exercised this insurance provider can just withdraw the usdc uh now if the oh token is exercised this insurance provider simply withdraws the eath instead because somebody ended up providing the eath in order to exercise that option so let's go through that workflow real quick if you are somebody who ended up buying one of these o tokens let's say that you wanted that price movement protection you bought one on uniswap you would come along with uh one o token and one each these numbers need to match you would send them both to the vault the vault would look up what its predetermined parameters are for how it should be storing this data and it says okay well thank you for for these two assets i will go ahead and send you 330 usdc there's no oracles involved there's no check to make sure that this is a reasonable time to do it so long as it is before expiration you show up with one side of the assets you get the other one at a fixed price now normally people would not actually execute those options because this is a bad price based on today's prices for one ease to turn into usdc on the open market you could probably get closer to about 390 usdc per eth but the open system doesn't actually check to make sure that the person who has performed this action isn't making a bad decision so this system had been working for you know some months and uh many people were buying and selling these assets and using the system you know pretty functionally until we started hearing some rumblings about an exploit that had occurred and anybody who went and looked at the open contracts noticed that they had been very quickly drained of significant quantities of in this case usdc so there's a um a nice article here by peck shield that came out maybe about a day after the attack occurred this is a pretty good overview of what happened it's very short but very concise and drives at the heart of the issue what this article talks about is what we're going to be talking about in this video so i'll leave a link here if you want to to read a little bit more but let's say this article hadn't come out yet and you're curious about how and how and why the open system was drained of this usdc how might you figure that out well one thing you can do is just go look at the contract itself this here is the open vault no the thing we had a circle around in that previous diagram and one of the things we can do is look at the analytics here so if we look at the usdc holdings of this contract and then look at the analytics we can see that this thing was getting usdc and getting more of it more of it more of it we're talking about you know at this point it has you know over 200 000 dollars worth of usdc and then i can't see that right there but you know basically crashes down to nothing so i might come here and look and see okay well how did that happen how did we go from having so much usdc ah you know stored on this contract to having almost none now this this token holds right here is the the oeth vault contract one of the things i can do is look for patterns in in token movement let's go back a little bit farther okay so here we see a bunch of transactions where um where usdc is moving in right we have like one transaction usdc moves in one transaction you know usdc moves in um then we see over here you know usdc is moving in moving in uh let's now now we're looking at a whole bunch of usdc moving out and remember this is a 330 usdc per eth contract so the fact that lots of usdc is moving out meaning people are exercising these options is very strange because this is not the proper price the the price that these exercised options are getting per eth is not appropriate so let's look at one of these transactions um where where ethan is moving out this one here and what we can see is that there is a whole lot going on in this contract lots of tokens are moving around lots of ether is moving around the contract that's being interacted with is not the open contract itself but it's being called another contract is being called which is making an internal call to it uh if you open this so just opens up a new tab this is an unverified contract so somebody deployed some special logic to the blockchain to interact with this system and uh yeah you can see it's got some some call data that seems pretty okay opaque so something is pretty messed up right here somebody is execute you know executing on these options even though the price doesn't really make sense um now it can be a little difficult to see what's going on just with some flat list of token movements so one of the tools that i like to employ when i am looking into these transactions there's a site called tx.info and i here's the the transaction question i went ahead and uh copied it come over here to this paste it in the transaction hash uh give it a second because it's looking at not just what happened but it's creating a hierarchical list of what is actually happened inside of this transaction so one thing we note is now here's the emitted events this is something you can also get on ether scan here is each individual coin transfer which is fairly interesting but probably one of the most interesting parts here is account balances instead of just looking at all the various transfers this gives you the net effect of this transaction where we can see that uh you know 24 000 usdc has been credited to this is that receiving contract the unverified source one and the usdc has been deducted from this system but it does not have a corresponding increase in ether as you would expect you know when you execute an option you give ether for the usdc this is not uh this has not received that ether so something really unusual happened in this transaction in order to see what happened we see that the uh so this is the the caller right this is the user the eoa this is the contract the contract ended up creating o tokens this is the the transaction that deposits this person's own usdc to create o tokens and then we see that's like you know the system went ahead and transferred the o tokens to the vault what we see here is that they then called in and said okay i would like to exercise and they exercised against two different vaults right a vault is a place where basically usdc is stored and somebody owes some o tokens so they are eligible to have an option executed against them so they called it against two of these vaults um and we can see that they it transferred the usdc the receiver was that e78 contract the one this is the attacker's unsourced verified contract we see that it transferred to it twice but it only accepted the 75 eth to facilitate that transaction once and then at the very end they went ahead and took the eth that they gave themselves originally here it's a little strange because they are creating o tokens here they are executing against themselves and somebody else then at the end they are claiming the eth that became their vaults property because of the first transfer against their vault so why is it that the system only required one submission of 75 eth to claim 75 eth worth of usdc two times that question is really the crux of the bug here and to answer that let's look at the source code for the the o token contract itself though this is the the vault that ends up storing the the usdc uh on behalf of oh token holders so that they could come along with later to exercise that option so we'll go ahead and open this up a little bit more so we can scroll through it a little bit easier all right so this is this 0x951 this is the one that was drained of ustc if you come along and and look through here so it's a fairly long contract it's not terribly complicated a lot of this is flattened erc20 code but there are a few interesting functions in here so the bug as it was called was related to the exercise function so this exercise function allows again remember i said okay i want to exercise this much and i would like to exercise from these faults right these users who had previously deposited usdc in order to create these o tokens to sell i would now like to execute on those options uh so effectively it jumps into a loop here to to iterate through the arguments that you passed it right here see we're iterating through these vaults to exercise from and uh depending on what's going on here it's going to effectively call this exercise internal function so this is the public exercise the the internal one has an underscore here so we're going to go down to this internal underscore exercise right this is the only one that can be called from that public function and there's a lot of things going on here but the the real important part here is right here i'm going to blow this up a little bit since it's better the video because they're using eth directly as value attached to a transaction and not using ether as a token such as wealth there's there's different logic for handling how you receive eth as value so again ether is attached to the transaction itself and so what you need to do is check that the value that was attached to the transaction equals the amount that you were expecting to receive so if it's eth it makes sure the value is attached if it's not eth it goes ahead and transfers the asset so for example if this was if this was switched if the people were depositing eth and you were coming in with usdc when you called this internal underscore exercise function every time you entered this function you would transfer some batch of usdc from yourself to the contract the problem however is that this exercise this underscore exercise internal function is called multiple times in that loop that we saw above and every time it enters this loop the message value hasn't changed right the amount of value that was provided to this transaction remains the same every time you enter this loop and so you basically get to to accomplish all this other logic on this transaction without providing any more eth because the amount of eth that you submitted in that original transaction is the same as you can call this unlimited times and it just makes sure that the amount of value that you are submitting um is the same so you get credit for your eth every time you call this transaction even though you aren't sending more ethe in it keeps checking the exact same value versus if you're using tokens uh every time you entered this transaction this this function you would call this transfer from and each iteration it would take more and more usdc from you which is appropriate so basically there was a bug here where where it's not properly checking when you're exercising multiple options and providing eath it's not ensuring that every time you enter this function you are receiving more and more eath so all the person needs to do is call and exercise with multiple vaults to exercise so that it could uh get credit for the eat that it is receiving that is sent the first time over and over again and just keep cashing out those usdc deposits from other users and when they come to reclaim their eth there isn't enough to pay everybody this system ends up becoming um you know under collateralized based you know versus the uh the assets that it owes everybody that comes in and tries to claim their their corresponding assets uh so yeah that was uh that's kind of the gist of this issue and the other question that i've received a few times is how this has happened despite the fact that this was audited by the very reputable uh open zeppelin uh if you come here and check out develop go to security they're talking about this open zeppelin audit here so open zeppelin they took a look at this thing the bug actually occurs in options contract that is the source code file that had this problem and uh yeah they don't mention this issue they don't mention this and i'd be kind of surprised if open zeppelin missed an issue as critical as just not checking that message value was received twice now they mentioned that the audited commit is this right this is a reference to a specific point in time in the uh get repository for this code so if we go here right i just followed that link here so we're following that exact commit hash that it mentioned come over here to contracts come over here to options contract this code should look pretty familiar let's go ahead and find our functions here here's exercise exercise looking for that function call that we are browsing what we find here is that the exercise function itself you know when we looked over here on on github we saw that it took an argument of there was exercise o tokens and then an array of vaults to exercise from in this case the function signature is just completely different the function signature only has o tokens and the system actually performs completely different if you read some of these comments here they talk about how the cloud was paid out from all repository holders as opposed to naming specific ones um and then the the repository holders like end up withdrawing like proportional as opposed to executing entirely against single vaults so there was a very structural change that happened between the time that the the project handed off their source code to open zeppelin to audit and the code that actually got deployed on chain right this is this is a completely different function that that doesn't really behave the same and the the economics around it are completely different and the bug was was implemented um you know much later almost uh a month later um in in a different commit so the problem with get with the system really is that they requested an audit from a reputable auditing you know company they received an audit that looks like you know it is very uh it's very thoughtful is very in-depth but they kept developing during the time frame that the audit was undergoing and you know open zeppelin isn't going to sit there and and and keep refreshing to make sure that new bugs aren't getting added they end up getting you know a snapshot in time they use that snapshot in time to review the code and see if there's any bugs there and so we when we talk about projects that are audited a lot of times we aren't that concrete about the fact that they were audited and the fact that no changes have gone into the code since a company like open zeppelin signed off on it as uh not having any bugs that that they found after looking at it for for however long so uh i think that the real lesson to learn here is that um projects aren't audited but solidity code is audited and very specifically solidity code at a very specific point in time is audited and a lot of times we kind of confuse it to we say oh you know this project is audited i i think the question really comes down to when and we need to do a better job of creating a system that allows people to know what code actually is and if this code was actually audited or if this code was audited and then we made a bunch of changes that we don't think probably impacted anything so anyway yes that's um this is what i have for you today so again my name is scott bigelow and i'm currently working with the ethereum foundation on a project called spot check that is providing free quick gas and security uh consulting to projects that are nearing mainnet release so if you have or know of projects that could benefit from security or gas auditing go ahead and hit me up here on either on twitter or my email is scott.bigelow at ethereum.org thanks see you next time 