so targeting zero mev in the base layer so i'll start with a quick definition of mev so mev is the profit to be made by reordering and censoring transactions so this is very close to the original flash boys 2.0 paper yeah and deliberately so it does not include block rewards or gas fees or just all the different ways miners can make money it also does not include latency arbitrage and i'll come back to that a bit later so reordering and censoring transactions is data corruption yeah transactions are data and so reordering that data is corruption now you might be thinking i don't see what the problem is here transactions seem fine to me they're atomic um they're validated by thousands of nodes and they're digitally signed you know what's the problem well my point is that data order is as important as data content so imagine for example a picture file so how would that picture look if i took every one of those pixels in the picture and i rearranged them so i kept the same content but i just rearranged the pixels but i might come out with something like this now would you say that that is a corrupt data file i definitely would all right that's corrupt data so i've got some bad news for you which is that each one of those pixels represents a transaction in ethereum so on this side the transactions are ordered by arrival time and on this side they're ordered by inclusion type so the time they're actually included on the ethereum blockchain and what you're looking at here is the genuine corruption caused by the ethereum network which comes from the extraction of mev gas price auctions and mever mev auctions yeah so that's real corruption happening in the ethereum network data was taken a few days ago so what's going on here is that we're selling the right to corrupt transaction data yeah in this way so i suppose the point i'm making is you can't sell the right to corrupt transaction data and then wonder why your con your transaction data is corrupted and you're getting mev so the point here is that mev is equivalent to reordering and censoring transactions it's actually how we defined it and reordering and censoring transactions as i've just shown you is data corruption yeah so these three things here i've done them as a triangle but actually this is more accurate yeah they're equivalent they're actually different names for the same thing yeah and this is only preventable in the base layer this is the layer it's happening in and that's why only a base layer fix will work so in terms of some stats rather than some pretty pictures the average inclusion time on the ethereum network for a transaction is 2 minutes 30 seconds all right that's high that's 12 blocks right that's high and that's so that's um transactions going through the memphis the standard deviation is 20 minutes 20 minutes that's the variance so time order is corrupt in ethereum and that's why latency arbitrage is not possible yeah because latency is a measure of time you can't have time-based arbitrage when your time order looks like this yeah so the upshot of that is that i'm afraid to say all abv is bad all mev is bad because it all comes from the same thing which is setting the right to corrupt data so what we need is some transactional order integrity yeah we need fair order now people ask well what's fair order you know buy what measure fare for who how do we decide well it's actually quite simple turns out it's send time order yeah if alice sent her transaction before bob's it should be included first if bob sent his before alice his should be included first and that's it's uncontroversial so i'm not saying this is easy to do but what i am saying is it's objectively fair objectively fair and that's because it models reality and that's what any transaction processing system is actually trying to do in the end it's trying to audit and log and record what's happening in the real world and that's that's this this is what's happening in the real world so remember mev is the profit to be made by reordering and censoring transactions so if you do this sometime order you don't have any med you don't have any med and that also means we can now measure order integrity yeah we can define it as minimal divergence from send time but as significantly we also want symmetrical divergence from sometimes so for example an example of asymmetry in traditional finance citadel always have zero milliseconds latency pretty much wall street bets traders always have 300 milliseconds plus latency yeah so there's an asymmetry between the different participants so although the transaction order is broadly okay on nasdaq the asymmetry is not so looking from worst to best i've got to tell you i'm sorry to say this but where ethereum is now we're the worst all right we've got high asymmetrical sent time order our transaction order's very corrupt wealthiest best resource benefit uh inclusion time averages two minutes 30 seconds the variance is 20 minutes yes bad so nasdaq is our sort of nearest is a good example of a centralized regulated competitor now they have quite a low error actually but they have an asymmetrical sometime error so their transaction order's broadly okay but the wealthiest and best resource benefit we're just going to leapfrog them we're going to jump over them we're going to get to here ethereum soon the best right low symmetrical send time error transaction order approximates some time all participants treated equally this is the vision for ethereum right this is where we've always wanted to end up this is why we're all in it yeah i would suggest the point is centralized exchanges can't do this because they're centralized the best they can do is arrival time which has these asymmetries we can do better it's my belief that that fair ordering will give us symmetrical send time order so it sounds good right how do we get there so i propose a class of solutions called content layer solutions they could have many implementations but broadly speaking three characteristics so why do we let miners order if it leads to all of these terrible effects well we can't stop them because content is centralized so what we've got here is and if you can see this oh i can move this great what you've got is uh a distributed application layer and a distributed structural layer you know a blockchain but at the moment that it most matters when a block is created the miner has full control full tyrannical control over that they're in god mode they'd pick exactly what transactions they like one computer all right so the solution to this should be no surprise to anybody at this conference it's the way satoshi solved double spending yeah it's how we'll solve mev we decentralize it's not a shock right so many nodes will decide the content of one block and then we get a distributed application layer a distributed content layer and a distributed structural layer so the next big problem we've got to solve is the structure of the mempool or rather the fact that it doesn't have one yeah it's an unstructured mess it's a graveyard for sudden time order we have hundreds and thousands literally hundreds of thousands of transactions sloshing around at any moment and that increased choice of transactions leads directly to increased mev opportunities all right so what can we do what we can do is we can chunk up the mempool at low latency like every one to three seconds and we can do this quickly because there's no need to execute transactions we're just doing simple validation checks we're not updating state we're not creating our testing blocks so the idea is we could what three seconds that's about 70 transactions that anyone's got to exploit per chunk not a hundred thousand plus 70. so less mev so for this to work it's got to be non-optional yeah it's got to be a base layer solution so the content there creates chunks here the validators write the chunks in order to the blockchain or they fail attestation that's it there's no there's no wiggle room and the idea of this is that at that point corrupting transaction order so disrespecting the content there would require the resources to pull off a 51 attack and that's what we're trying to do we're trying to escalate transaction reordering to the same level as it would take to do a blockry also so this is what i've described here is plain alex is the most basic content there that i could imagine yeah so these are the advantages just of this most basic version of it the simplest implementation so looking at mev by type uh this is based on flashbots bundles and my analysis of them it looks to me like we've got 27 of mev is um three flash spots is sandwich attacks 16 is backgrounds all right these are unambiguously exploitative mev types so that's 43 overall so if we have 12 second content chunks this is based on real data that i've extracted and analyzed if we have 12 second content chunks that could result in a 40 reduction in the most exploitative mev okay sandwiching in backgrounds but we're not aiming to do 12 second content chunks we're aiming to do one to three second content chunks so the mev reduction could be greater than that and we're not doing anything really all we're doing is chunking up the mempool we're not enforcing any order we're not encrypting at this point they're just doing something really quite simple so i'm not sure i've got time to go through all of these i will quickly these are some other advantages so you know about the 40 reduction we've got lower user costs we've got better data integrity we've got user experience improvements we've got the remaining mevs more democratized we've got a bandwidth reduction potentially and i'm not even going to go into the last job but it's good right so here's a possible road map all right how do we get this stuff out there how do we get from reducing mev to solving it so i would propose we start with plain alex which is what i've described and we we can implement that relatively quickly you know it's relatively simple that could give us an immediate and significant mev reduction but the fun really starts when you start doing other things with the content layer so for example you can have users encrypting transactions and sending them to the mempool if we're able to chunk transactions every three seconds we could use time lock encryption decrypt them after five seconds get no block delays yeah so what you're doing is you're encrypting transactions while they're while the order is being established in the content there and then you're decrypting them so you get no block delays um and you've got an encrypted mempool essentially so another way of doing it would be threshold encryption uh so other speakers have spoken about this today i quite like this idea actually of a reputation market for key split holders that might be quite a good way to go um thing to bear in mind is if we manage to do this right then mev is actually solved at this point because you cannot exploit transaction order to your benefit because you don't know what's in the transaction so i wouldn't stop there all right uh we can then go on to fair alex we've had dark alex we go on to fair alex yeah let's let's finish the job so it's it actually looks to me as if pickers might the pickers and the the content now i'm proposing map quite closely to equitas replicas now if you can encrypt before you do fair ordering you're in a really nice situation because you don't you've you've mitigated collusion because bad actors are minimally incentivized to order encrypted transactions fairly yeah i mean good actors are going to do it anyway the bad actors are actually minimally incentivized to do the same because it's the least worked for them it's the least overhead just to order by arrival time pop a transaction on a list says pretty big news and at that point mev is solved and we have an objectively fair distributed system for all okay best on the planet and i've written yea here to remind me to say yea yay thank you everybody so just to let you know that um best way to get hold of me if you want to continue this conversation with me if you like the ideas or even if you hate them is probably twitter so at pmc goo and crypto and that most the documentation has been out of date so for example there's a most the documentation about uh the content layer is based on is about random alex which was a random ordered version which i've shelved for now it's actually got some uses but um i'm ruthless like that so i've shelved that particular variant for now okay thank you so much 