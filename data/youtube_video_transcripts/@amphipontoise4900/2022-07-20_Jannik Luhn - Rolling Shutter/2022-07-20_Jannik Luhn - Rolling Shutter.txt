okay hi everyone my name is janik thank you all for coming despite it being very late and also very hot in this room i'm here to talk about rolling shutter it's a front running and mvv protection mechanism roll ups and i want to first start by talking a little bit about mev what it is and if it's bad or not um and we want to do with it and then talk to our solution talk about our solution to to that so what's mav it's an abbreviation that stands for minor or maximal extractable value and it basically means the profit that a block producer can make by optimizing how they build their blocks because we have some options there they can choose which transactions to include and which not to include how to order them and also they have to set some other parameters like that timestamp and the parent block and this can influence and it does influence how much money they make and yeah one more thing about the block producer it's got mine or it used to be called mine extractable value um but in different protocols this entity has a different name so in proof of stake blockchains it's usually the validator and rollups is the sequencer um but in it's basically all the all the same it applies to all these protocols examples for these for example arbitrage these are the most common ones arbitrage means you have two exchanges to taxes they trade the same token but with different prices which means you can buy on the one where the token is cheap and sell it the one where it's expensive and make a risk-free profit anyone can do that but the block producer is basically first in line they can they get the prime spot and that's why it's it's a form of mvv another example is liquidations liquidations are kind of bounties that are paid by d5 protocols in order to yeah to make that protocol work so once a condition is met anyone can call a function and basically they get paid for it and again anyone can call this but the block user is first so again a form of mev next sandwiching now it gets a little bit more complicated we have a um a user transaction and for example this transaction um sells a token which means it influences the price of the token the miner now gets the transaction and they see this with sale transactions so what they can do is they can sell the transaction before that the user transaction and buy it afterwards and basically do arbitrage based on the price change introduced by this transaction yeah that's sandwiching and lastly censorship that's very easy the block reduces simply ignores a transaction because for example they get paid by another entity so now the question is is this good is it bad and it turns out this is actually a pretty uh difficult question to answer and to come up with a clear solution to that but i think for these four examples it's very simple um arbitrage and liquidations i think are generally considered good by most most people because they are tools that um that protocols use so without arbitrage without liquidations many defect protocols including decentralized exchanges wouldn't work so we want to have these protocols so mvv is here useful we want to have it sandwiching and censorship on the other hand are clearly bad so censorship is pretty obvious and sidewishing is bad because um it um so the user who wants to trade something they get a worse price so it basically reduces utility for the users of the protocol so this we don't want so our so what what our solution aims to do now is we want to fight these types of mvv that are clearly bad like censorship and sandwiching but we still want to allow for arbitrage and liquidation to happen and we want this type mmv to be extracted and we want to also have these types of mb extracted in an efficient manner because there's some mvv protection mechanisms that make these uh kinds of arbitrary mvv extraction inefficient and that's bad for everyone because it will be extracted and then but for example simply gas prices [Music] get higher block space is used less efficiently so our solution we in theory can be applied everywhere in most protocols that have some sort of block protection mechanism but we do focus on rollups and the reason for that is that there's many reasons the first one is that we think the majority of mav will be on rollups in the future simply because of the majority of users will be on rollups another reason is that roller protocols are still new and relatively easy to modify so the protocols are not not fixed yet all the roll-up teams are still implementing them um whereas layer 1 protocols they are already established and they're much more conservative with changes they want to introduce so therefore we yeah it's much easier for us to to talk to roll up implementers and try to convince them to to work with us and lastly most roll ups have a single sequencer which makes our protocol much easier to to implement as we will see later so therefore what we decided to do is build this rolling shutter mechanism that i will describe in a second and we build it as kind of a plug-in that can be integrated into almost any roll-up so how does it work basically we allow users to encrypt their transactions um then they send the encrypted transactions to the sequencer the sequencer will select them order them and put them into a batch and only once they have been included in a batch then they will be decrypted and executed now this still means that the sequence has a lot of power the block produces a lot of power they still can order however they like they can still ignore transactions but they don't have a lot of insight into these transactions they don't know what they do because they're encrypted so they can front-run they can sensor but they can't do so effectively so in the end they won't do it and but these other kinds of mv like arbitrage and liquidations that's still perfectly accessible because um they can um they can still order however they like and that's like a little image that illustrates how it would work we produce a batch after the batch is there we produce the key then the next batch and the next key and so on and whenever we have a key we can execute that's the general principle naive way to do that would be to allow the users to choose the key to encrypt and then ask them later to review the key unfortunately that's not a good idea for two reasons first of all it's pretty bad ux users in if they want to only send one transaction they have to send two they have to first encrypt and then later have to provide the decryption key and even more difficult or more dangerous they have the option to not reveal the key and this is uh it gives them basically a free option and that makes it very difficult for for many protocols to to live on on a blockchain like this so we don't want to deal with that therefore our solution here is to have a committee so this committee we call it the keepers they their job is to provide encryption keys and decryption keys so they first provide the encryption key give it to everyone users can now encrypt the transactions and later um once they see that the block producers produce their block only then they will provide the decryption key and this solves this free option problem because the user is not involved anymore for the decryption they can't and they can't choose to not reveal but they also don't have to do it themselves it's a committee we could use a single entity that would be pretty bad because we would have to trust them to do their job properly for this committee we only have to assume that a threshold of them are honest and online so for example two-thirds of them could be 200 nodes so i think this is a good security assumption that's justified they run a dkg protocol the problem with dkg protocols they're pretty um well established but the problem is they usually have a quadratic overhead so they need to um all these members have to talk to each other to produce a key and that's very inefficient especially if you want to have more keepers um and we want to produce these keys very frequently right we want to produce batches like every five to ten seconds so that people don't have to wait for so long for their transactions to be decrypted and executed so this is like this is used a lot this uh communication so we we try to avoid it as much as possible so the solution we came up with together with some researchers from from a university we split this up we split this up in a quadratic setup phase produce a kind of a round or a kind of a master key or we call it the eon key and then for each batch um we only need linear rounds so for each of these rounds each keeper only has to send a single message so this is now maximally efficient and makes our protocol work with lots of with lots of keepers so a very very secure system the transactions they pretty much look like normal ethereum transactions they have a receiver a call data like the function they want to call a gas limit guest price and non a signature and ideally we would encrypt everything but unfortunately that's not not easy to do not and because the block producer who who selects these transactions they need to know that they will be paid so they will need to know that they will get a transaction fee from the users and but if everything is encrypted they can't really verify that they that there's actually a sender that has money so what we do instead is we um have an plaintext envelope so all the fields that are related to gas payments are public and but the important fields like what the transaction does and who is called and who sends money to whom all of this is encrypted now the sequencing step as i said earlier we call that there's still a proper user that orders and can order however they like we call this entity that does what they call later but it will be it's basically the same as the sequencer just a different name because it's two different pieces of software and their job is to produce these patches commit to them including of course the order list of transactions but in addition to that they also commit on the block number and the timestamp um all this context under which a transaction is executed because this can also be in in theory can be used to function so they also finalize that before transactions are decrypted and eventually these transactions are then passed to the sequencer here's how the architecture of our system looked like looks like as i said we want to build a plugin that can be integrated into rollups so what we build here is on the left we build the keepers and the collater it's two pieces of software but then rollouts already have software for the sequencer and they usually have like a state transition logic and the only changes that they now have to make to integrate with us is they have to provide an interface with which our correlator can talk to the sequencer that's pretty pretty simple and they have to adjust the state transition logic to execute our encrypted batches um also not a big change so in theory or also in practice this should not be too difficult so and all the complexity is basically covered in the left part in the software that we provide there are things that can go wrong of course some of them are cryptographically provable some of them are not but we should um oh apparently i don't have too much time anymore so maybe we can talk if you're interested in that it's already pretty uh detailed you can know about this later maybe you can ask a question about it um but there's one more thing i want to mention because that's pretty cool um the special technology that we use it can also be used for other stuff um and one um technology one thing we work on with snapshot together is a um we trying to use it to make voting more secure or more fair so usually in votes um in downwards you all the time see what votes are sent and the people who vote last have more information than the people who vote early and we can prevent this using shutter by encrypting votes and only reveal them when the vote is over so that's pretty cool and excited to see this pretty soon hopefully yeah that's all from me do you have questions yeah i have a question on the last slide is it automatic that you have to reveal what it was after the vote is over or can you keep them forever encrypted so um the people have to reveal are these keepers that i mentioned earlier so it's a committee it's not the users not the people who vote also not the project or whatever who who um who does the vote it's the keepers and only a subset of them is necessary so only like two-thirds of them are necessary so we think that it's uh yeah in practice not possible to to stop a vote from being rebuilt okay so it can't be like you can't say what the results of the votes were without um knowing how how much each person voted um no like you can't you can't decrypt and then like yeah you can't hide it thank you you mentioned something about the keepers sharing the keys among them isn't doesn't it mean that if there's one row keeper then the keys are compromised um no because we have this threshold assumption only we only need two thirds of the keepers so as long as a certain number as long as these are honest they can reconstruct the shared secret similar to secret sharing where you need you don't need information from every member but if some [Music] some are offline you can just ignore them and use the information that others have to to reconstruct the secret okay no questions no more thank you thanks 