great uh hi and welcome everyone thanks for joining um the graph uh workshop uh joining us today is simon and he'll be taking us through building sub graphs on the graph with that i'll hand it over to simon to introduce himself and kick the session off thank you so much emily hello everybody um yeah i'm jumping in here for for wish she she was announced before but um i also did some subgraph development workshop already in person so that's what i will do now kind of just virtually so my name is simone i'm a solutions engineer at action note working on the graph i'm also um one of those being in our discord answering questions and uh yeah so i will have a short presentation that go through the theory about subgraph development um feel free to just interrupt me if you have a question um but i hope i can make it so that we in the end have more time for questions um yeah also drop your questions in the chat so we can so you don't have to interrupt and we cannot go through them later on all right then i would like to start all right so um this talk is about subgraph development on the example of a nft contract um yeah as this is the nft hackathon i think that makes kind of sense um but yeah to start eva baylen the director of the graph foundation once said um yeah if you build a dab for the community but using decentralized com components it's no longer adapt um a little bit the provocative tweet but somehow i think that's the general sentiment in the web three space but let's kind of go through all the what's in there let's unpack unpack this so what is that um basically adapt is just a decentralized application so it is an application that builds upon decentralized components which which we know already um like the blockchain is a decentralized component but to be fair and also a little bit to say like decentralization is very hard um so to really be decentralized it needs a lot of stuff so that's also that i think we might have to build our crowns today but you should the decentralization should remain the overarching goal and good news is um this is possible it is already possible i'll show you in the next slides so here we see this is the initial dep architecture like in the beginning when ethereum was founded they had this already mined to have an architecture like this mainly you have the the users on top that browse the user interface that was um deployed on ipfs completely so it's actually a front-end only thing that directly communicates with the blockchain you already know um writing transactions to the blockchain we do that often buying nfts and all other transactions but also a reading from the blockchain as you see here um [Music] the the decentralized so we have a decent place viewer that's directly interact with the blockchain um but the problem with that architecture is that um the blockchain by itself is actually a variety optimization and incentivized database so reading is slow by meaning on write optimized and incentivized think about if you send a transaction to the blockchain and the whole security of the blockchain by itself that stems from the fact that you pay transaction fees to pay gas for that transaction so that it's written by the miners to the blockchain but the reading from the blockchain like there is no incentivization to do so um you can read you can there are this json rpc interface but it is not optimized at all and also there is no incentivization for any node to provide that interface in the beginning the idea was like that everybody is running its own node at home but um yeah i doubt that a lot of people actually do this um but hopefully this will change anyways um when you directly interact with the um with the json rpc interface and they want to do something like get token ideas by owners or you want to have all token ids from a from an erc 721 contract extracted then you need to write code like this and i am very much in the team of clean code and this is not clean at all i mean this is kind of a forest of awaits and imagine how long that it gets when we have let's say 10 tokens or or 50 tokens where each of these contract calls maybe takes one second to resolve through um through json arps interface so this is not this is not a good option so how can we solve that problem and you can think about the modern dapper or architecture where you have on top by user interface again it's still possible to um to deploy it through ipfs if it's a front and only thing um and then we have the indexing pro to have an indexing protocol like the graph that that interacts with other um with the blockchain data it's not only the ethereum blockchain anymore it can also be the roll-ups like arbitrary optimism cksync and so on so on and also rv for ipfso um this is where you can have the data so with the graph there is actually kind of a read incentivized and optimized um component to the descent to the web free or decentralized app stack that we can use so by using the graph you could write the same thing like with that like we saw before in a very neat graphql query that could look like this and um yeah this is how i like to have my frontend code actually so we talked already about the graph so that's actually where the graph sits in the whole stack and uh and why it is cool so um it's the api for review vibrant decentralized futures or like an indexing protocol for creating networks like ethereum and ipfs like indexing blockchain and smart contract data for making it easily accessible for the front ends um today the graph hosted service with a centralized solution uh at the uh um powers one building queries per day but since june it's already like there's the graph decentralized network deployed so it is there there are 160 um indexers who are in this network who who will who are more than happy to index your subgraphs to have it like in a fully decentralized way yeah that's what this slide um [Music] yeah so so to talk about the bounties i can tell you already like if you use uh existing sub graphs on the network on the decentralized network or if you write the subgraph and you deploy to decentralized network that would be a big plus here for the judging other than that like as i said like we have the graph has two um categories for bounties like the first is the best user for existing subgraphs there are a lot of very interesting ass upgrades already on the network it's um from sora foundation um super air and so on and so forth um i can give you a a list with those subgraphs if you ask me on discord that are interesting and on the on the right hand side it's actually what we took but the what you want to uh have more or see more is like new sub graphs like new subgraph development like there are two prices like 2009 in total and yeah that's actually wrong it's just i think it's one grand prize and one runner up anyways i think it is cool um it makes a lot of sense used to graph anyways for your projects so um even without the bounty but they're also bounty so you use the graph so um now the next step is let me walk through the nft subgraph development so the first question is like what the heck is a subgraph anyways for the subgraph you can think about it is basically it is just a database schema now you define how you want to organize the data for your application um think about uh yeah a typical nft subgraph consists of one table with the nfts in there then you have maybe one table with the with the transfers one table with the users and then you you connect those with relations so it's basically really a database as we know then there is a a mapping means this kind of some logic that can watch the blockchain for um for transactions like for or for events basically for events or calls or even for every block and then it gets triggered and this mappings then takes the data out from the blockchain and puts it into the database and then of course we have the blockchain ethereum or other evm compatible chains um also near you could try out uh that that can uh yeah that you can write subgroups for them so simple said uh on the blockchain you have all these uh transactions or like the different transactions they are kind of widely mixed regardless which protocol that you are using um and then what the graph does is actually kind of you know sort that take them out and put them in order so you can quickly query the data that you need so on a high level uh the graph looks like this um you have on top you have you have the dab actually that um that you are building with the front then tooling and then um the depth usually kind of send transactions to the blockchain let's say you want to mint an nft then you have a smart contract where you have that nft unit then you send a transaction to that smart contract that actually says hey i want to mint it um the smart contract when you interact with the emit and those events will be consumed by the graph node and then sent to this to the mapping that is deployed as i said part of the subgraph which which then in turn will store it here in the data storage on the left-hand side we see that later on when you want to query create that data and just send queries through that neat graphql api that the graph is providing for you and that will go into the graph node and then directly reads from that store from the database very quick so you are very quick like but brief reading you do not touch the blockchain at all um so that's the whole trick um yeah some tips and tricks so in general you should um emit all information that you want to store in the database as events because that is just best practice about about how to work with those um events or systems like the blockchain is do you have those events and um try to avoid these eve calls if cause is in this in the moment when you have when you have been here data flows in and and you need to ask the blockchain again for more data this makes generally indexing slow so try to event all the data that you that you want to have indexed uh try not to imitate it in uh apf events yes i'm checking the um checking the questions can subgroup listen to events from multiple contracts or cat one can one combine multiple softwares into one mapping good question um yes you can uh like one subgroup can index as much contracts as you want actually um it is uh it just on just in one chain generally and um you can even have like there are even even techniques to start to index new contracts when let's say you have a factory where people kind of can deploy their own erc721 contract out of your um root contract or something like that so that's possible um if you go cross chain then you you have to have to have multiple blockchains like for every chain one one subgraph and then you combine the data in the front end usually okay next question is no the index is um only uh that that only applies to solidity and to the graph if you know by itself um the the the graph actually does not care about that the all data in the graph is indexed so um yeah all right um let me go let me continue yeah then you can create entities for important objects or concepts so for example one one i one trick here is to say um okay i have um yeah i don't know i have i have accounts so you have an entity account or that buys you have an entity account and and that end on that entity you can store the aggregation data like how many uh nfts a certain address has that you can store on that or you can start with um let's say for nft is a good example is the you can have a trade entity and then you can store aggregation on those trades and you can say like which punk has um i know has a hoodie or how many pounds to have a hoodie and you know if you the trade hoodie with i know 10 uh so that's that's a little bit the trick here and try to link this entities together as much as possible so this gives more use to your subgraph like maybe even beyond your current use that other people can build up on your subcraft that's very cool then i want to also uh tell you about these nft standards that there's a working group um that it's worth checking anyways also if you plan to go into the contract development but they also have some resources about them subgraph development and then uh the graphical online that you can use uh it's it's a bit better than the playground that you find on those service or in the studio okay then this this question from muradif that's a bounty does the graph have a native incentive for the blockers to develop new subcraft yes of course um you you could you could apply um yeah now you can apply for uh for a grant at the graph foundation um other than that uh yeah i mean like that there is an incentive let's um on the on the graph decentralized network when you deploy a sub graph as a developer you can also be the first that signals on it by signaling this kind of this correlation that's content correlation and being by being the first one to signal a subgraph you are probably the one that gets the uh the up the most of the query fees so like when that subgraph then receives queries people pay for query fees and that query fee you could um will be disputed amongst the curators and as a developer you can be the very first creator there is also a bonding curve but it's a little bit complex um we can maybe go um yes we can go deeper in that topic maybe later but yeah query fees yes um so then i think also good practice is to check about uh like how many and like to think about your main questions like how many nfts are there in total or which credits do you want to send in general so like what do you want to know about your contracts or your protocol and for nfps so some that came to my mind by writing it's like how many nfcs are there in total how many nfts are there with trade x who owns which nfts or who owned it before is it really the the right one then if available the own chain market prices that said um for open c it's quite complex to know the prices uh they their interface or their smart contracts are closed source so there are some people that try to reverse engineer to get to the data but it's not so easy but if you look at crypto punks and other on-chain marketplaces maybe like sora uh you get you can easily get to that data and then you can have the historic prices or how to price the globe like what's the current asking price what's the current highest bid if you have also the bits um there and other specialities that your nft might have like i don't know if you have some utility or link to whatever so this is kind of keeping in mind by planning your subgroup like okay what what other questions i actually want to answer um yeah and then like the nft schema like roughly we can model it like this so you have a contract it represents the collection it's actually quite similar like that that you see 721 subgroups that are already deployed uh are set up so i have a contract then you have address i have that uh contract with account how many and if these are there you can have a list of owners or you can also have owners count maybe here when you have an account like so people are like oh lack owner you can have current holdings or also aggregation of the holdings then you have an actual nft like token by itself that you have token id you can have that you can store the metadata uri i don't know my discontent i can search it up later but um or time and i will find me um okay event interface is uh yeah then you could then you probably want to have an entity that even made you might might not doing it depends if you want to see like when like when the transfers mean speed ask sales whatsoever like all these events that can happen on [Music] metadata if available maybe trades for available statistics about trades so um yeah this would be now the the demo we can install the dependencies find the contract online create configuration run the graph compiler uh create the subgraph studio this is the example actually uh um with the open zeppelins nft sub graph uh or no general open zip and has like sub graph templates that you can use uh they are very cool and then here i have like prepared live coding how to use it um that said the workshop usually is for one hour and we are like six minutes um i only have six minutes left but let's see um yeah this would be the steps um yes so another thing is token uri um [Music] it's the the thing is uh like the the graph cannot or currently cannot actually follow like arbitrary uris like https or whatever so a very like best practice is to avoid this hp token your eyes try to put metadata on chain there are different examples of people that did it i mean for example if you look at the nfts that uni swap does for example now in v3 they exactly don't like this so this is this very cool um if you have this on chain it's also possible then to actually parse it inside of the graph it's much better otherwise i mean don't forget to make your base unchangeable so if at some point i know your server goes down or whatever it can still change but i would try to put as much as possible on chain um yeah there's also kind of this pattern of bull clothes metadata into the subgraph in the beginning that's also possible yeah there are some some some ideas you can talk about but the token uri actually if the http uri is a bit the problem the ron asked like another question if sorry we fell off like how can we uh handle network issues potentially missing events like it's it is this is like it is solved by the graph actually for you like if you write the subgraph the execution of the top graph is deterministic that means like the sub graph um like there is never a missing event like you you always know if something is missing and the subgraph is trying and trying again to to index and actually get to that data uh if um yeah if you can but maybe you talk about ipfs right so um with as i said like https hp and https cannot be created from inside the graph but what can be queried is ipfs but the availability of data on ipfs is not um it's not guaranteed right so there yes actually maybe this so it could be that when you when you try to download data from ipfs inside your subgraph then this this um these requests are timing out the workaround here is um workaround here is uh to yeah you can try to if you have access to those files you can try to pin them to the graphs ipf ipfs node there are also some repos around that can do this my my discord username i can quickly show you this one yeah okay ron i assume that your uh thing is but yeah as i said like otherwise it index is very deterministically so there's no missed events or no no transaction uh like it happens on this newer faster chains on polygon or binance or whatsoever we saw without problems like this but only few minutes never happens like there's it's not like once an event is around once it isn't i mean it's a yeah it's an immutable data storage yeah okay um yeah live or we can we can save if um yeah i do the live coding you can drop questions here i don't think that i think we can make a little bit longer all right [Music] so how it goes so basically yeah you create a new folder let me go in there and the graph cli i already have installed um check this this is the latest version so you should check for the latest version actually that makes sense if you start from scratch otherwise what we have um this so i use yarns bleeding edge now we install just the open separate dependencies then the graph ts uh and graphs you like so the helper um yeah the other thing here are the ones from zeppelin and graph yes kind of the types and um graphs you like uh yeah you install the cli again into the project if that makes sense um yeah we can in the meantime we can check here like what i do usually i index the hash mask stop cross so i think what we check here is like we first get the address but also like the creator thing so we have address and we have to create just for the start block because we do not we can't set a startup so we don't want to index before the contract actually was rather it just made sense um already i think because it's big enough right so you see it still installing let's see if i can make a comments folder just paste the code so we have it for reference to chase okay more or less at it here uh as [Music] start block yeah it's pre-filled yeah now we can compile the stuff already so i'm making this fast um we are free to ask any questions in the meantime just about to show you how easy it is okay so we have schema all right so so now we have the standard scheme as i said like before there is um the account the contract the token operate transfers events and transactions so we have already kind of this is database keywords you know basic database and also subgraph yml file essentially starting point so uh here's the uh yeah there is the schema first data source again there's the contract address the api the api then is installed uh through the node modules and also all these event headers you can also check those [Music] clients i mean maybe i know but you cannot check that your antennas um yeah this is just just a wrapping this is just not like now here it just imports that code but you can also wrote the copy so just for quick story um yeah yeah i can get some description [Music] and i usually also add the scripts packages and fix this already then usually you run your now takes the api and the schema yes and generates um some typing files for you uh so that helps actually with development so so uh you have kind of this need to uh or to complete in vs code and also for schema and uh yeah the next step is build this build uh it's gonna actually compile it everything is written in assembly script so it's it looks like typescript but it is uh yeah it can be it can be compiled down to laws what wasn't so web assembly and so now we have this thing it's already compiled so we have in the build folder we have this sub graph here um this will be actually then deployed and i think the next step is just go to studio studio i i show you the profile you can support the descent plus network um that works for ethereum and drink by but if you want to develop on other chains uh you can you should still use the most terms for now can connect the wallet to login um yeah okay send a message yeah test so i can see it like serial deploy so i need to authenticate copy this um now it's authenticated and now i can just do your deploy i think yes right you pick a label you can wrap whatever you want maybe it's just like one two three four five whatever i mean i'm not sure what somewhere how important seminary so then we have the queries uri so you receive kind of a preview uri and that's a step before i think this is now already indexing yes all right see it's already indexing let's go to playground or because the feature that's inside some entities or blocks you see that something is going on but also when when we are here we can find some objects of arcade which focus do we have what what's the id the uri then the contract the name id symbol owner id boom and we already have kind of you know this what i said before like this neat interface to to the hash marks so this works because it's it's standard blind contract and um yeah uh and we can use the open sampling uh templates but you can also then like if you look at this uh thing here um yeah here the next steps would be kind of to to really extend so you can just copy paste it over and fix those imports and then start to really work on on it and so on so forth i also have some other resources here so like developer now is very good resources and then another job it's obviously kind of already a legendary guide about uh full stack ethereum development the crypto punks from cherry is a good example um how you can do stuff then as i said the graphics card online that the work that the other works from from now that similar to mine talks and artisco yeah i think that's it mostly um any questions if anyone has any questions um feel free to unmute and ask now otherwise simon is available in the graph discord if you would like to chat to him async about anything regarding the workshop or maybe the project um that you plan to build out this weekend um don't hesitate to reach out to the graph team um in the sponsor discord channel yes go to our yeah come to our channels and talk to us perfect thanks so much simon and thanks everyone for joining um and we will see you in discord thank you so much 