all right hello and welcome everyone to the hyperlane workshop permissionless interoperability with hyperlane uh joining us today is a York Rhodes who will be taking us through this session and with that I'll pass over to York to introduce himself and get the session started hey guys how's it going uh my name is York I'm with the hyperlane protocol I've been working on this for around a year I was kind of born out of last year's eve Denver and just wrapped up last week in Denver we did some talks I'm going to be kind of um yeah summarizing some of the takeaways there and kind of what tools are accessible for you guys to to work with hyperlane during the hackathons for East Global so yeah without further Ado I'll hop into hyperlane so hyperlane's an interoperability protocol and before we begin I kind of just want to share my definition of what interoperability is so to me interoperability is composability amongst apps on different infrastructure so ethereum unlocked this composability of decentralized applications by introducing this generalized execution environment we call the evm and it did so kind of at the expense of performance uh as a consequence of that generalized execution environment it becomes much more difficult to have kind of Highly optimized consensus basically and what we've kind of seen over the past 10 or so years in crypto is applications as they want to optimize for performance or or kind of capturing other forms of Revenue they begin to move away from these generalized execution environments which kind of provide composability by default to maybe like an app chain model or a roll-up model where um the composability story is a bit less clear uh in exchange for basically better performance and in the past maybe a couple years or so the ethereum community has kind of galvanized around the roll-up architecture uh for kind of performance benefits that can be passed on to application users and so this is kind of exciting uh because you know we can no longer we no longer have to have all of the network you know being throttled by like a single nft mint we can you know now have rollups take take on some of the load there and what we're seeing in the ecosystem is applications are beginning to adopt these new architectures so actually uh pretty recently the basically volume of transactions that Roll-Ups which are settling to ethereum our processing has superseded actually ethereum L1 transaction volume which is um you know pretty exciting um we're starting to see applications and really opt into these new architectures and and benefit or have their users benefit from kind of the scaling properties um but along with those new architectures comes a few challenges so um basically interoperability between these different Roll-Ups is a highly fragmented ecosystem and this is because there's kind of all these different types of interoperability between these architectures so the first form that probably most you guys are familiar with of interoperability is what we call like the canonical bridges of these Roll-Ups which are basically on L1 there's a smart contract interface for doing a deposit to a Roll-Up um and then there's an equivalent withdrawal interface to withdraw your asset from from that overload and then separately we have kind of a bunch of these asset bridges that function between Roll-Ups that allow you to move assets uh using smart contracts between between Roll-Ups and so now some examples of this are hop synapse a bunch of these are focused on are across these Protocols are focused on moving assets between roll-ups and the reason that these exist is uh the canonical Bridges which again provide this deposit and withdrawal interface uh tend to be too cumbersome or too slow uh to go through always for a certain application use cases especially in the case of optimistic Roll-Ups you know we have this withdrawal period of I think like seven days so um I think we don't want to impose that latency on an application that wants to kind of do something for its users across rollups and then finally we have these like General message passing between Roll-Ups um and this is kind of emerging uh as a way for smart contracts that exist on different Roll-Ups to have composability whether it's calling each other's Contra functions or doing doing something a little more sophisticated than just moving assets between the roll-ups and there's been kind of a few I guess early attempts in the community to establish some shared standards uh so instead of each role of having you know its own custom bespoke interface that now all application developers need to go in and custom integrate with people are trying to Define standards for this so there's one ERC from uh I think the pool together team that's shown in the bottom left here that's basically just trying to standardize these interfaces around something which is a little more sane and doesn't require application developers to you know have 30 different uh kind of adapters for all these different interoperability protocols um and yeah just to highlight kind of why why are we even doing this in the first place why are we trying to you know introduce interoperability between different chains or different Roll-Ups um different execution environments and the answer is these new types of application architectures can actually unlock Innovation and new new properties for users so just as like a very recent example the a16z research team posted an article they've been doing kind of a deep dive on a bunch a bunch of different auction mechanisms but they implemented a sealed bid auction using Aztec connect which is basically like this L2 that the Aztec team is working on and in doing so they kind of provided privacy to participants in this auction who are settling on L1 but um you know maybe don't want to reveal you know their entire balances for example um so yeah this is just like really exciting once we get interoperability between what I call heterogeneous infrastructure we can really begin to kind of like Leverage a bunch of the Innovation that's happening at the infrastructure layer in in a single application um so right now there's like you know tons of research some tons of r d going into um you know uh basically new new roll-up architectures whether it's for privacy or uh you know performance um it's basically like a majority of the research Community is focused on these problems right now um but there's not really a great like uh interoperability between these different layers because they're all kind of designed uh in uh aren't hearing you at my ends um yeah they're all just kind of designed and different companies that maybe have a specific product in mind that they're going to build on top but haven't really necessarily thought about how those products and those applications are going to compose with applications that are on other chains there's also a lot of people working on like client interoperability which is kind of amongst the research Community like gets louded as like the Holy Grail of interoperability um but there's and this is kind of what the cosmos ecosystem has been you know working towards for the past uh I don't know for five years um in their work on IBC is uh basically having these native light clients for every train that wants to uh be interoperable and so in their in their ecosystem they kind of make a bunch of assumptions about the consensus uh and execution environment that uh chains are are operating and then they're able to do these like client proofs between these chains um but even even with this sort of solution there's a bunch of problems so for one it's quite expensive to operate these like clients because you have to basically be processing every block header on chain and as you scale a number of connections you have between chains you have to do this for every chain you're connected to um and actually in the cosmos ecosystem this is basically like subsidized as a public good for people to operate these things but there's not really a great economic model around how to fund these like clients and the other challenge is uh these implementations of these like clients are quite complicated and require an implementation for every single uh State model and so with all these teams kind of innovating on the VM layer you know we have like all these new VMS coming out fuel Aptos um you know there's there's a ton uh it's probably a new one on Twitter today uh the light client implementation for these new VMS is is probably many years away and and these things don't generalize super well um and and for Roll-Ups especially this is true we basically don't have a good like client solution for Roll-Ups uh because of kind of how Roll-Ups are architected so all that's to say kind of like clients are not a Panacea for interoperability but we do need some generalized protocol for application developers to understand to you know benefit from composability with all these different new infrastructure layers that are kind of spinning up without again like you as a developer having to go through you know 25 different developer docs and say uh you know what does their interface look like um so this is where this idea of modular interoperability comes in um and this is kind of aligned with the the modular blockchain thesis which is basically you know once applications reach a sufficient operating scale like let's say you know osmosis or you know dydx recently is is moving to a cosmos chain one once applications Reach This sufficient scale they want to again they want us to move away from maybe one of these generalized execution environments to something that's much more well optimized to their application and more kind of fine-tuned and so uh we need to maintain the property of these protocols being composable with all the other defy Legos um but we want to move them off you know let's say ethereum L1 and so for developers to to maintain that composability uh we need to separate What's called the transport layer in the application layer so the transport layer is basically how information moves between these chains and the application layer is just basically what is the on-chain Smart contract interface to actually send and receive messages between these different chains and so you guys as DAV developers shouldn't need to understand all these details about the transport layer meaning oh is this a roll-up that's sharing you know a settlement layer with the destination chain you know am I am I sending to uh roll up am I sending to an L1 am I sending to you know a cosmos chain do I need to use a different transport layer like as a developer you shouldn't need to have control flow for all those different cases there should be kind of like an application layer interface for you to pass messages and and basically to send and receive messages to and from any chain irrespective of what the underlying kind of infrastructure and transport layer looks like and so this is where hyperlane comes in hyperlane is what we call a generalized message passing protocol which provides this interface to your smart contracts on basically all of the chains that I've talked about thus far so we're live on like I think around 15 evm networks and we're working on a bunch of implementations of our spec across a bunch of other VMS so we have a few of VM implementation a c-level the implementation which is for Solana we have a cosmos SDK module and basically as uh you know as a customer of hyperlaner as a developer using hyperlane you no longer have to maintain you know an implementation which is specific to optimism or specific to arbitrum or you know specific to one of these Roll-Ups because you have this consistent application layer API um and um you know this is all with the caveat that like okay we we want to abstract away the transport layer from application developers because uh it complicates the implementation work but we simultaneously want to allow those application developers to express their preferences for security so we you know we don't want to just say okay we're gonna oracleize all this information at the transport layer between chains and developers who just trust us um in the spirit of kind of modularity we want to provide a an interface for applications to say hey I know my application architecture the best you know that's why I'm deploying on this specific chain or I'm you know building an application specific roll up Etc I know my application the best I want to design and pick all the trade-offs at every layer of the stack and uh I want to be able to specify what security I require on messages which are coming inbound to my application so you know this can be like a function call from another chain this can be an asset transfer you know you need some way to say okay I have this much confidence that that uh this message which says let's say that it's you know transferring me uh 100 usdc is uh was actually kind of um is verifiable basically according to the source chain and so in the hyperlane protocol we have this again another application layer interface we call The Interchange security module interface and um as a message recipient or again like a an application developer like you guys you can say I want to use this specific security model for this uh for for messages which are inbound to my application and so um you know today are default security model that applications are kind of uh if they're not specifying a interchange security module they're opted into is basically this proof of stake validator set that we have on each chain and if if validators are lying about uh are basically producing signatures that don't match what the the source chain uh kind of says as as what the what messages were sent out from that chain then they can be slashed uh but the the beauty of this kind of modular interface is you can have an interchange security module which is specific to your application um and again you can you don't have to kind of assume some sort of like Omnibus security model like a lot of the existing uh asset Bridges or generalized message passing protocols kind of prescribe so if you guys are familiar with like Wormhole or some of these big asset Bridges you know there's like a centralized validator set and you're basically like trusting that all all the applications that are built on top of something like Wormhole are just trusting that like that validator set will never be compromised um but it is the case that it might make economic sense for that validator set to collude and you know rug your protocol um and that's a pretty unfortunate situation that we're in because we have kind of this like third party uh set of security providers um but with with the kind of like ISM interface that hyperlane provides you can now introduce these application specific security requirements so you could say you know I want the validators who are providing Security on messages inbounds to my application to have some exposure or risk to my application so maybe they also need to be staking your application's protocol token um or maybe you have a multi-sake that you want to ensure has signed off on you know cross-chain governance or something that you're doing um between chains that um again now allows you to kind of Express stronger and more granular security preferences as a as an application developer um yeah so hopefully that makes sense this is kind of like something we're really trying to get people to experiment with and potentially come up with interesting security models which are application specific so you know whether that's like a cross-chain stable coin um we want to introduce security mechanisms which right now we have a couple off the shelf implementations available we have this like proof of stake multi-sig we have um we're working on an optimistic security model that's was kind of pioneered by the The Nomad folks um but yeah uh again just just to summarize kind of you know simple messaging API that exists across all these chains that kind of abstracts away the complexity or like idiosyncrasies of some of these different infrastructure layers and then a way for developers to specify their preferences uh of like what security is happening at the transport layer while still having that configuration interface at the application layer so it's all just you know simple smart contract interface you just set an address you don't have to run or operate any of your own infrastructure um so again there's this is like modular modular interoperability and then finally what um now really makes this uh kind of scale well is we're providing the tools for developers to expand our protocol to whatever infrastructure they want um and this allows developers not to have to lobby for kind of inclusion so let's say you don't you don't have to go you no longer have to go to jump or Wormhole and ask them and Lobby them to to you know bring their bridge to your chain or your roll up um which is you know a quite difficult process and probably is too much risk for them to take on so instead you can deploy hyperlane to any chain you want you can expand it permissionlessly this is what like the title of this Workshop was about permissionless interoperability it's this idea that you can expand this interface it's messaging API to any new VM or any new chain that you want and you don't have to convince anyone to begin providing uh kind of Transport layer relays to that new chain because you can specify your own interchange security module on that new deployment that says Okay I want my application to be on this new chain on day one and I'm gonna get kind of all of the composability from all the existing hyperland deployments inbounds to my new deployment um and so we have like super simple instructions for how to do this on evm chains right now again we're gonna are working on expanding this to a bunch of other VMS and we're also kind of excited to collaborate with uh people who who want to see hyperlane on on new VMS or on new chains but this is something that we'd really love to see people kind of play around with is you know take hyperlane go check out the docs and look at what chains were on um and you know if your application wants to be on some chain that we're not on you know you can go and just like run a couple scripts and deploy the hyperlane protocol to that chain and now introduce uh composability for your application with all these existing Network effects so yeah that's basically one I what I wanted to talk to you about uh uh about today um I'm going to take a look at the chat and see kind of what questions came in what kind of messages we would want to send between chains that are enabled by interoperability yeah great question so this goes back to kind of what I was talking about with what interoperability unlocks so um yeah again uh you know in a in a single VM like single chain monolithic worlds where we just have ethereum you know all the smart contracts that are deployed on ethereum can just atomically call functions on each other and this kind of enabled a bunch of innovation that wasn't possible on bitcoin because now we can do it's like arbitrary execution we have to steering complete environment but the caveat is you don't have to get great scaling properties uh because all of your like verifiability needs to be super generalized um and what we're seeing kind of in the past couple years is people want to push the envelope and get better performance or optimize the infrastructure for a specific product and so they're deploying these app chains they're deploying these roll-ups but they still need to leverage existing Network effects to either bootstrap their growth um or just kind of you know get the same benefits of defy on ethereum and that you can leverage you know other protocols liquidity or other protocols you know assets under management and so this is the type of messages that you would want to send between chains you you know you want to do a function call on a contract that's on another chain or you want to you know send some assets or communicate some uh you know synchronize some State that's maybe across multiple chains if you're you know maybe if you're leveraging assets that are on some other chain or on ethereum L1 for some new application or maybe you're leveraging you know the ethereum name service on your chain um you can do interchange queries so you can like introduce oracles between different chains you can use uniswap two Ops um on your chain for some you know D5 protocol now that's the general idea does hyperlane support substrate uh great question so we're working with a few teams um in the polka dot ecosystem uh we don't have kind of like a substrate SDK implementation but we do have deployments on Moonbeam and I believe uh a star um and yeah we're actually seeing some teams in the wild kind of prefer the hyperlane interface to um to the native substrate solution which is uh this like xcm vertical can you talk on how does hyperline integrate oracles yeah basic um idea is you can um basically sends a message to some chain that you want to oracleize state from and say hey make this view call on this chain and send me back the response so it's basically like a two hop message we have a section in our Docs um I might just hop over there real quick on what we call interchange queries which allows you to basically create an oracle from any chain to any chain by basically doing these cross-chain view calls so that's what this um the stocks page is for um it's kind of a few other uh developer Primitives on top of the messaging API that we talked about which again abstract away some of the complexity here but yeah we'd love to see kind of anyone who's interested in getting these like cross chain oracles to use this API give us feedback um yeah if there's any other questions around that happy to answer hello can you talk about how hyperlink provides swapping tokens from one chain to another like what does it use yeah so it's a good question um so right now we're not uh operating a uh like what you might call an asset Bridge or a liquidity layer uh internally right now um so what we're doing instead is okay we are basically wrapping a bunch of other asset bridges on chains where they're available in the hyperlane messaging API so if you want to basically move usdc with one of these messages to another chain you can do that with the liquidity layer API um and it will you know go talk to the portal protocol to like mint and burn that that asset and then handle your message as it receives the tokens on the destination chain um we are working on um kind of a more native liquidity layer solution but yeah right now we're mostly uh we mostly just have adapters to a bunch of uh third-party asset bridges on chains where they're available but that can also be you know a project that you guys can build on top of hyperlane is basically a more more generalized asset Bridge we also have this like work routes API which kind of generalizes the erc20 standard to cross-chain transfers um definitely check that out as well currently is for liquidity if I'm building a cross-sense web that is like decentralized Excel that provides Crossing swaps is it a good idea to use hyperlink yeah so uh I mean obviously I'm biased but I definitely think so I mean right now our validator set with like the default security that I was describing earlier is um not very decentralized We have basically like a bunch of people uh in our Discord that are operating as validators um but we're working on scaling up the economic security that they're staking and we have a bunch of ideas there around leveraging something like eigenlayer and restaking and kind of bootstrapping more Economic Security but I would say right now if you want to do something um with kind of a lot of uh basically like uh I guess economic risk then you probably want to do the heavier list of like implementing your own uh interchange security module which uh kind of prevents this currently like fairly small validator set from having an incentive to to I guess collude against your applications but yeah if you want to read more about the validators or understand kind of what our what our uh distribution looks like right now definitely like hop in our Discord and happy to to answer further questions around like the security status quo um Shankar I I uh I'm honestly not totally up to speed on what our uh what our substrate integration looks like but I again like would love for you to get in the Discord and um I'll connect you with kind of the the right people there hey York and I don't know if you saw the question from Meyer about uh what's uh warp root mean ah I I'm sorry yeah I missed that so um a word brow is this kind of our take on uh token Bridges um we wanted to like differentiate the language a little bit because we've come up with some like different trade-offs so instead of like you know wrapping and unwrapping your token through some Bridge like Wormhole where you have this like honey pot of every single token that's in Wormhole functioning as like a bounty on the security of those validators instead you can have what we call warp routes which allows you to like introduce fault isolation between these different applications and that's possible through again what I was describing earlier with this like modular security interchange security module configuration or you can have like application specific fault tolerances instead of like having this Global shared security model um and there's a there's a repo you guys can check out if you want to understand a little more about how warp routes work um you can basically clone this repo and launch your own wordbrout um super easily there's also like a a UI template that you guys can basically just like clone and get one of these like all isolated word routes yeah all this is linked on the docs docs.hyperlane.xyz um and yeah please please do follow up with questions and in the Discord um if you guys do end up playing around with anything we talked about here yeah I think that's my time so um yeah thanks so much guys for coming yeah cheers uh thank you uh everybody for joining us today and thanks to our for the great presentation and yeah after any more questions please just pop them into the hyperlands Discord I posted the link a little while ago so yeah cheers everybody have a good day 