foreign [Applause] [Music] we will take a look at how the graph provides critical infrastructure to web3 and you will then learn how you can create your own API that is tailored to your data requirements my name is you can find me on Twitter web free slip chance you can find me in Discord slim chance 16.99 I'm in the eat Global Discord if you need any help with any technical questions and you can also find me upstairs via right by the elevator so drop by our boot if you need any help with your subgraphs so let me first start with the question that everybody asks me why do we need index data the the blockchain is public right but most blockchains are optimized providing data and not for reading it and you can imagine the blockchain as a big Public Library where every day there comes a new truckload of books and they are not sorted in any way they're just added to the end of the shelves and imagine that you go into this library and you want the list of the books with the most the highest word count if you were to do that using a traditional like RPC or just connecting to a blockchain RPC you would need to check every single book note down the word count and then create your list and this is where the graph comes in as it allows you to Index this data beforehand let's take a more practical example a D5 dashboard most of you are familiar with uniswap a decentralized protocol for swapping tokens uh some of you might also know that there's a dashboard called info.uniswap.org where you can get valuable charts and data about the protocol now if you were to retrieve this data directly from an RPC you will need to do and and a call for every single time there's a trade the price would change so you would need to check the device and to get a chart like this you would need to do millions of calls which would be very resource heavy really expensive so that's why we need to pre-process this data it would also take you an enormous amount of time which you would need to process this in the front end so again index data allows you to have a this data in in real time in your application all of the data that you see on info.unishwap.org is provided by the graph so you might think who needs the index data and we found out that that is everyone we are currently seeing over 64 000 subgraphs have been created on the hosted service and over 640 billion queries have been served by the graph so why are people using the graph well you can create a customized API that is tailored to your data requirements this includes which sorted filter and aggregated data and it allows for fully decentralized and serverless applications if you're that relies on a single centralized server it's just an app the graph currently have two Services the hosted service which is a centralized service run by Edge node one of the core developer teams at the graph it supports 38 different networks near polygon B and B and 35 more we are currently moving to the decentralized network where we currently support ethereum mainnet but we believe every death believe deserves decentralized open apis to retrieve their data from the blockchain and we are delivering on that with the current ongoing mips program where we are incentivizing indexes to start indexing other blockchains as well and as I say historic step forward not just for the graph but for the entire web3 ecosystem that relies on us and wants us to provide them truly decentralized open apis and and to dive deeper into why do we need decentralization in in the infrastructure layer well there's no central point of failure you never have to call your back-end engineer at Sunday's Sunday morning saying that your server went down it is naturally load balanced the graph is infinitely scalable and it does so seamlessly it is Geo distributed service we currently have indexes on every continent with over 200 indexes that are currently on the graph Network you will never wake up to an email from your service provider saying that your server went down because your service provider had taken a no no crypto sense and most of all well this this number is a little bit outdated now we now have 220 indexes all competing to deliver the highest quality of service to the lowest possible price and this is why I am excited about the graph and I hope also you guys will be excited to use the graph this weekend and going forward so I'm going to stop there and I'm going to ask if you have any questions about the protocol if not we can move on to the next part I'll dive into the subgolf so it's not incentivized for indexers to split their stake over multiple nodes unless they're also running the service in multiple Geo distributed locations which at that point well let them because they are just also providing better service to the network yeah so let's dive into I've touched a little bit on what the subgraph is it has three major parts the sub graph manifests here you define your network the contacts you want to or the network you want to index the contacts on that Network the start block because when you when you get the blueprint to the indexer they will start indexing the data from a certain softblock it can be from the Genesis block or from any other block that you specify and what events calls or other triggers to listen for on these contracts the subgraph schema is where you define the data structure that you want to query and this is where you want to think ahead and make it as close as possible to the data requirements of your application you would have the data structure the entities relations between the entities and so on then where you will spend the most time as a subgraph developer is in the mapping code how you map data from the events that you have sped specified and to the data structure that you also have specified here and you would also do any kind of transformation aggregation of data will happen in the Manifest or in the mappings but that is written in assembly script which is very similar to typescript if you work with that so let's dive into it let's look at a so this is the graph in the graph you have access to what's called a subgraph studio where you can log in with your metamask I'm already logged in and created a few sub graphs on other workshops if I wanted to create a new one I click create a subgraph I want to create one for mainnet in our case we want to index in this Workshop I will show you how to index the basic contract so they bought a yacht club let's call it Basie Bogota for example so now you have created this in the subgraph studio in the sub cap Studio you can see some important information like it is currently undeployed it is uh having a sub subgroup slug which is the identifier you will use and some of the CLI commands and you also have a deployment key that you use to identify yourself so you only you can deploy changes and upgrades to this subgraph what you would you do is you would first install the graph CLI I've already done it on my machine then we you will initialize your your sub graph how let me let me duplicate my screen so it's easier now a cheat code that I like to use is the index events flag this will create a scaffold code that's indexing all the events that it finds in a certain contract it asks us which network or which protocol type that the contract is on it's sanitarium contract the subgraph slug the directory and then which network set it on and it's on mainnet now the contract address I'll save that maybe I'm not connected to the internet that foreign there you go so now it's creating a subgraph scaffold Force with scaffold code just give it a second oops it's a tough time to download things from the internet here I believe maybe if everybody turns off their phones and their laptops so there we go no we we can add more contracts I just won't know here so now we have a um a subgraph in CD basically Bogota but so here we can see the three files that I talked about earlier you have the subgaff yaml which defines what to to index and in our case we are looking at the base e contract and on mainnet at this address I will add a stop block as well because we don't want to wait around for it to index all the way from the the Genesis block so I'm adding that here we have the schema it is currently pretty sparse it's a simple indexing of all the four events on this contract approval approval for all ownership transfer and transfer and then in the source file you have the the mapping file where you see all of these entities are being stored and this has already been created just by using the index event flag and I recommend using that as a uh as a way to populate your code with some boilerplate events and and and entities now we are ready to deploy we can do graph Cogen yes now if you go to back to the studio you can see that you would also authenticate your laptop first or your computer first I've already done that so I can go all the way ahead and and do graph deploy give it a so now it's uploading all the the subgraph files to ipfs so that indexes can fetch that data and start using the subguard as a blueprint to then transform raw blockchain data into the open API that is a subgraph but in our case we are just deploying to the studio which is a centralized service and it's a a place to stage and test your sub graphs before deploying it to the Visa requires Network so it's deployed let's check it out let's refresh the page let me sub Subway is already fully synced already fully populated with data about every single event that has happened on the basic contract so this is pretty cool but what really we can do with subgraphs is then go back in and add aggregated data say you want to find out okay how many how many board Apes have been traded every month or how um what is the total value of or like what other aggregated data you want to have in in your subgraph you can add that then to the mapping code and then redeploy so for example we can go into the schema and say that we want to Simply like now we have all the transfer events but we don't know when they happen so we could for example have a timestamp and then in the um than to to create that [Music] um to to create the the time stamp uh in the so you can access it from the mapping code you you will run graph code gen again now it's created the types for us so we can access them in the uh in in the mapping code so now I can could go in in on the handle transfer and and save this in entity Dot you see now it's appearing here timestamp oops at event Dot time save so now if I were to redeploy that would that's all that is needed to add that to your subgraph code and and thus you can reiterate and add more functionality to your subgraph is there any questions so far about buying your subgraph you change something in the upgradable contract you have to go and change where the graph is pointing to like which contract is pointing to is that correct yeah so the question here is if you are using upgradable contracts and in this case you can use something that is called like Dynamic data sources which is a way to then like change the or add more data sources while the subgraph is in production and that is used for for example upgradable contracts another use case is Factory contacts like say for example unit swap every time a new pair is created you want to create a new data source which is the new pool and in that case you would also use Dynamic data sources it's also called templates somewhere in the documentation so it's but it's uh it would be templates in the Manifest for example but uh yeah I can give you some documentation after this talk if you want to dive deeper into it [Music] other questions about sub gov so creating a subgraph point that is that is correct and I will show you now how to query sub graphs and I want to show you the content code but I will show you how to how you can create a graphql query and then you can use it depending on like how your content application like what language you're using in the content application you can then use that query so if we go back to the graph.com as I mentioned earlier we have a graph explorer that or we have a decentralized network you can find sub graphs that that is on the decentralized network via the graph Explorer we also have the hostess service which has 30 000 open apis that you can query I will show you how to query one of them so let's for example let's say we want to query the synthetics subgraph for example here you can create a graphql query to test test your query it's not a valid query this is some you can save your queries and and use them let me instead open the endpoint this takes us to a graphql explorer that allows you to create your own graphql queries using a simple like checkbox type of interface so you can for example find like this the synth holders uh order by sent and you say you want to have the first first 10 and I've the internet is with us we can get a query response so there you have the first 10 cent holders order by send and you can yeah with our prices here on the hackerton we have two tracks one is creating a new subgraph so a new open apis as I showed you 10 minutes ago and the auto track is using an existing sub graph in your application and and here you see it is very very easy to create a a query query and the power of using graphql which that you can get exactly what you need so no more than that and no less than that as well you don't need to have this reiteration that you often have to do with SQL where you have to first maybe find the ID of something and then you need to go in go back in and find the fields that you are looking for but here you can get uh get everything in one query so what determines the speed of that the subgroup is index that's a that's a good question it depends uh a lot on on how you write your mapping code so there are some some there are some [Music] patterns that you want to avoid when you're writing the sub card for example you want to avoid doing an excessive amount of eat calls so in a subgraph you can do eight calls at an um at a block and get this the state of a sub the state of the chain at that block and you want to avoid having an excessive amount so you don't want to for example create a loop where you are looping to a lot of entities and for each of them doing a a query to an RPG endpoint so you can do that in in a safeguard but you don't you want to to limit that so each query takes around 100 to 200 milliseconds at a rule of thumb so a few of them doesn't matter but if you are doing a thousand of these and you're doing that every block or every every event every transaction that's going to be costly when it when you are indexing a sub Corp yeah so uh his uh the question was querying a pass block or past range and you can the you can unless you have like deleted a an entity in in the subgraph you can just find it directly here like synth folders will this will also hold all the synth holders uh since this started indexing but there's also a feature called time travel queries that creates this state of a subgraph at an at any block that you specify so say that I want all synth holders at a given block I can get that using time travels create time travel queries so yeah so so here you would have block number and then you would write this for example a block number here so at this state this subgraph started indexing at block 5 million and change so I cannot query block 233 so but any number that I put in that is over this uh 5 million does anyone does everybody see my screen by the way is it yeah so so at that yeah cool yeah so again we need to um differentiate between the decentralized network where you're paying for queries and the hosted service which is completely free you will pay for query costs so so first of all like with the sub graph that we just created we it's currently on the sub graph Studio which is the staging area and that is also free to use once you deploy your subgraph to the mainnet so let me see the the basic Bogota here this is the one I just created this has a development and query URL that you can find here that is completely free to use you can also use the playground to to play around with it but once you want to go into production and use this subguard for the use this API you would go to publish and you would publish on publish it on mainnet and at that point you will also need a API key to create app subgraph and you will pay queries in GRT yeah uh I'm I'm done so yeah we can take that afterwards [Applause] 