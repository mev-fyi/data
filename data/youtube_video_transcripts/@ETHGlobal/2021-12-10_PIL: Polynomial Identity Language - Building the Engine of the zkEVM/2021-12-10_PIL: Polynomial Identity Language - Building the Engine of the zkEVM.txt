[Music] [Applause] [Music] jordi on on stage um and judy's going to be talking about polygon hermes and especially introduction to the polynomial identity language so without further ado let's welcome jordy hello hello everybody thank you very much let me share my presentation right now well first first of all before starting i just want to well welcome to the to the polygon zero people uh it's a luxury to have them on board and uh very excited to to work with them uh we're already as as daniel and brandon already said we have been already working with them in the last in the last weeks and has been very productive and i also want to thank you to the to the polygon funders for setting up this collaborative environment in the technical things i think that we can go much further uh together helping one each other as a team so it's going to be very incredible and [Music] i'm sure that we are going to scale ethereum that then is the goal that we have all together so with that said i'm going to present today the the the pill uh just to understand where the pill fits in the in the in the project uh well um let me just here just a second let's see how okay so uh the the idea of so the most critical thing for uh roll up is generating this proof uh generating this proof is is is quite hard but the idea of this proof is we have an auto state we have many transactions in the case of hermes we have uh normal ethereum transactions we want to one we want to be ebm compatible by code but by code we don't want to compile or just using the compiler we just want to implement the actual bytecode so we have normal ethereum transactions and we want to create a new state route okay so building this uh circuit is this deterministic program or this circuit is the the the challenge so to build this circuit what we what we do is we have uh mainly well we are the approach that we are built that we're following right now is we're building a stark and then in order to reduce the gas cost to uh 300k or even lower it's just to uh verify these start with a a plonk or growth 16 proof okay so this is the the main approach and um the fact of using starks this this is um a little bit uh a game changer between traditional r1cs systems like plonk or glo16 and more polynomial polynomial base this is in comparing with electronics this is uh just working with normal ants and or normal gates and you just put them a lot of them or when you introduce the clock when you introduce a clock in the circuit you can reduce the same electronics and run many cycles so here is where the polynomials takes uh very importance you when you read the word polynomial just understand it as an array of values a piano polynomial is a set of values a line you can represent a line by two numbers well you can represent an a a big polynomial with many numbers so you understand the values and this works well in this concept of uh clock of a step so you have a state machine and every time in the state machine you have a new value and this is represented by a polynomial with in each step one one value and so on so and uh and and the idea of defining the of defining this proverb is that we need to define we need to commit to a set of polynomials and then defining a set of relationships identities uh between these polynomials in order in order to build these stained machines that work together and here is where the polynomial um identity language is language that we created for creating these special these relationships between polynomials and building these state machines okay uh what with this relationship with this uh set of relationships with this compiler this will be used for generating the starks uh for generating the the the prover of the stark and then the very fire of the star okay so to start i think the best way to understand how this porno identity language is just work uh just do an example of how this works okay let's start with what would be the hello world of this language in this case is we are defining a very simple state machine that actually computes 32 bit numbers through uh from uh two numbers of 16 bit numbers so it's a state machine that has two steps okay so it's just even steps and odd steps in even a step we just get a number and put it in a register and in the second step we just shift the register and add the second number and then we and then we start over again so we can generate as many uh 32-bit numbers as we would so we have one register in this case is one state variable this case is out and we have one input that it's a value that we can put at any state we can put the value that you want we can put new each value and every two steps we are generating one new 32 bit numbers so hope we would be write that in pill okay i was this would be as simple as that we have a constant polynomial it's a constant polynomial that's so the first is the first number is one the second zero one zero one zero one zero this is it's the instruction what it's doing okay we have the fringe the input of the system the number that we freely can set to any number that we want and we have the register itself the register out okay so in this and and then we start defining the constraints to these polynomials the first constraint is that we are forcing that freeing is a third it's it's a 16 bits numbers okay in this case we are doing it's included in another constant number that we have defined here in the on top that includes all the numbers between zero and ffff so all done all the 16 bit numbers okay so with this we guarantee that the freeing can be any number but just between zero and uh zero x fss okay and then we define the the constraint uh for this sustained machine actually we're saying that the next step must be um if it's if set is one if it's so it's the first step then this is going to be one the second part this is gonna be zero so the first if it's one we are just putting the input to the uh to the to the register okay if a set is zero so it's the second step then this is going to be zero but this second one is going to be one and then what we are doing is we are shifting the out and adding the freeing so every two steps we are generating a number that we know for sure that's going to be maximum 32 bits number okay so we define it this this this way okay let's move to a more complex state machine in this case we are going to define state machines that generates groups of five numbers of 32 bytes numbers that fulfills this relationship a times b plus c must be d to 2 to the 32 plus e okay so we are dividing this more significant bit and less significant we are doing arithmetic operation this case is a multiplication and a division okay so how we do that okay we have a state machine with five registers a b c d and e and uh the idea is that uh in in the in the in the five first steps we are just latching we are setting uh we are setting we are putting the the input we are setting these registers we are setting a we are setting b we are setting c we are settings d and when setting e and once we have other registers set then we force the condition okay when we have to force the condition where we have this second this this this this next polynomial we call it latch that's actually when you want to force that this condition fulfill so we have a state machine where you just uh load uh five numbers and then you you you are forcing that these phase numbers are uh fulfills this uh condition so how would we write that well we will write this we have this constant polynomial set i said this at cncdncd we have also the the latch polynomial okay and we have also the frame it's the input and then we have the five registers okay and how and here we start adding the the constraints the first constraints is we say frame must be a 32 bits number here we here is the first thing that it's important we are using the results of the other state machine the bytes4. so this this frame must be a number that must be included in the bike so for in o that means that this number must be a 32-bit numbers because we have the conditions that we generated in the last state machine okay then we do the next uh then we calculate the next stage machine in case it's the a prime b prime c prime and d prime and this is if set a is one then we just uh set the free into a and if it's zero we just keep the last value okay so this is the conditions for the next a b c and d okay and finally when latch is one we must fulfill that move soon is zero and mulsum is like an intermediate polynomial that we say that a times b plus c minus d to the 32 plus c is and this must be zero in order to fulfill this this operation when latch is one so here we just define it a same machine where we can do arithmetic operations in this case is this addition plus so here you can do a an addition just for example setting b to zero or you can do a subtraction by setting a and b we'll see in the next in the next example how we how we use this arithmetic uh circuit so let's now build something more complex okay let's build a computer let's build a state machine that actually uh execute instructions okay so here we have uh five uh state have five registers okay we also have a six uh register we call it the program counter actually is the line that i'm executing this is another register that this is in this state machine we have a bunch of polynomials that are the that in somehow they are the instruction that i want to execute okay we'll see these polynomials how this works but this is the instruction okay we have also a frame okay and with this we have a state machine to go from um a to a prime is the next state of a and we are evolving we are executing we can put any instruction that's defined by all these uh bits that that compose the instruction and we are executing this okay so let's see different instructions how this would work okay well first the definition would be just we define all these uh all these uh polynomials okay the same way that we saw before okay we defined here a set of um so for this this instructions must fulfill some initial conditions for example we want that in a binary so we say that in a times in a minus one must be zero here the only condition for this to happen is that in a is either zero or one okay we want free in to be also 32 bits numbers we have in uh we want also the constant to be also 32 bit numbers but in this case we are at um an offset just so that costs can be also positive and negative 32-bit numbers but big numbers okay and then we have the address that's just uh 16 bit numbers it's the by two the one the first one that we we had okay so let's do let's start with uh instructions that move from a to b or from b to a or something like that okay for this there is part of the instruction that's it's a in a in b in c in d and in a here we have these are selectors of which register we want to we have this intermediary register we call it top okay so the data is we will load uh from a b c d and e and we load to up okay this is the first line of the polynomial in the language so if in a is one then we load a if the name is if if in b is one then we'll load b okay we add them together we can also set the cons uh we can also put a constant value so the instruction can have a constant value for example if we want to put an 7 in register a then cons would be good would be value seven okay and we also can select the the the the the freeing okay and we set we have this set values to a b c and d so for example if i want to move from b to c then in b would be one the other scenes would be zero the bonds would be zero okay and the set c would be one and the set a set b said d and c would be zero okay so in this case with this will fulfill this relationship if i want to put a 7 in d then cons would be 7 all in a indian c d and in 3 would be 0 and the set d would be 1 and the other sets would be 0. okay and this is how we define and build these instructions so the instructions for moving okay we can also do uh conditional jumps jumps and conditional jumps in this case is we have a circuit we are i'm not going to enter in detail how this works but we have a circuit that determines if the operator is zero or not okay and if it's zero and the instruction is a jump okay then instead of loading the program counter to the program counter plus one we just load a new address so we do a conditional jump in here just by defining how so for seeing how by changing how by defining how we set uh which condition must uh the program then the next problem counter mass mass must fit okay so we have also so we have conditional jumps and we want to do also arithmetic operations we can do we want to do multiplications additions and so on and and how we do that okay and this is probably the most important um slide of my presentation okay because this is the the trick and the main thing that we are doing here okay so we here is we are connecting the last state machine the state machine that do operations and with the main state machine when the main state machine we have the the instruction arithmetic when we have when we force we have this arithmetic instruction then we are saying that the the values in a b c d and of the operator must be included in the last state machine arithmetic a arithmetically animated cn so somehow what we are doing is we are connecting um we also we are saying in the main in the main state machine we are assuming that uh summary mating function is okay okay so we can set up freely we can put the values in the registers and we are saying okay this condition must be filled and we assume that this is okay but this is because this is delegated the verification of this is delegated to the other state machine okay and this concept of connecting uh different state machines with the block up again thank you to the aztec people with the block up idea this is a great thing this allows us to connect these sustained machines and this is what allows us to do engineering we can generate like many state machines that are doing different things and connect them all together okay so um yeah this would be of course no we have a processor so we have a processor then we need to define an assembly this is a little bit how we would work the the assembly okay we define this from going from one register to other and we have the arithmetic or the jumps operations so this is an assembly but there is something that's uh missing here and it's how we warranty because who we guarantee that we are executing the right program we we we want to have like a rom we have one to have a program and we want to force that we're executing a program because if we see here um this is this these are free inputs you can put any instruction that you want this is okay it will fulfill these uh relationships but how can i create a rom and execute this program okay but let's move forward and we create this uh from this assembly we create this uh we create this uh uh table so we we encode these instructions with with bits we have in a b in and d and we create what we call it a rom a room at the end is another polynomial where the first instruction the second instruction the third instruction and we encode the all these polynomials somehow this is a minimum numbers we have the constant the constant value which is wider than address and we also embed the line with the line of the the line of the program this is the first line but the line zero line one line two like three left four and five okay so we have a set of values and with this we have a polynomial okay we have a polynomial it's wrong okay and we want to guarantee that we are executing this drum and how we do that with again with a single block up we are taking all the polynomials that compose the instruction the address the set a set this jumps arithmetic all the instruction all together we pack the same way that we did it in the rom instead of having the line in this case we have the program counter it's the problem counter indicates which line should be attributed and then we just force in the last is that in strace is included in the rom with this condition we guarantee that we are executing actually uh uh a rom okay so with this we can have a rom that executed that our rom so we have a processor with a rom that's executing on all that define it with a polynomial identities with this with this language okay of course um the evm for building the avm the state machine is similar to this but with much more complex we have of course instead of working with 32 bits operations we're having 256 operations we need to deal with the gas we need to deal with the maximum we need to deal with the stacks we need to deal with the calls so there are some extras because we are tailor-mading this uh uh build so this this processor in order to execute of course ethereum of code so this is why we are adding these these um you know fine-tuning things that will help us to implement the dope codes but they are the same of course will be many other state machines like you know cacaos signature verifications uh comparators there is a lot of it's a lot of a lot of uh state machines but with this we will create the the full uh ethereum virtual machine so to summarize is we have this spin language this is like the hardware layer you know it's we are defining these state machines that work together we have uh uh with this we define the the the state machine we have an assembly okay and with the assembly we create a rom which actually has a specific program and it's a program that actually implements ethereum it's actually it's a program that process as an input process many transactions and uh actually and calculates the new state actually it's a a single process that executes all these okay we have an executor that actually is the the runtime that the thing that takes up the transactions and actually creates these uh polynomials and then uh with this we generate the star this is better represented in this next slide okay so we have the executor executor generates a proof of course here we have an uh an assembly we have a rom we compile that to an assembly to uh no and this we we plug it to the executor that you could generate to start okay with the pill language we generate the we compose the stark end up with the pin language through circum and all the all the uh the start which generate a circuit to validate the stark and then this is then at the end is verified in solidity so this is the the process is very much uh is very much this of course the prover is not the only the proven is not the only thing that we have to implement the prover is just a piece for running a fully kbn there is also a note with all the you know transaction pools and so on and of course all the smart contracts layer one layer two here uh if you want to see how we are going to do all the transfers layer one two year two we have a uh i did a presentation in liscon so you can find it in youtube you can find there and of course we also have uh this uh coordinator selector we have a new protocol we have we will now improve efficiency probably have some opportunity to explain how it works but this is also what gives the centralization but all this piece is what we are building somehow in inner mess and the planning for hermes of course this is not a full commitment this is the project we are doing is quite challenging but this is the the this is the the schedule that we are managing internally we are very excited right now we are running very fast we have an incredible team right now that's very motivating for doing this i think we have at least in my eyes we have the best team in the world for creating that uh we are very i i i'm sure that we are gonna get it we are very really very very very excited and yeah um looking forward and uh hope to skeleton very soon i don't know if there is any questions but that's all on my side thanks so much um there's a couple of common recurring themes in the questions which is uh people want to know how they can learn this on their own pace uh because there's a lot that happen in this talk and uh people are curious if they can find out whether it's the copy of your presentation to other links to understanding where you've talked about pio i will make it copy and everything we're doing is open source so sometimes we're not publishing right now because we are changing very much and it's things like that but we will open very soon as as the pieces get more consolidated and uh yeah you can check out uh polygon hermes repo and there is a lot of information there awesome [Music] [Applause] [Music] you 