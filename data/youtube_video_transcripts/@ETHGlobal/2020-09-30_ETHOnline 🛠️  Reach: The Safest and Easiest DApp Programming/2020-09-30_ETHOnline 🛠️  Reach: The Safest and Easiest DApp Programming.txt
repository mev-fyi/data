cool um jay if you're ready to get started um we're good to go awesome uh well uh nice to see you all everyone um it's uh great to be part of this uh worldwide east global hackathon event and i'm excited to show you today about the reach programming language um by way of a little bit of introduction my name is jay mccarthy uh i'm a research professor um at a university in massachusetts and the uh cto and co-founder of reach um and what i'd like to do for you today is give you a bit of a walk through on what reaches and what it can do um over here on the screen chair on the left hand side you'll see a terminal um and i'll be you know typing in some code and stuff there but for now let's look over on this other side for a moment where we have uh just some quick slides i want to point out um if you would like you can go to the um the discord channel on the ethereum hackers server called sponsorreach and you can also go to our community discord which is discord.reach.sh and um we will be doing prizes for people who use uh reach in the hackathon i'll remind you of this later um now if you would like to go and follow along with some of the stuff that i'm doing today then you can go to our documentation which is at docs.reach.sh and you'll get this page right here so i'm going to be talking about things that are mainly in the overview and then a little bit in our tutorial like i said if you want to follow around you can open up the overview and you can also install there's multiple places where you can find installation instructions on the docs but i'm going to look at this one right here in the tutorial and i'm going to copy this line over here into mic so i'm going to go and make a directory called reach go into it copy this to download reach and i'm going to run a reach.version to see which version i have and then make sure that i have the compiler set up by writing reach compile help and reach is a completely dockerized application so you don't need to really download anything other than you have docker installed and you have this little shell script that manages interacting with the docker containers that we've made now what i want to do is tell you about what reach is and what it does so i'm going to edit a file that we're going to call index.rs h right of reachprogram now reach is a dap programming language now when we say that programming language we don't just mean a smart contract programming language like solidity um or the other variants of um you know languages like study that you know add uh more type features or make a higher level language or a different syntax because when you write a um when you write a program uh in a smart smart contract programming language one of the main things that you're doing is you're thinking about what is my smart contract what is the state of the smart contract and what are the valid transitions between one state to and the other state and what other smart contract programming languages do is they basically give you tools to help manage your thought process of understanding um what kind of state machine you want to build and what um which which transitions are allowed now from our perspective that reach we think that this is not the way that most people um are inclined to think about the kinds of interactions that they want to enable um in a decentralized application and so instead what reach does is it takes the perspective that when you're writing a decentralized application you want to think about all the different participants to that interaction and then say what actions they are allowed to take and when you say what actions they're allowed to take we can then figure out behind the scenes what the state of the computation should be and which transitions are allowed so what i'm going to do now is give you a little example of this now if you're following along and you download and open your own index.rs h file it's probably not going to be marked as syntax highlighted but reach is a subset of javascript so you can just mark it as being javascript in whatever code editor you use and you should be fine now because we're a subset of javascript we have a little tag at the beginning to indicate that you intend this file to be parsed as a reach program so we put at the top of reach and then the version number and what we're going to do is we're going to define an export so like i said we're writing it's just like writing a javascript program so we're going to define a constant mean and this is going to be our reach application now a reach application um we're going to define a few different pieces of it so we're going to find um some compile-time options which for us will be not relevant we're going to write down a list of the participants so the participants and also we're going to then write function and this function is going to perform the computation of the decentralized application so for now let's make it so that there's no participants and it doesn't do anything this right here is a sort of trivial reach program that just shows the pieces of what reach uh whatever each program does now i don't want this uh walkthrough to be only about like the syntax of what you type in when you write a reach program we want to think about like the larger idea about what a decentralized application is so let's make a really really simple decentralized application in this one what we're going to do is we're going to have two participants and these participants we're just going to choose the name the colloquial names and we're going to choose the other name bob these are kind of like classic names that are used and when you're writing um like a cryptographic protocol and you're talking about you know like a online interaction to sort of be the anonymous people now um what alice and bob are going to do in our little program is is that alice will ask bob for some funds then bob will send the funds and alice will uh you know take them so this is a really simple interaction that's not really a useful decentralized application i mean i'm just kind of giving the idea about what what reach is doing um and uh we'll kind of have behind the scenes of this that um you know when alice takes them she'll share something she'll share some information some information now like i said you know we want to focus on like the the really simple ideas so i don't want to you know have the tutorial be you know making a crowdfunding campaign or something like that because i don't want to get lost in the weeds i want to talk about kind of the big picture now in a reach program inside of this function which again you know we write like a javascript function what we do is we we write down what each uh participant does so how do we do that so first of all because we said that there are two participants alice and bob this function that defines the behavior of our decentralized application is going to take two arguments we'll call them what we can call them alice and bob and what these two things do is they represent that participant and we're going to write down what actions they take so for example we can write down the action that alice is going to publish something now reach we use the terminology a publication to mean that one participant sends information out to the wide world because remember on um the blockchain like ethereum all uh transactions are public and since all transactions are public that means that the actions that individual participants take are we call them publishing events now if alice wants to ask bob for some funds that means that she has to ask for a specific amount of funds so we're going to write down here the amount that she requests now if we were to run this program let's stop for a moment and see what happens when we run it i'm going to save go back to the command line i'm going to type reach compile and it's going to give me an error it's going to give me an hour because we didn't say what amount is so we'll see what it says it says on line 12 it's an unbound identifier amount did you mean these other things that are you know built-in functions [Music] so the thing is is that you know of course this program doesn't contain anywhere what the amount is so what we'll do is we'll say that to figure out what the amount is alice is going to take an action totally on her own so we're going to write alice only and then we're going to pass in a thunk which is a function that you know takes no arguments this is kind of like a normal programming idea and so here's kind of the first look at one of the big ideas in reach so in reach the entire program which is you know in between these braces right here is every action that every participant is going to take and some of those actions involve other participants like for instance when alice makes this publication that means that on the other side bob is going to learn what she published but there are some things that alice can take entirely on her own for instance she can learn she can decide what amount she wants to do it so we could write down something like she has the amount of you know 42 or something like that but of course this is not really how uh you know a good application would be designed because we don't want to hard code in exactly what it is because we don't make a decentralized application that can only deal with you know 42 units of currency instead what we want to do is make it so that every time we run this we can have a different thing now in a normal programming language where you weren't programming an entire decentralized application we might do something like add an argument to this function that would take in what the amount is but the thing is is that with reach programs don't specify like one function they instead specify an entire computation regarding many different participants now the way that we're going to do this is that these little objects right here that we pass when we define the participants is what we call a participant interaction interface and what a participant interaction interface is is it is the interface between the backend code that reach is going to generate and a front end that you would write in javascript or go or something like that that would provide the actual user interface for your um for your application so we're going to write down that there's going to be something in this interaction interface that we're going to call her request and her request we're gonna when we specify this object we're gonna say what type it is we're gonna say that it is an unsigned integer 256. because that's kind of the standard uh type that we have uh on ethereum now here we can say then we can say interact interact dot request so what this does is it says that the amount is going to be whatever is in this interaction interface and we want the request key now we can go try to run this we can see we can run reach compile and see what it says so it says that this is an invalid binding because secret identifiers have to be prefixed with underscore did you mean to declassify this this is the first this is the kind of the next big idea of a reach program that in reach programs there are two kinds of information there's information that is secret to only one participant and there's information that has been published and it's very dangerous to accidentally share things that you intend to keep secret so what reach does is it mandates that you essentially click a little box that says i confirm that i really want to share this the way that we do that is that we write we call a function called declassify and what declassified does is it says this value is now allowed to be shared with the world and so now when we run this program whoops now when we run this program uh it'll work well i mean it'll go to the next thing but it won't if uh the program isn't finished yet um and so now it's gonna say that uh you know you can't do exit right now so we've we've successfully read request we've bound it to the variable amount and then we've published that now the next part of the program sorry the next thing that goes on in a reach program is that any time you write a publication like this the perspective of the reach program switches to what is happening in the consensus network again going back to the model of what a reach program does how the way you want to think about a reach program is that you have each of the participants and what actions they want to take and every time one of them does some action that is shared with the entire world we then take the perspective of the world and we say well what should be true about that publication so for instance we could do something like we could write down that we are going to require that this amount be less than 100 and i don't know why we think you know we're just sort of spitballing you know what i mean uh and so here we can write down uh constraints on what things could be published and then when we're done writing down all of those constraints we're gonna commit to this being what happens in the program now at this point we have committed and the perspective goes back to all of the participants and we write down things for instance that bob does or alice does and so on now i want to just you know pause one moment and see what happens when we run this program when we compile it when we compile this program it turns out that it says that there is an error there's error that reach tried to prove six theorems about our program but there is one failure this is kind of the next big idea about reach programs and that reach programs automatically take your program sorry the reach compiler automatically takes your program and sends it to a theorem prover and verifies that every requirement in your program is actually satisfied by all runs of your program and so what this means is that this requirement right here may not be true because alice doesn't actually check to make sure that the amount that came back from the interact interface is really less than 100. and so we can write down a check like that by writing assume that the amount is less than one hundred now when we write this what we're saying is we're saying that alice when she plays this uh you know game honestly she always checks to make sure that the amount is less than 100 and any time when we have a publication by someone playing the role as alice we always check to make sure that their amount is less than 100. so behind the scenes what goes on is that this assumption right here is going to get turned into a runtime check on the client side of our reach program and this requirement right here is going to be turned into a runtime check inside of the consensus network contract and notice that reach guarantees that these are always matching with one another there are other kinds of assertions um and verifications that um reach does but i won't talk about those right now we'll talk about them a little bit later okay so now we can do is we can do kind of the other side of the interaction which is what bob does so because we've committed we've now switched and we're back in the perspective where any participant can do something so right down here we'll write down bob dot only and we'll pass a funk and in this thunk what we're going to do is we're going to call interact and we're going to say that alice wants this amount so what we're going to do is we're going to go up to his interaction interface and we're going to say that he hasn't he has an interface function that's called wand and the idea behind this is that bob of course is not always going to send these funds because one of alice asks for too much money you know i mean right now he's only willing to you know buy some information for you know 40 units but you know maybe tomorrow he'll be willing to spend more so what happens is that this interaction interface not only contains values like requests but actually also contains functions so we can write down that there's a function inside here and we'll say that its argument is that it takes in a u into 256 and returns nothing and so now what's going to happen is that when we run this reach program when we compile it that is behind the scenes we're going to generate a javascript backend that will have a call from bob's back end to bob's front end code where we can he can provide this he can do something with this want value and maybe one of the things that they will do is he won't return because he doesn't want to continue with the program but supposing that he does then what bob is going to do is bob is going to pay the amount and then we'll commit the transaction now pay is like is like publish but bob doesn't know anything that the rest of the world needs to find out and because he doesn't know that thing um you know there's nothing for him to publish but what he can do is he can pay funds now when he pays these funds he's not paying them directly to alice instead he's putting them in a basically an escrow account that is associated with a smart contract of course on ethereum that means he transfers money directly to the contract now notice that bob can look at this value amount and he can look at that amount here he can pay it and we can require it there that's because alice published this if alice didn't publish this then it wouldn't work so if i like comment up this line and have her do an empty publish then this program isn't going to work because it's going to say that amount is unbound it's going to say here that this is an undone identifier in line 17 so line 17 is this one right here that this amount isn't bound because publication what it does is it provides that value for the entire world including you know the smart contract perspective so now we run the program and we get another theorem failure in this theorem there's actually four failures but they're different versions of the same one is called the zero balance theorem and what's the zero balance theorem so this is again one of the things that reach provides automatically for you behind the scenes it's going to guarantee that whenever you write um a decentralized application the escrow account never ends with funds inside of it we've all heard about smart contracts being released where there's some error in the program and funds are locked away forever and they can't be you know gotten back well that's exactly what reach is protecting in this instance it guarantees that all paths through your program must always end with the balance being zero and of course what happens here is that once bob pays this amount the escrow account now has those funds in it but then the very next thing that happens is an exit because we haven't finished the program and since it's just an exit that means that there's funds left over and this is illegal it doesn't happen it's not allowed to happen in reach program so it fails to compile this is very similar to how when you program in you know a safe programming language like ocaml or haskell or ml or another version of ml or something like that you are protected against type violations so reach is of course a typed language it's a type variant of javascript essentially but in addition to protecting you against um errors based on data it also protects you against errors based on sort of the economic logic of this pro of your program not only of course the economic logic but also just you know general things like the thing i mentioned before about the um about the way that the assertions work so anyways it protects us against that so now what we need to do is we need to finish the program so let's finish the program by saying that the next thing that happens is that alice is going to we have to figure out what it is that she's going to share so we're going to say that she will share it's going to be called info and she's going to declassify her interact dot info so let's go up and add that to that interaction interface and we'll make a little thing right here that says info and we'll say bytes um i just want to pause for a moment someone asked a question they said so what if the contract what if i want the contract to explicitly keep funds for later use can i address the con the contract itself as a participant so again um one of the perspectives that reach has is that you're making a decentralized application and in between these braces is the entire application there's nothing more so what i what i mean by that is that imagine your program started off like this where alice did something and then bob did something and then you say you want it for later use well that means that something is going to happen down the road where you're where the contract is going to use those funds for something well really whatever happens down the road would really be in this region right here you would add that to your reach program explicitly now maybe one of the things that that would do is it would you know call some foreign contract or there would be a third party you know steve who would come in and steve would do something so this is a very simple program that was just showing the basic ideas um but in general what richa's going to do is it's going to guarantee that all paths through the program will always guarantee that the balance is zero so if you want them to happen in the future to get access to that money that has to be in the reach program okay so what we've done is we've added this info up here uh which we're going to just mark as some some arbitrary bytes and then alice is going to declassify those she's going to publish them and then we will have her commit and then after she commits we'll make it so that bob will only and he'll do he'll call interact.got and he'll see the info and then i think that's all that we need to do so we'll go back and we'll add to bob that he has another function that's called got and this will actually take in the bytes and return nothing and so the idea here is that well alice asks for the amount of money bob sends it alice then can now you know share what she has and then she can publish it and then bob will actually get it so let's run the program and we'll see it compiled oh whoops so the the balance zero thing is still failing because i actually forgot in here to say that we actually need to transfer the money to alice i like did that step of the program where alice comes back and says here's the information that you asked for but i forgot to actually make it so that she gets the money back so what we'll do is we'll say that we're going to transfer the amount to alice now at this point we run the program whoops at this point we run the program and it should work so we compile it checked 12 theorems and there are no problems now something that's really interesting about this is that you know when i first did this i forgot to include this line okay but what if i like made a typo in this line and you know i'm going to do kind of a contrived example what if i accidentally thought that there was more money available and i tried to transfer the amount plus one this program can't possibly work because the contract only has amount so what is reach going to do so what reach is going to do is it's going to prove a different theorem one of those 12 that we mentioned before this is called the balance sufficient theorem and what the balance efficient theorem says is that there's never a transfer that is too big okay what if i you know only transferred some of the money what if i forgot some of it and i'd say that there's we're just gonna transfer the amount minus one we expect it to error and say that there's that balance zero theorem failing which is exactly what happens we get the balanced zero therm theorem failing so as you can see reach is protecting us from a wide variety of errors and at this point we you know have a working reach program well we have part of a working reach program because we can compile it but like what did compiling do and like how do we actually use it so that's what i want to talk about next so because we've just compiled this let me you know exit the editor we have this new directory here called build so what's in build well build has this file right here index.main mjs so let's see what's in see what's in that file so this right here is a javascript backend for our application that was automatically generated for us so here it provides a function named alice which is all the behavior that alice does and we can look inside here and we can i mean if you see through the compiler you can see things that are happening so for example there's going to be in here a little call that says i'm going to check to see that variable 2 is less than 100. see variable 2 is less than 100 and then there's going to be an assertion that says that variable 7 must be true and notice that it says that this is at line 19. so let's look at what was on line 18 or yeah was it 1 18 that's 16 yes so that's this line right here that checks that amount is less than 100. so each part of this program that we wrote got turned into a piece of that javascript program also embedded inside of there were calls to this function that's called send receive and what send receive does is it actually um sends out a a message on the blockchain waits for the result and so on so all of the details of actually interacting with ethereum are totally abstracted from this program so what i want to do now is you know show how to actually use this and the way that we're going to do this is we're going to go and we're going to make another thing that's going to be index.mjs so we're going to write a an actual javascript program that's going to actually take this back-end that we just generated and run it in a testing scenario so what we'll do is we're going to import our something that's going to load the standard library this right here is an amazing program it's called anti-rsix so it keeps your wonderful wrists from being used too much and from getting hurt reminds me to stretch a little bit all right now we're back to work so we're going to import the standard library from reach and we're also going to import as what we're going to call the back end that code that we just generated it's in build and it's named index.maine.mjs we're going to write an asynchronous function that is going to have all the behavior of our code and then we're just going to call that function right away this is going to make it so it's convenient so we can have the body of our code you know do all the things that we need we're going to do is we're going to load the standard library what this load thing does right here is when we're connecting to ethereum it's going to look at our environment variables figure out what our local node is make sure that the connection that load is available and then provide uh that to us it's just kind of abstract all of those details you know this works within fiera it works with a local guest instance that you make all of those things what we'll then do is we're going to make i'm going to use a test scenario where i have like a test version of geth if you're not familiar uh geth is the name of the go implementation of ethereum it's a really convenient way to start up a local private ethereum network where you can you know draw funds from it um and uh and like create accounts that just have an arbitrary amount of ethereum it's a very convenient development tool so i can write account alice and this will be calling our standard library new test account standard library and i'm going to call parse currency and i'm going to have her start off with five units of ethereum parse currency is a helper function that takes in you know a normal a normal number and turns that into whatever the currency of the network is so in this case it's going to take five the number five interpret that as ethereum and convert it into whey which is like the micro uh unit of ethereum we're going to make another account for bob standard lib new test account standard lib.parse currency 10 and we'll start him off with 10. he's got more because he's got to pay alice then what we'll do is we will say that there is the contract version of alice which is going to take the alice account and deploy our decentralized application so remember back end right here is what came from the code that the reach compiler automatically generated for us so when we call deploy on that value this is going to take that upload it to ethereum make sure that it's set up and then return a handle to it alice is going to take the job of doing that because she's the first person that does something we're going to make another one for bob and what bob is going to do is he is going to attach to the thing that alice created now this value right here contract alice it like doesn't have like any secret information it just has the address um that the contract is deployed at and some other metadata um to make sure that we have the right instance when bob attaches he's going to look at that and make sure that it actually has the correct byte code that he thinks it has okay so we got our accounts that we made in our test scenario we have our contract versions now we're going to do is we're going to actually like call the program so the way that we're going to call the program is we're going to await on a bunch of promises when you write a reach program you are writing a real javascript program when you're writing the front end like when you're using the reach syntax you know you're using something that's like javascript it has very similar ideas to javascript but there's you know there's there's enough differences but when you're writing this you're really writing a javascript program and it's very useful to be familiar with modern javascript where you have async await you're thinking about promises because you're really writing an asynchronous program right because when we make this test account we've got to go contact the network make the account contact the faucet send things into it and so on when we do this deploying we've got to you know upload that make sure that it's available when we attach we have to make sure that the bytecode is available so all of these are asynchronous actions and of course the program itself is an asynchronous action because we know that behind the scenes it goes off and it sends messages and bob may come back and be asked something so we're going to wait on some promises these promises are generated by the functions that are provided by the by the reach code so we're going to write backend dot alice so remember back end is the reach code that got is the result of the compilation and alice is the name of the participant and we're going to pride her with the standard library her contract and then we're going to provide her with her interaction object this is alice's interaction object and then we're also going to call bob with the standard library the contract bob and then his interaction object okay now what were their interaction objects uh let's remind ourselves i think i'll actually open it the other way that's nicer so up here we can see that the interaction object for alice was that she had a request and the information she wanted to share and bob had the want function and the got function so let's rate these in here so she has to provide a request which is how much she wants and let's say that she wants five units the same amount that bob has more than her and let's say what is her info let's say that she knows the secret that um what's a good secret um we'll say that she knows the secret that if you wear these you can see through evil illusions she just has some arbitrary bytes now bob on the other hand what he needs to do is he needs to provide a want function and this want function is going to take in the amount and it's going to do something what i'm going to do is i'm going to make it so that all it does is just going to print out a message it's going to print out the message console.log that alice is asking me bob for some amount of currency and so we'll write standard lib dot format currency format currency is kind of like the opposite of parse currency parse currency takes in a number and turns it into the underlying unit of the network and what format currency does is it takes an underlying unit of the network and turns into something that users want to see and so she is asking for this amount okay and then he also has the got function and this is the secret and she's gonna say console.log and alice's secret alice's secret is and then he'll print it out and because it's raw bytes that's what this says raw bytes that's not really a string um we have a converter that turns this string into bytes but there's no automatic conversion in the other direction because there's no guarantee that you're getting something that is you know utf-8 encoded all those things so we're going to explicitly call a function that's called hex to string and she's going to look and he's going to look at the secret okay so here we've written the program and now we want to test it so how you would test this you know in a normal scenario if you're writing a decentralized application is you now have to you know load up ganache or you have to start your ethereum node and you gotta deal all with those things um but what we need to do is it's actually quite simple we just write reach run and what reach run is going to do is it's going to download a docker image for us that's called the runner and what the runner does is it has a version of our standard library pre-installed so it's going to create a node package for our code start it up then what it's going to do is it's going to create behind the scenes a it's going to create behind the scenes a um what's the right way to say this uh an a special instance of the ethereum devnet and then when it creates a special instance of the ethereum devnet it's then gonna attach our program to that and run it so we don't actually have to worry about any of the details of creating a um we don't have to worry about any of the details of actually creating a network um and managing it that's all taken care of behind the scenes uh but unfortunately when we were in this program it errored and notice that it errored and it said that it errored on line 17 of our code so what was the line what was line 17 of our code again and notice it says on line 17 of the reach file so 17 was this line right here so this assumption failed uh and remember this assumption was that um the amount had to be less than a hundred but remember uh you know on ethereum um the units of money are always in way in a way is like i think it's like one to the it's like 10 to the 18th or something like that so you know we asked for five ethereum which is like ridiculously large uh so you know uh we could change this to be a really big number um but i'm actually just going to comment it out for now because you know we don't really care uh that was just kind of a demonstration of showing you know how reach works how it can um double check that you have these requirements but for the perspective of our program we don't really need that so we'll go back and we'll run reach run again and reach run is going to compile for us so see at first it compiles oh it's going to yell at us that we forgot a trailing comma that's too bad then it's gonna you know finish running it's gonna go off and create the uh docker instance it's gonna start it up then it's going to run says bob alice's alice if you were watching behind the scenes you looked at my horrible grammar um atlas asks me bob for five and now the secret is if you wear these you can see through evil illusions so notice that what happened in this program when we ran it was that these things got printed so let me just fix this ask me alice asked me for this now it's a little bit unsatisfying because this program you know we don't really like see what happens behind the scenes one thing that might be convenient is to also see like what people's you know what people's balances are like how things change as we uh as we run the program so what we can do is let's add an additional thing to our javascript code where we can see what the participants balances are so what i'm going to do is i'm going to have a little call down here where i'm going to write down i'm going to call you know show balance and i'll do it for alice alice and i'll do it again for bob and we'll do that before and after so we can see how things change now what is the show balance function let's just write it ourselves so show balance is going to take in a particular um identity so it's going to take in somebody who and what we'll do is we will call um we'll call console.log on um standard lib format currency oh we have this this is the this is the who and this is the um this is the account and what do we want to give them we want to give um await standard lib.balance of and we'll say the account name and we'll say we'll make a little string here that says whose balance is i will print that out and then i think this is good did i forget anything yeah there's a misplaced parenthesis there okay so let's run the program and see how that goes so we'll run reach run notice that it doesn't recompile the reach program it just updates the docker container it says that alan's balance is 4.9 and then a bunch of decimals and then bob's balance is 10 but then afterwards alice's is 9 and bob's is 10. now you ethereum hackers know that of course uh the number here is much smaller is not exactly even because there's the gas cost involved so this is what it's like to write a reach program we get to focus on the high level details of our program we get to think about who the participants are what information do they start off knowing what interactions are they going to have with the running application after it's deployed then what we do is we write down what each individual step of the program is and these steps are not the transitions in a state machine we don't have to think about the low level details about how the consensus network is going to deal with our contract instead we don't really think about the smart contract what we do is we think about the decentralized application which is a distributed computation involving a whole bunch of participants we write down what they do individually we write down what information they share we write down what has to be true about the things that they share we write down how they take turns doing things and how information gets shared throughout the course of the application behind the scenes reach guarantees many properties for us automatically it guarantees that the balance is always zero at the end of the program it guarantees that we don't try to overspend it guarantees that every time we make a requirement the honest participants actually check those things so what this does is it guarantees that when we have honest people playing uh running our program there won't accidentally be spurious errors so this reach program you know it is only uh you know 42 lines of code and you know with uh very generous white space when we look at the javascript code that we also wrote you know it's a little bit more dense but it's also only 34 lines of code and notice that there's not a single place in it um there's not a single there's not a single part of it that is actually sensitive to being ethereum so notice that right here we said that we're just going to load the standard library so it turns out that the way that reach works we can give configuration arguments to that reach run function where we can say well don't actually start up a local guest node instead connect to my inferior account or maybe don't start a guest node and don't actually use a theorem at all instead use another network because reach is actually a blockchain agnostic.programming language where one computation can be written one computation uh can be compiled to many different platforms now what reach does for us then is it generates for us a backend program and this back-end program includes versions of our smart contract for each of the back-ends that we support so for instance it uh you know it supports we're working on algorand support so there's algorithm contracts that get generated uh inside here you'll also see also see the ethereum abi that gets generated as well as the ethereum byte code if you want to see the raw um if you want to see the not by code version there's a flag where you can see that if this is interesting to you what i suggest that you do is go to our documentation so our documentation is at docs.reach.sh you can see the overview which is roughly what we've done today so we've seen this example program where each line is talked about what it does and how we use it um and you can see all of the details of that and then after you're entered after you've gone through that if you'd like you can go through our tutorial which takes you know quite a bit longer to do and you can see a more involved program please join our sponsor discord channel we're going to have a hackathon prizes for people using reach um and if you would like we are going to offer a long form version of this where i'll you know help people type in things themselves go through the tutorial and so on now this time it's a great time to answer questions i see that there's been a few questions from youtube so the first question someone asks is does the use of re does reach restrict the types of smart contracts that can be written versus solidity um yes so reach right now has quite a few limitations um on our documentation page we have a discussion of those limitations and our plans for dealing with them some of those limitations are sweat limitations like just as a little tiny example right now the reach compiler only supports unsigned integers it's fairly obvious how we can extend that but right now we're focusing on the big picture of what reach can do as opposed to filling in all of those little gaps there are some you know bigger ones that we have to think more about and you know i suggest talking to us about those checking out our limitations page in general i think of reach as not being a replacement for solidity instead the way that i want to think about it is that we all know that there are many interesting programs out there in the world like you know i'm using uh you know google chrome right now it's amazing and would it have been possible for us to implement google chrome in assembly technically it is possible right because it just gets compiled to assembly so someone could have written that by hand but we don't seriously think that anyone is going to really write programs like google chrome in assembly and reach's vision this has reached the company that does not reach the programming language uh reach's vision for the future of web 3.0 is not a world where there are thousands or tens of thousands of decentralized application programmers we imagine a world where there are millions of different centralized application programmers we want a world where there are so many applications that um we don't need a few brilliant minds like metallic to come up with what people will use the blockchain for we want there to be a huge flood of ideas and the best way that there can be a huge flood of idiots is there's a really easy language to use where you're not scared of writing a program incorrectly and losing 15 million dollars overnight um that's not the kind of world that's going to a language where it's so dangerous to program is not one that encourages creativity like i think we have observed in other markets like you know the the smartphone market and whatnot so with that in mind uh reach is not designed to be able to handle every single program the same way that when you're writing an operating system you need to drop down to uh c and assembly sometimes or if you're going to write a machine learning algorithm you might write the architecture in python but then behind the scenes you're going to use tensorflow which is of course a very advanced uh you know c plus plugin c plus plus math kernel library so our kind of model for reach is that we want to be able to handle eighty percent of all smart contracts and the remaining um ones people might use low level tools like ethereum or yule or other tools sorry not if you're solidity or yule or other tools like that um now the next question someone asked is you know what's the team what's the reach team's guidance on production readiness of reach and or general thoughts to recommend the use of reach versatility being an industry standard i think that i kind of answered that a little bit about the way that we see the future of web 3.0 i will say that some of the limitations that we talked about on our documentation for reach uh do inhibit it from being uh being wise to launch things long things in production in particular um we haven't enabled the feature in the theorem prover to guarantee bounce checking on arithmetic operations again this is kind of a sweat thing not a thought thing we want to work out the broad details uh before doing that we use by the way the z3 theorem prover which is also something that silly can use and it's kind of an industrial standard for automated reasoning about programs now someone else asks so can we use the generated javascript code in a browser context as well injecting accounts with metamask or like we don't have a tutorial that walks through how to do that but we use um ethers as our like you know ethereum transport library which can attach to metamask right now we're really focusing on designing the language getting the developer experience for testing smooth and we haven't invested very much in deploying browser applications but that's on the roadmap if you have other questions like i said you can go to our community discord discord.reach.sh which is linked all over the documentation so you can click on the discord community and you can also go to our um you can also go to our sponsor discord channel sponsor reach on the ethereum hackers server awesome thank you so much jay this is so much for having me um it's a real pleasure to talk with all the other ethereum hackers in the world and um i hope to see you all on our channels and interact with you more thanks so much right on thanks so much reminder everyone to steak if you haven't yet and participate on youth online cheers yeah great presentation thanks rob hi everyone yeah that was a good presentation thank you 