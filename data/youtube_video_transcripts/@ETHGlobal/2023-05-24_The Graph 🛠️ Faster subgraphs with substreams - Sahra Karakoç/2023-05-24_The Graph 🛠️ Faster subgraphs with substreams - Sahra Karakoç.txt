foreign [Music] which is a new technology by The graft built by one of the core teams of the graph streaming fast about me my name is Sandra I am a med student at weekends University turkey I'm from Turkey I also work as a developer at graphops which is another core team at the graph today we'll be talking about what the graph is and then bounties quickly about subgraphs and then we're going to compare the suppressed with substreams and then talk about sub streams and subgraphic biceps which is the main point of this Workshop about the graph graph is the data layer of pep3 it allows you to index and query blockchain data and we'll see how it does that in detail in a moment about the prices so if you build a subgraph or use an existing subgraph you might be eligible for bounties and also if you use substreams or deploy your subgraph to the subgraph studio you get bonus points for to use substance you should pay attention because I'll show you how so the subgraphs very quickly there in ETL process extraction transformation and load of blockchain data and the way they do it is I mean they consist of three components the first is sub-raphael is the Manifest file which is the configuration file here we see that we're listening to ethereal you can see it here and subgraphs listen to the contract events so we have to specify which contracts we are listening we have one contract here which is the GRT contract in my example GRT is a token of the graph and then for each event we have a Handler which transforms the event data to the entities we want in the schema in the store of the subgraph here we are seeing a simple Handler it takes the event data and then populates the fields of a entity in the schema we Define the shape of the data we want in the store as I said so okay substance in your technology and if you know about subgraphs it might be a bit confusing so we're going to compare them as I said subprofs is an ETL process the whole thing extraction transformation and load but when it comes to substreams I write that their ET but actually is the transformation layer but extraction also comes built in if you are developing substreams the extraction happens by firehouse and other technology developed by streaming fast and transformation is done by substrers but there is not necessarily a load layer so you have to Define where you store your data at the end and we call them syncs in substrings that's the term that we used and in my case my sync will be a subgraph that's why a subgraph hit by substrers that's the name and another difference is that subgraph handlers the functions that transform the data they're written in some script but in substance we write them in Rust also substitutions are composable so substitutions consist of modules many modules that transform and you know filter data and if you have a module or even the whole substream developed and then processed you can reuse it and other developers can use it as well and substrers are parallelizable which means that let's say you're processing I don't know two millions of blocks you can process the first million in parallel the second million which makes things a lot faster that's why they're faster I mean one of the reasons why they are faster than subcrafts also in subgraph case you can only listen to the events and maybe occasionally make you know contract calls but in sub streams you have the whole block data which is my favorite about substimes you have the calls transfers logs even the store changes so everything that happens to block you can see in your substreams also since you get the whole block and the blog comes with ordinals so everything that happens has an order of has an order in the block so you get you know what happened before what you know you you know the range in the block of everything that's another thing now when it comes to substance big subgraph we get rid of the mappings with where the transformation happens we replace it with substreams and we keep the subgraphy animal and the schema but subparation will look a bit different I will show you in a month because our subgraph no longer listens to the block but it leads us to a module from the substreams so substreams as I said they consist of many small modules here I will show an example and this is the module graph of a substrips we have the block the black is the input of the map map transverse this is a module and this map just you know filters data and feeds the data to downward modules and then the other modules do their own transformation and filtering and then feed it to the downward modules at the end in our example since it's a subgraphic by sub shapes we have a special module which is called graph out which will feed the data to sub graph store and I have two more maps map accounts and map walk total Supply chains that's just for you know demoing just showing you how to use stores there are functions of stores but we're not going to use it for our subgraph so substance we have two types of modules as you can see maps and stores the maps they take bytes as input and then output buys and in the meantime they transfer and filter data and these bytes are encoded as product above messages here you can see a problem of definitions that you should do if you're a substance developer you should Define what type of outputs your Handler will have I Define the transfer just to keep it simple and here you can see the input of my module is the block and the output is the transfers protobuf I defined when it comes to stores okay stores are stable but they're not the Final store this isn't this shouldn't be confused because in subgrass when we say stored we mean the permanent store the database but here we have the stateful um temporary stores where your modules will use so whatever you put in the store will not be credible or anything you're just gonna use it in your other modules while your substream is running here we see um this guy has the value type and update policy so the reason is that for the value type every store is a value type because stores consist of key value pairs so you set it in the beginning and you cannot change it every store will have a specific value type update policy comes from the fact that as I said modules can be run like the run time they can be parallelizable so if you don't have an update policy you cannot really merge them so let's say you process the first million block and then second million block now they have to be merged so this is where the update policy comes in if I have an ad um here this store is going to be storing balances of GRT for users so the first million block will have a balance for a user the second million will have valves and then we're gonna add it because that's how you calculate the balance so we have different value types you can check this this is from the docs of streaming fast and we also have different update policies you know set set if not access in the set case the last key uh wins and the in set if not exists the first keyrings we have the admin Max and append okay now let's see how a substream looks like so we start with the substance yaml this is the configuration for for the sub streams um and here we defined I don't know the file for photo Imports Etc but the important part is the modules this is what I showed you before I have the transfer module store modules other store and transfer modules sorry um map and stores and here as I said you defined about attack update policy input output everything and in the product file I also showed you this you define the input output shape of your data in Deliverance this is where you actually write your modules the handlers the first example of a module is the map transfers that we have seen here the first guy here so what this does is that we have the GRT token contract again GRT is the graphs token and we just look through all the logs coming from the Block as you can see the input of this map is the block the whole block but you know I stick to the events because it's more beginner friendly but if you want to see more advanced stuff about you know the block information there's I like store changes if you want to learn about them I can also show that to you if you come to our booth so we look through logs here and we just skip everything that's not from GRT token contract and whenever we see a transfer event we create a product of transfer that we defined and we output this now where does this go we have seen that here we Define input output so this is where the substream graph is defined here this map transfers output is the input of store balances store balances is where we keep the track keep track of the balances of you know each user on each transfer we just add like increase the balance of a user if it's to that user and decrease it if it's from that user that's very simple but the reason why I have it here uh is because I want to show how to use the stores in Delta mode so the logic of thousand mode comes from the fact that let's say uh again you're calculating the balance of a user but a user might be making 10 you know transfers in bond block maybe they did a multi-call maybe they have a bot something like that and then the value of their key the accounts address will be the key the value will be the balance it will be changing 10 times in one block so these are called Deltas the changes in one block so the whole sub streams graph is executed on each block so that's uh that happens on each box so we have the dial test of the block if one store changes multiple times even if it's one we're gonna have one laptop so in a store when we get the store as an input from another map this map account gets the store balances as an input um you can look through deltas and here just to show you how we do that is like we get for each Delta we create an account product buff this is just for an example you wouldn't really do this but we can run this map account to see what it does I have enough transfers let's make a web accounts and also we can run it or we can use the GUI which looks a bit cuter so here this is the output of map accounts module as you can see there is apparently only one transfer so far the like this is um right now streaming From the Block by the way so there's only one um GRT transfer so we use the we see um that road above here so if there is any other I can switch but there is none and also I can switch from uh module to module we can also see map transfers here it's because map transfers was an input to store balances and store balances with an input to map account so all the map is running uh at the moment as we can see there is another we can just jump here another activity another transfer another transfer another transfer and so on so it's really fun to use degree so let's stop it and continue um we have another mode that we can get we can use stores in that mode is um the get mode so with the Deltas you can see all the changes with the get mode you can have access do you remember the ordinals you can have access to a specific order the value of a key at a specific ordinal so in this example we're getting um I'm very calculating the total Supply in the first store that's very you know straightforward in the other map in the other module which takes that store as an input we are using the get functions so here I just created let's say let's calculate on each block how how much the total supply of GRT has changed the way we do it is by we have a special function which is get first which give you gives you the value at the beginning of the block the key is value at the beginning of the block and this is the key we get at the beginning of the block here and we have the get loss we also have get ads if you know the original let's say you want to know the balance of a user at the specific transfer you would get the order from the transfer and then ask for the value here using it that's another one let's run that okay from here this is just substream so far we want to actually build a subgraph fed by substream so we did all these Transformations and I think you can use this project it's in GitHub and I'm gonna show you the Share the link with you you can use this as a template because there are many files that you have to create and you know many things that you have to do I would just clone this and change stuff so from here we actually want this data to be stored in subgraphs how do we do it in a sub graph we have the schemack and very simple schema for today's example we have the GRT entity which also total supplied transfers maybe I want to list all the GRT transfers in my front end and the account just balances of each account now the sub graph yaml will look simpler and will take graph out as the input as I said no longer it's like it's interested in the black anymore no handlers nothing and the way we do it is as I said there is this special graphite module we use entity changes so entity changes are again product of definitions which just go and change the store on each entity changes photo buff coming from the graph out so let's say you your transfer entity this is the name of the entity from the subgraph story comes that comes the transfer entity you give the ID specify the ID and the order and then there's the operation here it can be update delete create but if the entity doesn't exist it will be created when you use the update operation so I always use the update operation and this change function will just update the field of your entity with the new value this house does it and the other entities change is using the Deltas it's just updating the balances of accounts on each Delta and this guy is updating the total Supply on each Delta and the output will go to the sub graph as I said and eventually we're going to have this subgraphed by substrips now let's run graph out just to see what it outputs ref up again I'm using GUI we can also run like using normal run command let's see okay the breath out we're seeing entity changes what happens in this specific block this is the current number of current block number there was a transfer so we are seeing it transfer and exchange of course if there's a transfer transfer entity change there will be an account balance and change and a GRT total Supply entity change so since this is running a bit slow because of the internet I don't have any other activity happening until this block so we can stop this and finally um we will be deploying um our subgraph to the studio to be eligible for you know not only bounces but you know also get bonus points the way we do it let me open subgraph Studio okay around here we connect with our wallets that this and here I already deployed this but when you um create an account with connect with your wallet and um just let's show you just create a sub graph you're gonna enter the name and select the network that's not really important because you're not going to publish it you're just gonna deploy it those are two different things you come here you um if you already built the sub graph and it's running you already have the graph CLI and you don't do this because this is for initializing a usual subgraph you just skip this init you authoritate the studio and then called gen graph build and deployed then your subgraph this is a subgraph fed by substrers this is the example I showed you I deployed it can be created just like a normal subgraph so to finish we have where is it okay it was here we have a QR code where you can see the prices um there are job openings and hacker resources and linked to the repo and to this slides as well thank you thank you 