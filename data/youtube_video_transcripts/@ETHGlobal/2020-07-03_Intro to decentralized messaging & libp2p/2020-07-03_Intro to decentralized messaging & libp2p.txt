okay stream is good so let's kick it off welcome everybody to this is probably the fifth hack of us event before kickoff we've been doing a series of workshops related to file coin Lippe basically the whole tech stack this week just to get people familiar with these new sorry I just got distracted getting people familiar with new stuff if they're not familiar with the file point ecosystem and today we are really excited to have take a point with us he will be giving an overview of centralized messaging and live p2p he is the jaya slippy to be tech lead at file coin and like I said we're very happy that he was able to join us today he's gonna share some of his expertise on this topic before I pass it over to him to start off a few things like I said make sure you've staked for hack efest this is how we ensure that people are really committed for the event and we want to make sure we're supporting people who are committed it's only 30 died and you get it back after the end of the event so please make sure to do that before Monday you have any issues DM anybody from the team we will look into it for you we've got one more event tonight after this which is the brainstorm session where as the previous events this week or more workshop focused technical this brainstorm session is going to be a little more open-ended come chat about ideas 8:00 p.m. Eastern tonight hopefully that's not too late for some of you but let's say we're gonna have a good show what else oh of course the kickoff is on Monday at 12 p.m. Eastern hopefully everybody gets used to translating from Eastern to their local time if you're not already but that's just what we've chosen to get people on the same page and one other thing we like to do in these events before kind of getting into the swing of it as we play a game that I invent every time this time we're gonna do the one we did yesterday you turn on your videos let's see Andrew I need you to count since you and Jacob have colored shirts on that's what we're gonna count colored shirts and I will be team monochromatic alright let's let's see how many black shirts we've got Andrew and Jacob please count the colored shirts let's see who wins one two wait no no Zarina you've got some stripes man I don't know I don't know about that one two three or five six well I got like two colored shirts I thought it was gonna be more balanced Brinks of color into your life yeah come on people no wait no I'm team monochrome it's alright III didn't I fail to account for striped shirts so we'll have to consider that for next time so I think the black shirts win this time last time it was a tie so go team dark shirts and with that Jacob we're done with the games floor is yours give us a little intro about what you do what you have done and where you're gonna talk about yeah hi everybody so strengths that I am Jacob Wayne I have been working with protocol labs for a little over two years now primarily focused on the Jas side of whippy-tippy and Jas light BFS I will also see me popping up in go lippy and go ipfs from time to time but primarily on the jaya side of things and helping out with like release management and release planning so if you really really want things for lib p2p and ipfs i am a great person do you throw requests that i'm so feel free to do that and yeah so today what we're gonna be doing is kind of giving you a brief overview of decentralized messaging we'll kind of talk a little bit about like how is that different from centralized and how is it different from distributed which is the thing ideally we'd like to get to and we'll talk about how to do that in Lib p2p today we're going to be going through the BJS implementation of lipid EP specifically in node but for those of you who you can either follow along there the workshop is kind of broken down into chapters to kind of step through where each subsequent chapter is has solution code already in place so if you get lost partway through you can just change into the next directory and get that running and if you aren't in a coding mood today I have there is a browser version in the repo and that is up on the Gateway of ipfs so you can chat to your heart's content this is a very very basic of chat application in react so if you want to use a nice chat application maybe use matrix and not this but we'll we'll play around with this today all right so I'm going to go ahead and share my screen and we will jump into it you guys have questions along the way feel free to shoot them into zoom I'll do my best to answer them along the way let's reorganize chat because Indies mean yeah so go ahead and pops up in the zoom as we go otherwise we're just going to go through this and then I'll leave space at the end if you have like broader more in-depth questions so here is the just the readme for the workshop so if you want to pull that down feel free to do that and we will get started if you haven't pulled it down already here is what the the web chat app looks like you can see this is a very depictive pit picture of what the internet and loop EDP looks like today with this green one being a node.js node and the not very well connected browser note is in purple but let's go ahead and jump in and start talking through this so yeah again code for today it's up there the branch is hack FS if you want to follow along there and in the main branch we're also kind of updating this along the way as we release new versions of Libby to be so the repo is just a good place to to come back to if you ever want to see how we're going through and in updating I'm like oh 27 to 28 and beyond so talking a little bit about centralized decentralized distributed like right now we're kind of in this era where we're pushing more towards decentralized but we've been in a centralized structure for so long where these Center nodes are like heavily controlled by a few very large corporations like Google and Amazon and there are like intrinsic problems with this that a we have like they're the places where all the data goes so they can house as much as what that does they want they can keep that we have gdpr in places like Europe but in the u.s. they kind of have freedom to pull that information another consequence of that is that it's very easy to censor single points and that becomes difficult for people living in in China or Turkey and places that are kind of restricting those those end points so ultimately what we want to do is we want to get to a point where we're able to develop a full peer-to-peer network and this is really this distributed side of things this full mesh looking infrastructure the problem with that is that talking directly peer-to-peer is very difficult building a distributed system is very difficult in in today's technology setup especially we look at like browsers and being able to connect to them and so kind of where we're at right now is this middle ground of we're building a decentralized network in web 3 on our way to getting fully distributed and we do this thing with like rendezvous sewers in WebRTC which we'll talk a bit about today with circuit relay nodes things like that where we can like have these center points where lots of people can connect to and then create you know peer-to-peer ecosystems from there so not quite what we want but it's a good stepping stone to get there so how does the p2p play a role in this so would be to be is the networking stack that ipfs file coin Sirian - and a few other ecosystems are building on and the reason for this is 'aslim p2p is designed to be a modular system of protocols as we get better support for distributed systems and as the internet and our infrastructure evolves over time like we need to make sure that we're building a networking layer that it's going to be able to adapt to those changes and so this is really what lip PDB is trying to do is create that foundational layer so that people can build awesome applications on top of it so getting down into the bits of live p2p what we're the first thing we need to look at is like transports because transports are the the foundational layer that lip p2p uses to connect to other nodes on the network and there's a wide variety of them and they're continuing to grow as like technology grows and as more and more people are joining the lip p2p ecosystem they're starting to develop you know more interesting in neat ways of passing that data around so each transport comes with its benefits and its drawbacks here's a very basic table of where things are at today this only includes node go and rust but we have currently today seven implementations of the p2p we also have like Java Python C++ and NIM and so like that's this ecosystem is growing and it's making it easier and easier to develop the PTP across different platforms so today what we want to look at because we're building this in JavaScript we're building a node only application right now but we also want to make sure that this chat app that we're all in we have the ability to also connect to the browser so looking at web sockets and web RTC so talking through a little bit more of these transports like TCP is a very basic transport that a lot of the servers or using Sogo uses it rust uses it and node uses it so this is a pretty prevalent widely supported transport but it does have its drawbacks like it can't talk to we can't talk to browsers it can't run in browsers WebSockets is nice because like it's widely supported in the implementations and it allows browser nodes to talk to server nodes the big drawback here is that WebSockets in the browser have to have an ssl certificate at the node that they're trying to talk to so if you run a server a node or an NGO you have to put an ssl certificate in front of it and a domain because currently at this point in time a sil certificates don't work for IP addresses that might be a thing in the not-too-distant future but that's currently in limitation which makes this very painful to make a peer-to-peer network explicity on that and then webrtc whatever see is really nice we currently don't have their is working support for it and go it's not quite there yet we're probably going to be looking at reevaluating that because what are the nice things about WebRTC is it has built into hole punching and hole punching is the thing that lets us talk from browser directly to browser so like using this chat app in Chrome or whatever browser you're using like we're connecting over a rendezvous server and then we're doing hole punching to actually talk directly browser to browser so we don't actually go through a relay server which is really really nice it's a very efficient form of communication and then we're working on an evolving quick transport so the RFC for quick it's still still in progress but it's being finalized and so we have the latest RFC is implemented in go and we've actually been working with the node.js team to get support in in node.js so that is coming hopefully in the not too distant future I think it's already experimental in node 12 or at least the fork of it so you can play around with it there I think we have a very rudimentary version of that in in node but not quite there yet so looking at what we're building today we said okay let's let's look at node because that's what we're running and then we want to make sure that we're able to talk to browsers so what we're gonna do is we're going to add TCP which is going to let us talk to things like DHT servers and other server nodes WebSockets is gonna let us talk to any bootstrap nodes that are on the network because all of the bootstrap nodes that the protocol labs team supports all of our Lippe to be bootstrap nodes those all have SSL in front of them so we can totally totally get that out of the box and connect to the network and then WebRTC we're gonna need so we can actually talk directly didn't one another over browsers so over this we're gonna kind of skip through some of the chapters just so I can get this done in roughly 60 minutes and so we're going to go through several of these concepts along the way and then when we to the basic setup for Libby to pee we'll jump into the code and see what that looks like and then from there we'll move on even for a localhost localhost is actually a secure domain so when you're testing locally you don't have to worry about it you can connect to your local host server so now that we've selected our transports and we know what we're gonna use what we need to do is look at like okay how do i how do I contact you on the network if you think about things like today us as people we have telephone addresses mobile phone addresses email addresses postal addresses telegram accounts like we have all of these various ways to contact people and there's not a clean way to do that if you were to fill out a form with all of your contact information like you would have to have like a ton of different fields formatted differently and those change over time and that becomes like very very painful to represent and what we want to do is loop EDP is make sure that that is like somewhat future proof that we can evolve these addresses over time that have a like singular structure so we don't have to worry about that we can just derive addresses from that so what multi adders do or multi addresses they allow us to compose flexible addresses in a path like structure when they're there string representation so they also tell us a ton about the the host that we're going to contact because we need that information so we're gonna step through a few multi adders here because they can be a bit difficult to consume but the first one we have here is like your very basic listen address that you'll see in ipfs and what it's saying is I'm looking for an ipv4 address at this IP address localhost and I want to connect over TCP so this is defining our transport and then we're gonna connect on port 4001 so fairly straightforward the next one is almost the same Zhaan's the port change except we have WS at the end and what this is telling us is we're going to run a WebSocket connection over a TCP transport because WebSockets traditionally run over TCP connections looking into some much more verbose we've gone from the simple thing to the much more complicated thing but this is one of the servers that we're going to look at connecting to actually today will be connect to one of the sub servers of that that main domain here we have a DNS for so we're running a DNS domain address which means we are going to need to do a IP DNS lookup so this is either this will probably automatically automatically happens in node but for things like the browser we actually have to do like resolution and that becomes painful because we actually don't have a way to do that in the browser without doing dns over HTTP which is kind of annoying but so what we want to do is we want to resolve the WebRTC star discovery lipid Pio address that is a TCP connection that's running on a secure port of sorry secure port of 443 and then you'll notice instead of WS this is WSS which indicates that this is a WebSocket secure connection this is required for browsers but things like go and node don't actually require SSL Certificates so you can actually make secure connections just over WebSockets which is nice because we can just fall back to the p2p decryption and at the very end of this is the thing that tells us this is a web RTC star connection and so this is a WebRTC rendezvous server which is going to allow us to negotiate WebRTC hole punching so the next thing here is similar to TCP except we're going to be running a UDP connection so this is gonna be packet based switching so TCP then that's gonna be running on 4001 again this is like your default IP FS implementation if you have quick enabled and go ipfs and then that's running the quic transport and then we see here that we actually get this p2p like in the past if you've you've been working with ipfs for a while this was typically ipfs but because like Libby - P is for many more applications than that we've changed that to just the PTP protocol what that indicates is there is a pure ID that's about to happen in this instance it's a truncated QM relay is the pure ID and at the very end of this we see that this is a PDP circuit so when the transport when the switch goes to look at this is this okay I am gonna make a relayed connection to this peer so I'm going to dial this peer over quick and then negotiate so this was what you might use for a listening address if you want to listen over this relay okay so once we have that really what we need to do is like okay we have some understanding of can you talk a little bit more about the circuit how it might be shared I yeah we can we can look at that at the will touch base back up at the end please remind me already so adding the multi adder once we do that once we figured out our multi adders we'll go through this in in a little bit and to look at like okay what what does this setup actually look like we need to actually specify what are our listen addresses we might want to change what our announced addresses are so for example if you are running a server and you want to you want to put a domain name in front of it like you want to announce addresses that you're not listening on you want to announce that domain address and we'll kind of look at some of what that looks like so the next thing we need to do for our base connection is is look at like connection reusability so in Lapita p we have there's a variety of protocols there's application level protocols pub/sub messages as DHT queries circuit relay is a protocol file exchanging ipfs and file coin and then the chat protocol that we're building today at least the first part of it and then like if you build something new on top of low p2p ad hoc FS like you're going to need to create your own protocol for that and so like how do we handle this with singular connections to other nodes how do we handle all of these things we don't want to create new connections for each of those we want to be able to reuse that and so if you kind of think about this like the concept of if you've ever heard about or seen a tin can phone basically the idea of I have you know two tin cans and I punch a hole through it and have a just a string running through a top string you can speak through that and that will transparent information but if you try to have multiple people talking into it at the same time like you're not going to get anything out the other end it's just going to be garbled and so what we want to do is to be able to take this like very PTP connection and we want to be able to do multiple virtual connections over it so it's kind of like this idea of we're creating virtual strings across our tin-can phone so that we can run each protocol on those streams and we'll look it up a little bit more what that looks like so this is called stream multiplexing in Lipa DB and multiplexing is a concept that actually dates back to early days of like telephony in you know telephone lines what they actually will multiplex multiple conversation over different frequencies and that's how they handle it in telephone TCP connections do it over multiple ports so you're not getting multiple connections per port you have you know singular connection that will multiplex over multiple ports to the applications that are receiving that and then for EM Plex which is the it's not the only multiplexer for the p2p we have like yaw marks and quilt quick has a built in multiplex multiplexer but M Plex has the the widest support right now because it's relatively easy to build compared to some of these other things so once we have that right we have our transports we have our multi adders for people so we're able to connect to them we're able to multiplex the connections so we can have multiple conversations over a single connection the next thing we need to do is encrypt this because we don't want this data just free flying over the internet and plaintext that's not not good life for anybody so what we want to do is encrypt that so when selecting our encryption protocol we need to think about a few things so our current supported protocols in the various languages are TLS 1.3 which is used right now by default for for go and then noise which is noise is going to be the default security trail for I believe for eath - and the reason for this is noise is a framework for building security protocols and it's actually pretty easy to implement relatively easy to implement in the various languages like TLS you don't like we have to deal in like node we need a TLS 1/3 implementation working and node.js before we can do that and then we're blocked on the browser because the browser doesn't have TLS 1/3 support with noise we can write all those protocols and then we can just handle that exchange and we have full support already in in JavaScript and go and we're working on getting those downstream and the other implementations which are very close then again quick has a built in TLS security and Sakai oh you'll probably see that around that was originally developed as a stopgap solution for TLS 1.2 not being able to do self-signed cert and so Sakaya will be will phasing away as we have these new new security transports in place and here's just a quick capture of Wireshark I don't want to bore you with all of the the details here on the to nitty-gritty but what you'll see here in the top right is really like once you've encrypted a connection you'll see that the thing that gets exposed is the original multi-stream handshake so we go in and say hi do you speak this multi stream protocol and then we'll reply back with yes I do and then we select from their crypto and as soon as we agree on crypto in this case sec io everything is immediately moved into crypto handshakes and encryption so everything's secure if we did this in plaintext you would see a variety of protocols being negotiated we can table that keeps change one for the end so base configuration like we've talked about a lot of things this is a lot to absorb let's kind of like jump in to the code here and get a look at at what exactly this looks like so if you are following along in the code we're just gonna jump into chapter four protocol okay so just kind of stepping through this set up here and if you follow along at the beginning let's start at like chapter one um it'll kind of guide you through requiring some of these things but here's the the baseline of setting up multiplexing and encryption so right at the top right we have our transports that we talked about we've got let PT PT CP we have the PTP WebSockets and web RTC star the next thing we need because no js' doesn't actually have support for web RTC out of the box so we need to custom install that module in the browser in most browsers we get whatever TC for free it's already there but we need to bring it with us when we're building node the next thing is our multi adder module that's going to let us do all the the multi other creation from there M Plex here we're using both noise and sekai o is more of like a fallback so what we want to do is we want to default to noise as that's going to be the de facto going forward eventually and then SEC I o is kind of a fallback and so that will allow us to talk to legacy nodes on the network who are still only speaking SEC IO and have a had a chance to upgrade to noise which is really important to be able to kind of like have that gap of letting the network upgrade from there we'll look at the chat protocol in a second but this is just a file that pulls in like a very very rudimentary chat protocol and then let p2p core which is what we're going to plug everything into so here we just have a main asynchronous function because we need to do some awaits in here there's a lot of the code is promise based we've moved away from callbacks about a year ago and so in here what we want to do is we need to create the Lib PDP node so as there is a convenience constructor because oftentimes the construction needs to happen asynchronously it's promised based because we might need to generate on keys or peer IDs if you haven't specified one in advance so from there we can actually select our addresses and here we talked about creating the listen addresses specifically like we want to listen on a wild card so what this means right here i p400 tcp is i want to listen locally on any any port just give me an open port i really don't care what it is and then later on we can announce that to the at work and let PTP will handle that automatically and then the next thing we want to do is we want to make sure that we have our WebSocket connection as well and so we're adding the list and address same thing it's going to listen wildcard find any port that it can and listen in things like IP FS like these are going to be hard-coded so you've got like 4,000 I think the other ones 4,000 too and the reason for this is like you can predict what those ports are gonna be on if you want to set up like port forwarding on your router at home you can do that instead of port cheering and actually like it's it's easier to plan that way if you don't have like UPnP set up on your home router and then the last address here is the web RTC transport and that's the multi order that we kind of showcased although this is a little bit different this is one of the WebRTC addresses so if you go to the web RTC repo we've got a list of a couple servers that we now host so that you can you can troubleshoot you can play around with it and then you can always run your own web RTC star server from there we get into actually specifying the B configuration so going in and saying okay the transport I want to pass in TCP WebSockets and web RTC star these are also going to be kind of in order of preference and so in this instance if the peer that we want to dial has TCP addresses we're gonna try to dial those first in order we do do parallel dials I believe it's up to 8 by default that will try at any one time but any TCP ones will be prioritized then web that socket and web RTC and usually because these are like the more efficient ways of connecting so we want to try to prioritize those performance that performance so from there we look at the the stream Luxor which in this instance is implies and then connection encryption again noise in Sakai oh this is preference base so we're gonna attempt when we're connecting to somebody we're gonna attempt to negotiate noise first and then if that fails we'll try sekai ow this does have a consequence of like it costs a round-trip so there is some latency there if we're trying to talk to legacy nodes but we get the advantage of like slowly upgrading the network over time typically if we're rolling out a new transport like right now in JSI PFS and in go ipfs these are switched so we'll actually do sekai o first because like i upgraded first i don't want to immediately take the performance of a roundtrip so I'm gonna upgrade add support and then I'm gonna let the network upgrade for a little while before I switch those priorities and that eventually will just decommission noise or for this we're gonna leave noise as as the preferred one this thing here is a little bit kludgy and we're gonna be working on making the transport configuration just configuration in general better in the future but all this is it's kind of a hack of saying okay I want to when we construct a transport because Lib PDP needs to inject itself into transports on creation I also want to pass it these additional properties and so what we do here is look at web RTC star and we get its its symbol string tag we can't use like a constructor name or anything like this because when you go into a browser and you bundle it it totally up you skates the name of the constructor and that's just going to cause you nightmares so we have this kind of like convenience constructor and in the future that will be easier to do all we're doing here is saying that web part AC module that we included we want to pass that in to the web part disease transport so we can leverage that then from there that's that's the basic creation um so we we don't really have discovery built in right now there's nothing specified we'll talk about that a bit more in a minute however because web RTC star is a rendezvous transport we will automatically check for the discovery component and if it's there will bind to it and will immediately listen so this you're automatically getting some discovery for free for finding web RTC star peers which is pretty nice from there what we want to do is like this is just a basic thing that as we connect to peers so listening to the connection manager anytime up here is connected um get that connection and then we can look let me just shrink this a little bit so you can see we can look at and say okay whenever I'm connected to appear each connection has remote peer on it which is pure ID so we can stringify the implementation of that and we can log it out we can see what that looks like in a second and then we'll get into the chat protocol handler a little bit and then from here we're just gonna start the node and that's the basic gist of getting everything running one of the problems this has is just some logging information here for the string ID and then the multi udders that were actually listening on is like this concept of bootstrapping which we'll talk about in a second with discovery and right here we're doing a very crude thing of we're just going to get the address of one of the bootstrap nodes and I've hard coded it here and we're just going to dial it to that if you want to like take a look at like some of the servers that we have running you can actually do a dig if you have dig on your machine you can do dig type txt and then we can actually look at this bootstrap the PDP io record and then we need to preface that with dns adder the reason for this is this how the DNS address lookup works you can just remember that because the DNS address at the front just needs to underscore so when we dig that information we're gonna get back text records so let P DP doc bootstrap that Iowa is a kind of a round robin gateway that houses all of these bootstrap nodes and if you just try to dial bootstrapped outlet PT but IO it's gonna fail because it has no idea who it's it's going to talk to and we currently don't support blind dialing for kind of encryption purposes so but you can look at this and see okay we've got a bunch of DNS adders back and so what we ended up doing is just selecting one of these and then from there you look at it it's a DNS a tour again and so you can additionally resolve that and those individual ones are going to resolve two IP addresses but for the sake of this we're just going to target one of the bootstrap nodes and then we're just going to dial it from there so if we run that again and we say we're in Chapter four so if I do node zero four I'm in root node o for protocol index and I could run that so we're gonna see our peer ID and we are listening on the following addresses so we see the wild-card zero got replaced with our external port and then so we've got a couple TCP addresses these are all local gateway localhost and local gateway and then our web RTC star server and then you can just see as we bootstrapped and we've connected over WebRTC we're getting that free discovery right there's no other discovery protocol in place it's just WebRTC star and if you're looking at the browser you probably see it like a lot of like spam updates going on with the nodes right now we are connected only to web RCPS we're connected to two peers we're connected to the bootstrap server which is over our TCP connection this is the one we manually dialed and then web RTC star are all of our other connections so all these other ones are going to be web RTC star connections so I'll go ahead and shut that down for now and then we'll we'll take a look so this is the base configuration right we're connected to the network we're connected appears we've got browser peers we've got node peers this is great so the next thing we probably want to look at doing is like let's let's get an actual protocol in place so that we can do something with this so what are protocols in the p2p it's a concept that people usually struggle with a little bit but what you can kind of think of protocols like everything in the p2p is basically a protocol and they're just basically these plain strings if you've ever messed with a a rest endpoint it's very similar to endpoints and rests like these are endpoints in lib p2p so what happens is we register our protocol with a specific thing today we're actually going to use the lip PDP chat 100 protocol and what we're gonna do there is we're altom utley gonna listen on that so anytime a new connection comes in a stream opens that connection is going to come in and that protocol is gonna be at the front of it and so we're gonna pick it up and say ok Lippe to be chat yes I handle that protocol or I don't handle the protocol if I handle it I'm gonna take it and I'm gonna pass it off to the application handler so this is going to be our chat protocol code so then from there you can send whatever kind of information you want to send over your stream as long as that can be as long as you know how to deal with it could Emily for the win yeah we'll get into that a little bit a little bit later and then so let's let's actually look at what the creating this this protocol looks like so we'll just pop in to this chat protocol and this is it's really basic so we have a handler and then we have a send function so looking at our protocol right this is the chat protocol that we talked about this is what's gonna allow us to chat with anybody else who's doing direct messaging will look at pub/sub later for actually doing chat in the chat application in the browser that's running on the gateway that's doing pub/sub based not not direct messaging but for getting started we're gonna do direct messaging because these kind of protocols are very valuable when you want to do like file exchanges because you don't want to like pub/sub that information you want to get a direct connection before you send a lot of data so our handler code that we're gonna register takes a connection and then it also has the stream the connection here is really for convenience to give you that additional information of like who's the remote peer here there's a lot of information on the connection if you want to check out the the API Doc's we've done a big overhaul of the API Doc's then they try to preview that here on J asleep p2p website so you can look at that and get a lot more information on things that we expose and it will include the type so you can actually go and jump over and look at what the connection is but we give a lot more information there now to where you can actually look at yes stats for the application what are all the streams open on this connection like previously you couldn't do this in jeaious and it was a nightmare so you can get a lot more information there so but really what we need is the stream and that's the thing that like okay one of my handler registers is okay somebody has negotiated the chat protocol that's exceeded here's the stream with the data on it so what we want to do is we want to we want to read all that out and because this is just a very basic string implementation of chat all we're going to do is we're going to take that incoming message so this is all like async iterator space which are pretty nice if you've ever messed with them but what we're gonna do is we're gonna pipe everything from stream and we're gonna read it out in this function so we're just gonna step over every message that comes through here and we're just gonna log log that data out and then we're gonna do replies on new streams so all we're doing here is we're just immediately going to close our our write end of it because we only care about the reading in that information on the send side of it we've just got this basic function set up that we're gonna pass the message we want to send and the stream that we want to pipe data over and so again we're piping this message array we could change that to be multiple messages but for now just a single message we're going to pipe that into the stream and then we can wait for any responses there and the reason like this is kind of kind of coogee because like nobody's ever gonna reply but if you actually look at like the main branch in lip e2p there's a bootstrap server in there that you can run and it will actually just auto reply with some random messages so we have that set up but in reality you you don't need to do that yeah and here we're also just this is logging out the messages that were actually sending so you get that like the chat log of hey I set this so if we look at how do we actually register this thing right so we've included our chat protocol in the handler now we need to do what we need to do two things the first thing we need to do is actually register and so we need to register our handler so Lib b2b has a handled method so we can jump down to this to do this is add chat handler so we can just uncomment that now we're gonna do is pass handle the protocol that we're gonna run which is our chat protocol and then the handler and that's it like this is we're now ready to respond to anything that comes in but we also need to send some data so down here for you go to our next to do this is just basic handler code that reads from standard in so this is gonna let us do is actually fire off messages from terminal and node so all we're doing is listening to process dot standard in and every time a message gets sent based on the new line return we're gonna get that message in what we do here is the basic slice like we trim off the new line and we're doing a very crude thing here that you should not do in a pop in a chat application is we go through all of our peers in the store and peer store we check if it supports the chat protocol and then we check if we have a connection if we have a connection will create a new stream and then we call our chat protocol CIN so this is connection take an existing connection call new stream on it that takes some time because we need to go she ate like we need to send a round-trip to there multiplexer and say hey let's do this all in Plex let's create a new stream and we want that stream to be the chat protocol so once we get that back we can go ahead and send our message over that stream and then that's that's it for the code so if I run that again now that we've commented that I can go get some chat and then I can say hello yeah and so nothing is listening to this right now so let me pop this open node oh oh no see this is how I change it that's why this is why we use wildcards running all the nodes you oh I broke something what did I break should I not run that uh-oh I broke something protocol handler did I save I did save we don't have much time left so this is what you do if you get stuck we open the next chapter and we look at it and this is gonna have our solution code in there this is a cheat lovey cheats so oh da five discovery index if I run that then I ran again over here no dota 5 index yes i'm spamming all all of my peers and this is where like we're gonna look at pub/sub so for sending messages because it's way more efficient so now we can see that the chat protocol is working I don't know what I messed up but I must have typed something incorrectly but if you get stuck CD into the next chapter and that's gonna have have everything in there so alright that's our base protocol so now we want to discover probably more peers like we have a web RTC star which is really nice but we probably want to get more on the internet I fat-fingered yeah I probably did I've got big chubby fingers alright so if we look at peer discovery like there's a variety of peers that we are a variety of discovery mechanisms that we probably want to use and so bootstrap is the primary one right like we did direct-dial before but ideally we probably want multiple bootstrap lists and we might want a bootstrap to different parts of the network to avoid either like networks going down like we don't want to rely on one so having a list of nodes that we can initially dial to and bootstrap into the network is valuable em G and s we're not going to use that here locally today what it is is local discovery on your your home network since like this workshop was originally designed for people in place or people all in one place but since we all can't be together we will scrap mdns but if you do have infrastructure or an office or like places where multiple peers are going to be connected mg and s is like a great way to connect with other peers so it'sit's still very valuable downslide it doesn't work in the browser DHT is also a very very good way to find peers one of the limitations there is really like the most of the DHT nodes are like TCP only but we do happen to have a few that run over other transports like WebSockets so you can actually technically still crawl the DHT although doing that in a browser is going to be slow because you need to open up a lot of connections it's usually like I think can go ipfs we're averaging about like 50 dials for a query that's very expensive when you're trying to do like WebRTC WebSocket connections so like you can use it but it won't work very well this could be five chain safe put that together there's a JavaScript implementation of it it chains it I believe and this is for if to network discovery so that's really nice it's kind of like a DHT it uses a DHT to discover peers so that's also a very nice way to connect it is UDP only right now so again it's it's not gonna work in the browser but you can use it in node if you want to and then rendezvous servers like lived WebRTC star signaling servers and then we're actually building a rendezvous protocol and what that's gonna let you do is actually like ask the rendezvous protocol for like peers that have registered to certain namespaces so if you build your own chat protocol or your own web application or anything you'd be able to go to that rendezvous server and ask it directly for like a federated list of people who are registered that which is really kind of short circuit a lot of the initial boot time and then we do have people who have built some discovery mechanisms and like Bluetooth for a local discovery web Bluetooth not quite there yet but there's another interesting way to find things locally and looking at like the distributed space like what we really want to get to is that's kind of like looking at the environment that you want to be as being able to like discover my notes locally and then grow to the the wider network there so we don't have to like we don't have to depend on you know people running centralized bootstrap servers like you can trust us but you shouldn't trust us like don't do that let's let's make this all like organic and and actually make it a peer-to-peer network that's what we want to see and then DHT random walk so in the DHT the newest version of the DHT Inco ipfs doesn't technically do a it's not a random walk but it's ultimately like a refresh of your routing tables so if you don't know what a DHT is it's a distributed hash table and ultimately it's like a big key value store of peers on your network and then peers who have certain data and this is kind of how ipfs store's content if you're looking for content on the ipfs network like you're gonna look for that cid here and a query the DHT for it and it's gonna tell you who has that then it's just a matter of connecting to that person to get the data so but with that we can actually use tht random walk and we do have support for this and jeaious and we are gonna run it because it's fun but that is a great way to just like get to know more peers on the network in addition to actually finding contact so here's kind of how the DHT works if you're not familiar with it let's say I'm looking I want a random walk the DHT and for simplicity's sake we're gonna say like the DHT IDs are actually like people's names and so I know Alice and Bob but I'm looking for Brandon and so what I'm gonna do is I'm gonna ask Alice and Bob like hey do you know Brandon and Alice is gonna say I nope don't know anybody I don't know anybody close to Brandon but Bob's gonna say hey I I don't know Brandon but I know Brenda in along that process of like making up the ID of Brandon like Brandon might not even exist would you say like hey yeah give me give me somebody Brandon we learned about Brenda that way and so this is kind of how that random walk works right it's like just going around a party to meet people and like do you know Dave do you know Dave do you know Dave like Dave might not be at the party like Dave might not exist but it's a way for you to to find new people so we're gonna leverage that and the best thing to do is to you know got to catch them all use all of the discovery services use as much as you can because the more discovery services that you have it's more tools at your disposal to get connected to notes and a lot of it is to get connected to you so we aren't going to use mdns and scratch that out but we're gonna use bootstrap the DHT random walk and we already have the web party signaling server so configuring discovery we are a bit short on time so what we're gonna do is we're just gonna look at the pub sub directory and again this is going to have not you I want you here hey Jacob yeah it's it's alright if you go over a bit this is recorded so if there are people following along after and you want including thing that's totally fine we'll be sticking around okay great okay so looking at right we want we want to do discovery next configure that and do the shortness of time I'll just kind of walk through but again CD into the next chapter pub sub and that's gonna have all the solution code so we can ignore pub sub chat here's our old protocol which we're gonna end up getting rid of in favor of pub sub but focusing on peer discovery so here are our things I lied em deenis is setup haha so we've got bootstrap so rather than dialing that peer doing a manual dial we're gonna set it up in our bootstrap list so we're using the Lib PTP bootstrap module we'll be to be mdns for a local discovery so I'm gonna be able to discover myself when I run two nodes but I won't be able to discover you over mdns and then we're gonna use the DHT for random walk and so again our listen addresses are the same nothing has changed their modules the only things that we're changing this pure discovery we're gonna add bootstrap and mdns these are exported values from above and then we are going to include the cad DHT so we're running a code emiliya based implementation of the DHD but in theory as long as it meets the api requirements you could run coral you could run other kinds of like you can build your own DHD experiment with it play with it see how it works but for this we're going to use the condemned led HD and then again nothing's changed our transport so peer discovery what we've done is we've taken the dial the manual dial from down here and we've just moved this into our bootstrap list and so what this would let us do is if I wanted to let go look at that dig again so if I look at dig if I want to like hey let's let's add ewr looks like fun let's add that the reason we have to add these individually and not just add the main thing that we did a dig on the reason for that is currently dns adder resolution in j/s we don't have that in place yet do to do didn't need in to do dns over HTTP in web browsers but we can add another bootstrap note to our list it's no problem you can add as many as you want and when the note starts up it will automatically dial all of this and then DHT so we're going to turn it on and then we're gonna enable random walk just see these explicitly there if you add the DHT by default these will already be in place I just want to kind of show you where those options would exist because there are some additional options you can change the interval the frequency you can look at that in the DHT configuration but this is kind of the base for expanding off of and then the rest of this code is is all the same so what we can then do is run Oh dot six pub/sub because we're doing the previous chapter on discovery I want to run two of these oh I did something what did we do oh just to do poppy do wait start something's broke in debug star I broke something bad oh so I need to push that update we need to actually call the main function it's important to run the code if you want it to work there we go I'll push that fix up after this sorry about that so we have our base code here discoveries on once the DHT kicks in you're gonna see a lot of peers get discovered very quickly this is what's going on we're doing the random walk and then if I run on the other node we'll connect to those again this is gonna do MD and s so if we look at our pure ID Q mu we actually discovered that very quickly actually faster than our bootstrap nodes because we're on the local network so mdns discovered really quickly so we say yeah hi there and we got that they're hard to see in the connection span but we have that that connection there as well so this is this is nice we're connect to the web RTC server we're connected to bootstrap servers we queried the network we walked the DHT so we're also connected to a bunch of other random peers either over TCP or WebSockets so there's a lot going on there okay yeah so the dig if you add the the text type that will give you that that dig I won't dive into implementing your own DHT yeah that's a lot of work oh hi you can see my chat I better close this I trust you all but I shouldn't so I'm gonna close that yeah so this is great you can see you guys actually shutting in here so you're you're connected you're on my robots so from there we have discovery in place like what next right so we've at the point like we can connect appears we can discover peers we were able to chat with one another which is cool but again like we are checking all of our open connections and we're spamming everybody like every time we send a message this is not not polite to our neighbors so how do we make that better and as we kind of alluded to this is going to get into pub/sub so there are currently two implementations of pub/sub which is gossip sub and flood sub gossip sub is is widely supported now in the various implementations there is an update to the protocol 1.1 which is being slowly rolled out the gordy has it and then j s and I think Python are working on that any other implementations will be working on it soon and the nice thing about gossip sub is if you don't support it it will actually fall back it's a flood sub so there's really no reason not to use gossip sub you should you should totally use it if your implementation supports it use it it's much better so like what is what is pops up so pub sub is basically what we do is we create overlays on the network and I'm going to talk specifically about gossips up because flood sub is not much better than what we had before because it will it floods the network it will publish to every peer it knows in a lot of times like we get messages back and it floods it's it's very effective at getting data across the network but it's very bad for the network what gossip sub will do is it will actually develop kind of like handprint meshes over the network so as more peers join who subscribe to the same topics it will actually like connect to specific peers and develop a subset and then those peers will develop their own meshes so you'll have multiple meshes they'll communicate message across one another and they'll share messages to a subset of peers not to all of them just to a few and the reason it's called gossip sub is because like this has an intrinsic like chance of failing to like deliver a message because like if I'm only communicating to a few peers like we run the risk of not not getting to everybody so what actually happens is intermittently gossip sub will actually gossip to everybody in its mesh and say here are the peers I've recently seen any peer in its mesh or like it will also do that to random peers like flood sub like so it picks mesh peers and non mesh peers sends that out and says I felt I've seen these messages recently those peers can then come back and request that message if they missed it and so this is kind of like a if you're familiar with ipfs is like bit swap of kind of having that exchange like do you have this thing I want this thing like this is what gossip sub kind of enables us to do to be a bit more polite to the network and only send messages to a select few by still having some guarantee that we're getting messages so let's let's switch over and change this out so what we're going to wanted you is weaken again for the sake of time I will just pop into the odo 7 messaging session so what we did is we stripped out our chat protocol now what we're doing is we're using this pub sub chat and very briefly we'll look at what that is while getting to this like this messaging but it actually uses like a more complex message instead of just streaming data over because more complex applications will want to use more complex messages but this is just a basic chat protocol we won't dive into it too much but this will go in it will subscribe to the pub sub topic which is going to be our our chat topic and then it's gonna let us do a few things like if you are in the browser version you can actually do /name and then set your name because we're doing like a little bit more complex messaging which we'll walk through in a little bit but that's basically what it does and then when we get certain updates we'll will notify our peer about about certain changes like there's the ability to send like stats of hey what type of note am I Who am I connected to and this lets us build the edging on that we're seeing in the the graph that you can see in the browser version so from there all we did was we stripped out the we don't need to look PTP handle anymore because we're not running a custom protocol we're building a custom pub/sub Handler and so now what we have if we have this pub sub chat constructor so we've called that and then it's gonna take Lib p2p because it's gonna bind on top of it it's gonna take the pub sub chat topic and then it's gonna take a handler and that handler is just gonna have like we've customized that inside and so this is this is what pub sub is gonna call back with it's gonna tell us who the message is from and then what the actual message is and that messages is a struct of information so we can go through there and also me what we're doing is kind of binding like okay who's this message from we want to update any user handlers and this is the ability to change your name well when do we get that notification if it's a name change we'll update that locally not the best way to do this in reality but it just kind of showcases you how to go about doing that and then again because we're node we're just gonna log that out to the console yes so pub/sub are these signed yes all pub/sub messages are signed by default so you know who they came from they're verify you can turn signing off if you want to but it's on by default encryption part works in this so with pub/sub encryption like everything's already encrypted like at the very beginning when we set up encryption everything that goes over libido P is encrypted so these pub/sub messages when you sign that right so you're gonna send the pub/sub messages what's gonna happen is first pub/sub gossip subs gonna sign it say okay this message is from me then it's gonna fire it to the multiplexer which is gonna prepend any stream data to let the other application know like hey this stream that we've been working on this message is part of that stream and then that goes into encryption and so everything is unencrypted except but right before it's gonna leave your machine we encrypt it and then that goes across encrypted the other side the remote peer is gonna take that gonna decrypt it run it through the multiplexer pass that back to pub/sub pub subs gonna look at it it's gonna check the sign it's going to verify the signature if that fails it's just gonna throw the message it's just going to discard it we don't do any like we don't tell you that it works we didn't tell you that we discarded it we just silently get rid of it because we don't want to let you know that failed for security reasons and then all we did is we changed our chat input handler so that we are actually running pub/sub chests n so any message that comes in again from the command line we can just do a pub sub chess set so if I run that and we are on ODOT seven I can hit that notice this isn't yep doing the name change we'll look at that in a second so if you're trying to do a name change in node on this version it won't work yet but we can get in there I say hello everyone and so we're getting getting that information so we've gone from direct message to now chatting over gossip sub alright so next thing we'll look at is the last thing is really this the idea of complex messaging and so most of the message you'll see in Lippe to be our protobuf based but there's no reason you don't have to use protobuf you could use JSON you could use Ybor like you can use any serializer that you want to you could use just strings if you wanted to but ultimately that the thing that you want to use which is why we use protobuf is to get the D serialization and to account for size so you may want to take that into account when you're figuring out serializers to how much data you're actually sending over the wider that will matter so if we look at our we'll just go ahead and look at the messages very quickly so our messages have a request type and it's just gonna say okay this is a message I'm sending a message or I'm letting me know that some of my metadata change for stats and so from there we've just got some fields defined I'm you can see that the type of the message is required because we need to let you know that we're sending something and then just some additional fields there so send message we're including the data which is the full pub/sub message the full signed pub/sub message and then we have the timestamp of when it was created and the ID of the the message I believe and then from there update peer this is just our very crude message for saying like hey I've updated my user handle so now like you can render me whenever I set new chats as that that person and we'll see that in a second so if I jump back over here I think the only change we actually need to make them check this for two days is right here to change this not that oh my goodness there we go all right so ultimately here when we get a message from the command line rather than just sending it what we want to do is we want to do we want to check command and if we quickly look at check command I believe this is going to return us a bool yeah so this returns a bool that says hey if there was a command we're just going to return true so that you can know to exit so when we go pups a check command if that happened just exit early otherwise we can go through and actually send the message and so that that should be it for setting that up so far run owed us seven messaging again and I'll run that again locally here then I should be able to send messages yes hello and then I should also be able to change my name oh my gosh this is let's let me get rid of all these peer connections for a second so we can actually see this doo doo doo all right so we've got that data and then if I do slash name which you can do also again and the chat above or in the browser chat we can change our name I'm gonna say hey it's me so we see over here we actually are displaying just a system level notification of like so-and-so change their name like you might see in like riot or IRC or something and then if I send a subsequent message we can see now that that's coming through so we were able to pass this so using that same chat protocol creating a complex message and then just sending sending that so we don't have to have a bunch of protocol handlers one that knows how to handle more complicated data so we've went through the writing of complex messaging so we're gonna kind of whiny things down now and so really talking about like looking at next steps right because like if we built this chat application right now we're on the public network but what happens if we're trying to find nodes that run our chat protocol like a pub/sub protocol or who are listening to our pub/sub topic like if the network has millions of nodes or billions of nodes publicly like if you just join in and try to publish something you're you're likely not gonna find the person on your topic so how do we broadcast these messages from a set of peers there are millions of the network to kind of get get back down find who we really need to really want to send to so this kind of brings us back to the kadhi Millia DHT so what we're actually able to do is we create provider records and like again an IP FS these are content blocks in but you don't have to use a program ten blocks what you can do is you can say hey I want to take this pub sub chat topic that I have I'm gonna turn that into a CID which is a Content identifier so you would just need to for us this would be MPM install c ids is the module there is a CID module that's not right it's the IDS unfortunately the name was taken but ultimately what we can do is that we can then take that string of a lip PDB chat pub subtopic pass it to the CID and then we can do a find on the network for that right so what we might be able to do is we take this lippy to chat protocol and then whenever we subscribe to the topic we could in theory like query the network and register as a provider to say hey I am on this chat topic just like we provide content right i download the content I'm now a provider you can come and get that from me so here in the with the DHT we could do the same thing I'm like hey if you want to be part of this pub sub topic like come connect me I am on this topic so then any time we go to like additionally subscribe we put up we can also query the network and ask like who are providers like I want to join this topic and so we can find those providers that way and then join the pub/sub mesh from there and then gossip sub well we'll take it from there once we find peers gossip sub also incorporates a peer exchange so we can learn about other peers who are also speaking on this topic so that's that's a nice way of being able to handle that and you can do that in a variety of ways in the future again I talked about kind of like rendezvous services and that's like a federated version of being able to do this we're gonna do that hopefully in the next few months for j/s and the reason for that is like again running a DHT in the browser is pretty expensive so what we want to be able to do is actually use rendezvous servers so that you can register on the run to be serviced say hey I'm a provider of this hi or query for this those providers so I'm gonna kind of just open it open it up into questions now and if I missed a question from before please go ahead and and repost that a check you set up rules for caching topics and messages that your providers hold a few messages yeah so there's actually a in pub/sub there's a recently seen cache so pups I've already handles this because this is where they like I want I have comes in that cache right now is just a least recent you use cached so once you have too many messages in there it will drop out but in theory you could totally fork gossip sub or build on top of gossip sub extend it and then you could build your own you know your own cache on top of it I think three box I'm not sure if they still do this from thing about the right team they actually create like cafes and because like hey right now our chat isn't persisted but what you can actually do is like we can create that cache we can create that database so that wouldn't you join rejoin again you can get all that data back I'm not sure how matrix is doing that but I imagine they're doing something similar in terms of being able to exchange that chat any other questions again if you you guys are working through this and you want to go through the toriel off can you please feel free to ping me like you can ping me and like github repo hit me up on discuss I will be in the hack efest jet over the duration so you can also ping me there and I am more than happy to to walk you through this or talk about any more of these like complicated topics how about robustness in this whole system of protocols if we want better discovery I'm not sure what you mean there could we unmute siddhart hello yeah actually I needed to know the difference there is a cross on the console of that the library B to be the present cons yeah so like if you look at the benefit of lip EDP is really the the peer-to-peer system like having a decentralized system so that you're not relying on centralized infrastructure the consequence of that is that it's slower than in some instances a lot of instances it's going to be slower than centralized right and centralizes it's easier I can spin up a server or a multiple multitude of servers behind a like a load balancer and I can have tons of peers like coming to me and getting that information the consequence of this right is that like you lose there's there's one person who has it have youth like if you've ever been like part of an early adopter of a program or an application and then they just like okay we've ran out of money we can't support this anymore we shut it down we shut all the servers down like all your data's gone right unless they were kind enough to like extract all that for you so really what Lib PDP allows you to do is like bring some of that back make it peer-to-peer so that you're not reliant on these these centralized infrastructures that can just shut down a point in time thank you questions I'm just perusing for questions yeah I know people ask a few things throughout so if we kind of jumped over it Wow ticket was going through this tutorial feel free to raise that now I think I don't think there was a question earlier on circuit relays but I don't think I we passed over trying to find it good about the circuit how it might be shared when you're setting up a circuit and then sharing that circuit between different peers and basically being able to create multiple connections across that circuit or then you talk about sharing the connection so the whole idea of a circuit and what that was and then these all these other questions you can see are transfer questions for me like identification key exchange yeah that unencrypted and so links are fine you don't have to add them all here I just want to say I'm grateful I'll have thank you guys for making this a lot easier than a couple of years ago so thank you yeah so for for relays and this is one of the things that we're actually we're looking at improving the relay infrastructure one of the consequences for relays is that they are expensive to host especially if you're doing something like file exchange with ipfs or file and like running a relays like you're running multiple peers like file downloads to multiple peers that's like that's very costly and so you don't really want to do that and so one of the things that we're looking at doing is actually building limited relays and so what they would do is you would be able to kind of rate limit peers and do things like web RTC peer exchange like we could do distributed WebRTC so rather than using like centralized ice servers and centralized signaling servers you could actually find relays on the network via the DHT or some other every mechanism you can connect to those relays announce yourself so hey I'm listening on this relay then re advertise to peers on the network like the DHT or rendezvous service and say hey my new addresses are are here I'm now available at this relay from there you can also say ok I want to I want to speak with our TC star because I'm gonna browser so you'd be able to establish the connection over the relay do a very minimal SDP handshake cuz that's not a lot of bandwidth we can do that negotiate with other peers next to us who have some way of checking like NAT status or giving us SDP offers like decentralized ice servers and then we can do connection upgrade to there so taking that relay and then do hole punching and then say ok I no longer need this relayed connection now I'm gonna use the direct connection that we were able to just establish and then from there we can we can back off and do file transfer over like WebRTC but that would also work for anything like coordinating TCP simultaneous handshakes to to hole punch through TCP connections so there's there's a lot there that we're trying to look at like how can we reduce the cost because like relays are so so very effective at helping with this but we also want to reduce that cost of like not sending gigabytes of data over over real eight beers because that's not not very nice did I answer all of your questions somewhat if there's other follow-up ok yeah and that will be yeah those connections will be fully fully encrypted so why you're actually like sending the you're going through an intermediary peer right so there's always that that concern of eavesdropping but what you're doing is we have a relay we have pure a pure be pure a is going to establish a secure connection to the relay your B is also going to do that and then as part of this negotiation process these a and B are also going to negotiate fully cryptid an encrypted connection over this stream right so it's a virtual connection so while it's running over it all of that data is encrypted so like there's there's no chance you can't man-in-the-middle that like it just yeah it's it's secure thank you very much zoom is video streaming like a zoom clone built on the PDP possible yeah so I hope I didn't jump over questions I might have yeah there were two but go ahead with that one first okay yeah so video streaming you could you can do um ultimately the thing here is to be able to run run data channels and so there are things like I think there's already somebody working on not inlet p2p but using web web torrent to to run video streaming but it's entirely check out live pure so it's entirely possible to do that to run video streaming over that the big thing that are right is making sure that you can get that direct connection and so like web RTC you would want to make sure that you're using data channels to just send this information and there are like streaming services that are already using like WebRTC for for video conferencing talkie is one I'm forgetting one of the other ones but these applications where you're able to just open up a browser window and you immediately get end-to-end encryption WebRTC video sharing and that's all peer-to-peer like granted there is that initial SDP exchange so you have some central server but in theory that can be entirely done let p2p you could use in the future distributed WebRTC signaling to establish that data channel connection and then you can stream yes Jesse thank you so Jesse is the the other one that I was thinking about and sorry for skipping some of these questions go back can you brief you talked about exchanging streams over lib p2p for use cases like live streaming I think kind of kind of talked about that hopefully I answered your question if not feel free to follow up there from YouTube chat what level encryption is used when the message leaves the client so I assume you're talking about the stream encryption and this is this is noise or TLS depending on your security transport right so all of that data whether there's pub/sub or direct messaging before it leaves your node it's getting encrypted with with noise or sekai oh and so depending on which protocol you're using like that could be symmetric or asymmetric encryption it depends on the transports and so like those will evolve over time but you can you can change those like the noise protocol is the frameworks open we have a spec for the version of it that we we've implemented and so you can actually go look at the spec see what's going on in there look at the encryption patterns there but yeah it really depends on what version of crypto you're using is lit p2p I think this is the next one let p2p on mobile phone doable any existing team working on that already there are a few people working on it textile is actually working on they have some versions of Android and iOS for textile so that's like ipfs light so it doesn't bring everything in ipfs brings but it has like some portion of ipfs and then that's running lit p2p so it is possible there's like a java implementation which you'd be able to use with android and then for JSP to be working on is better support for react native because there are some folks who are going to be building more more react native apps so the big thing there is really again hooking up the Lib PB itself bundling that and react isn't too big of a deal we just have to get past like the JavaScript locals and then hook into like writing those custom transport or those transport bridges to get tcp or UDP from the phone itself from mobile itself and so that's really what we're looking at now it's like how do you bridge the transport of those modules do you pretty use numberless technique more than Libby to pee during implementation file exchange could you I'm not sure what you mean there if you could expand on that hello hello yes okay now I have I have the members last cake gigantic suits against the library the library p2p it's more faster than my authority but maybe it's not secure more than one more than the library to pee so I need to know more from you and more details about the more information and details about the security in the library you'd be to be ok I'll try to answer this as best I can remember less technique are you talking more about like permissioning for for file exchange mm-hmm so ok also like file all communication in lip EDP is secure so really the question is like do you want your application to be on the public network often times this just isn't the case like you might want to do kind of there's a couple things you can do you can run private networks that don't connect to the public network at all you can also encrypt those if you want with in the p2p by default we have support for symmetric private network keys so you can actually add a pre-shared key to your swarm and everything that goes over the wire like there's no leak of multi stream or anything everything that goes over the wire is encrypted with that private shared key on you can ensure no one on your network is able to talk to a public node and no public node is able to talk to your to your network so as long as those pre-shared keys don't get shared publicly like you can encrypt that entire network if you're less concerned about like okay I'm okay being open to the network but I really don't want to join the public network but I want people to be able to find me this is where you kind of get into some things that we've been looking at with the DHT II of doing like running multiple D H DS so in the future we'll probably look at lid p2p being able to run multiple dhts so what you'd be able to do is like okay for our application we're gonna run a DHD just for us and then we're also going to run a DHT on the public so that people can find our application you join the public network figure out okay I want to join live peer this app so then I can find peers who support that and then join that network in mesh n so this is kind of like this is really where I think the p2p network like should evolve over time is being able to like I want to join the public network and from there I want to find the peers that I care about and connected them like for like network security on universities and things like that like doing a full network privacy like encryption like that's a lot more valuable but if you want to be able to at least kind of stay public then that's probably the way to go is isolate those DG's thank you do what is the major difference between Lippe implementation on ipfs versus on aetherium so they're they're not really that different so ultimately the the biggest thing is the big differences there are what built on top of them so like I talked about at the beginning like disk b5 discovery that's the discovery mechanism that aetherium uses to join the etherium Network and it's not necessarily restrictive right like you could build an app on J s WP to connect to aetherium and get the modules and connect to the right place for JavaScript chain safe has a lodestar which is a client for aetherium and the other implementations have various versions of of aetherium clients but these are all built based on lit p2p so like noise is the same they might use different versions of dhts like might bring their own dhts so that's that's really at the core of lit p2p doesn't really change and that's why I like the PTP like we we are driven by you guys wanting to do things whether it's on ipfs or aetherium or anywhere else like that's that's what we're trying to solve like we didn't build originally lib p2p actually came bundled in ipfs and when we built j/s we actually built Lippe to be separately and then we ripped the go version out of ipfs because like this is a protocol that's valuable to to anybody building on non-public network so that's ultimately what we want to do and we've been working with the etherium community to make sure it would be to be works for their needs that might be it and we're definitely well over time so I'm gonna wrap it there no no it's not it's not you this is all great but we should probably not make just a two-hour video yeah that was that was really great I'm glad people about to follow along and see your process for all that so there were some people asking about where they could actually find the repo for this is that just now linked to the readme you had earlier yeah so just pull it up I guess you could just drop it into the slack Channel and that's yeah that's probably the best place to find it if people are still looking for it all right with that I think we can wrap thank you again Jacob for sharing some of your knowledge and the work you've done much appreciated we gotta get more people to is the constant issue nobody wants to put on their video so it looks like there's only four people here we have we had fifty earlier and looks like thirty people stuck it out again so good job folks oh there's Andrew Andrews jumping back in to give the golf class that was years years of me reading stuff and he just compressed into two hours yeah then he saved us all from Satan yeah yeah again Thank You Jacob and like I mentioned he'll be available in the slack with links and feedback as we move into the actual building part of pakka fess which consequently starts Monday or after they kick off at 12 noon I believe the actual hacking kickoff is at 1:30 p.m. Eastern so that's when everybody can open their repos and start start hacking I think that's it if you have at stake to make sure to stake we've got one more event like I mentioned the brainstorm session with Juan tonight and hopefully we're gonna wrangle a couple more people it's gonna be fun tonight at 8 p.m. Eastern and I think with that we can wrap thank you everybody see you in slack so every bite 