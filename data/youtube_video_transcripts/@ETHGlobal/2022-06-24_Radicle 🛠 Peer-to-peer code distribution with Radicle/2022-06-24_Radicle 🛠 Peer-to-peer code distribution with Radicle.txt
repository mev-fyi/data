[Music] my name is alexey or cloudhead i am one of the founders of radical which is a stack for um uh peer-to-peer code collaboration and sovereign code infrastructure and um okay and um [Music] yeah today i'm just gonna kind of talk about how it works uh how to use it uh what we've got what's coming up etc and try to fit everything in in 30 minutes but uh if you want to know more you can go on radical network and and you know i'm basically going to sort of go through the get started um stuff um and with a little bit more and some explanation of how everything works um so first of all yeah what's the idea so the idea is essentially to create um a decentralized alternative to something like github uh so a way for developers to collaborate on code and to publish that code in a distributed peer-to-peer way and so to to achieve that we uh um we created an architecture that is quite a bit different from the traditional uh you know client server architecture uh and i'm i'm going to talk about that a little bit but um first i wanted to just kind of actually go through uh the the steps in creating a radical identity and and uh project and all that stuff just so you can get an idea of how it works and then i'll explain a little bit um the the actual architecture of it the design and the inner workings so the first thing is um yeah so the [Music] way to set things up is via cli so that's kind of the onboarding uh we do is via cli so i've already installed this because otherwise you're you would have to wait 10 minutes for it to build um but essentially uh there's a there's a brew package that's slightly always behind master and then there's a you know you can also download from source so i have this installed locally and it's called rad radical and if we just type it like this you'll see a list of commands um and it's also going to tell us that you know this is the first time we're using radicals so to get started um type red auth to authenticate so i'm i'm going to do that and this is essentially going to ask me to create an identity and these identities are completely uh owned by the users so they they live um on your own device and then they can be replicated to other devices so you kind of own this forever um and [Music] i'm just gonna uh fill this in and so this is gonna you're gonna create a key pair um and so the the passphrase is really passphrase for the key pair so the the keys the private key is encrypted and it's telling me okay like you have a peer id which i'll explain but essentially it identifies this device so my laptop in this case and a sort of personal urn which is multi-device so it's kind of my user id that is across devices then it's telling me okay let's um you know you can initialize the repository uh initialize the radical project from git repository with rad init and so what i'll do is so i have this this folder here with a bunch of stuff and i'm going to um uh git clone one of my projects from github uh so i'm gonna do this and i'm gonna initialize um a radical project from this github project essentially so you can clone any git repo we're going to go inside of it uh right just a regular git repo and then i'm going to call red in it i'm just going to go back here and uh project name so this project is called rx um it's a uh pixel editor um written in rust okay cool i asked for default branch master all right it's gonna initialize this now it's going to ask me uh whether i want to use my radical signing key to sign commits and i'm going to say yes because this is going to well we can do pretty cool things when you're when when we use our radical key for assigning commits like link it to ethereum and to the rest of the radical ecosystem so i'm going to say yes you don't have to um and okay so the project is created it's giving me a project id which again is in the form of a urn rad kit plus some unique identifier and um i can now um yeah i can always show the project i like this and i can also now push this project to some remote and um so let's see what this what this says okay you can see this um so it's essentially saying okay select a c note to sync with and these are um essentially remote uh servers uh that kind of constitute a peer-to-peer network and um users can choose where to push their code and you can also have your own seed node um but since that's not set up here the cli asks you if you want to push to one of the the sort of public nodes that we operate ourselves so with the the foundation operates um so i'm going to pick a um i'm going to pick a node i might have already no yeah i'm going to pick this node um and so it's it's going to do its it's its thing and now it's um so a couple of things it's in the output here um we're using again this uh this radical key which is also an ssh key so it's compatible with all sorts of ssh things um okay syncing the project id we see that it's syncing it to this seed node here and then when it's when it's done it it's telling us that we can view um we can view this project online through a web interface so i'm going to um i'm going to copy this into uh the browser i have here and so that we can check it out so so this is the project and so this is this is essentially a um a web front end to uh the the radical network and um the interesting thing about it and it's kind of hard to see um but um the the code here is actually being loaded from the seed node i pushed to so it's this uh this web front end has actually many back ends in the sense of any seed node can operate as a back end to this bug front and you can actually see here it's going to be look very small but the the seed domain name is up here and i can put any seed in here and it's just going to load it up and show me the code from there um in in the in the interface you kind of also see if i zoom in the the name of the seed here which is telling me hey that the source code is actually being fetched from from from the seed and if i click on this um i'm actually going to load uh the the actual seed node so the seed has a lot of projects it has the one i just pushed i was testing the demo so it's kind of two separate projects with the same name but there's a there's a lot of stuff on here right and if you go to for instance on the on the main page you can see that we have our seed nodes here uh the ones you could choose from and we can browse them and uh right if i go to um to this test project it says it's loaded from here and so all of the data is coming from that different c node so you can have your own seed nodes that host your own code and it all kind of interrupts with the same ui all right cool any questions so far otherwise i'll keep going yep so i mean obviously you have your code on your machine also ideally you can also push to multiple seat nodes there's nothing wrong with that and we're also working on a peer-to-peer network for c notes to um replicate data asynchronously between them so yeah the idea is that um your code is going to be in a bunch of different places yeah uh cool um yeah so let's let's go let's go back here um so let's look a little bit at how some of this works um so radical is obviously it's it's based on git and um we use git um not just for for code uh like like developers but we also use it to store um all kinds of artifacts so things like the these identities that i spoke uh of so um yeah let's let's look at what that looks like so i'm i'm inside this this project rx right um we saw that if you do red dot you can see the the project id we can also do um this is kind of just an alias but we can also say hey let's look at the um the the history of this um project and what this is what this is gonna output is is not the source code history but it's the history of this identity and identities are super important radical because um it's kind of what let's it's what lets you have projects hosted in multiple different places but in an unforgeable way right so you know if you have a if if we compare this to the github model or github gitlab model um if you have the same project on github and gitlab well there's no way to tell that it's the same project right there two completely different it might be the same code and the same repository but there's nothing that allows you to say that oh these are owned by the same person right or that the username on on one system is the same as the same person as that username on a different system right so the the radical identities kind of solve this problem by um shipping this this document which is just a really adjacent document that is committed inside of git but not in your source tree and is signed by the owners of the project or the maintainers and so if we look at this um this json there's there's this thing called delegations and delegations is essentially signers it's like it's it's users who [Music] can sign on behalf of this project essentially and if i do write self this is going to query my own user identity and you can see that my year end matches the delegation here so i as the creator of the project i am the first delegate essentially and then the payload is um you know the stuff i filled in so name description etc and you can see here um uh this this key which kind of points to a previous version of this document so these documents are upgradable and uh and they work kind of like a multi-sig so right right now if i want to change anything about this project i can um just do an update because i'm the only signer but if there's if there's multiple delegates then we'll have to to have a quorum of signatures to update the document and then a second um update will a second document will exist that will point to the previous one um cool questions i'll keep going uh okay so what are the other things i wanted to show um [Music] right so let's look at um let's just look at uh the um [Music] our own um our own documents our personal document or identity um and so these um these are very extensible so the the the format essentially has an extensions area where you can provide um any kind of metadata you want with a certain schema and so one of the things we're working on is for instance associating uh these radical identities with uh ens right with ethereum um i'm not going to go through the whole flow here because i would need like a wallet and stuff like that but i can i can show some of it or like part of it um so there's an ens command essentially and here it's telling us that the local identity so this this one up here is not associated with any ens name right um if i do uh something like if i do well if we just look at the what we can do there's a bunch of things we can do and and the the you know what we're working right now is like having this this setup flow which does a two-way attestation between radical ens and then ens back to radical um this already works but you need to you need like an rpc node and stuff like that so i won't do that but i'll just show like the the local side of things and and i'll use this this command here to do rad ens set local i use my ens name and it's just going to ask me for confirmation and so now it's going to output essentially the new payload which has some extra information in it and if we uh inspect my username again now you'll see that there is the first uh the original identity and then there's the um new version of it that points to the that replaces the the previous one here right um and in here you see a separate payload that has an ens name and and this is good like we're using this to build start building um features that essentially um link code with money or code with uh ethereum and on chain state essentially um all right cool um let me just see uh what else i had in here not in here but in here oh yeah um so one thing i wanted to show was um a little bit of how the uh architectural looks uh under the hood um so i'm just gonna open this thing and i'm gonna move it here so what we've been looking at essentially is is this part here right radical user and we've been in our working copy essentially so this is the uh yeah just the checkout the repository checkout and the way things work essentially is that when you do uh when you do a rad push that i did earlier um what it does really is it it doesn't get git push rad with with us with a kind of rad url and we have a remote helper that catches that push and it actually pushes to a local um a local repository we call the monorepo because it's a repository that stores all of your code across all everything essentially all of your code all storage all all identities are stored in this git repository that is stored that is local to your machine and all nodes have their own mono repository and we use git as a transport as a protocol to replicate things between between nodes essentially and um yeah so what happened when i pushed is that it first it copied the refs to this monorepo and then it did a rad sync which essentially copies from the monorepo to a remote node and so in this case let's say you know this is like the the maple seed node for instance um the the the refs the all the git objects were copied to the other side and uh and on the other side again it's since it's just in the end git repository it's fully git compatible so a regular get user who doesn't have radical installed could do a git clone or can do a git clone directly from that uh repository via bridge and the reason we have a bridge is that this monorepo is not just a regular repo it's sort of like a repo of repos and i can show that a little bit if you guys are curious um and then to to to go back to the the question that was asked earlier uh on top of this there's a peer-to-peer layer that's in development that essentially uh um allows well asynchronously replicates objects between different nodes um according to a sort of tracking configuration so essentially a node or a user can say hey i'm interested in replicating these five or these 20 or 30 projects just keep in sync and then you know as long as your your daemon on your computer is running or uh whenever you activate a radical it'll sort of synchronize with the the peers it knows about and copy all of the refs and objects that you're interested in um yeah that's uh that's pretty much it so um you know there's there's other capabilities already and lots of stuff for developing but uh you know if you just want to list projects you have a radar ls you can um via the um i'm not in not in the project tracking is how you essentially collaborate so um essentially this is how you add peers to work with uh adam remote peers which when you do that essentially it starts to track their changes that's why it's called tracking and so you have a remote a remote for all of the the collaborator collaborators on the project and you can manage that and you can also [Music] list i mean this is not going to show anything here because there's i'm not like there's no one else on this project um but yeah you can list remotes on on various seat nodes when you're collaborating with someone um yeah i think that's that's about it um we're pretty good on time if there's any any any questions happy to answer them oh and in uh in relation to the hackathon uh uh so we're we're um you know we're sponsoring a uh we have a prize for someone who would implement uh the best sub command on the cli there's lots of kind of things you could do but just to explain how this works essentially it works like git if you have a command called like rad hello in your path then um typing rad space hello will invoke that command so it's really just a matter of creating binary and executable [Music] in that format with like name something like this that takes parameters and then um it'll be sort of it'll be picked up automatically by the by the cli installed locally so it's extensive in that way cool questions comments concerns no all right now there is a question um is there any incentive for posting your own signals we're working on it at the moment there isn't except you know if it's your own code i guess to just keep it available um but yeah this is something we're interested in and and we're working on so could you like uh have your own push everything there just be safe and then maybe push also to uh exactly yeah exactly and um one thing uh one thing that's maybe interesting regarding your like having a personal seed note is um uh we use ens for um we use ens to uh to map between uh you know user identities and seed nodes so you can uh let's say um wait that's not it let's say i go to clown head radical eat so this is my ethereum address or ethereum name under uh under the radical uh domain so um this is automatically getting mapped to my seed node and so i can browse my projects here right and so this is kind of how we're using ens to one of the other ways we're using ens to map between ethereum and the sort of physical server world um so you have a yeah one of the the ens keys is called seed host or it's like uh the key is a bit different of course but it's it's that's what it stands for um and that's how we can map between developer identities or orgs and projects hosted somewhere oh um i guess so on the on the website there's a couple things you can do the the main thing at the moment i mean yeah the main thing is like if you want to register a name under radical heath so an e and s name um the only advantage really over uh like dot eth is that they're kind of free forever so you just register you just pay once the tx fee and um and you're having yes name forever essentially um and then there's other things like we we're reworking this but um uh i don't want to connect right now because i don't want to get docs but my uh uh yeah like um you can you can essentially create orgs and stuff like that on here um you can edit your ens records um so like um the page i had before um this one here yeah so there's an edit button so you can edit all of these records from here also uh with your metamask or whatever um and what else um yeah there's more stuff coming up also we're gonna have like um ability to sign in with ethereum on a seat note to be able to essentially take actions as that node so do like server-side authenticated actions uh and um and things with um with uh also monetization so sending money receiving money stuff like that we have a team working on uh something called drips which are since essentially money streaming and uh um yeah that's going to be part of this also so yeah it's for all the ethereum stuff essentially yeah that's that's kind of what i said right like the yeah names orgs uh and uh incentive related things funding etc um if there's really anything else yeah we have a gnosis safe integration also for orgs so you can you can there's certain things you can do with that is there a chance that like these repositories you could just their data right could you address them on ipfs and then use igfs nodes like put them on ipfs yeah you can do that the reason we don't do that by default is that it's not very efficient because the the representation on ipfs is like ipfs is good for for big files essentially or it's best for big files when you're representing a git repo it's like thousands of small objects and um the the git protocol um is optimized for that so it'll it'll actually like the git protocol is an interactive protocol so when you connect to a node um uh sorry when you connect to it to a git remote then you pull or you push you're gonna have a negotiation phase where it's like hey these are the objects i have and you're gonna ask the other node what objects it has and then you'll just kind of the remote will create a pac file which is like a compressed archive of only the things you don't have on the fly and send you that and then you're going to open that pac file and apply the the updates locally and and that's something ipfs can't do right it has some optimizations of course but it's not it's really not nowhere near as uh as fast and good for that use case we tried it actually a while ago yeah yeah uh good question is it possible to maybe extend it functionality to include this stuff on top of it it's not really needed i mean um we are sort of extending git's functionality but without modifying git itself um i mean so this is actually something i wanted to show briefly um yeah so um if i look if i do this i can see sort of the the actual get refs that um are stored for this project and you'll see these these regular get refs that like all uh repositories have so essentially your branches are stored this way but then we have a kind of subdirectory under rad and you store other things like the the identity the related related identities a pointer to um yeah i appointed here it's your own id and then a um a document with all of the signatures for uh all of the graphs essentially and so it's it's it's quite powerful like there's a bunch of things like um like for example um for configuration we use get to like so the um the default seat that your uh you're using for a project is stored under git under the git configuration um uh yeah we essentially get is is already really extensible and so um [Music] we're actually not at a point where we've hit any barriers or any issues with with that all right all good thank you [Applause] 