everyone and for those who are listening to live stream because that's what they told me most of the people are um today tonight we're going to talk a little bit about proof of stake and the merge and actually i'm going to do it in spanish so i'm going to be practicing my spanish a little bit so you can help me out uh if i if i struggle when i struggle maybe and for those of you who only speak english i've done a similar version of this talk in buenos aires last week so you can find that recording there or ask me for it uh or talk to me afterwards um [Music] the proof of stake [Music] yes [Music] [Music] [Music] is [Music] [Music] um [Music] [Music] [Music] [Music] [Applause] [Music] [Music] [Music] mining pool mining farm and proof of work [Music] [Music] mentality existing and proof of work [Music] bueno marijuana [Music] [Music] ambiente incentiva [Music] [Music] [Music] [Music] [Music] is idea [Music] [Music] [Music] [Music] uh i don't know if that translation was right but common misconceptions [Music] [Music] uh uh [Music] how much time do i have 8th [Music] mexico [Music] gracias [Applause] uh but first i'm steph i'm a devrel engineer at polygon um you can also find me on twitter at oceans404 but the o is a zero it's kinda hard to read um but we're talking about evolving nfts i just wanted to throw this up because this is kind of my eighth global evolution the first time i was on the main stage was virtually on zoom and then in amsterdam so it's pretty cool to be back in mexico as a sponsor full circle okay so let's talk about nfts um and we'll just start with like fundamentals so nfts allow for the creation of non-fungible tokens for tracking ownership of different things so we've seen that as digital digital collectibles like the board ape yacht club collection but we've also seen physical properties being sold as nfts and then even assets with negative value like loans but this is just an erc 721 token standard so you can see all the required functions and also events uh if you create an nft contract you'll probably um extend a contract like this and you'll have to have all of these uh functions and events as part of your nft this is my pfp it's a doodle but what is really important about it is the token uri so the image the name the description and all of the different attributes that describe this nft so you can see the face has a happy note the hair is long and purple the body is a white puffer and one of the things about nfts historically is that if they're used for collectibles like my doodle it's pretty important that these images and also the metadata are immutable so that they don't change so that this stays a rare asset for different features that it has that the rest of the collection doesn't have so with collectibles it does make sense to have immutability but can you think of any other use cases where maybe immutable assets aren't as fun or they just don't fit the problem statement i thought of a few so the first one is in gaming if you have nfts or assets that level up or change the way they look based on different things that happen in the game another thing i thought about was a coveted passport so i have this really annoying piece of paper i have to carry around and then every time i get a vaccine or a booster somebody like physically writes it into my passport which is pretty ridiculous i think that should be unchained so a digital passport is something that could be a cool evolving nft also baseball cards uh i'm from la so i watched the dodgers hopefully cody bellinger never leaves but if he does his baseball card team would change and this baseball card wouldn't be relevant anymore and then this is just kind of a dig at board 8 yacht club because static nfts are boring but how are we going to build this so we're going to use polygon pos in tableland just to give you a quick refresher on polygon it's an ethereum scaling solution it's great because transactions are really fast they're low cost we're also going carbon negative this year which i'm really excited about so nice and sustainable and then tableland which you might have heard about i don't think they're here so i'll just talk about it but tableland lets us write sql to create tables to store mutable nft metadata that is governed by immutable rules and the tableland data exists on both polygon and mumbai so whichever network you choose to deploy on you'll be able to do that and so in this dap that i created i made two different tables a main table and an attributes table so the main table has id name description and image and then the attributes table has all of the different trait types and values that you would see as part of an nft so this is an example of one that i made today i called it tequila nft my spanish has been pretty bad this trip but i can always say the word tequila so that's what we went with for this demo but just to go back to the doodle really quick you can see that the attributes are the same way where it's an array of different objects and each object has a trait type as well as a value cool so i created some drink nfts i had five different images that um we can update and you can see that the glass goes down down down i actually sent these to some of my friends who who are in this room christina you have one kartik and jacob i also sent you drinks because i thought you deserved them but i'm gonna modify your nfts to drain your drinks and i'll show you how to do that which is pretty rude in the real world don't drink your friends drinks but we'll do it today so we're going to mutate the image url and then we'll also mutate different attributes two call outs for this the first one is just that the default for tableland is that you can only mutate data if you are the contract owner so if you've deployed it you can mutate it but you can override that behavior by adding something called a tableland controller which allows you to have like the owner of the nft mutate it if you were interested in that type of behavior and then the other call out for this demo is we're going to be manually updating the nft just like from the command line but you could do this automatically with chain link keepers or a different solution like that so let's get to the code i created a github repo for this um it's just under my github ocean's 404 it's called mutable nft's table land and polygon i'm pretty proud of the readme so take a look at that if you wanted to duplicate this or do it in your own projects it just has the two intros and then building instructions in case you wanted to deploy this yourself you would just create a env file add three different api keys for our mumbai alchemy key polyscan and then your private key and then you just install and you could run this smart contract to create your own contract um where was i let me get into the code okay so the first thing that's pretty specific to my tequila nfts are that uh this custom metadata generation i'm just setting it it's a naive solution i don't have trait randomness for these nfts i have three different tequila types and two different drink names and they're being randomly added as attributes attribute values these are just the starter values um i'll show you how to update these values since that's kind of the interesting part of this demo but i just wanted to give you a sense of how we're creating the metadata first so uh the first thing i did was just deployed that smart contract and i'll show you the poly scan of that so this is the smart contract and then each of the table land tables also has its own transaction and it's actually a little nft which is kind of cool i didn't know that but each of these main table and attributes table is minted as an nft that you also own as the contract creator so kind of fun okay so let's get to updating the metadata like i said i already deployed this but we're going to run the update metadata function to change some of these values around so i created a big block so you can probably update these on your own but there's two different update lines that i was playing with today the first one is changing the image so the main table had that image property um so i'm going to change the image to an empty uh tequila cup where id is zero so just to prove that we're actually doing this this is the nft it is full and we're going to change this image so that it's empty and it's an on-chain transaction okay so i have the image link here i am pinning it on ipfs and it's stored decentralized in storage but i'm just going to change this so that it has this new image and then i'll save this file and then i'll run the script to update metadata and we should see this image change on openc so just going into my terminal i'll clear that out so it's a little easier to see but it's just an npx hard hat run script update metadata and you can see the network is polygon mumbai so this is just doing a read of the different tables that we already have and it is updating that image and once it's updated we'll see the transaction hash and be able to look at that on polyscan cool oops so again back in the code we were just updating that main table with the new image where id equals zero and i really like tableland because you can write sql queries which is just super user friendly in my opinion so i'm just going to put in that hash transaction and you can see it was successful and if you look at the input you can actually see when you decode um this happened on chains so oops so you can see that this image changed where id is zero and now if we go back to this nft i think we'll have to run a refresh on the metadata because openc is a little slow but in a minute we should see a completely new image that is an empty cup oh not yet all right empty cup okay so that worked for nobody has ever cheered for an empty drink before okay so that's how you would update an image but you can also do this for the actual metadata properties so right now uh the drink name is margarita and the tequila type is enjo somebody correct that print yes okay you look like you know your tequilas what is your favorite type of drink we're gonna change this metadata tequila sunrise okay that's the orange juice one right no shade [Laughter] okay um so i'm going to change this value to a tequila sunrise i commented out that line above just so that we have it for easier reference but we're looking for trait type drink name and we're updating value to tequila sunrise where main id is zero because it's that first id so i'm going to run update metadata one more time we'll get a new transaction hash and hopefully we'll see a tequila sunrise and i'm not super artistic but if you were and you wanted to play with svg data you could um do fun things with pixel art uh to actually make it look like the drinks someday i'll i'll get to that level of artistry so we're just back in poly scan looking for that new transaction it was successful 23 seconds ago again we'll decode that input data and we see tequila sunrise at id 0. so let's refresh the metadata one more time and we have an empty tequila sunrise [Music] all right i'm just gonna go back to my slides cool so yeah check out that repo um i hope it's relatively easy for you all to change values and stuff in case you wanted to create some mutable uh nfts this weekend but just wanted to go over the polygon prizes one more time we have four different prize categories for the following problem statements so public goods refi which is regenerative finance metaverse or gaming and then the best ux or user onboarding experience to your dap so really excited to see what you all create we'll probably give away two to three prizes in each of these categories and then here's some developer resources if you want to take a picture of that they're also all online so you should be able to find everything if you can't come complain to me because that's bad user experience cool and then this is our polygon devs twitter a lot of my teammates aren't here this weekend but they love to see what you're building so tweet at them and use the hashtag onpolygon so that we can amplify your work and then last but not least wag me i'm in the middle next to jordy this is an iconic photo because he is um like the creator of zk evm and i'm not worthy to be standing next to him but fun photo all right thank you so much feel free to come up to me and ask any more questions or just chat tell me what you're building and yeah have a great weekend [Applause] uh thank you for coming to the welcoming workshop this workshop is just a quick introduction of how to use swallowconnect i'm first going to do it in english and then if there's any questions i can also do it in spanish again just don't have so i'm going to start uh so while connect is basically a remote signing secure signing protocol uh it allows for easy integration with between wallets and and apps by using a qr code basically allows you to sign transactions from your wallet without your private keys ever leaving your wallet the the main integration point with wallop connect is with this qr code and we have we provide a specifics a pacific um i'm just gonna skip this we have a specific um application uh or package an npm package that you can use to get started with walla connect this is the web3 model and basically it's just a single provider that you can see here in this image that gives you the ability to either use metamask wallet connect torus coinbase it basically allows you to use any web3 provider with just a single npm package so if you want to develop a dap that is enabled with walla connect you would use this uh this npm package let's just go through it so this is the the package that you need um this if you already have a dap a website that is already set up all you need to do is just to add this dependency for enabling the web3 model and then let's show you how you can get started with so this is the the easiest way to get started with the qr with a qr code pretty much by setting it up with this uh object you can see that in the object we got with three model and then we pass it an object parameter and we have the network main net and you need to get a inferior and inferior provider uh and if you're a project id and just to repeat this is just for version one of all connect i should have mentioned this earlier version one of all connect is the current most stable version of that we have right now and it's the one that you're likely going to have the easiest time with uh the from our perspective the bad things about version one is that you can only use for evm chains and i'll i'll go over v2 later but this is just if you want to have a working dap we recommend that you use v1 for now um so once you have the the um the web free model initiated you can do the dot connect and this will allow the user once they click on the connect button to it will display this four options and then you can just select on the wall connect option that will display to you a qr code that you can see like here it will display qr code they can just scan with the wallet so while developing adapt with using this web3 model you will get return this provider object you get given this provider object this is the traditional provider object that you might find in a lot of the apps that you use and this provider object gives you basically some events that you need to subscribe to just to get an understanding of when the user changes in a wallet or when the user changes the chain and it's important to follow the the event types just to have an idea that you know what to expect and so we recommend that you pay attention to the eip1193 stand event types and this is what the provider object will will be following the standard that's going to be following so sometimes you want to quickly test with one wallet and then you want to disconnect it's like okay you know i want to i want to test it with another wallet we recommend that you also clear the cache just to make sure that you have a complete uh clean uh session because sometimes when you reload the web browser i mean the website you're still going to have the previous account saved in the web in the web3 model and so it's because it has a a browser uh cache for remembering the previous accounts that it interacted with but for development purposes it's better to disconnect and also clear the cache provider just to make it easier for you in your lives and don't have like a laggard accounts left over and that might interfere your development process during this hackathon so this this is the same package right you can you have at the bottom left you can see all the different types of providers that you can that you can use we you have wall connect you have coinbase wallet uh the web3 object or like metamask um this there's a big lester you can see um what what should uh if anyone wants to scan these stocks i can now now it's the time there's more qr codes at the end so yeah so just to repeat the easiest way to interact with while connect is to first use this package this web 3 model package that gives you this react this interface that you see on the left on the left that has these several options and with these options you can have a provider object that allows you to either send transactions and send and request information from the wallet i recommend that you look at the docs so you can understand the full scope of features that this web 3 model package can can give you for developing your dap here's a very good example repo it's basically a a quick start for a dap and it has the web 3 model enabled and yeah this is like the easiest way for you to get started with wall connect okay so everything before here was preparation one and i want to be clear that for this hackathon that version one is the easiest way to get something working for you now for we have also a version two recently that we just released and we're trying to push it more because that's what we're the direction we want to take the the the software the our our sdk uh right now the version two wall connect doesn't have a web3 model so you would have to fork one of our existing example um repositories that i'll show you later and the only api that's supported is the sign api so it's like you can sign for transactions and you can the wallet can respond right now these are the wallets that support version two so this is a good list in case you want to be testing them just to have an idea because not all wallets currently support version two of wall connect we have a a website a react wallet that you can use for testing purposes so if like for example you actually if you find something that's not working for you you can go to this react dash wallet wallet.wallaceconnect.com and that should provide you a a very simple browser based wallet that you can then uh use with welcome expression2 and then on the right side you have a react app that is using well connect version 2 at this at this domain react app react app.walconnect.com so just to be clear just repeat what i said like these are some wallets that already have integrated wall connect version two and so it's not all of them just so just a specific list but if you find issues developing with these uh wallets that that's on this list we also have this react wallet that you can use for for um version two uh another important thing for version two is that uh we have a a project id gateway that you need to use to set up your your um your uh your provider uh you'll see in the docs if you go to in the docs website while connect you will see the instructions of how to set up a version 2 while connect client and it's important that you go to to set up your project id so you have to get a project id before anything else for version 2. this is indifferent this is different to how v1 where we don't have a project id on the other hand um version two we do require a project id and you know recently we just released this new feature with sign in with ethereum uh just recently for our own website so it's actually quite easy like you just have to if you already have a version one of wala connect you can scan the qr code and you can basically create an account and get a project id without email just a a um theory matters so you know please try it out and we're quite excited about just this feature um yeah um so on the first qr code the v2 websites this is the repository which has there's a lot of qr codes here it's probably a bit too crowded for this um so this has all the information you need to get started with version two um for v2 for version one two and also um the whole repository our whole organization [Music] yeah so that's what i have for now any questions i should answer or any curiosities go ahead yeah so yeah so just to repeat the question uh the question is like how do you uh do a request for a transaction and and the way you do it so both both metamask and wallet connect would be providing we'll have this provider object and if you look at the our documentation for the web3 model um should i have the qr code my pen yeah so if you look at the comment documentation for the the web3 model you will have you have some quick starts on how to request for transactions and the the nice thing about the web3 model is that allows you to use both metamask and wall connect at the same time so it's a user choice so you can request a transaction and there's examples on how to do this in the uh docs that are here yeah so just uh if you have like if you want to test different evm chains uh you have to pay attention to listen to the chain change id uh event so like if you want to listen to like for example polygon mumbai or some other evm for version one of all connect like some evm chains um it's important to pay the wallet initiates that uh change request so the wallet sends to that it's like okay i need to change the chain id and then the data that is with using this provider has to listen to these events for the what the chain change so this is just something important if you're using multiple chains um for development purposes i the metamask mobile wallet is good uh the rainbow wallet is also pretty good but you know there are a lot of are there's a lot of wallets out there that use well connect and you know just use what's your what's best for you um yeah any more questions and you know i could try to do this again in spanish it's not going to be as good but uh you gotta try in spanish okay [Music] is [Music] [Music] uh um m [Music] okay [Music] is [Music] [Music] project [Music] [Music] foreign [Music] [Music] a uh [Music] [Music] [Music] um [Music] is uh foreign um um foreign [Applause] um yeah we are here to talk about why crypto is really really awesome before of that though uh i would love to tell a shoe of hands who here understands spanish because we may be able to listen in spanish if everyone understands it otherwise no so if you understand spanish put your hand up that is all but i think we're going to fall back to english still but uh thank you for that you can if you have any questions about that you can come ask us in spanish afterwards but yeah we are welcoming and we are here to talk about why crypto is really really awesome uh that did not switch there that seems wrong there we go okay so crypto is really really awesome i don't think i have to explain it i feel like everyone agrees why crypto is really good it has unlimited distribution it's a centralized all of these really cool things the issue though is that well it is really really cool it has a big hoarding problem where the people that got to it first kind of like got most of it and now the new people getting in have less advantage it's like less inclusive you have to be early basically and at work when we have this idea of what if bitcoin has started by giving one person each person in the world one bitcoin how would the network effects played out how would accessibility to this technology improve the world and so bitcoin is unfortunately really expensive so we cannot just like buy eight billion bitcoins and give it to everyone but we thought let's do it with a different currency let's do it with a wall coin and pretty quickly we got into a big problem which is if we're if we're going to give something that is valuable for free to everyone people are going to try to game it they are going to try to claim multiple pieces and so how do we make sure that each person only claims their part once and there's this thing called civil attacks it's pretty common especially in like airdrops from the company which is from different projects which is when someone just like creates multiple wallets and pretends to be multiple people maybe they're doing like some activity to seem active and then just like give them the money and they sell it so that's not really good for the project that's not really good for pretty much anyone except for those people and that is called a civil attack and we we wanted something called civil resistance we wanted to be able to tell people online and we wanted specifically something that was both private inclusive and scalable something that the whole world could be onboarded into something that didn't require you to give out your personal information and something that didn't really differentiate from early or late that anyone really could sign up to something universal and so we started looking into the options asking for email or phone serves as a way of identity but it's like i i personally have like more than 10 emails so it's not super civil resistant then maybe you could ask for a passport or an id but aside from like some people in some place of the world not really having ideas this has a big problem with the privacy part because then we need to store your info then we looked into something called web of trust which is when people authenticate other people and the issue there aside from a bunch of like mathematical stuff is that you need an initial web of trust source so you need an initial set of users that you trust and then people that are like super separated from those people maybe someone here in latam if this gets started in sf will be it will be much harder for them to get authenticated as human so it's not super scalable and then we looked into biometrics which is something that everyone has it's relatively easy to sign up and say okay maybe this will work and so there are multiple biometrics that we could use the most important measure here was what they call entropy the whatever we use has to have enough information so that we can tell eight billion humans apart an example of this is the fingerprint you cannot like fingerprints are not different enough so that you could tell eight billion humans apart just from the fingerprint and also if you make a little cut on your fingerprint now it's a completely new one so it is also super simple systems we have the face but the face kind of has the same problem um face id from the iphone can tell you apart from around like 30 million people obviously it looks at 10 attempts but if 30 million people try to unlock it one of them could so it's also not super scalable for us we have the palm which has the same issue with the fingertip where you can just like make a little cut or have someone finger in the middle and that's again a unique one you have dna which could make me work but aside from being even more creepy than scanning your eye it's also really expensive to process and takes time and it's amazed so we go to the iris which stays constant after you have grown up and it's unique it's easy to verify and it's really really hard to change and so we started looking what can we use for these services maybe we can use our phone cameras turns out you need a really really high resolution for these things and the phone cameras are unfortunately not enough same thing for off-the-shelf devices devices that are built for this like whatever clear uses or all of these other sources these also have the issue of they're usually made to verify not um identify so what that means is you will put in your id and it would say okay let's make sure that this is miguel i'm going to check their iris with like the iris that we have stored for miguel what we want to do is make sure that my iris is known in a list of 8 billion eyes and so those tools are not built for that and they were like okay maybe we have to build custom hardware and that is not great no one wants to build custom cargo it's a really really hard problem but after a while we ended up building this thing the arm this one is the special mexican edition um which basically takes care of um making sure that you're real making sure that you're not trying to trick it by scanning a dead body or a pet or just like showing a picture of an eye to it and then it will look at your iris and it will compute what we call an iris code which is then used to register you without actually having to save the photo of your irises because again privacy is really important and so we have a solution that will our is this thing one slide kind of have the feeling that every time that i press the button it's just like one slide below anyways we can work with that i'm just like sorry for the context before uh but um basically we have a solution that doesn't require images or your name or contacting for any or any ways or traditional kyc we just have this iris code that is computed from your iris but that's that's not really enough we wanted something more because even with the system if we just like said okay this wallet is verified then you can kind of track your wallet across different usages of the protocol and figure out who they are and so we looked into using serialized proofs now we jump to anyways we looked into using c knowledge proofs in order to fix it and we ended up with a system that is pretty complex jumping around anyways we ended up for a system which is like pretty complex but it works really well it preserves your privacy it's fully private some even maybe anonymous where you can just like get scanned it you get added to the list and then you can anonymously verify that you are on the list which are the building which entry of the lease you are so this was great we said let's let's go outside straight out we went all around the world to more than oh this is like delayed a few seconds okay to more than 25 countries and we tried it pretty much anywhere that we can think of we onboarded we onboarded more than 650 000 people it's changed a little bit since this image because we keep growing and it is fully open source as well uh you can check the core the code for the open source protocol and we're going to continue open sourcing the hardware of the orb and everything else but there was one thing that kept coming up um since everyone was saying you built this whole system to give out your coin to give out wall coin to everyone um isn't it a shame that you can you're only going to like use it once and then throw it away and there's a bunch of other apps that could also use this civil resistance that you're building and something that is scalable at this why can we not reuse it and yeah we want to rebuild that and we build a protocol called wall id which allows you to reuse the same security and verification that we have created ourselves to do all of these things and so quality is a protocol to anonymously verify that first of all someone is a real person but also they've never done something before like claiming working or boarding a governance proposal and it does this completely anonymously it will not reveal any information so for example i can prove i'm a real human and i have never claimed well coin or i have never voted in nepal or mint nft or redeemed this air drop or even completely wept to things like join the discord or follow someone on twitter and the system that enables all of these is really really complex specifically because you want to maintain privacy but the really good news is that you don't need to really care about any of these things integrating this whole thing into your app basically takes um [Music] this code you put this in it will show a captcha like widget which is um there that captcha and so users can just like click that scan the qr with the what that shows up with their welcoming app actually using qualcomm we saw before and then um you just like verify that either through an api or on sale with our contracts and there you go you have saved resistance so for example if you have this example airtop you literally just have to add a wallet in there and there you go it will pop in the app as this application once we file your human you click verify and you get the whole thing that you can then verify anywhere so it's really really easy and it's really really powerful too it's super flexible we've been talking for ages about all of the really cool things that uh having similar systems could enable and and now we have civil systems so we can start playing with all of these forms of quadratic voting and funding we can do errors we can do social incentives all of these really really cool things and also you can use it obviously right now we have um developer.working.org we also have wallpain.org slash mexico which has all the resources that you guys will need and just like to show again how easy this is paolo here is going to actually add wall id to them to an app from scratch so we're going to take an app to mintapo app and we're going to show you how you would make that civil system it's a really simple app it doesn't even use insane it makes use of the api but i feel like it's a really good example of how you how easy it is in literally five minutes to make sure that your users can only make an action once or register or any of these things um while that's loading i'll share a bunch of examples of what we've been using this for uh one of the things that we've been doing is we have a discord bot where discord has this really big spam problem traditionally even though they have captchas for signing up because someone can just like complete the caption multiple times and then you're going with multiple accounts and start the eminence spamming people and so we made this spot that allows you to verify quality once you join the discord and then it will make sure that you can only have access to the channels that you want to your users chat to if you've been verified once so that makes sure that um that make sure that only one one account per this one account on your server will be a human and also if you want someone they're gone forever they cannot come back so i feel like it fits really well the idea that we traditionally have of one user equal to one human now paolo is going to demo how you would set up from scratch all right thanks miguel i'm gonna do a live coding session show you how easy it is to integrate world id this is a demo so hopefully something will go wrong but let's get let's get started so easiest way to get started with world id is going into our developer portal our developer portal will walk you through all the all the ways that you can integrate world id and basically we have two ways you can integrate on chain or you can integrate with our api under the hood the api is doing the same thing it's calling our smart contract to verify everything on chain we just abstract that complexity for you if you just want to do something off-chain so as miguel mentioned what i'm going to do is show you an example of claiming po-apps but you can only claim once verifying that you're a unique person claiming a pull-up so we have this very simple uh website where i can claim a po-app but anyone can come in and just uh get all the pause for themselves so what we're gonna do is we're gonna we're gonna create an action in our developer portal should be very very simple um this is the important part where you select if you want to run this on what we call cloud which uses our api or if you want to run it on chain we're going to do cloud for this example and create an action here so it's going to give you like all the instructions of what you need to do which we're going to skip for now because i'm going to do it and you the only extra thing that you need to configure is how you want to display uh the the verification in the world coin app so you can say something like uh claim my po app once and you'll get here something called an action id the action id is what scopes the uh verification for the user so when when you get a verification from world id you'll get three things one is the zero knowledge proof that verifies that you're a unique human two is the merkle root which uh aids with that verification and number three is a nullifier hash that hash is quite important because that is the unique identifier for that person for your app so you can use that as a unique user identifier but the cool thing is it will not uh track users across apps so i'm gonna i'm gonna take this here and then uh we're gonna start with the development so i'm gonna set this um action id now i'm i'm gonna install here the the the world coin sdk sorry i think i need my glasses looks like internet is not helping us out here there we go so i i just i just need to um very important if you're using next uh the javascript widget uses a dependency that requires windows so you're gonna have to do a dynamic import should be quite simple so you import the widget we're going to say statistics widget props and i have the widget so i'm gonna i'm gonna insert the widget here the signal is uh a string that you need to pass it's part of the zero knowledge proof verification it's an important security measure depending on what your app is in this case uh it's not necessary so i'm just gonna add an arbitrary string i'm gonna you mount the action id and then we're gonna say on success set proof which we're gonna create here all right and then we're gonna say like don't let the person claim the pop unless the proof is set and we're gonna run this so now i have the the widget here now i need to verify the proof so i i'm gonna go to my handle claim process and then we're gonna do call the caller api here where we send the signal is my pop and then the proof and then if the response is successful we're gonna redirect the user to the claim url and if it's not we're just gonna console error and then set error error claiming there we go and this is our api request so the cool thing is like if you're if you're using our api in the developer portal you just need to call our api to verify that the response so it will look something like this there we go and then we'll just send rekt.body and then again if verification response is successful we'll send the pop url if it's not let's just send an error and i think we should be fine here oh we're missing and i wait all right so let's try this out so i'm gonna i'm gonna verify i'm only claiming my pop once i have my world coin app here which you should be able to see so the user the user flow is the user clicks on the captcha then on your worldcoin app after you've verified a nerve you have your world id you scan the qr code we connect through wallet connect which is like a pretty cool thing you get here the prompt you can see here this is what we configure claim ipod once you can add whatever whatever text that you want and you can do the verification one once the verification is done i can actually go and claim my po app um looks like there was an error oh thank you we i missed a little thing here let's try this again and i can actually go and clean my pot and the cool thing is if i go back and i ask the same person using the same world id try to do this again i'll get an error saying that i previously verified this so it's quite easy to integrate if you want to go the smart contract route you should just go to our starter kit uh it's worldcoin slash world id starter we have a very simple smart contract that will let you uh do the this verification on chain as you can see the the the critical code is just uh calling our smart contract to verify the proof and if it's valid you just execute your action if it's not valid it'll just revert so uh should be quite simple if you guys have any questions we'll be around and we're happy to answer english or spanish and yep thank you so much [Applause] we can go we can do um we have uh 20k in prices we have three main prices we have two honorable prices and then we have a pool apple for everyone i yeah and we also have the notion we have this url that you can go to which i mentioned before um worldcoin.org slash mexico that has all the information about the prices starter resources the documentation the developer portal everything that we mentioned here and everything that you will ever need it's on the pc again it's wallqueen.org mexico and as i was saying before we have 20k in prices which is uh for best use of the protocol we have 5k uh 3k and 2k for the three best uses we also have two 1k prices for honorable mentions that will make the top still really cool and then we have 8k distributed amongst everyone else that qualifies and yeah really really excited to see what you build like we said i will be on the booth most of the day we're also in the discord uh anything that you need we're willing to help in english spanish and good luck [Applause] nice this feels cool i mean like i flew in from europe yesterday and this for me my body is probably kind of giving that talk at an after hour at six a.m in the morning but uh let's do this eat sleep hack repeat um yeah what i will do is kind of a quick start to sub graph development and also querying i mean the problem with a lot of depth when we talk with them about the graph is like they are a little bit afraid about the technology because the graph is such a powerful thing but it's also it seems like at the first sight overwhelming like how get into it and how can i use it and what exactly does it i think it's cool everybody uses it but i don't know how so i want to kind of reduce that fear and give you kind of um you know a quick intro so let's have a quick repetition about what is actually a smart contract so i think about the smart contract actually in in the thing that is just data so it's structured data that's lives on the blockchain it's immutable or kind of actually mutable and then you have rules how to change that data that's a smart contract basically and the smart contract by itself it always knows about its current state who owns which nft right now but it does not really know about historical state but the blockchain knows but the smart contract by itself knows only about the current state so let's look at that example so if you look at the you know standard nft smart contract this is the data like you have just a list with uh with token ids owners and then some random metadata uris if you're lucky then they're not on google cloud but um yeah and that's that's the state you can always create this market like who owns which which um token but what you don't know like by just looking at the state of the smart contract who owned it before so that's problem especially for nfts like there's this big word about the promenades but also other stuff that's interesting that when we want to look into the past like for example on uni swap how did the prices of a pair kind of develop or how did the tvl of a certain protocol uh change over time and very interesting data that but you need to look into into the past of the smart contract state right so it would be nice to have kind of something like a time machine right that you can just kind of go back in time and see like how was the state of that smart contract yesterday or like before yesterday a week ago and so on so forth so that's one way how you could look at what the graph is it kind of gives you this possibility for this time machine but not only that or kind of to understand it a little bit better first i said like the smart contracts are basically data and rules how to change the data and if you want to change the data what you do is you send a transaction to the blockchain so that that data actually gets changed right and that's what we look at with the graph we look at the transactions another angle on the whole thing is when you start to develop depth so initially kind of in the early days of ethereum there was this idea of having the user interface you know just html css and javascript deployed somewhere on a decentralized storage censorship resistance and so on then you run your own blockchain on your computer right and then you download that front end on your computer and start to run and start to interact directly um but yeah there was a problem that because the blockchain by itself is right optimized and the json rpc interface that you use to interact with your node is also kind of it's it's for writing data mostly the reading stuff is a little bit kind of after thought but like the modern frontends that we see today like usually you read data right you want to see kind of how did the token price develop who traded which and what's going on and there was there was not really really a thing that's also why like a lot of centralized companies jump in to fill the gap to kind of provide that data in somehow in an efficient way but we want to be decentralized right so in the wild we see code like this i mean this was actually one of the projects that i worked with kind of looking at the code and and for those that understand javascript you see like all these await statements those are then kind of the the loop through an arbitrary big number of balances and all these await statements they get 200 300 hundred milliseconds to resolve and if you have like ten nfds or of 20 nfts here and all of those are awaited and then in the end kind of this simple page that just shows you how your nfts take seconds to load which which is a super bad experience right like um so which how should it be like you should have like a user interface on top that actually writes the blockchain and that you have kind of this indexing query protocol in the middle that gives you this data efficiently so in the end you can write queries that look like this right kind of very nice and uh you know i love graphql because it's such a nice language so this does actually the same and like to send this query it's kind of a matter of milliseconds so so this is actually where the graph comes in you know it's kind of these apis for for this vibrant decentralized future like on the host service currently we have roughly one billion yeah billion queries per day uh big names like audios uh uni swap m stable enzyme uh used to graph uh it's kind of yeah it's it's well well used and and now there is also kind of this decentralized indexing uh network protocol launched like one year ago so you were not not only able to kind of use the centralized hosted service which which was a proof of of concept but uh you can really have like decentralized subgraphs and data so there is kind of this network with 170 indexers that are kind of uh individuals there's this red and redundancy across the world it's fast cheaper while reliable and like we're going towards this global open api so in the end you can build truly decentralized steps but again so to get back to to what's what we can do here is like there are two bounties from the graph and i show you how to get those now like there's the best use of an existing sub graph which is a little bit easier uh so we have a winner and a runner up so the winner gets 2k and the runner 500 and then the best new subgraph which is more heavy but also more cool to do is um it's the same so it's kind of a little bit of strategy so what do you want to do do you want to do the easy stuff but you have more competition or do you want to do the hard stuff so but it takes you more time but that's up to you but we're happy to help bonus points for the charging is if you go with the new technologies like substream i do not talk about this in that talk but you can read online or you use the decentralized graph network right so how do we do it um yeah a subgraph explained again is kind of this thing very very right at kind of a data structure it's it's actually a database for those who know about databases and then you have instruction set so you look at the blockchain what's going on there and then you start to write in the database so you have it easily retrievable later on um so you can think about the transactions on the blockchain are kind of a mess you know everything is kind of in on the same thing what you want to do is kind of you want to kind of have like the databases per protocol so you can easily query it and make sense out of it um so roughly that how it works on top you have to dab you as we said like you send transactions a smart contract to change the state which will emit some events the graph node kind of having the information from the subgraph we'll take those events put it into a database so that on the other side you can then just query that database and have quickly your front end so in the end like a sub graph it's more left what's going on here you have this mess of uh of different stuff and magically it kind of is organized in a way that you can reuse um now you have learned about the graph so you can now scan that qr code and tell all the people that you learned about the graph marketing team told me to bring in the slides so you could do it or not three ah one more a few more you wanna do it nice um you got it cool thanks so nft subgraph development like i always use nfts as an example because like you understand it's like it's the super easy thing so how does an nft contract look like you have a transfer event which is the most important one actually and then you have those functions kind of balance off owner which are read functions and you have to transfer from which is a write function um more or less that's it there are there is some other stuff around with allowances but in a nutshell that that's kind of an nft you just have some contract that even emits that event and kind of provides those functions it's very simple but that's also the beauty because you can build so much out of it but it's also easy then to index so i have some tips tricks here but we skip through these because i want to show you also how we can query but the slides are online so it's more kind of a reference for you so you can think about like what queries do i really want before you you start to write the subgraph for nfts it's kind of the how many nfcs are in total who owes what what's the pronouns we have kind of a rough schema how you would model that in a database so you have a contract which represents the collection you have an account which are the owners then you have the nfts which are then linked to the account and also the contract then you can store all the events for later reference and store the metadata if you have it and trades also if you have it that's roughly how i would model it and then what you do is kind of you install dependencies find the contract and then you start to initialize and then you just deploy it to this to the studio and then you enhance the subgraph and then deploy again and so on so forth until you're ready and then you can publish i also have kind of a collection of pattern in this presentation but it's also probably better for looking into that later but they are here so it's kind of some stuff that it could do but um i would say let's just do it can i go into this terminal list or something no right okay so you i hope you have graph installed right on latest version so what can we do we can go to um either scan and uh i know i could just go for a random nft and you can just copy the contract out actually you can just do graph in it dash dash um what is it index events and this dash index events actually it's kind of the trick to make the initialization much much faster and we need to document this a little bit better but like uh now i'll tell you and if you do this then a wizard starts and then they ask you so okay which protocol do we want to index the graph supports rv theorem near cosmos uranus theorem here so let's go with ethereum then like in which product you want to initialize there is the subgraph studio which is the new one where you can publish your decentralized network so we always go with the cool new stuff and then we give you this log so let's name it hash masks sub graph all right directory to create in yeah let's let's go with this hashmas subgroup why not then which uh then before we we use the protocol now we kind of take the chain so we go with your main net contract address i already got it so it's this one you just go with the address oh um what did i do wrong just try again studio address all right yeah the alternative is that you have the api um maybe for the hackers around you uh especially when you start to write your contract you can also just add the path to an api but i think it would take too much time here to do this but actually i want to show you anyways there is a much cooler possibility currently with new tools so now we have the soulbound studio which more or less does the same that i've just tried to do uh in in the command line but let's see maybe this is a little bit more um more reliable so actually how this works so you can go on the sole mounted x y set and then there is the sub graph canvas right and um here uh you have very nice ui so we can give it a name i don't know what's going on here i don't want this so we do we add a contract and now i can paste in the address and what it does in the background kind of it starts to download the api and and also resolves the start block eventually nice and then that's it and i can save this mod the smart contract and probably now in the explorer here nice okay cool so you see i have to i have to contract um and and and you see okay the contract has these events so we i have the approval events i don't really care about the approval actually like i just want the hashmas to have a funny feature so the names of the name change event so uh well let's let's change this the ownership is also kind of just internal and then the transfer so you can easily go and say like okay i want to just index those events and here they are and it's all kind of prepared for you and go back to edit sub graph maybe i need to there are box today i'm not lucky with my live coding or maybe maybe it's because of this i don't know it's about yeah i know that they worked on it today and now also this demo doesn't work but what we have is the abi so let's go the other route again oh i cannot con i cannot work with vi on on the english keyboard let's do this any private data that would reveal if i do this or maybe let's do a new folder all right okay graph init index address i will see that coming all right yeah the dependencies will take some time probably in the meantime um so what it does it it now creates the scaffold which is cool so we can go to um the graph.com studio or actually if if you want if you want to follow then you have it here in the products you go to studio oh yeah sign and then you can just create a sub graph you get minute hash masks continue and actually you just need to do graph off let's see where we are here so what we have here is now it initialized the subgraph for us already so you have to subgraph yaml which says like um which which source we can also add to start block here which is you can see it the transaction when it was deployed it saves us time thinking and so on so forth you also have like auto generated schema you see similar like all the events are just indexed and you have also the auto-generated mappings so you can easily just get started with that stuff and don't don't need to overthink and um yes and i would not really do much now we just kind of say yeah that looks good just deploy i need probably need to do a graph code then first yeah nice deploy nice it's here see it's already sinking and oh did it fail now no and then you can go already in the playground and start to yeah and it already see it's already starts to have data very cool also when you do this here um you see this this uh query endpoint and this actually kind of the next thing how to create stuff from the graph so in the from the studio you have this graphical endpoint that you can also use in your front and then but you can also go here and start to um inspect and i know for example like the hash masks they can change names so i can say like okay id name new name what happened here and then you can just send this query and then you see okay someone changed the name to this or 11 mark cuban dodge nicola tesla so we already have like you see it took me five minutes and we already have like very valuable data about the contract ready in a in a nice graphql interface um yeah so that's about developing subgraphs so if you want to go like if you just do this you probably don't get the bounty you should then start you know to change the schema change the the mappings and so on but like if you have that first step and you want to extend your subgraph then come to our booth and i'm happy kind of to explain the concepts you can also go to the documentation how to proceed from here further but i want to spend some time also here on this next slide um how to query data from the decentralized network um we also don't need to go through the slides but this works like this so you have again the graph then there is this one product called the graph explorer and here you see all the sub graphs like all the 439 subgraphs which are deployed to decentralized network get now and you can you can scroll through them and there are very interesting ones so for example um uh yeah you have i know like lido ray main net pull together sushi hop protocol some doodles ethereum blocks you can query if you want and there's this ess 721 marketplace that tracks kind of marketplace uh volumes and stuff but like the one that i like the most actually is the crypto punks so you can search for crypto punks and then you need to be careful always go for the ones with the highest signal that's what corresion is here for i think this one is a scam um but yeah it's a decentralized network everybody can deploy right so how it works again here you have a playground similar to before so we can see like okay which accounts do we have send the graphical query you can start to little bit explore it um but actually the the cool like it really gets gets cool if you do if you do this so you can get that query url here and then you go to graphyql dash online.com and and paste it here but like the next step is also you need to have uh you need to have an api key you can also go again into the studio and then you can create api keys here we can just create one and then you can use it so you can copy that api key there is there are a thousand free api keys initially queries if you do this and then you just need to replace the api key here with your api key sorry should i take the other one ah here okay all right get the api key nice again and now i can say for example like i get this is actually interesting so who wants to know um [Music] actually the sales yeah the yeah for the punks it's interesting the highest sale so i can say like the nft id and then amount order by amount or the direction descending sent and see this it's interesting nobody knows that but actually the highest sale on the crypto punks was that much and it was a wash trading if you go to the larva larva labs or now uvelip's website and you want to see this you don't see that watch trading here but it's true like somebody did it get a flash loan get the highest sale and then uh get the flashlight back so it was interesting so now we had kind of this walkthrough from how you can like what is the graph how you can create the subgraph and how you can query existing subgraphs on the decentralized network yeah i know it was a lot i have packed in 30 30 minutes but um yeah thanks for watching and if you have any more questions we're trying to be at the booth as much as possible and then there is discord and other channels yeah happy hacking [Applause] i'm here to present seokyo uh before i do that formalities first a big thank you to the eth global team for obviously organizing this event and in particular this workshop uh onto business what is sol ql i'm gonna say what it isn't first it isn't a querying language so why is ql in the name the same reason java is in javascript it sounds cool i've told you what it isn't i'm going to show you what it is now um the most brief description would be it is a tool that mimics hardhat forking but is much quicker than hard hat forking i'll show you in a moment so here i've got a standard hardhat environment setup i've got a config file with the compiler version provider url the forking standard setup if you if you have used hard hat this will be pretty familiar to you obviously so the smart contract i'm going to be testing today is called the query contract and in order for this to work we need to impose some restrictions on this courier contract so one of those research restrictions is it has to have a function with this signature right here so it has to have a function named query which returns bytes memory so what is going on here basically what we're doing is we're taking the uni swap v2 factory contract on gurley testnet and we are calling the all pairs function to get the eighth pair and then once we have the eighth pair we call the token zero function to get its first token now there is a specific reason why this example was chosen i'll explain that later but let's get into the comparison first so this uh benchmark is available on our website over here so you can try running the benchmark yourself see if you get some similar results without further ado let's test soul ql first and then i'll test hot hat forking afterwards okay 7.9 seconds to do what to get 10 pair contracts from the uni swap v2 factory and then get their first token cool now 7 seconds does sound slow but we are offering this as an alternative to [Music] hardhat forking which gives us the following results wait a while okay 13 seconds now that doesn't seem like much of a difference even though it is almost a 2x gain but what ends up happening is as we increase the number of token addresses we are fetching uh the difference goes up quite quickly an example would be assuming that hard hat forking grows linearly with the number of tokens that we query whereas seoul kl would grow logarithmically so much slower now before i explain how this performance game comes to life i'm gonna go through some caveats there's two main ones firstly we do not have hard hats console.log functionality yet although it's possible just will take a while and two we don't have the functionality to be able to pass constructor parameters to contracts yet again that can be implemented so here you'll notice that there is no constructor every piece of information that we need has been declared inside as a literal and that is because as of right now there is no support for being able to pass data into a constructor okay so this is what i was talking about earlier this is a graph representing on the x-axis we have the number of pair contracts we're querying and on the y-axis we have the number of milliseconds taken to get a result so as you can see soko the blue dots here stays pretty constant whereas hard hat grows pretty quickly so at this point right here at 2 000 pairs we're looking at about a 30 x gain in performance so that would be comparing [Music] around 6 seconds to 1 800 seconds so just to put things into perspective that's six seconds compared to 30 minutes which is a pretty big difference okay and at the very far end so here we have 9507 pairs at that point hard hat doesn't even work you will probably get a timeout or some other form of networking error so again for this demonstration just because it takes a while uh we're not going to demonstrate these data points right here because they would quite literally take the rest of the workshop to show but yes so that shows the speed gain that you would have from using soul qr now we do have examples you could follow along with so if i open here go to the docks obviously we have this warning here this is still in alpha so braking changes will happen but installation you go to a directory and you run this command right here it basically what it does is it clones a repo that we have set up and it installs the dependencies um i'll actually show you so right here if i do npx sol ql at 0.012 i'm going to call this test 2. so we get this test2 directory uh we've already run npm install so all of your dependencies are already installed so here what you have is the exact same smart contract i just showed you but we also have this main script which shows the usage of the soul ql api so basically the way this works is you import the solkier class from the package obviously you instantiate an ethers provider with your provider link you would have a contract name this name would be this name right here so if i turn this into query two i'd also have to turn this right here into query two for this to work we are passing the chain id and we instantiate a source soul ql interface like so the reason you pass the chain id and your provider at the same time is because if you already know what chain id your provider has obviously we don't need to make an asynchronous call to figure out your chain id for you that would take an extra couple hundred milliseconds don't want that you also have to pass the hardhat runtime environment to this soul cure class reason being hardhat does quite a bit behind the scenes so rather than reinventing the wheel ourselves we just decided to rely on hard hat so that is quite essential over there and then to get the results all you have to do is run the following line this gives you a [Music] encoded string of bytes like this but we can obviously use the default api coder of ethers.js to decode our result and have it in a nicer format reason this is address 100 is because over here this is what we are this address 100 array is what we are packing and returning as bytes memory so just to show you where was i if i go here that is by the way if you oh there you go that was quicker than before anyway so this is your uh encoded result basically which you use the ethers the js decoder to turn into this right here okay now with that out of the way where were my slides this is diving a bit into the nitty-gritty of how this thing works and why it gives us the performance scan it does give us so firstly i'll explain what seoul keol is doing and then i'll go through what hot hat is doing and why hard hat is slower than soul qr so basically what selkiel does is it takes your contract it uses the built-in hard hat compiler to compile it down to evm bytecode it then sends that bytecode to the provider you give the soul qr api and it gives you the results back now there is one step in the middle here so the way this actually works is we also have these oracle contracts these are contracts that we deploy so these are actually deployed right now just ungurley but we are on the verge of deploying it to other chains as well so what is happening here is basically we call this function here when we want to simulate our smart contract which takes in the barcode of that smart contract and then deploys that contract using this assembly block here runs the query method on it and returns the result now in real life this would cost gas however we're not actually signing this transaction we're simulating it so if you've used call static before that's what we're doing here so we don't actually pay any gas for this so that's how that works now it would be more helpful to see all of this happen on the provider's dashboard so that you can see the type of json rpc requests you get for hard hat forking as opposed to soul clear so i'm gonna run the hardhat forking script again and we don't need to wait for it to finish we can just come here don't steal my api keys thank you okay this is what hard hat does recall that smart contracts have a storage address on the global ethereum state so what hard hat does is it has a local evm instance but it doesn't obviously have access to the entire ethereum straight states because if it did it would be a full node but it isn't so what it does is to get the data it needs to do its computation it sends your provider eth get storage at requests so this parameter here is actually a smart contract address so if you look this up this could be the v2 factory or it could be the pair actually you can probably do that yep there we go so this address here is the uni swap v2 factory deployed on gurley so obviously we're getting data from the smart contract but we don't have the data locally so we send json rpc requests to our provider to get the data so basically the bottom line is when you're using hard hat you are sending a lot of json rpc requests and hard hat deliberately slows this down just so you don't get rate limited which is actually a fair call but then let's see the alternative approach of soul qr again we didn't really need for it to finish right this is all we get a single heath call reason being we are passing the byte code of our smart contract that's what this mysterious looking string here is to the provider and the provider simulates deploying a smart contract using this bytecode using the oracle smart contract that we genuinely have applied deployed so this is the result that you then get so essentially the performance gain we get from using sol ql comes from making fewer json rpc requests we make exactly one request so obviously that has a lot less networking overhead which is what results in where is it this graph right here so as you increase the number of pairs that you're occurring obviously you get proportionally more get storage at json rpc requests whereas with sol ql if you increase uh the number of iterations you're doing in your loop you're really just changing the jump i bytecode so the length of the bytecode of the smart contract doesn't change that much as you increase the number of pairs so what ends up happening is firstly the data you have to send to the provider to be able to simulate this smart contract doesn't increase linearly as the number of reads from storage you do increases and secondly because the provider is doing all of the reads from state locally they can obviously do it much much quicker than the hard hat evm on your machine having to make a separate json opc request each time it needs to read a contract's storage so yes that's what seoul qr does any questions no questions all right i believe we are early 10 minutes early cool well that's it for me thank you for listening [Applause] [Music] you 