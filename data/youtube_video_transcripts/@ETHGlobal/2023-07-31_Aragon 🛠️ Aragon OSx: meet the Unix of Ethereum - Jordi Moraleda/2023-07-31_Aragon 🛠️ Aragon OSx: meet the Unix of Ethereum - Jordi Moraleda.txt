foreign [Music] the first talk and yeah today we have some sweet things for you ideally I'll be talking about some of the things that developers fall in love when you embrace them when you discover them when you think okay how could I be doing this before reps uh let's get started so we are in 1970 uh welcome to uh digital Equipment Corporation uh the computer they released was called pdb how did it work the entire system was basically on program right and if you needed to change something basically there was one program running the entire thing uh there needs to be one program for every architecture there was a way to add to remove it was basically something monolithic but then came operating systems so you have a trusted kernel that can basically do everything it likes and then you have untrusted programs that interact with the kernel to do things so that you can have many programs and you can basically forget about what's behind and how does this look like so at the Double half let's say that is the network basically the things that um you know the hardware itself and then below you have different programs that might need to interact to these resources for example if you want to use Spotify Spotify will talk to the kernel in a kind of standardized and abstracted way so that it can use the speaker so that it can use maybe the network display whatever right but fast forward into the future where are we let's say 50 years later in let's say 2017 yeah well I think we're the same place because back at the time every protocol that needed to be made had to be made from scratch because there was nothing to build an abstraction on top of right so basically well writing the entire protocol every single time there was no way to add and remove features there was no way to you know easily customize things but then these chains this started to change when Argan in 2017 released argon OS the first version it was the first solution to a problem uh it was revolutionary revolutionary in many terms and still as of today it is a hacked it's very robust and it worked based on templates right as the different templates for ngos for cessations for profit companies and it was good for some of these use cases but at the same time it had some challenges for for it to be used in simpler use cases and some of the Lessons Learned is that there are not two equal communities two thous are going to always need different things they are going to have different flows they're going to require something new to them at the same time the same Dao always evolves over time you can start today and you have no idea of what your community is going to look like in the future what you will need and you cannot I mean super hard to design for this ahead of time and another lesson being learned is that many times Argos has been forked and has been implemented in you know for very big projects like Lido the central line and so on the thing is that this is not ideal because you need to fork and maintain a big code base right so if you can extend instead of forking and maintaining the whole thing that's a big bonus and for this this year in 2023 March this year we have released OSX which is basically a must a massive Leap Forward which consists of two components so we have a dial core and then we also have undressed plugins or external addresses let's say contracts that can interact with the dial core doesn't it sound a bit familiar to you I think it should because basically we're talking about the same concept of our operating system which is there are some plugins some contracts some wallets that want to use the dial right they want that out to do something with shared resources pretty much like programs do in operating system so for example if a plugin wants the dial to transfer some die to another address there will have to be some governance proposal on the plugin but essentially the plugin will need to have permission to go to the dial and then the dial internally has a permission database which is basically the Bible of everything that can happen within this community right but then we've been talking uh at least the title is about the Unix of ethereum let's get a bit into this what's the Unix philosophy if your developers you're most certainly aware of some of the basic uh principles of it which is writing programs that can do one thing and do it well right the components um building problems that can work together that they can talk to each other very easily that you can compose that you can combine and architect something bigger than just the program itself that needs to grow indefinitely and also flexibility if you build small pieces these small pieces should be able to work in many scenarios not just for one specific use case right that should be reusable by many other tools so again you can build more complex things and more interesting things this is a very simple Unix program all it does is just opening a file reading some data and reading it back writing it back Etc the blue Dots here the the blue functions here they are the absolute simplest things you can find you don't have a open file function you don't have a write buffer where no you have a general function that works everywhere for every single kind of thing but on top of this um for example with programs like the one we had here imagine we compiled this we eventually have a layer on top in which we can start composing some of these programs some of these binaries that we made to make something more interesting more complex and more accepted away how do we translate many of these terms let's say for ourselves for Argon OS X so in Unix everything is a file okay for us everything is a permission because eventually you want to execute something right uh there are system calls like read write exec etc for us there is doubt.execute asking the current to do something uh permissions for example change mode change Group Change owner well we have granting and revoking permissions and then we have some of the basic utilities like LS copy Etc which are some of the plugins that we ship ourselves and some of the plugins that anyone can do can be able to see can be token boating Etc there are some additional marketing principles that which have inherited not only from Unix let's say but some other languages like for example rust we like there to be only one correct way of doing things right we lack Clarity we like developers we want developers to be explicit about they do if this code is going to be audited it needs to be obvious what the code is doing we don't want any hidden magic behind the scenes at the same time we want people in general the community to only pay for the gas for features that they need and that they are using just no hidden bloat not just shipping 20 million things that you don't use but they are there right and it needs to be easy to understand the reason about because after all it's all about security foreign let's start talking about plugins because arganize X is basically about a community is basically something valuable that needs to be protected by many people there needs to be many people behind for this to be secure and for this we need plugins what is the plugin basically the a plugin is our way to solve a small problem a small custom problem uh following the earliest photos of his so make it simple and stop rementing the wheel basically reusing everything else that we as argon offer for free basically plug-in versioning upgradability so shipping new versions and allowing people to easily upgrade to the newest features that you ship maintaining data maintaining statuses uh using the permission management system which is one of the top most built of things about the initial versions of our organos also interact with all the plugins also combine different plugins together to achieve the custom scenarios that you now needs and more that we're going to see um pretty soon so and the end goal of these is supplementing the wheel because we want to ship fast because we don't want to you know be rewriting things that happen already solved in the past so how does a plugin look like so first of all the green box here is let's say the plugin that for example we would like to have a multi-seek okay but at the same time we're going to need what we call the plugin setup just above right what does this plug-in setup do it's a contract that the developer does which manages installations updates of the plugins and uninstalls is basically a scripting in which you can do basically everything on top of that when you want to publish a plugin version you publish the plugin setup we have a registry and then in this plugin registry you can create your own repository you even get an ens if you want and then you keep publishing different builds if you choose your plugin to be upgradable people will be aware that there is a new version they can quit the proposal and they can get the latest and greatest features that you just shipped to them you want yourself and then on the other side there are all the goodies to just make all of these accessible to uis to any applications that you can think of so in the end what's the landscape that this leaves us let's see so as I said there are not two dials that are exactly equal so most likely you could for example want to start with a dial with maybe one of the sick plugin and then maybe eventually install another one may install a token voting one and maybe the feature maybe you want to do off-chain voting and you install a third one and you decide that you want to remove one of the other ones so you're basically the coupling let's say the shape of your dial the shape of your community from how the actual dial works so for example here at the top imagine that there are many operations that the dial can can perform many functions these functions they have different rows Associated to them when you install a plugin you granted some permissions and depending on depending on the permissions of this plugin the address can perform these operations right but if tomorrow for example I decide to remove the multi-six plugin let's say I am doing a clean uninstall and then I could install maybe an automatic but that token voting that could do the exact same thing but with a different logic so you're basically setting yourself to be feature proof in terms of evolving operating without committing your doubt to B as it is today forever so let's see some code because my whole point on this issue is to show you how easy it is to do applying so this is the absolute most simple plugin that you can get all you have to do is inheriting from plugin clonable for example or from plugging the UPS available you get for free all of the tooling you can just simply forget about the rest in this example we have a plugin what he's doing is preparing a list of actions and this list of actions eventually we connect to the Dao to which this plane is linked let's head to which this plugin is listening to the permission database and we're asking the data to execute these actions that's it that's the hello world that's a hello Dao let's say plugin that you can build um what if for example our plugin wants to start using some additional permissions for itself what if we want to restrict the plugin itself we don't want just anyone to go there we want some function to be guarded so first of all we will need to create here our our own permission ID which is basically about 32. um computed by sashing some value and then below on the function that we want to guard we are going to add this modifier this is the basic building block then only the people who holds the permission in this case my plan permission ID on the Laos database is going to be able to use this this is something fruit that you can grant you can remove you can evolve you can iterate you can have another plugin with a different logic you can have a different version of this plugin with uh maybe fixing a bug Etc so it gets really really really flexible for you to just evolve how does applying setup look like so there is the iply and setup interface which is basically the method that your install script should Implement so this is a two-step process step number one you prepare the installation the update or the an installation of a plugin and then step number two the Dao has a proposal and eventually the community accepts and decides to apply the permissions that you have requested and essentially the plugin becomes installed updated whatever here you have some example of one of our employers so the music plugin what you have is a Constructor we do the initial deploy to have let's say the implementation on chain that we will then carbon copy we don't need to deploy every single time so we use proxies so in this example what we do is prevention your function will receive some parameters that you're going to encode with the settings of this particular plugin and then you you can just simply copy this line that we provide you the tooling to just use it and then this creates a proxy with your specific plugin instance you get your very own plugin and then the last step is requesting permissions this may seem about verbose but essentially what we're doing here is well we're building a list of formations so we're saying please allow the dial to upgrade the plugin settings or please allow the dial to upgrade the plugin itself and at the same time oh please Dao allow the new plugin to use to do execute or to do something right so you do your wish list of permissions and then the community assesses whether they lag them or not and eventually if they approve them these three permissions here are going to you know make it to the dial aspiration database okay so what is a permission as we saw before basically it's a source of entropy a string hashed which is then a number and we use it to Shield functions and permissions they look like granting for permission to who to do what on where so allow the dial to do this on the plane but what if we want to we want things to be a bit more um let's say more granular what if we want some conditions to to be a bit more restricted right so you can use permission conditions which is nothing more than a contract that you can Define right so for example when you have some plugin trying to execute some operation you could tell that okay whenever someone wants to perform this action ask this contract and if this contract says yes you just continue right so they allow for us to basically decouple uh the fact of the features themselves with the restrictions and this prevents things like plugins going super complex because you need to combine a matrix of you know I want to do this but not that but yes but no it gets extremely complicated if you can decouple these two things again you can have very composable very modular things very very modal protocol without needing to remember the wheel because most of the time some of these conditions will have been implemented by someone else right same as plugin some of these plugins will have already been implemented by someone else and you can just pull them and get let's say their upgrades for free as well so in the end permissions for us would look like Grant permission to a certain contract to do certain a certain role on some Target optionally when a condition is met and with this you can just go and build the Moon so uh this is how simple a permission contract would look like the only thing it would be to implement is basically that is granted condition um it would receive the parameters of what is being attempted to do and eventually it needs to return yes or no in this case um first parameter being greater than the second one so this is all I've got for you there's much more you can just find us uh Carlos and Juliet we will be here around um we have here a couple of um plug-in examples for you so one is an example of a plugin to understand how it works okay and the second more is second one is more of a project in which you get a plugin and you get also the all of the internet testing and some JavaScript client for it to connect on a UI and also some basic subgraph indexing in case you want your right to be more um you know user friendly and all of this feel free to take pictures of this QR codes at the same time you can also go to devs.argon.org and you'll get all the whole documentation of the protocol and also you can join us on this course so we yeah some people from the community are very active also helping around and yeah the tldr for me is the sky is basically the limit if you don't have to remain the will to build the next big thing and you can focus on customizing only what you need and recycling everything that there's around then basically you're ready to go build the absolute Next Big Thing so that's it pretty much um I'll be happy to ask many questions and expand any of the topics that you think think s for the presentation I would have a question about the initial deployment of dro those the initial deployer or owner needs to write code as a smart contractor to set up everything and to include plugins or is it just a call to an existing contract so you could decide to deploy yourself but most likely you want to use something that we call the Dow Factory so you call that a factory which is a contract that we deploy ourselves is there and then you pass it a list of the plugins that you want it to us right so by default the deployer if you happen to deploy it yourself you would be kind of having total permission on it with the intent of installing a plugin and then dropping this permission and yeah can give you more examples on that absolutely but yeah there's a contract that does everything for you garage first tell us what are you like most popular plugins for now which you created I mean your team and the water like custom plugins your clients and other that was created that uh like very commonly used so we ship four standard ones which is the multiplying we also shipped another variant which is called the address list right yeah which is a a version of it which is intended for everyone to vote whereas in a multi-sik you only expect some people to just say okay right in address this you have um at least an explicit list of addresses and they bought and then you have the evolution of these which is token voting so you can vote with an rc20 token Etc uh it supports delegation and supports many things that you expect then there is another interesting plugin interesting we call it internally the dictator plug it uh which is basically the admin plan which in which one address is able to do everything this is in cases that for example you need to experiment or you need to kick start the dial right you could manually Grant permissions to yourself but the idea of fine applying the benefit is that everything is encapsulated right you just add it as a whole and remove it as a whole so you could start us with this plugin then upgrade the more the sick then upgrade to any of the other ones that you would say regarding what the community is doing I don't know maybe in Juliet Carlos can expand on this but the idea as of now the point in which we are is people do their custom thing right it's not that they're just publishing plugins around this may well become let's say the next step but at this point it's more like not needing I mean being able to recycle and just adding the extra plugin that this these very small thing that any of these system plugins could not possibly solve for you touch if this replies a question hi can you hear me yeah I'm guessing I think about your presentation I'd like to ask uh if I'm going to use the aragono S6 yeah will I be able to use the auto-generated client yes it is done on the Argon app I'm sorry I haven't traveled could you speak a bit louder yeah so I can close the door thank you yeah thank you okay so let's say I'm gonna use the argono6 here to create a model uh will I be able to use auto-generated client yeah as it is done on the Argon app so what we ship is uh the Argon SDK which basically uh provides all the tooling to um to interact with basically uh web ethereums ivfs and sub graph okay then on top we built abstraction layer so you can interact with anything related to the dial in general but at the same time we also um oh sorry about that foreign so the second example here you get an example of a JavaScript client that uses the SDK right to just um at the custom things that you need for your client right so the idea is that you get maybe 95 of the tooling is there and you can just right away start calling um you know web3 call this contract or ibfs fetch this data Etc so it's not opportunity because the custom bit that only you know well you need uh you know what do you want right we can possibly know how you intend to use for example maybe you want to use the graph or maybe you want to use a back end and index something there or maybe I mean there's no general rule here and last question could I use uh SDK to work with already existing one that was that uh created from the client as well from the app you have for example HD data to get all of the dials as long as you can basically call the contracts as long as you from JavaScript you can simplify the information so again the message the SDK gives you um all of the building blocks for you to build on top we use it ourselves to build our own plugin clients right and you can just replicate this um just write the custom five percent think and forget about the rest because we did it good in again 