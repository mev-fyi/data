we're really optimistic all right hi everybody um thanks for joining us and today we'll be starting the workshop with uh kelvin and ben from optimism an overview on code uh an overview and code walkthrough and without further ado i will let um kevin and ben take it over if you have any question you feel free to post it in the chat we'll get back to them if not during this workshop after in the sponsorship channel and discord thanks yo thank you hello everyone welcome welcome kelvin can you help me with this uh screen training presentation yeah i don't want to accidentally reveal your social media or something hey everyone what's going on welcome welcome give us a sec as we uh throw together throw up these slides how are you all doing today i'm very excited to see some on some unmuted faces incredibly exciting i hope that we get lots of excellent questions that kelvin will help me surface as we go so it's great to see you all it's good to be here sweet all right so we are preparing to hack folks let's get ready it's the scaling ethereum hackathon get hyped um before we begin i do want to let you guys know that if you're hoping to walk through the code alongside kelvin that kelvin will be going over later you can check out this link which will redirect you to some prereqs that you can get downloading in the background however no pressure at all if you don't want docker to kill your neighbors netflix or something like that of course all of this will be recorded all of the code and stuff is public so you can go back take your sweet time uh pause mr kelvin with some of these incredible uh incredible shots that we're getting here with these incredible glasses damn son where'd you find this so in addition to that uh i will say that i'm ben and next to me is kelvin who is currently manning the little sound board we put together for this uh this workshop so if you hear it do you hear random noise in the background that's what that is uh yeah so i'm ben and this is kelvin and we work at optimism and we'll be talking to you all today about a couple of things so the first thing we're gonna do and i think the most important thing that we're gonna do is give you guys a little taste of optimistic ethereum now there's going to be some very familiar tastes there that you've hopefully already acquired which is just the ethereum developer stack um there's also some new tastes that will be unfamiliar but hopefully very uh umami or choose your favorite shade choose your favorite flavor they'll be new but hopefully they'll be fun we think they're a lot of fun so first i'm just going to talk through conceptually some of some of those components and then i'm going to step back and kelvin's going to hop in i will take over the sound board and kelvin will do some coding with you all so we'll first we'll do it in words then we'll do it in code and then we're going to wrap up talking just very briefly about our plans for the hackathon and how we're going to support you lovely people all right kelvin are we checking questions on chat by the way i love questions i love questions folks if you if you guys can get us to not finish this presentation because of questions i'll be very pleased first question when when i'll sir uh soon okay i think we're i mean we have a sound board so i guess we're buying into where we have to accept some some level of memory questions first question down let's go all right so what are we building so we are here building optimistic ethereum now what is optimistic ethereum in one exhale of a of a hit or uh optimistic ethereum is just like ethereum but with better scalability 10 to 100 x cheaper and secured by l1 so basically if you want to sum it up in a simple meme you know we can make it look something like that okay so there's the tlbr i'm going to very quickly go over some of the the underpinnings of uh how optimism ethereum works and how optimistic roll-ups work i'm going to assume some context if you guys want more uh you can go check out other talks that we've done if you guys have seen those other talks you'll notice that i stole those exact same slides here again sorry i'm not original uh if it ain't broke i'm not gonna fix it so thank you thank you but the basic premise of optimistic execution in general can be summed up in the following way you don't go to court to cash a check you go to court if the check bounces bounces so basically what we're saying is that we can get uh increased scalability in layer two because only in the event of a dispute do we need to execute the gas uh the sort of full gas for the transaction right and actually run it on chain and so this is where we get this is where we get our scaling properties okay so what does that mean in a little more detail okay so i'm just going to walk you through very basically what's going on so up on the top half of the screen here we have l1 that's ethereum and on l2 uh is down below and we have this rollup state and basically what we do is we go through a repeated process whereby a new transaction and a new proposed state is rolled up now this is probably the most useful although it does play very nicely i hadn't thought of this into the whole taste eating analogy but um what does rolled up actually mean basically it means that it's notarized on l1 it basically means we've put it into l1 in such a way that if we need to do a dispute we can but the other thing that happens is a proposal comes along with that transaction and that proposal claims what the no what the notarized transaction should do and would do now uh the key property is that we have a period of time that is like a dispute period it's called the withdrawal window sometimes as well in which someone can basically challenge this behavior and but if no challenges if the if the proposal basically goes unchallenged for this period of time then we optimistically accept it basically we assume that it must be right because it's past the period of time at which it could be disputed okay so again this is a repeated process right we do it once twice let's say let's say now we have this new transaction getting added and someone proposes that they have all the money afterwards right that doesn't seem right that seems like a problem so what do you want to do you want to do a fraud proof so you go to l1 and you say hey guys this proposal for s2 here looks really good but if you take s2 and you apply tx2 to it i'm going to show you you are not going to get s3 and so you basically prove that the proposal is wrong and you blow it out of the water and it gets son where'd eliminated find this okay so there's our sound board for that okay and then the other important thing i think to go over as i just try to breeze through this is that um we basically have built something called the ovm which allows that execute function during the fraud proof to basically be an evm transaction and so this is where you get all the wonderful evm like properties replicated into your layer 2. all right so i tried to breeze through that a little quicker than i normally do because what i want to focus on for this hackathon and for this presentation for kicking things off what do these things actually mean for someone as a developer what does it mean if you're a hacker that's trying to go through and use our stack over the course of this month so i think the first thing to say right i said before that there's some similar tastes right and effectively that's quite true i think the hello world example for a blockchain project at this point pretty much is to launch an erc20 i mean at least that's the case for ethereum and of course that's the case on our chain as well so kelvin will go through right quick how to take an erc20 turned into an optimistic vrc20 um and the tl dr is that it requires almost nothing because you should be able to use all your same tooling that you love to deploy and interact with ethereum but now do so interacting with optimistic ethereum so that all should be the same and super familiar now there are new components that happen in in this layer two paradigm and namely those arise from the fact that we now have two layers so these layers need a way to talk to each other and it turns out that that talking sort of by necessity is a little bit different okay and generally the way that two layers talk for ninety percent of use cases is a deposit or a withdrawal right you're either putting your money in from layer one so that you can use it more cheaply in layer two or you're pulling it out um so that you can you know take it or send it to an exchange or whatever cool okay so we sometimes call so okay another piece of context that i want to share is that all of the deposit withdrawal tooling should be very easy for you and for a lot of use cases you can just use out-of-the-box deposits and withdrawals but it's still useful uh i i think and very important for developers to understand what they are building when they're using some deposited funds on l2 what does it actually mean where did it come from and how does the system work behind the scenes so i'm going into a little more depth here than the abstraction for developers you know needs to be taken but hey we're at a workshop we're going to kick things off that's what we're going to do okay so it's pretty simple again up on the top we have l1 on the bottom we have l2 and basically um what happens is to deposit what that really means is you're locking up funds on l1 because you want to move them to l2 and while they're in use on l2 they shouldn't be also usable on l1 right that would be like a double spend or it wouldn't really make sense so all you do is you have a contract on l1 that locks funds and it tells l2 hey i locked up this number of funds mint and this was the person who did it so mint them the equal amount of tokens onto l2 so that's this is this these two pieces together are what we would call a deposit great and of course the exact inverse holds true in the opposite direction to get your funds out of l2 you should no longer be able to use them on l2 so what you do is you burn those funds on l2 and once the dispute period pass and the optimistic state is is accepted this will unlock your funds on l1 and let you get them out um yeah excellent excellent make sure we're checking for questions calvin come on y'all got to stop me who triggers the mint of the l2 funds ah who triggers the mint of the l2 funds that is a very good question and it's a great segue so i'm glad i'm glad we we caught it i just have this little slide here that's making these arrows bigger but to emphasize that this is what i want to talk about what mints the l2 funds in some sense you could even call it a cross-chain transaction right in reality we we call it a cross-chain message because it's more like the transaction starts sends the message and then there's a transaction that is receiving the message on l2 but in effect what what allows this minty to occur are smart contracts talking to each other between chains and so there are differences in similarities in the ways that contracts can talk to each other between chains um so i'm going to talk through talk through those differences and those similarities uh what we have strived to do in optimism ethereum is make that part of the protocol as similar to what we do in ethereum as possible so in ethereum the way that contracts talk to each other is a cross-contract call and when you do a cross-contract call you say who you're calling and you you give some data that you want to call them with it's like your message right that says that encodes information such as i am calling this function and i am providing these inputs to this function along with calling that function and of course how much gas you're going to spend so we've tried to replicate that in intuition as much as possible for sending messages across chain but you do have to do it with a different contract because it has to work with l2 so here's your here's the interface and uh exactly equivalently to what you can do on ethereum now you can when you get a message in a smart contract you can check the message.sender and you can see who is this message sender do i want to trust them or not or maybe they've just given me some money so i want to do something for them um so the other thing you can do just like you can get the message.sender in normal ethereum you can get the cross chain message sender um from a contract question two down question two down oh yeah cool okay so a couple different things i want to speed up here come and make sure i got time for you a couple of different things the biggest difference uh in some sense is that there is no return data so you can't call you can't do a cross-chain call to uh to like a getter function for example and expect that data to be returned and this is basically because they occur in different blocks on each chain and so because they're it's not the same block because they're two different layers they can't sort of have that round-trip communication this is a very very fun design space hint into inkwink you might you might think of call backs when you see this and see that you can only call functions one way and indeed we think there's a lot of cool stuff that can come out of this hackathon related to that but that's the one difference the other difference that's sort of related is that this communication is asynchronous so there's a bit of a time delay so we have a crazy time graphic here to describe that and uh basically what that time delay is is pretty short when you go in and you deposit funds because a layer one message can sort of force things on there too because layer one is the source of truth but to withdraw your money or to send a layer two to layer one message that takes a little bit more time because you have to wait for the dispute period so those are some of that is basically what is the same and what is different at a very high level when you're developing on a system like optimus crypterium so i think uh if we have any other questions come let me know and if we don't we're gonna switch off to kelvin who's gonna actually walk you through you guys through coding this stuff up anything else i think that's it all right let's go let me switch seats and pass it over to mr fishter let's go all right let's write some code well i'm not actually going to write any code because uh it's bad practice to write code on stream but why don't we switch all right so here's what we're gonna do i hope that everyone can see this yep everyone can see this great so uh i asked everyone uh to to prepare for this if you aren't prepared for this don't worry about it don't do it now because it'll take you too long so just watch the stream afterwards and follow along then but essentially what we're going to do is we're going to run through the basic tutorial and then we're going to sort of also run through what like an l 1 l 2 communication flow would look like and give you an example of how you can do that if you want to hack on that um so the basic tutorial is is just sort of getting an erc20 contract deployed and and compiling and working right pretty simple stuff um so if you download if you if you go to optimism tutorial you will be able to to clone this repo and then all you really need to do is install it right pretty simple and then we're using hard hat so you know hard hat has this nice little compile so i can run run hard hat compile and and you know boom uh my erc20 contract just got compiled this is a sort of standard flow so the only sort of difference uh in optimistic ethereum as we do you are an ad this plugin that's right add a plugin and great and then we just add this plugin to our hardhat config and we're also going to create a new network um i'm going to just copy the same mnemonic and then we are going to specifically set this little flag that says ovm equals true and for now uh just to make our lives easier because we don't have accounts with balance we're just going to set a gas price to zero great so pretty simple and then compiling for the ovm is really simple all we have to do just like we did uh npx hard hat compile right you just had network optimism great cool uh oh uh oh sorry i forgot to put a url in here so this is gonna we're gonna have a node running at 8545 standard standard port um this doesn't matter right now but let's first compile great so this is now compiling our contracts with the uh optimistic ethereum solidity compiler great perfect so wonderful so now you can see we have these two artifacts folders artifacts and artifacts ovm ovm means optimistic virtual machine right sort of just like the very slight tweak on the ethereum virtual machine wonderful great so similarly let's you know this is how we would test a solidity contract boom test it um right come on go great wonderful perfect now what we're going to do is spin up our our simulated development l1 l2 system so this is uh if we if you download the optimism monorepo and install it and and follow the instructions that are in the tutorial here uh we have this little docker compose up thing that will spin up the entire system and it spins up not only the l2 node but it also spins up an l1 node which is really nice for being able to sort of like simulate the behavior between these two systems so this takes a minute to spin up so we're gonna we're gonna give that a second uh i should have probably spun this up before that's life anyway let that run uh unfortunately there's no clear indication when this thing is done you'll just kind of know that it's done because it starts doing a lot uh we need to change that sorry anyway once this is done we'll be able to do hard hat test network optimism and uh i'll give this a second to sort of finish up here because the machine is chugging along while simultaneously screen sharing downloading like 17 video you know videos and spinning up an l1 blockchain and an l2 blockchain and an l2 blockchain and the software that makes the two communicate with one another so but hey it works all right so uh i think we're ready now sometimes it's a little bit slow because ethers has an annoying little polling interval that takes four seconds so sometimes it takes four seconds per test which we need to fix i don't know why it just does this but let's see great so we are starting our test now come on go there we go so it starts and uh and then and then there you go so you can see there's like this weird four second delay which is uh cool okay can i ask a question kelvin yeah what am i saying right now i'm actually seeing on the right hand side a bunch of transactions that are this erc20 test transactions yeah but they're being run on l2 on l2 your local l2 so we we showed how to to do it to deploy to l1 right that's the flow that everyone is familiar with deploying uc 20 to l1 this is just the basic flow of like okay we deploy in your c20.2 now you can see again this annoying four second delay whatever anyway point is you deploy to l2 it's basically the i'm this the whole point of this section is just to show you the similarities between deploying to to optimism and deploying to l1 perfect great all right so now we're going to keep this chain running in the background here whatever sorry for all the spam you know what let's just uh let's move it kind of into its own little corner so that's the basic flow right that's all we did it's just a basic erc20 we add uh we add this plug-in we add our optimism network and we're good to go um but then let's let's go into sort of what uh the more interesting you know communication between the two systems looks like so we've set up this example this very minimal example of uh what it looks like when you want to deposit an erc20 on layer one this is locking it up on layer one and then it sort of gets spit out on layer two and then we're gonna do the whole process backwards so we have these two files very similar this is the same exact erc20 contract that we have in the tutorial boom nothing different and the only difference is we have this this l2 deposited erc20 so this is the sort of the contract that represents the tokens that have been sort of deposited from layer one and um essentially we've we've kind of abstracted a few things for developers to create a nice interface um but we have these two handlers one for withdrawals and one for deposits so so you'll uh you'll extend this or inherit this contract which will give you these deposit and withdraw functions and in this case so this when someone when a user call calls withdraw this function will be triggered in this case you can see we're just burning the tokens on layer two similarly when tokens are deposited we just mint on there too and a lot of this complexity is kind of hidden for you in this uh this sort of helper contract that we've built if you wanna see sort of the low-level information about how this works you can take a look at this contract and get more information there and then basically the flow will be that we have a standard erc20 nothing special about it we're gonna have a gateway contract and we're gonna put funds into the gateway contract and then then those when you lock up those funds in the gateway contract they're sort of just gonna appear on layer two after a little bit and then we're gonna burn those funds on there too and we're gonna sort of unlock them again in the gateway contract on layer one and this example.js file you can ignore all this junk but you can follow along and it's pretty simple right we connect to both of our networks right we're gonna have a wallet on each one of our chains and then we have these two addresses that you don't really need to worry about they're called the messengers they're kind of the contracts that are responsible for doing this communication and a watcher which sort of just helps you you know see when a specific thing when a specific transaction cross-domain cross-chain transaction has been uh finalized so the flow is really simple right so step one we deploy our erc20 to layer one simple this is the ethereum you know erc20 step two we're going to deploy our erc20 to layer two right so we're gonna have two erc20s now and this is that special the positive erc20 contract then step three we're going to create this gateway an erc20 gateway this is a standardized contract that we provide for you so you can also look at that contract and understand how that works under the hood but the point is it's sort of a gate this this contract on layer one that you hook up to both of the contracts you say this is the one on layer one this is the one on layer two so one way to think about it am i right kelvin is like the gateway on l1 is like the thing that was locking and unlocking on the top of my diagram and then on l2 the thing that was minting and burning is the erc20 yeah right got it and the reason we've chosen this design pattern is just because a lot of people already have existing erc20s you could if you wanted to build this gateway directly into the erc20 implementation but that's for another time anyway so then once you've deployed the gateway onto layer 1 you need to sort of initialize layer 2 and make it aware of the gateway the layer 2 your 20. and so then we're going to then we're going to show you what the balances are right so on layer 1 we should have some balance on layer 2 we don't have anything then we're going to approve the gateway to spend some of our tokens we're going to call the deposit function and actually deposit those tokens into layer two we're gonna wait for that deposit to be picked up on layer two and we're gonna see that we have a balance on layer two and then we're gonna do the process in reverse we're gonna withdraw the tokens back to layer one we're gonna wait for that withdrawal to be relayed and and we're gonna see that we have a balance right so it's pretty straightforward um now i'm just gonna so we still have this node running here so i'm just gonna run the example and hopefully this all all completely works great all right so we can see it's deploying to layer 1 then it's deploying layer 2. yes and then we are deploying the gateway we're initializing the layer 2 years boom you can see that we have one two three four on layer one and zero on layer two now we're waiting oh now we have zero on there and one two three four on there two now we're waiting for it to come back yes yeah yeah it works it's functional oh yeah so this is really the you know using these two examples i think you can get a pretty clear idea of sort of what it takes to you know deploy just a basic contract to layer two and then what it takes to sort of build an application that communicates between layer one and layer two this is where the really interesting stuff comes in so um i don't know if we had a slide for it we don't know we have a slide for it yes for the so the the infra info of course where's the slide first we got a slide should just be at the end of that presentation all right we're gonna switch you back to our slide so we can give you some information really quickly all right where are we okay great okay here we go so if you would like to hack on on optimism during this hackathon we will be very much active on discord um if you go to optimus and ios discord i think you should get redirected assuming we set that up correctly otherwise if you go to community.optimism.io you will find links to the discord and you will also find links to docs and stuff like that so um we're going to make a hackathon channel on discord and if you'd like to learn more or if you'd like to start messing around come hang and we will be around sweet thanks y'all thank you guys that was great that was really great thank you um yeah i mean of course like the best way to communicate is through discord uh at the moment if you want to have feedback from like if you if you want to make sure someone catches uh it within the global community it can be easier but of course like being directly connected to the optimism to their own discord work we'll go hang out at the well we'll be in the global discord right after this so yeah um no for sure yeah it would be great to see you there uh everyone if you i know there was a lot of questions i'm not sure everybody got answered um so feel free to come and post them in the 8 global discord channel and uh and kevin and ben will be there for you so thanks everyone 