hello and welcome everyone to the scroll Workshop scaling ethereum with rollups and zero knowledge proofs joining us today is Daniel Helm who will be taking us through this session and with that I'll pass it over to Daniel to get the session started hi everyone thanks for joining oh this is scaling ethereum uh with Roll-Ups and zero knowledge proofs introduction to scroll and the ZK evm just for a heads up this is a pretty non-technical talk I'm hoping to give a real overview get people's uh I don't know get get the get the basic building blocks and mental models of Roll-Ups there for people who it might still be confusing to um our co-founder hi Shen gave a little bit of a demo going deep into some of the architecture and how ZK VMS work so if that is up your alley a bit more check out the YouTube recording but with that I'm going to jump in here I am Daniel Helm I lead developer relations at scroll and if you are unfamiliar with scroll we are building a scaling solution for ethereum that is a ZK roll-up okay so that might be a lot if you don't know who we are you might go to our website and you see this you see the native ZK evm scaling solution for ethereum it's a ZK evm based ZK roll up on ethereum and all this jargon right like if you read this and you're unfamiliar with even what a scaling solution for ethereum means it might leave you feeling a bit like this and so the goal of this talk is to to get people more accustomed to what this jargon means and and get you started building and deploying on scroll if you're only kind of getting started with these kind of solutions but if you are new here uh and you only take away one thing I want it to be that for users and devs scroll is pretty much ethereum um for the most part it's gonna feel and look just like using ethereum and to show that to make it a little bit less scary to think about ZK Roll-Ups I want to do a quick live demo we could go to something like uniswap v3.scroll.io which is a little demo test app we've got here and I could go to connect my wallet and it's going to ask me to not connect uh well it allows me to connect I do that and then it'll say that I need to connect to the scroll Alpha Network which is a test net that we deployed about a week and a half ago maybe two weeks on top of Worley but I can then change my network put in you know the amount of bridge squarely East that maybe I want to wrap into West I can wrap those and just like interacting with any other dap or smart contracts here it's going to look and feel just like interacting with mainnet or a test net and the only difference being that the block times are going to be a little bit faster so we'll get into a bit of that here in the middle of the talk but I just want to show like nothing scary here for the most part you're just talking about interacting with uh with what feels like ethereum and that's that's by Design so let's get into understanding what scroll is what we're building and we have to start this kind of story off with part one blockchain scalability so you're underneath glow o hackathon I'm sure you know a little bit about the promise of ethereum right but it is this platform for decentralized applications and we have this one network where we can share code and data create all these new possibilities and it is open to all anyone can join in on doing this great Collective work where we are doing all sorts of new consensus problems and everyone joins in as long as there's not too many people at once right this is the problem if you have too many people at once you might run into this right you go to deploy your smart contract you go to uh swap a token maybe mint nnft and you see that the estimated gas fee is insane right and and that is not usability you see this and you say oh maybe this network isn't open to me it no longer feels accessible to me so that's the scalability issue right and why do we run into this well this is the issue of ethereum blocks which I'm sure this audience is is very acquainted with we have transactions that are asking the network to do some amount of work right computational work we measure these things in gas and every block can only do so much work this is limited and at some point uh you know the block has to decide okay we have too many too much work too many transactions who do we decide but we're going to choose the work of the transactions that are paying the most for that work and so this is generally just the idea of block space that you'll hear right if it fills up gas prices increase in order to you know incentivize people to only make transactions that need to be making transactions uh but you also are edging out people that can't afford it so people you know this is the gender problem scalability as engineers and developers I think the first thing we start to do is say all right that sounds like a problem let's fix it there's an annoyance there's got to be an engineering solution here and I think the first kind of approach you can take is say well let's make the chain do more work if if we can only do so much work in a block let's just double that and then we half the fees and we're good to go right well though we have to look back at ethereum ethereum is this decentralized network of nodes and validators and every time we have something happening on the network right every single one of these nodes has to do that work everyone has to do the work so they can come to consensus and say this was our old State we caught this transaction did some work this is our new state and now we all agree on where the change should be and so what we you know see when we look at that is that when you say make the chain do more work what you're actually saying is make every single node in the network do more work right and that can maybe become a problem because when you have a super computer uh it's gonna say sure I can do a lot more work like if the item is easy a couple transactions doing a little bit of work not a big deal but then when you look at people running you know raspberry pies for their validators smaller machines maybe other resource constraints like bandwidth or whatever else uh not so happy anymore right you start pricing out or resourcing out uh these players from your network and so then we have what was a happy healthy Network looking a bit more like this and when we have all these sad nodes that can no longer participate in the network the network becomes weaker it becomes more sensitive to to to to Bad actors and that's not what we want so this is a super high level understanding of one aspect of what we call the scalability trilemma this thing has a name I'm sure scaling ethereum you've heard this stated many times but the general gist of the scalability trilemma is this you have to pick two of these three items at the tips of the triangle right you need to be scalable or secure or decentralized as a blockchain network you only get to pick two so when we said let's make the chain do more work what we were really doing is going with this typical high TPS chain solution right maybe the Solana solution where we might resource out uh we push out you know resource intensive yeah resource week nodes in our network but in an effort to to scale it so what's our new solution well what if we said make a new network we can just spin up a whole new one right this might look like this we have a whole bunch of validators on ethereum but we can just kind of split them in half and we'll say on the left half you'll still be called ethereum but on the right half we'll call you ethereum prime you'll be this kind of other network that looks and feels and acts just like ethereum but now we have twice as much block space right this is great um well this is great until we start saying that now we have maybe half the amount of security half the amount of validators that are securing each Network so now uh the the network on the left becomes more prone to Bad actors not to mention we also have to figure out how to like bridge this divide of the line that's now separating the networks because we have two blockchain Networks and so this might be considered like the multi-chain ecosystem right this is another solution that you'll see in the space but it has its trade-offs and and things we don't like about it so um yeah that that's the the scalability trilemma in a nutshell if you want to learn more about this we're going to keep talking about it but but vitalik has kind of a classic blog post that introduces this idea so if you just search like vitalik scalability uh trilemma I bet you'll find it so let's jump into part two layer twos and Roll-Ups how are we going to try and get around this annoying problem well remember we've got ethereum this great decentralized Network that we've done all this work to make secure and we said that you know what it does is it does work right it has blocks and every block it does a big chunk of work modeled here by a beautiful gray box but what if we like break down this box into into the sub work that it does and maybe this is our minting and nft this is our swapping some tokens and and try to imagine what would it look like if we took some piece of of ethereum's work and we said okay what if we just devoted that work to securing some other network what if we made sure that a new network wasn't breaking its rules using work on ethereum um and so this is kind of the novel idea here right what we can do is we can have an off-chain protocol that we secure using ethereum so some kind of like definitions here we have a layer two and it exists as its own off-chain protocol using a layer one as an important piece of its architecture now we call this being deployed on top of that layer one when we get into the idea of a Roll-Ups specifically we're going to be using that layer one for certain security guarantees so that could be you know ordering our transactions that could be data availability censorship resistant correctness things that you can go find probably more technical talks about uh and and the the larger scaling ethereum presentations but the the the kind of key Insight here is that when we talk about Roll-Ups on ethereum what we want to do is inherit the security of ethereum and that's the word that gets used by taking all these things that are these security guarantees we get to like Outsource them from the perspective of the off-chain protocol and rely on ethereum to to take care of these things and so what that looks like in our you know triangle here is that we get ethereum to lock down our security side uh and at that point we could actually start to say things like make a new network and make the chain do more work right because we no longer have the the issue of these security aspects and we can move towards scalability by doing both of these things we can make a new network that is able to do more work but still inherit the security that ethereum brings to us so you've probably seen a ton of these different projects that build on this right we have a layer one like ethereum and then we have all these layer twos and a whole ecosystem of them and you can see some some icons here but Scrolls is playing in the space as well so we're playing this game of Engineers we're designing our way to scale ethereum we've already decided that ethereum can give us our security but but what should we make our roll up do right because now we just have an off chain protocol we haven't specified anything about it we can do it whatever we want here um and maybe the Insight that I would bring here is that ethereum has an incredible ecosystem already um we're all kind of a part of this community by being part of things like youth Global uh and we already get to gain the benefits of the tools the educational resources the users the communities the smart contracts all of these things pre-exist in the ethereum ecosystem and they're what make it so rich and kind of like so attractive to Developers and so the kind of question is if we're going to inherit ethereum security why not try to inherit all of these things too right like why make someone learn a whole new paradigm if we can make these things also kind of get extracted into to what we're building on top of ethereum and so where we can let's just behave like ethereum's virtual machine um that's the thing that takes in the transactions and and does the work on the network if we can just mimic that as closely as possible then we're in a special position where all of the tools and resources and communities can just basically copy paste their code and redeploy somewhere else and benefit from from the scalability benefits and surprise surprise this is this is what scroll is doing and this is what we're building so let's get a little bit more into the technicals of how we're doing that but generally like I said for most users in devs using scroll is just like using ethereum and that's because we're designed in this way here okay so we said we're going to use some of ethereum's work to make sure that an off-chain protocol a new network isn't breaking its rules there's different flavors of this and different Roll-Ups are doing different ways to approach this so you've got scroll on the top here and a project like optimism or arbitrum on the bottom if you've learned anything about them you have probably heard of them heard them labeled as optimistic Roll-Ups right and what they do is they have something called a fraud proof or a fault proof the idea is that they do a bunch of data they do a bunch of work off chain but they put the transaction data back on the L1 and then they wait a little while and they say we're going to assume that this is all good to go and then we'll give someone seven days to say no someone's breaking the rules and if no one says that then uh we'll just continue uh knowing that everything's good in the off chain protocol now scroll on the other hand we are not an optimistic roll-up we are a ZK roll-up back to this kind of jargon thing zero knowledge roll up and let's take a look a little bit at what is securing scroll if we don't have the the optimistic ideas of the other roll-ups to get into this we're going to need a super fast primer on zero knowledge proofs so deep breath we've made it through two parts we've looked at the scalability problem we've looked at kind of the protocol and how layer ones can secure our Layer Two but now we have to get into this kind of magic of zero knowledge proofs which I think can oftentimes get really complicated really mathy but hopefully this is going to be the simplest explanation you've ever seen and it'll hopefully get you the gist of what you need to know so let's do a little thought experiment what if we had a big block of work any sort of work and we wanted to do this work over some sort of data or input and it's a lot of work it's a really big amount of work that can only be done by an army of supercomputers right a really uh crazy amount but we can imagine that we had this special magical wand that made a receipt of that work and that proof of the work could be then passed to a much smaller computer that had a different program that was used to just verify it so this smaller computer didn't have to go redo all the work it maybe didn't even have to look back at the data but somehow there was a magical incantation that could create a receipt where we were able to verify the proof and just kind of trust the output all right this is seems pretty magical so magical that I think we'd have to use a time machine to get something like this and we'd have to take the time machine all the way back to 1991. um okay so in 1991 we had a field emerging with papers like checking computations and poly logarithmic time and in the summary abstract here you'll see descriptions like in this setup a single reliable PC can monitor the operation of a herd of supercomputers working with possibly extremely powerful but unreliable software and untrusted Hardware so this is the idea of our small little Raspberry Pi being able to verify the work of an army of super computers right so this is a field that's been around for a while uh recently it's been evolving very quickly and this is the field of zero knowledge proofs so we can change our kind of hypothetical here and to better understand how we're using linear knowledge proofs we can say what if the work being done is not you know just some random work what if the work being done is actually the evm and what we have is the input are a bunch of transactions so we had new transactions the evm processes them and updates us to the newest state of the blockchain and what if the network was not a bunch of super computers but a network like scroll so what if scroll was doing this kind of work and we need someone that we trust you know we might not trust scroll as a network but we need something that we trust to verify this proof or receipt and we trust ethereum right we trust the computations that are done there because of all the reasons that we love ethereum and so we can use a little bit of that computational work on ethereum to verify the proof of everything off chain happening on scroll and say yep Scrolls following the rules scroll is acting just like an evm should act and now we can trust now that we've verified that the next state is the true state okay this explanation totally ignores this idea of private inputs into zero knowledge proofs this is things like privacy protocols a ZK evm doesn't need these so I'm glossing over them here but just so you know like this is a whole nother uh fascinating and exciting part of zero knowledge proofs but we are not using the Privacy aspect we are using What's called the succinctness aspect of this proofs and so we're able to take a bunch of computation and smush it down into a tiny proof okay so scroll it is a ZK roll up and on chain on layer one we are we have a smart contract that is a ZK evm proof verifier and so we were able to pass proofs to that verifier along with some other data in order to say we are secured as an off-chain protocol all right so part four into scroll now why scroll so I talked a little bit about this but ultimately we've designed Scrolls so that it has great developer experience in terms of other Roll-Ups you might hear of other ZK EVMS but what is important about Scrolls that we are byte code equivalent with the evm that means when you compile your smart contract uh what you end up with some byte code and those things refer to different op codes and stuff but that byte code that you would commit on mainenet is the exact same byte code that you would put on our Network which gives it really really good compatibility with developer tooling existing contracts you don't have to go re-audit anything because you're not just compatible with solidity as a language but what the solidity compiles down into um scroll now as as the softchain protocol gives us a lot more throughput and so we have created more secure block space for ethereum which means that scroll is going to save your users and gas fees and because we're able to do this work faster we can also get quicker feedback to users so scroll aims at having about three second block times compared to ethereums 12. um and the last thing that I think is like a wise girl that I like to emphasize is is alignment right so we we like to really believe that we're building an ethereum's Vision um this plays out in a lot of ways but the way I like to think about it is that there's scaling ethereum the technology but there's also scaling community and scaling ethos they're scaling all these things that aren't purely technological that make ethereum a special community and we try to be heavily aligned with those things um and I think it comes through also in our Origins we are a open source project we initially actually came out of work on the ethereum foundation's privacy and scaling Explorations project where they're building in zkevm and we're still constantly committing code back to that repo and if you're more interested in alignment in our vision for for long term check out our website and some of the blog articles there so I'd like to just take a quick look at what it looks like um as transactions come into our sequencer so I got on layer one you know um well let's jump into a layer two we have transactions they come into a sequencer and they get executed right RX execution environment is just get if you're familiar with it just slightly modified um but what happens is our sequencer does a few things it's going to execute transactions that are coming in it's also going to watch for new deposits and our Bridge contract on the layer one and then it's going to roll up these uh not blocks but batches of blocks and say all that call data all this transaction data it's going to stick that back on ethereum and uh we that's for data availability purposes so all the you know swaps and mints that you're doing that data actually gets committed to ethereum so that later when we use approver to create a proof we can also commit the proof to on chain and that roll-up contract can say four all this data coming in and the Old State we can say this new proof we can verify the update to that to that state and this prover here is oversimplified because this is actually a whole proving Network and the goal right now is to get mainnet out and then the next work is to to make this a fully decentralized prover Network so that it is open and permissionless for anyone to provide proofs for scroll and then the beautiful goal after that is to decentralize our sequencer uh but this is a pretty complicated design space and we're still working through exactly what the details of that are going to be um yeah so I'm going to just walk by block give a walk through what it looks like when transactions come in on scroll uh running a type on time so I'm gonna try to do this quickly but we can imagine scroll having all of these blocks that come in we can batch these together and then literally write that to ethereum and then once we have the proof generated at a later block on ethereum uh commit that to ethereum as well and so you can think about different transactions having different states I won't get too much into this but when a transaction is in scroll at all we can call it pre-committed once we've written that back to ethereum you can consider that committed we've committed to that data but not until that proof has been finalized on chain can we really say that the transaction is finalized and so this could be 20 minutes but that's quite different than the seven day waiting period for optimistic roll-ups and what this looks like kind of working across time we can imagine transactions coming into our sequencer that get bundled in a block the data and call data from that get committed onto the rollup contract on L1 and we now have that block being committed right that information that gets passed to the coordinator we call this a trace of the work that's done um and that gets passed to approver who's going to generate a proof this might take several blocks but that's okay we can make these things in parallel and so we can go through and create a handful of these blocks and keep passing them off to different proof generators eventually these proofs will get created and this is actually our pre-alpha Network on Alpha we have blocks uh we have batches of these blocks that kind of similar to this will then get committed on chain and verified and so now we see that once we've verified this all the blocks included in it are now finalized and that's kind of those states that I described earlier if you're interested in like diving deeper into this we have a roll-up explorer that shows a little bit of how this works but remember for most users and devs scroll is pretty much ethereum but faster cheaper and accessible to more users at once if you're interested in trying out scroll we launched our Alpha Testa on gwarly about two weeks ago and you can use it as you saw I used our uniswap example here but all it takes is an RPC change for you to deploy there or to interact with it it's on top of Worley and if you need some bridged squarely don't hesitate to reach out in the East Global Discord and the scroll Channel let us know and we will send you some Gorly if you're interested in looking at how to connect your wallet testing out the bridge let's set scroll.io Alpha and really importantly we have guide.scroll.io and oops there you'll find our developer documentation so if you go here you'll find our developer info but most importantly you'll find our developer quick start which not only shows the the network information but also copy pasting lines for hard hat Foundry remix truffle brownie ethers and scaffold eth to get going with just some copy pastes into your current deployment well so if you're going to be hacking just want to do one last show for our prizes we're gonna have twenty thousand dollars in prices in total we have a prize pool for just deploying your smart contract on scroll no matter what other prizes you apply to you can deploy on scroll as well to be part of our prize pool for ten thousand dollars we also have a track for Applied ZK projects we don't expose any of those CK Primitives we talked about but if you're building in ZK uh we want you on our chain so we've got two prizes for twenty five hundred dollars and then we have the last one here called cheap and fast block space utilizer and we really just want to see people testing the design space of of what is possible with cheaper gas fees and three second confirmation times from the adapt perspective so check out our prizes and happy to answer questions if I have 60 seconds to do so but yeah you've got some time there's um uh there was one question about uh from Stephen how long does it usually take for scroll to go through a zkp from pre-commit to finalized and what are the differences between scroll and ZK sync polycon and ZK evm great question so from pre-commit to finalized pre-commit to committed is the fast one right basically we wait until there's enough blocks to fill up about 50 million gas um which just depends on how much activity there is on the network but let's say it's nine seconds and then we make a transaction on ethereum and so then we're committed there um the the longer one is is the proof when we hit mainnet I believe the goal is for those to always come in at under 20 minutes um right now I don't know that we have enough provers on the network to keep up with the demand but the fast way to check is to check I roll up Explorer and you can see that the last handful of blocks because they're coming in very quickly are all in pre-committed but let's just say we looked at quite a few here we have a lot committed and so I've already gone back an hour and these are still committed so it seems like approvers are not keeping up with the amount of transactions we're having coming in which is uh a blessing and a curse to have a whole lot of testnet activity on your network um but yeah right now it seems like it is several hours but um yeah 20 minutes is where we're aiming for but we have to scale up the number of proverbers on the network to do that okay what are the differences between scroll and ZK sync and polycon ZK ebm um one of the major differences between us and ZK sync is is that idea that I described earlier where ZK sync is what we call language compatible with solidity and so you are taking solidity you're compiling it into an environment for their VM whereas uh polygon and ourselves have a model where we are byte code compatible you are compiling it just like you would for mainnet and that thing gets deployed uh on our networks there are other kind of architectural differences about the approach that us and polygon are taking um I don't think I want to like dive too deeply in there but yeah so curious what our popular UK cases of scroll at the moment um so right now yeah it's been two weeks we are a General application platform um and so really what we've been mostly seeing are the things that we've been encouraging people to make uh and so at eth Denver two weeks ago we got a lot of projects that were like applied ZK because we had bounties there we had a lot of projects around decentralized social media because we had a bounty for that but we've also had a handful of game devs using scroll which is really exciting because that's a place where cheap transactions and fast transactions are really helpful um and in general just any anything designed for ethereum already uh is it's a good use case for for scroll and yeah we've we've also gone through some governance processes for projects like uniswap and Ave and so on our testnet we'll have those contracts that you can interact with um the uniswap ones are live the away ones are still a little bit away if you want to interact with the pre-existing environments on scroll um is it possible to use scroll with smart JS or Iden um I know the answer for smart JS yes um just like you can um yeah basically I think the the setup for that I'm not a ZK developer but my understanding is that so in Cairo you can like compile a solidity contract to verify a proof and so you could compile that proof for Generation using snark.js either in node or in a browser and then commit that on chain using you know metamask or whatever and if it works in the evm context it's going to also work in the the scroll context is it possible to deploy scroll evm to a different data availability layer um in theory yes right like we have the ZK evm and that kind of lives as a separate component to the roll-up architecture that we're doing the data availability and of commitments and proofs to um so if you yeah wanted to put together a weird project where you took our open source repos and you you know committed to to eigenlayer's D.A or Celestia's D.A and then verified somewhere else uh that could be fascinating but it's not necessarily what we're looking at doing uh for the moment we're really interested in committing to to ethereum like our you pay gas in ethereum on our Network right like we're very interested in inheriting the security of ethereum and furthering the the goals of ethereum itself and 4844 is going to really help us do that in terms of data availability um this question was missed is the proof block posted directly after the data block on L1 no so um kind of as you can maybe see in this diagram like the the the proof for these three you know data availability blocks um can come way later and that's fine right we can keep committing to the newest state of what our off-chain protocol thinks is the latest State um but from the L1 from the bridge perspective and maybe pulling funds out we're only going to trust that once we have a ZK proof that can kind of prove up to a certain uh chain head if that makes sense hopefully that answers your question Rory I don't know if I've missed any no that was um that was one that was missed so I just copied and pasted it down there but everything else um there was just one comment I guess that uh Meyer mentioned that it took 17 minutes for Theirs to get finalized um yeah and that's another interesting thing I think for the 17 minutes too that's probably how long it will take to um get Bridge from funds from the L1 to the L2 right if you're bridging Worley from L1 to L2 we have to make that transaction and then basically that sits on our on our relayer and it's going to say I'm not going to make this on the L2 until I'm really you know till the L1 has called this transaction safe and that just has to do with epochs and finality on the layer one is that why it takes you know somewhere usually around I think eight to sixteen minutes um for for that bridging to occur so awesome well cheers I think that's uh all the questions we have um so yeah thanks so much for joining us today and for the great presentation uh Daniel and um if anybody has needs has any follow-up questions I'm just going to post a Discord link to the scroll Channel feel free to reach out there thank you so much um I'm gonna add to the last coming question on my way out here and it says what circuits to scroll use uh check out haishun's talk from the intro but we have a repo that was forked from the ethereum foundation's privacy and scaling Explorations ZK evm repo it's all available on GitHub it's all written in Halo 2 and um yeah if you are a smart contract developer that also yeah wants to be thinking about the the circuit side of things check out those repos and we we love open source contributors so all right last answer there thank you so much Rory and everyone for listening and I hope to see some 