uh thanks again everybody for joining us this afternoon we're joined here by richard a developer advocate at chain link uh richard i'll i'll give you the space to introduce yourself probably better than i can um but i really wanted to shout out everyone for for joining us real quick uh the floor is yours man take it away yeah sure so let me make sure i can share my screen too because you know that's like the hardest part and still see people maybe and can everybody see my screen is that working yes yes fantastic so yes i am richard gottlieber i'm a developer advocate at chain link labs uh you can see my twitter an email there if after this you want to reach out chat about this presentation anything else blockchain not blockchain related whatever i am game to chat love chatting with people uh yeah so i'm going to be talking about chain link and some of the really cool things that come along with chain link and oracle networks so to get going just to make sure we're all on the same page you all probably know this already but smart contracts are this new thing that enable you to have cryptographically based agreements and one of the big powerful things about smart contracts is that they enable you to have agreements that are based on truth instead of trust and what i mean by that is traditionally agreements are based upon a third party being involved to ensure that the agreement happens personally i live in the united states legal system here pretty much always ensures that agreements that are legal agreements happen but even that pretty much kind of bothers me a little bit because i think the world would be a lot better place if everyone had access to agreements that you knew were guaranteed to go through and that's where cryptographic agreements come in so they are based upon cryptographic truths and smart contracts are these agreements they enable you to have a contract an agreement that you know is going to work but along with blockchains there comes this other thing where there is this decentralization and distributed piece as well and in order for that to work blockchains have this weird quirk where they need to reach consensus they all need to agree and yeah i think luke mentioned i'll do my best to answer questions if you have any questions toss them into the chat here but i'm going to ask you all a question real quick to see if we can reach consensus can anybody several of you hopefully tell me what one plus one is and that's a hard question i'll wait for answers in the chat oh luke luke's being a problem so one plus one normally that is what we would call a deterministic value we can all agree normally that one plus one integers are two right and that's a deterministic value it's always going to be the same if i present you with that problem the answer will always be the same now if i were to ask what's the temperature outside i don't know if anybody wants to answer that but i'm going to go ahead and predict the future that we're going to have different answers then we're going to have answers maybe some are in fahrenheit maybe some are in celsius and it's gonna depend like even if you ask me that question when you ask me that question it could depend on which uh thermometer outside i'm looking at right and those are non-deterministic values and the real world is made up a lot of made up of a lot of values that are non-deterministic temperature is one example of this things like generating a random number anytime you ask somebody to give you a random number odds are it's going to be different than another person and that makes it very difficult to come to consensus right if you imagine the blockchain and all the different nodes need to all agree on what has happened trying to agree on something like give me a random number it's going to be problematic this is often referred to as the oracle problem bringing this non-deterministic real world data into the blockchain and blockchains they have all these benefits but i kind of think of them as being like isolated in this deterministic bubble where their benefits can only exist because they live inside this bubble so given that and given that disconnect that's where chain link comes in so chain link is a oracle network and it's a distributed oracle network and why that is important is you could definitely set up your own oracle and i'll pause your questions here in just a minute once i get through kind of this just to make sure that we're all on the same page um so you could spin up your own oracle node definitely you could bring data into a smart contract and feed that data into blockchain but if you remember i mentioned that one of the benefits of blockchains is that they are decentralized and that they're distributed if you spin up your own oracle node you've now taken that decentralized power and essentially centralized it into that one node that's a problem you've introduced a single point of failure that could mean you know if that one node goes down so maybe you build in redundancy but then you have one operator controlling that group of nodes that's redundant there's no guarantee that that operator is doing things in a truthful manner and so you again kind of lose the power of decentralization unless you have your oracles in a decentralized network and that's what chain link is so chain link is a decentralized oracle network that provides access to off-chain data to the blockchain so i'll pause here for just a minute if y'all have any questions so far i see lucas is asking what about legal considerations when you use chain link for gambling games um i don't know as far as this talk goes about answering that i think that that would be a probably an it depends uh situation depending on where you are and whatever the rules are and laws are around that as far as ensuring things for gambling like ensuring the random numbers that are generated are actually random chain link can do that and we'll talk about that in just a moment but i'll pause for a minute see if anyone else has any other questions so far or if everything is clear as mud okay so we have a decentralized oracle network that can bring data on chain and that solves the one problem about bringing that data on chain but we also have the problem of the data that's being brought on chain being non-deterministic and one of the solutions to this is to have a mechanism for reaching consensus within that process of bringing the data on chain within chain link one of the common use cases is bringing pricing data for different assets into smart contracts and as you can see you have the node network and each node is reporting slightly different prices um those nodes the way that this works to kind of reach that consensus is to they each node reports the value along with their signature so you know which node is reporting the value to a smart contract that smart contract acts as an aggregator and it takes the median price in this example to ensure that there is an agreed upon value so even though all the different values come into the contract you can have a deterministic value based on the different values fed in because every time you look at that set of data you can get the median and then that is a deterministic value so that's one way to uh deal with the issue of non-deterministic data and bring it into a deterministic bubble that is the blockchain this enables you to create hybrid smart contracts which are smart contracts that have both on chain and off chain data and in my opinion this kind of like unlocks like another world of capabilities when it comes to smart contracts and i know i i think that's really exciting and we'll talk about some of the things that chain link offers in a little bit more detail next but before we get into that are there any questions so far and two like as i'm going through feel free to pop questions into the chat too as they come up and i can read them as we go you make a scoring mechanism one to ten and nodes people say ranks smart contract compiles the aggregate score i'm not sure i understand the first part of your question brian um so yes if nodes are reporting different values that's where um the kind of deterministic piece would need to happen within the smart contract so you can have those oracles uh reporting their different values and then you need to i guess kind of implement however you see it as being the proper way to implement it uh the method of getting to a single answer like a definitive answer for those different values does that make sense okay cool so what does chain link offer currently we offer data feeds uh which as the name implies are feeds of data to bring data on chain vrf which is a verifiable randomness function when i see vrf i think random numbers and then keepers which are fast becoming probably my favorite thing that chain link does currently because i see a ton of potential there keepers are essentially a way to automate smart contracts and we'll actually be looking at a demo that uses keepers here in just a little bit so data feeds first and foremost as name implies like i said it's bringing off chain data on chain uh it's enabling that data to be brought on in a secure and reliable format um the reliability and security comes from the fact that again you have that decentralized oracle network the different nodes within the oracle network are run by independent operators so there's not a single entity that's controlling the node network that helps increase the reliability and security of that network of oracle nodes so you can bring on everything from you know financial data apis from different websites so api is being like any sort of programmatically generated data like weather sports scores you name it there's probably an api out there for it i think there's one for pokemon and getting all the information about pokemon the sky's the limit when it comes to that but essentially it enables you to bring any off-chain data on chain to enhance your smart contracts if you head over to data.chain.link you can see the price feed data which is one of the most popular current uses of data feeds it's essentially uh asset pairs so in this example that you can see here it's uh if in terms of usd and you can see that there are different oracles each reporting their own separate price and then consensus is reached on what that trusted answer is a couple interesting things to point out here is that there are trigger parameters so there's parameters that will cause the price to be updated one of them is a deviation threshold so it's going to be if the price changes a certain percentage it'll update the price within the smart contract aggregator or if a heartbeat occurs so every uh so often it depends on the price feed the price is just updated regardless of deviation and value so yeah i don't know if there's any questions about those so far my imagination is not that great and so thinking about price feeds and lens protocol i'm not sure where that would go but that's probably why i'm not in the hackathon i do think from a data feed standpoint there is a any api function which will allow you to call any api and that could be very interesting thinking about this hackathon and possible uses there i will say we very much support using that for and suggest using that for things like hackathons when it comes to production projects any api is not recommended simply because it's not distributed decentralized you're using it as a single instance do all these companies pay to validate the data or they collectively paying gas this is an interesting question when it comes to how are these things paid for so let me just head over to this and let's take a look at one of these really quick so each of these is a node operator and they're all operated by different entities you can kind of see who the different operators are given their logos you might recognize a few of them but the node operators so they they operate their own node they pay to operate their own node um independently and then as far as the cost of this being brought on chain when you make any we like to call a state change to a blockchain that costs gas uh so anytime that you were to update this trusted answer so this value is actually stored within a smart contract whenever that's updated yes there is a gas fee associated with it to use this data feed is essentially free as a consumer given that reading from a blockchain has no cost associated with it however if you're building a project that relies on this value being here you're kind of incentivized to ensure that the node operators are bringing that data on chain um so that's why if you look on these pages you can see some information like the price history uh information about the different oracles and then down here we have users and these users are kind of like sponsors and that they are incentivizing the node operators to have this data feed available does that make sense sure thing all right so that was data feeds now let's talk about vrf vrf like i mentioned is randomness it's generating random numbers in a verifiable fashion and that is really important when you need numbers that are provably random and you can ensure are actually random and what i mean by actually random is when we're on the blockchain we mentioned that we need deterministic values one way to generate a random number is to use some sort of seed that would in theory be random into a hashing function and what the hashing function will do is it will take the input and create a hash and that hash can then be used as your random number now on the surface it seems like that will be totally random and it is to a degree let's take a look here and pretend ferment that we're simply betting on the outcome of a coin flip um if i win the bet and i call heads or tails correctly i win say a million dollars i'm incentivized to win if i'm running a node i can know what the function is that's generating the random number if it's being generated on chain in a smart contract smart contracts are transparent that's a very good thing but it's also a risky thing if you're not careful this is one instance of that so pretend that we are using the current block uh hash id as the seed to generate a random number i can as a miner on a blockchain choose to either mine the block with that randomness or not so it's kind of like if we're rolling dice i can choose i guess i'll go back to the coin flipping example i can't choose the outcome of the coin it's still random but i can know the outcome ahead of time and choose to re-flip and then once the flip is advantageous to me i can say yes that's the flip that we're going to be you know using for this bet so you can't fix the random number but you can regenerate random numbers potentially if you're a malicious actor when they're generated on chain so that's where vrf comes in vrf uses the node network so the decentralized oracle node network to generate a random number with a proof of randomness and then that number is submitted back to the chain so there isn't a way for the random number generation to be maliciously tinkered with in the same fashion there are projects like pool together and avagachi that are using this pool together use it to pick their lottery winners which you know kind of a big deal i know in the past there's been some shenanigans about actual lotteries uh off-chain not being honest um and then avogadro uses it for picking random traits within their ecosystem of nfts so questions about random numbers okay let me go on to the last one which uh it's my my personal favorite at the moment and that's keepers keepers are essentially in my mind like if this than that for smart contracts we've talked about all these benefits about smart contracts all the you know things like truth based agreements the fact that they are decentralized distributed the transparency one thing to know about smart contracts is in my opinion i like to call them unmotivated they don't do anything by themselves that's where keepers comes in so keepers gives you a event driven framework to execute smart contract functions so that can be time based or based on other events um like for example looking back to our data feeds the price changing essentially the oracle network will monitor whatever the triggering event is that you have set up in the case that that event happens it will then call a function within your smart contract we'll actually take a look at that in the demo here in just a moment again this kind of goes back to the same conversation as the oracles and setting up your own oracle you could set up a computer to call your smart contracts functions but then you're relying on a centralized source to ensure your smart contract is being executed properly and keepers abstracts that away and kind of takes care of the devops type work for you in a distributed fashion so before we get into the demo here's a link to the code and all the links that will be in this do we have any questions before we dive into the demo you make time-based events as one-time thing or is it um so you could set up one time based upon different triggers and actually i think that we can address that in the demo i can show you that in the demo so let's dive into the demo this one's kind of about nfts we're going to make an nft grow from a seed to a little seedling to a full flower using keepers so one nft is going to change state based on a keeper updating it um so yeah let's dive in to the actual code this contract is essentially a erc721 contract straight from open zeppelin's erc721 wizard with a few couple minor changes i have a array of strings for the ipfs uris essentially this is the metadata that will inform the nft about the different traits attributes of the nft for the seed it looks something like this we have the name of its current state a description the image and a few attributes both the metadata and the images are stored on ipfs distributed file system it's pretty cool it's the interplanetary file system which i don't know just sounds really cool we have our erc721 with its name and its uh id and then i've added this function grow flower which essentially is going to look at the current stage of the nft and then take it to the next one if it needs to so that's pretty cool so let's make this dynamic let's use keepers to do this so as with everything chain link related the docs are the best place to start docs.chain.link they're kind of broken down by type of chain we have evm chains ethereum binance polygon you name it solana and tara we are going to be using keepers so we'll head to the keepers bit and we'll look at making compatible contracts keepers requires two main functions to be added to your contract in order to make it keeper compatible the first is check upkeep and to your question brian this is where you would have some sort of value that would be false if it had been triggered already so what check upkeep does is it says does the keeper network need to execute the perform upkeep function on this contract this is going to be a view function it's going to return data there's no gas fee associated with check upkeep so the keepers network will kind of pull to see does this contract need to be updated if this is true then it's going to run perform upkeep so those two functions are what make a contract keeper compatible uh there's examples here i like to go all the way down to the bottom and here's a full keeper compatible contract that will increment a counter based on keepers but i like to just kind of steal the code right here and then modify it for our needs so go ahead and take this code pop it in here and you'll see this contract is based on a couple of things it's going to be based on the timestamp of the block the last time it was updated and then this interval so we don't have these two variables in our contract so let's go ahead and add them to our contract the first one is what was it again it's last time stamp so last time stamp and that's going to be a mutant and then we also had a uint called interval so interval is going to be how frequently we want the keeper to run the perform upkeep function within our contract i would like to put that n as the constructor just so that every time this contract's deployed i could choose how frequently it updates so we'll go ahead and take that in uh as a value here and then within our constructor so the constructor runs whenever the contract is first deployed to the blockchain within our constructor we'll go ahead and set those two values as well so we'll set interval equal to the value that was passed in and we'll go ahead and set last timestamp this will be the last time we checked to see if we needed to run our upkeep to block.timestamp um and that will get us sorry that will get us our current time stamp for when it's deployed so at this point check upkeep should be good to go it'll tell us if upkeep is needed if the difference between when this is running and the last time it ran is more than the interval that we want to update sweet we also need to update perform upkeep to not do this which is to increment the counter but to grow the flower and grow flower takes in an integer that is the id of the nft in this case we're just going to force it to be the first nft that's minted just for demo purposes one other thing you may notice is this code here looks oddly similar and that's because anytime we perform upkeep it's kind of a best practice to ensure that you still need upkeep just on the off chance that something has changed in between and you don't actually need to perform the upkeep so we're re-checking that we need to perform our upkeep so at this point we are ready to deploy this so we'll go ahead and pick all the things here and we'll set our interval to say 30 seconds we'll deploy it i'm putting this on the mumbai the polygon test network so while this is deploying does anybody have any questions so why not use require um i don't know that it would make a difference really i think this similar similar outcome um you could always set the state in the contract or require state to be zero why did i delete override so i don't understand the robert i understand that you could always set state bit uh why delete override because in the example it's overriding something and in when i'm using it here i'm not overriding anything uh in the example uh it's a keeper compatible interface and so that already has these two functions and so it's overriding those functions in that interface and since i'm not importing that i don't need to override them cool so we'll head on over to keepers.chain.link oh cool thanks robert went on over to keepers that change that link so we have created our contract we now need to create the keeper and inform the oracle network that hey there's a new upkeep that we want to be keeping track of so we'll do register a new upkeep there's a few things here that you need to fill out [Music] email address is important because there is a balance for this imagine this is a bucket of link link is the token that the oracle network uses um and if that were to get too low it will email you and say hey your keepers are about to stop working because you've run out of link things like that one other thing here is that you need to provide the address of your contract so first you have to deploy your contracts we did that we'll grab the address here and then you create the keeper or the upkeep so we add that in here we register and we approve it and while it's happening before we can upkeep a nft we need to mint an nft so i'll go ahead and create one real quick and there's a couple different ways to see this kind of evolve we can look at the actual stage which will go from zero to one to two or we can look at the actual uri you remember that's these values here and they end in kind of a different name that we can take a look at so you'll see it's a seed here and then finally if openc is being friendly and updating quickly we can take a look at it here and maybe see it okay it's already gone past the seed i missed the seed on open c because it took too long it's more than 30 seconds it passed if we look at our upkeep we can see we funded the upkeep and then we performed the upkeep so that's why it went from the seed to the little sprout but we did see here before that happened that it was zero at this point it's one um and we're at the sprout here and in just a moment we should see that it goes to its final stage it may take 30 seconds while we wait for that to happen though uh thinking about this hackathon thinking about ways to maybe use something like keepers within this space i think that's anything that you think of where you want to either like retire or get rid of things on a certain time frame or pull information from a smart contract on a given time frame or have when something happens have it trigger something else these are all different ways that you could use keepers within your smart contracts i know there's some conversation going on i don't know if anybody has any questions while we wait for this it should be up to date so if we just refresh the metadata here we should see it's currently a sprout and then if we refresh and refresh the page yeah so the keepers have turned it from the seed to the sprout to the full-on blooms so just like that like every 30 seconds it was updating the different values i don't know i think it's pretty neat um but yeah what questions we have how do i stop other actors from calling my upkeep function so the upkeep function you could limit it to i believe is it where did it go you could put a require statement in here to do that to ensure that it's only being done by the keeper network but i would posit that anything that's within an upkeep you it's going to be called on a regular basis and so that's why you'd want the checks in there to ensure that that upkeep should happen if someone wants to perform a uh on change like state change transaction for you and pay the gas fees for you i'd say like you know more power to them um because because they're they're paying for your smart contractor to be updated which is kind of cool but yeah i think that's within that function you should think of it as this can be called at any time and kind of structure the logic in there accordingly does that make sense so yeah i don't know if anybody else has any questions thoughts how do we deploy an api i don't have time already like past time um but within the docs any api we'll get you that information and it's the same level of like example code here you can just click uh open remix it'll take you to the contract here you can deploy it and mess with it there when oracle's update who is paying the gas or do the users sponsors pull money into the need just curious state chains gets paid for so the oracle nodes when they are actually making a state change they are paying the gas um they are i guess compensated to do that they're incentivized to do this via link token so for example when this upkeep ran uh it costs a little bit of link the amount of link it costs will be dependent on which network we're running on this is on polygon so it's not a lot of link um but yeah that's kind of how they're incentivized to do this work is through the link token stuff everyone continues this conversation discords yes underscore to be great cool i think we're good right on everyone thanks for uh asking such inquisitive questions there and thanks uh richard for for going deep to answer all of them that's been super helpful this has been an incredible presentation thanks uh as i mentioned in mozart go ahead i will say the chain link hackathon is starting soon too uh i'll pop a link to that in the in the chat as well but just uh just fyi i missed that slide i got too carried away with questions this is the questions are too much fun uh on that note i encourage everyone to reach out and discord and continue those conversations great place to ask those questions if you couldn't thank them right now uh they will be around uh patrick perry sorry richard i'm sure you'll be around uh and some of the rest of the team so that's an an excellent opportunity if you'll be building with chain link i highly recommend hitting them up in in the channel and discussing further other than that uh we'll be closing the room here i want to thank everyone for joining us this afternoon uh and thank you richard for for your time and uh going going above and beyond 