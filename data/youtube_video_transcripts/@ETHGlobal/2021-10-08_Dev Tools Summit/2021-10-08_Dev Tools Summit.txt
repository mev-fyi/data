foreign good morning good afternoon good evening everybody my name is kartik one of the co-founders of Eep Global I want to welcome all of you to our devtools Summit so all of you are watching this I need global.tv just a quick reminder for those of you who are joining this thing for the first time this is what we're going to use for the rest of the day so this is a live platform so if you have any questions for our speakers uh you can just sign into the chat and ask those questions there and we will be able to relay those questions directly to our our speakers today also for everybody that joins in we will be giving in giving it a nftpo app to all the participants so sign in and say hi and uh for those of you who are curious on what the timeline looks like for the poapps it's going to be right after each online ends which is next Friday so if this event's organized by each Global and for those of you who don't know what each Global is it's an organization with a very simple Mission our goal was to onboard thousands of developers into the web 3 ecosystem and we do this by running hackathons and summits so eat online is our biggest event of the year ethonline is a collection of a handful of summits and a month-long hackathon for the hackathon we have over 1100 people from 77 different countries participating from 19 different time zones is an incredible number of folks from so many diverse backgrounds and and skills and we can't wait to see what they build when we see all the project submissions next week on top of that we're doing six incredible Summits highlighting all the amazing things happening in this ecosystem so our first summit was about nfts and creators on September 24th then we did a summit about the Ave grants ecosystem on the 30th last Friday was our Summit around governance endows and everything that's happening in that sector yesterday was our Summit highlighting all the amazing things on the compound grants ecosystem and today of course these are devtools summit we're going to talk about all the things that you have access to as a developer and all the amazing tools that you can use into your existing workflows so I can't wait to uh dig in and next Friday will be our last Summit and also the hackathon finale where we're going to Showcase all the amazing projects from the hackathon as well as talk about the future of ethereum with these two so let's get into today's Summit so we have an incredible lineup today uh there's so many amazing people from the developer side that are going to come on and talk about what they've been working on we're going to kick off the day with Austin who's going to talk about how everything is structured under the hood for scaffold eat then we have Rick Moon talking about all the latest updates and features in ethers JS V6 then Mark is going to talk about how to use used app in rapidly developed apps um and then we'll have frenzy talk about sourceify and what you can do with verification and how you can do that a lot easier then we'll have Hari talk about all the new features in the latest version of solidity Yusuf is going to talk about how you can store off chain data easily and manage all of that with web 3. storage in nft.storage then we'll have Chris talk about eat SDK and how you can make smart contract interactions a lot easier to debug and code we're going to have an amazing panel discussion with Sam CZ sun nakesh morillion and Rajiv around just security for your smart contracts and then Daniel's going to talk about how you can decentralize front pins with tooling and and home screen from the Skynet team Patricio is going to talk about the future of hard hat how he got stronger and where it's going which I'm super excited about and then we'll have Gilbert talk about how do you actually write smart contracts without solidity uh it's going to be a pretty big overview of how everything works internally for on the EDM and then our last talk will be by Kelvin who is going to talk about Smock showcasing everything you can do to do better testing for your code so it's an amazing next six hours so grab some coffee and something to eat and uh we'll quickly get started so without further Ado let's kick off with our first talk of the day I want to welcome Austin who's going to dig right into scaffolding so Austin welcome thanks for having me kartik excited to do a whole day of Dev tools this is really neat there's a lot of Giga brains that you guys have uh amassed here together to to talk about tools and ethereum I like you said I will Dive Right In I'm a builder on ethereum and uh I work on this tool called scaffold eat with a great community of folks but just to zoom out just a little bit this is a great landing spot ethereum.org is a great place to uh go for a big picture learn learn the how and the why and if you get in here uh for developers there's uh the tools that we're gonna a lot of the tools that we're gonna see today are are here uh listed somewhere somewhere on this so you can get uh started and I'm going to be talking about scaffold eat but scaffold eth is just a collection of a lot of other tools like like hard hat and ethers so we'll hear from them uh later today too so let me jump into scaffold eats so scaffold eat is uh it's a Dap template I found that like creating my whole stack took a lot of time at every hackathon so scaffold eth is a template where you have everything freestanding and working at right out of the box and you can kind of tinker and learn and go from there and and what I mean by that let's just go ahead and get it started here so I I've got my front end so so if you go to I don't know a few let's see let's let's Google scaffold eat there if you scaff Google scaffold eat that's going to drop you right into the repo here and you can follow this uh basically you'll you will need like node and yarn and get and uh that that can take some time to set up make sure you get the right yarn if you're on Linux uh I I go through that a lot with developers where it's just getting the environment right takes takes a little time then you'll clone down scaffold eat uh yarn install and yarn chain and yarn chain fires up hard hat so it has a hard hat note on the back end it has a bunch of wallets for us that are loaded up with eth and then you'll yarn start and that will bring up your Dev server your react server your front end so we kind of have a back end and a front end and then uh the last step is to yarn deploy and what that's going to do is take this stock contract this kind of like example contract for you and it's going to deploy it to the front end if I bring this down let's see I don't even know what I'm doing here let's let's put that there then we get uh our this interface and this interface is the key piece to scaffold each being able to have your smart contract here and your front end here and be able to do things like let's grab this person's address and let's make an address public owner and set it equal to that and hit save and then yarn deploy and you get in this iteration Loop where you're you're you're testing uh your assumptions you're building on uh your smart contract your learning solidity and kind of this front end is kind of Auto adapting to your changes as you as you write your contract and figure out kind of how that's that's going to work and look so uh one one fun uh uh thing I like to do on a mentorship session is just set it up so maybe like the owner can can edit this first or so the owner can set the purpose first right so we're going to make sure that the what message dot sender has to equal equal the owner right and if it's not then we will say not the owner simple simple solidity we're testing it out we're trying it out how do we go about testing this well this this leads us to how wallets work in scaffold beef so if I bring up a incognito window oh not the loogies if we go to localhost there we go and not I think it's 3 000 there we go got a lot of got a lot of apps running here okay so if you bring a up a an incognito window see how we have this like green account here and then over here on my other window there's kind of like this purple account and there's this big annoying button that helps you grab funds from the faucet for any of these accounts kind of as they come up but no this is just like a burner wallet eventually you can connect your meta mask or or some other wallet and that's going to be there for you but at first just testing what you want to do is just kind of use a burner wallet and kind of just click and and make these transactions quickly for example if I wanted to send some funds from from purple guy to green guy I can kind of just copy this address and then over here in the wallet I can paste it in and I can see visually that we have the the the correct address and I could send ten dollars and notice how it's in USD right like scaffold these is doing a lot of stuff here with these components so it it makes adapt just feel and work better right we can we can click back and forth between eth but for the user they're like yes I just want to send the 10 bucks and I just want it to go right so you notice no metamask prompt uh we we have notifications locally and that'll fill in with block native eventually when you go to a public network but you can see that I can send money between those two wallets so now these two wallets are interfacing with our smart contract so if from this uh dude right here who is actually the owner we could see if I say hello world and I send that in we get Hello World to Change and if we do a read there we see it and this should fail right I think if we did everything right yep not the owner awesome okay so it yells at us that it's not the owner we kind of tested that line and made sure it works but we also kind of learned how how wallets work along the way right so let's just kind of let's see the the the the the the thing that I like to explain about ethereum is that it's like this massive multiplayer game and that this this is kind of centralized what's more fun is if we think about our smart contract as like this vending machine right that we want to access and so I always do this payable example next where instead of requiring that it's the owner let's let's trigger off of the value let's make this thing in from an attestation smart contract into more of like a vending machine smart contract and and we make it payable and we set the message Dot and we double check that the message.value is greater than or equal to like 0.001 uh ether right something like that and we'll say not enough and on the other side we deploy that and we should see our smart contract load in and now even the bad guy if the bad guy wants to participate in our smart contract can play along right this this should work now but it should cost me some money and let's let's send in just this and here's a new here's another developer learning point here where you have to take this times 10 to the 18 right in my UI I force the developer to go through that clunky process so they realize we're switching into way here as we're sending it to the smart contract and once you do that there we go so it did work and something interesting has happened here though right this contract is now uh has some value right and what we would do is probably move on to build some kind of withdraw function or something that lets the the developer pull those funds out of the contract but whoops I close it up let's let's dive into that's that's kind of like the tldr of getting started with scaffoldings right you can pull that down from the repo you can get in you can start tinkering with your smart contract and your your front end is going to Auto reload let's dive in and just like look a little bit more at scaffoldeeth kind of just look at how it's set up so uh you'll have these major packages and it's hard for me to show here but it's really small but the the packages that it comes with are hard hat and react those are the two like major packages and your react.jsx is kind of like where you start to build your app it's kind of what's this deploy displaying all this stuff and and it kind of sets up all your wallet stuff it sets up all your providers and then there's a bunch of Handy hooks here like use balance right you put in your provider and your address and then you just have the balance of that address on that Network kind of stored up in your state and and kind of digging in a little bit more to how we're working on scalp well these we're kind of working on that like a kind of global context like a single context for all the web 3 stuff so it's not as messy as this so we are cleaning this up and working more and more on the repo and and to dive in that in a little bit more I'd like to talk about each hooks for a second so we as we build out scaffold eats we realized that there was this all these hooks that we were using that were really uh really useful and we wanted them to be their own Library basically right like having them in scaffold Heath is really handy because we can edit them live but it's much better if we carve those out and kind of give them back to the ecosystem as a library that anybody can use in any project and so that's ethics so we took the hooks out of scaffold eth wrote them in typescript cleaned them up uh put them up in their own npm package and so now scaffold just brings that in but you can use it as a dependency in your app too and there's tons of Handy hooks that you'll find when you get in and try to try to build a Dap a web 3 app is going to just need a lot of this information right so just know the ethics is there and it kind of is carved out of scaffold eat and we're trying to do that more and more there's there's components here we'd like to carve out and then like eat Services there's all these uh like do you want to use ethers to pop like create 100 wallets and drop five dollars to each one like that's a little service right or even just like an SSL proxy in front of your dap so we'd like to have a Services repo uh soon too but diving in a little bit more to this front end things like Network display right if I'm if I'm on the wrong Network I'd like for it to prompt me and let me have a little button right your your dap needs all those things out of the box so that's why scaffoldeep has that built in so when you go to put your product out there people you know get a warning about being on the wrong Network and that you know they see their blocky previews and there's an address input with a QR code scanner so tons of Handy Hooks and components and services that we found that we needed as we built out scaffold eats that you as the wonderful developer at home can use to build your next decentralized app uh so let's see grab funds from the faucet so we have this nice faucet down here that kind of represents the the hard hat uh accounts that are loaded up with cash and they can send some money out you can even open up the wallet of that and send like a whole bunch right so so we got our wallets there uh let me look I want to show off this right here so this component is the contract component this is what's rendering this contract here so so you kind of have this solidity here you have your your contract here then you're deploying it there there's some hard hat config that you you'll get into and you'll learn hard hat and then over in the front end it's kind of injecting it into this contract component and it's doing that live every time you deploy your contract so it lets you really Tinker with things right out of the gate but then eventually you'll want to build an example UI right you you'll want to set it up so maybe you uh let's see can I do that you can hit a button and it will update that the the let's go back so I just paid for that one right so I just clicked a button that went to the contract and called that function on the contract and you can see that uh here in views if we go look at that I just do a ton of examples trying to show you all the different ways you could possibly do this so here here is that button right there that we just clicked and basically it calls uh it wraps it into transactions we get those notifications and you can also send raw things to that transaction but think of it more like a Notifier and then we reach out to our uh your contract and we set the purpose and you'll notice we throw this override in there where we send value along and that's using ether's uh Rick move we'll talk more later uh but but we we use that here in scaffold eats so that uh that knowledge will be uh transferable there okay so let's see so you've got your contract you've got your app you're able to Tinker for a while then eventually you go ahead and you build out some UI and then you've got let's say your app here and it's kind of like ready to go right what's what's the next step to push this thing to to production or to a live site so what we'll do is we'll need to deploy this contract to a live Network right and to do that we can't use our hard hat so I'm going to use a yarn or we can't use the there's like accounts that are loaded up with value on our hard hat chain we can't like have a free account that's loaded up with value on a public network right so I'm going to yarn generate oh I should make that bigger I'm going to yarn generate and that's going to create a local mnemonic here within my scaffold eth directory and then if I do yarn account I can I can see that account and see if it has any funds anywhere I'm just going to go ahead and fund that on some testing that looks like we're already on rinka B let's go with it so let's send this dude what 0.1 ring could be real quick hope this works let's go all right so so now our deployer within 15 seconds should have some funds and we should be set to do something like yarn deploy dash dash Network brinkovy and you can also get in and uh edit this hard hat file right here where your network is pointed but we're going to uh deploy with dash dash Network rinkabee and let's see if this goes please work first try this is using hard hat deploy from wigawog I think I understand his name right it's a deploy plug-in for hard hat so you know really cool ecosystem around hard hat there and a lot of cool plugins there and you'll have access to those as you build out with scaffold League too all right let's get this contract deployed okay so once we've got our contract deployed we need to start talking about our front end we've got our contract out there and technically our app is live and people can talk to our app by just talking to the smart contract but we'd like to build a front end around that right and so over in your app.jsx at the top there is this little Network selected right and what do we want to do we want to switch our network over to rinki and if I hit save there our app Should hot reload and now it's pointed at rank of D except for my contracts not getting deployed maybe maybe I could call an audible and go to a little bit different Contra or oh oh oh there we go there it goes there it is okay so now we're out on rinkaby and Now's the Time like maybe we don't want to use burner wallets maybe you want to connect in our metamask and I can set the purpose to hello world and I can pay .001 ringer B and of course you wouldn't have your end user have to hit that little button that's for developers you'll build a better UI as you build it out whoops oh man I should have cashed those all right here we go 0.001 can I do it on rinket B you'll notice we get now we get the metamask prompt and I can confirm that we'll get a nice uh block native notified dialog down here in the bottom right it'll track our uh public blockchain transaction right that could have been a deployment to uh mainnet if we wanted to so it looks like it's all working I'm going to do a yarn build that's going to build up my local react app and it's going to have this whole thing as a static app and I'll be able to push that out to Surge and and uh and use that app give that app out to other folks now there's a few things that you'll want to do before you go to production there's some constants like inferior IDs that you'll probably want to update probably don't have those pointing to the stock one that will fall over really quickly in production but that's that's zero to one with scaffolding that's how you bring it up that's how you Tinker with solidity that's how you start learning and that's you know once you have something it's just a couple more commands and you've got that as like a production app on a production Network work so let me just dive into like what you do with that tool that you basically that tool starts you off you have a license to learn at that point so in the last five minutes here I just want to cover like where to go once you have the license to learn and so I I the first place like of course we'll you'll look at your contract you'll look at your front end you'll you'll work on your develop your deploy script uh but then check out the documentation there's really good documentation for scaffold eat online video right at the top perfect right happy bow tie Friday by the way so in here you you've got all the scaffolding stack it kind of explains a lot of what I'm explaining already but does it in text form and then it kind of like gets you started with with what's next right so so once you once you've got the the app and the everything figured out uh you kind of want to go on this this Tour of Duty is what what we're calling it where there's challenges and and uh some some other stuff let me just dive in let's see okay let's back up for a second make sure make sure I cover the readme uh sequentially learning solidity a great way to learn solidity is just to have uh there's a lot of great apps out there too but just have solidity by example up and just like go through these uh these topics and kind of learn and what I mean by that is like okay how do let's learn how a mapping Works let's grab a mapping out of this mapping smart contract example and let's paste it into our contract and let's yarn deploy it and let's see what it looks like and then let's poke at it over here when we have that app so so diving into solidity that will get you the up the Dunning Krueger you feel like you can do anything but then it's time to go on a tour of Duty and learn kind of everything there is to to learn about how what works on ethereum and what doesn't work and and all the weird gotchas right and so that kind of is here and I I have this thing that I shall called the ethereum dev speedrun so if you are a web 2 developer or you know web 2 devs and they're thinking about getting into ethereum just tell them to go speed run ethereum and and hopefully when they type in speed run ethereum or whatever I typed in there they will get uh this medium article that talks about what we just talked about getting scaffold Leaf up and running getting the the uh the syntax down but then it jumps you into all these cool example branches so something that has come out of having this template for building dapps is a ton of dapps and a ton of branches so there's 250 different branches here uh ranging from nfts to different starter kits and different uh tutorials there's a ZK thing there we're seeing like these lists this composable nft is awesome I wish I had more time to talk about it but getting into uh svgs and nfts and nfts that go in nfts and render their like parents that render the children it's really cool how it all like the hierarchically renders an nft in all on chain in solidity but that's all a whole different that's the side quest as you get scaffold eat down you can go to any of these branches and all all of all the smart contracts all the front and everything is going to be kind of the same language everything's going to be kind of in the same place so once you know one good branch of scaffold youth you kind of know where everything is on all of them and you know you know how the wallets work and you know how to interface with a smart contract and you know kind of like what that context looks like okay so uh from these branches though uh the speed run once you have the syntax once you're ready to get in I recommend doing the simple nft example and the simple nft example I think I have right here will take you through the same setup we just went through but then you'll edit this mint script and you'll let's see can I is this what do I have a couple minutes let's let's just go look at this uh localhost 3001 you'll do the same thing where you probably want to create uh let's see a yarn deploy well I did I have a yarn chain and a yarn deploy let's see if I can get it to work uh everything's in the same place right guess what here's your smart contract right in that folder instead of your contract it's called your collectible and it's the super simple nft example straight from openc uh and and you can get in here and deploy that uh and once you deploy it you have a mint script and it says grab your front end ID and paste it in here and when you run yarn mint hopefully uh those uh nfts show up here there we go let's see if we can get an nft to show up all right and then I'm gonna grab whoops I'm gonna grab this address there they are and I'm going to paste it in here and I'm going to grab this dude's address and I'm gonna send him this Buffalo let's make sure that oh I don't have any gas gotta go to the faucet first there we go now send him this Buffalo oh I still don't have any gas what did I do wrong there oh I sent that guy gas that's funny uh now send him the Buffalo no don't use my camera send him the Buffalo isn't that nice that you have a QR code scanner though right on all your address inputs all right cool cool cool so so uh the simple nft example is your first step to kind of get context and move on to how like all these different branches work then start taking on some challenges take on challenge one it's going to build you're going to be building a staking app where you have to get a bunch of jerks to coordinate and if anything breaks down there then they can all withdraw you don't want jerks to be able to grief each other but if they all uh do coordinate then money moves on to another contract and and uh you're you're staking around kind of state machine moves on then took uh challenge two is about a token vendor and building a contract you learn contract to contract you'll learn uh like contracts talking to contracts you'll learn erc20 uh you'll learn the approve pattern if you if you sell your tokens back and then the third challenge is a little bit more open-ended build the decks and it's it's actually pretty easy using this article but you build a very like MVP decentralized exchange and learn about Reserves and and then uh kind of move on to take the buyer mints and start branching out right take some of these branches and take them to the next step or learn the thing that you want to learn next and there's a whole kind of like funding mechanism with build Guild where I'm funding developers that are building these tutorials so there's there's kind of funding available for folks that are kind of building on on top of this let's see if we can get right back to our app real quick and see if I do a yarn surge here I think our app is built and ready to go and uh what domain this will this will be it's like a ranked purpose so I'm just going to say our purpose p-u-r-p-o-s-e let's see if I can upload our this dap go from kind of zero to one and have the DAP fully deployed it will be at what our purpose uh surge dot sh no one like front run me and get get something on screen or anything I think we're where I'm I'm open for questions now we've got the app deployed uh reach out to me I'm Austin Griffiths on Twitter and telegram hey hey hey this is our purpose and I'm paying oh I don't have a rinkaby I need to connect here we go here we go connect my app in and say hey hey hey and actually pay some rinka B let's see if this works yes there we go so I went from zero to one I took took an app idea brought up scaffold eth uh built the contract out deployed the contract then I deployed an app uh that talks to that contract out to a public network where anybody could go to that URL right now and it'll probably fall over pretty quickly but you can use that to to interface with the smart contract and there we go it's hey hey and so yeah again check out the ethereum dev Speed Run it'll take you through scaffold Leaf at first but then it will move you uh I've been missing the chat I was supposed to be watching the chat sorry Karthik oh it looks like it looks like we're good actually you'll follow through a bunch of these branches a lot of these gotchas random numbers on chain and uh how how defy and swapping and lending work and how sign messages work there's lots of little gotchas that you'll learn build a multi-sig wallet and learn how that works good luck everybody happy bow tie Friday Karthik thanks for having me uh any any closing questions or anything I need to do on this side I think uh there we go um a lot of I mean a lot of amazing comments from the chat I think uh the easiest thing would be maybe you can just log in on these couple.tv and answer some of those quick questions uh mostly it's people requesting you should have your own live stream 24 7 call Austin and you can just always showcase Kathleen uh one question I'll ask you is uh what is uh what's kind of getting you excited about things that you want to add to Scaffolding in the future what are some of the things that matter what's so cool about it is it's it's all these it's it's random things all the time like right now the thing that I'm most excited about is this uh SVG nft library in scaffoldee so there's you know there's defy and there's governance and there's compo there's coordination tools there's all these different branches but really the one that I'm most excited about is like what I made loogies with which was just like a little SVG nft but it's like you get into the smart contract and you see like this is the Json like it's it's building it's crafting the Json and the solidity and then it's crafting the SVG and the solidity and we're doing something where you can send the nft to another nft and then when it renders itself it calls the render function of all the other ones so then you see all the little nfts inside of there like moving around super fun stuff that that's like I I don't know why that gets me so excited but I am super excited for SVG nfts awesome well thank you for actually standardizing that then in that case um cool well someone else did it I just made it easier to Fork that's the that's what I'm here for thank you Karthik thanks Austin we are ready to move on to our next talk so next up we have Rick moo and Rick's going to be talking about ether's V6 so without further Ado I'd like to welcome hey yes we can excellent excellent um so just jump in then yes sir excellent so um let me figure out how to go back to sharing screen so as some full disclosure I kind of got confused as to what talk I was giving today and so I prepared the wrong one so I spent the last hour throwing this together so there might be typos and such um can you see this yep excellent excellent um sorry we'll do it live with the Bill O'Reilly route yes exactly so um this has not been fully thought through or but here's my best um thing so I think probably a lot of people are familiar with ethers um so I just want to give a quick overview what the V6 is going to be about um right now V6 only lives on my desktop as a local repository but I'm hoping within the next two weeks to get a public beta out so people can start using it um I'm also hoping there's lots of questions that people have because I don't think this is going to take up the full half hour but we will see I'm also awesome talk uh uh Austin it was a it felt like a like the movies were like the the counters counting down and you're trying to get this this contract deployed in the last like you know it's counting down five four three two and then you're done you you've saved it you got just in the the neck of time so anyways back to ether's V6 um so one of the big things with ether's V6 is it's esm first so there's no longer going to be any ES3 support So if you're running node 8 or Note 10 um or you're using an ie era browser things probably will not work out well with with V6 I plan to keep V5 running for a little bit for people who who really need kind of those old old platform supports um but there's also some things I'm changing in V V6 that'll make it easier to maybe like use Babel to get those ES3 like things working um so also because everything is esm the build process is far more simple for those that aren't familiar the build process for for V5 because it builds ES3 and it builds um uh es esm modules the and also because typescript does not support multiple Targets in that way during the build process for com for composite packages during the build process it has to rewrite all the TS config files everywhere all over disk and then recompile it this just leads to a really complicated real process so this makes things much easier also esm has much better tool support like I said between Babel and all the different bundlers things just work also all the dependencies are esm which really helps the bundlers because the bundlers usually choke the second they hit elliptic or they hit bnjs or hash JS these like traditional JavaScript libraries so basically not in a nutshell esm first is like a key part of of V6 um and part of that is because now we can use modern es features for example we can't even use map or weak map or any of those that really or especially proxies those really cool features um that JavaScript has introduced in the last five or six years just because V5 tried to stay compatible with a very large audience so proxies are very cool for those unfamiliar with proxies they're basically a JavaScript object they can trap when you're trying to do stuff with them I've got a better slide next that kind of demonstrates that private members a lot of the things in V5 they were private just by virtue but they had an underscore in front of them um the problem with this is people kind of Tinker with and and and break things they don't even realize they're breaking by interacting with these private members especially other Frameworks I've definitely seen Frameworks who are tinkering with private members and then I get an issue because ethers isn't working for them but it's because it's been broken somewhere else along the way again much better bundler support this is an important thing I think for most people at the end of the day everyone wants to make a react native app which needs bundling or as loss was just showing with scaffolding you want this one thing all bundled up into one little concise package that can sit on the web and be served from some CDN and your app should just work bigint 20 yes 2020 bigint is kind of like um it's a it's a weird point for me because on the one side it's really recent es2020 if you have a browser that's that's made in September 29th or even if you have a react native app that was made in September 29th of 2020 it's going to fail the work with this version of of the library so for es2020 Biggins there's also an additional dist file which has a which is um got the big int stuff swapped out for the traditional big number libraries so internally it'll be a bit slower but it'll still work on older platforms um backwards compatibility for those who don't know me is very important I maintain a lot of really old um projects and it sucks when there's literally no path forward to keep them alive because I can't update this version of that thing without breaking this and vice versa um so next slide contract proxies so this is really where the proxies are going to shine um so right now if you use um ethers for a contract if you've got a function called Foo if you've got multiple multiple functions called Foo or in this case Adder it's hard for for the uh the system to know which one you mean if you have one that takes in an adder and a uh 256 and when it takes in an adder and a unit 128 there's literally no way that it can tell which one you actually intended which is why you then have to specify the actual signature which gets complicated this might be too much detail for some people I'm not sure but those who who suffered this they are very vocal about suffering this and so um they'll be the ones who appreciate this the most and I'm hoping people going forward will appreciate this without realizing that they're appreciating it but basically you can force a type so in this case we see that you've got a typed uh un26 you're you're casting this so if there is for example if there was a function called Adder that took in an address and a un256 and an adder in a unit 1.8 this is now non-ambiguous the system now knows exactly which one you meant because that chain ID has been forced into you into 256. the other big advantage of the proxies though is if you see the next three examples they're all they're all referring to the exact same method this this address that takes an address into YouTube U into 256 um well it'll normalize them before you even get to the point so the proxy actually gets the string and gets a chance to normalize it into a string to do a do a lookup in its own lookup table so it doesn't matter how you specify this method it'll be able to find the one you want whether you have extra things in there like the names or not the names whether it's a view public all those extra stuff it just throws it away so that's the biggest advantage of of having a proxies is at runtime I can decide what you probably meant now ethers will still never guess if it's if it's at all ambiguous then you're going to get an error you have to but you yeah the problem with ev5 though is you start getting all these warnings in the console logs just by loading this um this API this at runtime can tell you you know you're wrong you know go to go to jail do not pass go that sort of thing um so typescript when I wrote V5 it was very much based on V4 and I had never used typescript before and so as a result there was a lot of decisions that were made that were I mean at the time typescript was still very young but there was a lot of decisions I made based on JavaScript developers JavaScript is still very important the nice thing is modern typescript takes into account a lot of things for JavaScript developers that it did not back then so it's been redesigned a lot with typescript as a first-class citizen so typescript is like a fundamental part of of the library now not just kind of useful for for people who um who use typescript so all dependencies are fully type typescript there's no more weird little libraries lying around that uh have types that were made by hand and therefore maybe not quite right it also again goes back to the bundler thing because all the dependencies are typescript and all the bundle all the dependencies are uh ecmascript they kind of cohesively work together better without weird foibles there's also a lot more templating in in V6 and I'll give some examples of that next um but even with the templating I don't think there's many places where you have to explicitly specify the templating it will fall back onto meaningful defaults for you strict error checking is in now which is something I know a lot of people wanted in V5 anything that returns something can always return something or null and this means that you miss out on a lot of type checking because you if you're not doing it all checks then you might get a null object back and you won't get any compile time error for that and there's better separation between concrete classes and Abstract interfaces there's moving around more on that in a few slides I think again the slide deck is really new in my head so oh those came first excellent so concrete classes so I've moved some interfaces to concrete classes so interfaces are kind of good for things that you want the flexibility of just what they should look like whereas classes are nice because you can actually do things to them so one of the big changes is networks networks are now an actual class there's actually another slide even later later on about networks so I'll go more into it then um but it means that they can do much more things at runtime based on the parameters you gave them the other big one is transactions transactions for serializing and parsing they've always been a hassle because people do weird things people specify a v as well as an y parameter or they specify a vs as well as an S like there's all these things that I had to check and make sure they all worked together so now that transactions um are a proper object it's much easier to set all the things on it especially these days with EIP 2930 EIP 2017 EIP 1559 we have all these weird things that go with with transactions so this just helps bring them all together and much easier to to either parse or serialize or pass them around a transaction object is now a valid object for example to pass into a signer if you wanted to send it um and transaction responses for example inherit from transaction so it's just like all those all those that's actually a slide I should have made I'll make a mental note of that so basically The Inheritance model makes more sense because you've got transaction requests transaction responses transaction objects parse transactions all these different types of things now that there's a proper hierarchy to how they all interact with each other um you can pass one thing in from one thing into another thing that should accept that thing in V5 right now it does a lot of checking to make sure you're not shooting yourself in the foot but sometimes that shooting yourself in the foot is almost desired um so this makes sure that when you shoot yourself in the foot you're shooting yourself in the foot safely um if that makes sense also there's a much more flexible web API it provides pre-flight checks and advanced retry logic this is useful AWS has added a lot of functionality for blockchain type things but the way they interact with with authenticated requests means that there's a lot of things that are very hard to do right now so the new web API I'm looking forward to sharing I use it actually in other non-etherium ethers based projects so that's a bit on concrete classes so abstract interfaces I also moved the other direction some things that used to be classes are now interfaces um so the signer and the provider used to be classes that you had to inherit which meant if you want to do really custom things you sometimes couldn't because you had to inherit from provider you had to inherit from signer and now you're stuck because you might want to subclass something else that's more interesting or you might not want to implement a thing that's in those abstract classes but that it needed that you don't want uh yeah another big thing a lot of people ask for so I'm just blowing through these I'm hoping for questions to help clarify anything people so please write down questions and Bug Karthik for things that come up um I think you'll pass those along to me um so addressable this is something that I know people really are frustrated with there's weird errors because right now if there's a function call for a contract or there's a method on a provider that takes in a address it accepts addresses and accepts ens names A lot of people have bugs where they pass in a signer instead an assigner is a hundred percent reconcilable as an address it's just V5 doesn't do that so in V6 you can pass the insigners or accounts or anything that's a meaningfully an address into something that expects an address and so there's this whole address type that things can Implement to ensure that the system knows that they're an addressable and that they'll just work the new freezable API so this is another thing that ethers has always done and it's been a huge point of annoyance for a lot of people everything in ethers is immutable um this is really important for an asynchronous environment because you don't want to pass something in the provider have it preparing to do something with it and then you and another part of code start mutating that object and now maybe the provider receives half of the mutated States and half the non-mutated states so everything in ethers has historically been immutable so with the new freezable API you can pass in a mutable or immutable object the first thing it's going to do is create an immutable copy of it internal to the provider so you can go off and now do weird things to the the thing you have and be assured it's not affecting anything else there's also a lot of places in ethers where it passes you an immutable copy for example a transaction you might get a for example you might hit a provider ask for transaction um want to change some things on that transaction and then send that transaction maybe just update the nonce or something well you can't do that as it stands right now because those things are all coming back as immutable so with this you would get back an immutable copy but there's always on the freezable API you can do a DOT clone get immutable copy which allows you to modify the things you want to pass so it kind of like helps keep things safe by the things that need to be immutable or should be immutable are still but when you need a mutable copy for doing something useful um you can the air interface I'll actually go into more as well in another slide but it provides a type safety for the property access because ethers provides a very complex I love complexity word a very useful but not uh not the the way that most people are used to handling with errors um and yeah I'll get to that in a second anyways oh actually I'll get two next currently um so errors so here's a great example so great if you have a modern typescript thing errors come back as unknown you don't know what the error is so this actually uses a conditional type in typescript so it knows that the transaction replaced is an enum and so once you're inside this is air I don't know if you see my cursor I'm wiggling over top of the air dot replacement once you've once you're inside this block for is error it the typing system is now fully aware that the air object is of type which is an interface is the is the interface of a transaction replaced error sorry I'm talking fast one okay so yes once you're inside this block it knows that's the type so it knows what properties exist it also knows what types of properties are and so it also means that everywhere in the code that throws a transaction replaced error it must provide all the properties associated with that so it kind of helps on the coding side to make sure I'm not missing a property that you really want to exist and to make sure that when you want to use a property that you can have the type checking in place to verify as the property is the right thing um don't know how much more I think I'm almost done but so network network so this was talking about before one of the biggest issues ethers has right now is not just like issues but requests I have from ethers is people start having these weird chains they've changed that no one's ever heard of or they're chains that I've never heard of at the very least because I don't really follow a lot of these um like Fringe or even some of the common ones um uh chains so the network now bundles a lot more stuff into it but as a result the network is often enough to to specify a chain that's weird in a strange way if it has a different address format if it hashes things differently um if it needs to talk to l1s to do something the network object the network object is now more more cohesive more more flexible you can do a lot of a lot of those things so for example right now for BSC and for polygon and for um arbitrum I don't pronounce that one but for those types of chains they actually sometimes require a whole different package which provides a new Json RPC provider and therefore new static Json RPC provider and a new ether scan provider all these extra things just because they changed something that's kind of fundamental to ethereum but for their chains it made sense so with the network object being pulled out it means that you can now have just a a BSC based Network and things will just work the the world's a happy place all that extra work that needs to be done is done inside the network object instead of inside the provider um on that note the plugins the plugins uh are kind of part of that as well it means that a network can use a plugin to describe a more complex Behavior full of the one of the biggest issues with l2s right now is that the ens support is not obvious for how it should work ens on an L2 is somewhat complicated so with the new network object we're now able to fully support um l2s with ens basically they need an L1 connection but all that happens internal to the the network and the provider object so you can just start using ens names on polygon for example and also Duran I'm not sure people from North Durham it's an awesome way for l2s to interact with anything like baseball it basically means anything can become an L2 it's really awesome if you don't know about it check it out but there's built-in support for it um one of the big advantages of using plugins is we can in a very backwards compatible way add support or remove support for things like durin so during right now will be by default off but we'll have a plug-in that will turn it on in the future we have it by default on and have a plug-in that turns it off um yeah lots of awesome flexibility ah excellent I'm done so I guess I will open up the floor to questions if anyone has anything to I'm sorry I blew through everything really fast but I'm hoping to fill in the time with questions or the things I blew through too quickly or did not describe enough words to like um yes we're good here um all right so a few questions few comments and a lot of a lot of amazing comments um first of all everybody decided by typescript support so that's that's great that's not a question that's just a lot of Happiness uh obvious question what is the timeline of the release um how you're thinking about that and when can people try this out well so right so I'm hoping for a public beta in maybe two maybe three weeks I have a minor bump I need to get out this week um I'm hoping that's gonna be the last minor bump of V5 um so hopefully in three weeks time and maybe even earlier I can I might not have a version up on npm but earlier I am hoping to even maybe have a GitHub repo up so people can kind of see see the differences and if they're really ambitious you know try it out from that without npm support but it'll be on npm hopefully within I'm hoping for two to three weeks but you know this is ethereum so two weeks TM give or take a month um this is great uh okay so another kind of question in a theme is uh talking about you you sort of touched on this but talking about um multiple networks like is is the fallback provider the best approach still or how do you think about supporting multiple networks uh more appropriately and we kind of talked about some of them like optimism or arbitrary and meaningful of those absolutely so you should always still use the fallback provider if you have that opportunity um one of the cool things I'm doing with that is plugins so for example if you pull so there's ancillary packages so for example if you pull in the ancillary package for for polygon or for BSC one of the things you can now do is it can is that new package that you have that somebody else can even maintain not Richard someone else can maintain that package it can actually call into the default provider and register itself as a plugin so in the future so basically you would you would include ethers then you would include the BSC package but then when you do ether stock at default provider BSC it's actually going to be the BSC package it's responding to that and populating the object as you as you need um and so it will all so that for example will automatically handle um deciding how to connect to l1s so that you get uh ens support it'll figure out whether the network supports EIP 1559 or all those extra little things it needs to do so weird networks can do the weird things they need and I don't use weird as a negative connotation I use weird as in different like it's behaving not as ethereum does specifically but it's ethereum enough to to work yes cool um another kind of question which is that we can connect goes deep as you like here what are some kind of extensions that you personally wish existed that still don't um and sort of like how does the V6 architecture sort of help enable some of those things from your own personal wishlist so so um in terms of extensions um I'm not quite sure what that means I'm going to guess maybe like ancillary packages that's one of the things I'm focusing on in V5 is making more ancillary packages and I'm trying to move a lot of things so there's actually a lot of packages in V6 that will not exist that exist in V5 I'm merging some packages but for example Hardware wallets has been moved out into its own ancillary package so the advantage of this is it makes the turnaround time faster because I don't want people mucking around with the core the core is still something I want to make sure is like secure and concise and adheres to all the things I want to adhere to but the ancillary packages are a little bit more more open-ended and so for example what I'm hoping to at some point is to just give Ledger the ability to have contribute contributor rates to the insular package for Hardware Waltz so that when they make an update they can go in and make that change it'd be nice if trezor can also go in and make the changes as well there's still going to be a gatekeeping thing I still control publishing things to npm but I can at least let other people manage that sort of thing and so it's exact so it's the same thing as well for other extensions for maybe like diamonds maybe somebody wants a diamond API I don't necessarily need that built right into ethers but if there's a necessary package for diamonds um the the author of that EIP I could even give uh him or her I'm not sure um permission to to modify or update that as as necessary um so that's kind of like that's part of V5 ish but with V6 I'm making a much stronger push towards moving more things out of the core and into ancillary packages awesome um another question is around um how you think ethers will evolve to support um more Cutting Edge stuff like building or testing or interacting with zero knowledge applications or just circuits to kind of see that that's ether's gs's role or what should somebody think about in this case it would depend a lot um actually I've not thought of it before but I think it would make sense so for example there should be probably some sort of ZK you can imagine ZK sync could have like a ZK sync provider and again this would be a slurry package anything that they need kind of bundled inside I would totally be willing to add to to ethers but a lot of that stuff can just be added kind of like as a as an extension Library if you don't need ZK snarks inside ethers I'd rather not have it directly in ethers but if it starts becoming a thing where all networks start using ZK Roll-Ups for the specific thing then it totally makes sense to put in there and possibly even wrap into a plug-in for networks um and oh that's another thing I forgot to mention as well uh a big chunk of the redesigning for V6 is breaking things into a ridiculous number of files so in V5 everything was one file inside each package the problem is like bundlers and specifically tree shaking right fail tragically when you have one file it has it just it has to be so it has to be so pessimistic as to what is going to be possibly called that it includes stuff that is remotely or completely completely impossible to be involved so the nice thing is most tree shaking systems they understand file boundaries so if something requires me from their file it's completely out of scope of what's going to be necessary and so it drops it so um right going back to what we were talking about a second ago it's actually possible because of this this like splitting files to include ZK snark stuff in ethers and because it'd be in its own file separate from everything else if you're not including something that includes something that includes something that includes this it'll automatically get like ripped out by my most bundlers no big exactly and I think in that world like even if something is part of the core um ether's library and not being used you can still kind of make the argument so the case could be actually part of the core that's exactly I was gonna say that's one more quick Point as well as the size of this Library should be much smaller I'm using nobel's secu256 and a different big number library and because of es2020 it's it's going to chop like a ridiculous amount like I feel like between 10 and 20 of the size is going to get knocked off by this one Library change amazing um two more questions before we uh before we close off today um how can people kind of contribute to the project do you need any help with certain things what's kind of the process or things that you prioritize right so this is one of the biggest reasons why I want to move to ancillary packages because everyone wants to help I love the idea of people helping but reviewing code is hard the and the other thing is any code like people want little features at it and once you add a feature you may you may spend it three days making the feature but now I'm supporting it for life um so I'm looking forward to more ancillary packages so that I can actually just kind of give some of the ownership up if you really want this feature then you can add it um and so it's kind of hard right now for me to kind of like give pieces off to people to work on uh documentation is always appreciated I love it when people contribute the documentation I love tutorials and once and once in Syria packages are more of a thing I'm looking forward to having more people be able to like just take that and run with it um so that will be coming soon again TM and final question which has been asked a couple of times um can you share the slides with our audience so if you can just send that link to me and I'll be able to assign it to everybody in the chat so whenever that happens absolutely yep I'll send it out perfect thank you so much Rick um take care all right with that we are ready for our next talk so our next speaker is Mark I want to invite him on stage to talk about you step and uh I'll let him intro himself and talk about this amazing project so without further Ado welcome hey hey Carter great to be here great to see you great to be here on this event I'm talking to you guys one click this disclaimer I'm in a hotel in a public space that's the only place where there is a working Wi-Fi so uh there might be some distractions but but let's hope for the best So today we're talking about used up it's a framework proactive development of the apps and when ICD apps I really mean the web component the web part of it we're not going to talk about smart contracts today so it's going to greatly connect to the previous presentation of Richard that we that some of you might have seen on uh HHS so why doing a framework might be a question that many of you uh might be asking yourself and what could be possibly Difficult about building front-ends for depth right it's a simple web application it's a simple rear application well it turns out it's kind of hard and we really try we would know we kind of tried it all we tried react we tried react with redox we tried RX drives we try domain driven design we tried everything for our last four years and so we looked at what different people are doing and we really didn't find an easy way to build Fiat and I think there is no like any fundamental problem not any major problem that makes it difficult it just there's this little small little problems everywhere that makes it difficult and I give you you know a few examples seven seven my seven top picks right so first of all if you go to an application and you want to and obviously we want to make a good user experience we want to build great ux for applications for our users so first of all um and when the user goes to the app for the first time they want to be able to browse the app without connecting they want to be in the grid only mode before they connect the metamask before they connect the wallet of choice right so the app should support this really only mode and um the other thing is and you know that's not very hard you just make a couple leaves make sure to connect to read online provider easy peasy right but now the problem is you always want to show the most recent state of the application every 15 seconds or so depending on the network might be different times but you know new block might arrive and when the new block arrives some of the state might change some of the values that you display in your application might be different and you never know which one it might be it might have nothing to do with uh with what user was doing so but a lot of well application developers do is they keep querying every time every time every every few seconds they keep querying and see you know what is what is the status of this value over here what is the status of this value over there now that makes a lot of requests which brings up which brings us to the next problem which is how do we keep amount of requests small so that well first of all our inferioral chemi bill is not that high but second that you know the UI is responsive and the user can see the kind side and there is no like hundreds of requests in the background that you know one is waiting for the other and then there's the whole since we're talking about refreshing there's a whole thing when we're switching wallets right so when we switch from one wallet to another let's say I go to UNI swap I want to exchange from one currency to another I set up the whole thing I wanna exchange A to B and you know this is the exchange rate it all looks good but I'm connected with the wallet so I want to switch the wallet I don't want to see the whole application reloading right and actually if you go if you go to a documentation of ethereum they say if you change the wallet or you change the network you should refresh the whole application because it's so complex to figure out what needs to be refreshed and we're not not them anymore not with used up use up is handling that for you as you're gonna see so switching wallet switching network is becoming a thing now because now we have more and more often we work with applications that have multiple net that support multiple networks you know your own layer one you're on Layer Two you keep switching depending what you want to do all kind of bridges are being built all the time it's not anything extraordinary anymore anything weird anything in print as Rich what Richard would say and then there's the whole training of transactions and I know it seems simple you know like you look for the transaction if it's pending if it's successive it failed but then you know transactions tend to be slow users switch contacts user wants to understand but understand what happens the transaction fails is on already on the other screen maybe it was replaced maybe something else happened right so we want to have we want to give user support to give give him um information about you know uh the history or uh or the notifications uh of the transaction right history what was done notification what just happened sure and that's why we created used up we created used up just you know earlier this year I think it was March when we released kind of the first version and um and it's already used by close to 500 applications I believe so use app is a framework for rapidly app development and it's built for ethereum but really any evm compatible blockchain should be able to fund it should be able to you should be able to use that framework with any if you can based Network and um it's built we didn't want to reinvent the Wheel from we didn't want to reinvent the wheel so it's built on react it builds on meters that you might you know just in reach our presentation uh that was just before mine it's built on top of web free react which was developed by um guys in uni slab and became kind of a standard thing for managing the connection State and for testing it is a swapple Which is popular framework which we also have developed for a smart contract testing now it's a standard you can use it for testing your UI as well smart so without further Ado what are the features we really have three major features connection management Reading blockchain State and transactions and we really don't want to make it much more than that we just want to do those three things and do them really really well there will be some plugins there are already some plugins so there are other things that you can do with use that but this is really the core stuff that we want to support it we're already supporting and that we think it should be done really really well because that's what the apps are all about so what connection is doing first of all you have read only support out of the box you have support for Network switching and coming soon we want to be able you can now support multiple networks but we want to be able to support multiple networks in parallel so that you can you can display content from many networks easily so here's an example called this is really all the configuration you need to do you need to specify very simple uh configuration object which tells you what's your default Network in this case it you may not what is what is going to be your address your infuro Alchemy or whatever provider provider you want to use for your ethereum Json RPC for your for your access to ethereum and then you've wrapped your application with the app provider and give the conflict as an argument and that's it it's done your application is ready you can start developing your application without any for your ID and here is an example application what it does it's it allows you to connect it allows you to connect to um ethereum and it shows your balance so you connect with your meta mask or your favorite wallet there is a new hook so eaters is all about idiomatic react hooks so everything you do is a hook and it comes with all those great goodies that Ria who comes with which is like you don't need to think about refresh you don't need to think about state it just give you stuff and you can just use it and in this case we're using view features so again shout out to Richard and it and it gives you two things one is account which is your current account can be new if the account if not connected and activate browser wallet which is a function then you can call to trigger connection to metamask then we ask for balance use either balance which is again hook which have one argument give me the account you want balance for and the account in this case is just the account that we're connecting with again interbalance might return null because it might be uh we might be not connected or the balance was not yet retrieved and then we have a simple piece of interface the button to connect and we just displaying either the balance and you know we format it with format features which is again features js5 so here's how it looks like there's a connect button we click connect and boom off we go we can switch the accounts we can switch the networks and everything working everything is refreshing this is like all done under the hood you don't need to know anything about it and if you see this example application you can see there is actually more than just the account there is more than just teach your balance there's also the account and the value on eater staking contracts on each or two is taking contracts so here is the full code for the application without HTML and CSS but this is basically the whole code except for the configuration except for HTML and CSS that you need to that you need to have so again we use use it or balance in this case for staking contract which is just a concept that contains the address of the statement contract we use account from use from user user and we use user balance from uh well we just grab it from The Hook and the hooks again they're gonna take care of all the refreshment whether it's different wallet different network whether we're not connected whether we read only mode whether we're not in the read only mode so that was pretty easy I hope uh so yeah let's see again pretty easy we have this little notification at the bottom we're gonna uh we're gonna I'm gonna explain what it is a little bit later everything just works boom so that was just to show you connecting and very basic reading from the blockchain now we're gonna dig deeper into other functions for reading from the blockchain so so what is reading from the blockchain gives you more than just eaters well it gives you Auto Refresh on your blog it gives you Auto approach a wallet change and here is a new thing combine multiple calls into a single multi-call so everything that you see on the screen is aggregated into one collection and every few seconds there is a single call asking to your note hey is there a new block nothing to do is there a new block oh no new block nothing to do is there a new block oh there is a new block and everything that is visible on the screen and nothing more gonna be combined into a single multiple and a single request is going to retrieve out the data get it back and and distribute the data across uh the application across the visible user interface and it's all done by books so you don't need to know anything about it it just works right so we've seen this example I think with in this one example yeah so here we're gonna send money from one account to another so we continue on the same example that we've seen a moment before but this time we're waiting for pending transaction just to show you that any moment now when the transaction gonna finish we're gonna see the either balance Gonna Change and boom it just have changed to 0.69 so again nothing to do just works so can we yeah uh yeah so here's an example because one question you might ask okay very nice about user bonds right but what about if you want to read other things from Smart contracts so there's this convenient use contract call which is again the hook which you can use to define your own hooks to query blockchain for really anything so you have your stock and balance so we're gonna create a new book this particular use stock and balance book is actually part of library but imagine you need to recreate it from scratch or you want to you know do whatever do whatever other call to Smart contracts that you want you use use contract call that Returns the value that Returns the same thing that uh smart contracts gonna return and it has four arguments the first argument is your C20 Enterprise this is the same format that interest.js is using it takes an address of the contract you want to call it takes the name of the method and it takes an array of arguments for the function that it then needs to call again there is a little bit with those extra extra ants and extra question marks because the values might turn out to be to be no if you're not connected if the value is not yet retrieved but other than that it's just a single function call good so we talk about connecting to the blockchain and we talked about um reading the state from the blockchain now we're gonna talk a little bit more about making transactions so here's an example we're gonna we're gonna send a transaction what we're gonna use for that is we're gonna use a hook surprise so yes send transaction is a simple hook that allows you to send money that allows you to send either um to the uh from one account to another and it returns well three values but for now we're gonna focus on two volumes one value is the same transaction and second is State and the send transaction is a function that takes an arc as an argument uh ethereum transaction so it has typical values like two value might be other things like nodes and and whatnot or gas related fields but for for this example we're going to keep it simple you just have two we just have two uh arguments two and value so we're sending some eater to a certain address and or some certain amount again we're using either JS parse feature function and the nice thing about it is we have this additional variable that is State and State can be non-mining successfully on exception so we might be we might not yet send the attractions to the transaction yet there is no mining means the transaction spending success and fail transaction is mine successfully or not really successfully an exception might be coming for example if user cancel in metamask order is a code so this is how it works this is an example if we go back to example this is how it works just click Send opens your meta mask and you have those really simple transactions being mined this is just a piece of HTML that you display depending on the state transaction successful just a piece of the HTML that you display depending on the state and on the bottom you also have a notification so we're gonna talk about notifications in just two spots but for now we're gonna go into more complex example so that was just sending an eater now we're gonna actually call a functional we're actually gonna issue a transaction that's gonna execute a function on the blockchain so for that we're going to use a very similar probe that is called news contract function and it really has two arguments so the contract contract again it's either it's contract so it's so we already have information about API and the address and the second argument is the name of function again it returns to two variables in return state which gonna track the state of the transaction and the sun function that you can use to send to send to to execute the transaction to call a function now would send uh it's a little bit more tricky because send takes the list of arguments that is the same as a functional solidity and it might also take one extra parameter which is override so you might overwrite some value of your transaction like value in each or gas where creative fields so in this case what we're gonna do is we're gonna wrap and unwrap eater so the first example from the top what it does it simply uh unwraps the repeater right so you're calling the withdrawal function on wrap Twitter contract and uh well it sends just one argument which is the amount of prep feature that you want on track the example from the bottom goes the other side so it braps heater so it takes your reader and deposits and you get rap feature in return in this case there are no function has no arguments but you need to override the value you need to override the amount of feature that you want to send and this is how it works in practice and again you see very nice State Management very nice notification over here and you just wait boom transaction succeed transaction is successful everything that needed to be related the balances are now updated good and you've seen those little notifications at the bottom to get those all you need to do is to use use notification book so you need to uh uh it gives you the list of all the notifications and notification include things like wallet connected transaction pending transaction might successfully transaction type there was an exception running the transaction and this again because it's hooked and it takes care of all the updating uh like it's gonna make those automatically made those notification disappear after certain amount of time that is configurable and if you want to have just released the history of all your transactions of other user transactions that you've done you can use use transactions hook that gives you you know just persistent uh history and um just think about the amount of work it it takes to implement those hooks it they need to work on different networks they need to work properly when you switch the network back and forth that they need to work when you close and reopen your browser so like there is there is significant amount of work to it that you don't just don't need to do if you're using and there's one more extra thing there's this uh use contract function returns one extra variable that is event so we already have parsed events and you can just dig in and see what the events are if anybody's done it in Etheridge before you know it usually it takes a few hours to do it first time and then as always takes time to to figure it out again to how to parse those events boom off you go out of the box so what else is there there's plenty of other stuff so there's a lot of quotes related to many different things there is use lookup address who does it relates to ins there is huge dust price that gets to the the the gas price you can use block methods The Meta information about the current block there's a lot of helper models like Galaxy Core other things that generates the exploring that works even if you keep switching networks so that it's all right pretty convenient as well get the current chain name shorten your address if you wanna if you wanna display just a part of it in the interface and so on and so forth uh currently we support all the ethereum networks mainnet and all the test Nets we support binance active polygon Tata Moon River and Mumbai which are the polka dot chains Harmony pound Phantom and a bunch of and if you wanted a local development we support local change like for example on hard times if you're developing your hard hats or ganache and um you know it's a really short pull request if you need to make it work with anything else it's a few things that needs to configure and we keep seeing more and models per requests coming so if your network is missing I'm pretty sure uh there is an easy way to add it and there is one nice bonus thing which is a browser plugin so we have a browser plugin and it's available for Firefox and chrome and it tracks what's happening under the hood so you can see uh you know it might be a little bit unintuitive at the beginning what's happening what's going on under the hood so it does that it also manage your apis and tags so if you have specific accounts or specific contracts to interact with you can make it very readable and understandable so here's an example uh you can see the history on the left it was initialized course updated means you know that there are new things displayed on the website that is now being tracked by the multiple and every time you connect to a different network main app called one or anything else you can see right every time that happens you probably you probably you're gonna need to update calls again because you know you used to call on one network now you're gonna call on another Network every time you switch stream you change something in the interface it's gonna update calls right every time there is a new Block it's gonna check if there if it needs to update anything if it does it will let you know you know Call's updated uh first takes update sorry right and yeah that's that's the browser plugin uh what's next really I was really enjoying I was watching Richard more presentation about ether.js because he talked a lot about um you know the challenges coming with this new reality of multi-chain layer one layer two solutions so this is what we think is going to be the most important next thing to implement a new stuff so it's really great to see Richard it's already working on that I'm gonna take a lot of that work from our uh from our hands but yeah we want to be able to for you to Define your environments when you might have multiple networks connected in the parallel those networks might slightly differ and everything just works and also as I said we think this is pretty much future complete so we don't want to add more and more features and uh but we do see a lot of opportunity to have plugins or separate npms and one example is a coin gecko Oracle that is just very simple package that gives you the current price using phone get for API and it's just so addictive when you start writing this idiomatic we react Cooks in the style in this in this API manner it's just so easy so adding other things they're just using the same idioms the same way of working and makes it so easy like if you want to display the list of you know what's what's on the user wallet and how much is it worth you hook up the gun gecko Oracle you'll have that you hook up the standard token API and then you just come multiply one by the other you don't need to worry about all those things we're talking about Refreshments wallets networks and yeah yeah yep so it's working we have the multi I think I mentioned it's like 500 application is using your as of today it's a very young Network a very young framework but you know we had uh we're using it on production in several different applications with ourselves everything I showed you today the examples are available at the example.use.io so go check it the code is available on the GitHub check the documents check our website views.io and thank you very much for listening guys let me know if you have any questions all right that was really awesome uh I mean everybody and myself got super excited by all the uh the amazing kind of attractions you have there uh we have a couple questions and a couple comments and a couple of open-ended things for you uh let's start off with something simple can you give us a framework of when somebody should think about using ustap versus like scaffolding and kind of what are the difference absolutely so first of all I want to say and I'm not sure about this on the main brand or not but a scaffold is actually is using used up at least in one of the versions because I think you know awesome many versions of that I'm not sure which version exactly so um [Music] our philosophy is we want to do one thing and one thing really really well so and I think scaffolder is really good at like being this like boilerplate a place boom off you go and you can just start coding right so and we don't try to compete with that I think it's you know awesome is doing amazing work and and there is nothing and we don't want to compete we don't see us we consider the need to improve on that what we do see what we did see the core problem is you know as we develop those applications for customers so you know some of you might know me um I co-founder default it was recently acquired by trust token so but we're gonna continue working on the open source so don't worry guys but the point is we work over and over solving the same problem and the code gets also played right and we thought that we need a better abstraction layer on connecting reading and writing for the blockchain it's really those stupid things because that's what you do with production you know like and and we want to be really really good at that right we want to make it so it's super easy super fast super efficient and yeah so we're happy to we're super happy that scaffold is using it and I hope it's going to use more of it awesome um another question is this production ready and I think it kind of works absolutely absolutely there is like with Taylor I I don't remember but I looked pulled together with Taylor I've seen at least a few a few serious guys using an interaction and we use them I wouldn't be able to tell you from the top of my head but there's several projects productionally like billion dollar the total value locked and interpretches built um and then I'll do a final question which uh which is uh I think being brought up as a team from a couple people but uh for Daryl and he's planned to support settle in the future but you know you have react okay so maybe maybe this is the I'll type this in chat um but uh the question I think uh I see well I didn't hear about this ever this framework before but I'll check it out and let you know guys I know that there is a next person waiting to start so thank you very much okay you so much American uh yeah everybody check out usap and we'll do it ourselves too thank you very much next up uh we have frenzy and she's going to be talking about sourceify so a lot of you are interested in verifying your contracts and uh society makes that a lot easier so without further Ado let's welcome printing on screen hey hi guys yeah thank you for having me um I'm super excited to be here um let's get it started there we go okay looks as if I'm all good right [Music] okay cool uh yeah so thank you for having me once more um today I'm going to talk about next level source code verification with certify my name is Francisca and I am part of the solidity team and I am also part of this little side project called sosify and why sourceify is next level source code verification and what you can do with this and why it's important all of this I'm going to share with you later so yeah exactly what will I talk about today uh first of all I want to highlight again what's wrong with today's ux and web3 uh what is Source verification and why is it important what are metadata files and what's netsmack why is sosify next level Source verification and last but not least because this is a developer Summit and you can learn how you can use certify with the common Dev tools or also manually so let's get started um yeah first I really want to remind us all what's wrong with the today's ux and web3 um I mean many many of you might have seen this before uh we have lots of trust issues and uninformed decisions these decisions that we currently take when we interact in web 3 they are based on Hex data strings we don't know what they mean and we don't know if this interaction we do is actually what we intend to do and yeah that process is also called Euro signing and yeah this really shows us nothing we don't know what we are doing and many many many questions might arise from this uh some of them could be you know other function arguments correct which contract am I interacting with here is this thing really doing what I wanted to do uh what is the source code of this and has it been audited or is this the one that has been audited uh is this the right address that I'm interacting with um did anybody check the legitimacy of this uh do I call the card function and last but not least can I consider this save to use based on this hex data string you cannot answer any of these questions and yeah if you are not sure what I'm talking about yet I also brought a few little examples with me um here we have uni swap where I am trying to swap some ease for die and yeah the information I get on which I can base my assumption or a decision on is these beautiful 260 bytes of hex data same as here I'm trying to buy a super rare nft and again I see maybe a bit of function type um information and then again hex data but really nothing else which could prove that I'm actually doing what I want to do um yeah a couple of more examples the same here with ens um trying to prolong my ens name and again I only get a hex data and a bit of a function type in this case renew which could give me some indication maybe it's the correct thing I'm doing but it is not really approved um and lastly here um I even needed to sign a message before I could even see any information on the website and again that is uh some data that is basically meaningless to me and um even though this is a developer Summit here today I also want to remind you that our users are not necessarily developers and for them this is even more confusing than it is for us so how can we improve the current status quo luckily there are some ideas how we can even make this whole problem go away and Achieve trust minimized web 3 interactions and just throwing a couple of words at you right now and I don't expect you to understand what all of these mean and no worries because we will go into more detail on all of these later on but basically trust randomized web 3 interactions can be achieved by a nice collaboration between several aspects which include source code transparency and availability Source verification metadata and netspec availability and lastly wallet and blog Explorer Integrations so with that in mind I will go through some of the basics um maybe some of you are new to the web series space and uh you don't know what the the term Source verification really means that's not a problem at all because I'm going to explain it um Source verification um is what we refer to as basically or in other areas this is known as binary reproducibility or bytecode reproducibility and what it basically means is that the deployed byte code that you Deploy on chain equals the byte code that is compiled from the source code so let's say a project is open source and it claims that their source code can be found at location X and then there is some byte code and that's deployed on chain and basically by recompiling the byte code that is open source and verifying that this matches the deployed the deployed by it called unchain we have verified the source and that's the process of source verification you might notice for example through Issa scan because here this is a very popular blob Explorer and Via this block Explorer you can do this verification process so many of you might have seen this before um and yeah I will today show you an alternative effect how you can also verify uh your source files and will give a bit more context on why we think that the current verification how it's been done for example by etherscan is maybe not enough it's already very good but it's we can go much further than that um and throughout this talk I'm gonna use the East to deposit contract to show you what I mean exactly using an example so here you see the ETA scan website and we are on the page that shows the deposit contract and if you scroll down and if you click on contract you see this little green um check box here and you can also see here contract source code verified um so that means somebody has done this verification process and um the the source code got recompiled and matches the byte code that is deployed on chain yay um next up what is a metadata file metadata files are actually a quite cool feature from solidity which got introduced many years ago but unfortunately not many people are aware of them or are using them properly but so basically a metadata file is a Json file that is generated by the solidity compiler that contains a lot of crucial information about the compiled contract at the very end of the compiled bytecode you see a hex data and this hex data includes already a bit of information it includes the use compiler version and a swarm or ipfs hash and if you follow that hash to for example ipfs and the metadata has been published on ipfs then you can find much more information you can find the full compiler version you can find the complete API of the contract developer documentation user documentation compiler settings to recompile the code out to the byte code so all of this is very important information crucial and some of this should in the best case be displayed to the users directly and let's have a look again what this means at the example of the deposit contract here we see the metadata Json of the deposit contract and here you see all the things that I've mentioned before the used compiler version the language here you could expand and see the entire API here currently expanded the dev docs so the developer documentation here are the user documentation and so on so all the information that I've just mentioned okay but uh what is netspec which has also been already mentioned in the metadata file netspec is the ethereum natural language specification format and that is basically um a spec that helps you to provide Rich documentations for functions return variables and more in the form of comments so basically the developer documentation and the user documentation that we've seen before in the metadata file they come from this comments that you put in the code using the netspec format um and yeah so they are basically categorized and develop a focus and end user-focused messages and they are also some other categories that you could use as well all of this by the way you can find in the solidity documentation in case you want to read more about it and um those end user-focused messages that you can use to describe the public facing um functions that you have in your code they are really crucial to users since they basically translate into human understandable words what the contract interaction will entail and so that they can decide on their own whether they want to do this contract interaction whether that is what they intended to do or not and so looking back at the deposit contract we see that this deposit contract has been actually commented using this netspec format and here for example we see at def which is the tag that you would use for the developer documentation and here we also see at notice which is the tag you would use for the user documentation and I also want to show you again how this would look like in the metadata file itself so all what we've seen in the source code you can find again in the metadata file it's nicely structured here and it's basically all there just waiting to be displayed for the right person so they know what they are actually doing foreign that is especially important because the two things we just described on the one hand The Source verification and on the other hand the code commenting in form of NetSpend Commons they together have the power to create greater transparency in contract interactions but if we only have one of them the equation is not complete so on the one hand if we have a verified code that is open source but there are no Nets back comments or there's no um code commenting been done then the end user does not understand what is happening even though it has been verified so that is bad on the other hand if the developer used netspec and the end user can understand uh what they are doing because there's some sort of display of the snap spec happening for example in the wallet front end but the code isn't verified so then the description could could be inaccurate or even worse it could mean something entirely as so that is also bad but when the code is verified and open source and the end user can understand it because there is some meaningful information displayed to him in the wallet user interface then that's awesome so that is why we don't only need Source verification and we don't only need code commenting but we need both and we need it together yeah so next question would be how do we bring all of these pieces together just lurking at the time there somewhere but I think I'm still good um meet certified sourcify is first and foremost an initiative to raise awareness about the importance of source verification and is also an initiative to try to raise the standards and the availability of the verified source files so if I consists of several products that want to make it easier for devs to verify their sources but first and foremost it's this decentralized metadata and source code repository which I'm going to show to you later but we also see ourselves as Bridge builders in the ecosystem and we really try to help make save our web3 interactions a reality so what we do on a daily basis is basically talking to all the stakeholders in the ecosystem that need to be involved to make our vision come reality um what are our goals on a high level we want to enable trust minimized informed rob3 interactions and that also entails stuff like trending hex strings which we've seen in the beginning in wallets into human readable information and on a technical level um that means stuff like keeping the metadata and the source files available via ipfs that can otherwise be a big issue and also become an infrastructure or base layer which allows other tools to really build on top of it and to leverage what we are offering so here's another little example of how this could look like if we would turn hex strings into human readable information on the left hand we see um what we've also seen in the beginning uh contract interaction how it looks at the moment in wallets um we have a bunch of hex data and we have the function type contract interaction but what we would like to see there would be a function type would be arguments but would also be a description that would display the Nets back and then also showing the source and basically a little information whether this code has been verified somewhere or not and then with the option to click on it if you're a technical person to click on it and then basically see the source code for yourself foreign that looks like really a nice Improvement to the ux we have today but what do we need to get there from our side we think we need several components for this to make it work on the one hand we need automated verifications are really really easy verification processes that are not as cumbersome and as complex as the processes we have today we need an open contract repository of all verified contracts that also includes the metadata files because I've mentioned before the verification alone without the metadata files does not bring us the translation part so both of them are really needed together um we need verification interfaces and plugins that also contribute to the very easy verification process in case the automated verification process fails and lastly of course we need Integrations Integrations and more Integrations um because this is a very complex ecosystem and in order to basically bring this benefits that we then have on the infrastructure level to the users we need to integrate with blog explorers and with wallets and maybe even with other stakeholders first of all I want to now um describe you a little bit more how this automatic verification could work so certify at the moment currently already automatically verifies new deployments um that's very awesome and that only has really one condition the metadata and the source files must be published to ipfs so when you are a developer and you let's say deploy a contract to um if you remain it then your next step must be to Auto either to use Auto publishing or to publish the metadata Json and the source files to ipfs so that our um soci-fi monitoring service can actually pick it up so how does it work oops like again um the deployer um deploys a new contract to the blockchain and then our monitor listens to all the new uh blocks that are being created by the blockchain and basically looks in those new blocks for new deployments Once the monitor finds new deployments it checks in this byte code that I've mentioned before the very last bit this hash the ipfs hash and then checks at this address on ipfs whether it can find the the metadata file and if it finds the metadata file and if it finds the source files then it runs the verifier and um after the verifier has done its work um the stuff is being indexed and pinned and we make sure that the metadata files and the source files don't get lost on ipfs so that would be the optimal automatic scenario and and that automatic scenario no manual verification from the developer is needed whatsoever so this is really different to the verification process you might know for example from either scan at the moment um let's say you want to verify a contract that you deployed two years ago or it was uh you didn't publish it um on time so the monitor couldn't find it on ipfs or some other scenarios where it needs manual input that's also not a problem because we also have a manual verification interface which I'm going to show you later but this automatic verification we think is a crucial point in making it just easy and seamless for new deployments to be verified so why is this next level Source verification I've touched on many of these points um already um firstly we do no code flattening that means the metadata in a way is verified as well that does not mean that the content in the metadata especially the content and the net spec files is true we cannot judge whether what the dev translated to be happening in the contract is actually happening but because everything is transparent and everything is open source what you can do next is basically as a developer go and see the source code go and see the comments and see whether that reflects what is actually happening or not um as the next Point all contracts are independently verifiable that means you have all the information you need to do the recompilation yourself anybody could do it so that is not a one-off verification but anybody could at any point verify the Integrity of this again and lastly tackling the availability issue so making the storage of source files and the processes around verification more decentralized independent and hence more resilient that means especially uh we shouldn't just trust one third party to verify everything for us and what happens if this third party goes down or the database is somehow corrupted or I don't know what can happen so we are friends of Open Source and we are friends of decentralization so we really try to make this process as decentralized and independent from one middleman as possible okay and since this is a developer Summit let's now have a look at how you can use specify today to do this verification I've just mentioned yeah in the best case you um don't need to do anything as I've explained with the automatic verification process um the only thing you need to do in that case is to publish your metadata files and source files on ipfs here's the example of remix um where you have a very handy button just right under the compile button you have a published on ipfs button and all you need to do in the best case is Click publish on ipfs and you're done because our monitor will pick the stuff up and we'll verify it without any need for you to do anything so I clicked publish on ipfs and then I see here um socify it's that's how I called this project metadata has been published and I can see the addresses of um the files that I've published to ipfs here so that would be an easy way how to do it with remix there's even also another way how you can verify your sources and remix because there's also a sourcify remix plugin which you can use as well secondly if you're using hard hat there is a hard hat deploy plugin and that had a deploy plugin also con includes the sourcify verification so all you need to do if you want to verify on certify with hardhead is do hard head Network mainnet sourceify or whatever Network you are on and then it will get verified as well um for travel it's again a bit different um so in travel you find the metadata output in the artifact and in there you find the metadata as a string and not as a metadata.json so what you can do in the case if you use travel is you can go to our manual verification interface and just drop your source files and that artifact file in our manual interface and it will verify everything so no need for you to extract the metadata or to somehow transform it into an its own Json file we do that in our verification interface so you just have to dump this artifact file foreign and lastly here is how our interface currently looks I am sorry that this is a bit blurry I know but um I tried to make GIF out of this so let's see what is happening here um in the first instance you saw the sourcify.dev website where I added a let me play this from the beginning because this makes no sense for you guys well let's wait until it's over basically what you're seeing here is already the repository um the contract repository with all information but I want to see it from the start again so let's see what's happening here that's the metadata file great I hope this will go back to what I wanted to show you yes so basically you enter which network you have been using and the contract address and then you dump the files meaning the source file and the metadata file and then you click verify but because the deposit contract which I'm using for the example has already been verified I get the notification has been verified and it leads me to the contract repository where I can have a look at the source file as well as the metadata file here you see the source file of the deposit contract which is neatly stored in the contract repository and then you can also go back and you can click on the metadata Json which shows you all um the net spec comments but also the other information that is included in the metadata file and yeah all of this you can see when you go to certified.def and enter the contract address so also if you are interested in knowing whether a contract has been verified or not you can just go there dump the contract address there and it will show you whether this contract has been verified already or not okay so going back to the initial um slide that I had in the beginning how can we achieve trust minimized web3 interactions I now want to translate these into what you as a developer can do so let's have a look what you can do to help this make uh make this a reality is you have to open source your code and make it available via ipfs you can use sourceify and verify verify your source and metadata files you should use uh code commenting and comment your code using netspec and lastly you should either build Integrations or encourage others to do so so what should you take home from this talk and no matter whether you are a developer or user please always verify your contracts or check if they have been verified and especially in the case that they have not been verified demand verification and raise awareness for the safety risks that are there if stuff has not been verified and on the more technical side of things because we want to become more decentralized please help us pin the certified content on ipfs contribute code if you like and generally all ideas are welcome so please join in our chat um we are on metrics and guitar so please join there and contribute ask questions um we also do user support there in case the verification should not work um we are on Twitter at socialize um we are at in GitHub ethereum sourcify and for all the plugins it's github.com and our website is sourcify.def and in the dweb is certify.e um yeah wrapping up I want to say big thank you and credits to Chris Eddie Fabian Yakov ligi and also welcome out to new maintenance Khan and Johnson because all the people I've mentioned uh they are our developers and they are the brains behind this project so I'm only the messenger here today and uh trying to be able to answer all your questions if you have any now thank you thank you so much Francie this was uh awesome um good award a handful of questions which uh luckily Chris just already answered on the chat but I'll still bring up some of these uh here I think the a common discussion that's going on is how do you think about Integrations and obviously there's multiple interpretations of what Integrations are uh whether it's about this plugging into existing developer environment to adding more plugins or support for how this gets used outside of just a web interface what are kind of plans for that and how does that look like yeah that's a good point so in and one of my other talks I also had a slide on all the cool Integrations we already have but because the time was short and I wanted to this time highlight how to use it I didn't include this but actually um in terms of so let's go deep into whatever we can okay so in terms of uh developer tooling there are already some Integrations out there that I mentioned so for hearted it's the hardware deploy for truffle I think there's no uh plug-in yet I hope I'm not mistaken and for remix there is the certified plugin already so on the tooling side of things we are quite good um of course on the wallet side of things things could improve but they are open conversations already with some of the wallets which are great and then lastly on the Block Explorer side um the autoscan block Explorer recently uh released a new version which actually includes certified support which is very cool so um yeah there also needs to be some more work on the Block Explorer side of things especially with the big block explorers but yeah we hope that this will happen soon and we are open to conversations and with most of the people we already have an open conversation Channel but of course we also know there are so many priorities and so many things to work on at the same time that uh it's understandable that nobody can only prioritize um sourcify it uh looks like other questions are coming in um let's see well other than everybody just being excited about what's going on so um do you have a specific all right so do you have any specific small projects a hacker or a hackathon could build to benefit sourceify it's like small improvements I think is probably the the better interpretation here yeah that is a very good question if I had more time I would definitely come up with some stuff maybe Chris has some ideas if he's in the chat um all right Chris is answering oh okay great yeah yeah no because I think there's a couple of things that we can do and as I also said we are currently onboarding to new maintainers to the project which is uh really exciting and I think they would also have some ideas how you could help for sure um but um also on that side yeah just I think we have some ipfs issues for example so if somebody's in ipfs expert um or just pinning the repository but yeah in terms of hackathon projects there's probably some stuff that could be done awesome well if uh there are no more outstanding questions um you can end this but this is obviously great and congrats on making this a big initiative in a better public utility so hopefully yeah thank you so much for having me yeah yeah so much all right so with that we are ready to move on to our next talk and our next speaker is hurry and Harry's going to be talking about all the new features in the latest update for solidity so we'll just give it a second for uh everything to work out on the AV side and already whenever you're ready uh turn on your camera and we'll get the slide uh started from our end here we go hello can you hear me well uh yes everything is good I know we're doing the slides on on uh on our end so just give me one more second to pull that up and now we can sure make that work foreign I I can go present it when I'm trying to see if I can actually make it a presentation full screen mode but um let's see if that works there we go Okay so just say next whenever uh oh great yeah so I'll say next whenever I want to move okay great so my talk is about two important abstractions and solidity and as you might already know the zero eight zero version was a very important release for us because it introduced a major feature that is safe map by default but since then we have followed up with two other major features that we believe has a similar potential I'm not going to say what the two features are right now but rather I want to slowly introduce a problem and then try to convince you why we implemented this feature and how you can solve certain problems elegantly using our new features so next so let's dive straight into our toy problem suppose you want to write a smart contract that sells some object the object asset price and there is a limited quantity of the object available and the problem is extremely simple the problem is that a user wants to buy some quantity of the object and you want to compute it all price so next the solution the very first solution for this is the following so you write a function which is total price that takes two unsight integers here quantity and price and then you multiply it it's very simple and perfectly valid code but what is the problem here the problem is that you can notice that the price and quantity are supposed to be two different things for example you're not supposed to assign a price to a quantity or vice versa but in our code we can because both of them are unsigned integers so from a type safety perspective we can do much better so in our example the type only represents the underlying that representation and note how the data should be interpreted so to repeat we would like to have two different types for quantity and price but we already have a solution for this in the language let's look at another solution so next the solution number two is just using structs so we have two structs here quantity and price they both have a single element and now you can write the same function but the arguments are not structs instead of Elementary value type foreign is much more type safe than the previous one and you can no longer assign quantity to price or vice versa that would be a type error but now this has some other problems so stocks are a wonderful abstraction but it comes with the cost I will actually explain the cost in detail in a bit but let's just say that it's not as efficient as the first example so note that a struct is a reference type what this means is that it is a pointer towards a value in call data memory or storage so in this example it is in memory so you can see it clearly because we you have to explicitly specify it you can see quantity memory q and price memory p so remember that I mentioned this is not as efficient so let's forget about the problem for a bit and talk about something more fundamental so next so we will briefly talk about the difference between stack and memory in the ethereum virtual machine so a stack is simply a data structure the ethereum Wilson machine is a stack based machine which means that you mainly do operations using a stack speaking of operations the main operation in a stack is to push a value to the top of the stack and then there are a bunch of operations that allows you to rearrange the stack as well as doing various computations so for example if you have two elements on the stack you can add them by using the add or code and what that does is what that does is that the two elements will be removed and replaced by the result foreign and let's now talk about memory so memory is a temporary location in the ethereum washing machine where you can store things and read them later the main takeaway from this description should be that stack is much more fundamental than memory so it's important because there is often this misconception that all values in solidity are stored in memory that is not true in solidity you have to explicitly say memory when you need to store or read something to and from memory so for example local variables are stored in stack and not memory because often they don't have a number specifier so if we go back uh to the first example the values are actually stored in stack and in the second example the values are stored in memory but this still doesn't explain why one is more efficient than the other in terms of gas let's now try to see why that is true next so as I said before the most fundamental operation that you can do with the stack is putting a value in it so you can do this with the push operation [Music] the operations is very cheap and only costs three gas so if you consume the value for example when you want to add it with something already something that is already in the stack you don't need to pay anything extra for consuming it you only pay for the addition so consuming doesn't have an extra cost as long as the element is at the right location but if it's not at the right location in the stack you can use some stack operations to move it to the right location before consuming it and each of these stack operations would typically cost three gas but in our best case scenario the cost for putting something in stack is just three gas and we hope that the value of value is at the right place so that we don't have to do any more operations to move it around now let's see how to do the same things with memory so if you want to put a value in memory you do it using the operation M store so M store of a b will store the value B at the location starting from a so remember that all operations have to go through the stack so to do M store of a comma B you have to first put uh the values A and B in the stack so you have to start with b and then a so we have already discussed the cost for doing this so to put B in stack it costs three gas it is a push operation similarly to put a in stack it costs three gas and now the M store instruction has to cost three which is fixed and at least another three which can depending it's which can vary depending on how big uh air gets so the more memory you use it can get more and more expensive after a certain point so in total you have to pay at least 12 gas for this operation and similarly if you want to read a value from memory you do this using the operation M load M load of a again you need to start by putting the value in stack which costs free gas and afterwards the M load inspection which cost three gas so that is a total of six gas so as you can see here just to write and read from memory you need to spend at least 18 guests whereas this can be done with just three gas and stack so stack operations can be around six times cheaper than memory so can you go back to slides great now I hope that answers my statement not efficient now let's go to the real solution so what if solidity had a way to create an abstraction but without having to pay an additional cost for it abstractions are amazing but we don't want to pay more gas for it so let me introduce you to user defined value types so it is what we call as a zero cost abstraction it can be used starting from version 089 which was released exactly nine days before so it allows you to create an alias type while having additional type safety the syntax looks like Type U is V where U is the name of the new type and V is an elementary value type that means we can be an address a u and a an INT 8 Etc so how do we solve the same problem using user-defined value types so next so here is an example on how to write a contract to think solve the toy problem so here you define a new type quantity and price you you see the syntax type quantity is unit and type prices you need note that these types are distinct and therefore you cannot just assign one to another that would be a type error so this example also introduces how we allow conversions to and from the underlying type which is by using the function wrap and unwrap so quantity dot unwrapped can be used to convert from quantity to unit and quantity.wap can be used to convert from U into quantity the scan of course be generalized so if you replace U and to you with eight everywhere then drag and unwrap will correspondingly change foreign so next a very important thing to note about this is that the types are fully backwards compatible what does that even mean so what this means is that even when you have to implement a contract that needs to follow a standard which was written a long time ago you can still use the use to define value types to interface with it or rewrite it for example to the erc20 standard requires the type for the amount of token to be you win 256. but you can define a new type with the name decimal 18. which is a zero cost abstraction over you win 256. and you can replace you into 56 with decimal 80 whenever you think wherever you think that's more appropriate and it will be completely backwards compatible so here I have two examples of interfaces and how and uh they are supposed to represent some of the subset of the erc20 standard and both of them would work exactly the same but in my opinion the first one is much more clearer because it makes it clear that the value is supposed to actually represent a number with 18 decimals which is the case for most tokens whereas in the second case it's not obvious what value uh is supposed to represent in terms of decimals so effectively the feature allows you to write code that is much more clearer and easy to read so next so there are of course some open questions about how we improve this feature and one of them is about defining operators so user-defined value types does not have any operators right now but we would like to have them in the future so as you can see in this example which is again about a token and how we have a type that represents a value in 18 decimals so the type decimal 18. so we need a syntax to create the operator plus equal to because if you look at the function uh mint you have the line balance of user plus equal to Value but we don't have a plus equal to right now but we would like to have them you can participate in the discussion uh where we propose this feature by going to the links we would like we would love to hear your opinion on this I will leave a link to my slides later if you want to check out the links so now that we have solved our first problem let's forget about it and talk about a completely new problem [Music] so the new problem is also very simple uh next so the new problem is the following so how can we tell a user why a transaction failed so suppose you have a simple contract that can only be used by the owner so typically so it's difficult to have a modifier that checks the sender and rewards of the center is not the same as the owner you can see the contract here where you have a immutable variable owner which would be set to the message.center during the contract initialization and then you have a modifier only owner which would check if the message or sender is same as the owner which was saved during the Constructor and if it's not the same the transaction would reward for example if you look at the withdrawal function it can only be called by called if the modifier only owner is true so I have a comment here which I said don't do this but this is a typical this is a very typical and smart contracts and why did I say this so that's mainly because this is a very large reverse thing it's 40 bytes it's more than 40 bytes and large reward string add to higher deploy costs for the contract as well as higher gas costs for reverting transactions the deploy cost here can be especially important if your contract is getting near the contract size limit but what if we had a way to create a high level error object next and that is exactly what customers do so it was introduced in the version 084 and syntax is very similar to how we do how we Define events so you can see the error only on Earth and also notice how we use a netspec commands to describe it if you listen to the talk about Source verification by Francie that happened just before you will see some of our goals about how we want to use NetSpend comments to improve the user experience for contracts contract interactions so instead of a required statement you replace it by and if followed by reward only order next so here is a short summary of the before and after in the first example that's how you do it classically using a string and in the second example we have a contract uh we use customers and the second example is better because it has lower cost for rewarding transactions as well as cheaper contract deploy cost or smaller bytecode and next so let's get to the next level of reward messages sometimes the reward reason sometimes you want the reward reason to have more information than a very simple static string in the past if you wanted to convey a structured message back to the user you would have to do something like the following the context is that we have a token like contract and if we have a call to the transfer function and if there is insufficient balance we want to revert and tell that to the user of course we can always reward with saying okay insufficient balance but we want to do more than that so if you really want to have a proper error message you could do something that looks like this so what we have here is a function you went to Str that converts a integer to string and then you concatenate all these things on chain I think I have a bug here but yeah whatever it doesn't matter so first of all this you went to string conversion is doing it on train is paying more gas than you're supposed to do I mean it's just unfortunately expensive so when I mean expensive it's not as expensive as a storage read or stories right but it's completely unnecessary in my opinion things don't really belong in smart contracts so you should try to really minimize them and the second reason is that whenever you have a function call in solidity each argument has to be evaluated first I mean so if you have F of a b and if a and b are function call you have to evaluate A and B before you evaluate f so in this case API dot encode pack is a function call and that means that even if the condition for require is true the reward string has to be still evaluated so this means that you're just wasting Cash for every single call even if even if the call is completely correct so next so let's see how to solve the same problem by using custom errors so here is an example that combines you know multiple things from this talk the first thing is the user-defined value type decimal 18. so we have a token again and we have a we have an error insufficient balance so remember that I told you that customers are similar to events you can have arguments so here you have a reward uh with the address of the user the current balance and how much is required for the transaction to succeed it looks very similar to how you emit an event so this is a much cheaper and much more idiomatic approach to having much more structured error than using strings so next yeah so customers is a feature it's a compiler feature but it wouldn't be complete without tooling support so several of the popular tools actually support customers and we are hoping to see better support So currently block explorers like either scan doesn't automatically record customers and we hope this is something that would be supported in the near future but all these like uh all these like tools do support it so next so that's pretty much my talk my name is Hari and I hope I was able to convince you why these two major features that is used to define value types and customers are useful and also why we need them I would love to see smart contracts using these features and I hope I was able to influence you you can find my slides in the following link I can now answer some questions you can also find my contact in the link if you want to follow up and if you want to reach out to the compiler team we can find the details in the link so questions all right that was a great talk um just kind of sourcing everybody I'm stopping all the chats to see if there are more questions I think overall people are just excited about uh the the gas efficiencies here of course um this is kind of the most obvious uh uh thing that you can highlight it along with those idiomatic attractions um so if anybody asks we're just getting comments that people are loving this um so uh Rich if you have any questions for our a we can ask that too um maybe just a more future forward-looking question will be uh what are some of these other attractions that you're thinking about in the back burner or the possible next releases like what does that look like um and and sort of how you think about the future of the language yeah so one something that we wanted to do was uh having some support for fixed Point types and we think that used to define value types is like the first step towards it so right now our uh thinking process is that we don't want like proper fixed Point types and solidity because there is uh there is no single way to implement it if you look at the implementation there are like multiple implementation and each one has their own advantages and disadvantages so if something lands in the compiler it has to be you know somewhat uh the implementation but there is no the implementation so we think it's something that libraries should do and we think we want to better support it by using uh used to define value types and that's why operators would like be the next step in user-defined value types improvements and I think that would unlock a much more abstract code much unlock that would let you write much more abstract code and also say for also efficient code yeah that's the number one priority right now gotcha um in terms of I mean you're gonna talk about some of the Integrations that are still um like on track to be actually on there from like the libraries to etherscan what have you um what is it that they should keep in mind as you think about integrating it or is there any obviously I feel like you address that there's no backwards in compatibility uh or sorry there's no incompatibility here as people think about it it is equivalent it's just a high level abstraction but uh for developers on this side looking to just quickly switch over to these abstract types um do any advice or comments on what they should keep in mind uh not really I think it's a fairly straightforward to like uh Switz and we purposefully designed uh it to keep it simple and if you have comments uh if you're using the feature and want to see some changes we are always open for comments so the way we Implement features is by starting with like a minimal version that will like do most of the things and we would slowly add more features to make it stronger so if you have you know comments feel free to reach out to us as a matter of fact the feature user defined value types was greatly influenced by one of our user feedback so it your feedback really matters and it put like influence the language awesome and uh the way people can get involved is is the GitHub or what is the official resource so you can find all our information in solidityland.org but you can also uh come to our guitar chat uh uh look at open issues in our GitHub Channel um or in the metrics Channel as well but to go to go to link is solidityland.org awesome well um I a couple people were asking for a link to the slides we just posted that so uh that also has a link at the end of the presentation so thank you so much Hari uh for that amazing intro for the demo of what's new and uh hope you have a good rest of the weekend thanks bye all right with that we are ready for our next talk um so our next speaker is Yusuf and we will be talking about blockchain data storage using what three storage unit storage so uh without further Ado Let's uh let's see how we can make an empty story welcome it's good to be here thanks I will share the screen here cool so I am Yusuf I work at protocol Labs where we make itfs and filecoin uh those are two really interesting bits of technology that um we think can help everybody in this or decentralized app ecosystem take advantage of uh this vast network of storage that's now available so let me sort of get into the mix here so it's kind of a mashup of two talks about web3. storage and nft. storage these are both services that we've built to make using ipfs and file coin really easy and accessible for especially for web 2 developers or really anybody that wants like sort of friction a low friction path into this storage Network so uh first I want to talk a little bit about nfts so we became really interested in nfts um you know we have been for a while but obviously this year these sort of take off in the public Consciousness and that's when I personally started getting into them um I was like Loosely aware of them before that but basically it was really like encouraging for us to see that ipfs was being used to store lots of nfts um and we think it's a really great fit for this kind of application because first of all like storing data on most blockchains is prohibitedly expensive and therefore to have an nft that represents something outside of itself which is the case for many there needs to be a link between the nft and data that lives off chain and we ipfs has some really great properties for that for creating that kind of link so we'll go into that in a little bit um but we started to you know realize that the developers uh that like openc and foundation and Zora and so on that really care they care about users being able to access the data should they ever disappear and this is sort of a Common Thread in these kind of circles is that like nobody wants to trust any individual party to stick around forever but we combine you know if we all like play well together we can hopefully design a system that outlives any of us individually right and that's uh and it's good for for us to kind of build systems with that in mind even though hopefully of course we'll be around for a while um but again something that users care about is especially like they became aware that the thing that they're I don't know maybe people are already aware of this but I think that people that are new to nfts don't always understand like what specifically lives on the blockchain and what lives elsewhere and like what's that relationship so there's like an educational piece to that that we've been involved in trying to kind of flew people into what you know what is that link and what's this strong way to make that link ipfs fits um and if you're new to ipfs it is the interplanetary file system uh it's been around for several years and the gist of it is basically that you first you put your data onto an ipfs node and that node participates in this big peer-to-peer content sharing Network right basically if somebody wants a piece of content they'll ask for it and if I have it I'll provide it and everybody does this and it's actually a pretty efficient way to distribute data across a network in in many ways but first so anyway first you put your data into the ipvs node and you get back this string the content ID and it is a cryptographic hash by default it's Draw 2 256 but there you can use lots of different hash functions and all the rest it's very customizable piece of software but the the fundamental point is that this CID will always identify one specific piece of content and any changes to the content would it produce a different CID so given a CID you can say hey Network please give me this data and when it comes back from anybody you can always verify that it's correct because you can compare it against the CID that you used to retrieve it so this means that you don't need to really care who is providing the data or where they come from or you know anything you don't need to know anything about them as long as the protocol works as long as somebody has the data and they see your request they can provide it and you'll you'll get it and it's a pretty cool feature for linking to things which we'll get into in just a second but so here's the the requesting process somebody request the data by the CID the original node response and now they both have a copy and if a third node comes along asking for it both of them can respond in parallel and say oh I have it here's a few pieces guy on the left gives a few pieces kind of right gives a few pieces and now you get the file potentially faster than you could downloading the whole thing from one but there's lots of variables there with respect to latency and so on so it's really hard to make like absolute claims about performance characteristics versus other systems but in general there's potential for efficiency there so yeah now this third node has it and as a result they can also participate in the providing process and that's great the original note go away yeah but the content is still there and so we've kind of gotten close to this dream of the content outliving us and our you know organizational guidance and so on the data is still retrievable from other nodes and you know that's kind of the power of peer-to-peer Network like that no individual peer is you know blessed or special um but there's some caveats to this approach with ipfs if all the nodes that had the content disappeared from the network then there's nobody there to provide it uh there's it's like an active process where your node needs to be online in order to respond to requests and if no node is online with that content it's just not resolvable although I should mention that the sand is basically true of yeah HTTP servers like facebook.com or suddenly to be unresolvable then nobody could access it but with the um with ipfs you have kind of an interesting property where if anybody later adds the same content to the network provided they use the same hashing algorithm and everything um then they'll come up with the same CID and any links to that original content will be resolvable so it's I guess like a third party can sort of fix a broken Link in a way that they can't with HTTP so that's kind of neat but the the second caveat is that there is an automatic garbage collection process for these ephemeral copies that get made as content propagates throughout the network each node will keep a little copy for a minute but eventually look they might get disc pressure and we'll have to clean up and throw stuff away so to prevent that there's a thing called pinning which is just signaling to your ipfs node please keep this alive um you know don't garbage collect your stuff and um this has been one of the the main ways for people to practically speak and get their data into ipfs and made accessible is to use a pinning service that will sort of provide this data for you on your behalf so you don't have to run your own infrastructure and so on and you know as we're looking at the nft space and thinking about like what can we contribute we saw well we can make this process um a little easier for people by basically more or less becoming a pinning service but doing so using um so the some of our other technology like namely file coin which we'll talk about in just a sec so the way we present this is as nft.storage is a website it is free to use you log in you get an API token and then you can upload your stuff through us and where we provide it on ipfs and also um for long-term storage it's looking to filecoin so the way this works is yeah you take your nft it's a very simple um upload interface it's just an HTTP request there's some there's a few different variations on that depending on what your needs are and which endpoint you might want to use but then anyway we get your data through some request and then nft storage is going to store it on an ivfs cluster that we manage and then we're also we also redundantly store it with a third-party provider just for Faith keeping and behind the scenes though we are also negotiating deals with file coin storage providers to store data for the long term and they are actually getting paid by the network in the form of block rewards which is kind of an interesting sort of economic angle that we can talk about in a second but the for now like the advantage of filecoin is that it fits this property of like allowing members of the network to disappear but still giving you some solid assurances about your data so now all if any if nft storage were to go away completely and all the ipfs nodes that we manage or that other people run lost all the content the data is still just there on filecoin being continually challenged by the protocol to like prove its existence so that's um basically if you had like in the worst case scenario where we just fold up shop completely and can't pay the bills anymore um everybody has this sort of you know public verifiable escape hatch as it were where and just like or a seed Vault maybe is another way to think of it where like the data is preserved and it's it's just right there and we provide all the information for retrieving it in our API and stuff so um yeah to use it you go to nft.storage which is a top level domain now so that's cool and uh it's it's really simple and free um and just take that check it out it's a very it's the HTTP API it's not very big um the uh the main endpoint is this upload endpoint for storing things but there's also um you know stuff for retrieving status information about your uploads you know to who is storing it on file coin and ipfs and so on and so on so you can kind of get that granular information if you need it um and if you're in JavaScript we have this JavaScript client that makes it uh makes things a little simpler and will help you format data according to ERC 1155 standards so if you are building an ESC level m55 contract or one that you know can be compatible with one with that um use this client.store method and what uh it will do some nice stuff for you basically you can give it a file object and it will add the file to ipfs and create a hash link for you in your metadata Json and then also it wraps the whole thing up into this thing called a dag C board graph it's not super important what Dax eboard is but it's basically uh just a compact binary Json object but it's it's a nice way of addressing hash link data that we like to play with as part of the ipld project if you're interested um so I'm going to quickly just show you guys how to use energy storage and I'm going to talk a little bit about our other storage service so here's the site itself and you log in with GitHub or email it'll send you a magic link to click on uh if I log into my profile you'll see a few things I've stored mostly just testing things out and so on and we can go here and poke out of it and get an API token that we can authenticate with um I should also mention that my home internet is very slow so things that are slow for me may not be slow for you when you're using them so especially when I'm uploading things it's kind of sad uh but anyway so here we are at the API keys and uh I made this one a few minutes ago you can make and delete them here and there's my key for later I'll probably come back here and I'm gonna I've got an empty project here with some images that maybe we could store on nft storage and let's make an npm project to write some code so if I do npn in it and I just kind of accept all the defaults now I have a package.json file and I can say npm install nft dot storage that gets me the JavaScript client Library um yeah I'm also going to pull in a couple other libraries once this is done to make you know building a simple little example app easier so minimist is a for pulling out command line arguments kind of nice and then mime types for figuring out what kind of file you've got because the store function kind of likes you to provide it with a mime type and this this method that formats according to ERC 1155 expects it to be an image file type when you provided the image field well you can actually give it an np4 now for compatibility with platforms that use videos and image field um so anyhow we have now installed some dependencies and head over to an editor and make ourselves a file I'll call this index dot MJS something that's relatively new in node land is if you name your file with a MJS extension or if you put type module in your package Json you can use import syntax import nft storage from nft Storage I'll also pull in the file object since the the API uses is the file object that you would see in a web browser context and then it provides an implementation for node if you're working on node.js so I can import that here and then in order to read the file from my local disk I'll import nodes FS modules Imports FS from FS slash promises so I can use the async await and we'll pull in minimis that we've installed earlier and my types so that's all that we'll need in a second and let's do function for storing an nft so this is called async functions store nft and it'll take a image file name and then see maybe the name and description metadata that will uh we'll tag our nft with that description so to do this we're going to make an nft storage client and for that we'll need a token which I'm going to be a naughty boy and hard code into my source code yeah and obviously this is actually an area that will be improving upon very shortly like right um right now the best practice for protecting your API token for entity storage is probably to protect the Habit uh interact with entities prefers from the back end service since bundling it into a purely decentralized app front-end would expose it to the client but we're working on solutions for that which would involve direct authentication through a wallet and using decentralized identity and also sort of user scope tokens so that you can manage authorization when you use as we have I am mentioning this because um it's just a common issue that we are heads down working on so stay tuned in the meantime I'm gonna grab a token from here and paste it in here so I got that and now I can make a client so I'll say const uh plant there's new nft storage and you give it a token argument and uh I can do stuff with it but first I'll need to read my file in so I can say file data equals fs.read file let's say I need to await this it's async and I don't image file name and type is going to be mime dot lookup image file name because it just pulls the file type from the file extension it's not super fancy and then we're going to say okay I have the data and the file types and I can make a file it's a new file object that takes an array of blob Parts which is basically just you know things that can be turned into binary data so this stuff we slurped up from our image file name here will fit that just fine um actually uh uh let's see let me quickly make this bigger so everybody I think it's a little easier to read there we go so I'm making a new file and I'm giving it the file data the file name um maybe we'll trim that down to just be the last part of the file path so I'll import Face name now you can say yeah image file name okay and then the last part of the file Constructor is the optional argument so you can pass in the mime type so we looked that up earlier now we can pass it in and now we have a file object that I can I'm going to call this image right because that's what the store method expects image now this is a proper file that we can hand off to the client so now I'm going to say I'm just going to return client dot store image name description and there's a few other you can add optional properties to if you have if you want to have properties with any key value stuff you want in there for custom use case which if you are doing the the ERC 11.55 we do recommend like sticking custom properties and properties if you can just because it makes it easier we're trying to beat the drum of standardization a little bit um because having been on the receiving end we're also um you know scraping ethereum chains and finding all kinds of nfts in the wild to kind of see what people are doing so there's a lot of uh interesting metadata variations out there but at any rate um now we have this and we can say we can call it so let's make up a main function [Music] ah same and this is where we can grab our headline arcs sorry this complete it didn't even dirty all right so ours equals Minimus and for this you pass in the process argument so process.rv pull off the first two for node reasons and now um Minimus is kind of simple it's just like it takes whatever arguments it gets and parses them out and gives you a dictionary or a JS object Runner so now I'm going to just assert that you gave me the right stuff so um there's nothing we want there to be an image a name and a description so if there's no image complain this may be a little fussy for live coding but still I mean error handling is important foreign the image here's the image file name and we can just toss that over here and say metadata equals await store nft and then give it the image file name name and description and now let's log into the console and see what would happen so all right so now if I call the main function we should be able to call this thing as a node script and see what we see so let's see here we go if I do node index.js foreign age and I can give it uh images um name Etc and yeah I probably should have added a little console log saying hey we're doing a thing now but there it goes it's already done so it so what happens we the result you get back at this is um he has an ipfest URL which is in the ipfs colon slash format if you want you can pretty easily turn this into a HTTP Gateway URL so um this part here is the CID and then there's a file path so if I wanted to make a Gateway URL out of this I can say CID sorry um copying things accidentally here CID dot ipfs.dweb.link there's lots of other gateways but that's the one that sticks in my head and then then add the file path at the end so I'll show you what that looks like real quick I do cid.ipfs.u web dot link slash metadata.json yeah I spelled that wrong that's a data yeah so because um yeah there's basically a little a bundle it makes a little graph structure for you and then you can Traverse that graph using this pathing syntax over but it's basically it's just yeah there we go there's there's been metadata that we stored and you can see here if uh it's big enough that this is the image field has this same ipfs score reference to the image itself so you can make another Gateway link and pull it out um I uh dude if you have Brave installed it'll follow these links automatically but I for some reason didn't think to use it for this demo I will uh oops [Music] so that will chase out the image itself um and so and if you want to sort of machine readable uh or traversable form of this uh without having to parse links and so on that wrapper object like the root object of this graph where if you just have the CID without the metadata.json it's actually a with that dag sieber thing I was talking about earlier where you can fetch this object and then use um our ipld tooling to Traverse into the metadata and find the image itself and sort of all bundled into this graph so I'm not sure why this is taking so long to resolve but I I blame my terrible internet I did so we'll see uh anyway let's maybe take a break from all this stuff and uh we'll talk about web 3. storage we'll come back and hopefully we'll have loaded by then all right so oh look there's something I want to mention before we get onto webview. storage which is um that we have uh this thing called there's a format called a car which is a Content archive and you can send us content archives and if you want to pre-format your ipfs data like if you have specific layout that you want or also um if you want to send big files over 100 megabytes I should mention too that we're going to be doing this for you automatically soon so I may not have to do it yourself but it's kind of nice to understand what's going on behind under the scene so you have a mental model uh what's working so the advantage of using a car is you know the CID before you upload so you're not waiting on our server to tell you what the identifier is and you can verify that it's correct that we're like storing exactly what you know you're giving us and like I say it's chunkable and it has this you can split the cars into chunks here so I have one big graph and I can split it into the little graphs that all have the same roots and our back end will piece them all together for you and yeah that's pretty cool so I'll talk a little bit more about cars in a second because we have this other service and I'm just quickly running low on time so uh I should get into the weeds of web 3 storage it works very much like nft storage especially under the hood they're very very similar um and it's so if you remember this live from before it's the same thing but for non-nft data it's it's essentially any data that you have that you want to be stored on ipfs and filecoin you can just upload through head3. storage and we will store it for you um and it has the cars baked in so uh and this will be coming to nft storage soon but right now web 3 storage has it already in the JavaScript client where essentially you give it a file of any size and it will create the car file for you and do the chunking and send everything off and it gives you access to the root CID um as soon as we compute it on the client so you can display in your UI and say oh here's the thing now in parallel send it off to uh web3 storage and it'll get stored for you and you get progress callbacks and stuff like that very briefly here's kind of what the architecture looks um I'm not going to talk a bunch about it but there's some Cloud workers we maintain some state in a database but then the interesting bit is this storage broker service it will take your data and batch it up into usually I think we usually do 32 gigabyte chunks and store those each with a filecoin provider since that's the most efficient format for getting data directly into a file plane sort of Pipeline and then but parallel to that we've already added it to our ipfs cluster and so we're done in pinata cluster so it's available for retrieval pretty much as soon as you upload um but then there's maybe I think we're at like 18 hours now in terms of delay for getting it onto file coin right I'm sorry and that actually be eight but I have to actually ask people if the real number is sorry but it is a few hours because we have um we have this aggregation process going on um and but as a result of this by by meeting the miners where they are that's right for storage providers as they were calling we um we we were able to offer this service for free so here's uh something that comes up a lot when we talk about the service it's like how is this free and it basically is because um the primary economic driver for file coin providers right now is block rewards so they get rewarded first for committing capacity to the network so if you bring drives online uh into the network and prove that you've done so um then you get potential block rewards relative to your overall storage power the capacity that you're on that you're adding but um if you are storing real data boom you get a 10x multiplier basically it it and and the way that this works is that there's a all a system called filecoin Plus in which the a notary allocates this resource called data cap and data cap essentially is it's more it's a sort of like a voucher that says like we we believe this is real data and not just some random you know garbage that somebody uh generated to pump up their numbers I guess um so the idea is that by flowing your data through web3 storage and nft storage like we have a reasonable assurance that you're a real person or that there's a real like sort of social need behind the data and that's kind of what we're getting at because like fundamentally our mission is data preservation and all that so anyway verified data increases the chance of block rewards by 10x and so as a result it's the actual cost of like storing the data and there's some collateral that the providers put up front to you know ensure that they're going to store it that is all basically and kind of negligible compared to the increased reward so it works out for them to provide long-term storage for free and so when not charging users anything for storage as well there's a minimal operational cost to us to keep the ipfs side of things you know running the bats in the grand scheme not a big deal and we're super you know into providing it to make things easier for people so that's that's what I got thanks very much and if anybody has questions please let me know so that was awesome um also nice recovery I feel like we're going to go over time but this book yeah yeah totally fold it in um I think uh two kind of common questions um when you actually already addressed with the Nuance between work three and then if he does storage uh it's just a formatting and the car archive formats um a common question that I think we get especially during the hackathon is what are some best practices that you recommend uh when people want to think about storing metadata or even updating it like how do we think about that and how does nft sort of just kind of come in handy for these types of things um yeah question into uh how do you actually what's next after this like you are is this done like is this a great service you're offering it this works like how do you actually improve this thing or what are future features um actually I mean so there are some reliability things that we want to bake in that right now like we're doing a database migration that should make everything faster and more you know solid but feature wise I think those two questions are kind of related where like right now especially Michael and gazelle I don't know if you guys have met them yet but they are heads down trying to figure out a sort of a workable plan for extensible nfts or like not not exactly mutating but keeping track of you know assertions about an nft over time and um so the way that we kind of to see that happening now is using events to send out basically you know entity value triples where you would say like the entity is an identifier for the nft itself and then an attribute is some assertion about it like you know it has an alternate representation here or or like this you know it was remixed into something it would be you'd imagine lots of scenarios but then eventually you fold those into you basically compact a big log and then you have I mean you know a view of the evolved nft over time but that's all kind of like speculative right now we're still trying to figure out how practical can we make this and like how and also like you know is this something that requires a lot of buy-in from people up front or is there a way we can kind of apply this to nfts that already exist and I think that there is but there's a lot of details there so I think that that's kind of where our focus is nft wise right now for nft storage is to try to figure I'm not sure if it'll actually come through energy storage directly but I mean we will support it there but I think that that's kind of a broader effort of trying to figure out what the data model should look like um in terms of the actual experience of using it um we're right now so right now we have two separate services and we're going to end up making nft storage a client of web3 storage so just for Less stuff for us to manage and for the token management stuff is the big feature that's going to be coming to both platforms soon I think it's a like so there'll be a way to have like a sort of admin token that you can then create a user scope token and then then users will be able to manage and delete their own stuff without having access to anybody else's but then we're also going to have like a fully decentralized path of using a decentralized identifier document to assert ownership of a key and then that gets you like we just want to know that they're you know be able to identify you somehow we don't have to know who exact specifically you are so that we're building that out and should be coming um I mean I can't promise timelines but also what the ideas do sound pretty credible here um that's great well I think that's all the time we have today um thank you so much for doing that presentation and also yeah thanks that was great but uh perfect so with that we are ready to move on to our next talk and next up we have Chris and Chris is going to talk about youth SDK and how to make development a lot more pleasurable so without further Ado welcome [Music] hello uh let me share my screen okay I think it works now so uh hello yes my name is Chris catchogue and during the day I worked uh I work as a software engineer for uh maker Dao working particularly on Layer Two staff and during the night I'm part of a deaf organization where we're trying to make ethereum uh developer experience better today I want to talk about if SDK a new this is actually a word Premiere so guys free Alpha incoming a new tool that is a generator of lightweight and typesafe sdks for ethereum smart contracts and I'm gonna unpack this uh in a bit now let's talk a little bit about the ethereum dev landscape and how it had evolved so you know if you were using ethereum few years ago uh everyone was using web free.js and it was pretty raw it didn't even support premises back then these days it has JS is a king a similar thing happened to travel and heart hat and I I'd like to point out a more uh profound uh change which is which is a change in language that we used a couple of years ago everyone was using JavaScript now more and more people use typescript and not only blockchain Community like you can see this rise of typescript everywhere and uh you know some time ago you could think about Java typescript as some kind of add-on to JavaScript these days typescript is more popular than you know full-fledged programming languages like uh Ruby and uh and uh you know uh now these days a lot of libraries were Rewritten in in types of for example eaters.js it's written uh in typescript already as Richard mentioned it's gonna be even a better supporting typescript soon but still in some sense web free JS with typescript is broken and it breaks exactly in the moment when you start interacting with uh with smart contracts deployed on ethereum the problem is that to interact with a smart contract you need an API and this is a piece of uh Dynamic piece of Json JavaScript that you basically inject into your blockchain access library and then you get like some sort of uh object created during runtime that can talk with the smart contract and the problem is that you cannot type it you cannot prepare typings to this uh in a usual way and I recognize all of these issues some time ago uh like you know the rising popularity of typescript and the problems related to web free um interface word and created a tool called type chain so type chain uh takes your Json apis files and takes information about your target so uh do you travel to use eaters maybe web free.js and it generates a typescript typings as a Sim as a separate build step so this way you have excellent ID support you can uh you know just browse for the methods that um that uh that are available on the smart contract uh we support as well not spec that was already uh mentioned uh during this Dev Summit um as I mentioned it supports officially many different targets eters.js before five webview.js travel but recently we also added separate for hard hat which is kind of great like if you use hard hat you should that I give it a try it's typing things like get contract at and so on and I feel like type chain uh does uh like accomplished a lot like a lot of well-known companies like Union swap maker obviously optimism uses it but you know it it makes interaction with smart attacks a breeze but it doesn't solve all of the problems that a webview developer can can encounter especially during setting up like the scene for a smart contract development for smart contract interaction rather so you can imagine that the typical day in the web free developer uh life looks more or less like this like imagine that you get a new assignment to write some kind of script that gathers data or reads some events from multiple multiple smart contracts or maybe you're developing a front-end or backend it doesn't matter first of all what you probably do is you gather smart contract addresses and maybe use either scan for that maybe you browse and you know you just type in either scan search to find the addresses maybe use a GitHub and or docs of a given project to find all the addresses but then you need to find apis maybe if you're lucky you can you can find the API somewhere in the on the GitHub but then you need to wire apis with the addresses in code like create ethersjs contract wrappers or something similar then you need to generate typings if you if you want to have like you know good developer experience and type competition and only then you can start actual work so if SDK tries to make this ceremony much more easier and enable rapid smart contract to enable wrap rapid interaction uh over smart contracts so I like to think about it as a love child of each JS type chain and itexcom and you know talk is cheap so let's go and try to use it in a hard hat demo so here's a boilerplate code for a hard hat example and this is a very simple code that it's configured to Fork mainnet from a particular block and we can start writing code note that there are no you know useful contracts here we're going to interact with mainnet contracts and the only reason we use height catches for you know uh Fork features and what we want to do here imagine that it's I guess one week ago and compound hack just happened and you're a white hat or just person curious and you want to you know realize what happened you don't know too much about compound smart contracts but you still have you know addresses of the uh of the contracts and you want to you know dive right into it and try to and try to you know play with it um try to reproduce the original claim that caused like minting a lot of comp tokens and you know try to play with the whole setup so uh usually now you would start dumping apis in your code and so on and so on and it would take you some time but now we can use if SDK and to do that we can go uh write the GitHub and grab a command to install it it's to the dependencies and once it's it's installed we can use it right uh right now so first of all we need to create a config file so if SDK will read all uh contract information from contracts dot Json um config file so in this file we Define all of the contracts that we want to interact with and I already have this piece of code ready to uh copies so let me just dump it yeah so first we need to specify a network that we want to interact with uh here it's mainnet and then we we can uh start writing arbitrary nested list of smart contracts so we can have this namespaces like tokens but at the end of the day is name of the of a smart contract and address that it leaves uh on on the Practical Network and we do the same for compound for other compound smart contracts like comptroller which is responsible for dealing out the rewards it's a proxy so it has controller implementation and the treasury so there's another interesting uh bit about this attack and that's why we need a treasury so let me now it's the moment when we can actually run if SDK and see what happens so now it read a config file and it's getting apis automatically and it's generating client and notice that client was generated directly to node modules and now we're good to go to start interacting with the smart contracts that we defined so let me import the SDK so this is the if SDK client package and we have get main.sk and this function who is tailored based on the config that we just created so here we're gonna call it and we're gonna pass signer and you can see that it matches the shape of this object matches exactly the shape of a config file and if we go inside we see that there are a bunch of typings and in the runtimes these are either JS contracts uh that are already configured to be used so the interesting bit about the compound attack was that there there was a treasury contract that could be used to a trip even more compound tokens into treasury so just to test that that's that's actually test first the Jupe function so we're gonna uh we're gonna add some logging here let's say before drip and we're gonna call some methods uh so we're gonna check the balance of comp token on on E uh on the uh comptroller uh address so if drip function works correctly we should see that the balance was increased uh need some formatting and we need to import this function okay now we can call uh tree function and note notice that I'm not an expert in uh compound contracts but thanks to you know type competition I can write my code pretty quickly and here again I forgot to handle promise but since everything is typed correctly I got immediately uh you know an error in my idea about this so now we're coming trip function and after drip this um this balance should uh increase if drip works correctly so here I have a script to to to execute the code that we just developed and yes we can see that drip is causing like you know a lot of new comp tokens available uh now uh we can try to replay the what original uh maybe not attacker but the original claimer did so we want to claim tokens and receive much more uh much more uh rewards than we should receive right so again we're gonna we're gonna print out balance but this time uh before claim and we're gonna print out balance of the eoa that we're interested in um now we can call oh so there's another thing that we need to actually uh initialize a comptroller because it's just a proxy so we need to take the implementation and attach it to uh to the controller uh address okay with this we can do claim and notice that there are a bunch of um overloads but this is the one that we're interested in the holder is again our eoa and the C tokens is the list of C tokens that the Rogue claimer claimed and finally we can print out the balance again of the UA so if things go well we should see like this claim uh causing a lot of rewards to be sent to the eoa let me run it again it's a little bit slow because it's farcode but yes we can see that there was a bunch of comp reward uh sent to the user I don't know we can play it with this code but what I wanted to present here is that we were able to start interacting with a system that we know almost nothing about and you know write a script that does something meaningful meaningful very quickly and uh writing so it's funny because if SDK wasn't ready really one week ago as I told you it's a word Premiere and I was writing similar code and I made the typo while copying one of the addresses and I was exiting I was interacting using the wrong API to the wrong address and I spent like half of an hour trying to debug it so with if SDK it's all like very simple to to to code um now continuing my presentation so as you could see if SDK generates this lightweight type save ready to use sdks it works for different networks so even so uh we care about the network config because we need to have a way to connect to etherscan and and get a verified contracts for this for these uh for this particular Network so that's why uh that's why we support explicit at least of networks but it's pretty long including things like Optimus mainnet we generate sdks directly to node modules so if you're familiar with Prisma this is exactly the same approach I think it's quite nice because the import paths are always the same and they are like short and as I said it's perfect for writing any scripts uh one time one time scripts or front-ends or backends diving a little bit more into details apis that we gathered are stored in the if SDK apis directory and this directory should be actually committed to the git repository to avoid querying contracts again when you execute ifsk again another trick is that you could add executing QR executing um um if SDK as a as a post insta script so it's uh much easier to use because you always need to generate the client code um client generation is a little bit complicated because fires will generate uh fires to generate typescript code we generate typings and only then we run typescript compiler to get JavaScript code that you can easily place in the node modules directory and not much is Insertion I already mentioned so um what are the future plans so um we will We would like to have a first class support for hardcat so uh right now like you you saw like it's a quite un opinionated tool if it comes to what you're using if you could use it with uh you know whatever you want but we can improve the uh integration for some of the Frameworks so for example for hard hat we could register the API so hardcat knows more about them and can print meaningful error messages and so on uh we would love to integrate if SDK we've used app that Mark mentioned today um and uh the the beat that I didn't like uh during demo uh you could notice that we users were users are forced right now to reconnect proxy with implementation so we could also automatically query proxies to get always the valid implementation so if you recognize that a given contract is a proxy we can always query implementation and then query API for this implementation and then merge this apis so this would be I think a pretty nice feature for end users finally we we are planning on supporting alternative API sources so sourcify was mentioned here today already and I think it's an excellent tool that we should integrate with um because you know etherscan is pretty great but it's a closed source for perfect company so it's always nice to have like a decentralized alternative um and then we're thinking about supporting Dynamic addresses for for example for local network when you can provide them by hand and just enjoy the typed uh shell and that's it uh more or less um you should join uh our discards so at def we're focused on uh improving ethereum uh developer experience there's a couple of people involved in the organization here are social media and I'm open to any questions right now thank you thanks so much Chris um no this is really great I think uh kind of a couple of questions uh the first one is just as a confirmation are you getting the abis from etherscan or somewhere else and uh how does that work uh yeah so I I think I I answered it at the end but yeah right now um we use guitar scan API there's actually a key hard-coded uh somewhere deep in if SDK so I hope you guys don't uh dos it and but yeah the better idea would be to use uh sarcify or these have you know some uh like multiple backends but for now um eater scan was a way to go no that makes a lot of sense and I think uh one super cool part of this isn't is that so many talks today they're all interconnected and they're just helping uh basically modularize each other so it's just great that I saw you step a sourcify and everything here um I know you already touched on this thing but what are some of the future things that you're trying to integrate and uh or add features for and how do you think this will evolve over the next six to 12 months yeah so uh I I think like a single biggest uh feature that we're looking at is you know integration with other uh libraries tools in the ecosystem particularly the ones that you would use on front end so uh Margaret was showing uh today used app and uh used up is is great but if you'd if you are paying attention you would notice that smart contracts interactions right now at used app is uh totally untyped right I bet that the whole thing is written in typescript but again as I mentioned at the beginning interacting with smart contracts it's a little bit uh more difficult and um so we would like to you know integrate with with tools to provide like this first class support for uh for you know typed smart contracts and you know it's it's not something that uh you do um you know that the reason why we're doing is that because it saves you time in the longer time right like now these days if I write some code without uh you know having type information and basically you know guessing I need to go again to check the documentation or check the source code of the smart contract uh to you know double check the arguments or whatever like you know having all of this in the ID is just a game changer and it makes you know writing codes so much faster and debugging and that's just about yeah yeah and this beat like graphing this bit that that you could show that you could see that I've forgot about 08 in one place and you know ID could you know literally spot it right there and just say you know hey you forget to wait this is exactly the thing that that we're missing when when you know coding just in JavaScript absolutely um and then uh just kind of lastly to close um are there some immediate things that people can help with uh in terms of like contributing to the project directly or how is that structured and how can people get involved yeah so I would uh encourage all of you to just jump on a Discord Channel and uh we're trying to it's it's a very fresh channel so not so much uh going on there now but uh this would be a perfect place to to try to coordinate and if SDK is in quite experimental stage right now where uh we're just trying to figure out what's the best way for example to define the config or to Define some uh you know other things like I don't know the CLI interface on so I would uh encourage anyone uh to you know just just drop us some feedback and so on awesome well hopefully that was helpful for everybody too and uh it's a good reminder for everybody to join the Discord and make it more lively uh Chris thank you so much for that amazing demo and presentation and uh can't wait to uh myself use ET SDK and have others to try it out too thank you amazing all right with that we are ready for our next panel this is something I'm super excited about we're kind of just talking about smart contract security um and for this panel we have same season Rajiv and morelian um on on stage and um Ryan will be facilitating uh this discussion so I'll let him ask quality panelisting teams themselves instead of me doing the whole thing uh and making more fun so I'll hand this off to him and welcome everybody on stage hi everyone uh yeah thanks karchik uh I'm morelian and uh let's do some intros so nikesh why don't you start us off and then uh then Sam and Rajiv it's great to be here um yeah so my background is in uh I actually do physics and computer science at some point uh before in the before the times before I was joined the blockchain space I was wandering around in a bit of cryptography a little bit of reverse engineering just general I.T security type things but for the last two and a half years I've been working at open Zeppelin as a security researcher so basically we do Audits and research and trying to improve the security of the space protect the open economy as they say I guess that's my broader broad outline hmm thank you Sam cool hey guys I'm Sam I'm a research partner at Paradigm and uh I do security so you know Finding bugs mostly just fighting bugs that's about it that's basically all I do uh yeah Rajiv hey everyone I'm Rajiv I'm the founder of securium which is a recent initiative to further improve the state of security of ethereum applications and secureum is currently running a boot camp on Smart contract security auditing that's uh funded by an ethereum Foundation Grant and sponsor Partnerships from consensus diligence Sigma Prime and trailer bits so here I am thanks great okay so uh and and by way of introduction um uh I was one of the uh original members of consensus diligence and am now uh working at optimism uh focusing on protocol development and security issues and so I'm really excited to be uh doing this panel I think that so so given that youth Global uh that that this conference is really focused on tooling which I think is a really exciting topic and and this group is is really security focused I think it it'd be great to kind of will move this this conversation along kind of like uh you know balanced on the knife's edge between tooling and security of which there's a good amount of overlap um so having done that I think like a good place to start would be just uh you know we can each provide a little bit of context um about you know our the way we approach tooling uh where it fits in our day-to-day roles uh what we're looking for when we're when we're choosing what tools to include in our uh tool boxes if you will um and and if anything maybe tools that that you might have built in the past as well nikesh fair enough um yeah so actually as mentioned just before we started this that um my day-to-day work is um I'm pretty it's pretty spouse with tools so a lot of what I'm doing is just reading code and then trying to understand it deeply I think we have a bit of a bias that way that um we think a lot of the value we provide is just a security engineer taking the time to deeply understand code and trying to match match the knowledge to the to the particular task at hand but I do I was saying I do think a lot of the tools that I find are useful are just things that that avoid distractions so um so like I have really good note-taking tools for instance to help me keep track of what I'm doing as I'm as I'm reviewing we can talk about some of those if you're interested or the fact that I have like um in the past I if I needed to understand like a line of solidity I would like launch remix and then try and write it in there which was a huge waste of time but now I've got like this solidity rapple which just connects to like a local ganache CLI um in in itself like the whole point of that tool is just so that I can stop thinking about it so I can I have a thought in my head like what does this line of solidity do I quickly go and do that and then get back to what I was attempting to do before which was just understand the system but I think a lot of it really depends on what you're attempting to do maybe just being a security auditor um there's a particular style in that that we follow which is just trying to understand contracts deeply but um but of course there are different approaches to security all over the space that I'm imagining there'll be several tools that will be useful in other places um I might leave it there for now um pass it over to you yeah I mean I can jump in here uh I think I mostly agree like when I when I'm doing audits for reviews I tend to actually stay away from a lot of the automated standards I find that uh you know I'm gonna I'm gonna end up going through and reviewing the contracts anyways and so for me at least there isn't really uh much benefit that those scatter spring however that being said I do find Value in tools elsewhere like um for example when I'm reviewing some contract on mainnet sometimes I need to figure out uh what you know what's in a particular storage slot or what happens if some function is called uh in the past I would you know pull up devtools and you know 130.ether you know get storage at uh and it worked it was very ugly but it worked nowadays I actually just use set for that from the adaptools package so uh here we go we're we're three minutes in and already someone is show adapt tools uh we'll see all of them let's see where else this goes yeah it's funny like I I I I kind of got off Twitter for a lot of this summer and then I came back and it was everyone's like talking about dab tools which has been around forever where did that come from what is it like what what flipped there that everybody wants to talk about dab tools all of a sudden because they're happening on Twitter and then everybody else learns about them because they're happening on Twitter and I think a lot of the security Community is relatively small and uh a lot of the value is just like knowing what other people in the community are doing you hear that like I get to read a Blog that Samsung's written and then I learn something new because of that fact and I think it's just like access to the community you'll end up doing whatever else they're doing that's that's my instinct but I don't know I can't speak for why other people do what they do I mean it's really cool like Martin and the team at devtools have been working so hard for so long it's it's nice to see them getting some traction like that but but please go ahead and retrieve No I um I mean I I might be the odd man out I haven't used app tools so yeah yeah please excuse me for that uh I'm gonna actually try to do that over the weekend but uh but yeah I mean from a tooling perspective I think the points made are valid um the way I see it I do see Tooling in the space of ethereum security as uh maybe focused on developers and maybe in our separate set of tools that are focused on Auditors and today I think there is a good overlap so a lot of the Auditors uh like Sam was saying and you just are in the space you're looking at contracts uh and predominantly there's a lot of manual analysis so the ROI that you would get from uh you know from any of the automated tools is maybe not that much on a day-to-day basis maybe there are some special use cases for that but for developers I think uh there is there is a lot a lot of value right uh be it any other static analysis tools uh like Slither or the tags or any of those there's a lot of value to that so I do see that sort of uh dichotomy maybe that that gets blurred sometimes but uh as for me um you know when I review contracts I do fall back on magnet analysis um so the tool that I use there is uh is is usually this already visual developer plugin which really helps me navigate the code uh very cool or that stuff for vs idea yeah bye my old friends at diligence so that's that's fantastic um and I do tend to use Slither now and then to just get you know get me some good starting points to just get some sanity checks going and in the past I've actually uh contributed uh semi detectors to the development of Slither so that's that's my general perception on tooling aspects yeah so my the way that like the pattern I'm I'm sensing here I think is is um you know as as Auditors the it's very different from developers like as a developer you just like you live in one code base and you are there all the time and you start you know you join this company your like project and you had they gave you a couple weeks to ramp up you know like the amount of time that is kind of like the training period for someone in a new company is kind of like how long you have for an audit I think so what you what what security researchers does artists are doing is just like really trying to understand the code as quickly as possible and so I think that there's um seems like a uh the pattern is that you're sort of like a bit more less of like just point-and-shoot scanner approach and more of a marriage of say human and automation to to get deeper understanding and I think that's where you see the visualization tools the graphing uh those kinds of things becoming very very popular for auditors um but so I mean you guys also see a lot of different code bases I I imagine um do you do you see patterns uh of tools uh and so you have opinions about teams and code bases and which ones are good and and which ones you love less and we don't have to talk about names but do you see patterns of tools that that the teams you think you know are on the right track are using in there their development process so I I guess my advice is whenever I see teams using um so like the team that I have in mind at the moment that they do all of their pull requests out in the open and then they answer their questions and they have security questions quite often I'll be reviewing code and then I'll go look at the pull requests that they made or some of the commits and I get to see all their comments and their thought process behind it all of that stuff is really useful um I don't know like it seems to be correlated with a lot of the continuous integration tools that they use like so as because I'm not a developer I can't say exactly how related these things are but I think there's probably some level of professionalism when you reach the point where you where you take uh just development seriously and then you make sure that there are two people reviewing every uh like all your there's always someone who reviews all your code and then you're going through the process correctly there does seem to be at least correlated in my mind with people who take security seriously as well and just maybe riffing a little bit on what rachief was saying I think a lot of our clients will actually use some of these tools before they reach an audit and it's like a good way to to find your own like bugs Fest in your own code um before you actually take the time and effort to go in and get it audited so I guess that's my initial Instinct I I'm not recommending a particular tool other than just noting the level of professionalism does seem to correlate somewhat with the level of security analysis maybe so say you might say so GitHub or git and and the code collaboration tools that in general that just enable people to ask each other hard questions about what they're trying to merge right so I guess like everybody is using GitHub but then some of them are just like pushing to master directly and some people are making pull requests without values and that's that's the sort of way that I that's a that's that's like like reviewing pull requests is is a like a high bar or like an indicator or something I I mean maybe it I think it depends on the detail I think I'm speaking like I'm sorry my point is that it's crazy that anybody's not doing that I think it's just what I'm getting at but okay okay yeah I think my instinct is really more about like how much effort they put into reviewing pull requests there's obviously different um different degrees of half series that you take that sort of thing certainly yeah okay um so so I think like maybe even if if uh it's not the focus for anyone here I'm I'm curious what if any uh Impressions you have about the potential there is among the uh the the more advanced tooling um so static analysis I think like I think like running Slither is a really good just like you know it points out a lot of stuff a lot of code smells um that's a static analysis tool then I think you know fuzzing there's a variety of good fuzzers out there that um are maybe the next step to look at or else symbolic execution tools um do you have a sense do you have a feeling about like where we are at with those uh have you seen sort of like output from them and and found that useful or is it just uh usually just a list of findings that don't really give you Joy um I mean I can jump in if and but I'm sure I feel like it might be monopolizing this a little bit so I'm anxious about that suddenly feel free to interrupt me well well I mean I'll just I'll just like Sam and Sam and well you told us in chat but Sam just like tell us what you said about everything not in contracts I mean I guess maybe I'm not connecting the dots here I in chat I just said I'll pass on the question because I when I'm when I'm Ravine code I basically were a project I basically ignore everything that's not in contracts and I guess to even be more specific I ignore everything that's uh that's uh inside test as well because I personally I don't you know unless the code is like so confusing us too I'm not sure what the correct behavior is um there's really no point in me checking the test it's I think it's just a waste of time uh but actually on the topic of uh fuzzing I once again will start Georgia's uh Georgios has been like one of the major drivers behind the devtools chilling I think and now it's rubbed off onto me so I would now I will now show adaptables again because you did this presentation internally at Paradigm uh where you showed up the fuzzing in property testing that you can do with dab and it's actually kind of like you know you you obviously you have like a kid in uh in metacore and I think mythex does fuzzing too right am I misremember yeah uh and you have a and you can you can do you know fuzzy and property testing with them you want you can go uh more advanced I'm sure but it's always felt sort of inaccessible I feel like um it's it's always seemed like this this hurdle to overcome to figure out how to like use these tools um and the interesting thing with devtools is they've taken a very similar approach to How it Go does it which is you basically have you just you just write a function in solidity like you know maybe right beside right beside your actual code itself and you just put in as parameters to the function uh the things you want the fuzzer to explore and that's all you need to do and the rest is just handled for you just run the command so I think that's actually really awesome and hopefully as more and more people find out about this through the non-stop Shilling that happens everywhere uh you know maybe we'll see more and more using uh usage of funding and property testing so so to clarify what I I think I understand is like it looks a lot like a typical test Suite but instead of saying um transfer one token to Sam I'd say transfer X tokens to somebody and that's that's all I do I leave that open and the fuzzer takes it from there yeah pretty much you could have like you know if you had a function that uh you know did some complex math to figure out the returns for some exchange right uh you know you could treat it as a black box it's it it takes some un256's input in return some of you and 256 as output and you could just tell the father you know I want you to just like I just care about this un256 input and then assert on the next line like the output is same right and the fuzzer takes care of the rest it's just that magical yeah so so for for anyone not really aware of what what fuzz testing is it's I mean it's basically that it it's uh instead of writing one test at a time it's uh tools that generate ideally millions of of test cases um and sometimes can be quite sophisticated about like like speaking from from diligence what for some reason the fuzzer there is called Harvey and like that's not really like a product name it's just the internal name but Harvey um it's it's quite like it's like it tracks where it's been in the byte code uh and when it like bounces off a require statement or an if Branch multiple times it it does um like solving to try and say okay like I almost got this this if else Branch to flip so that I could I could get into that um and it tries to figure out the the math so that I actually can trigger that which is not an easy problem um and I think that that is I actually was just looking as about a month ago that they I think they've really shifted the focus from myth X over to just like like fuzzing and and doing uh more fuzzing as a service and there's also like I'm really interested in what we were working on there which is this tool called scribble which allows you to write uh basically Nat spec format formatted comments which will then you recompile the solidity and it adds all these assert statements that um allow you to describe specifically the the failure cases um it was still like it was still coming along as far as sort of like usability but I think I'm due to check it out again go ahead regime all right yeah I think two critical points that that were made right one of them is um as maybe security researchers who were deeply into the space we focus a lot on the effectiveness of tools uh you know understandably so how accurate it is false posters all that make a big difference we also focus a lot on the efficiency of tools and the second part actually leads to the usability aspect of the tool itself that I believe oftentimes is not you know because if if you're deep in the weeds then you know if we are developing and if it's all open source then you're using it so we really don't appreciate how uh you know deep we are and in that same tool is actually expected to be used by the developers of protocols and like you said you know we have like a week or two to actually look at the stool then that barrier I think becomes a huge deal right in terms of well I let's take Slither for example right take it install it and you run it and it should just work right in the box right but for some of these other equal to it's like you said right be it fuzzing be it symbolic Checkers there's just so much heavy lifting that needs to be done uh even before you can start using it right I mean you need to understand how the tool was the intricacies the documentation of the tool itself and then we need to write the rules the fuzzing or uh let's say property based testing right so there's just so much work that is involved there uh which I think you know hopefully over time will get will get much simpler so that the product or protocol teams themselves can actually start using these tools to uh to a good extent so I think that I think is uh something that maybe as a community we don't pay enough attention to I agree cash no I was gonna say so I haven't actually used uh fuzzing since I've joined this space But like I used to do some fuzzing stuff back in like a VPN traffic and you just throwed a bunch of um packets and see what breaks at least at the time a lot of what we were looking for was crashes basically looking for places where the whole thing crashes and then seeing if you could instrument the system later and find find where it broke I was a little surprised to to hear that logic applied to the smart contract space just partly because you're not trying to like crash the evm in any sense you're you're really um you you'll maybe it's more it's a closer to like smt or like property-based testing rather than what we'd call fuzzing maybe I misunderstanding the term um or I've got some bias that that's forcing me to think in a particular way certainly your idea at the end of like being able to Nat spec a particular property friends I've mentioned this example uh in the past sometimes I'm looking at code and then I know that this value is meant to be a um a percentage so it has to be less than one for instance but it's not immediately obvious just looking at the code that it always is to the extent that it's possible to like not spec that and say this is supposed to be less than one please make sure that it's true throughout the whole code base um I think all that that would be useful but personally I haven't actually seen that that happen it sounds like you're telling me uh I just have to wait a couple of weeks and then maybe maybe that'll be out well I mean In fairness I think that that's how all of the fuzzling related tools that we've talked about work is you basically have to reason like you got to know your system and you gotta know what's wrong and if something is announced that only goes up then like the fuzzer can tell you if it goes down but you have to write somewhere uh that it should only go up and it should never go down so like there's various places you can write that um but yeah it's not it's not just like a general crash kind of situation it's you you have to be able to Define your failure modes can I just clarify is it doing this probabilistically or is it actually exhaustively checking the possible inputs I mean it's a weird term when you're like enumerate through the whole space but you could do it symbolically as well to to check yeah uh it's I mean like I know that and like the mythex suite they would measure like how much of the code they'd visited it still doesn't mean like you could hit 100 of the code and not not necessarily have all meet like all the edge cases or explore all the the kind of like execution modes um but that is the objective is to to Traverse the entire system I will mention that daptos does do symbolic execution as well but also it's a good point that it's a good point that you know it right now like all these tools do require you to Define it like the the weak part about unit tests is that you can only unit test what you can think of right and so often you know in hindsight you'll look at something and go damn like that would have been a really nice unit test but like the hard part wasn't writing the test it was thinking of the test in the first place and with you know fuzzing and symbolic execution or property testing it's you know you've alleviated some of the challenges with like you know maybe defining exactly how to test but you still do have to think of the thing to test for um and in fact that even you know we can take that one level higher with formal verification we see that uh as one example that comes to mind um uh the the Miso bug that I found in the couple months weeks months ago I don't know how time works anymore uh that was formally verified it was just that there was no case defined for uh both minting or sorry both uh buying into the auction and using the batch uh contract and so once you know once the team went and like added that case the form of airfare was like yeah there's a bug here but you know you have to think of that first and so it might be interesting I don't I don't even know if this would be possible or not but if there was some way to just like you know similar to how traditional fuzzers just look for crashes uh if there's white just look for ways to send ether out or ways to transfer tokens out that might be way too computationally expensive I'm not really sure maybe someone else here can comment on that no no like I think that that that's Slither does that Rajiv yeah yeah I mean to a certain extent right whatever you can determine syntactically and somatically like Club ether and so on but yeah please continue um oh okay yeah so I was gonna say like I'm pretty sure mythx did did that does that uh the thing is if you care enough about the security of your contracts like it's like it's usually kind of well no this is not true obviously the experience bears that out but I think it's hard to detect the weird things um and I think that the messages that you end up showing are like well there's like a kind of like you call out here to unknown we're not sure what you're gonna do um but like fuzz testing so as soon as you call out to an unknown contract what are you going to do like generate all the possible contracts um or symbolic execution as well like it's that just doesn't really make any sense um but but I was hoping and so so formal verification I'm just like uh overrated or underrated let's just let's phrase it that way we'll go around and retrieve you got to go first because absolutely so yeah I think I think like with many things in uh well in the space and maybe in life right formal verification is probably overrated in the near term in this space and probably underrated in the longer term um so there's just I mean I get the impression maybe it's sort of the meme of the Season or whatever right but it's just like hey you know let's let's go to formal verification right I mean I I do I do believe that property-based testing such as scribble or certos or kevm or verex from chain security all these do have uh you know will play a significant role maybe it's just you know where we are in the maturity cycle of the tools I mean there are so many things that are moving right solidity is changing every month ethereum itself is changing uh protocols uh everything so in that scheme of things I think uh just just sort of moderating our expectations from these tools especially formal verification that it's not a magic wand and like Sam said uh well you know great we do use a formal very uh verifier but how do we know that you know the formal verification tool itself I mean you know somebody built it how do we know that that doesn't help us how do we know the properties that were written uh you know do not have omissions right so those things and this sort of goes back uh I mean none of this actually is new in the web 3 space if you look back uh all the way to um who was at Ken Thompson's during award lecture on Reflections on trust and Trust right so he talked about well all these layers that we seem to rely upon as something very canonical something you know perfect but that's not the case and that applies even to formal verification tools uh so no wonder right I mean if you have a checkbox saying well this protocol was formally verified it's not a magic one but that is not a problem with the tool or the approach it's just a problem with our mismatched expectations so what you're saying is you should write it GD spec a spec I'm uh so that you can like identify those things I guess right I mean that that would be again a mismatched expectation at this point having looked at some real code basis I would be happy you know for a typical project for uh something more than uh one screen readme file right something you know we can start with that we can go to better documentation I mean if we have a list of all the contracts and the interactions a spec would be fantastic absolutely yeah a spec is a powerful tool um English language underrated uh nikesh uh overrated or underrated formal verification useful but as rajes pointing out there's probably a mismatch between what it can do and what people think it can do even the spec I don't think helps as much as you might might expect at least my instinct from that is based on the fact that people have been talking about like formally verifying vpns forever and there is a spec like it's there's an RF scene that's existed for a long time and uh and it seems theoretically that you should be able to just Implement that spec in uh in a formal verification tool and then but still openssl has the market and it's like spaghetti code completely and partly that's just because they got their first and also like if you want to open and you want to add this new uh protocol you want to use Divi home and instead or you do something slightly different then that's like spins out a whole six month eight month project to specify that part of the test I think the like it's particularly in the blockchain space it's moving so quickly that by the time we have like a spec of erc20 people already doing flash loans and stuff so then you'll you'll lose the uh the ability to to at least keep up to date with what people are doing I suppose I I do think it probably would be useful to have a formal like formally verify some repeatable components like if you get I mean I might just throw a open second button contracts in here like if you if you can formally verify something that's been used like in lots of different projects and is relatively well defined um I think that might be useful but uh but I at the moment I think it's just going to be lagging behind for a long time no yeah so I think like Sam anything to add I think rajiv's uh you know short-term long-term answers just so he's like effortlessly wise that it's hard to add a whole lot but I mean anecdotally I will say that usually when I see that Satora has formally verified a repo I'm like okay that's probably safe um like you know again but I think that speaks of equal volumes to both the technique itself and also their team's ability to actually reason out what your code is supposed to do for you because that is what they do is they sell you the service and they sell you well they sell you the technology and they sell you the service to use that technology so yeah so so one thing I think is interesting there is like um one of my favorite auditing techniques was like making diagrams and I think that's something like that's a form of spec like I I and so a lot of tools do this too they in that they informal verification as well again that they force you to reason through uh they just put you through an exercise in which you sit down and you're like what does it do what does it actually do and you know converting solidity to a picture or or words I think is an effective way of or or like or properties and maybe properties is a higher value output because you can reuse them um but I think for a lot of tools that is my sense is that that is a lot of the value is that it forces you to interact with the system more deeply energy oh I was just going to do the same absolutely agree with uh you know the quote was said uh I think to sort of go back to one of the first questions uh that was supposed if there were two tools that I would love love to see right from again separating out the auditing from a developer perspective from a development perspective if there were two tools I think those would be at two ends of the spectrum one of them would be something like Slither something that's very fast static analysis that catches all the code smells that catches all the basic pitfalls shows you what the best practices are so that I think would give the best bang for the buck for the development team right away and the other one would be the Other Extreme which would be the property based tests because that would force the dev team to think about you know well want to have a spec right and you might call it spec documentation whatever but it forces you to think of well what is the requirement what is the expected Behavior right and it makes you document that formally in the context of this too right so those I think would be the two sort of uh uh you know top on my wish list so I have an instinct it's not very well formalized so I'm I'm kind of shooting from the appear but I think um marillion's point was excellent about the fact that it forces you through this process in itself is useful even if the output of what the the tool says um might not be that readable um but I have a sense that we might be mixing layers because at least in my in my experience the the real value a lot of these things is being able to transfer the knowledge in the developer's head into someone else's head so into an audit for instance or just into another developer um so they have some threat model in mind and they know that they wrote the code in this particular way because they're trying to avoid some particular style of attack and then in order to comes in and thinks well have you thought of this style of an attack and maybe they have maybe they haven't but then there's a huge ramping up period and then then it's also quite unfortunate you get to the end of an audit and now you're an expert in the system and then that wanes until the next audit shows up so um like I think a lot of processes are potentially in place to maybe shorten that time period so that um so that we're not doing it in batches so like obviously it'll be useful to to try and maintain more of a continuous sort of relationship that way but um but I think we then make a mistake potentially when you then try and specify it in the code because at the high level I haven't said anything about this particular contracts or if statements or anything I'm thinking really just about have you thought about replay attacks have you thought about access control issues and that sort of thing and um I guess a lot of times your threat model goes out of date after a while like you you have you wrote your code is assuming some sort of threat model and then it turns out the ecosystem changes uh flash loans become a thing or for instance now you can do reentrancy because the gas limit has changed or something like that has has gone wrong and you don't go back and revisit the code because um because you thought the code was self-sufficient whereas um what we really need is just a way to transfer knowledge I think a lot of the value comes from just the existence of the security community that has seen all of these things before you can go through previous audit reports and stuff we have repositories of where these things exist so like you could say I'm building a tool like I'm building a voting tool let me look at all the places these are the checks that I need to worry about these are the things that are broken um I think a lot of that is useful well before you actually get to the code level um and to the extent that we can have tools that just like spreads security knowledge around the space I think that's uh that's going to be a at least it seems like an underserved Market that's my my own Instinct but it isn't particularly formally uh sorry formalized yet so we're kind of just shooting a little from here fair enough I think like a good example of that like the threat model changing I think is maybe like developing a DEX uh all this will use a bunch of erc20 tokens and then somebody's like oh but I have a token that will do callbacks to whoever you want when you transfer it um and you just don't think about that right you're like it's just an erc20 token it's does nothing fancy um so uh maybe just to to keep moving along and I don't know this this is probably a little bit of everybody's wheelhouse but like do you have thoughts about like what you should be doing when the code is running on chain like it's out there uh is there is there a magical way to detect and prevent uh attacks in real time um and I think nikesh this is like kind of softballing for you so go ahead I think it's I I sort of have to mention at this point so uh we suddenly opened Zeppelin we have this tool Defender it's got a auto tasks you can suddenly write up your uh your your security Properties or things that you want to check you can say like if this balance changes or if some property it holds on the blockchain uh then please run this task or at least give me an alert we're also developing a new uh a new tool called photo which is um like a web 3 native cyber security thing which is it's quite it's basically like an alert monitoring system there will be details to come soon um but uh the important thing the thing that's particularly interesting about this is it's it's web3 native so uh so it's not like an external tool that you're running and then you try and pipe it into the blockchain it's actually running directly on the Chain so you'll be able to hook it into all of your apps it's like developer sorry it's decentralized and and directly integratable in the same way and composable in the same way the rest of uh the blockchain so that's my uh my pitch is it gonna save you or is it just gonna make sure that you know right away that your system is totally owned ah true that's a good point so it is it is um it's like agent detection so you're it's detecting things that have changed it's not um necessarily preventing it but it it suddenly we do have things like Auto tasks that say like if this happens then run this command so you could like pause a contract at the moment that something changes so you can you can take sort of automated actions that way if you get like I mean if the if the attacker doesn't bother to use flashbots I guess right like and right yeah so of course yeah it it's too that it it'll shorten the time period it takes to react maybe that's a good way but yeah um I are there other things out there or Sam or Rajiv do you have a thought about not even tooling but just like running these systems safely no is an okay answer too just okay no um I mean I've seen quite a few attempts to building these sort of things now where you know you try to alert on transactions in the member of course as Nikish said yeah that flashbots is more and more saying that that becomes kind of hard the the only time I've really seen I you know what I don't really know where I was going with this I was the the point I was trying to get to is like I tried building one of these at one point um and it was meant to like alert on pastors past transactions so like things that were already mined and just just to see like if anything interesting was going on tried to like automatically detective a transaction was like a novelist uh it was like somewhat okay it was very noisy though so I sort of escaped upon it but that would be I don't know if anyone's built that or made a public version of that but that would be cool to see just a like a live automated thread Intel feed almost yeah I have uh I don't have much to add in this space but uh maybe I have a more questions in the space right so if you and I discuss this with some of you in the past is if you look at the web tool world right you have a long list of security products in the last 30 40 years you know so all the way from AVS firewalls intrusion detection systems and all the you know different names of that intuition prevention systems all these things right so there's no reason you know except uh taking into account some some of the big changes in the web 3 space Maybe culturally as well as technologically that these systems could not theoretically be implementable in the webpage space right so if you're able to see a transaction in space as it is flowing through the mempools or whatever layers you're at theoretically one should be able to simulate that you know for you know your main net with whatever tooling be able to simulate this transaction and be able uh where we obviously need better and faster resources than that attackers themselves but you should be able to do that and then uh you know put in a transaction that actually takes over or goes ahead of that address transaction and somehow fixes the code or makes the type of transaction invalid right so theoretically I think it should be possible I don't know I mean uh maybe indication others have more practical experience in the space with Defender and other tools but that that was I mean that was just a thought and I hopefully we will see uh some research or maybe even products or techniques in the space just make sure I understand uh that claim so the the idea is you see something a mental and then you're you're essentially trying to replace that transaction so obviously front running as a concept is existing and people are doing it for unlike non-security related reasons like just for Arbitrage generally and there's that's been developed uh quite extensively to the point where your people are like running gas suctions and things whenever something new happens then of course flashbots now is alleviating some of that um I understand you're you're perhaps approaching it from the security angle but maybe I haven't seen why it's a different concept it sort of seems similar to seeing something that you don't want to happen or something that you want to prevent first and then getting your transaction first um unless the contract itself is designed in such a way that it has a delay sorry I'm just I'm thinking out loud at this point and I might be uh misleading him no yeah Sam why don't you jump in here I think you've been quiet for a little bit so um no I mean put me on the spot I guess I don't know I've been quiet because I didn't really have much Dad uh um you you were unmuted I took that as a signal oh sorry yeah that I read too much that's my bad okay um I mean our well I yeah I I kind of think you're right in the cash like in the uh you know if you can well basically I guess you're gonna get into this is like outside the our our wheelhouse but like you're gonna get into reworks right like because you got you got flashbots you got private transactions I'm a brilliant black hat hacker I know how to you know um I've got I found an exploit I submit it through flashbots nobody can see that um and that's it's going to execute I'm going to own your contract the only way to to get back to like to to restore that is to reorg the chain and like outbid and I kind of lost track of that conversation that was happening over the summer but um that that's that's where that goes to me is as far as I can tell it still sounds like it might be in the same bucket in the sense that I so and now I'm definitely speaking outside I don't know anything about how uh how useful it is to reok or how plausible it is to do that uh hopefully people are thinking about that to make make that difficult but um but I would still guess that if that tool is available if that technique is available it'll be used first to to win um like trades unisoft trades or something to Arbitrage some as long as there's like direct money on the line that'll be the the use use case originally um and people will be doing Arbitrage with that tool before like the security level catches up that's my my instinct so yeah I guess we got I guess we got like a minute and a half left so a question I kind of like I just remembered I really wanted to ask is like what tools needs to exist or like be way better than it currently is that you would like to see in your life so let's like 15 seconds what does it do nikesh your remu go ahead Fair um I have this this grand plan of like making a threat modeling Tool uh that I think uh that works same same kind of saying working at the high level of understanding threats rather than understanding code that's my 15 second Pitch cool Rajiv um so I have a slightly different brush right I I think all tools have their place but my wish is they get used sooner than waiting for the Auditors to run them so I'm I'm thinking and you know I'm getting really big on the shift left that has been such a big thing in the web 2 space I think web3 space needs a lot of that I have like a really big insane idea and like a smaller doable idea the big one is like I want like this integrated all-in-one platform where I can like view contracts decompile them analyze transactions inspect storage slots uh look up four byte hashes like the works right like everything I need to do ever is like a tab away like convert from hex task or whatever right all that stuff that is like a lot of work oh so I suck at UI design so I'm not doing it myself uh the more doable one is like some tool in my ID that lets me annotate specific variables or blocks or whatever with things that I don't have to remember like this variable is always going to be even or this variable is always going to be less than 100 or something like that and then that way when I click through three functions and I look at the variable again you know I don't remember that I can just hover over and it's like okay hey by the way you said this is going to be less than 100 so you know just for reference yeah okay that's great um I think we're at time yeah um that was an awesome discussion we'll we'll do two uh quick things um and anybody can pick one up to do everybody but the first kind of question is uh for people who are trying to enter the space as Auditors uh do you have any tips or advice for them and what do you kind of recommend they do if they want to be on the auditing side join the secure and boot camp sorry no that's that's you should show first yeah yeah maybe maybe just to get more context to people what is the boot camp and uh how can they find out more yeah I mentioned this in the beginning but uh securian boot camp is a three-month boot camp that has just started in October it's funded by an EF Grant and the sponsor Partners that's not the top auditing funds in this space uh the idea is to be extremely open to people from different contexts so there's a two-month learn phase where people are gonna learn about ethereum 101 it's already 101 201 order techniques audit findings all the rich content that we already have curated in this space and the final month is going to be where the rubber really hits the road they're going to be taking a look at some real world projects where they actually evaluate them for audit Readiness and hopefully you know have a good chance of becoming auditors awesome um and I'll kind of blend this on the other side of uh sorry I feel like I I might want to answer that question just because uh first of all I certainly agree with achieve that the security seems excellent but of course uh I feel like I have to point out if you can ask me the question uh open Zeppelin has a bunch of uh um videos that we put out like tin show one of our security researchers puts these things out we have like the ethernet and uh all sorts of these sorts of techniques are useful and we're always hiring so if you actually resonate with that question then uh come hit us up uh all right I'll one quick one um and others can kind of mix and match that last one too I just for people who are trying to now replay apps to production or contracts to Productions and that um any tips for how do they actually think about auditing or insurance or anything else around that and what are some things to keep in mind for newcomers very open-ended anything qualifies I think maybe the same Instinct like try and get plugged into the security ecosystem you'll like there's lots of people who'll guide you through the process but uh it's hard to answer that in one second but try and get plugged into the ecosystem is my my main suggestion look your audience early the lead times are long perfect well we'll end that there thank you so much Samurai location morelian uh this is an awesome discussion and uh for any other questions we'll relay them to you over email so uh with that we are ready for our next talk so uh without further Ado thank you welcome thank you very much Daniel Daniel's going to be talking about how to decentralize front ends with Skynet and on screen so Daniel welcome and I'll let you uh kick it from here thank you so much for the introduction let me go ahead and get my screen sharing going and I assume everything can be seen now um so yeah thanks of kartik for the introduction um I also just want to before I get into things say thank you so much to each Global uh for inviting me to speak the hackathon and Summits have been a lot of fun so far uh always good to learn from all the smartest people around um yeah so the talk name it is decentralized front ends better tooling with Skynet and home screen I'm Daniel Helm I'm the developer evangelist at Skynet labs and in lieu of doing kind of a personal bio I figured I'd kick off this session with a question should we decentralize front ends in the web 3 space so you know I work day in and day out in decentralized storage so I'm going to emphatically say yes but this is the question that developers have to make a decision about right and I think maybe it's better to reframe this question if we really want to get to the bottom of it and ask are we really Building permissionless Systems if they're centralized at the point of entry uh so it phrased another way you know like are we really Building open protocols if we're only letting our users access them or 99 of our users access them using AWS netlif5 or cell digitalocean so these are kind of how I'm framing my talks if some of these terms are new to you um don't worry I'm going to do some back filling but I just want to kind of set these out at the very front so if you're unfamiliar with decentralized storage we can kind of start there maybe you missed yusuf's great talk earlier today introducing some of the ideas of decentralized storage but we're talking about a core piece of web3 infrastructure where files web apps nfts basically anything not stored on chain can be accessed without relying on a single trusted Authority at their best their trustless permissionless and censorship resistant and they're really good ways to potentially Wrangle control of data storage away from the Amazons and the Googles the world there are a lot of folks building in the space um so we're talking about projects like Skynet or ipfs or rweave and most of them take a similar Approach at least to this kind of Base data that you're going to upload so you upload a file and what you get back is a unique identifier this cryptographic hash or Merkle root that you know looks all crazy but what it says is that this is the contents of this file and if this file changes my URL is going to change um so here I'm actually showing a Skylink it's what we use inside of the Skynet ecosystem and it can be used to know that like once the file is uploaded you can share that URL and no one's going to change it you're not going to change it the portal is not going to change it um no host will be able to change that data that data is immutable it's not going to change and what this lets us do is take that and stick it on the end of a portal URL and so again everyone in the ecosystem has portals or gateways ways of accessing this data through a web browser and so here we see the Skylink stuck on the end of science guy.net which is the portal that we run or you can stick it on the end of a community portal like skyportal.xyz all right so if this is new to you um this might seem a little bit abstract so real quickly I just want to show what it looks like to upload something to Skynet we can jump over and I'm actually going to upload a web app because we're talking about website front ends and look I've already forked and yarn installed and yarn build the unit swap interface and so we have a build folder here and I'm going to open it up and explore find my build folder and drag and drop it to the Skynet uploader and so what happens when I do this is that file goes onto Skynet it gets broken up to a bunch of into a bunch of pieces and stored on the Saya blockchain and at the end of it what I'm going to get back is one of those URLs right so I have this folder that has the index.html file and I get back a URL that I can open and I've got uniswap here and once that file is uploaded and on the Skynet Network you know that is available everywhere so we have a url.cisguy.net I can change this again to skyportal.xyz click enter and I'm able to pull up the exact same content so this is kind of the base idea of decentralized storage we're able to have lots of access points to this data that's not stored in a single location okay great let's see what this looks like though from the perspective of running a web app because I think a lot of developers say to themselves like hey it's just a web app like these are kind of overblown requirements we don't need all this to be immutable but you know the stakes are real and they're getting realer every day in the web 3 space and so we're seeing developers and web3 users get placed in really tight spots and they're having to kind of address questions like what do teams do if you know they're hosting a site that makes them liable for user actions or what if their hosting providers don't like the way that the wind is blowing with regulations or local social pressures and for users you know right now you're totally unaware when the code of a front end changes which kind of puts you at the at the whim of the security and product decisions that the dev team is making as they push out these changes to their website um so these aren't paranoid hypotheticals like we see this play out in the news right um uniswap uh had to you know they removed assets from their front end in order to protect protect the developer team and users during a time of regulatory uncertainty and we had Sushi's miso attack that put over three million dollars at risk not because of a smart contract bug or some of the security issues we saw before but malicious code that was introduced into the front end um and one of my favorite things I've seen recently is one inch's new feature um that I don't even know if it's live anymore but briefly you had to sign with your wallet a little message saying I am not a citizen of the United States uh and they also did some Geo fencing where if you then still try to use their web app while being located in the US it would say like no no you're not in the US so make sure you disable your VPN which is telling us that you're in the US um and so if we're seeing all these issues developers uh can you know be asked why not decentralize uh and it's because there's lots of challenges and concerns that developers have you know not all web 2 patterns translate well to web 3. if you've always used a back-end a back end to you know handle server-side things like storing user sessions or doing database queries sometimes the new web3 Frameworks can just feel weird just like writing smart contracts can feel weird um similarly in the web 3 space with this decentralized architecture we have limited framework support compared to traditional web serving so if you're only serving static assets because these things are you know immutable then your Frameworks are going to be limited and most protocols don't even allow for writing custom routing rules which are usually available in on traditional web servers and the final kind of thing that I think developers have concerns about is performance and so I think this can take many shapes both in terms of things like time to First byte for users you want your website to load really fast and feel Snappy but there's also performance concerns about you know is the long-term scalability proven for projects that are going to be like storing all their files on the blockchain or is data availability like that's a you know performance concern like if who can we rely on to keep data available and online so these are real challenges um and you know to these developers I shall uh why not decentralize with Skynet you know um so it's true that not all web 2 patterns translate but uh the tooling is being built for really performant mutable data apis including one of my favorites is one that we've developed called my sky which is a cross-ecosystem decentralized user identity um additionally there is limited framework support um so some kind of classic both back-end front-end paired Frameworks aren't going to work but at this point um you've got full support for things like Gatsby and a react router and other dynamically routed client-side Frameworks and lastly with regards to Performance concerns um it's probably a little bit out of scope to get like deep into the architecture of Skynet or Saya here um but try it out I think you'll see that our speeds are already comparable to the experience of web 2 and what web2 users expect and this level accessibility for our users is a primary concern we're always working to really reduce our time to First byte and and what that looks like um so with Skynet you know all of these things are possible for users and developers without having to install a wallet or special software or really touch any sort of cryptocurrency okay so yeah at the end of the day yeah this is our goal any developer can build a web 3 app that anyone can use all right so I talked about some of the kind of like fundamental ideas there but if our web app is immutable you know if we have this folder of files that we stick on to our wave ipfs Skynet um how do users keep up to date right we have this crazy URL that is not very readable well let's take a look at an example here we have our friendly user and that user really likes this website that has daily builds um and they they use the decentralized web they're they're good um and so when they release Tuesday's build it has a Skylink like that and our user grabs that Skylink and is happy using Tuesday's build um they've been using it all the time but tomorrow rolls around and the developers uh roll out Wednesday's build they shipped their dark mode update and um you know our user doesn't have any way of knowing what that new Skylink is or is going to be it's a cryptographic thing it's unpredictable everything else and so we have to introduce ways to you know fix this issue and for Skynet this looks like resolver Skylinks in ipfs they have ipns but what this does is let you have a mutable constant URL that you can just then point and up make those updates when you sign some sort of certain proof that you are the owner of this piece and so what this looks like on Tuesday is that our user has the resolver Skylink and is getting Tuesday's billed and what this looks like on Wednesday is the user still accessing the build through the exact same URL this resolver Skylink and never had to worry about the immutability of of the core underlying data and then in actuality like you know this is kind of ugly and terrible right this is not very usable and so what most developers will do is add in a human readable name and so this is going to use DNS like traditional DNS ens or hns to give us something like dailybuilds.com dailybuilds.eath those will have records pointing to the resolver Skylink and then again you know the resolver Skylink probably is part of like a GitHub action when a new build gets created and deployed will automatically update to point to the latest build all right and again I'm using Skynet here but uh all the other ecosystems I think have kind of comparable things all right so this is how easy it is to get a decentralized front end uh but then you know the next question is is decentralized hosting enough here um if a user is still just going to like app.uniswap.org which is hosted an ipfs that's great for censorship resistance uh it's great that it's decentralized and hosted that way but that still doesn't answer that question of the front-end attack and I want to kind of look at that a little bit in our diagram here so returning to the diagram let's assume you know Thursday comes along and a bad build makes it through you know the developers have gone Rogue there's malware everywhere uh worst of all dark mode has been removed from the application what we have is a situation where our automated deployment is still just going to go ahead and automatically point to that and our user when going to dailybuilds.com is going to still in a decentralized way access this malicious build and unfortunately because the user's so accustomed to accessing the website through the dot com.east domains they have no history or recollection of the underlying immutable data that's still available but they just don't know how to access it and so you know for this reason um we've really started seeing a problem where it seems like we need to not only decentralize our front ends but also our upgrades for users need to be voluntary and aversion history kind of needs to be accessible um and you know home screen is entered the chat this is the project that we've been working on we released home screen at the beginning of this hackathon um and what it is is a decentralized application where users are able to log in with fully decentralized identity and access their favorite decentralized apps these are versioned builds of web apps they're fully controlled by the user and when they pin these to their own personal cloud it you know gets all the assets all of the code and stores it there so they always have access to these apps and then they can also upgrade downgrade share the apps with friends at any time um so I just want to like quickly show a little bit of what it's like to interact with home screen here I can go to homescreen.hns.scienceky.net and it tells me that web3 needs decentralized front ends great I'm going to go ahead and authenticate with my sky and this is what I was talking about earlier are decentralized identity and we can sign up I'll get a new passphrase this is never communicated to any server or anything but I'm able to use that passphrase across device anywhere to access my personal cloud and so we're sitting here interacting with the mutable data layer of Skynet and I can add you know apps whenever I want so let's say I want to go and add uniswap.east I told you earlier this is hosted on ipfs we have ipfs support here oh my God the live demo gets me um okay let's try app.uniswap.org let's see if that one will work all right cool also hosted on ipfs it finds the ipfs link uploads that to Skynet and now I'm able to pin that dap to Skynet and have it always accessible for myself um okay so and we can also kind of like look at the details here you know it's going to pull down our name our description and some other details and now when I go to click on uniswap I have a build of uniswap gear okay I talked to you earlier about resolver Skylinks and how those things can update um and you know I don't have updates available for uniswap because if they host on ipfs but we do have updates available for Sky send and so I love Sky send I'm using it I want to check for updates I can do so here it'll go it'll find that we now have a new Skylink a new immutable file the resolver Skylink is pointing somewhere else the the dev team is signed off on this version and I can then pin it it's then stored on Skynet and then I will add it to my personal metadata here and I can access this new version of Sky send instantaneously if I don't like this new version I'm also always free to go view the details come in and I can say better version and downgrade to my older Skylink that I had before and that way that will always be my default when I come and click this here okay so if you've worked with decentralized storage before maybe some of this isn't new but also just like pay attention to how fast this is going we were interacting with mutable data and it's performance um yeah it feels good if you're a developer and this is interesting to you I really encourage you to look at what it takes to integrate with home screen foreign let's get this full screen again so for integrating with home screen there's kind of three main steps you're going to have to get an app that deploys on Skynet uh you'll want to set up automated deployments using something like our GitHub action which I can show a little bit of later and you'll want to add a home screen button and a reference to that apps resolver Skylink so that users can easily find this and add it to their home screen so you can follow along any of this at docs.net Integrations slash home screen and you'll also find a link there to the video that I did earlier for ethonline that uh you know I actually do this as Live code and about 20 minutes to set up a home screen integration so we already deployed an app to Skynet you know obviously When You're Building Code you're not going to want to go drag and drop a file every single time but just to kind of again say any directory with an index.html file is going to be supported as a web app and then if you use kind of our deployment tooling you have additional Gatsby and react router support that you can get working in terms of automating those deployments um like I had mentioned we have a GitHub action which lets us build and upload our you know build directories straight to Skynet whenever we push a new PR and we can also set a secret in there so that we can sign that code and update that resolver Skylink every single time one of those new builds deploys um and you know the resolver Skylink is very nice because then we can also Point ens names or h s names or traditional domain names at that resolver Skylink and we know that we have this kind of like fully automated deployment system and at no point do we ever really have to interact with a traditional hosting provider and then again step three here is going to be adding the add to home screen button and our resolver Sky link and so like I kind of showed before when we're interacting with home screen you can go ahead and actually type in things like we're still tweaking the ux for the user side of things but you can also find repos uh where an add to home screen button has been added and so you know I've worked with some kind of like unofficial builds here where I've made a repo for say balancer um and it now has an add to home screen button that has the resolver sky link that gets built every time something gets pushed to main so I have a GitHub action that deploys to Skynet and when that happens there's a step here that you can copy and paste from our documentation to get things automatically deploying to Skynet so when I click on this add to home screen button I'm able to be taken to home screen instantly asked if I want to add this app to my home screen and we can see all the metadata that the developers provided including the resolver Skylink where it's going to be updated and of course I can open up balancer here in the next Tab and get going with decentralized storage and decentralized trading okay so um yeah one last little shell here there's a 10 000 coin prize pool 2000 Cyclone for the best hack using home screen and so look into it if you are a last minute hacker still having to figure out how to get your front end live and on the internet we have a lot of Skynet resources if you want to learn more support.scisguy.net is kind of our intro guide but we also have developer guides available at docs.net along with SDK stuff for JavaScript and sdks available and quite a handful of languages if you're interested in joining the Skynet Community it's a good one we have a Discord at discord.gg skynetlabs and it is full of developers that have built with Skynet and are super generous with their knowledge so come say hello tell us what you're interested in building and I'm sure some folks will help you get started thanks again for hearing my appeal for the web 3 needing decentralized front ends and I'd love to answer some questions from the chat thanks Daniel this was great I think we have a couple minutes I I think the set of questions or follow-ups here are maybe just understanding where this what does this evolve to like hosting static content is great but not okay there's a lot more complex use cases of front-end applications how are you going to think about the evolution of home screen or just kind of if you can share some things that will be possible in the future or or in the works right now yeah and so um I kind of glossed over all of our mutable data structures like we have a good handful and my sky is a big one that we're um kind of aggressively developing on the back end where users have totally user provisioned storage space that when they log in with my sky in different applications those applications can request permissions to other application storage so you can build a social graph on application a and just import it natively into application b as though it were an API even though it's a piece of storage that you locally own um and beyond that probably a few more months out um we are working towards monetization and so if you have content that you've put up on as part of your my sky identity and people want to help support you or consume that content we want to have a more Equitable way for Content creators to get paid for for their data amazing um and uh I know the answer but I'll ask this for the sake of others also knowing this is kind of free um yes and no so you know like if free to use it's freemium um similar you know to like web3. storage if you use sciasky.net you get I think 10 gigabytes if you don't give us your email if you give us an email address or later on just sign up with my sky you'll get 100 gigabytes um and then you can pay in Fiat beyond that at this point but the whole storage stack or the whole portal stack is totally open source so if you don't trust us you don't like us please please run a community portal we love Community portals um and you don't have to rely on us at all and uh just so we have some clarity on the the limitations when you say 10 or 100 gigs is that storage or bandwidth and how does bandwidth work if it's not that is storage bandwidth is actually kind of like um on the consumer not on the original uploader or provider so once something's kind of on Skynet anyone can pin that and so there's no like single owner anymore um and so you know right now the bandwidth is just kind of like part of the system and the portals eat that cost um you know maybe other portals will need to to throttle that or something else but we have kind of some of those things in place but nothing that if you're not on a very impressive connection you'll probably ever notice so amazing well hopefully Venture that was good uh enough for for your question to uh to be answered and then I want to thank all thank you again for doing this amazing presentation and making a lot of demo work thanks so much it was a lot of fun and with that we are ready for our next talk and up next is Patricio and Patricia's going to be talking about hard hats present and future super excited to see what he has to share and announce there welcome okay thanks Karthik for the introduction so let me just set this up [Music] okay can you see my screen yep right okay thanks everyone do we somewhere uh watching at this presentation so I'm Patricio co-founder and CTO of Nami glass and you probably know us from our product our development tool called hard hat in this presentation I'm gonna talk about how haircut Works internally and its future so first a quick recap of about welder Harris in ethereum development environment which is composed by two major components one is hard Hub Runner and the other one is Hurricane Network is a task Runner that lets you automate all the common tasks that you have to do while developing ethereum applications there are similar tools to Hardware runner in every development ecosystem or platform for example webpack and parcel are some of the most common ones when doing web development or Gradle when doing Android development and actually had money has been heavily inspired by this by default her had Runner comes with a set of predefined tasks that they will do things like compiling your contracts testing them deploying them things like that but there's also a rich ecosystem of clients that let you integrate other tools add features or new tasks to have hard running or customize the existing ones how can network is our development ethereum Network uh and what this means is that it simulates in ethereum network just like many robsten or Coban where it's totally local instead of having many nodes communicating with each other you can think of Kafka Network as a single node a female ethereum Network when you run hacker Runner just like running your tests a new instance of harken network gets initialized your your smart contacts are run within hurricane Network and then after your tests passed or failed this instance of hacker Network gets destroyed and in this presentation we are going to focus on how hurricane network works the challenges of building and maintaining it and how it's going to evolve in the future so first how does carhead Network work how can network is a node.js module that it's embedded into her Runner and exposes the same Json RPC interface that a real ethereum network ethereum node does this means that we kind of Lie to the different libraries and applications that integrate with tracker Network and pretend to be a real node but instead instead do everything locally within no CS so for example when you connect metamask or wallet to hacker Network it doesn't need to know that it's dealing with hard hat instead it just acts as as if it were working with ethereum mainnet the same happens with with three or ethers or any other library or application this gave us the advantage of being able to integrate with everything quite easily so instead of communicating things to a network network resolves everything locally and what this means is that if you send a transaction we don't forward it to a network of different nodes but just create a local blog in our own blockchain and keep it for us we don't forward those blocks either you know communicate with anyone else um to do this we use ethereum ESPN which is a typescript evm implementation and it lets us execute everything locally but what made hacker Network different or special is not being able to simulate the network but rather that we always look or try to provide as much context and information about what's going on within your smart contracts because that's what let's let's sorry the developers debug and test their smart contracts and be more effective on building them and this is where automation challenges appear and the way this works is by relying on random observation and this is because in ethereum as we all know you have to pay for gas when you try to execute something and in particular the person paying for that gas is the final user so keeping the amount of gas that you pay to a minimum is super important because it makes your application more or less competitive and this leads to many things but in particular one of them is Association rate in a minimal amount of [Music] when compiling your smart contracts instead of embedding functionality to help you debug your smart contracts or head tools do that it has to operate a very minimal uh by code without any kind of random support so that the amount of gas that the final users are gonna pay when running that smart context is slower so things like for example generating stock prices are not part of the program but brother left to the tooling in contrast in other in other development platforms this will be embedded within the actual binary which makes things easier because the compiler has the whole controller information and to be able to do this effectively now the way we approach this is instead by as I mentioned random observation but what does that mean it means that when we execute anything within Harker Network we trace this execution and by tracing here I mean collecting information or the history of what went what went through when executing the the contract at the ABM and this Trace you can think of it as a sequence of pvmo codes or operations that have been run during the execution of a Vivian smart contract and well this is very useful at that level it isn't very approachable because you have to be very deep into the AVM to be able to understand that understand things at that level but instead what we do is take that evm and very low level representation of the execution of your contract and try to recreate more friendly information for the user for example this is how we Implement console log when we take a trace of the ABM we recognize certain patterns that mean that someone tried to call to the console log library of function and when we do when we detect that we decode the goals argument and bring them to the console or to the terminal of the user and this is in general the approach that you have to take if you are willing to will advance a tooling for ethereum another thing that we do is generating stack prices and in this case it's it's similar like we take the trace an evm Trace but also fetch the compiler circle that has a lot of information about your contracts and combine those uh to recreate a code stack in solidity which means that we know when a function was called or a return from a function was executed uh but this is not always complete or perfect because there are certain ways that a contact can fail or certain Paths of execution which are not actually reflected or come from your code but rather from internal solidity functionality or how to generated code and that information is not very useful for the final user or developer and this is this is particularly true for all the versions of solidity so what we do is relying on a set of characteristics that we read through time to improve this information and give richer things to the user like how to generated error messages when you send for example when you send a transaction to a contract and the function that you are trying to invoke doesn't exist in that contact we can detect that and clear and give a clear error message explaining what we did while depending on the version of solidity and your settings without these sets this set of heuristics all you would have got is a a revert without recent Network message and this is in fact a ton of worked with and has some limitations that I'm gonna explore next uh the first one is that relaying heuristics is extremely flat fragile they are built super ad hook for every version of solidity in fact the way that we build them is by looking at hand itself TV and prices and and after some time you start recognizing but to recognize patterns between them and then encoding those patterns within Hardware Network so we can kind of translate our intuitive uh like pattern matching that we do when looking at these civilian traces and encode it as JavaScript code within Kraken Network but the problem is that as they are super at Hope they are fragile because whenever a new version of solidity comes out they can break because maybe solidity change something that broke our pattern it doesn't repeat anymore and the change may make sense it's not their responsibility for our heuristics to be stay away through time but the problem with that is that nothing guarantees us that we will be able to fix them or that we will be able to create new ones if we need them for a particular feature and they're building with them is that they are another we saturate because these characteristics and for the ones in the audience that don't know what that means it's you can think of them as fussy matching things in this context at least they are like pattern recognition logic but not very precise and the way the reason that they are not very precise is because they can't be too precise or we are going to have a lot of voice negatives and they can be to lose because otherwise we are going to have voice positives but we'll never be able to be 100 accurate because the compiler doesn't give us the precise information to do that another problem with this approach is that the tooling that does this is always getting more and more complex the reason for this is that solidity versions tend to stick forever within the ecosystem let's suppose that you build the contact now you probably are gonna usually the zero weight 4085 something about those lines and tomorrow's zero point and you finish your contact you deploy it and tomorrow 0.9 comes out and has some cool features that led us tool developers improve your development experience the chances of you rebuilding I mean voting rebuilding and really deploying your contact just to get very tooling are very low because that's gonna cost a lot of money at least for Audits and also it's gonna take a huge coordination effort and the by the advantages for you may be huge uh it's not a it's not great for the community they won't get a lot of advantages so that's not going to happen but even if you are building with the latest version of solid chances are that you are interacting with a contract that was deployed using another version of solidity and you still want to understand what what and why things go wrong while you are testing your contacts or dividing them so that means that we still need to support every version of solidity probably forever another disadvantage is that creating these tools is very expensive and complex and these leads to two things the first one is that there are fewer tools than maybe there would be if these were cheaper and the other disadvantage is that you get very inconsistent features across the different tools for example if you want to use console log today there's only a few tools that support it like haircut if you want to step the wire there is just a few that have it that have them if you want to use a good integrative fasting system there is just a few of them and the problem with this is not that we want to have every feature that everyone has but that these are very basic features that in other development development platforms are given and they should be given for every tool in ethereum but they are not and that's something that we we are aiming to improve instead I think tooling should be a different tools should be differentiating themselves with more specific functionality instead of the basics and the way that we are planning to tackle these problems is with two new projects that for now we call slang and refnet slang is a neutrality compiler that it's gonna be built especially for tooling and right now this library that provides a development network with all these rich functionality that has so as I just mentioned resnet is going to be a library for other tools to build on top wrestling wouldn't be a replacement for hacker Network within hardcat but instead it's gonna be its new core and the interface of hurricane network will still be the same it's being built as a platform as a runtime observation engine that we let Harker Network be more stable faster and mature but also we LED other tools get the same functionality for free and it's written in brust so it can be run everywhere and distribute as a just as a normal Library like a C library and also it's gonna be um compilable to awesome so that it can be used in a browser and things like premix or ethereum Studio can get all these features for free it's gonna provide all the functionality that character network has out of the world and instead of relying in heuristics it's gonna depend on slang's output to have an accurate understanding of solidity of what's going on everywhere so we are going to be able to be precise one all the things that we do but we'll also be able to do more stuff because we are going to be we are going to have the information to do those things and once the basic functionality is mature and we have the common base for a development Network we are going to work on more advanced tools the more advanced features that have enabled doesn't provide today like a steady wire the gas profiler called coverage analysis and more slang slang is a solidity compiler as I mentioned that it's gonna be focused on developer tools this means that we won't be competing with soci but instead we will be focusing the on development time of your smart contacts but but like orienting the compiler to be able to integrate with other tools and provide all the information that those needs but building a compiler is a huge Challenge and we think that should see that's a good job on building a compiler it's good to for running yours my contacts on mainit and we pretend to keep using it for that so hard hat and other tools that want to use slang will build both with slang and so C and use each of those builds for different things and of course deploying with the soil CBD slang is also going to have an integrated language server which is a service that let's text editors and ideas integrate with the compiler to gather like features that advanced editors have to support the language for free things like some to definition refactors shunt references things like that kind of require a compiler to be with or at least part of the compiler and we think that having them integrated within the compiler is a way to have them to tweele them reliably and keeping them up to date with the evolution of the language so we are also providing that out of the box it's also going to have apis for different tools to be building built on top exposing the bars there or the type check system uh and those things are going to allow things like reliable fast and up-to-date linked formatters and other things and one of the key things of slang as I mentioned is that it's crashing rate of the metadata that when resnet requires not only to be able to avoid relying on heuristics but also to uh let us iterate resnet faster so if we want to do anything that is not possible with breathnet we can just tweak slang read and generate more metadata and the the good thing here is that as we are not gonna be deploying this Mark on this bytecode generated by compiler compiling these smart contracts we can tweak what will generate so that we can enable everything we want Within resnet but maybe some of you are wondering uh on how reliable are things gonna be if we compile with one compiler during development and with another one when deploying and that would be a great question because if we use different compilers for these things this wouldn't be as reliable as just using sub-c but one of the cool things about ethereum is that it's a completely deterministic and isolated platform or execution environment that lets us do pretty cool things if you have two bits of the same smart contact but that were built with different compilers but both of them like translating solidity to Evie and Michael they should execute and give the same results there's of course gonna be small differences in gas costs and stuff like that but in general the modifications to the ethereum state should be the same if I execute the Neo C20 transfer built in a smart contract build with slang or built with soci then result should be the same uh so we are going to take advantage of this um build resnet in a way that can execute both versions of a smart contact at the same time so instead of relying shaston slang during development we are going to be building with both and executing with both slang and Celsius we are going to trace both of them compare the results and use slang together Rich metadata of the execution and so let's see to commit the changes that that smart contact execution made to the ethereum state and in general this should work great and let us have the best of both of Both Worlds uh reliable test results because they are the results that the salty version of the contract generated and that's going to be the same ones that this contact will generate to maintenance and at the same time we are also going to have as much metadata about the execution as we need [Music] um in the there's of course a chance that these results don't match and this would probably be because some bag or immature aspect of slang but that wouldn't be terrible either because at worst what would happen is that they development experience with the great beat on a certain transaction or smart contact but we'll still be able to rely on our test results so we won't be compromising on correctness or security of our smart context so the current status of these projects is different for each of them rested is already under developing it's being built from the inside out of Harker Network we are going to replace one module at the time and ship them as part of hurricane Network probably will ship both at the same time initially and do something similar to what I already mentioned of executing two things either cyan comparing results to ensure the correctness of redneck before shipping it to production and slang is not being developed yet we are building a team of compiler experts and doing some research and planning around it but both should ship within the next year and we'll be shipped initially as part of Karkat and I stay mature they will be exported as libraries and independent tools for other libraries and tools to to be able to rely on them and get a list functionality for free uh and finally our goal here for both for rain have resonate and slang is for them to weaken the building blocks of the dueling of ethereum like oil Dimension tooling uh and the like our objective is to for to to lower the cost that I mentioned uh of building new tools and maintaining existing ones so that this leads to newer more mature tools for ethereum ecosystem for the clearing ecosystem and eventually for all of its users and Protocols are built on top of it um finally if anything of this looks interesting to you we are hiding both for redneck and slang also for hardcat and other projects that I didn't mention here so feel free to go to this link namiklabs.io Skyrim and take a look at our shop listings there and if you have any questions you can send our Discord which is in our website haircut.org and that's all awesome um Patricia that was a greater View and uh I mean that's such a massive overtaking that you're gonna go into over the next few years um you talked to a lot of this is still in the works and especially for for slime um my only kind of question is how do you think about that um especially when solidity itself is also evolving in parallel um what are some kind of things that you are thinking uh that should be kept in mind and how do you kind of match the direction and the speed of the vvm ecosystem evolving yes I think that's that's a good question uh especially about solidity still evolving I think that that's uh like a common fact for every language as the it's going to be it's gonna evolve fast and tools are gonna struggle to keep up with it and we are already struggling to keep up with it and these projects were made massive are gonna make keeping up with it much easier for us another tools uh but also as the ecosystem matures and gets bigger and has more tools and more stakeholders depending on solidity I guess the natural progression is for the evolution of the language to split apart from the evolution of the compiler and have some kind of governance over the language but that's still to be defined in the future absolutely um obviously finding this out in real time with everybody else is the challenge yeah yeah anybody to know what what uh this look like but uh this is great um I think you already talked about how people can get involved so check out rat.org and if you're interested in being part of this feature um so thanks again Patricio this is great thank you I wish you all the best and can't wait to use flying in Redman awesome thank you Karthik bye see you and next up we have Gilbert and this is a very interesting top that I'm most super excited about Gilbert is going to be talking about how do you actually write my contracts without solidity we're going to go into some internals about how all this works under the hood and without further Ado let's welcome Gilbert I'll ask you uh to turn your camera on and we're good to go [Music] all right thanks a lot let me share my screen real quick perfect all right hello everyone my name is Gilbert I am a smart contract auditor and instructor at optimistic at optimistic we do smart on contract Audits and we also train people how to write smart contracts and then place them but enough about me let's talk about smart contracts without solidity so we're going to go over several things in this talk first we're going to go over why should you learn Evian op codes as a smart contract developer uh we're going to go over how to deploy a smart contract or in other words how to write op codes for deploying a smart contract without solidity we're going to take a quick look at a little new language called trim and then we're going to Implement a full smart contract using these op codes so first why learn ebm opcodes well essentially you want to become a better solidity engineer what does that mean if you know opcodes then you are better prepared for low-level hacks and issues solidarities compiler has had problems in the past if you understand opcodes you'll better understand why those things happen second you want to have a deeper understanding of common design patterns especially related to proxies proxies use hopcodes all the time that are not available normally in solidity and it's great to have a internalized understanding of how smart contracts actually run when you're making transactions to these contracts foreign we're going to look at what I call basm which is bear assembly and basically what this is is we want to be able to write these op codes without writing the Raw bytecode so on the left you have the byte code on the right we have basm so we definitely want to write what's on the right so that we don't have to well I mean it's it's pretty straightforward you don't want to write what's on the left and um yeah this is this is pretty much all it is there's pretty much no features in this language all it does is that it takes your op codes and then converts it into its respective byte codes and puts it all together so let's use this to actually write some code so for the first contract that we're going to look at we are going to deploy a contract and it's going to be a very simple contract there's not going to be any functions in this contract all that's going to do is whatever transaction that's made to this contract it's just going to return the number nine uh just blindly doesn't even care doesn't care about what function you're trying to call it doesn't care about your arguments it'll just return the number nine so as you probably know when you deploy a smart contract you deploy the code of that smart contract but also some additional initial initialization by code so here we have some init by code and the way that it works is that the byte code that you use to deploy needs to return the runtime bytecode so in other words in this example the init by code we have here the goal of this init by code it can do other stuff but ultimately it needs to return the data that represents the byte code down there so when we make a deployed transaction the runtime by code is not going to run at all only the initial by code runs just because of the way we wrote it and then it will return it so let's looked a little bit at the details of how this works so first we have a code copy and this copies into memory a piece of the entire by code that you're running and your create smart contract transaction so the first argument um here what I have here is um evm is a stack based language so all this code that you see on the left is pushing onto a stack and then when you run code copy it just pops off the top three items in the stack to do whatever it needs to do so on the right hand side we just have a a syntax that's a little bit more readable for those who are not that familiar with topgoods so this code copy takes three arguments and the first one is where you're going to copy two when you do code copy you are copying your byte code data into memory so zero just says stick it into this spot and as you can see um this is going to copy some code and we're going to see exactly which code is copying the second argument is the offset of your contract by code so this we hard code 0x0c because it's 13 bytes before getting to that point so that second half is our runtime code we want to start there when we do the copy then lastly if we tell it how many bytes to copy so last over here we have 10 bytes because our runtime code is 10 bytes so that will copy 10 bytes into our memory slot which is at 0x0. now that it's in memory we can use the return by code or the return opcode to return it and return takes two parameters first one is the memory offset we just wrote to 0x0 so we want to start returning data from that point and then secondly the length which is again 10 because there's 10 bytes of memory that we need to return and that's pretty much it so this memory or this data that we're returning the green box this is the code that the evm will take and store at your new contract address now whenever anyone makes any sort of transaction to your contract address it's going to be running that specific by code which again is the green box so this works but there's a problem we are hard coding some bytes and when you're writing code you definitely do not want to be manually Counting bytes so that you can um just get it to run adding one line of code will cause these values to be wrong and that's really bad so that is the motivation behind the language trip so trim is a little language that I wrote um in a few days and the idea is just to have a mostly purely syntax transformation so that you can write your code in a little nicer manner you're still dealing with OP codes with trim there's not any fancy function calls or Stacks or memory management it's almost purely syntactical so instead of writing what you see on the left which is the code we just saw you can optionally write the thing on the right basically the rule is anytime you have a parenthesis now you're in s expression land and you can reverse the order of your arguments and it'll just translate it back to the left so that's pretty straightforward if you don't have parentheses then you're still in opcode land for example the stop on the right that is just a plain opcode feature number two is labels labels is how we solve the problem of manually Counting bytes so on the left we have zero C and zero a these are hard-coded values based on the length of our code now on the right we can write this hashtag runtime and that just represents a location in your code so the last runtime on the right that is the actual label and then when you reference runtime within an S expression it will fill in that location for you so this is a way to get around manually counting bytes the first line we subtract the total code size with the position of runtime and that'll give us our runtime code size and we dupe it so that we can use twice and then we code copy from zero to the runtime position with that length and return the links so that's pretty handy and the last feature which with trim is instead of manually putting in strings you can just write the string and it will translate it to that push statement for you so again these features are mostly syntactical um it's not going to manage memory for you you're still writing objects okay so lastly we want to look at a example of writing a full contract so here we are going to emulate or we're going to implement a version of this in opcodes so here's the solidity code uh this is a little bit different from the standard greeter contract that you get from generating a new hard hat project the main difference is it uses bytes 32 instead of string and the reason for that is just for teaching purposes string is a lot more complicated than bytes 32 so I avoided that by just using bytes 32 directly the other thing to note about this code is it has initialization so our bytes 32 greeting variable is initialized with hello evm so that's something else that we're going to have to implement as well so let's do it all right so on the left we have our initialization code and it's pretty much the same as what we just saw and two slides ago the only addition we have is the s store we are storing in storage slot zero our string hello EDM and that's pretty much it that's all you need you just need these three op codes One op code for s store one off code for push zero and another op code for pushing the string value and then that's your initialization that because it's initialization code it's not going to make it into your runtime code which is good now on the right hand side we have a reference for API encoded function calls of greets this is a function ID for Crete and then on SEC reading that does have an argument so you have the function ID plus the value of that bytes 32. um and that's what that looks like so we're gonna we're gonna be using that or referencing it when rewrite the code to uh access that all right so we just omit the net code for the slideshow to make more room the first thing we want to do is copy the function ID onto the stack and this is the transaction data so on the right um this reference I didn't mention it's the data that you send with the transaction so if you're making a transaction to our contract um most of the time you're going to be encoding your data using Avi and that's what we see on the right hand side so if they're calling greet then it's going to look like that so I can use my mouse can I if they're calling greet then it's going to look like this right here if they're calling SEC reading with this parameter it's going to look like that in either case we need to handle different functions in our contract and the conventional way to do that is by using an API encoded function ID so we need to see if the first four bytes of our transaction data or our call data is either this here or if it's this here and based on that we're going to run different code so that's what this first one does call data copy will read data from your call data and the offset o4 is the length that you're reading oh zero is the starting point and one C here this is the the position in memory that you're writing to or you're copying to um so zero we want to start at the beginning obviously because the function ID is the first part of your code data four we want to read four bytes four bytes is eight hex characters um so that we read the function ID and nothing else and then this is actually 28. because this just makes it easier to deal with call data copy we want to write it as a un256 which is 32 bytes but we're only writing four bytes if we don't we're just doing this so that we can slot it into a very specific spot in memory to make things easier and then here we are loading from memory position zero and M load will load 32 bytes so it will catch the data that we just wrote after that we want to see if it matches um a no function ID and the reason we do that is because we're going to have we're using trim now we're going to have two different labels one label for our Greek code and one label for our set greeting code so this here this is um pushing a known function ID onto the sack and then it's duplicating the input function ID and if they match then it's going to jump to that label so EQ will take the top two items of the stack and if it's true it'll push a one if it's false it'll push a zero and jump high but only jump if the top of the stack is not zero so in other words if this matches the call data's function ID then it's going to jump to greet and we're going to do the same thing for stack reading so if this does not match then jump ID or sorry then jump I will not jump and then we'll move on to the next one and then we're going to check well does our input match this function ID and if it does then we jump to set reading otherwise we revert but this this logic here this is how solidity gets compiled down obviously solidity compiles into more bytecode than this with some extra features but this is essentially how it works it's basically a case statement does the function ID match this go here does it match this go here and that's it so now let's get into writing the actual code for these functions it's a convention to have a jump destination op code for places you expect to be jumped to it actually doesn't do anything but I guess it makes the code a little nicer to read foreign the only thing we need to do for gree is we need to load the current greeting so first we load um the storage at position zero and then we store that into memory because we need to return from memory and then we return it so in other words we're loading from Storage into memory the current greeting and then we're returning that value and that's the entirety of our grief function suck reading is pretty similar in fact it's even simpler call data load will load again 32 bytes from your call data and here four is the offset so we are skipping four bytes because we want to skip the function ID and then the next 32 bytes we know is our parameter so we load that onto the stack that comma should be there that's a typo but we load the string onto the stack and restore that into storage slot zero and that updates the storage and that's the entirety of the set grading function then we here we have a stop because just in case later we want to add more functions we don't want to accidentally run over you know the the normal problem which which statements you just kind of go over your case so that's what's up it's done that's what stop is doing there um so yeah that's the that's the entirety of the contract but how do we do so if you compile this in solidity you end up with 404 bytes and the code that we just wrote is only 76 bytes so that's pretty cool um of course this is uh not without its trade-offs we are not checking call data links for example solidity checks call data links by default that avoids for example accidentally setting an owner address to zero without providing a zero without providing an address and some other stuff solidity also makes sure that all your functions are not payable by default which means that it generates bytecode to revert if the transaction has either value in it it does that for for all functions unless you specify payable so there's trade-offs there but it's pretty cool we can write some op codes and we can be how many times is this like four times smaller than the default solidity by code generation uh but yeah so hopefully that gives you a good taste of how to write smart contracts with out solidity with plain old op codes we use trim as a language just to make things a little bit easier to read and write But ultimately it's still just op codes so learning this stuff will make you a better engineer it will help you internalize how things work at the low level lowest level at the EDM and um opcodes are just good to know in general because things like proxies and static calls those are all using op codes that are not available in normal solidity code and lastly um we teach smart contract engineering and security and optimistic so if you or anyone else is interested in becoming a smart contract engineer we take mostly senior Engineers we only make exceptions for special cases uh but yeah if you're interested then visit our website and contact us awesome uh thank you Gilbert a couple quick questions where can people learn about trim um and could you uh talk a little bit more about some resources to sort of play with it or debug things and just how people should think about trying it out when they're doing the MapQuest directly yes so um preparing for this was a little bit rushed I'll be honest um trim is not published yet but it will be soon and we also have a really cool um in browser tool for kind of writing trim and it just automatically runs your code as you type it and it shows you the results it shows you your memory it shows you your stack usage uh your gas usage and all of that um yeah if you're interested in knowing when it does get released uh just shoot us an email and optimistic and I'll put you on a list um wonderful well thank you so much for that amazing demo and presentation and can't wait to see uh how to play with trim thank you very much great and uh with that we are ready for our last Talk of the day um up next we have Kelvin and kelvin's going to be talking about smok and uh hola come introduce what's mock is but uh I'm already excited about the top title and I'm also glad that Calvin used a 2007 plus version of Microsoft Word instead of the original 2003 so without further Ado let's welcome Kelvin there we go let's give you a turn video on and you can get started Kelvin all right all right um cool fantastic so let me share my screen where is this okay sharing perfect let me make sure I can see the comments just in case great alrighty so hello hello uh I'm Kelvin and today I'm going to present to you Smock Smock is a tool that uh well it's the solidity mocking library and it's a tool that we originally built over at optimism last year to sort of simplify our smart contract development process and today we've sort of uh We've revolved and we've created a V2 in collaboration with D5 Wonderland and we would like to present it to you and hopefully see if you can get something out of it uh these are let me make sure these are actually showing up where are we there we go got the Twitter handle for optimism got the Twitter handle for uh D5 Wonderland and you've got my Twitter handle so first things first I want to set the scene I want to set the scene for you and for why you need smok in your life this is you you are a smart contract developer you are a very smart smart smart smart contract developer uh you are a big brain gigantic Brand Smart contract developer and as such you sit on your very expensive uh very powerful uh you know 2013 MacBook Pro and you spit out smart contracts Into The Ether now spitting out smart contracts into the ether is a very dangerous activity you need to be very careful when you do this but you are a big Brand Smart contract developer you know that what you need is you need well-tested smart contracts so let's talk about testing how do people usually test their smart contracts well they might do a little bit of this you know they do some JavaScript and they might do some calls and some assertions and I might do a little bit of this and some calls and some assertions and then they sit there and they they put a little check box on their contract and they say oh it's safe it's perfect it's beautiful but um but as you can see this is a very this is a single small brain spark contract but you you as the legitimate defy developer you don't you don't build these smart small smart contracts you build real smart contracts you are a big Marine default developer and you only build the biggest of brain contracts right so when your smart contract systems start to get bigger and start to get a little more complicated it gets harder to effectively test your contracts so you need to evolve with it and you need to become a big brain defy contract smart contract tester so how does this work how does Smock make your life easier well let's first talk about what smok is through an example I'm going to talk about a very specific example of house mock functions and why it might be useful and sort of get you if get you to sort of uh to bring back dark memories from your past about difficulties that you might have had while trying to test smart contracts because I've definitely had these dark memories blocked deep in my brain smart solidity Smock is the solidity mocking Library the facility Library there is no better it allows you to write better tests that is a key feature of smile why do you need it let's talk examples this is you this is your big brain uh testing creature and you're gonna you're gonna write some smart contracts you're gonna start with writing a small smart contract and then you might write a big smart contract and you want to test how these things work you want to test them individually you want to test how they work together you know you throw out words without unit testing and smoke testing and integration testing and whatever all these different testing things but ultimately you want to make sure that your system works or people might lose money which is a big problem so let's throw an example on this let's uh let's specifically let's talk about something reasonably complicated we're going to talk about a Merkel airdrop do you know what a Mercury drop is it doesn't make a difference the point is something reasonably complicated that people can kind of comprehend right so let's say we have a Merkel air drop and then we have a recipient of a Merkle air drop right so how would you go about testing the burglary or drop contract well you might do some stuff like you might you might you know you have to create a Merkel tree and you're going to have to Hash a bunch of stuff and you're gonna have to deploy the contract and then you're going to have to publish the Merkel rude and you're going to have to you know test if you have a balance and all this right so it's a ton of effort but you need to do that in order to add to effectively unit test your smart contract but how are you going to test another contract that interacts with your Merkel airdrop contract how are you going to do that because you want this right this is the ideal end result the ideal end result is that your your recipients get their money and they can go off and do stuff and they can spend it on yams or whatever they want to spend it on and you don't want this right you don't want the airdrop to just fall on the floor because no one can get their money and you just whatever it's a whole headache right so how are you going to test this well let's talk about let's talk about this other this other character right this other airdrop recipient think about how you might test this airdrop recipient well the air yeah there's the airdrop recipient the answer to this question is basically for most people if you think about it you'd have to basically perform the entire testing process that you already performed for the first contract right in order to test if this person is going to get a balance you have to go and you have to create this Merkel airdrop contract and you got to go and and set it up right you got to do this you gotta load the whole contract you got to deploy it you got to do all this setup right this is a huge headache so how do developers actually do this in practice how have they been doing this they've been writing these fixtures right all these fixtures and then you get fixtures inside of your fixtures and then you get fixtures inside of those fixtures and it keeps going until at the very bottom there's a Bose Einstein condensate of fixtures and it all matter is just fixtures this is bad what you really want is you want smock so how does smok fix your problem Smock means you don't need to load anything Smock means you don't have to do all of this junk setup that you are on all this this uh fixture code that just completely pollutes the code base and you can just get straight to the airdrop straight to the airdrop and how you do that through the power of mocking we love mocking mocking is a beautiful thing so let's talk about it let's talk about how this tool actually works now you have a scenario you want to test it you want to test a contract that interacts with a much more complex contract but you don't want to set up the entire complex contract because that's a huge headache so how does this actually work how are we going to make this well smart gives you two primary tools gives you fakes and it gives you mocks so first we're going to talk about fix is what it looks like to create a fake wits mock so you can see here hopefully people can see my little uh Mouse if you can't you can see here that we are going to import Smock and D5 Wonderland smart D5 Wonderland is where we're hosting the uh the npm package where we're hosting this you get it and uh then it's straight really straightforward this is a hard hat plug-in so you get this beautiful syntax where I can just say Smock dot fake and then the name of the contract and now I have a fully fledged fake version of my contract that contract doesn't have any real code but it has a real address and if you make calls to that contract address you are actually going to get back Real Results so for instance I can make let's say this fake has a function called bark and I tell Bart to return woof if my smart contract calls that fake contract it says you know fedcontract.bark or whatever you know contract.part it's actually going to return woof when you run the tests in the evm so it hooks into the to the evm in hard hat the hard hat ebm at a low level and so it really simulates that there's a smart contract there and you can make it do whatever you want you can even do these beautiful assertions this nice syntax if you use these Smock matchers you get this nice syntax and even make assertions that your moth is called with a specific input data so this basically just removes all of the need to do all this setup right I don't need to set up my uh my Merkel airdrop anymore I just create a fake version of the Merkle airdrop and I just give myself a balance in it I just say the balance of me returns however much I want crazy so the docs are at smock.readthedocs.io and inside those docks you're going to find some really cool things as to what you can do with these fakes so pretty straightforward one thing you can just do is have it return default values default values it's all zero so you know if you if it's it's a function it's called get address and it returns an address and you just return like this it's going to return the zero address but you can also make it return fixed values you can make a return you know a given address a specific address or you can make a return a number depending on what the function expects to return um you can also make the function revert this is really useful if you want to test cases where okay this one thing went wrong and you know what I want to make sure that my contract behaves properly but you know think about you you have to do all this weird modification to your smart your other smart contract to to be able to get it to revert and to get into that specific state where it's going to trigger that one specific revert no get rid of all of that it's just going to return the revert message that you expect and you can test the behavior of your contract fantastic you can make it revert with a string you can make a revert with bytes you can make a reverse whatever you want but here's where it gets more interesting you can also make it return more complex structures right so we have support for structs you can make a return structs you can make a return arrays right so you can these are really interesting uh you know data structures Beyond just the basic ones you can even make a return Dynamic values function inside of the return and this function can return whatever you want and can even look at this so it could randomly return one value or the other value I wouldn't recommend doing this in practice but uh you can definitely have a more complex piece of logic inside of this return function this return function could even be asynchronous so you can go call you know you can make an HTTP request inside of a smart contract which is a little insane but only during testing don't try to do this in production it won't do anything because it does that doesn't make any sense but in testing you do whatever you want fantastic and can even use the arguments that were provided to the function inside of the function that you are triggering so for instance if I want if I had a function that took a u in as an input and I wanted to return whatever the input is times 10 I can do that I can just have it take the input to the function and multiply it by 10 and I'm going to get my my output value and it's just going to return what I expected I can literally essentially and I have these beautiful things written in JavaScript that can do whatever they whatever you could possibly imagine to make your testing life easier you no longer need to set up your contracts to be in this very specific state fantastic so Fakes fakes already get you really really far fakes are a beautiful thing but I have to tell you there is something Beyond fakes there's something even more beautiful than fakes and that of course it's mocks mocks are mocks are fantastic and let me tell you a little bit about MOX inside of smock Smock mocks are like fakes but they're backed by a real smart contract so this means that you deploy your smart contract and you essentially have the ability to manipulate your smart contract after it's been deployed which is very it can be very very useful so a basic feature that you have with this this mocking ability is call for right by default when you call your contract it's a normal contract it's a standard solidity smart contract it's going to behave just like the solidity code that you wrote but you can also manipulate it so let's say by default I have an add function and I call count and it's going to return you know 10 whatever right and this is because there's actually solidity code running but then I'm going to say okay okay but for now now I actually want to make count return one and now count returns one easy right beautiful but there's more and now this let's see if this works because I animated this by hand in Powerpoint foreign there we go you can set the value of the variable this is this is where the game changes with mocks you can completely manipulate what's happening inside of your smart contract you can set the value of any variable to whatever you want look at this my variable name is being set to one two three four I can set the owner of my contract so I don't have to do all this you know what if there's a bunch of complex logic that I want to test that's based on an internal variable being something well I don't want to do all the complex logic to get the internal variable to be equal to that value right there's a huge amount of effort that goes into this and you don't need to do that anymore you just say okay well I'm going to test the case where this internal variable is equal to so one two three four and uh I want to see how my contract works when the internal variable is equal to one two three four but there's more you can even set the value of a struct or a mapping you can set the value of whatever you want you can set a value of a nested mapping you can change literally anything inside of your smart contract and make it possible to to test every tiny little interaction without mountains of boilerplate fixture code that somebody's going to have to maintain for the rest time this is how you should be writing your smart contracts and if you're not writing your smart contract test this way you are you are missing out on uh on a deep and uh satisfying tool tell you that this is you this is you after learning about Smock this is this is the entire universe after learning about Smock and uh this is Smock so there you go smock is is all there is the entire world is now just Smock so how do you get started well it's pretty straightforward D5 Wonderland slash mark on npm the code is available github.com g5wonderland slash mock and the doctorates mocked I'll read the docs.io it's quite intuitive the docs are good the code is pretty straightforward it's got a really nice API shout out to the D5 Wonderland team for really cleaning up the API and uh I really recommend that you check it out you try to write a few tests especially for your more complicated smart contracts and get a feeling for just how easy it is to build great tests when you're using smart and of course I'm gonna throw this in there optimism's hiring if you want to you know if you're bored of your web 2 job and you want to work on cool stuff like this um and uh there's the jobs link lever.jobs.lever.com optimism um and that's my talk pretty straightforward pretty short but uh I hope you enjoyed it and very excited to see all the new people who are now going to use Smart forever and always thank you thank you so much Calvin I'm still uh just laughing through all the incredible stuff that you got in this uh the drum rolls killed me um it's really good um one final plug for everybody uh for the sake of everybody following up um what is their URL to learn more about smok the website the GitHub EMP impact here all these things in one-off slides but uh tell us where people can go to use it immediately yes I would recommend starting with looking at the GitHub it's got instructions on how to get started and it's got links to everything you'll need to know so github.com defy Wonderland Smock we'll have everything you need um to get started awesome and uh one last question before we close today is obviously been working on this thing for a year and and there are a lot of people that are using this but what is uh the future of the library look like what are some features or additions or things it's not good at that you want to do just talk to us a little bit more about that um so the thing that I'm most excited for is we're planning a rewrite of the core internal stuff um Smock was originally it uses a very hacky method to do what it does uh it uses the fact that that the ethereum JS VM emits things in events and it turns out that emits objects by reference and so you can you can listen to the event and then manipulate the thing that you receive in the event and it will have an impact on the VM which is really terrible so what we are planning to do is a more comprehensive rewrite which essentially involves a fork of the underlying VM instead and the feature that I'm most excited for is the ability to directly test libraries there's a uh if you if you've ever tried to test libraries you know that the standard pattern is you create these these mock libraries that wrap that wrap those libraries and expose all the functions and you can actually test them and so uh in the plan sort of smock V3 it'll be possible to directly test libraries uh with one of these contracts so you don't need to keep writing this boilerplate mock code for your library and you'll also be able to manipulate internal functions so you can say okay you know my internal function is going to return whatever I want instead of just these external public functions oh that is incredible it's like God Mode for EDM God Mode for ubn cool well thank you so much for that uh incredible presentation we gotta get you back on just so we can see what the next one would look like and I get to top yourself if not at least meet the same expectations but this was great thank you wonderful close to today's adaptable Summit uh thank you for hundreds of you for sticking all the way to the end it's been uh six incredible hours of just back to back that tool showcases and talks so I can't wait for uh the next version of The Summit ourselves all right so in conclusion I got two quick things for everybody first of all for all of you who are hackers watching The Summit uh the submission deadline for your projects is this Sunday so be sure to uh make sure that you do everything before 3 P.M Eastern this about 3 P.M Pacific so 6 PM Eastern this Summit and uh and if you have any questions if any last-minute things that you're stuck on you can ask all of that um all you can ask us for help on the Discord for beef global and just make sure that you're ready for the submission deadline and uh before we close today I want to just remind everybody that our next hackathon will be unicode we are proud to announce that we're doing this event for the union Swap Grants ecosystem and uh this is going to take place at the end of this month so if you're interested in hacking that more V5 stuff and building on top of uniswap protocol check out unicode.if google.com and sign up to to hack for the next hackathon so with that I want to sign off today and uh hope all of you have a great weekend and we'll see you all next Friday for the Eid online finale take care everybody for good evening 