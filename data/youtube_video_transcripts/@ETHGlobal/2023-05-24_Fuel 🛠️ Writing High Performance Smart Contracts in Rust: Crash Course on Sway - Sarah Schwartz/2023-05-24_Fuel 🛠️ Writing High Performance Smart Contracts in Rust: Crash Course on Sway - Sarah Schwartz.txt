foreign [Music] Schwartz and I'm a developer relations engineer at fuel labs and today we're going to do a workshop to walk you through how to build a field stack gap on fuel so really quickly what is fuel fuel is a modular execution layer so that means you can execute on fuel and settle on any other L1 like ethereum and uses the feel VM instead of the evm and it has a utxo model which allows for a parallel transaction execution some quick terminology about fuel when I say fuel I'm referring to the fuel blockchain or Network sway is our rust based domain-specific language that we're going to be writing our smart contract with Fork stands for fuel orchestrator and it's essentially like cargo for rest or npm for node fuel up is the tool chain manager that will install fork and the feel node software on your machine and then fuels is the sdks there's a rest in typescript SDK that you can use to interact with fuel so really quickly comparing evm to fvm or fuel VM so evm you're writing your contracts in solidity you're probably using some sort of development framework like hard hat or Foundry if you're probably using ethersjs or web3js for your sdks to interact with your contract and for the indexer you might build your custom indexer you might use something like the graph and basically these are all sort of independently managed tools that you have to sort of Plug and Play and get them all working together versus fuel everything is built in-house like all the aspects of your application so sway is a language fuel up is sort of like a tool chain manager we have our own rest and typescript sdks in our own index server system and solidity is really like the OG language for the evm it's been there for us for a lot of cool stuff but it can also be like a Minefield for vulnerabilities it can be really tricky to feel confident that your contract is not like going to get hacked and there's just like sort of a lot of um environmental things you just have to like know about solidity versus sway it's rust space so if you're familiar with Rasta doll you'll know that the compiler and rest was really helpful because it will tell you like exactly where all of your errors are and we have the same sort of thing going on with sway we have our own compiler that will give you really detailed error messages and also warn you if you uh possibly have a re-entry vulnerability so it's really built with Lessons Learned From solidity in mind and designed for really good developer experience so the dependencies you'll need to build with fuel is first you'll need the rest tool chain and you'll also need fuel up so I can show you how to install fuel up so you can um find this on our GitHub Google Labs it's our GitHub name fuel up and we also have a book if you go to install.fuel.network.latest you'll find these instructions and basically to install fuel up it's this one really simple command here and it should modify your path for you so it's just one step um and then once you have that installed you can you should be able to use this like fuel up show command to see all of your tool chains installed so right now I have the beta 3 tool chains that is my default and these are essentially like different versions so we have different test Nets that associate to the different versions So Right Now Beta 3 is our latest test net and to develop and Deploy on the beta 3 test net UDD is the beta 3 tool chain so I'm going to make a new project and go to my desktop and let's make a new folder called sway demo oh actually just called sway oops and go into that folder and we're going to use the Ford command to create a new project so it's Fork new and then we can just call this contracts you can call it whatever you want so I'm going to open this up in vs code and here is what the template contract looks like so it's really simple there's getting more file there's this fork.tomel file which is essentially like configuration or manifest file and then here's our contract so main dots way and the first line of all uh contacts since we start with this contract keyword and this is because there's different program types in sway so there's something called predicates which are essentially like functions that evaluate to true or false there are scripts there's libraries and then there's contracts which I'm guessing you're familiar with already and one different thing that sway has that solidity doesn't is you have to Define your own Avi here so this is the name of the contract my contract and we can change this to whatever we want so I can call this game and then we have one function here is called test function and it returns a Boolean and then below is where we actually implement the logic for the the functions that we have in the Avi so essentially the ABI is like an outline for all the functions and their inputs and outputs and then we implement the logic here so we're going to implement the game Avi as a contract and we're going to make a really simple game it's not going to be too crazy um but yeah we're going to create a game and this game is going to have players so I'm going to create a struct called player and if you're not familiar with rest destruct is sort of like an object in JavaScript um essentially it's just something that has keys and values so our player can have a level and we have to give it a type here so the standard number type and sway is a u64 so you can say the levels u64 and then we might also want to have something like a player type and we can use an e num for this so an enum is essentially it stands for enumeration it's essentially just a list of options um so we could have let's say like um sorry our enum can be called player type and and say there's one that's like a superhero and the syntax is a little different than rest if you're familiar with that and then we can have like a super villain or something so these are just sort of unit types they're just basically like a blank type so the player type is either going to be a superhero or a super villain all right so now that we have our players we want to be able to store them persistently in our contract right so we're going to have a function called new player so we're going to change the name here prior to new player and it can return the player struct and you can see the this is not very happy with me because the ABI here is not matching the functions in the actual implementation so we need to update that view player and true is autoplayered okay so we have this new player here and we function and we know that we're going to want to store the players somewhere so we'll just add a comment like store player store player and so in solidity you apply for my worth like uh in persistent you might be familiar with persistent variables and solidity and know that they can sort of be anywhere in the contract um as long as it's outside the function but in sway we actually have a dedicated storage block so you know as you're reading this okay everything inside the storage block is what's going to be the persistent storage and I don't have to keep track of like you know is this variable persistent is this one not anything outside the storage block is not persistently stored so we're going to have all of our players store here and the player the type of this is going to be a mapping so we have a special type called storage map and it takes like a generic key in value here and you can initialize it as an empty storage map just like this and so thinking about the key and values we're going to use here we're probably going to want to save their address to the actual player struct so one another thing that's different about solidity and sway is that sway has two different types to distinguish eoas or externally owned accounts and contracts so you can't just use like an address type for contracts so we have another tied with an enum that's called identity and an identity can represent either an address or a contract ID so here we're saying that we don't care if a contract wants to play this game if we did care about that and we only wanted eoas to play the game we could store this as an address but just to keep it simple I'll keep it as identity and we're going to store that to the player so okay how do we get the identity in this function so just like solidity we're going to use a message sender and this is actually going to be um a method that we import from our standard Library so like rest there's a standard library and it's sort of like if you're familiar with react at all it's sort of like being able to import use state or use effect from react like it's already there you just have to explicitly import it and call it so we can say use standard library and the message sender function is in this Library called auth you can say message sender and before we start the player we can say let's sender equals message sender dot unwrap and why does it say unwrap is because message sender returns a result type which means that there is a small potential that it's unable to detect the sender and that's like for really specific edge cases so generally you're going to be able to reliably detect the sender but that's why it's there and then we're going to insert it into the storage map so we can say storage and this is a really important part so instead of like in solidity you want to call or reference a persistent variable you just use the name of that variable and you sort of have to keep track like okay this one's in use already but with sway you use the storage uh keyword and object to access all this so I can say like let player equals X and then you know storage dot players something else and they won't conflict so storage.players is how we're going to access the players mapping and then we can use this insert method to insert the identity in player so it's going to be the sender and a player which we haven't made yet so there are a couple ways to create a new player one way we could do is just say let player equals and then use this like player strike keyword and sort of like create an object and recreate this right here um another way is that we can Implement Associated functions for restrict so we can sort of use this like object oriented programming method here say Implement player and add a function called new that's going to return itself which is sort of like this in JavaScript um and essentially we can just say self the level will start at level one and then player type will be a parameter here so layer type I'm sorry whoops like your type like our variable okay so now we want to decide whether or not to make our player a superhero or a super villain and one thing we can do is decide like okay if you're in eoa you can be a superhero if you're a contract you're a super villain so we can use a match expression to match the type of sender and see whether or not it's an address or an contract ID so suede has exhaustive pattern matching just like rest which means that it will detect um basically all of the possible options for you and let you know if you haven't addressed like some possibility so the sender let's see let's say let the player type equals and it will use this match expression so if the sender is the type identity of an address or like this sorry address the player type is going to be superhero and it's a contract ID super villain see match text player okay this is for the whole function and then to initialize a new player we can say player equals player new and then pass in that player type and at the end here we can return the layer object and should be happy with this okay we spell this right all right nice so there's a new player function um let's see what else can we add to this one really cool feature that fuel has or sway has is a native tokens or native assets which means that there's essentially you can mint tokens in your contract and then send them like directly in a call so you don't have to approve and then transfer you can just directly send tokens and we have something on our standard library to make this really easy so we have a token library and you can import this like mint to function and then we can just call that here and mint a bunch of tokens to our player so I think we'll mint one token which the units and sway are basically Gray so one billion is one token and we'll send that to the player nice all right we're add one more function here which is level up so the player starts at level one but how do we increase that level we can add a new function here called level up and we'll have it return a u64 which could be the new level and this will take a parameter of ref mute self and what that means is just a reference to the struct itself and it's mutable so by default all variables are person or constants since way so we have to declare this as needable and we can say self dot level plus equals one and then just return the new self dot level all right so we need to add one more function here that can be called to actually level up so we'll have to add it to our ADI so we can say function is level up we'll turn to u64 and then we need to add it down here and I like to just sort of copy and paste to make sure everything matches and the player oops sorry let's send it to the sender out player there we go all right so to level up we're going to need to grab that player from our storage so just like this we're going to get the sender with the message sender function and then we're going to look into storage.players to see if we can get this sender so you can use this dot get a function so let player equals storage.player socket sender and then we can say player dot level up and then we have this so it's already upset in E right now just because this player should be mutable if we're going to update it and then we're going to reinsert it into the storage mapping to overwrite our previous value so we can just use the same line right here and then this level up function returns our level so level with that and we'll turn it at the end here all right so there's a lot more we could do with this contract we could also make this function payable and say like you know are they sending that you know this token that I just minted them and essentially how you can do that is [Music] um in so in solidity you can just sort of look at the message amount but in sway you can see the message amount and the message or sorry the asset ID being sent because you can send almost any asset so essentially you could just add like a require statement something like this they require the amount uh you know as greater than zero and require that the asset equals the contract ID that's ID equals the contract ID um and add this add like a payable uh um annotation so this one actually one more thing I forgot here is um in sway functions are pure by default and you have to specifically say when you're going to access storage so right now if I try to compile this it shouldn't work let's see yeah okay it should say let's see opening a few things here so it's a storage attribute access mismatch oh sorry that's a different thing um so basically yeah essentially yeah Storage storage attribute is this thing right here I'm going to add it to above each function and so our new player function writes to storage our level up function will read and write to storage and we just have to add these here as well oh excuse me Let's see we have to add them to our actual functions down here let's have the same lamb storage read write and storage right okay let's see that this compiles now okay so again I said insert we'll see storage type clear uh okay so I forgot one more thing which is when you're getting something from Storage it returns an option type and an option type is basically it can either have the value that you're looking for it can return none which is sort of like null so we also have to unwrap this as well so awesome we built the command I'm using is Fork build and it created a bill file all right so I don't have enough time to create a front end for this but I do have an example I can show you um get to install basically this is what our typescript front-end looks like let me start this thing was about Electric ity so we have our contract ID and you can see the steps to deploy the contract if you go to our developer Quick Start and we have this uh fuel wallet like window object so we have our own wallet extension and we have this hook to check if it's connected and basically here's our new player function so we can use the fuels or a fuel window object to get the user's account and then we can use these like generated types that we got from our contract to a stantiated connection to our contract with the ID and the wallet as the provider and then Pierce calling our new player contract so we say oh wait contract.functions.new player dot transaction parameters and add variable outputs is one so this is probably the trickiest thing about this is whenever tokens are sent from the contract to an address that will affect the utxos of the transaction so we have to specify that tokens will be sent out to an address here or else this call will fail and then we just say dot call and our level up function is basically the same I actually added like a payable thing here so we're sending uh you know 0.1 of our tokens with uh in the call parameters and I'm basically just console logging this so I'm going to say make any oops I'll see you this words I'm on the wrong Network all right so beta 3 test net I have funds in my wallet make a new player and it will show inputs and outputs and I'm going to receive one of these unknown tokens because I don't have this asset in my wallet yet I'm gonna prove that and we should see our players all right so here's our new player it's a Superhero level one and we're going to level up real quick and this is sending point one of our tokens and we should see the new level in the console all right well now we're level two okay so yeah that's basically it for uh how to build a fuel stacked app um if you're looking for resources um field.network is our website you can find links to our developer quick start and all of our documentation here and then I also have a copy of this contract and front end we just built on my GitHub Sarah Schwartz dot sway game demo and I'll put up the QR code for that if you want to check out that code yeah any questions in this book yeah but owned by my frozen there's so many space for the neck well what what so so uh it's just like ethereum sort of like so whoever deploys the contract basically or like I guess they're you know you have to write in an owner but um correct so yeah sorry yeah the question was if if you're calling a contract and storing it using storage then who's paying for that it's whoever's calling the contract just like ethereum yeah true all right well um if you haven't already we have a booth downstairs with a ton of t-shirts please get a free t-shirt you don't have to fill out a survey or anything and yeah come let us know if you have any questions thanks 