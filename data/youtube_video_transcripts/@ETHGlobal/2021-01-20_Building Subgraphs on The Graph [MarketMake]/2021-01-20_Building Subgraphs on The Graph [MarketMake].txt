yourself just for that background noise great so do you think we should get started now trent awesome thank you everyone for joining we have ariel from the graph who's going to show us how to build subgraphs so you can integrate them into your hacks thanks ariel i'll let you take it away thank you uh well first with introductions uh my name is ariel uh i i'm working as a smart contract leader in the graph i joined the team a year ago um previously i worked for a couple of years in decent land another project in the ecosystem and i want to give you some tools that i think will be very helpful uh with the projects you're building but also i would like to um use this opportunity to like explain the the value behind the the graph and why why what is useful um i i want i want to show you like the different approaches when building a front-end application for um for something based in ethereum on any blockchain and the difficulties that you like you face when building that type of application and what happened in this center and for instance uh so you can understand the how you can implement in your project uh basically using the graph uh the idea behind the graph exhibition is to be an open api uh for all type of data um basically what the graph is doing is indexing uh blockchain data now uh mostly i'm the most popular ethereum and and it's organizing this information so you can query it easily okay uh and the challenges you see when you're building a front-end application is that you have some contract you created um um a protocol and and then you want to create a front-end that is quite in this contract and it's it's it's hard uh for different reasons um let me share my screen uh now um so i can show you an example application um this is the the marketplace uh that we built in in decent land like a few years ago this is a an improved version of the initial marketplace but with the team when we started uh creating a front end for our contracts uh we faced many issues the first issue is like decentraland was um well it's a it's an open virtual world with parcels of lands that you people can uh buy and sell and put content on top of that and we have every all these all this information in contracts the land is an nft uh you have mana there is a token and we wanted to to build a front end and the naive solution was to query the contracts directly basically creating a react application uh sending request to an ethereum node and trying to print the information in the front end to help users but it was like a naive and a very slow solution because when we wanted to show a map like this one we wanted to we needed to like query like thousands of uh of land from a contract and if you notes are not prepared for that uh it's super slow uh we found out that the information in the blockchain the information is stored as blocks it stores transactions with a payload that raw data emits events but that's not a proper or very friendly uh structure to to query the data you have in your application so what we did was to index that information doing our own manual typescript app that basically uh listen for events the film events insert that information about postgres so we can query that information from our front end that was much faster and it was a really interesting solution but the issue with that is that maintaining a a typescript or rust or go application that you build yourself for indexing uh the blockchain is is stuff like you there are many things that can happen like ethereum nodes going down uh maybe latency or some problem with the with the request you have reorgs um you have to keep up with a lot of things so in the end we are not like um migrating to the graph um basically the graph is is building um we are building um a server called graph node that integrates uh like connects the what happens in the blockchain your own um indexer that is configure as mappings and it exposes an api using graphql so in summary it's like a backend for your for your ethereum application now i i'm saying ethereum because it's the most popular but there are like uh many uh different blockchains integrated um so the solution that now you see here in the center and it's using the graph as a back end and it's super fast you can you can see that you can basically switch from different land parts of land uh fast and it's quite in the the the back end uh using the graph so that's that's an introduction i i think that you can use the same thing in your project and um i want to show you what's behind the scenes uh to create something like this an interesting place i will say if you want to start your um create an um a sub graph uh that you can use as a backend is to go to the documentation in the graph docs uh you have the introduction explaining what you are building uh but you have a like a quick start uh where you can see like all the steps you need to do to bootstrap your project first and then how to deploy the subgraph into our hosted service basically what we are doing is running uh different nodes that we call the host service um that accept different subgraph and index them and publish on an api that you can use in the front end okay so the first steps that you need to do is to install um these this uh package you can use npm or yarn the the the one you prefer and it's it's going to install um a tool that you can use from the command line called graph and by using this tool you can bootstrap the project first okay so it will create like a skeleton in the in a folder where you you will work and then uh publish to the hosted service okay um i'm going to tell you more about the something called the decentralized network that we launched in december uh but first let's let's focus on the hosted service um so the first steps to to create a sub graph is to um do the init that that i mentioned um i have a i have already created a project here so i can show you with with more information but basically what you need to do is graph you need um you're going to connect uh to this to our service with github so i'm using my use of my github username and uh a name let's say fake token it's going to guide through the the the creation of the of this skeleton of the project it's going to ask a couple of questions uh you can select the the blockchain you are going to index yeah you can yeah can you zoom in your terminal a little bit oh yeah it is better can you see that um yeah i think that's better um okay um maybe this um it's going to ask a contract address and it's going to fill a lot of files uh by doing this so i'm going to cancel and go to the project i already created here is the project you can see like there are a number of files created by the the the bootstraps uh script and i'm going to explain each each of the files so you should you understand what what you what you need to do with each of them um so these indexing units is what we call subgraphs so probably your project will have one subgraph at least but it can have multiples of graphs okay so a subgraph is something that is connecting uh one blockchain like ethereum it's going to connect entities that we can think of entities like um a table or an object in a database and it's going to connect uh mappings or handlers that you will use to map information from you see what you see in transactions in blocks or in events you're going to map them into entities okay so basically you are you are transforming the data using the blockchain to something that is more of uh friendly for your application okay so let's skip this part of the documentation that is about the init that i already show um you have this this file called subgraph yaml okay that's going to define something that we call the mappings so this is this is the the same file in my in my project uh you'll see that these files configures a number of things um the first thing is a data source um we are saying i want to index the graph token this is my example we are going to index the graph token we are going it's a typical erc 20 token uh we are going to use the the mainnet the main network uh the source the the address of this token is this one we're going to start indexing everything that happens in the blockchain with the graph token from this block you can leave it zero if you don't know you can like set to a particular block number if you if you know when this um token or contact was deployed it's more efficient if you set a a block so the the graph don't need to index from scratch from the genesis uh so this will help um and then you define a number of mappings what we call mappings this this is connecting um an event signature i'm using an event handler here um with a with a function okay with a function called handle transfer so when you run this subgraph it's going to index uh every event with this signature by calling this function okay called handles handle transfer um so this is the mappings you can you could define let's say if you wanted to to manage more events like approvals you will basically copy this information paste it and set the the right uh signature signatures like whatever it is uh it could be any any type of event immediately in a contract in ethereum um so let's see the other part of this you have the you have the a mapping configure uh you you have a as i mentioned an event handler and there are some entities as i mentioned before um for this project i created one entity called account uh what i'm trying to do here this is an easy and easy example is to um have a list of accounts that use the protocol basically the graph token and and be able to query the balance of each account easily okay so what i did is i created an entity and that is defining schema.graphql this file very simple entity um you define an entity like this type account is the name of the entity this is the type and as you see this entity has two fields uh one is the id this is mandatory every entity needs to have an id and one extra attribute that is the balance okay and this is a big reference about how to define schema uh you can like find information in in google everywhere about graphql graphql is a protocol uh created i think by facebook um where it can let you basically create an api on top of a model that you can create in different different ways okay uh so this is a way to define a super simple entity in graphql and we are using graphql as um as a way to express and to query the the api that you index um so here i have my account and the last thing i need to do is to uh set the logic for the indexing right so again going back uh i have the mappings i have an entity called account i have an event handler from ethereum every time the indexer c transfer will call handle transfer this function is on the mappings file so you have these mapping files with a bunch of functions this can be commented out i'm not using them um they are empty but you can see here is um a file that it seem looks similar to typescript is assembly script um it's very similar to typescript with some limitations and the good thing this is compiling to web assembly and it's super fast so we have we have indexers reading in rust that can run the these mappings well assembly and and we we've like tried to use the faster technology and and also rust is very stable so um running basically one graph node is super safe um so good question um one of the hackers is asking if there's a repo they can follow along with uh good idea to have a repo uh we have a repo um not for the project i'm doing right now but there are like multiple examples of soft graphs um if you go to github graph protocols there are an examples of graph and there are others of graphs for let's say pull together uh uni swap aragon and their own pro and these projects also have subgraphs so you can see the same structure um okay yeah that might be a good start i'll grab those links yeah uh maybe you can look at examples of graph uh what i'm going to do after the code is to maybe push my example so you can see it okay um so um i i was i was saying okay when the graph now is indexing the blockchain and is finding an event emitted for a transfer it's going to call this this function and basically i'm in charge of defining what these functions should do uh okay so what i'm doing here is um we receive the event and you can see that this is this is already pre-filled with the with some typescript bindings so you can like see all the information you can uh basically read from the events uh the address of the contract the the blog the blog the transaction uh to get like a hash for instance uh you can get the the event parameters by doing this uh with from to and the value and what i'm doing here is like fetching this information and basically then storing in the entity that i defined okay in the in the graphql schema so um this is this is by basically some checks i added because when you are minting a token um basically it's a transfer from the serial address and i don't want to record an entity for the serial address so i'm skipping that but uh what i'm doing basically is uh storing one entity for the for the from account storing one entity to the destination account and um subtracting the value from from the balance of the uh source account and adding the value to the to the destination account so i'm keeping the balances of multiple different accounts using the transfers information okay so after the after the graph node finished indexing this sub graph i will have information about the accounts with the proper balances okay um you can also apart from from right now i heard some some noise sorry um [Music] the apart from defining a handler like i'm showing you here you can define uh other functions helper functions uh so for instance i i define this load or create account function that you can use from your own code that is basically testing if the entity exists or not and initializing a new one okay you can again you can think of an entity as an object that you save in a database or that or or a row in a table okay um so i want to show you a bit this function because it's interesting um this is the way i can work with entities um you will import in the in this file from from the schema um i'm importing this entity i defined here um i once i import it i can use it the same thing with the with this typescript um bindings so i can collect functions like load that is going to fetch an entity from the from the storage um using the id in my case it is the address okay the address of the account and you can assign it to a variable and then interact with that variable okay so um you can see the the attributes to define in my case it's balanced um and you can operate on that on that attribute okay this is one way to operate with the with the entities the other way is to basically i'm loading here i'm testing if the entity is already there uh the other thing you can do in this case is the i'm testing if the account exists or not if if it doesn't i basically create a new entity called account the address and setting the balance to zero okay the last thing you do after you basically operate on an entity is saving it and it's going to basically save to the storage update it or create a new a new record okay um i i find it quite easy maybe it's a lot of information when you see like for the first time but um it gives you a way to like manage each of the events that gets emitted into a very contained function where you can like do transformations on the on the entities so this is on the this is on the side of of coding it um let me show you about the workflow um so let's move this down um you have to brush it here it will it when you need to depress it it will create this package json with some information about the uh to deploy the project in the in our hosted service but also some helper functions to basically build uh build the subgraph um you'll see that there are two things like you see code gen and build and these two things are important um if you run code gen this is basically doing is reading the schema it's reading the um uh the contract information and it's creating the the these bindings that i that i uh show you where you can like basically import it in your code uh and do this um uh and use it like a typescript um object okay so it will help with the development uh you can see the generated files here like graph token ts uh this is auto generated by coding uh and it's also creating uh this schema ts from the original definition i created here okay uh you don't need to worry that much about these two generated files you need to define the stream up properly and then um basically run code gen if you change the schema okay the other thing is building the this a graph well my custom my cat is trying to to code with me uh the other thing that you you can run is spilled it's the other important function um in your workflow um basically what what this is doing is compiling this um compiling your project into into web assembly and it's preparing it to to being deployed okay so running build is a good opportunity to free to fetch uh to identify issues in the in the code let's say i know let's do something let me see if this is breaking the code okay i've removed some some attribute here and it's like giving me some information that the the conversion is wrong and i require a typecast and this is because i'm like assigning uh something i'm assigning a parameter itself this attribute so if you fix it and run again you'll see a confirmation that the the code is right so you are able to deploy it okay um so this is all the things that you need to do to prepare your code um handle transfer is a function basically i use for for keeping track of the balances but in your case could be something completely different maybe you are tracking nfts you want to track the uh i know the rewards assigned on a farming defy project uh there are many things that you can do uh all these protocols emits events um you multiple contracts in in the mappings uh i i set this uh data source the graph token but you can set multiple different ones uh you can track multiple events you have block handlers you have many many different tools to play um and to create uh some crafts so the final step is to deploy this into our hosted service if you want to do that um you can visit the graph plotter uh this is uh the website of the of the host service what we are seeing now here is my already deployed project um i already been playing with this example and deploying it uh so you can see like all the information about the project but um you will sign in with your github click add sub graph and uh basically you can define the you can put an avatar you can set a name well it's going to validate um it's it's under my account you can set a title uh you can uh decide if you want to show it or not in our explorer um we have a dashboard where you can see all the subgraphs from different projects and then you click create some graph from here and it's not working i know why oh there um so i created my my new subgraph and what you can do um is uh follow these instructions basically it's it's it's guiding through what we already did uh setting a graph out like you are using your access access token to to to login and then uh graph deploy okay so we are now going to you to do a graph deploy uh on my graph token project here uh npm run it is now building a web assembly and it's going to push this sub graph to ipfs um and then notify the hosted service that it needs to index this subgraph okay you give uh you get a confirmation that everything is all right um one particular thing to notice is that we are using ipfs we the the graph node is using deterministic sources for all the information like if you run two sub graphs multiple times you it should like get to the same result um basically using the um the graph node is taking care of the of the block reorgs and it's it's deterministic so uh by using ipfs we uh guarantee that the hashes won't change and the information is the same if you are going to index this subgraph from different places okay so now if we go back to the ui uh you will see the current version of the sub graph and something called depending version okay the pending version is the new version i deployed and the current version is like the live version i had before and this is interesting because if you you do change in the sub graph let's say you fix a bug or maybe you added a new feature to the subgraph the current version will be will be working will still be working so your your um your front end if it's quitting this graph will uh keep up solving the uh results and getting information from the from the api and it's uh changed and hot swapped when the when it finished okay uh so if you change to pending version you will see the progress of the of the indexing you can see like uh well the the hash of the file you can see the log of the progress of the of the indexing process uh you can see like things like this signature uh here uh it's it's calling handle transfer um you can change the the debug level and it's it's good to to see the progress um it's also showing the priorities here okay um so the these this hosted service helps like a playground where you can uh submit your subgraph test it share this link where people can start using this a graph integrating in the front end or on any other service um let's see these this playground first um we have um as you know we define this account entity these uh two attributes um i can query it by using graphql if you click play here you'll see account data like for instance this account has like zero balance uh this one uh way of token uh this this account has like um uh more more balance remember that this is this number is in way so it's a super long number you need to divide to take into account the decimals in the in the token you can change this to query more results this is a very a very simple example right but um it gives you an idea of the workflow uh things that you might need when developing a subgraph is um adding some debugging information like um where is that here um the let's say you want to log um let's say you want to add some logs to your to your handler uh you can import this graph ts library and use the log function so you could add things like log debug a message a placeholder and then um something to fill this playholder um let's say it is from okay um so when you build this project and deploy you will see these messages in the log okay this is very useful if you if you want to see if a variable has the what you expected it to have for instance um so let's deploy the brush gift game it's going to generate the files if the files change the ipfs hash will be different because the content changed so it will be a difference of graph and now it's deploying so we get back here and we can see that this subgraph id match with the host service one so we we are we know that we are indexing the right one and if we go to logs and we um we set debug level uh we can see the message i i set in my code like hello and the on the address and this gives you the possibility to try different combinations and maybe finding a bug in your code easily by using the log so it's super useful in mathematics um the other thing that is super powerful that let me show you in the documentation um is that you can define uh in our example we define an entity a super simple entity like it was the account with a couple of attributes but you can define um entities with relationships let me look for an example of that uh because it's interesting here um you can define uh relationships right like let's say you have transactions and transaction receipts you could define um like these two things as entities and you can link them by saying that transaction has a transaction receipt and and you are linking the receipt from the transaction okay so when you query that in the in the in the playground and by using graphql you will see that these two things are linked okay uh you can define one-to-many relationships too you can do reverse lookups this is something that you maybe if you use orms database in the past uh this is like a pattern very using in rams like i know i came in python or others um you can um define a relationship and then from one from a different entity look back to the to the balances in this case um you can define many-to-many relationships um to make it performant this approach is very similar to what you do in a database by having an intermediate relationship to link users and organizations so as you can see there are many patterns you can use um i don't think i will have the time to give like everything because there's a lot of documentation uh but i want to give you the tools so you can like bootstrap your subgraph and then you can basically have the means to investigate and and maybe adding and making them more complex if i were to learn how to create a subgraph i think that i would base with this documentation and there are a bunch of examples online from big projects of let me see if i can find the for instance uh ue swap um unisop has the subgraph defining their i'm referring to user because one of one of the biggest projects out there um uh has it there's a graph and it's quite um complete so you can look for ideas uh you can see that they find their own helpers um you can base on on on other project helpers too um they have a well this function where they are defining handlers for tracking new pairs and creating entities related to that if you're looking at a new project maybe it's a good idea to look at the mappings file that i show you initially because this is the way you track everything you can see how they link contracts to particular events um particular functions they use to handle the event okay um also the schema file this is a much more complete example that i show they have these factories token a pair with these entities that can be linked as i show you with derived from and one entity having other entity defined like liquidity position as a user and a pair for instance um so there are many many many options uh for you to play in your project and i would like see other subgraphs from the other projects to to get good ideas um another tool i would like to show you is in the explorer um any questions so far yeah there are a few in the chat and then one i've pulled over from youtube if you want to go through them quick okay um i can read them to you or if you'd like to read them yourself either uh i'm nothing uh are them in the in zoom or yeah i didn't zoom yeah i'll just read them out um the first one is just a general question about what uh graph protocol does and i'll just read it it's so this protocol would allow us to index and search for data across blockchains on top of other protocols is that right what about oracles uh well uh something that exists a stop graph is now indexing things that exist in in a blockchain so if that information is put into a transaction that can be read it can be indexed so let's say uh chain link is uh the chilling project there are you there are multiple nodes in the chainlink uh project that are submitting information entry about different things right like uh they are a solution for oracle's uh bringing information from the real world to the to the to the blockchain so you can set up um as a graph that is watching these contracts and you could index the information that these contracts are are bringing okay so you could index change you could index any information that is on the blockchain with the graph yeah one way to summarize it and tell me if this makes sense is uh the graph is good for indexing historic data and oracle's bring new data on chain that's digital exactly exactly yeah cool um let's see what the next one is uh raphael asks is load an inherited method from the entity prototype this is going back a few minutes i think when you were going through the demo what's the the question uh sorry i mush that together the question is is load an inherited method from the entity prototype yeah yeah it's uh every every uh entity with the finest schema graphql it's uh extending the entity object yeah so we don't need to definitely load load it's in every in every entity okay okay cool rafael if that answered your question or not just drop it in the chat and then we can address it later uh one of the questions from youtube is not very familiar with graphql but what are the advantages of using graph first doing the same thing in mongodb well um what gives you a graphql it's super uh extensible it's easy to query like different um uh it's a combination of two things you define uh an entity format but it's all building uh an api for you almost automatically okay by reading the entities that you define so we we thought it was uh a perfect solution to create a generic api that can be used for multiple use cases if you were to um i mean is a storage solution okay for querying uh you need something else you can use the language provided by basically when you connect on the on the client but uh it's a different abstraction the graphql lets you create queries and then the storage can be something else in our case graph nodes use postgres uh so this thing this information is complex uh converted into tables and and and like the storage is completely different and you could swap these stories to something else to something different to postgres um but and you keep graphql as an outer interface to the world cool maybe this this next question is might be a little bit out of scope for this tutorial but uh raphael asks will we ever get charged for deploying a subgraph the uh host service now is free you can basically uh deploy some graphs on uh using your project for for free uh what the new thing in in the graph is that we launch a decentralized network uh in uh december that means like instead of us hosting hosting the these up all the all the sub graphs we have a network of now more than 100 indexers that can uh that they index subgraphs from the network okay and apps can use them uh to use the network you need to use uh glt uh there is a token and uh we we are um we having um we are planning some migration from the host service to the network but it's going to take some time and and we will like give more information about how that will happen uh the idea is to maintain the the playground in in the host service uh but will provide more information in the coming weeks we'll see okay i have a question yeah um forgive me if this is like a dumb question but i was just curious i mean it seems like a lot of these uh diy protocols of their own tokens but what prevents uh you guys from not using ether um and then just uh why why do you need a separate token i was just curious on that yeah um there are a couple of things um or i would say crypto economic mechanisms that they wanted to use uh one is um these are uh this this token that we created uh have multiple functions in the in the network there are like uh delegators uh indexers uh curators uh and um and consumers basically people that sorry consumers people that queried the graph and developers of the graphs so by having a token we uh could um like create more of a crypto we are more like um free to create great economic um uh designs on top of this token indexes can stake delegators can share some capital to indexers by using the token we can have an inflationary rewards for indexers by minting an amount of tokens based on them providing service to the um subgraphs that they curate uh so if we're using it we won't be able to add this all these crypto economic mechanisms or maybe we should have designed them in a different way so that's the main advantage um i think that we can do like a complete call about the decentralized network uh because there's a bunch of things in the design it's very interesting i would like to talk about that maybe in a different uh a worship all right thanks thank you yeah that's it for questions now unless somebody just thought of one but you can move back into whatever part of the workshop you're in ariel yeah i wanted to show this um explorer where you can as i mentioned before um looking at open source code it's a good way to learn and to get ideas for for for your project and to basically uh get to a a higher level of of uh i i learn a lot of as a developer by looking at other projects uh so you can um you have this explorer uh where you can see subgraph created for for from the community you see like many of the biggest projects in the ecosystem using it so you can click on this featured one and look at the look at the sub graph and a good thing to to see apart from the coding github is how they design the entities like um basically designing the entities is like thinking about the tables and the relationship you you should have in your back end so uh is it a good idea to have a user uh do you want to i mean this is this all depends on how you are going to query the information uh this is a good idea to have a user do you have a pair in this case uh they have a pools and they have pairs so it's like probably they they are like consolidating a lot of information in this in this entity but um i will look at the design of other projects for their back-ends so um i think it will help you to to design your own schema uh because maybe that's one of the first things you would like to like design the schema and then uh see how you map the events that you can read from a contract to this schema okay um then you can play with it with a play around of basically any sub graph uh you can create multiple entities at the same times like you can see in this example but um you could play an um like i don't know this uni sub factories uh entity has these attributes you can add them like i'm doing now uh most liquid tokens this is another entity that probably has more attributes so you can query them like this um yeah so so i invite you to play with the with the explorer um see what all process are doing work on your entities and um start the skeleton as issue with the graph in it and and then deploy the place of graphs in the in the explorer and and play with that i think this gives you a good overview to start but i would like to to to see if you have any questions or maybe i want to fast on a couple of things and you want to uh me to to repeat something or let me know that's for you hackers if you had any questions or missed something while the tutorial was being gone through now's your time to ask away sounds like you covered everything okay good job uh if you uh yeah if i i i have a feeling i went too fast in a couple of places but there's a lot of things to show uh so yeah that the summary is like you have the tools and you can like now deep dive into the documentation and look at the examples of graphs i would push my the one i've been using in this demo and i'm free if you want to ask questions after the workshop okay yeah it looks like one one just came in from youtube uh not really related to the hackathon i don't think but um will creating useful subgraphs help me earn grt i am very interested in being involved i think that is true right there there's some curation benefits yeah uh if you create some graphs uh you can um do curation on the subgraph and by by doing uh by creating a sub graph what you get is um rewards from query fees that the index indexes are um that that are using that sub graph are earning okay so let's say 10 of the um query fees goes to curators and the curators are related to the process of creating a sub graph so as a developer you you would probably instead of um pushing to the host service like i show here um you will be curating on a sub graph and pushing the code there okay so you'll get rewards by doing that um there is a section in the documentation that this is split now that you go to host service this is the thing i show you but there's a section for the network we are completing this section but you can see the roles i mentioned in the all the crypto economics of the of the network and the the things you can get by participating by being each of these roles as a delegator as an indexer as a curator and some guys we are going to complete this this document uh with more information about the network okay yeah um another person asks can you implement the graph in an existing project yeah yeah uh as i mentioned before when uh when we started this centerland it was um we started this project with the native solution of quitting the contracts it was super slow then we switched to our own indexer and then we switch to the graph so uh the approach to to implement something like that is you keep your backend while you are you develop a new a sub graph to replace that back end you can test it using the the the explorer and all the tools we have and then you switch your front end to use the graphql interface from the from the uh from the subgraph now you you know that the front end is working properly you can like ditch your indexer if you had something for your back end uh one last thing what would be the best tutorial to start with if you didn't know anything about the graph the best tutorial is this documentation i showed i think it's pretty well reading rhythm uh there's uh all the things i mentioned like from installing the the cli to what is a sub graph the manifest the schema i will start by reading this and then basically running graph in it and getting the skeleton and step by step trying to implement um something easy and getting it more complex with time but yeah and then as you move forward looking at other projects like bigger projects um and get ideas like the units of the show but there are so many uh in github definitely yeah so i just dropped the link in there for the graph.com docs seems like a good place to start thank you um i think we've covered all the questions unless there's one oh oh here we go um let's see uh can you give a rundown on the other big projects in crypto doing data index and querying and what the differences are eg dune analytics uh versus the graph versus whatever you think it's worth mentioning well dune dune is not um a protocol like well yeah sure i'll let you answer go ahead yeah yeah now the the ones i i follow i know from the communities uh dune analytics uh nansen maybe uh they have um maybe different approaches uh like um the analytics has however they have a repo um i would say like a lot of information that you can query from from different places to create charts and to create like uh some visualizations and i think that they are very good at all these uh i'll see data say that science and maybe the approach for uh the graphics like even if you can do that with subgraphs uh it's more of um people are using money for as a live backend for the for the open data like you you have uh some service running you like a critical part of your application is it's not that you're doing only analytics you have we have sites like unix raptor info but uh you have a running site like it's the back end for your gap in a way and uh and that's the value and uh and you can aggregate information from different places so i think that there are different approaches and people tend to use maybe during analytics for other purposes like analytics that you do with some time it's not it's not at the back end for your service um uh nonsense is the same thing it's more of a user oriented that you want to like track the token flow or other things but it's not b these services are not backend for the for wealth-free applications yeah yeah that's a good way to summarize it uh another question is can you explain a little more about the cost in grt we need to pay to deploy or query sub graphs um yeah it's an interesting question the index indexers now they set the costs uh by using a tool um that is lets them uh set up set the the cost for perk wave and there's some another entity um that this is a gateway that has like some uh indexing routing logic based on on the on the query fees and the query price but maybe it's it's a bit soon to answer that question because uh we are starting to see the market the formation of a market around the the query fees so it's it's a bit early because we we launched like decentralized network maybe a month ago yeah so um it's early i will have a better answer after some time and see how indexers set up their their their prices um but i i always pay competition we have we we have like more than 100 indexers already uh so we'll see how it how displays okay yeah um okay the questions keep coming in somebody asked if you can share the example code and i believe you said you're going to push this as a yeah to the repo i i will push the the example code basically the example is indexing the graph token erc20 and saving some information in an entity that you can query you can use it for a different erc20 if you want yeah um another question is could a sub graph be used to make a block explorer what are the limits on sub graph size um you can basically you can track let me show you something um we have uh my my ex my example application was um using event handlers so you set up this signature and then you basically set up the function that you want to uh index but there's other things called uh block hundred handlers okay so you can set up uh that you want to watch every every block okay and you have a handle block function so you could basically by by using that you could like listen every block you could store blocks and transactions am i doing that you have a block explorer you have the the i will say um what you need to be level explorer um maybe it will take some time to index that's a graph uh but you have the tools um so i will say the answer is yes by using these tools uh people typically use this subgraph to create a like um um like a back end for an a a specific application maybe a block explorer is something more general but you could use these tools there was another question about that um other yeah other questions not necessarily about the block explorer oh uh what are the limits on subgraph size i i i didn't answer that but uh we have um uh very large subgraphs in the house's service uh i i won't talk about the limit because i don't know if we set a limit i can ask people in the team if we have a hard limit but we have really large gigabytes like many gigs uh size subgraphs uh i think i saw somebody syncing their it was either an ether or a wrapped ether sub graph and it seemed like it took quite a long time so it's possible to do large ones um whatever whatever yeah i'll try to find the tweet is dennison um okay uh let's see gawain asks will the graph be compatible with matic before the end of the hackathon uh the end of the hackathon is february 7th i believe um what do you think ariel uh i can ask the team uh i know that we are uh doing some uh integration with matic but it's more of um i need to ask the engineering team because they they know better or we're going to provide the answer after the call yeah yeah uh going i wouldn't i would assume it's not going to be um because even if it if it's available in like a week or so it may not be enough time so don't don't don't plan your project around this specific uh integration but hopefully hopefully they get in time yeah i think it's a good advice uh if you are like waiting till the last minute to get that and uh create that dependency uh i'm not sure about times but it's a good advice if you come like maybe work around that um another question from keita is could i obtain a list of accounts who hold a certain erc20 using the graph accounts that call the specific erc20 you would need to maybe uh track all the erc20s and see when uh there's a transfer to to that account um maybe i can think of a better approach to that but there's a way to create um or maybe you can scan transactions and and see if they from or to address is created to that account um i would need to think about that but i think you should you you would be able uh there's something that i didn't show that it's data sources templates uh this is something useful is if you want to track multiple erc20s instead of one like i did in the demo uh you can create a template okay and and then um by setting up a template you can then apply this template to multiple erc20s so you define how to uh track a transfer let's say for a contract and then you apply it to multiple addresses that are using the same interface your c20s for instance okay uh so you kind of create a list of multiple real situations i want to follow um so that's interesting you can dive in the documentation and look for data sources templates uh keda did that answer your question or maybe we can maybe talk more offline yeah okay cool uh i think we i think we've covered everything um after the the last last call this is the last last last call for questions if anybody wants to okay we got another one coming in uh what is the vision for the graph i hear it is the new google in a sense can't you elaborate yeah uh it's uh the vision is to to be a decentralized protocol for indexing acquiring uh open data basically uh and we are focusing maybe our is popular for for ethereum because uh the project started by indexing uh the ethereum blockchain but it is to index uh any kind of information out there that can be uh like just like the ethereum blockchain where we are supporting other blockchains too and um create this mapping of the world by having a lot of sub graphs from for different things and that's maybe why people say it resembles google indexing uh web pages and we are doing this for like web3 um i i see that resembles the resemblances is by by the indexing um but that's the mission uh so um we are doing a great job by being the backend for multiple of of the wealth free ecosystem and we want to like keep on like integrating more uh more chains and uh um we are doing that is when i show you graphic needs it's not only supporting maintenance there's like other things xdi and we are planning to to have more integration so that's the solution i think that's probably a good place to to wrap it um the graph has a huge vision and they'd love to help you build that vision at this hackathon uh thanks ariel for sharing sharing this tutorial um if there's anything that needs to be followed up we'll be in the discord um i'm not sure if you're there but it would be it'd be great to have you join arielle and then hackers can you know pass along anything or any roadblocks they hit um yeah thank you everybody for sticking around thank you i'll turn this on see you there bye see ya 