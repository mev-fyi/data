um i think i lost the network for some reason think i lost the network for some reason i can't hear you initially okay um just just give me a second i'm gonna switch my network quickly okay um this hello can you hear me am i audible yeah okay cool cool so hello everyone uh sorry for the initial problem it was just some network issue here so i am trish and i am currently speaking from india and uh i am a pac and slash algorithm designer at paraswap and i'm super excited to you know build a chain arbitrage bot with you guys so let's get started i'm gonna quickly share my screen do you guys see my screen just just uh stop looks good cool so so yeah so maybe a lot of people who are listening to this conversation might already be familiar with what arbitrage is if they're from d5 space but to people who are not familiar arbitrage are basically inefficiencies in the market which leads to risk-free profits so basically you can make money with with basically nothing and let's take a concrete example right so let's take an example in the defy space so if you wanna uh if you let's suppose you you swap eat to die and you swap one eat and you get three thousand die and then you use uni swap for that and then you swap your three thousand die to let's suppose 1.1 eat using sushi swap and you just get an extra 0.1 each so this is basically your arbitrage just because there was a difference in the prices for uni swap and sushi show so there are different ways of doing arbitrage but today we're going to look uh and cross chain arbitrage so where does paraswap come into play so powerstop is a liquidity aggregator and when i say well a liquidity aggregator it basically gets prices from multiple dexes and gives you the best price when you want to swap from one token to another um i think the best way to see it is to just look at it so i'm gonna just open parasol and go through it so let me just quickly open paratop so first of all parasoc supports like ethereum polygon bsc so let's let's just look into ethereum and you can just put like from and do token and so parasol will basically give you let's take some big amount to see some good stuff happening and you know it gives you this you know you can use uni swap v3 to to route it and you can see how many different exchanges we are looking through to give you this price uh maybe let's look into polygon and you can see like with polygon just going from magic to usdc we are looking through not only multiple exchanges but also multiple routes so yeah parasol basically tries to beat the market using different exchanges and different connectors and that's what is liquidity aggregation so let's come back to our presentation cool so now we know what parasoc does and how we can use it in our arbitrage board is basically when we want to get the price for swapping one token to another we can use parasol and we can also use parasol up to building transactions so so what is a cross-chain arbitrage so we understood what an arbitrage board was but what is a crush in arbitrage so a question arbitrage is basically when you you know when one of the transaction is in one chain another is in another shape i mean the simple example is again we we take like ethernet and you know you you do like one each mathematic and you get let's suppose 1500 matic and then you do 1500 matic to eat in like polygon chain and then you get 1.1 uh each so you got like point one eat extra uh now the you know the interesting thing is one of the transaction is a main net another is in polygon and uh there are quite some things you need to take care of first of all you need to get pricing for both the change simultaneously and then you need to execute the transactions and then also make sure that your tokens are balanced in both the chain so yeah we're gonna try to build that in today's workshop and for simplicity we'll actually just use you know eat and mate because those are like just uh native tokens in both the network uh yeah so yeah let's get started with coding i mean we are all here for that yeah so before we start coding uh yeah everything is open source at parasol's github so let me just quickly show that as well so you can come here all the code is open source and feel free to you know fork it and start working with it it's just like a sample code it's quite simple i'm gonna go through it now so yeah so so we'll start with first integrating with paraswab api and just quickly open the code so we are writing the code in js not jazz and it should be fairly easy to understand also for people who are not very familiar with node.js so i'll just try to give you basic idea of how to build it so even if you want to build it in some different language you can build it easily um so first of all we need the parasol url to integrate with the parasol api and this is the url and then we create a parasol class which has two basic operation get price and bill transaction uh let's actually first look look into the parasol documentation it's quite explanatory before we actually start so you just copy the url for the documentation so you know parasol has like basically two main endpoints i would say uh one is the pricing endpoints and other is like the transaction building endpoint so the you know we looked into pricing right and once we do the pricing we can actually connect the wallet and build a transaction to actually execute the swap so the pricing endpoint does like the pricing part where you will get like a route and with the best price and then you can call the transaction building endpoint with with your final route and then you can get a transaction transaction object which you can then send to your full node and then you can you know execute the transaction so that's the basic uh two end points and for the pricing one if you look it's quite simple what you need to pass is like the front token this could be your address or the symbol itself uh then two token the amount and then you have side and network you should i would also recommend to pass from decimals and two decimal because if you wanna like parasol allows you to swap arbitrary erc20 token to arbitrary s20 token and if you pass decimals then you can do that otherwise parasab has to list that token so yeah let's look into the code so quite simple [Music] so we have a try catch blocks because if there is an error in pricing and the request url is basically the url prices and then you have the from which is so we have the get price is success like takes from two source amount to network and from is basically a token object which has an address and a decimal so we just put the from address to address source amount from decimals to decimal cell and the network so the interesting thing here is you know you have the same api and you can query both the networks uh so that's that's very that's very good actually for our arbitrage board and then you basically do a simple get request and then you get a price route i can also quickly just show you how the price out looks like we should actually have some price routes so just some some random query so we just did like an eat to die or some big amount of somehow when the price route you know you get like the best shroud and you like this was a mega route so you know omega out in terms of parasol is basically like the most complicated one where you have like you know multiple routes going through so you have like multiple routes using multiple exchanges so here we're using you see quick swap curve v2 sushi swap and curvy one so that's pretty good and then we have uh the destination amount here which is what is important i think we also have the destination amount here um let's see this one so that's what i'm using here if you see the price is like data priced at our best amount and the payload is the whole payload uh when you build a transaction it's important that you give the exact price route payload because the payload is like just it has a hash at hmac so you know you don't you should not modify the price out payload just the payload and then let's come into the build transaction it's also quite simple so if you look at the document documentation here build transaction um the important thing is your again do decimal from decimal uh refer user address so refer is i think yeah refer is not required i think but it's maybe it's the type typo here um user address user address is the address who's going to execute the transaction it is important because para swab just like checks certain things like balance is there correctly and stuff like that then there's price route which is the exact payload that you got from the pricing destination amount source amount that's token which can again be your token address or the symbol so this is pretty clear i would say um you can see that so you can see it's just like putting the price out with the payload that we got from two and yeah uh the source.sml and i'm also actually passing the referrer uh if you see here and the referee is said to be our part now the reason i'm doing this is you know when when you pass a refer what would happen is when you do the on chain like when you execute the transaction and uh there's a swap event that's released and the referee will also be there in the swap event so in future if you want to build like a cool dashboard where you want to check you know what kind of transaction that artboard did and all kind of statistics we can very easily do that because we can just you know get all the swap events where the referrer was our part and we can easily use the parasol sub graph so there is also a parasol sub graph which has like you know that you can index using the referrer so i just you know chose some random name i mean arbor school um yeah so you can for the pricing you you need to pass the referer index partner and for the transaction building you just pass it in the transaction like the request data and then you do a post so here in the pricing we did a get request for building transaction we do a post request and then you get the transaction object uh i just you know create another transaction object just using this and i make sure like those on the right format so we convert it into hex so we get the hack gas value which we convert into hex uh the value which we also converted into hex and and that's it so i think this is pretty simple if there is any any questions here please yeah put it in the chat uh don't feel hesitated let me see if there was anything that was posted in the chat as well i'm not sure if i can see that anyways i will go ahead maybe i will check that in later on um cool so let's see where what we have next in our timeline so we understood how to you know query parasop api uh the next is like you know going through the bot draft so you know how would the bot look like the bot logic and um this is basically the i just you know i've commented out all the code and i will just go through it and comment part by part to understand each part of the logic um yeah so first you know we like you know i first i think i should explain the end example so we we need like a private key which holds some funds in mainland and a private key which holds some funds in polygon also http provider for mainnet i think you can use intuit or alchemy and http provider for polygon just create like an end file copy all these variables and put the appropriate providers and then in the in our index file what we're doing is we just like importing them so for that we need the dot n so that we can [Music] add it in the environment variable and just just add it here and i'm just like putting into a map with like a network with different network id so that we can easily access it so for mainnet we know the network id is one and for polygon we know the network id is 137. for now you can just ignore these variables i'll come to this later on so i also import like the parasol class that we created here right so this class that we created here and also we need like big numbers library so usually whenever you like you know work with uh web3 stuff uh in js you would need some kind of big number support because you know js doesn't has us that so also you know we need ethers to send the transaction and do all kind of f3 stuff so for that we're using ethers you can also use web3.js that's also cool um yeah and then what we do is we just create like a map of tokens so that we can use it and as we saw in parasol we were just you know it's we use like an address and a decimal so that's what i'm doing here and creating a map with like network different network and eat and matec for both the network so eat address this and matic address wheat is this whereas matic address in matic is just like eat address but eat itself as a different address this is pretty cool like because the native addresses is always this uh and others are like erc20 in each other's network so yeah we can quickly see that as well so users can this is yourmatic token and the decimals is also like 18 so this is fine and also for this one just to quickly verify and this is like your wheat so i mean yeah it's sweet and 18. um so the reason i chose actually eve and matt take for crosstown arabic characters basically because you know these are like the native tokens and when you do like swap you can just put them in the value and you don't need to give an allowance or approval and you know that will just you know give us some some more space to not like you know add more complexity but make it simple so yeah that's why but we can use any arbitrary token so you can put any token which is supported in both the network and then you should be you you should be able to use it for the crush and arbitrage part and then let's come to the main uh port logic and that's you know we have the crosston arbitrage part class where you have like an alive which is basically the you know making the bot alive um then you have some internal function execute tx rebalance you'll come to this and then there's this main logic run and if you see the logic inside alive is quite simple it's basically you try to run the bot if it throws the editor you just cancel the error or else you just keep on keeping it alive so it recursively just calls it itself the bot just tries to keep itself alive we'll come to the main bot logic later on but let's come to the main function and first what we do here in the main function is we create like the providers just like initialize the providers so we just create a json rpc provider with the main network id and polygon network id just again on a map and then we create wallets so to sign the transaction here we use like the private key and the provider and then use the ethers wallet you can also look into the documentation ethers stocks just to so so this is the one we use we pass the private key and the provider [Music] and then what we do is we just create an instance of the parasol class that we created before uh an instance of the bot class i just name it cross chain arbitrator yeah and and then we just make the bot alive right and then wait for it cool so that completes the second part as well the draft of the bot and then we can come to the cool stuff i would say the you know the main part that we are here for the arbitrage logic so bill the arbitrage algorithm and so let's start with understanding so i mean these are just helper functions so normalize basically takes any amount and a token and then you know converts into a decimal representation so if you have like you know it has 18 decimals so 1 e18 would be 1 8 but if you have one eighteen and you wanna convert into one heat what you would do is just um yeah if you wanna convert one into one eighteen you will basically just take amount one and then times ten to the power token decimal and just this is just the reverse and you just divide so that's pretty clear and then we come to the run uh logic and so what we do is we first first just take some source amount and i just took an arbitrary amount 0.05 each that we want to try and we take the token and we normalize it so what we'll get is something like you know point zero five times one eighty right that's what we're gonna get so it will be five and then sixteen zeros um then we have the so then you call the parasol to get the first price so we call the price first in the parasaur pricing um then what we do is maybe i can just console log this so that i can we can see what happens um should be able to do that let's see so long price first right so we just you can see that we just got like a payload from the parasol api and this is the price and this is the whole payload so this is working you can see and we can i mean i don't see the route here but the yeah their best route is inside this it's like an object so yeah we need to expand this to see that if you want to see that as well um but this is cool and then what we can do is we can take the destination uh so source amount first [Music] let me see what i'm doing here yeah i'm just taking the source amount and this putting it in a denormalized form which is just yeah the reverse of the separation and then i am denormalizing also the price that we got here so basically this price uh in the denormalized form for matic so we can just just to log it and then we just you know have like good log of the price let's see you know so we so for the first swap we want to get the price from e to matic and for the main net and the source amount is 0.05 e and the destination amount is like 77.8186 matrix um cool so that's working and then what we do is so the the idea is you know you wanna you wanna swap from eat to matic and there can be some small slippage right uh a snippet so what the slippage is basically you know when you when you get a price and then you execute a transaction that you might not get the exact same price after when you keep the transaction and you can basically set a slippage so that if the price that you get on chain is less than this particular value then the transaction will automatically revert so you can set the slippage when you build a transaction in the parasol so when you when you think about the arbitrage logic you should actually consider the slippers you should consider the worst case scenario so that you always are profitable right and so if you swap from certain token to certain other token you should consider that you will be hit worst case slippage and then you should take that amount as your destination amount so i'm just doing that calculation here so you know we can cons we can take any arbitrary slippage and for the for our case we can just set it to like you know three percent slippage which is point zero three and then i i just do a simple you know whatever price that we got we just multiply it with one minus slippage so that we get like this is the actual amount considering that we will be hit by the slippage and then use this amount so you know you converted each to matic subtracted your slippage and take this amount to again get to eat in polygon chain so you know here you see when you when you do the pricing we use mainnet and then and we will do the pricing here so you again press get price and we will use a token list polygon network take the matic token uh matrix to each in polygon network and then take the destination amount with slippage so the destination one that we got from the first uh swap we will use the source amount for the next uh swap and also use polygon network as the network id and then we can again log everything see so i'm just basically denormalizing the best amount of flippage and yeah so this is basically the source amount for the second swap denormalized form and this is the stars like the the normalize of the destination amount for the second swap and that's basically matic to eat main net and we can just see both of them running together right so you see the first swap eat thematic source amount was this the destination was this and then you have second swap matic to eat and this is the diaper let's correct this this should be polygon and so you have magic to eat happening in polygon and source amount with this and the destination amount was this and you see this destination amount was 77 but the source amount here is 75 so it's already considering three percent slippage so that's working and um and then what we do is we calculate the test amount for the second swap would slip it so we we you know we need to get the destination amount of the second swap with slippage and then we check if the current price is actually an arbitrage price so what we have to do is now we need to check that if the second like the destination amount with slippage for the second swap is actually greater than the first amount right so um maybe i can use like these slides again to quickly show so you know if you started with one eat let's suppose then you get into 1500 matic but you know with slippage it would be something like let's suppose for five zero right and then you take this four five zero and you swap here right so you have four five zero and then you get something like 1.01 let's suppose then you have actually uh and then you you consider like a slippage here which would be let's suppose one point like zero five right and this is still greater than this then it's an arbitrage trade but let's suppose it was not so it was something like 9.8 right then it will not be an arbitrage shape so this is the you know basic logic i mean this is like really really like simple arbitrage logic they can be like a lot of different complicated ways to do it but you just want to like build up something that works on the scope of the time so yeah so coming back here you just basically check if the source amount first is less than the final amount that we get including slippage and if it is so we just log it that we found in arbitrage if not uh we basically just uh yes if there is then we execute this part and if not then we do this this logic and um so if there's albert we do we do the transaction executing if there is no arbitrage then we basically just you know take some rest time so we just have a constant here declaring how much is the rex time which is basically just five seconds so we wait for five seconds and then we try to check our track again right so this is the logic that we do here where we just keep ourself alive so we run and then if there was no arbitrage we wait and then we call a live again which we'll call run again so yeah and then coming to the transaction executing um so you know we we have to build the transaction parallely so first of all you know we already did these transactions sequentially so we had to like first query the first pricing in the second pricing but if you think you know the block block uh block execution time for matic is like i think uh two seconds or three seconds and also for so you know the trunk the whole um arbitrage bot should be quite fast to actually uh get the price and build the transaction every block otherwise the price will already change meanwhile so yeah i mean here we did it sequentially maybe we can improve it later on but for now uh for build build transaction actually we can do it parallely so what we'll do is basically um use promise all which is basically calls both the async operations and um recall the transaction building from the parasol that we wrote before and we passed the pricing payload pricing first payload pricing second payload we have to pass the tokens again so eat domatic market to eat here source amount first and then here we need to pass destination amount with slippage so if you remember here in the parasol we had like minimum destination amount that we had to pass this is the amount that you know consider slippage here right and so here we have like the destination amount first with slippage here and this destination among second with slippage and the network ids and also the wallets so so the wallet that this basically gives you the address of the user so for which we use the private key here so the private key that's here uh we create the the wall splits and the wallets are basically passed as a constructor parameter and that's what we're using here for the address co and then we just log that executing the transaction and then we actually execute the transaction log the transaction object and then rebalance so um before coming to rebalance let's look into the execute tx function which is here and what it does is it just basically calls the wallet with the correct network and then sends the transaction object so the transaction object that we got from the build transaction from the pricing just pass here right and that's being basically used here and then once we get a transaction object we need to wait for it so that the transaction is actually mined so the send transaction only sends the transaction but then we call the wait function to actually wait for it to be mined and that's it so then the transaction is mine but then you know if you so if you have a wallet and you have certain eat in the eat wallet and certain matic in the matter wallet and then you keep on being arbitrage at some point your eat will get depleted and you will only have matic on the ethernet it may net and like uh eat on the polygon chain so what you need to do is somehow also use maybe the bridge to put back your um polygon you know to the polygon chain and eat the each chain so that you can you have to keep on balancing basically that's why you need to have like a rebalance every time you know you do arbitrage i haven't implemented the rebalance yet because it's just you know it gets more complicated so just wanted to keep it simple but the code is completely open source feel free to you know add the logic for rebalancing it should be straightforward if you know if there's a balance which is less then you can just um use the bridge to again uh put it to the another chain and that should be good and yeah that basically completes the whole logic of the arbitrage part and i think we can just run the whole thing and test it out uh before i go to testing maybe i can answer a few questions if there was something i'm not sure how i can see the questions let me just um chats cool uh questions in the chat um question from youtube from yan does parasol support the fuse main net um is no i i don't think we support fuse yet is fuse another blockchain i'm sorry i'm not aware of that um is it also evm compatible if so you know you can reach out to us on our channels and if they have like enough liquidity we can of course look into it and support it we are always looking for you know expanding to different chains so yeah for sure uh questions from youtube is there a websocket api plan rest is just to show to run proper arbitrage um we haven't planned to use like a web socket api yet but uh good good suggestion maybe we can look into that uh but at the moment if you're just using rest yeah uh price uh to subscribe to where is the main infrastructure location um so again the same question so we don't have a websocket for pricing yet but uh as i see there is already quite you know two people asking for that so always the same same person right yeah so we don't have a websocket yet and the main infrastructure location is i think in europe so yeah uh do you have a subgraph or polygon yes we do have a subgraph for polygon [Music] and you can actually find it in the subgraph you can also paste the link give me a second so this is the subgraph for polygon um did you run in hfpuis i'm not sure what fee is and he came more than 200 to 300 swaps a day um [Music] yeah so um i am yeah i'm not sure so i mean so i haven't like really you know uh did a lot of arbitrage using this code is just just to demonstrate the idea um and yeah that's that's is any other questions can you do this with flashlights of course i think yeah you can improve the logic with using you know flashlights and stuff so that's for sure you can do that hey i'm so sorry shrees we're a little bit over time right now um if people have questions for you they can send it to you on discord um okay but i'd like to thank you again for running this workshop it was really great i'd like to thank paris swap for sponsoring 8th global and yeah everybody have a really great day if you have questions reach out to him on discord 