all righty um hi everybody welcome to the building decentralized apis on top of ethereum with the graph workshop here we have nader from our sponsor the graph and yeah if you guys have any questions just hold them off till the end he's going to do a little bit of a q a and then you guys can send those into the chat when he's ready um yeah go ahead mater uh you can go ahead and start your presentation okay great go ahead and get everything set up here all rights okay i'm going to go ahead and shut my screen off all right so can everyone see that all right i guess it's good okay yeah so thank you for um coming and checking out this presentation my name is nader david i'm a developer relations engineer at edge and node working with both engine node as well as the graph protocol and what we're going to be talking about today and what i'm going to be demoing today is how to build a subgraph using the graph studio and the graph cli and a subgraph is essentially an api on top of blockchain data that's kind of the way you can think of it so i'm going to kind of go into like why the graph exists and why you might use something like this so the graph is an indexing protocol for querying networks like ethereum and ipfs so the reason that you might use something like the graph well in the past if you wanted to build out a performant or nice user interface or front-end application on top of any blockchain data it's actually not that easy to get really good querying capabilities directly from the chain now you can hit a chain like ethereum for example and you can query a smart contract at a certain point in time for usually like a single piece of data or maybe an array of data um at that point in time from that transaction um or from the current state but it's it's not easy to for example get um more robust or more complex queries that you typically would think of needing in a real world application so for instance let's say you wanted to kind of filter or search or do some type of compute that needed to get you like a selection set so maybe you're building out something where you have like messages and you want to get maybe the friends of a friend or let's say you wanted to kind of only get messages that came in or were created during like this time period or you wanted to kind of sort or filter or anything like that it's not something that's possible directly from the chain so to get around this a lot of dapps and a lot of projects i guess you could say or applications or anyone building something on top of blockchain data what they were often doing in the past was that they were building out their own in-house indexing servers so what you basically would do in that situation is that you would spin up maybe a server on aws you would then go and look into the the contract that you're interested in saving data from and you would actually go through each and every transaction and you would save all of that data and you would store it locally and then you would build out your own api on top of it now there are a couple of drawbacks to this approach first of all you're actually breaking the the entire idea around why someone might use a decentralized data source in the first place because you're no longer decentralized you now are centralized into this one database you also have a single point of failure so if you have any issue with your own server that goes down or whatever you now have you know this just single point of failure and then on top of that it's just resource intensive so let's say you have a new idea that you want to implement and you need like a new selection set or you need a new view on top of your data you now have to kind of build out that functionality deploy it and then it's it's takes that type of work to kind of make it made available so the graph actually solves a lot of those issues by allowing developers to deploy these open apis to a decentralized network and the graph sits in between the smart contract itself and the front end so with the graph you basically have a protocol of people running nodes that are doing the indexing for you on your behalf distributed around the world so let's say that you need to build an api on top of something like an nft smart contract which is going to be what we're working with today and you want to serve up queries where people can search for an nft by name maybe they can search for nft by the creator or maybe they want to just return the nfts that they've purchased or that that they've created um so we want to build that and we want to be deployed in an api in a decentralized way you can write the subgraph you deploy it to the decentralized network indexers around the world pick up that sub graph they index the data for you you're given an api endpoint and an api key you can then query that subgraph from your application and depending on where the user lives in the world or where the user is calling that api in the world the closest and most efficient indexer to that user will be serving up the data so you end up having not only a performance api at the actual implementation level but it's also being served geographically closest to the user or the application calling the api so that's kind of an overview of what the graph is there are a lot of applications using graph so you know some of the more popular ones that you may have heard of or you know projects like unit swap foundation um synthetics um if you go look at the graph.com and go to the graph explorer you can kind of get a good idea around a lot of the different subgraphs that are out there decentraland a lot ens you know a lot of these are popular adapts so there's a lot of subgraphs that are out there a lot of projects using it in the real world growing pretty quickly we hit over a billion queries in one day in july which is something that we thought was really cool and are now over 20 000 developers that have built over 16 000 sub graphs and this was actually data from a few weeks ago so it could be even more than that at this point so the ui looks something like this you have a view where you can kind of drill down into anyone's subgraph subgraphs are public so anyone that deploys a sub graph it's available to anyone that wants to look at it use it signal on it which is something i'll talk about in just a moment or just kind of get the data about what's going on so when this sub graph launched there was a lot of grt that was curated on it again something i'm going to talk about in just a moment and it kind of tells you all the the metadata about the the subgraph so here you can see things like the overview the indexers the curators and the playground the playground is kind of like a an api playground so if you ever worked with something like postman in the rest world as a developer you may have been able to kind of just input an endpoint and you're able to query that endpoint well with graphql you have something called graphical the graphical editor that we've built in and you have self-documenting entities on your right hand there where we have like the unit swap factory the token the pair and the user and then we have the query playground on the left where you're actually able to run these queries and get data back so the graph is powered by a network and there are a few different ways that participants participate in the network to make it the decentralized and make it work the way that it works so you have indexers you have curators and you have subgraph developers and then you have delegators so to participate in the network in one of these different roles you would um acquire some grt some graph tokens in some way and let's say that you wanted to run your own graph node then you could participate in the network as an indexer running the graph node software you would basically be able to index and save data for other people's subgraphs and serve that up you would be participating in the network in that way as an indexer you earn a portion of the query fees paid to the server or to the api you earn a portion of those query fees and you also earn a portion of the tokens that are made available as rewards to the entire network so there's something like percentage inflation from the total tokens that are available that get paid out to anyone that's indexing and the same thing goes for people that are deploying or a sub graph let's say that you have a good idea for an api you deploy it to the network and you want people to use it you would then become a curator by staking some grt to signal that that sub graph is a sub graph that people should check out and use once you signal on the sub graph indexers will start picking it up and indexing the data and then you also will return uh yo i'm sorry you'll receive query fees as well as indexing rewards or network rewards i would say so that's kind of an overview of the network um so how do you create a subgraph well you initialize the subgraph and using the graph studio as well as as well as the graph cli you define the data sources that you would like to index so for instance a data source would just be a smart contract address so we might say we want to index data from the cool cats um you know smart contract or we want to index data from like the crypto punks or in our case we're going to be working with zora which is an entire marketplace you then define the entities that you want to save so in a case of an nft marketplace an entity would probably be something like a token a non-fungible token and then you model that data in graphql which is a schema definition language or i would i would just actually say more like a data modeling language and also um you know a graphql schema is the data model and then the graphql is the actual api implementation and then you uh configure your assembly script mappings which is kind of like the only code that you you actually need to write to make uh to build a subgraph and then you can deploy this to the network and this is what we're going to be um working on today so we have 17 minutes so let's go ahead and try to see if we can't do this and i'm going to be working off of a workshop so if you're watching this or if you're watching this at a later time or if you just want to check this out at a later time you can go to github.com dabit3 and then you can find a project called building a subgraph workshop and this is the project that i'm going to be following today so here i am and i'm in the workshop building a subgraph workshop and all this is it's a combination of a readme a github readme that kind of describes how to do this it's kind of like a tutorial and then there there is an actual uh zora nft subgraph folder that has the code that we're about to write so let's go ahead and start doing this so the first thing that we want to do is we want to go to thegraph.com studio and if you go to the graph.com you'll see that we have this drop down menu here and we've added now the graph explorer and the subgraph studio we would click on subgraph studio and here we're going to go ahead and click connect wallet and we're going to go ahead and connect one of our wallets we're going to assign the requests and now we're in our explorer our own personal explorer i would say and we're going to go ahead and click create a subgraph so i'll call this something like like youth global api or something like that and now we have the place that we can deploy our subgraph to so we have the subgraph slug which is kind of like this right here we have the deploy key which is what we're going to need for authorization and then we have some other metadata here so if we did deploy this you could kind of set the description the code url like on github your website as well as up to three categories all right so now that we've created that we can go ahead and initialize a subgraph locally using the graph cli so you would npm install g graph protocol cli there which i've already done and then we're going to go ahead and use the graph init command and i'm just going to copy this command here and i'm going to kind of walk through it from the command line so here we are in an empty directory and here we're going to say graph init and i can pass in a few different flags so the first flag is going to be the contract name so if your contract address has multiple contracts you need to define which contract you want to to build your sub graph off of like what is the main contract in our case it's going to be token and you can add multiple contracts of course but for us we only need one we're going to pass in the index events flag which means it's going to look inside of the contract's abis and it's going to look for any event and it's going to automatically pull down that metadata and create some boilerplate code locally for us because the way that we're basically getting that data that we're going to be indexing is from these events so for instance when a token is minted there is a transfer event that's emitted when a token is transferred that same transfer event will be emitted and then also there is uh events that we're going to be listening for for when a token has its content or metadata uri is updated so let's say you have an nft you change like the the description or whatever like those events would be handled here and then finally we have the from contract address and we can go ahead and just hit enter and this should go ahead and set all this up the only thing we need to pass in is the sub graph slug from the dashboard here we can go ahead and accept all these and this should go ahead and create our new folder here so once that's created we can go ahead and change into that new folder and we're having you know some stuff being installed right now some node modules but while that's installing i'm going to go ahead and open this up in my text editor so the three main things that compose a sub graph are the graphql schema located at schema.graphql like i mentioned before that is the data model and i can go ahead and just kind of delete that for now we're going to fill that up in just a moment the other file that we're going to be working with is the subgraph.yml the subgraph.yaml is the configuration that tells the indexer you know what information to index essentially it kind of like describes your subgraphs to the indexer so we're going to open that and then the last thing that we're going to open is our mappings because i mentioned before the mappings are going to be the code that we actually write to describe i'm sorry that that matches i would say the data coming from the events to our data model all right so for the graphql schema we're going to be indexing data from zora so if i go to zora.co i see that we have these nfts and stuff so basically what i want to do is say okay let's get you know an nft and we might want to get like the the price or the metadata whatever information that we want to get on it so um we let's go ahead and create an entity for token and then we also might want to have uh relational data or links because i can actually click on this and then i can also look at the author or the creator and i can see all the nfts they've created right so how might we model our data so we have relationships like one-to-many relationships many-to-one relationships those sorts of things so for us to do that we're going to have two entities and our data model is going to consist of a token and a user type we're going to have different fields on each of these so when we query for a token we want to have different fields on that token so we might want the token id of course we want the content and metadata uri because this is going to be where the actual nft images is images and other information and then we might want you know whatever whatever other metadata we want to associate or that is available so we might want to be able to sort by when it was created so we can kind of show the newest nfts or whatever um we also are going to have fields for creator and owner this way we can have relationships like i mentioned before the other type is the user type and the user is going to be able to have an array of tokens that they've created an array of tokens that they've purchased so we have like those two different um relationships and we can actually do the one-to-many relationship here like a user has many tokens by using this at derav from directive which is part of the graph cli and graph um node it's kind of like part of the api for that and to create the relationship all we really need to do is pass in the field from which the relationship is derived so and this relationship is derived from the creator of the token which is going to be an address and this relationship is derived from the owner field which is also going to be addressed an address so we can go ahead and save that and we're done with that so we can go ahead and close this the next thing we'll check out is our subgraph configuration and the first thing we might do here is look at the entities so the two entities that we actually created in our graphql schema were token and user so let's go ahead and like open up the update that here so we have token we have user um the next thing where we need to think about are like what events that we want to listen for so in our case i mentioned we want the transfer events the metadata updated and the token uri updated so we already see that we have these event handlers created for us and these were created because we passed in index events meaning that we told the cli to go ahead and look in the apis and generate this boilerplate code for us so we can actually keep almost all of this the only thing that we want to delete that we're really not going to be working with is the approval and approval for all so we have token metadata uri updated we have token uri update and we have transfer so we can kind of like work with those three events and the last thing we need to do is actually handle these events as they are are handled so when we deploy this subgraph to the indexer it's going to go and it's going to find this smart contract address and it's going to look for any of these events and when one of these events is is fired it's going to call this function here passing in these arguments so we're going to be going like transaction after transaction after transaction and every time that we find one of these events we're going to call these functions now we can also tell the subgraph like where to start because if we don't tell the subgraph where to start it will start at the genesis block so let's say we want to say a start block and then here we can deploy our subgraph to start indexing from the address i'm sorry from the block where the contract was uh first deployed itself so i can go ahead and just set the start block here you can find this very easily on etherscan and now we're pretty much done with the subgraph.eml in order though to create our mappings that will handle these functions we're going to need talk to both the graph node to kind of like save the information but we also need to talk to the smart contract itself so when you're dealing with the nfts the erc721s the only three main pieces of data that you're going to have in this event are going to be the address from the previous owner the new owner and then the token id so how do we get the other metadata and to get the other metadata we need to actually talk to the smart contract so graph has a library called the graph typescript library and we can actually generate a bunch of helper code for us to kind of do that using the graph cli and all we really need to do is kind of just make sure that we're in the right directory here and we can run graph code gen and the graph code command will now look at our updated graphql schema and our apis and we'll generate a bunch of boilerplate that will allow us to interact both with the graph node as well as the smart contract itself now that that's been created we have this updated generated folder where we have a schema and if we look at the schema it should kind of match our our graphql schema where we have a token and a user we don't really need to ever touch this code just kind of showing you that it's there yeah lesson set up so when i fork i forked it on my github the the branch from the github link forking and cloning are one and the same right because we'll bring it down locally and then forking it we'll just have it copied over to your github repo but yeah either way it's fine if you want to get a copy of it yeah thank you sure and and i think the last thing we need to do is just to write our mappings so if we go to src slash uh mappings here we can go ahead and just start we can really just copy all this code but i'm going to kind of go through it uh slowly a little bit more slowly even though we only have five minutes left i'm gonna try to just kind of walk through a little bit um the things that we're gonna be interacting with are going to be again the graph node like saving or or even in the future if you need to reading from the note itself and then also talking to the contract itself so in the generated slash schema we have some code and some helper functions and stuff like that that will allow us to talk to the graph node and then in this token folder token.ts will give us helpers and functions and even events for type safety that allow us to talk to the smart contract so we're just going to import the ones that we want to work with there so token and user token uri updated event token metadata uri updated event and transfer event so like these are the three events and um this token contract will give us an api to talk to the contract itself and then we need to just handle those three events so the three events that we're going to be handling our transfer again handle transfer um handle token uri updated and handle metadata url updated and all these do are just match these three handlers here um and they can be written of course in any order we're just making sure we export those so the main function actually like with the most code here is this handle transfer and i'll walk through this when this this function is fired this means someone's either minted a new nft or they've transferred ownership of an nfc so in uh because of that we need to take um in consideration that there may be a token in existence or this might be a brand new token okay so if there is a token we go ahead and try to go ahead and fetch it right here and if it does not yet exist meaning that it is not yet in the graph node then we need to go ahead and create it so we go ahead and create the token we set the different fields that we've defined in our graphql schema like the creator and the token id we then also set a couple of other different fields by talking to the smart contract itself because we did not get the content uri or the metadata uri in the event so we need to actually go into the contract talk to it ask for that information and then we kind of save it here so the token if it doesn't exist we create the token and then we update or set the owner because if it's transferred to a different owner or it's being minted either way we want to set the owner field and then we just save it so this saves the data to the graph node and then we do this similar thing for the owner or for the user i would say if there is that user existing we go ahead and um do nothing i would say but if it if the user does not exist we go ahead and create the user and then the the last two handlers are really really simple all we're doing is updating the token uri or the metadata uri so we just say token metadata uri is equal to the new value that comes into the event and we just save it so these two functions are very simple all we're doing is updating either the token uri or the metadata uri and then from there we should be done and we should be able to go ahead and deploy this so to deploy we need to first authorize so we just run this graph off dash studio and this is going to go ahead and prompt us for our deploy key and the deploy key if you remember we can just copy it from our graph studio dashboard here to our clipboard just paste it there and then the last thing we can do now is we'll go ahead and copy the slug and we can say graph deploy dash studio pass in the slug give it a version it doesn't really matter what version you give it and this should go ahead and deploy and if deployed successfully you should see something like this where you have an id for the build and then you see where your api was deployed and if we go to our dashboard again we should see that the data is starting to be indexed and right away we see that it's already 100 synced meaning that it's literally gone through and indexed every single event and we should be able to start querying for it so if i hit query then i start seeing that we have our data coming back and we're given like an example query where we're kind of just returning the first five tokens but we can also do which is one of the you know reasons that people use the graph filtering sorting you can do full text circle types and stuff so one one thing we might want to do would be like let's try to return one of these items that we're seeing here because we want to get one of the more recent items so we might say order by created at timestamp and then we can say like the order direction [Music] is like descending because this way we can just bring back the most recently created nfts and then we see that we have like the token id being you know 41 whatever so let's go ahead and copy this content uri and see if this matches any of the nfcs that we see there so we have that looking thing there i don't see it here but you try this one more time maybe they have not refreshed with like the newer stuff because this should be like the newest thing i think created oh there we go so that's this is the newest thing that came back and then that's right here so we're getting the exact data the same data that zora is serving up now we're running we're about finished on time so i'm not going to go into publishing to the network because right now we're kind of in a sandbox and we're not really published the decentralized network but if you wanted to publish this and start you know testing it out in a development environment you could publish to rinkaby if you wanted to actually start you know using this in production or having other people like pay you to use it or whatever or um you know shout out a signal towards it with grt you would publish to mainnet which would be something you probably don't want to do until you're ready you know for sure because to make an update you actually have to deploy a new subgraph but anyway so that's it and i actually cover that part in this tutorial as well so um there's a link to a video here and also a link to a full tutorial that shows you how to deploy to the network there and that's it so thank you for checking this out um if you want to follow me i'm on twitter and i'd be happy to answer any questions twitter.dabitdurie and hit me up with any questions that you might have there all right thank you so much nader for running this workshop for us and thank you so much to the graph for sponsoring hackfest this year i want to encourage you guys to continue this conversation in the graph sponsor discord channel um and yeah that's pretty much it for the workshop thank you guys so much for coming and have a great rest of your day 