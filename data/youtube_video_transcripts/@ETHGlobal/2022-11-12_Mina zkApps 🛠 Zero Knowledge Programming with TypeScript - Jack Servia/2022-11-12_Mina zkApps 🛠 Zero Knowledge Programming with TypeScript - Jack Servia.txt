foreign [Applause] [Music] hi everybody thank you for being here I'm uh Jack and I am a developer relations engineer at of one Labs we're the company that incubated the you know protocol and and now we uh continue to build uh tools for mina um and that's what we're going to talk about today is Mina and snarky JS which is the smart contract language for Amina so um yeah here's our agenda we have uh sorry this is like in the way a little bit I'm gonna be like that um okay so yeah first we're going to talk about snarky JS which is uh a typescript library that you can use to build your knowledge roofs and it's also the smart contract language for the amino protocol we'll go through an example building um a simple contract that will let you you know uh only increment a number if it's the next number in the Fibonacci sequence and then we'll make it recursive which is a strategy that we can use to allow this code to um uh uh uh actually we'll just cross that bridge when we get to it um we'll talk about the Munich protocol which is sort of like a more General um uh uh sorry we'll we'll just all right we'll jump into it so it's not ggs uh it's a typescript library for defining zero knowledge proofs and it's also the smart contract language for the amino protocol and it looks like this but you don't have to worry too much about that because we'll dive in in a lot more detail in just a second everything is in typescript so you can keep using the tools that you're familiar with like prettier eslint vs code npm and it's very easy to learn the intellisense is so good that I think probably most people can can just uh dive into you know a repository of existing code and kind of make sense of it just by yeah hovering over the things that they don't understand and we have good descriptions of what it all does it's also extremely powerful um and this is for two reasons the first is kimchi which is our proof system and it's absolutely state of the art it has a number of features that are you know really unique to it and it's extremely well suited to this use case um so first of all it has a fully trustless setup so there's no ceremonies there's no sort of toxic waste just works we have custom constraints for Poseidon elliptic curves and encryption um so uh this makes operations that you'll end up doing a lot dramatically more efficient the proof size is constant so you can do as much computation as you want and the proofs always stays the same size and is the same computational complexity to verify it's recursive which means that you can actually create a proof and then verify that proof inside of the process of creating another proof um and that has uh a lot of really uh sort of cool implications that we'll talk about a little later uh and finally it's plonkish so we can add new features like Dynamic array access and a few other things we're working on uh what about the snarky dress Library so this is the other side of the equation um the sharkyges library we've built to be as easy to use as possible and as expressive as possible um and so yeah uh method chaining makes it very easy for developers to think through their programs in a linear way you kind of think like here's my data here's what needs to happen to it here's sort of where it ends up and it makes it more sort of apparent uh what's happening inside your contract versus what's just sort of happening uh like in in maybe like code that runs uh prior to your contracts execution or something like that um so yeah we can see what this looks like um if we want to know uh if you know this guess is is not equal uh to zero we can you know call this equals method uh and then and then just chain on to the end of the not method um and we can do the same thing like you know if we want to add two values together we can we can call just this add method on white Peg Zen and pass in uh um uh in an argument so uh custom circuit values provide a layer of abstraction that makes data a lot easier to think about this is uh basically a class that we have that you can extend in order to create um in this case we have pegs this is like four pegs on a on a as part of a board game um fundamentally zero knowledge groups require that everything that you work with is is represented in this uh type called a field it's it's a basically very similar to unsigned uh 256-bit integer except for that division works a lot differently um and yeah it's not too important to dive into like uh why this is necessary but it's universally required by all of the zero knowledge proof systems that exist today and it makes uh programming a little bit harder especially when you're getting getting started um and so the circuit value abstraction will let you uh define basically you know a way to take some uh type that you're more used to working with like in this case um you know uh like a JavaScript object uh that has um you know four values for each of these pegs and and then it'll map it into these field elements for you and do the inverse uh when it comes time to you know take something uh from the representation in the circuit into into a representation that's easier to work with um and finally a lot of the stuff that you need is already implemented in snarky JS so uh what we have included today is all of these types um efficient Poseidon hash functions efficient encryption and decryption um efficient signatures uh Merkle trees and the recursion API um and so all of these types are circuit values uh that are again constructed out of this this field element ultimately they're you know composed of the field element but you can work with them just just like you're used to working with uh you know like an unsigned 64-bit integer in in whatever other language uh so why did we choose typescript uh and the reason is because we're ecosystem focused and uh uh zero dollars groups are cool because they you know open the door for cryptographers and stuff to build uh crazy new things that that make it things that seem intuitively impossible possible but it's also really cool um if we can then make this available to people who uh you know want to build protocols or products that are user-facing and so that's kind of what we're going for we're going for uh like code reuse that's as high as it is in the JavaScript ecosystem um and uh yeah so we'll also sort of touch a little bit more on this a little bit later um so here's kind of uh everything we talked about and just you know there for the sake of if you go back and look through the slides after you can get like a condensed kind of view of everything um so how does snarky jazz work oh and also the slides will be available after there's a QR code you'll be able to scan it and it has all sorts of information everything I talked about it's good uh so how does Snapchat work um here it is in five sentences it's a typescript library all the information is represented in one of the snarky desk compatible types which is eventually you know all of them are composed of this field type um and then starkeyjs provides classes and functions that are compatible with the field type and uh it can represent anything that you do using these you know methods on these types as like what's called an arithmetization which is basically a math problem representation of the program which is important because then uh we can feed it into the xerinology system which is itself basically a math problem um and so a user that's interacting with starkeyjs program can run it you know as normal typescript and then uh if they want to they can actually pass all of these values that are computed as they're running it basically they can pass their like execution Trace into this math problem that we generated um and and use this to create a zero knowledge proof and so uh yeah the developer experience feels very much like uh if you view something like react um you know it's like yeah this is like pretty much uh JavaScript but we have maybe like another layer on top of it now that that's like expressive and kind of helps us do something specific and so um uh it's pretty easy to get started with um and so okay so how did the smart contracts work um and yeah developers write them in typescript and then they deploy just the verification key to a ziki app account so the verification key is like a commitment to the code with the added property that it can be used to validate these zero knowledge proofs um that are generated by the code and so when you know we want to deploy a zika aptamina we just send a transaction with this verification key to the meaner Network and that's the only thing that's stored on chain so the code actually doesn't live on chain only this verification key lives on chain uh and then the users run the smart contract in their browser and they generate a zero knowledge proof of their interaction so the code doesn't run on the Chain it actually runs in the browser um and this is cool for a couple of reasons uh yeah so we send the transaction it's a zero knowledge proof if it's valid then the transaction is applied and if it's invalid then it's dropped um so if the mean of blockchain can validate the zero dollar Truth uh it commits any relevant State updates and this is kind of what this looks like uh like from a higher level is we have you know the smart contract method we pass into it some arguments that the user generates some smart contract States so this is actually the state of the smart contract it has to be passed in as an argument I mean the reason is because the smart contract you know doesn't run uh on um the blockchain and so yeah we have to grab the values uh pass them in and run them ourselves and then we also get some values for the state of the world so this would be things like block height if that's something that's important uh in your um uh transaction and then what we get out is uh updates to the state of the smart contract and updates to the state of the world and so like when we're on a smart contract on Mina uh like what it ends up looking like if if we have something that has a net effect of you know transferring some balance from you to me let's say um what I'll actually do is I'll just send a zero knowledge proof as well as you know two new values and so you know one will be your balance which will be lower and one will be my balance Which is higher and as long as the zero knowledge proof is is valid um then we know that's legal and so we can just you know write these two values um uh that's more on that uh so how do CK apps work um you can install your smart contract into your UI repository and deploy it and that's all there is to it uh the smart contract is you know a bunch of typescript code you can put it on GitHub or npm or whatever um and then you can just install it into your your front-end repository with npm install um very simple okay so now we'll get into like you know a code example um so the Fibonacci sequence is a sequence of numbers that's uh each next number in the sequence is the result of summing the prior two numbers together um and we'll write a smart contract that will compute the next number of the Fibonacci sequence it'll have two pieces of State n minus two and N minus one and it'll have a single method update and this will let us update n minus 2 and N minus 1 if we pass in the correct number uh the correct you know next number in the Fibonacci sequence uh and so to write a CK app we can just extend the smart contract class of snarkyjs um so we have a smart contract called Fibonacci Sequence here and then we can Define our on-chain state and this is done we just have these variables and we add this state decorator and pass in as an argument the type of the state so here we're creating um two pieces of State uh each one has the field type and this will live you know on the actual Amino blockchain and and snarky just will sort of do the work to say uh we changed this we proved that we changed it the right way and we made sure that the media Network got um you know the request to change this um the next thing that we have is we have this deploy method and this is actually a method that gets called as the smart contract is being deployed so this deploy args is a thing that usually the z cap CLI which is a piece of developer tooling we'll talk about in a second um we'll pass in um for the most part you you this can stay exactly as you see it here in most contracts it can be used uh to configure a couple things at deploy time like set permissions for the contract and or for the contract account and stuff like that and in this case we're going to actually also use it to initialize the value of these on-chain state state values um and so we'll set n minus 2 to 0 and N minus 1 to 1. uh the next thing is is we'll add you know our actual method the users will call update and uh you can see update takes uh n as an argument which is of the type field and we add this method decorator um and the method decorator basically tell snarky Jess hey this is code that um users are going to call uh the same way that users would call you know like a method on an ethereum smart contract um and you know when users do call it we should prove that uh it executed correctly and then you know send it send this on uh to the to the media Network um so something that's worth calling out here is that uh any argument that we pass into the method and anything that happens inside of the method is totally private it happens in your computer and it doesn't leave your computer unless it eventually uh you know does something like emits an event or sets some piece of on-chain State um but even in those cases you could emit an event which is like a hash of the real value and have like a commitment where you could store a hash of the value um you know it's it's much easier to keep even even like uh permanent storage uh private in this way um but yeah that's that's worth calling out um finally uh we'll you know start to like make the functionality of of this method and so um the update method uh uh here we want it to to grab uh the value of these you know n minus one and minus two uh on chain state uh variables and so uh we just call the get method on on N minus one and N minus two and we set it into this you know constant Uh current n minus one and current n minus two um and so when the you know smart contract runs that's this get method basically says contact the mean to blockchain get the values store them here um the next thing that we have is uh uh we'll compute you know what the the new state what the next number in the Fibonacci sequence should be and we do this just by you know calling the add method on N minus two and and and passing it as an argument n minus one and so we have the sum of the last two values then in this new state um and then we assert that it's equal to the value that we passed in and so this assert equals statement means that uh if we don't if this condition doesn't hold true it will not be possible to generate a zero knowledge proof that's valid um and so yeah if you pass anything other than the next number in the Fibonacci sequence into this method uh you just won't be able to get a valid zero knowledge proof out and so you you won't be able to send a valid transaction to the media Network um then finally what we can do is we can actually set this on chain state to something new uh and so we'll set uh n minus 2 to current n minus 1 and we'll set n minus 1 to the new state and so you know this is just sort of Shifting everything over one um and so when we do this also again Mina will make sure that uh you you can't write you know you can't call these set methods unless uh everything that's happened is is sort of attested to with this valid zero knowledge proof and so um yeah this is like you know just as secure as doing this directly on like another blockchain you know setting some kind of state from within your contract um this is kind of like the general structure of this we have generally we Define our on-chain state sort of at the top um we have our deploy method and then we add you know the actual user callable methods below that um so uh this is cool but uh what else can we do uh well we can make it recursive and and so this is something that's unique to to the way that Mina works and uh to our proof system at least it is right now um and this is uh that our zero knowledge proofs can actually be passed as arguments into other zero knowledge proofs and validate it inside of those zero knowledge groups efficiently and so what this means is that like I don't know if I have a lot of computation I might you know split it into like this you know 10 different chunks around each of these chunks prove that we ran it correctly and then actually take those proofs and prove that we've like aggregated them together correctly um and so yeah we can uh embed recursive proofs into each other uh with arbitrary branches and merges and we can do it an infinite number of times and this is made possible with this ZK program uh thing and so this is basically a smart contract without um uh it's like sort of a stripped down smart contract it's just the program smart contract is kind of a superset of this um and so we Define you know a public input some methods um but what we can see is that for for our private inputs here we're actually passing proofs in and we can see that the method here takes you know still an N value but it can also take in um uh this FIB one and FIB 2 which which are are both proofs of the same kind that this will generate so this thing makes a proof um and then it can actually also take the proofs that it makes as arguments and make another proof from that and so what we do is we you know we verify these two proofs um and then uh we do basically the same thing that we did earlier and so so this is uh um can be quite powerful in a lot of cases uh it lets you do things like build um if you want to do something like build a game but you don't want to have users wait for blocks and and pay you know gas every time that they uh want to make a move you can actually you know we can set the game up in such a way that like uh I make a move I prove to you that I made the move correctly you actually uh you know look at the proof that I made my move correctly make your move and then prove that your move is correct and also prove that you've verified the proof of my move correctly and then we go back and forth this way and at the end we have a single proof the same size as each of its you know prior proofs we're not like creating more and more information here or just back and forth um this you know fixed size chunk um and uh and at the end um we have this proof that attests to the entire history of the game and so we can actually uh submit that proof uh then to the mean of blockchain in the form of like a transaction or something and settle the whole game in just one transaction so no need you know it's a basically very good ux same as like in a normal game because you don't wait for blocks and you don't pay transaction fees only at the end uh and so it's pretty straightforward we can just wrap our ZK program inside a proof class um and then we can uh yeah pass it in with this uh you know uh uh I guess uh yeah we set the the type of of the argument that we pass in to be this Fibonacci Sequence proof I mean and then we just call you know verify and and as long as the proof is valid then we go through if the proof is not valid then again uh it's impossible to generate a valid proof of you know this bit um so pretty cool okay so now we get to like kind of the interesting part this is like you know a tool that you can use to build stuff and then you can use to build things for mina um and Mina is a layer one blockchain that proves its entire finalized State using these recursive zero knowledge proofs um what this means is that it doesn't grow it stays a fixed size over time or at least the amount of information that you need in order to validate the current finalized state of mina stays a fixed size and so that means that uh like if I have an account I can store the state route a proof that the state route was gotten to like via a legal sort of path and then you know uh all the information for my account that I need in this 22 kilobytes um so this is really cool but it's actually also really useful and uh there's quite a few reasons the first is privacy so ethereum smart contracts run on every single node and so the information is all you know public um media smart contracts are out in the browser and so the arguments and the intermediary values are private by default uh you can see the only thing we send is our state update and our proof and we verify the proof and then we update the state if it's a valid proof um it's also opens the door to to being able to scale things uh more easily so there's no gas model um zika apps run off chain and the amount of the computation does not affect the transaction cost um you can do actually as much computation as you want to inside of a single transaction you can make these transactions asynchronous you can sorry you can make this computation asynchronous you can do all kinds of crazy stuff because it's literally just typescript code that uh then you know proves that it ran correctly and we get this fixed size proof no matter how much computation we do um so that's pretty cool and then you can also use this to build these application specific Roll-Ups which is this uh kind of idea like the game that we talked about a little bit earlier um we can build uh basically we can because we don't need the whole network in order to prove that that we've uh sort of ran something correctly we're depending on you know cryptography instead of Game Theory we can prove things in more narrow contexts and and then only settle to chain when we need to um and so this this makes it possible to build all kinds of things that would just be it would be too expensive to build them on on even very scalable blockchains today um finally it increases decentralization and the reason is because it's possible to validate you know the whole mean estate using only the small zero knowledge proof and so there's no need to rely on like a trusted third-party node operator like inferior um people can you know connect directly uh and it also makes bridging easier and this is pretty cool so smart contracts on other chains they can Bridge the entire Amino State just by verifying the most recent proof so this is like uh you know there's no sort of like uh multi-sig or or weird sort of can I don't know it's not like a normal Bridge it's basically like uh you can ver verify that the Mina consensus has worked correctly and worked up to a certain point just by taking this most recent proof and uh verifying it and so if you can write a smart contract that can do that on ethereum then you can Bridge the whole state to the home unit state to ethereum without introducing any additional trust assumptions um and without having to lock any kind of like you know liquidity anywhere and without having to uh yeah there's nothing it's very simple you just like a user basically says hey here's the meanest or you know the mean estate route and and the zero knowledge proof of it I'm just going to call this method on this ethereum contract pass in the state route and and the zero knowledge proof this will vary you know this contract will verify the zero knowledge proof and if it's valid and if the block height is higher than the last one then we'll just update the state and and so it's very very cool um and actually the nil Foundation is working on this and they have a demo on testnet and so if you want to there's also a link to this in the QR code at the end you can experiment with this uh this you know which is the whole mean estate uh to I forget which test now but one of the ethereum test Nets and this is an audit now um we also have oracles uh so users will be able to create TLS proofs that can bridge data from any website onto the mean of blockchain um and and the way that this kind of ends up working uh is that um right now uh when you go to like a website you get the little lock on the side of your browser and this is like in the result of an interactive process and it basically guarantees like hey I really am connecting to Amazon they actually are Amazon I'm sending them my credit card information and I know that nobody can see it basically um so it makes these you know guarantees but it's it's in an interactive process and so it doesn't work for something like a blockchain I can you know Amazon can prove to me that they're Amazon and that we had like the interaction we had but they couldn't prove it to ethereum um because yeah I I it would have to be this you know sort of interactive thing they can't just like generate like a a signature or something that says hey this all worked nicely um but was your knowledge proofs you can take these interactive processes and turn them into uh you know like static uh non-interactively verifiable proofs and so uh doing this with Mina this this will allow us to you know basically you can go to whatever website you want to you can prove that you really went to that website that the website really was the website you know uh they really had the the certificates for their like their domain name or whatever um and that they really sent you something and so I could do something like I don't know prove that I logged into my bank account and they sent me a web page that says I have a balance with X number of dollars and then I could actually take that proof and I could uh feed it into another proof that says uh like let's verify that Jack is a unique person by hashing his social security number or something and checking that it's not in a list and then also let's check if Jack has more than like one dollar um and then if I have more than one dollar uh you know uh we spit out a Boolean true and if I don't then we spit out a Boolean false and so we can augment this information as much as we really want to um and actually also uh probably right after this presentation we'll have a tutorial live that uh lets you build something similar to this for it's like a fake credit score Oracle it's just a uh a um uh API that returns a fake credit score and is signed and so so you could do this today with signed data um but but ZK oracles will allow you to do is is you know uh also have like sort of signed uh data that comes through a nestl Exchange um so that's pretty cool and what else well we actually don't know everything that's possible yet and this is what we're hoping that uh people like you guys here help us figure out um there are a lot of things like probably every six months it seems like we've found out new things that are possible that we didn't know uh were possible you know yeah six months ago and and uh yeah so that's the point of coming to hackathons and having people like you build stuff there's probably a lot of cool things that are possible to make that we haven't thought of yet and um you should build them uh and we have prizes we'll give you money if you build them um yeah so uh where to learn more and questions and answers uh how do you get started super super simple it'll install the z cap CLI this is our only piece of developer tooling it's very powerful and it's very simple to use um it will you know you run ZK project call it something and it'll spit out a repository with some scaffold code it's just a the scaffold code is just a smart contract that adds I think two numbers together and stores that on chain um but testing stuff all set up linter all set up everything good to go basically and then when it comes time to deploy it the ZK app CLI will connect to a test net and you know create a transaction that deploys this application um so yeah you can install this really easily and you can just get a project and like I said the easiest way to get started install it get a project and just poke through the code use intellisense and see you know what's going on it should be pretty straightforward uh ways that you can get involved with um the community are we have zika apps building them that's a good thing um you can make educational content or you can sort of do mentoring like hanging out in Discord and stuff Mina Foundation has quarterly grants that are backwards looking so if you do something cool maybe in like two months though they'll give you money or something like that um and then finally uh these are our social media Pages here's the Discord uh here's the link to our docs and you should definitely uh join the the zika app developers Channel on on um on our Discord uh this QR code here has a link to a notion page that has the slides for this presentation links to a couple of other presentations that have information on other things uh link to the nil Foundation stuff um basically all the information you want is behind this QR code I think that's all uh yeah thanks everybody for listening awesome 