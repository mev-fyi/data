[Music] [Applause] [Music] hello does it work yeah so just gonna wait a few minutes maybe some people are going in or out and then we start in like one or two minutes so well i think since the talk is a little bit short we just jump in and if people stream in later then we should still be ready for the code examples and and the technical details so let's see uh hello i'm chris from flashbots and here's my colleague matthias and we're happy to give a introduction for developers in what we do and how you can actually play with it and with our infrastructure so i guess i would like to know who is already familiar with flashbots here all right have you used a flashback protect already too i send a bundle ever manually all right okay that's good then we have a little bit of context then we dive into more of the technical details so if anybody's interested their slides they are online and it's linked again at the end so the talk is titled flashbots for solarpunk supercoders and it's because we share the democrat democratization values and their openness and permissionlessness and maximizing the social good ideals at flashbots so we really try to contribute to a open permissionless system where much of the value is available to the community that is very important like we really strived how to open supporting also the future of ethereum in this talk it's um just a little bit about us flashbots which apis and services we have and then come on libraries to interact with us and then i show you a couple of code examples and there is an example project that you can clone [Music] i'm not sure uh if you're familiar with the background with um pga wars and and miners uh searchers uh trying to extract value from the public mempool and miners doing their own things like front running and backgrounding transactions and this was having a very centralizing force and flashbots came up with some research as a basically a research collective that focused on illuminating the dark forest which means making that what is happening and what is going on more transparent with in form of writing of videos of data we have a bunch of dashboards that quantify the amount of mv that is extracted and also about how to tap in to that how to become a participant in the whole network to democratize it so that not only a very small group of privileged players have access to this but that this is a decentralized nature where people where everybody if you have ideas you can just tap in and become a participant in the network and this is a very very important thing because the centralizing effects they just also compound and the distribution of the mvp benefits so our goal is to maximize uh social goods as well there are some writings like you can easily find on writing slashbots.net or on docslashbots.net there's a lot of background and context that you can find there things we do let's get into the more practical side we have the flashbots relay flashbots protect we have mav inspect so the relay is which basically is the central entry point for the bundles and simulations that forwards the bundles to the miners so you can use this api the api is a little bit tricky to use because you need to sign the requests there's a couple of wrappers that you can use in libraries for python go javascript typescript rust and i will dive into them later flashbot protect is a user-facing service where you can set your wallet endpoints to rpc.flashbot.net and it will route valuable transactions through flashpots so your transactions will not get front run and you also have a reward protection with that you can actually disable the reverb protection by using protect with fast mode which routes direct the transactions without simulation to the miners so there's a if you just visit rpc.net then you will have a table with the advantages of both approaches but it's usually a very simple way to protect your transactions from being front run by bots from the public mempool without needing to do any any signing or anything it's like just a meta mask endpoint or whatever mvv inspect is a python tooling that automatically inspects the new blocks and the blockchain also historically to quantify mvv opportunities be it front running backgrounding arbitrage and other things we have a pretty wide range of of things that are quantified there and the data is shared on dashboard and explorer.net so with that if you want to have some charts that give you insights into uh how the trends are developing over time this is also most of this is also open source software so we appreciate contributions it's pretty easy to jump in it's very easy to participate on open issues or prs or get the most of these things even running locally for yourself of course we have mavgaf which is a go ethereum implementation that has a couple of additional features so you can do transaction simulations there where you can send in a bunch of transactions a bunch of bundles and it will simulate those against the state that you specify and then it returns you the value difference for what is it warfare minor and you get a couple of additional informations about individual transactions and it's very useful for quickly um working locally with the flashbots realistic we do a lot of research and collaborations there's a lot of open research we writings and specification work in collaboration with a bunch of teams and the ef and and yeah wide-ranging collaborations and also always opportunities to contribute we are hiring as well so if you're interested look at flashbot's jobs there is a bunch of open opportunities especially for engineers uh plus points if you have a go experience it's a very collaborative environment i i would definitely encourage you to take a look at that if you are interested in opportunities and also check out our github repository it's on github.com i touch on this briefly using the flashbacks infrastructure gives you a couple of advantages like privacy front running protection review protection block priority so the bundles they are added on the top of the block and it lifts also certain transaction size constraints so if you have like large data that you want to send through gaff won't let you do that through normal um normal transactions i think it's like 500 kilobytes is a size limit so you need to do something very interesting to actually go over this limit but there is a bunch of use cases and this transaction size limit is also not applied in through bundles quick overview how it really works users send transactions to the mempool goes to the miners then there is the searchers that look at your transactions in the main pool and slip in a transaction right in front of it that does whatever they can do to maximize their value based on on on the impact your transaction has of course there is like very quick growing segment like within a few weeks it was like 10 bots that competed against each other and this leads to a lot of transactions by boards that are in mind into blocks so here we have a the solution here is flashboards with mvvgaf and the thresholds really where searchers do not send their transactions back to the mempool but they send it to the flashbacks really they already get simulated and sends to the miners and the miners will only include those if they do not revert in the end so basically it's for also for searchers advantages because they can send and resend better and better bundles but to not get penalized by having a bad bundle actually mind and losing the transaction fees flashback protect is currently completely excusing excluding searches of boards that transactions get routed directly from users to flashbots to the miners there is thinking about how to involve searchers in a non-front-running way that's coming later and we also have mvv boost i don't know are you guys familiar interested in mv boost it's basically an approach to proposal builder separation for ethereum ii that is currently a very also collaborative project with a big part of the community and we try to think through all the challenges and get the approach that it's possible that the consensus client besides talking to the execution client can also get additional private transaction flow so there is relays that send basically blocks to mdv boost which runs as part of the validator consensus client node or instance and the consensus client can then choose which block to use if it's coming from mbv boost then it is not the transactions are not revealed only the header and the validator signs the header and only after he signed the header he receives the block payload which guarantees transaction privacy here so this is a very interesting project i encourage you like the specification is all on github as you see here flashbots slash mvp boost or if you search heavy boosting on google you will find this very easily all right then let's dive a little bit into the technical uh details um this is the apis that we have if call bundle and if send bundle is our classical most widely used apis call bundle allows you to simulate bundles so a list of transactions and you get the information where you have rewarded how much value they provided and so on and with a send bundle you can actually send it to the relay where it will be simulated internally again and if the simulation succeeds it will probably go to the minor except of a time of very high load where there is a some rate limiting if senpai transaction is a relatively new api that we have which does not require the payload signing it's you can send a oh no it requires a pilot signing but you can use a similar api to flashback protect too for the same private transaction you send one single transaction and it will internally get sent as either bundles to the relay because the bundles they are only for one specific block so it's kind of a little bit of hit-and-miss if you get included if there's like a lot of competing transactions and send private transaction abstracts this that it will send it automatically for up to 25 blocks until transactions included so if you're developing and you want to trust the easy way to send transactions privately but don't have all the issues of resending and checking if it's included you can just send it to esen private transaction and of course you can also use the rpc endpoint where you can use send raw transaction that will either route non-valuable transactions to the public mempool or if it's a valuable transaction through the flashbacks really through send private transaction again so if you send it to the rpc it will use send private transaction internally the rpc endpoint is also open source software written in go so you can take a look at that also you can run it locally very easily and we also always happy about contributions issues pull request feedback whatever if you run into anything we encourage you to open and get in touch and here is maybe the more interesting thing for hackathon like exactly how wood developers what's what's the easiest way to interact with the flashbots apis depending on your programming language in go it's this flashbots rpc library maybe in python it's the web free pi pi flashback provider if you use javascript typescript it's the effers provider and we also have one there is also a community built on for rust i wanted to show just a few code examples how to approach that in and i decided to use a javascript typescript because for a hackathon it's usually very accessible and you can maybe reuse the same code across backend and front-end with node.js and the browsers so i will jump into that and show live with the flashbots ethers provider so the repository if any one of you is interested and i'm sure we can somehow publish the slides later it's github.com metacris this is my username and then it's the flashbots ethers example so if you just go on github slash metacritics you should find it on the repositories so i will show you now some live coding here so basically what i did was git clone the repository [Music] it's in the readme it's built on some typescript boilerplate project that like does the right dependencies and that you can bundle the code as a node.js executable or for the browser with es build so it's a little bit outdated maybe but it is something that gets you started very quickly and that you can just install right now so be it's probably easily transferable to other things but i'm familiar with that so i use that how it works is you clone the repository you install the dependencies with yarn and that's basically all the setup you need here in the source directory there is four different main dot ts type scripts with increasing complexity and this is included from cli dot ts it's basically just include the run method and run it or from browser so is it large enough should it make it a little bit larger like this so the first example is a very simple setup of ethers this has a hard coded girly api key for infurial so i will deactivate this in a day or so but feel free today to play with that too it's in the configuration here this is just some randomly created private keys because it's a little bit tricky how to handle them if you build for both the back end and for the browser because with the backend usually you would use a process environment variable but for the browser this is not existent you can use es build to replace these variables in the build process that's that's very easy but yeah it's up to you how you handle this so for the sake of simplicity i just hard coded these values but you really should not check them into code so don't do what i did here this is really for just for example it has no values um g95 and some helpers and is the girly relay endpoint so in the first example it sets up a a first inferior provider gets a block number and then gets the block for this number it's kind of a very simple example and let's just run this a little bit smaller so you can run this in the cli mode with yarn cli this is also written in the readme so here it fetches the block the block number first and then the block that's it and in the readme we also have the information what else you can do so you can build it for the browser with yarn usb browser and you can add column watch so on every change in the code it automatically rebuilds if there is no hot reloading so in the browser you still need to manually reload the code but it will automatically build it if you change anything so it's waiting for changes it's all fine you open the browser test how do i do that things like this yep and here it's doing exactly the thing let's reload to see it better so it's getting the block number and then it's getting the block and then here you have the block details and it all runs in the browser maybe if you target the browser instead of an inferior provider you do like a i think it's called default web free provider that connects to your meta mask so metamask can then sign your transactions and then broadcast them so you don't need inferior but this is like up to you but this shows you it's like really kind of simple to reuse the same code with some constraints in both the back end in node.js as well as in the browser in the second example in the second example we create a transaction and in the third example we simulated in the fourth example we send it to flashbox and get some statistics so it's the same code as before it's just that we create a wallet and here we get the maximum base fee for the future block and then we create a wallet with to the wallet address and a bunch of parameters and basically that's it so to use that you would for instance go in in cli choose main two and then you can run yarn cli and then here you can see the transaction so in the next step it's exactly the same code except that here we also add a simulating part so basically you have to choose a target block which is the latest block plus one in this case and then we simulate it which means it's sent to the flashbots relay with call bundle they call bundle api the request is properly signed and then it returns to the simulation result let's see what this does so i again go to cli and just import this from mainfree and run yarn cli again so what do you think will happen with army keys exactly simulation is successful in the sense that it was simulated and the response has been received but it was of course invalid because in this empty wallet there is insufficient gas to send the transaction so this is a simulation result that the transaction itself had an error so success basically um it's really up to you how you want to craft the transactions or where you get them from and here finally in the fourth example after simulation if it's not an error it yeah here if it's not an error we submit it to the relay with send raw bundle there's sent bundle and central bundle in this provider send raw bundle means the transaction is already signed and because it's here here it's signed and if you do send bundle it will sign it internally so it submits the bundle but it won't happen here because the simulation has an error but we can comment this out and still send it anyway let's see what happens i need to import mean 4. what where is that 72 oh yeah simulation yeah exactly so this is here it's just a compiler error basically that there's additional apis that this does for you and because i commented out the simulation error response you cannot actually get the the result but there is two more additional apis that's called bundle stats and user stats where you can query the flashbacks really like how did this model do what happened with this bundle did it have a reputation impact and end user stats for foreseeing the reputation and some data about your signing key because we create basically we have two private keys here one private key for your wallet and one private key for signing the requests that go to the thresholds relay and this signing key is impacting whether you will end up in a high or in a low priority queue in times of high congestion when we have a lot of traffic the high priority signing keys will get simulated faster than those with the standard low priority and it's pretty easy to get into high priority you just need some successful bundles so let's try this again and i hope i saved i probably not i need to save yeah it's not like this so the bundle here was submitted but that it tells you here that the block that you sent it for has passed without the bundle being included so kind of what we expect here but it shows you if you want to interact with the flashbacks really from javascript like this is all that you need to do and then you can do some additional user experience with error handling and so on but this is a very simple way to get started in my opinion personally i think for backends the go code is even a little bit simpler and more straightforward but i think that's probably not true either okay just going to wrap it up if you're interested again take a look at github slash meta create slash flashbots e-first example and here you have the full code of the examples but also if you're building applications are infrastructure services user-facing apps be mindful of mev like mev exists it's exploitable very often and it's a not a great approach to just don't think and don't care about it too much it's really important like if you're a developer that you have some thoughts about how does your code your application your infrastructure impact users and and emit mvb because it is going to be exploited if and this can be disadvantages to users or lead to centralizing effects so if you have questions like there's a flashboard discord where there's very active discussions and it's very easy to get in touch so if you want to get feedback also on your applications about possible mvv it's uh definitely relatively easy to get in touch also matthias is here so he is a one of our mov experts and he will also be able to answer a lot of questions and i'm available after the talk too so that's it i think we rushed a little bit through it but if you want to collaborate easy just try and discord read the docs join github and if you want to build something i hope you have a lot of fun thank you [Applause] so maybe we have a few minutes for some questions any what is on your mind all right then i hope you enjoy the hackathon and happy hacking [Music] [Applause] [Music] you 