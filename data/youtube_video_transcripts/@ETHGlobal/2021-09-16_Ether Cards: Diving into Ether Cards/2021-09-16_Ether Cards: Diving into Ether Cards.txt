alrighty hi everybody welcome to the diving into ethercards workshop here we have mickey who is from our sponsor ethercards he's going to be sharing a lot about the platform and what you guys might be able to do with it uh during the hackathon so if you guys have any questions just shoot them right into the chat and i'll try to get to them at the end but if you don't get your question answered or if you have any other questions after this workshop ends feel free to contact them in the sponsor ethercards channel on discord all right mickey take awesome thank you so uh my name is mickey sakac uh i'm one of the blockchain leads at theater cards and i'm going to basically present the platform and some inner workings of the system uh as an intro ethercal is a custom nft platform that helps engage grow and monetize your community by using ethercards technology you can or anyone including artists musicians and athletes influencers and even non-profits uh can create an unparalleled experience for their supporters now uh what i can show you right now is the nfts that we've created for our own community and they are multiple classes uh creators ogs alphas and founders which are delimited by their ids so basically you have we have the creators which are 0.29 then you have ogs which start at 10 and go up to 99 uh alphas that start from uh 100 and go up to 900 999 and founders which go up to from 1 000 to 9999 as you can see the best cards out there so creators ogs and alphas have custom visuals and founders have what we call layers so every card has a couple of layers and those layers are somewhat of a trade or a property that gen that uh are generated from so the five layers to generate the image that you see and each one of them is uh created by someone and you can sometimes get a perfect one or get a one that's been created by one specific artist now ethercards themselves have traits these traits are basically properties or or functions of the card uh if you own one what you can do with it for example let's look at the reforge trade this is a one-time ability to randomize any or all selected layers of your cards accidental art image so if you use this you can re-roll the layers that you have one moment if you have the r draw for example you get three nfds from drops that launch their campaigns through either cards if uh in terms of the architecture and how it actually works uh we have two systems uh we initially started with the trades uh off chain which were stored in an ipfs file so if you take a look at the contract itself so this is an erc71 nft contract and when you take a look at the token uri and you query the id you're gonna see you're gonna get a url to a json file now this json file is served by a metadata server which loads the data from ipfs and manages or changes it uh in order to allow us to change it whenever you do something with it so let's say for example you use the refresh trade or you used the free ticket trade then it's a lot cheaper to do it off chain uh in the metadata server yet uh some systems like the reforge for example really need the data on chain so for that purpose we created the ec registry which i can show you here it basically registers the fact that the card has a trade it it does just that and if that trait requires an implementer so for example you have a trait that has a number or a value let's say for example the limited trade slot or the punk battle ticket you need a way to store that value and to store that value we have implementers so if we take a look at the registry itself versus the json file from the metadata server you're going to see that when you actually query the token data for a token id it's quite different mostly because of storage uh considerations we basically save a uintah array and in that uh array we use bits so let's say you have token id 58 and token id 58 is uh stored in the seventh byte of the bit array and then the traits themselves which are let's say for let's take unicorn or reforge they're stored in the same way except that they have an implementer so for trades that need an implementer it's present here and you're gonna see in a couple of minutes uh why and how we actually do those for reading the unchained data and setting down on chain data we provide uh an npm npm package which you can find that ethercard slash ec util you're going to see this used in the testing suite for creating or decoding the bit array data which is again for the trades themselves and for the tokens themselves and yeah going back to how it it all works what you have in blockchain systems usually is the front end that connects to a blockchain node and that blockchain node usually reads data from smart contracts if you're if you have a simple sale contract if you have a simple crowdfunding uh contract it it's all good you can just do i don't know 510 node calls whenever you load the front end but when you have 50 traits and you have to load every single one of them it's a lot harder especially when let's say for example you want to view multiple cards from a front end which would require thousands of calls to the chain uh for this thing we have uh the metadata caching server so the metadata server as well as a metadata view contract which is basically just a batch caller on chain which lets us read whatever uh contracts or properties we want up to like a thousand properties per call uh you're going to see that used in our front ends so what else can i tell you about this the vc registry itself also provides access controls for the implementers which are then used by the card upgrade the battle royale or a token sale contract as well as forges reforges and whatnot and let's now take a look at a trade the new trade that we're working currently which is the dust generator trade now when you design a trait you want to to have to be mindful about the user experience so what happens when you when someone wants to claim their balance or they want to spend their balance to do something so the dust generative trade is basically uh an implementer that generates uh an erc 20 token which can then be spent in the ecosystem to unlock different things and what i mean when i'm saying that you want to be mindful about it is if you want to make it easy for people to actually use it you want to have methods on that generator trade that allows them to claim partial or full balances claim multiple balances from multiple cards at once as as well as either go through approvals or not so when you do money rc20 transfer what happens you have to first approve the transfer then send the method call that you want to spend something uh in order to just have one transaction that those days you can basically upgrade your erc20 to a 777 contract uh and use the unreceived method for it so um let's look at the code itself um where's the yeah the right the github repository so this is public you can take a look at it you can use it we have added the mainnet and the ring betas net contracts right now you guys don't will not have access to actually right into them so you can use the repository to deploy your own set of contracts which is basically the erc dc registry v2 and if you need you have an nft toolbox which is basically just an erc721 with some superpowers like mint a specific id or batch mint or take a token and give it to someone else so that that should help you view view and use the system uh okay and why uh we have the ethercar straight registry hotpink edition uh it was a an in-house joke about uh dyeing our hair pink if we didn't release this in time but we actually did so we got away there um so what you what you actually expect from from the registry is just this you have a trait with a name and implementer type and based on the type you can it's either a normal trait that uses every single storage slot as so if if the trade exists on a token id uh it sets a one in that position but to be efficient we added a second type which is an inverted trait and then an inverted range so let's say you have for example 10 000 tokens and 8 000 of them have a trade if you invert the range uh the trait itself and you just stored the last 2000 as not having it you save up three times the gas or four times the gas mostly because you just save two thousand instead of eight thousand so for four times the gas and in terms of implementers the simple you intate implementer is basically you're just setting some data for a token and that's it and you can get it later this is useful again for ticketing systems for the battle royale for ruffles or even for the layer system in in the uinta rave version and what you basically do when you want to create a new one you just extend the value implementer that you you have and you deploy the contract with the registry's address and the trait id that you expect this thing is going to have you're going to have access to the code and the deployers and everything else i've included some extras uh one of the extras is the ethercards forge this is an on-chain layer transfer uh system so if you have let's look at a founder so if you have two founders one of them where is it here so if we have a founder or either another card it doesn't really matter and we have layers on it and we want to shift the layers from one card to another uh then we can use the layer forge to do this on chain first of all you have to save all the data on chain which is uh quite interesting mostly because it's quite heavy so if we take a look at the actual image for the layers you're going to see that we use hex values for layers so you have five layers and you're going to have five x values so it what we do is have the accidental collaboration with five values which can then be manipulated by the forge when it receives this the exercise itself so what we're actually looking for is new traits that might be interesting in in different cases uh let's say for example you have a community that doesn't really need layers they're not artist-based so in that instance you're not going to have them what can you have so the whole idea is we're looking for new traits that you guys can come up with and better storage optimizations for the existing trades because this thing for example so the uintahatory val implementer this one what does it do it uses a mapping of the token id or un16 and then a uint8 array and this is a dynamic array which means it uses 32 bytes to actually store five which is really bad what we can do is shift it around and have a five level uh mapping and then have ten thousand values per level which would uh reduce that quite significantly the problem with that is you you have to write some assembly to actually uh get into the storage space mostly because you can't reference story space from uh from memory at least not in the current versions of solidity any any questions i was kind of curious what about the front end do you guys have some kind of way to spin up the front end as well or i mean nice most of that yeah we do have a test net implementation for that but this is the one that we use for testing purposes uh i can give you guys uh access to it as well and uh let's just react boilerplate based on ether's js which uses our component yeah we've added our components into it and you're gonna be able to spin it up pretty easily and the other one is [Music] yeah this one so i'm gonna add links to the batch color that we were using in the front end to get a thousand properties of chain uh in one call through through js and solidity so yeah i'll give you access to these things in a moment thank you that's about it okay awesome thank you so much uh mickey for this workshop and thank you to ethercards for sponsoring eat online this year i do wanna encourage everyone to continue this conversation on discord through the ethercard sponsor channel and yeah everybody have a really great day thank you again um and i'll see you at next 