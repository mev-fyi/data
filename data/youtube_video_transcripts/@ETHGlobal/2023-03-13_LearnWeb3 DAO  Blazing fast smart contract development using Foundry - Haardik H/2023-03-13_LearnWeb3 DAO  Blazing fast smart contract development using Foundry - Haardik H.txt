foreign to the learn web3 dial Workshop blazingfast smart contract development using Foundry joining us today is Hardwick who will be talking us through this session and with that we'll pass it over to Hardwick to get the session started absolutely thank you Rory um I'm just gonna share my screen and to confirmed you all can still see it um we'll get started okay where are you can you see it yeah we can see it okay if you want to get full screen yeah yeah perfect cool hey guys hello everyone uh it's been a while since I've done any Global Workshop so really hyped to come back and we're gonna be seeing a lot more of me around 2023 workshops but today we are talking about smart contract development and testing using Foundry so a little bit about me my name is hardik I have no first name legally and the co-founder I've learned about free and in education and Vib maximalist uh for this talk or Workshop I'm going to be keeping an eye on chat so I have chat open over here if anybody has any questions you can put it in chat I'll answer sort of that I go along as happens feel free to pause me at any time and yeah try to keep this conversational if you have any questions um so what is Foundry right so Foundry is a solidity based smart contract development environment and it kind of falls into the same category of tools as like hard hat or truffle or ape Works which you might have used before the main difference is that everything you do in Foundry is done in solidity so you're writing tests in solidity you're writing your deployment scripts and all of that in solidity everything you're doing isn't solidity unlike for example hard hat or truffle where you have to do stuff in JavaScript or in a Forks or Brownie and similar you have to do stuff in Python everything on Foundry is done in solidity and we'll see they have there are certain advantages to doing that there's actually a very good case for doing all of this stuff in solidity as it avoids kind of that one level of abstraction that oh you now also need to have an understanding of JavaScript you also need to have an understanding of how JavaScript test Suites work you also need to understand how to convert uh U into 256 to a big number and then back and forth and is this really annoying so doing everything in solidity very very helpful that's one of the key differences you might want to consider using boundary for that if you're relatively newer um if you're kind of starting out or you don't have past experience in JavaScript for Python and you're learning solidity Foundry might be a better fit for you so you can just focus on sort of solidity based stuff all around the second thing is and this is actually also a pretty big deal Foundry is very very fast as much as eight times faster as some of the Alternatives the reason for this is you know Foundry was built from the ground up uh it's written in Rust first of all and everything that Foundry uses internally was built from the ground up to sort of support this project it's not really uh relying on external things as much compared to something like hard hat uh where first of all it's JavaScript then it's using the solidity JavaScript compiler and then it's using like ether's JS um overall it's relatively much slower than Foundry is now for this hackathon if you're just starting out again maybe this doesn't matter as much to you right now if you have like a simple project with maybe one or two solidity files uh the time difference between hard hat and Foundry is going to be pretty negligible and you might not notice major time differences but as you start working on bigger projects this time difference becomes very very noticeable to the point of uh the soulmate Library which is pretty famous the soulmate library takes six seconds to get compiled and be set up using cranberry that is going to take up to like 45 seconds on that tools and even a couple of minutes if you're using hard hat and that really adds up over time so as you're trying to fix a bug you know five seconds versus two minutes for compilation really adds up a lot so it's it's pretty fast it's it's it's up there um so generally Foundry is kind of broken into three specific segments and we're gonna take a look at a couple of them today so there's Forge uh there's cast and there's Anvil right so Forge is the main uh sort of the compilation tool the CLI where you kind of do everything related to running uh like creating a new Foundry project compiling your contracts the running tests all of that stuff happens with Forge uh cast is a CLI tool to sort of send transactions to the ethereum network and so on so you can call functions on your smart contract on any network using cast so it's kind of like a terminal based uh way to like call functions and stuff on ethereum and Anvil is a local local ethereum node that you can run for development and testing purposes it's kind of like hard hat node or truffles dimash so this is the local evm implementation that just is really fast you know you can run your tests against it you can Fork a network and run it on Anvil and so on so forth we're mostly going to be focused on force today and I'll try to take you through as much as I can about Foundry and what you should care so let's just let's just jump into it uh we should just start writing code so the first thing you want to do is if you haven't already installed boundary you don't already have Foundry on your machine what you want to do is actually let me just pull up the page for it because that will be easier there's a curve command you have to run but I will send it in chat and I will also open the page so you can find it yourself but basically uh yeah if you already haven't installed Foundry I'm on a Mac OS so you just have to run this command you need to download The Foundry up binary from Paradigm and once you've installed Foundry up that is the sort of package manager for boundaries kind of like the tool you use to keep Foundry up to date and install it and all of that stuff so I already have Foundry app on my machine and once you've downloaded it you just type Foundry up and it will install the latest version of Foundry which basically means the latest version of force cast and and build on your machines right so once this is all done um we will start by creating a new project so create an empty directory I'll call it Foundry tutorial oops well The Foundry tutorial and what you want to do is just type Forge in it and this will oops Forge oh I am in the wrong folder yeah seed into the folder you create and then type Forge in it and this will set up a new Foundry project in that folder and now let's just open this up in vs code to see what it looks like and what's all uh what do we have over here so we start off it gives us a solidity simple solidity contract to get started right we have a counter contract that just has a number you can set that number or you can increment that number over time so the way things work in boundary as I said everything is solidity right so you write your contracts and solidity but then you also you write your tests in solidity this is a test for that contract and then you also write your scripts in solidity this is where you might want to like deploy your contract to an actual Network and so on other than that what we have is we have a lit folder which comes with the forged standard Library installed and we'll get into what that means but this is really really cool stuff but just to get you familiar with the basic commands the very basic commands that you must know are Forge build so once you have the project you run Forge build this will compile all your solidity files and it says okay compiler run successful and at this point you will have an out folder that comes with the apis of all your contracts so most of these contracts currently come from the standard library but your contract powder this is the API for counter.solve the console Forge build once you've built it the another basic command you need to know is Forge test and force tests as the name suggests runs the tasks against the contrary runs the tests that you wrote and the cool thing about this is it actually gives you the gas cost required to run each one of your tests since your tests are written in solidity and you're calling other solidity functions that can tell you the gas cost for that test and in fact if you do fast testing which we'll get into it also gives you like the average gas price and the median gas price average gas cost and immediate gas cost required to run that test so Forge build and forged test two basic commands you must know okay um so this this contract obviously is super simple but we'll get into a couple of neat Foundry uh Foundry features that will show you kind of why it's so cool so we'll start off by creating a new contract first of all we'll create a new contract let's call it mirror.soul and this is going to be an extremely simple contract I'll just copy paste this this is going to be an extremely simple contract which all it does it has a function called Mirror which takes in a number X and then it Returns the same number back unless that number is 50. if x is 50 then it returns 42 but otherwise it just returns X back so you know 99 of the cases it will just return the same number back but then there's this one sort of edge case where it will return 42. so what we want to do is we'll create a test file for this we'll create a test file and the convention with Foundry is your test files are named contract dot P dot so so the contract name is mirror so this will be mirror.key.com right once we have this test file we write the tests as a regular solidity contract and I will copy paste it because I already have it but we'll walk through this ourselves so what's happening over here so first of all we import the testing framework quote unquote from the Ford standard library and the first standard Library comes from this lib folder over here right and you can look at the tesco.soul file that we're importing it basically Imports a bunch of other files and re-exports it but it allows us to write uh tests and solidity and then we import the actual contract that we're testing which is mirror.so with that we declare a new contract mirror test is test and then we have a function called setup so every test will have a function called setup which initially sort of you know sets up the testing environment specifically in this case it deploys a new version of the mirror contract and saves it as a state variable so you can call functions on the same contract over and over in your following tasks um then we have two test functions over here again the convention in Foundry actually I think this is enforced is your tests your test functions must begin with the term test right so you could you cannot like have a function named simple over here you have to name it like test simple or test XYZ so you have a super simple test called test simple and we're like okay assert assert equals mirror.mitter five and five so this is just checking okay if I call the mirror function with x equals five it should return me five and it should be equal and if it's not equal the test will fail so the assert equal nice helper function comes built into the testing and standard library and this is pretty basic test over here this one is more interesting so Foundry has support for what's called Buzz testing and what first testing basically means is it can sort of so in this case you know we're setting x equals five ourselves we're setting x equals five manually um but in the funding test you'll see oh did somebody say something okay so in the fuzzing test we take X as an argument and then we just pass that argument forward can I send a miradoxol um sure I don't know if I should just put it in chat but there you go so yeah so in the first test we take an argument and we pass that argument so we're not testing for a specific value effects but what first testing does and this is a more General concept than just Foundry this is more General sort of computer science related stuff but first testing basically means that the tester itself the testing framework itself will try to find random inputs to your function it will try to find random interest to your function and it will try all of them out and if it fails at any one input it will let you know so in this case it will try out different values effects and it will assert equals on all of those values of X and if it fails at some point it will let you know so you might have guessed what's going to happen over here if we run this test um what we are going to do is let's go back to our terminal and type for its test and it may not detect it the first time because it's not running as many times right now so by default that's a good question in the chat belief by default boundary tests 256 values randomly so it runs for 256 times randomly and currently that's not enough to find the obvious issue in our code um and you know it depends on your sort of Poland so Plus testing is not 100 guarantee you can't uh have it run like all infinite values you need to set like some sort of limit and to do that in this case so Foundry comes with a foundry.pomel file okay this is sort of the configuration file if you used hard hat before it's kind of like the hardware config.js file where you can set different configuration values for boundary and specifically for bus testing what you can do is add a plus parameter and set Foundry underscore Buzz underscore runs and I'll set it to say a thousand random runs right and if I run for this test again okay it's still passing there we go it tests with the random values every time so increase the number of runs even more if you're wanting to test even more values but in this case um you can see it says test fuzz failed with the argument 50. right so we didn't tell it to run x equals 50 it just randomly failed with the argument 50. so it was testing for random values and this first testing is very very useful and this is obviously a very simplified example you know looking at this code you can clearly tell the mirror function isn't behaving as it should but typically these bugs aren't this easy to find you can imagine some sort of complicated D5 protocol with 100 solidity files all across the project also importing each other and inheriting from each other and um having all the fancy stuff around there and sometimes it's easy to skip out on certain edge cases oh a multiplication is going wrong somewhere or there's some dangling if condition that's gonna like given a certain input it's going to do something that's not expected of it so sometimes manual testing fails to patch certain types of bugs that first testing can help you catch and it's really useful that Foundry comes with first first testing as a built-in feature so and all you have to do is just take an argument take an argument in your tests and pass that argument forward and it will automatically Generate random values for those arguments that's all you need to do can you define a range for those numbers um if you have to define a specific range you're probably better off just using like a regular test function instead because you know like a minute max value for it um if it's a really large maximum value I think there's probably a way I'm gonna have to look in the config for it but I do not know that off the top of my head right now unfortunately um but okay great question though so that's for Buzz testing now what else I want to show you one more cool thing about Foundry so let's go ahead and create another new contract and we'll call this one cheat codes dot solve and cheat codes are really cool so we'll create a super simple Point Break again as we have this contract called cheat codes which stores a number and a last time stamp and it has one function called set number which takes in a parameter new number and it just requires that the current block timestamp is greater than the last timestamp Plus 120. so this basically means that you know um set number is being followed at least two minutes after last timestamp so because blocked up paint stamp returns that hangs down but in seconds so we're saying that the current timestamp is greater than the last paint stamp plus 120 seconds so two minutes um and then if that is true then we update number equals new number and we set last time stamp equals blocked up time stamp okay uh again a simplified example but you can think of things like the count the compound governance mechanism or like time lock related things where certain functions can only be called in certain type intervals very useful feature to have generally on a smart contract but can be a pain in the ass when you're testing for it how do you test for it you don't want your tests to wait for two minutes just because your function cannot be called again uh until two minutes ideally you want to do some sort of happy things around there and make it believe that two minutes have passed and this is where cheat codes come in so we'll create a test for this we'll call this cheat codes Dot edosole and cheat codes dot P dot Sol what we're going to do actually let me write this out so I'll set up the basic boilerplate structure for it same as before quantract cheat codes test this test Imports the standard testing library and imports the cheat code solidity file so we'll take a reference to the cheat code smart contract and in our setup function um we'll just deploy the two post smart contract and what we will also do um actually actually this is fine for now so we'll deploy the cheat code smartphone price now when this is deployed when this is just deployed initially uh initially last timestamp equals zero right that's a default value per unit in solidity this is equals to zero um one thing you have to note is when tests are being run they're being run in sort of a simulated ebm environment right and initially when your tests start running your block.timestamp is also equal to zero it is not connected to a real Network it's equal to zero initially so in that case if we just pry calling set number right now um can somebody tell me what our cheat codes yeah I'm we're getting to it we're getting to it so right now switch codes is just the name of this contract and I'm going to get into what boundary cheat codes actually are but so if we have a test something like test set number and we just do cheat dot set number five right now this test will fail and why will this test fail because when the test starts running block.timestamp is going to be zero and zero is not greater than zero plus 120 initially so this test right now as it is will fail and we can see that if I just do boards test once more um um this is the mirror test the cheat code test over here uh test set number failed with the reason error okay and that is the EVS in in the um in the required statement over here so currently this test is failing these zero is not greater than zero plus 120. um two things to note first thing you can actually create trailing tasks in Foundry so you can expect a certain test to fail and that is okay so the way to do that is to change the name from test set number to test fail set number so this will tell Foundry we want this test to fail and that's expected Behavior so now if I run boundary test once more oops yeah I'll probably run found request once more you'll see everything passed everything is good it expected that has to fail and that's perfectly fine but now what if we want to call the set number function once again so create another test set number link and we do a set number again and this runs into the same problem block time stamp hasn't moved forward by two minutes this is where Foundry cheat codes come in so Calgary has a bunch of cheat codes they're basically things that allow you to alter the state of your execution environment they allow you to change things in the EDM or how they can't practice behaving so that's why it's called a cheat code these things do not work on a real ethereum Network they only work within The Foundry sort of environment and they're meant to make your testing easier and faster right specifically in this case what we want to do is there is a cheat code called and cheat codes by the way called by array like VM Dot cheat code name so VM is something that's built into the standard library for Forge and it's kind of like the the virtual machine the evm and you're making direct cheat code calls to it so you say vm.org uh 150 let's say and the worksheet code what this does worksheet code increases block.heim stamp by whatever value you tell it to so when we do vm.org 150 it's going to move block the timestamp to 150 and then call this at number function so our tests will immediately pass and on a real ethereum Network it's the same thing as actually waiting for two minutes to go by you can see this time nothing fell this time cheat codes both of the tests passed over here this is not the only cheat code that Foundry has available to you there are actually a bunch of cheat codes that are really cool um let me show you a list and there are a bunch of cheat codes we don't have time to go through all of them but warp is one of the first ones you see here sets the block time stamp to whatever you want it to um you can change the block difficulty you can change the block number you can change the block coinbase you can change a whole bunch of things um my favorite one has to be prank where you can behave as a different address even if you don't have the private key for it it's really useful in cases of things like if you're testing something against an obvious loan and you need money to pay back the flash loan I just prank as some rail somewhere and just pay 10 million die from them and do the Ali flashlight is pretty cool but they have a bunch of cheat codes you can use uh you change a lot about the evm within your testing environment which makes things easier um last ping before we head office for almost that time is a common question is how do we use all these other libraries we're familiar with I want to use open Zeppelin contracts you know I want to use soulmate I want to do all these things open Zeppelin contracts by default were designed for hard hat they were designed for Foundry but family supports them through you have to do something called remappings and let's say you wanted to create an nft collection so what you do is you type boards install um open Zeppelin slash open Zeppelin contracts which is their GitHub repo it's the GitHub organization slash GitHub repo and what this is going to do well it's going to download it's going to get clone the repo into your project and specifically it's going to put it in the lid folder next to the force standard Library um if you notice over here you know how we're able to do import for standard Library slash test.soul so basically you can import things from your lib folder including open Zeppelin contracts and you can also change how these Imports work um let me just show you so if ports comes with this thing called remappings by default it has support for three Re mappings which is the port standard Library open Zeppelin contracts and Bs test so what this basically means is typically if you have a contract over here let's say counter.sol and if I had to import from the lid folder it would typically look something like this I'm in the SRC directory it's like go back I'm going to live I don't could open bevel in bond cracks and then yada yada yada whatever I do this isn't very plain it doesn't look nice remappings allows you to kind of remap those paths so your Imports can look clean uh it comes with the open Dublin contract screen map built in so instead of typing lib slash open Zeppelin contracts I can just do import opens up little contracts slash whatever so if I have an e dot Soul over here I can just import it like that import open ziplin contracts like area and Forge will figure out because of remappings that it's supposed to grab it from lib slash open ziplining contracts and whatever and you can see this if I do for its build it should build without any issues there we go you can also have custom remappings so if you take this remapping then you output it to a file called remappings.pxt and you can now create your own remappings for example for a library that's not supported by default like if you're cloning the Ave repo or the uni swap repo or whatever you can create your own remapping sport over here but as an example let's say I want to create a remapping called prc721 slash which equals to lib slash open ziplin contracts slash token slash erc721 with this remapping I can change my import to just be erc721 it's large erc721.0 because it takes me directly into that specific folder where I need to go and now again if I import build uh oops failed to resolve file something went wrong found a tutorial live uh oops uh University 721 equals lib I messed something up over here of the deadline contract oops oh yeah it needs to be opened at the contract slash contracts slash token slash that um now if I do it for this build and see it works perfectly by it so yeah um that is all I wanted to cover about Foundry today a bunch of cool so we covered Plus testing we cover cheat codes remappings and imports it's obviously pretty fast my compiles have been taking less than one second to finish uh on hard hat this which I normally take decently longer and yeah I'll take a look at chat now for any other questions Oops I did not mean to snapshot on my screen it's meant to pause yesterday so let's go back to the slide back and there we go cool so yeah guys um yeah so that is that thank you for listening um I'm gonna take a look at a chat yeah if you want to learn more about building inductive general just learning about being General hit us up at learner3 uh learn about P dot IO or you can find us on Twitter and Discord always there if you have any questions um it says remapping raises some errors it did not find the file um you have to create a remappings.txt file in the root of your project you can either do that manually or you can run uh Forge remapping slash emappingers.exe to input it directly over there I do not use emacs I am a vs code plug I don't know for a complete beginner between hard hat and Foundry it kind of depends on your background if you already know JavaScript and you're just getting started in the space and you're only making like small projects um partap is probably easier because you already have that knowledge but there will come a point in larger projects where hardat starts getting a little bit annoying and changing between data types for like solidity and JavaScript can get a little bit tedious so you have to constantly convert data types back and forth at which point doing Foundry would be better however you know there's nothing stopping you from just starting off with Foundry at most you'll learn some even more solidity um with that point your install fails are you on Windows or Linux or Mac OS whatever are you getting I'm not sure um can we expect a defined reason on the test bill so actually what you can do is you can log things um I did not show that but let me let me bring that up so when you're creating either when you're creating like test files you can log uh they have a bunch of like logging helpers in the standard Library so you can do stuff like log underscore uint or like log underscore string or log underscore address whatever it may be and if you run it you need to run it with a verbose mode so if you just do like force test these logs will not show but if you do like boards test Dash we were both output it will tell you uh it will show you all these logs regarding ex defining specific reasons specifically for asserts uh what you can do over there is if you look at all the different assert helpers that exist you know I showed you assert equals uh there's a bunch of other uh other ones but you can optionally provide a string I don't know if this is very readable but you can optionally provide a string with the two arguments for assert equals or any of the other asserts which will be the error that shows up if uh if an issue happens yes Foundry was an addressed top three vs code solidity developer extensions I think I just used one really which I believe is just a visual solidity developer I believe that's what it's called this one that's pretty much the only thing I use I used to use some of the hard hat extensions but um this one hovers most of what I need typically um cool sounds like that's pretty much all the questions but I don't know if I missed anything but yeah thanks everyone we're over kind ruria I'll give it back to you and yeah check us out at learn about three and if you have any questions we'll get back to you cheers yeah cheers thanks so much for joining us today great presentation and uh yeah as hardly excited to reach out if you have any questions um 