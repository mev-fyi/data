foreign [Applause] [Music] hi there my name is David Snyder I'm one of the co-founders at lit protocol and over the course of the next hour you will hear from me Chris Cassano and Debbie as we talk about what is lit protocol how does it work and how to get started and so the big questions to think about here at the start of this is It's All About keys today we're going to talk about these key management and the use cases for distributed keys so some of you may know who this is if you have seen The Matrix trilogy this is known as the key maker in that in that film in that film series um but from the perspective of keys if you're familiar with that story what this individual is is a centralized trusted custodian a holder of keys and so if you've seen that film spoiler alert it is the centralized holder of keys that gets compromised and in the story lets Neo into the machine um back end so to speak and so I use this example just as a fun example from fiction to illustrate the idea that a centralized order of keys in our Network era that we are all living in really doesn't make sense and we've been addressing this problem quite specifically over the past few years and so really comes down to a big question of where are ease stored and so another way to say this is can the internet keep a secret and what we're going to see today is that the answer is yes and we'll talk about the methods for doing that I'll give a brief overview and then Chris will dive into some more detail but in short lit is a key management Network that uses something called multi-party computation and a threshold secret schemes to hold a key in distributed custody then developers can use that distributed custody key for the same thing that you used keys for in general because encryption and signing and we'll take a look at a number of examples in a moment and some of the core processes at the heart of this are things like distributed key generation proactive secret sharing and secure encrypted virtualization and this is the methods for Distributing the key and protecting the private key material to ensure even the node operators don't have access to it and the really kind of the key Insight here no pun intended is that nobody ever has the whole key the whole nation notion of a distributed key generation is you can have a bunch of parties holding something called a p fare and this is a threshold crypto system where you need a threshold of the net work in the case of lit that's two-thirds in order to authorize any decryption or signing with that underlying p so let's talk about the two use cases here um the first one that we'll talk about is decryption so these hexagons here in the middle represent the nodes which are custody in this distributed key again none of them is a centralized custodian none of them have the whole key and these nodes can read data from public State like blockchains and then determine if a rule is correct in provision access to another person so an example of how this might be used is Alice let's say Alice is a content creator Alice can write a book and can encrypt it client side and then say anybody who buys my nft they should be able to decrypt my book and Alice can take that encrypted blob and store it on a blockchain or store it on a distributed storage Network like filecoin or rweave or ipfs based system like ceramic and when Bob shows up later on he can sign a message and broadcast that to the nodes that says hi I'm Bob I own Alice's nft please give me the key to decrypt the book and the nodes can validate in this case against the chain data does Bob hold Alice's nft and if yes each of these nodes creates an authorization known as a decryption share and sends it down to Bob and Bob collects those on his machine client side in order to perform that decryption and so what we've got here is really quite cool because there's client-side encryption client-side decryption but the two parties never had to meet because lit is this network this distributed Network that is validating the rules and provisioning the keys and so another way that this is conceptualized is something called identity based encryption which definitionally at least before this uh offering did require a central Authority here you can see the definition from Wikipedia but again lit is the distributed Network alternative to doing a central Authority identity based or rules-based or conditional based encryption and so let's look at a couple specific use cases if you're familiar with lens protocol it is a social media protocol where everything is an nft what I mean by that is like liking following Etc are all on-train nfts the lens protocol team has integrated lit inside of their SDK in order to create gated posts so when you go and post on lens protocol you can say only collectors can view this which is like the equivalent of liking the post you collect it or only people who follow me can view this post and the encrypted blob is stored on ipfs and only the parties that meet these rules can perform the decryption so all of a sudden this creates like a patreon like benefit to these creators that are are using lens this is also um live in orbis.club for token gated messaging which is another kind of cool use case quite similar but in this case it's more about chat content rather than social content and we can also look about and look at this in the context of verifiable credentials so what we're looking at here in this video is um on an application called credit where a user is doing using a third-party service to do kyc or know your customer validation when that proof uh that in this case of some that somebody is over 18 is sent back to the user it's the same process again where the user is going to encrypt that proof client side is going to encrypt that proof client side and um is going to encrypt that proof client side and then can set a rule of selective disclosure around who is able to see that proof looks like there's a little bit of video trouble here but the just to repeat again get some data in cryptic client side can be kyc data in this example and this is quite interesting because it's also a verifiable credential so some signed Json linked data that in this case is encrypted and stored on ceramic and then the user in this case the individual who's over 18 can have the selective disclosure in the form of provisioning decryption rights via lit um to that data let us proceed here and the other ways that this encryption mechanism is being used is for things like data marketplaces so this is the logo of a project called streamer Network that uses lit to let data producers in create data encrypt it store it on the open web and then set a rule like you must buy this nft in order to decrypt that data set again having it be rules based or condition based is kind of the main Insight around conditional encryption and as mentioned earlier it's not just chain data that you can use for the rules for who can decrypt this but really any data on the web whether you can get it from an API an ATP request whatever it might be any statement that can be made true or false can be used as an input for this encryption data and it's also worth noting that things like cross train support Boolean logic all that sophistication if you wanted to implement that in your conditional decryptions you could and those are all in the lit Docs now let's talk about the other part of Keynes so as you know public key cryptography in general basically has two core features which is encryption we just talked about conditional encryption and signing signing is really interesting because like you have to sign a transaction in order to make an on-chain interaction in order to log something to the distributed letter that we call blocking to that state machine and so what we're looking at here is a very similar kind of diagram as you can see it's the same underlying architecture but in this case there is some code some JavaScript code and Chris will talk more about this that dictates when this distributed e should sign um and then the nodes can process that JavaScript and output in this case rather than an authorization to decrypt an authorization to sign and so there's a distributed key that is being managed by this network that is signing based on rules and again it's not just one node that is authorizing a signature but a threshold of the nodes so 20 out of the 30 nodes in the network and so let's take a look at some examples here like one pretty excellent use case for leveraging this is for user onboarding where you can do things like set up Discord or Google or web often as the authentication method where the private key is held and lit in this distributed network but the user's credential in this case oauth from Google or Discord can basically the network can validate that in that 20 out of 30 model that we discussed before and functionally create an authorized transaction from that distributed key so that is pretty exciting as it relates to onboarding if you're building a product that is maybe for non-web three natives this is also really interesting around decentralized Finance automation so what we're looking at in this video is a project called yacht labs and underneath the hood here um there are two parties which are represented by these two windows and there is one of these pkps these programmable key pairs which is this programmable key that's cut that's managed by lit that we just discussed and so what is happening here is this team has programmed that pkp or programmable key pair to act as an automated escrow agent for cross-train swaps though Alice is on arbitrum and Bob is on ethereum they can both send tokens to this wallet and when they both approve a swap happens to the other person's address and so as we kind of look along here we can see Alice has set everything up oops we'll go back to that we see Alice has set up the swap and now Bob is sending in from his side and the swap is ready on Alice's side and now the swap is ready on Bob's side and then they can receive the tokens once they've they've sent them to that escrow agent this is really interesting certainly it can apply to swaps but it may be also interesting to explore using this capacity to program keys for structured Financial products such as liquidity loss prevention on dexes um dollar cost averaging stop loss orders on state tokens definitely a lot of room for creativity here and then one more example from krebit what we're looking at here is a video where the lit pkp which has the capacity to sign programmatically is being used to issue a verifiable credential the verifiable credentialism signed data from the sign case on LD typically and in this case the user is signing into Discord then a lit is validating that that user uh it has has generated that JWT that oauth token if you will um from Discord and lit is essentially signing that and says yes this address in this case is in fact this user but what's nice about the way that this team has implemented it is that um that verifiable credential is encrypted and stored on ceramic in this case so once again it uses that private data it uses that encryption aspect that we talked about before and if you want to look at these demos more in depth you can find them all at theprotocol.com blog and so that about wraps it up for my section um uh I'll include a request for startups if you need some ideas in terms of thinking about what you can build with lit but really the thing before I kind of pass it off to the next person that I'd like to stress here is that like this is really a new primitive that you can think very creatively with if you're familiar with how like Lambda functions work um in or serverless functions uh essentially what lit is is like a Lambda service function and a key management solution but network based that's distributed and fault tolerant I'm really looking forward to seeing what gets built in this event and and interacting with a number of you um and with that I will pass it off to Chris thanks so much foreign and I am here to talk to you about how lit protocol works lit protocol is a decentralized and programmable Key Management Network what does that actually mean what that actually means is that Lit protocol is a network of node operators similar to like Bitcoin nodes or ethereum nodes or something like that but what the nodes actually do instead of running a blockchain is they provide Key Management Services and that means things like giving you Keys providing access to Keys when certain conditions are met um signing for you all kinds of things like that and it is a generalized programmable Network basically the goal of lit protocol is to take this amazing new technology of threshold cryptography and put it into your hands as a developer and we really want to make it as easy as possible to use this technology and uh fully programmable so you can do whatever you want with it and you know the thinking is that you could set up your own threshold cryptography network of nodes but it's a huge pain right who wants to manage nodes so instead you can use our nodes and write programs that run on them and do whatever you would like with that so if you're not familiar with threshold cryptography the general idea is that you perform a process called distributed key generation and for this example let's say that we have a network of 30 nodes and we're going to set a threshold of two-thirds which means that you need 20 out of the 30 nodes to participate in order to use Keys within this network and so you have 30 nodes and they come together they perform this process called distributed key generation and what this does is create a public and private key pair just like the one in your ethereum wallet but nobody knows the private key instead each node operator only has a private key share and they're able to do the same things with that private key share that you are with regular private key like sign and decrypt things but the difference is that somebody has to combine the resulting signature shares or decryption shares above the threshold to get out a decryption key or a signature and so in our case of a 30 node network with a two-thirds threshold you have to get a signature share from 20 out of 30 nodes you can combine those signature shares into a final signature um and there's kind of like two broad areas of use of lit protocol one is decentralized Access Control and in this case um the threshold cryptography is generally used for encryption and decryption and so some really cool use cases of things like this are um let's say you are in a dow and you want to encrypt some content upload it to ipfs or rweave or some kind of public storage but you only want your Dow members to be able to read it you don't want everybody else in the world to be able to read it if you think about this right it's actually kind of a hard problem if you just use some encryption key that you made up then you just share that encryption key with every member of the Dao right maybe you go on Discord you share it with them on there um but then what happens when somebody leaves the Dow right now all of your content is encrypted using this key you have to rotate the key give everyone a new key right it's like a huge headache you can imagine right every time someone joins or leaves you have to do like a whole operation basically um and instead what you can do is encrypt your content using lit you can set an access control condition that says user has to be a member of a dow and what that means is that um somebody on the right here this is like a user in a web browser or something can make a request to the lit nodes the lit nodes are these hexagons in the middle and they can say hi I'm in this Dow I would like to decrypt this content and they present a wallet signature from their wallet um just a signed message and uh the lit nodes check that signed message and say okay this user does actually on this wallet and then the lit nodes each individually check with the blockchain to see okay does this wallet actually meet the condition AKA is it actually in the Dow still right and if it is then each lit node will use its private key share to create a decryption share the user will collect all of these decryption shares above the threshold and then they are able to uh decrypt the content and lit supports tons of Access Control conditions uh it's not just like if you're a member of a dow that's just an example you could also do things like does the user hold an nft um you can basically like anything that lives on chain you can use as an access control condition and you can use any smart contract function it's like if you want you could make a smart contract that says like you know that checks SDK proof and says like only let a user in or only let user decrypt content if they present a ZK proof that that's valid that meets some condition right anything that you can imagine you can basically use as an access control condition and we also support um essentially using JavaScript as an access control condition where you can say only let the user decrypt if a JavaScript function returns true um and we'll talk a little bit more about those JavaScript functions later which we call lit actions so what is this useful for um it's really cool for permission and private data on the public web so you could imagine if you're using a cool fancy new decentralized Social Network and it stores its data on ipfs awesome right anybody can get the data um it's this beautiful open system but wait that also means that anybody can read all of your posts right there's no privacy um what you can do is encrypt your posts with lit protocol and you can set your Access Control conditions such that all of your friends are allowed to decrypt it and that's great because now you don't have to self-host the data right it's hosted on ipfs in the public web but it's permissioned and private in that you can still control who is able to access it and when another use case for lit protocol um is essentially signing um so the first case we talked about was reading from blockchains in order to decrypt something this use case is talking about writing to blockchains and the way that you write to a blockchain is with a signature the lit nodes hold private key shares and they're able to create threshold signatures that can be used to write to a blockchain and the way that the lit nodes actually do this is that you are able to upload some content some JavaScript code to ipfs and this is called the lit action and once it's on ipfs it's immutable because ipfs is content addressable so you can kind of think of these like lit's version of smart contracts but they're in JavaScript so they're really easy to use and these lit actions are allowed to uh also read from the web they can make HTTP requests so you can pull in data you could do all kinds of things that uh that would be really hard to do on traditional blockchain um and so like basically kind of how this actually works is a user shows up and says to the lit nodes like hi I would like you to run this program on ipfs and each lit node pulls this program down and runs it and if the program um asks for a signature each node creates a signature share the signature Shares are collected uh by the user the user combines them and is then able to broadcast them to uh or broadcast the resulting signature to a blockchain um and so that's how you can use lit to write to a blockchain in addition to read um and we think that this is like a really powerful new primitive that you can use for all kinds of things in cryptography um and one thing that I haven't really talked about yet um is when you're writing to this blockchain when these nodes are signing using a private key share whose private key is this right like is this the Network's private key like which which private key uh shares is it using and that's where the concept of a programmable key pair comes in a parallel key pair is an ecdsa key pair which is the algorithm that Bitcoin ethereum and Cosmos use and the lit nodes hold the private key shares that correspond to this key pair you can create a programmable key Pair akaa pkp by minting an nft that represents ownership over that pkp and then whoever owns that nft can ask the lit nodes to sign anything on their behalf using the private key shares that correspond to that pkb including ethereum or Bitcoin transactions and um I'll show you how this works right now so this is a lit action very basic lit action and what it does is it defines something to be signed this is just a simple array that contains the string hello world but this could be a transaction that you want to sign this could be a right to ceramic anything that requires a signature you can you can sign it's very very flexible and what you see here is um that we are requesting that the lit nodes sign this data using this key and store it in the result of uh name sig1 and basically like what's what's happening is the lit nodes hold the private key shares that correspond to this public key and so when you ask the each lit node to do this it's able to create a signature share and the signature shares I'll get returns to the user who's able to combine them into a final signature um so here's like sort of a basic overview of how that works the user creates some kind of Authentication uh you know that could be a wallet signature it could be an oauth token we support Google and Discord um and we're working on adding um phone and email authentication as well and they make a request to the lit nodes they talk to every single lit node in parallel and they present their Authentication and they also present an ipfs ID and they say hi lit node please run this code for me the lit nodes pull down the code from ipfs right and load it into a JavaScript runtime the JavaScript runtime executes the code and it actually checks that the user is authenticated and allowed to actually use the pkp and the lit action is also allowed to pull down any data from anywhere on the web using HTTP request so you can use it like in Oracle you can pull in data from anywhere in the world and use it in your computation and then if your lit action wants to sign it can request that the lit nodes use their threshold private key share to create a signature share which is then returned to the JavaScript runtime and what happens is the user down here is is running this request across all the nodes and collects signature shares from all the nodes the user is able to combine those signature shares into one signature and then can then broadcast the signed transaction or use that signature for whatever they want to use it for and we have a typescript SDK that um you can use that basically like does all of this for you and abstracts it all away where you just kind of like create a request pass in what you need and you get back a signature at the end um another cool pattern that you can use is the mint Grant burn pattern this is really interesting because um a pkp because it's created as an nft on um on a blockchain you can basically create the nft and mint it you can grant the access for it to use like some lit action and then you can burn it um and what that essentially does is lock the pkp such that it can only be used by this lid action forever now uh interesting like kind of toy use case of this right is suppose you have a lit action so you have some JavaScript code that given a number as input we'll check if that number is prime you can mint Grant burn a pkp on that Lit action and then you can pass numbers in and um if the number is prime then you know each lit node is running this independently um it will sign using its private key share the user collects all the signature shares combines them into a signature that signature essentially proves that any given number is prime because the corresponding uh programmable key pair can only ever be used to run that program and so what you kind of end up with is something that functions similarly to a ZK proof in the sense that you have a signature that proves that all of the nodes in the network got the same result and now you don't have to check if a number is prime if it's signed instead you can trust the signature because you know that the only way that the signature could have been produced from the corresponding pkp is if the lit nodes ran the program correctly and that you got the the result that it expected right which is the number is actually Prime and you can use this for anything right you could use this like to certify or to prove prove that like you know suppose like you have to prove that you're in a city but you don't want to prove like where in that radius uh that you actually are you just want to prove that you're in a radius without giving away your real attitude longitude you do something like that you could prove like that the weather was a certain temperature on a certain day in a certain place and time um you could because you can pull in data from the web using HTTP requests you can essentially like create proofs of anything on the web um very very easily and very very quickly and the proofs are ecgsa signatures so you can pass them right into a smart contract which is able to check those and and verify them a couple other cool use cases you can use a pkp as a vault um what this means is that a pkp um you know is a uh public private key pair it's a wallet you could send 100 nfts to it right and then um you can trade all 100 nfts at once because you can actually sell the pkp nft itself which is the nft that controls the pkp um to another user and you effectively have just sold the underlying private key that owns all of those nfts and remember the private key never exists it never uh it never gets like created anywhere and said the the lit nodes only have private key shares and so you can effectively like trustlessly trade a private key um in a way that you never could before this basically like breaks things like Soul bound tokens um a lot of anti-civil mechanisms like uh for example git coin passport or polygon ID can can be broken by this because now you can actually sell the wallet that owns the Soul Bond nfts right um that's something that you could you never do before because in order to do that with a regular private key that you are just like looking at you would have to prove that you've forgotten the private key right and and you can't prove that it's impossible to prove that um but with lit since the private key never exists you are able to actually uh to actually trade that um you can also use a pkp as a cloud wallet um lit supports a ton of different auth methods and so you know I talked a little bit about like if you hold the pkp nft you can ask the lit nodes to sign using um that pkp that's just one of a ton of different off methods that we support we also support um oauth with Google and Discord we support web often uh we're working on email and phone soon we don't have that yet but we will soon um and that that basically means that you can use any of those things as auth and there's a smart contract on chain that you can use to set up your auth for a pkp so you could like say uh I'm gonna onboard new users and all they have to do is log in with Google using Google oauth and I'm just going to pass that Google oauth access token to the lit nodes as proof the lit nodes can verify that access token and let the user sign using that pkp you know assuming that you've set up that user to off using that Google account so it's great for onboarding like you don't need to do c phrases you don't need to worry about anything like that you can get people a wallet very quickly like with one click um you can also use pkps for Automation and signing so this is a super cool use case it's like uh imagine like you're in some cool like 10 000 apy farm and you're like this is great I'm making tons of money but if the token price of Tanks then like I'm gonna lose all my money uh it sure would like it if there was some kind of way to set up a stop loss order but your tokens are staked you can't sell staked tokens with lit you could set up a lit action that checks the price of the token if the price of the token drops below a certain level then um it creates a transaction to unstake the tokens and then it creates another transaction to sell them on uniswap and you could basically like be pulling this right like have this lit action run every you know 10 minutes or something right and if the token price starts to tank then this will unstake and sell your tokens and this is really cool because it's just using raw ecdsa signing you can do anything you could do with a regular wallet with this so you could do things that are cross chain you could use Bridges um literally like whatever you can imagine you can build um and you know in order to do this in a sort of traditional way you would have to set up a hot wallet on a server um you know kind of like a trading bot type setup it's very very prone to uh to error you know having a private key on a server and and you know as a hot wallet it's really scary like it's a huge Target for attacks um and so this kind of like using lit for this instead gives you the protection of the decentralization right like somebody doesn't need to hack one computer to steal your money they need to hack two-thirds of the lit nodes and the lit nodes run inside of a trusted execution environment powered by AMD Sev SNP it's actually a secure encrypted virtualization environment so node operators can't see what the uh what their nodes are actually doing they you know they're it's fully opaque um and so it's very very hard to uh to hack into um and that's part of why we've built it that way so anyway here's some really cool ideas of what you can build with lit um and check out the docs at getlit.dev if you have any questions pop into Discord um we're always around and we are so excited to see what you build thank you I'm Debbie and I lead developer relations at lit protocol and today I'm going to go over how can how do you interact with lit how do you build with lit and as as well as some of our documentation examples that we have ready for you all so to get started we're on our documentation page so developer.lit protocol.com is the home of all of our developer docs on how do you build with lit Core Concepts around lid as well as example projects and tutorials that you can find so it's a bit of a Choose Your Own Adventure to start where if you want to start with code first you will start with examples or do you want to start with Concepts um for the hackathon I want to talk about our product our programmable key pair and lit actions product which enable programmatic signing and what's possible with programmatic signing with us so let's dive into first these use cases so pkps we see as a way to introduce automation interoperability into dapps so what that might look like is for defy automation you can use pkps and actions to automate your interactions so that might mean condition based transactions recurring payments liquid staking Solutions or for frictionless transaction execution we have an example just released around using a event listener platform that we've been working on to kick off what action what actions that does portfolio rebalancing so being able to set a trading strategy based on a percentage of what you want your portfolio to look like and then kicking off trading and that swapping is done with uniswap so be sure to look for that we have a whole list of examples for y'all to build with and then some more ideas would be around infrastructure as well as web 3 social so on the infrastructure side being able to do cross-train trained Bridges oracles for off chain Zeta so really leveraging the power of NPC and being able to take in a web 2 endpoint or take in some other kind of bridging data on chain and off chain um and then on the web 3 social side thinking about credentialing systems user and social graphs as well as a big thing we've been thinking about it's a kind of abstraction with support for web 2 auth methods so being able to authenticate authenticate through Google Apple passkey Discord and then having an underlying web3 wallet associated with that and really abstracting out how someone thinks about their wallet where rather than saving passphrases having different recovery methods and ways to access and use a web 3 account then lastly um we think all about gaming and how programmatic signing could enable different unlocks within gaming so signing a wall obstruction for blockchain based games that programmatic signing app element is really useful with the set program so NPC's non-playable characters being um actions characters different assets and games dot are that have movement and other interactions just that are very codified as well as some other ideas around condition based reports as soon as achievements and yeah we're always looking to see really novel projects so even outside of this list please um build something that's super cool and that you'll have fun doing um so next going down I'm going to give a little bit of an intro of how y'all would get a programmable key pair as well as after minting your pkp how do you use sat to sign Violet action so let's go to the pkp Explorer actually so pkp Explorer you can find it I'll go back again here within that programmable key pair introduction you can go to that Explorer from the very first page that introduction So within the Explorer you can mint the pkp so here I'm going to Mint one so you'll need some Matic to Mint just go to the test ombatic faucet and then be able to get that Matic so confirming okay I have one pending transaction so okay this was my pkp that we just saw me mint let's go view it we can check out that public key right here as well as that ether dress okay sweet we've got our pkp so let's go back so we want to use our pkp with lit action so I'm going to go into our lit action and everything that you need to know about lit actions is within our documentation if you have any questions please ask our Discord tweet on us and the easiest way to you to test and build with lit actions actually with our lit action CLI tool so going into here it's the get lit CLI command line tools so I'll help you create your lid action test it and then once that's ready you can take that lid action and put that within your project so first install the um get let's CLI I already have that installed so actually what I'm going to do is start actually in creating that project so from this very first step that command will need to initialize a new lit project we'll just initialize it in this folder here so we've created lit actions and then we want to let's say we want to just test it okay so if this is your first time setting up the CLI um you'll need to edit that Foo file to be able to build it and so the so every file should have a um let's see okay we okay um every lit action file within here should have actually a name so that's like that proper schema here when we check Foo we have that name we check hello for that main we have that name and so let's try writing that again actually I skipped a step so actually before we even do that build we actually have to do the setup so what the setup does is you get the ausig as well as you tie your pkp and so generally if you're writing out a lid action you would put it and you're writing out that code for it you would put in that pkp public Key address but here we actually have a way to help you sign for it through UI and then have that within your lit action so let's actually do get lit set up and then what you'll see here is this page that popped up and then I have a million pkp so I'll just select one okay great so all second pkp have been saved your config file you can view them at the getmet.dson let's take a look actually at that really quickly so here we have this awesome um so signature as well as rpkp public key and then from there we've updated our food that naming is all correct so actually let's do a build first before we test great build is successful why don't we do a test now and test we'll just test food agreed and then let's test Main and I'll show you that code for main so main is just a simple hello world um array that gets signed and then output back let's stream and so what we'll see here is that sign is State DSA function which we're calling the lit nodes to sign this message um likely within your project you'll be using the execute function so execute JS where you want to execute a lit action that has some logic or some conditional baked in it so here we see the signatures have been generated great um let's go back here so outside of that CLI tool which will help you just get set up really quickly I'll delete actions likely so requesting the signature saying sign the those are the examples that we've really been seeing with this little action likely going sheer what you want to do is so for this example we're calling executejs where you'll execute based on some parameters from your lit action code so example that might be conditional signing where you only want to sign based on some condition being met [Music] um in this case this is like the condition is if a user has X ether x-way and then calling this execute.js to be able to do that and we have a set of examples on our replit um so please be able to check that out as well as Fork those examples run those um they're really here for you to understand how to build with lit and then the last thing that I'm going to go I'm going to go over is using um how do you set up a way to tie in a Google account with a pkpe and then allow people to use that pkp or the underlying web 3 wallet essentially to do web3 Native things so this will help a lot with onboarding web 2 users to web3 this will help with abstracting away a lot of a lot more complicated ideas around keys and Key Management so be sure to go to this example pkp social auth example and um let's go through a the flow of it first before I explain some of that code so here we're going to sign in with lit and I want to just do my lip protocol account so I'm going to select one and then I'm going to sign this message so in another flow this would actually mint a pkp for the very first time that I'm loading this in and then I'm going to sign the message so this is my signature and this is my address and we'd be able to check that on chain so in this example we have just a basic repo of how do you set up um uh calling lit calling our relay server calling the Google pkp API as well and being able to use that all together to quickly spin up an application where someone could just sign in from just Google and we have additional off methods as well but you'll need to build in some of those relayers as well as a part of our relay is a gas abstraction so filling that in but you could use also use many different ways of paying for that gas not just through lit but through many other services okay so then now I want to close out a little bit with just letting you all know the resources that are available with our SDK so making sure that you all know that we have our API docs as well as examples within our reference here and then um further down the line outside of this hackathon please reach out to us about grants about things you want to build we're looking for ambassadors as well so being able to support this ecosystem where we're really trying to build decentralized technology to push forward data privacy to push forward usability of web 3. so thank you so much and I look forward to see you all in Tokyo and seeing what you all built 