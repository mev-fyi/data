foreign [Music] yummy data if it doesn't make sense to you don't worry we'll proceed to explain what this is so one query one query is all you need is the claim that I'm giving in this talk where if for you front-end developers I'm claiming that you can extract all the data you need for your front-end application in one query so a little bit about myself I'm a devro at mantle.xyz where Layer Two they just launched last week feel free to check us out mental.xyz and those are my socials so the number one thing for every dap is the front end I mean that's what your users interact with that's what you just see no one really cares about the back end it doesn't really matter how it organizes logic as long as it uses its aesthetic to the user the user will come back if it loads quicker that the user might come back more often so Albert Einstein the reactor has found a famously said that uh front end is just a well of bugs reason being because front end requires a lot of State Management you want to query data a data 8 and then you use data a to query data B and use data B to create data CDE so there's a lot of State Management involved so I'm here telling you that by querying all your data in one query you can avoid Auto State Management and reduce the number of bugs we'll go through like a simple unisol case study and everyone here I assume is familiar with the unisob model you put in some tokens and you get out some tokens so in this example we're swapping maybe say 10 if to usdc on the surface it sounds very trivial but behind the scenes there's actually a lot going on so um the front end is kind of anticipating how many if you want to swap what asset you want to swap for in this case it's eve how much of the asset you want to swap in this case it's 10 how much of the asset you want sorry which asset you want which is usdc in this case how much are you going to get out from this swap how much are the fees on a network in USD as opposed to if and what is the price impact do you have enough Eve to complete this uh this swap so and so on there's a lot of complexity going on behind the scenes and a very simple simple example of how one might approach this data extrapolation is with this example this example whereby you get the if address and from the if address you get the user's balance when you get the user's balance you can get the user's die balance and then sorry if balance or die balance and then you can get the uh amount of dye that the user will get swap out given this data this is terrible one mainly because this is blocking you're doing uh to get the if balance sorry to get the die balance you first have to get the if balances and so and so on so this is incredibly bad because it's blocking a naive approach to do this is paralyzing all these queries into a promise so you might call awake promise.org and query all the promises this is still good this is good this is better but you're still doing three parallel queries and I'm here telling you that you can do any amount of data you want in one query so yeah we can do all of this in one query and so we can do that with multi-call 3. for those of you who don't know what multi-call 3 is it's a smart contract that is deployed on I think 106 chains all using the create to op code so it's on the deterministic address and so you can use the same address for all 106 um or 106 chains traditionally without multi-call 3 how your dap would interact with the blockchain is by by issuing a separate query for each data extraction for example the idot balance off uniswap.sop amount out and the balance of e with multi-call 3 is actually a smart contract that lives on the blockchain so when you call multi-call.aggregate you actually call one query to the smart contract the smart contract then queries all the other relevant information needed from the other contracts so that way instead of using three queries you can use one query the problem with multicult 3 is that it is quite verbose by default if you're using etis which is the canonical Library these days to encode it you have to actually encode and decode your function into a very specific format so it's not very user friendly it adds a lot of uh complexity on the front end but it allows you to achieve querying parallel multiple queries in one query luckily VM I'm not sure if I'm pronounced this correctly volume from paradigm.xyz a new JavaScript library supports multi-colatory encoding and decoding out of the box um if you guys would like to check it out I think on the developer docs page you can you can see like there's a specific provider for the multi-callery provider provided that it's deployed on your chain so that's cool multi-call 3 is good but it's not good enough because it does not support dependent data and what I mean by dependent data is that it does not support the cases where the inputs to the previous query so to the current query is obtained from the previous query in this case we have a vault address obtained from a yield Optimizer we would like to then query that address to get the balance of our vault address which is simply not possible with multi-call 3 because it is stateless yeah so we can't do it in multi-call 3. however if we combine two little known hacks on Eve call and solidity we can actually achieve and we can actually achieve arbitrary arbitrary code and arbitrary business logic in a read-only fashion and let me explain a little bit more so for those of you who are not familiar with Eve call Eve call is an Json RPC method that is used behind the scenes every time you query every time you use a read-only function for example if on the front end I do die dot balance off user address WhatsApp actually be happening behind the scenes as I said I'm calling the Json RPC provider if call and it's providing it with a transaction object for example an address the two address the data blob and then it will return me the data so that's what's going on behind the scenes a little known fact is that you can actually use if core to query data from mutable functions an example of this would be the uniswap quota so traditionally the unisop quota is a read as it is a write function it's a mutable function for example the function quote exact input is external it's not external View and it's not external pure what that means is that if you're using it based on the ABI loan each query will cost you gas but you can actually do it in a view only mode and achieve the amounts out without without sending a transaction so you can actually query traditionally read functions in a read write functions in a read-only matter so cool that's cool we can read on the right functions so what okay hear me out so what if if we hijack solidity and made it return data in the Constructor and write the data extraction logic in the Constructor then we use if call to perform a read-only contract deployment to extract out the data we want does anyone get that that means what if we write average we can write arbitrary code because traditionally solidity does not return any values when you create a contract so what if we hijack The Constructor to force it to return some data and while deploying that contract we get back some values okay again let's recap okay what the dog said for one we force the solidity Constructor to return values two we write out our business logic in the Constructor AKA writing out arbitrary code three we use Eve call to quote unquote deploy the contract and upon deploying the contract it will our Constructor will execute the business logic and return us the data because we've hijacked it to do so so this is how you force the Constructor to return values we we need to go into assembly mode now we have some kind of arbitrary data that we want to return return data we perform our data extraction logic or business logic AKA arbitrary code in the middle section we API encode it and then we force we write some assembly to force it to return some data and that is how you force a Constructor to return values next once we've written a contract to pass our custom business logic we can use ifcor to deploy the contract and by deploying the contract with provider.call which uses if underscore call behind the scenes we're able to deploy a contract with custom business logic in a read-only manner and extract out our data the only thing left for us to do now is to format the data into a into its its relevant data types for example un256 strings or bytes depending on how you you packed it and that is how you can query all the state you need for your front-end application in one query some potting remarks is that you know if call actually has is actually really powerful it has a lot of uh undocumented well not well not well-known features behind the scenes such as the state override set where you can actually overwrite the call the code or the storage slots behind the scenes you can also overwrite the balances or nonsense of things it's very very useful when testing things um Gaff the the most popular ethereum execution layer has a graphql server behind the scenes so you can also extract a lot of data if through graphql instead of the traditional IPC methods uh yeah I have a proof of concept on my GitHub it's uh github.com Libby VM slash Eve call abuser there's a proof of concept there if you guys would like to check it out um yeah thanks for listening any questions oh yes yep I realized I went a bit quick here have you done any uh benchmarking to see what the actual performance improvements have been I mean this is more like uh it's well it's the same I mean it's all on latency you you're offloading the computation to the ethereum node so you're not actually on speed wise it's the same because you're not actually doing any additional uh the the amount of data isn't that significant yeah it's kilobytes unless you're unless you're on like I guess 2g or 3G it might make some issues but I think tradition on on most apps it shouldn't matter yeah because there's a contract size limit of adding a few kilobytes are there any other protocols using this in production right now no I'm using it yeah awesome thanks thank you 