hey yo what is going on everyone shaun on here again from eath global and welcome to the graph workshop i'm here with david from the graph would you like to introduce yourself for sure uh yeah i'm dave i've been working the graph for the last three years focusing on the the smart contracts and the protocol and a lot of subgraphs as well hence why i'm doing this presentation today all right that sounds really really cool well take it away david this is going to be awesome awesome thanks for the lovely intro i will now share my screen and let's get started so i'm just starting off here uh going over the prizes that we're giving out for this presentation or so sorry for this hackathon so there's 7 500 in total um and we're we'll get into the details of what a subgraph is for those of you who don't know but essentially you can see there's a couple of prizes for different subgraphs so the first prize to focus on is there's three prizes of 1500 die for the best sub graph on a scaling solution supported by the graphs hosted service and we'll see what you know the hosted services and what it what i mean by scaling solution then there's another prize worth a thousand die for the best new subgraph that could be any subgraph at all and two prizes of 250 die for the best meme related to the subgraph i didn't even know about this one that's awesome i hope i hope somebody crushes that one and we also got the graph will award one prize of 1500 to die to one of the following subgraphs built on one of the sponsors for scaling ethereum which is wearable ens matic uniswap or ave so those are the prizes you can find them for you know on the scaling ethereum notion document you got there and now i want to go into the graph and what it is and you know a little bit of background on you know what this presentation will be it will be a background of what the graph is and then we're going to go over a really quick example and all the examples there for us to show you how easy it is to get blockchain data from any blockchain that the graph supports and how quickly it can be done and really it gives a lot of power to any developer in the blockchain space and so what we're looking at right here this is the hosted service this is for the graph network this is where anybody can come and deploy a sub graph for free and it's kind of like a testing ground and you can see you know there's a if we click on unispot v2 here there's a playground right here where you can test all these queries to get all this rich data back from the blockchain so here's all this data that gets returned and this is all from a subgraph right and we're going to see how to build all that but this is essentially the hosted service and we're going to deploy a subgraph to the hosted service in this example but one of the main things i want to focus on as well is that this is the scaling ethereum hackathon and we don't also you know the graph has originally was only supported ethereum mainnet and the test nets for ethereum but now we've also been adding a lot of blockchains over the last year and so some of the blockchains we do support right now are ethereum xdi poa uh binance smart chain phantom fuse clover ceilo avalanche um polygon which is formerly known as matic as well as you know we have other things in the pipeline as well we we have we previously supported optimism but that's on hold now until they actually launch their their mainnet and we're also you know we have a couple blog posts on multi-blockchain uh the multi-blockchain future for the graph and there's there's projects we've mentioned there such as polka dots such as solana that we are you know we've we've looked at and we're we're planning on adding although they're not ready yet that's kind of the vision of the graph right the graph is this big project that's that's going to index all the data in web3 and in blockchains and make it available to people and that's why we're adding all these other blockchains so for this actual tutorial um i'll go go through and show you how to um deploy to a subgraph to a different network and really any of those networks i mentioned um you know like matic uh xdi poa finance smart chain they can they you can deploy a subgraph to all those and so there's some other valuable uh resources i want to share with you here before we hop in there's the graph.com docs and if you go to the front page there doc home there's the host of service docs this is what you'll be interested in for the hackathon most likely and this will go through you know more in depth what i'm describing in this in this short presentation and this you know if you're really interested in your your new person this is where i would recommend you come to to to understand what's going on right so there's there's a lot of good information here i'm not going to go over all of it i'm going to go over a subsection of it to allow us to complete a deployment of a subgraph today so you know one other thing i should probably get into before i show you how to deploy a subgraph is really what is a subgraph and you know a sub graph is basically a it's like a subset of data that is being extracted from a blockchain and presented to somebody in an indexed way so it can be queried uh you can take basic blockchain data that's very simple you know it's the stationary value that is updated on ethereum and you can build historical data from it so what it allows you to do is extract all this rich data out of blockchain's index to put it in a database and have it you know queryable in a super fast manner because if anyone's ever dealt with ethereum development you know many years ago before the graph existed it was really really slow to query you know an evm node directly and part of the reason is the evm node is not built to return queries right it's this it's this decentralized network that is you know its goal is to make sure that the chain um you know the blockchain goes in the right order there's not too many uncles the chain doesn't fork all this that's what it's more focused on the distributed peer-to-peer um stalling of blocks right it doesn't care too much about allowing all the data to be accessed very easily so that's where the graph comes in it's this layer on top of you know blockchains that allows data to be extracted so that kind of defines what the graph is now what is a sub graph it's you know it's if you really dig into this whole document right here the docs it'll describe it but essentially a subgraph you know my favorite way to describe it to somebody new is looking at the subgraph manifest so the subgraph manifest is a yaml file and it's actually really easy to digest once you read it you know it's very human readable and as you can see right here this you know this is just you know getting right into it the spec version is 0.01 that's pretty straightforward description gravatar for ethereum so gravatar is the name of the example subgraph that we're looking at today repository on github schema and we'll see what the schema is in a second it's a graphql schema if you're familiar with graphql that's great if not i'll give a very short explanation and then we get into the data sources so this is where it gets you know a lot more this is where the sub graph itself starts to designate what specific blockchain data it wants from a specific blockchain and from what specific contracts so if we go down this kind is an ethereum contract its name is gravity it's on the ethereum mainnet and here we go this section right here source so this is you know a contract on ethereum mainnet and we're telling it the start block that this contract was deployed on a chain reason for that is if you know when it was deployed you can skip you know the first six million blocks here you don't have to the graph node does not have to index all those past blocks you can skip right to when it was deployed as you see that's how like you know we're starting to like really hone in on the specific information that we're trying to extract from the blockchain and now we have you know we've identified the blockchain we've identified the contract we're looking at now let's figure out what we want from that specific contract now there's a few things that we can get we have these things called event handlers call handlers and block handlers so if you're familiar with solidity there are events that can be emitted by smart contracts and so a city developer will create events and it's basically just you know it's information that's output as an event it's not stored um persistently on chain anywhere it's in in storage so it's a lot cheaper to emit an event and usually an event should be triggered after a function does something that updates you know this the smart contract storage and then you know you want to release that information to your world in a more easy and easier manner right so that's what events are there for and you know in my experience most subgraphs can be written with just event handlers but what we also have are call handlers so call handlers are executed when a specific function is called on a smart contract so each function has a um a specific function signature which can be detected by the graph node and so if a function is called we can trigger on that as well and when these event handlers and call handlers happen what we're doing is we're running a mapping and then you'll see this the mappings are written in typescript and this hand this mapping called handle new gravatar it actually gets run and it stores this information in the blockchain or sorry in the in the sub graph and so what we're doing with these handlers is really like it's taking specific information on the blockchain uh from event server from calls and then storing it in the subgraph specifically and so it's really really powerful we've gone from you know you pick your blockchain you pick your address on a specific blockchain of this smart contract you're looking at and you pick the specific functions that you're interested in and the specific uh events that are emitted and you can build really really rich and important like uh data structures that can be you know released in this subgraph that the whole world can query and so one thing to also mention um because for example like one of the block there's a couple block chains that are that are evm like forks like like polygon right but if it's an evm fork and they don't they only support geth which is the case for polygon it means that call handlers won't work and the the nuanced reason for that is that the call handlers only work on the open ethereum node so that's why it works for ethereum mainnet you just have to run an open ethereum node that's an archive node and then you can you do these call handlers so if you're running on something like polygon which is deliberately a fork of death uh you'll only be able to use event handlers and block handlers and so that's just something to know you know if you ever have any questions you can come visit us in our discord channel and we we can help you out there for sure and the last one are block handlers obviously that just happens on a block whenever a block is ingested by the graph node you can trigger something but i don't see these used too often because it's actually quite expensive to trigger every time that a block is emitted um it's a lot of work to do and there's not many use cases that i've seen other than you know if you want to store specifically ethereum block information in like a block sub graph so that's good to note um most likely you'll be dealing with event handlers anyway so you probably won't have to worry too much about the call handler scenario i just described next if we get into the graphql schema so yes this is the schema that you know defines the objects that you want to be displayed in your sub graph so if we quickly go back to the unit swap sub graph this is what i'm talking about this is a entity as we call it and if you're familiar with uniswap you know there's a token this could be the graph token it can be any token and it has all total supply in the you know the uniswap uh or the uniswap uh you know exchange or on on chain exchange right and how much trade volume total all time how many transactions have happened uh the symbol all this information right you have other ones as well like a user so you can see what liquidity positions a user has um what transactions they've done and this is also interesting we have pay pair day data and pair our data so this is information that allows us to store you know historical uh graphing data for um the sub graph and you can display it as we see here in unityswap.info like this is all created by a subgraph it's very very rich and like it has a ton of information and that's not just not stored in the smart contracts because that would be super expensive actually like would never work on ethereum right but you can create a subgraph and you can build these and then anybody can use it it's really really powerful so that's basically a schema right it's graphql there's a bunch of documentation on graphql online if you're not familiar um but essentially you come along and you define the entities for the smart contract you're looking at and for the gravatar example you know a gravatar is like uh an avatar basically with with an image and a display name and an owner on ethereum so it's like whatever your twitter handle would be with the description right same idea and as you can see this is pretty much a straightforward entity this is you know this is an entity we're storing within the subgraph we're going to take the information from the ethereum smart contract and put it into the into the database with this structure and that's pretty much you know a subgraph schema you're not it's important to design your schema and put a lot of effort in up front but once you have your schema designed it's pretty much like set you might make a few changes um or you might want to expand in the future but really the bulk of the work that's going to happen is writing mappings so you know i've just discussed the subgraph manifest with you guys and it kind of is like the instruction manual for the graph and like the graph node in the graph network to know what data you're specifically looking at and then the graphql schema that's kind of your your like thesis of what the subgraph is supposed to be right you're you're saying what data objects you want to be stored and how you want them to be queried and lastly we're going to do writing the mappings which is the bulk of the work really because the two things i described are more or you know it's an instruction manual and a thesis and this is the the part where you connect you know what's on the blockchain to what you're trying to build in your thesis with your subgraph and this is where the bulk of the work comes in it's it's it's parsing all the data on chain and putting it into the format that you want to share with people in your subgraph so the mappings are written in typescript and they compile down to assembly script and essentially as you can see here we have you know a mapping this is this is a typescript code we have an event so this is an event in smart contract that you'll see in a little bit it's called new gravatar and so there's this function handler handle new gravatar which we saw up in the scheme or in the manifest and essentially that means when this event is emitted on chain this code is going to run so when it happens we create a new gravatar entity we give it the id that was emitted in the event and we're just simply setting the variables we saw on on chain in the event to the entity we have in the subgraph so this is event event.parameters.owner and we're storing it right in subgraph and then we have another one down here for handling the upgrade or the updating of avatar and this is a really simple mapping right here and it really you know isn't too complex but you can do a ton like if you look at the unit swap subgraph which is you know open source there's a ton of stuff that's happening there to make those rich charts that i showed you earlier so now let's get into the actual deployment of one of these sub-wraps now that i've explained it to you so we go here and this is the sub this is the graph we're at the explorer you are going to log in with your github account and go to your dashboard and what you're going to do is you're going to add a subgraph and so i'm going to name this scaling aetherium presentation prep presentation um and before i get in to deploying this i'd like to ask if there are any questions from the people viewing yes dave there's a question in the chat can we use the graph to build a merkle tree if the events were to build a view across multiple chains or can the graph only view one chain or a single chain at a time so that's a good question yeah um there is like this is a i would call it still a research question that we're dealing with at the graph and so you can imagine like you know you have a graph node and it's indexing a sub graph on binance smart chain and it's indexing a subgraph on polygon and indexing a subgraph on ethereum now all those chains have different block times and that is going to influence how the graph node operates it's it's easy to do one in isolation but let's say you want to create a sub graph that queries multiple different blockchains and has guarantees about what the query actually is and what it returns it's a lot more of a complex problem to solve so ultimately yeah the goal of graph is to be able to resolve um blockchain information from multiple blockchains at a reasonable time right like if it's if it's if it's six seconds like polka dot in 15 seconds like ethereum we want to have those as live as possible um but that is still an area of research that we're going to be doing because it's really you get a lot of things crossing over in that scenario and it's just going to be you know it's going to be a complex part but that's what we're here to do and we're excited to build that any other questions sorry i need to pull up the chat here as well for uh zoom uh no other questions in the zoom chat for now so you can feel free to um like keep going great yeah i just i have the chat open now as well i will continue on oh i see another question i'll answer really quick does it only work for evm compatible right now that is the case um so the chains that i mentioned before is like xdi poa bsc phantom those are all evm chains uh we do have blog posts out explaining the chains we're going to look at next because we are going multi-block chain and some of those named are like polka dot and solana but those are also new you know new endeavors for us i wouldn't call them research like the one i just said previously we're actually working on these other ones these multi-block chain um support i guess for the graph node but it's also you know it's it's a new it's a new domain that we need to master essentially um i think everybody's familiar with the evm but you know as the graph as these other chains like polkadot and solana same so will you know the other service providers and and people all in blockchain you know building wallets uh building block explorers all this stuff so yeah we we will be getting there and uh you know we're there to help these teams um allow people to get information from their blockchains easily as well great so i'll get back to this this is the you know the juicy part of the presentation doing all the coding and showing you how to deploy a subgraph um just let's give this a quick subtitle um just because it's needed some other information you can fill out here uh not needed i'm going to hide the subgraph because it's just a you know it's a presentation subgraph and it's it's not very you know it doesn't need to be shown to the world and now you get to this and i've now created the subgraph on the hosted service so you look up here in the url it says davecad that's my github name and the name of the subgraph that i chose and you can simply just follow the instructions here so let's install graphs tli now on my computer and that will allow me to deploy on chain or sorry to the hosted service so if i do this just installing graph cli with yarn on my computer let's go back to the presentation all right so that's installed now we need to init a project so this is the example project i'm going to do um we have to run this command here so this is just creating the repository we made this command for people to um scaling we made this command for to make it easier to set up the repository uh you know it's kind of like scaffolding code and so you go graphic knit from example um what did i call it again scaling ethereum presentation and this should work it should take about 20 to 30 seconds and this is all that this command is doing is setting up the scaffolding code and what we're going to see is it's actually going to set it up and it's going to be for uh main and ethereum but something i want to focus on here is you know how you would deploy it to a different chain and so i'm actually going to deploy this to theory mainnet but i'm going to go through how you deploy it to you know matic or or buy not smart chain or whatever evm chain that you're actually using um we'll just keep waiting for it to uh finish here great and so before i do that let's go back here and it's asking me to run yarn install and uh yarn code i already worked so cogen is oh yeah sorry i have to actually cd into that folder so now i'm in the folder that i just created with graphinet now let's run yarn install now let's run yarn code gen and so cogen just creates these typescript kind of bindings to make it easier to interact with the smart contracts basically so you have to create them from scratch and so now we're at the point where we're going to deploy it and it asks us to run graph off and so we're deploying to the hosted service which is this and the access token so first i'm going to copy this and go to my terminal it's asking for my access token and this allows you to deploy to the um hosted service so i copy my access token here which is showing right there it should it'll be there for uh it'll be different for yourself just run that it should say it's all good all right we are verified and now if you go here it's going to ask me to run graph deploy and before i do that i just want to quickly go over the code so let's open it up with vs code and this is the repository this is what a typical subgraph repository looks like and this was auto-generated with graphine it and i'll focus on the files i've already showed you guys uh so let's go here this is the manifest that i showed you guys earlier right you know we're on ethereum main net this is the smart contract address so the thing that i want to point out here is if you're deploying to a different chain you're essentially going to type in the command here like uh polygon and that's all you have to do now you're pointing to a different chain and now let's say you have your own smart contract on polygon you're going to type in the address that you have for that or whatever uh project that you're indexing on there so then you know and if it's a different smart contract you're probably going to have a different handler so you say like handle uh transaction right and you're just going through and updating this um i'm going to revert all the changes i did here because we're still going to be dealing with this uh gravatar contract on mainnet but you know the other thing to focus on is i don't know the exact command for binance smartchain but it's probably bsc uh you know if you're doing poa it's gonna be that it's very simple um you just gotta we have the documentation for all that as well so let's replace that with maina and that's how you can really deploy to any of these uh networks and so you know in relation to the prizes and stuff um that'll be very helpful for you because likely with this hackathon you might be deploying on something that is is you know l2 or some other network so um that's something to pay attention to here is the schema um as you can see it's just very very simple it's a gravatar has the id owner display name image url um and that's all we're storing in this in this subgraph right and so if we go up here you need the abi to create the typescript bindings this api comes with you know every smart contract that's created you should be able to find it online or you should have it yourself this is just a binary file we don't have to worry about the contracts now you don't have to store the contracts in the folder this is just here for convenience and as you can see these are the events i'm talking about these are this is how the event handler runs these events are you know commit new gravatar it's submitted when this function is ran and we're basically just going to store this information in the subgraph so you know this contract like i said only here for you know learning purposes you don't need to include that in your own subgraph folder these are just generated files that's what happens when you run yarn code gen um migrations are the typical you know migrations that come with the you know kind of like truffle and everything we don't have to worry about that a bunch of uh setup files and now the source code and this is the mapping that i've been talking about so as you can see this is also very straightforward it's you know it's triggering on that event and it's creating a new gravatar and storing this information and saving it so saving it goes into the subgraph you're saving it in the database and once that's saved that means you can now load that entity and that's how you update it essentially um and this is a common pattern you see sometimes you might load it and it might not exist yet so it returns null and then you create a new one and so that's a mapping and this is likely going to be where the bulk of your code is ran or created because you know this one's really simple but if you go to the unit swap sub graph it's i think it's thousands of line of code thousands of lines of code and that's really where the bulk of the work is because it's where you're you're taking what exists and you're making it into what you want it to be right so you know that's pretty much you know all you got to see in this repository and let's now deploy this uh this subgraph so let's copy this and i'll just have to replace this with what did i call again i'll just get it from here so scaling ethereum presentation next time i'll pick a shorter name and this should deploy and so right now this is you know connecting to the hosted service sending all the subgraph wasm files to the hosted service uploading the quasi files ipfs so that you know they're they're out there and so in the graph network everybody could grab them and now it's deployed so if we go here um [Music] before it was in an undeployed state now it's deployed and you see it's already synced up it's already synced up 12 million blocks because this sub graph already exists but as you can see all this information is stored within the sub graph and we're extracting this from the blockchain so you know this is you know the example query showing the first five but really all this information um is is taken off from chain like taken from on chain and it's really easy to query it's you know milliseconds to get this information and now you have this end point that anybody can query around the world and get this information and that's what makes the graph so powerful and you as we have this platform people will continue to build on it and build and find new ways to present information to people around the world and as more information gets stored on blockchains that just makes the graph you know that much more useful to to the world to to use as a querying protocol and an index in an indexing protocol um so that's all i have to say for the presentation um i'd love to take any more questions that people have wow that was an amazing presentation is one question in uh the chat can the graph keep up with solana's uh yeah that's that's kind of the question yeah so i think they said celina has a 400 millisecond block times so that's a good question um could the graph do it right now i don't know um i'm not like i'm not the graph node developer that is a you know but we have a team of rust engineers who do that um realistically 400 milliseconds is a lot faster than 13 seconds which we see on ethereum so could it do 400 milliseconds maybe if there were not that many transactions um but there's a couple different aspects of scaling here right so if it's 400 millisecond block time and these blocks are filled with a ton of information it's going to be more pressure on the graph nodes to run um it also depends on the mappings that you're seeing so in that unit swap sub graph i showed to create that graph that pink graph that goes up into the and to the right um that takes a lot more power and and time because those mappings are creating all of these entities on one transaction right like i trade on you swap but it has to update six entities within the sub graph so that is going to be a lot more stressful so you know i think whenever we get solana working um it'll be a progression of you know first dealing with the 400 second block times which you know technically of course we that's possible to do you know nothing's impossible in in in the world you could debate that i guess but um of course we can reach the four millisecond it'll be an engineering effort and the one that we're you know working on this year then it's also going to be can we keep up with you know solana if they're fitting in a thousand transactions in each block um if so then that's great and maybe we're gonna have to improve on that as time goes and then lastly we're also gonna have to work with um subgraph developers to teach them that you know you can't create a mapping that wants to solve all the information in the world um we're seeing this a little bit if anybody's paid attention on on the pancake swap subgraph um it has fallen behind before in the past and that's because finance smart chain has three second blocks but it's also the the sub graph um wants to do a lot in a short amount of time and you can easily ask it to do less you could even split it into two sub graphs and then it would be twice as fast so there's a bunch of different ways we can optimize the graph node to get to that 400 second block time as well as working with subgraph developers to speed up the time that's that's an awesome answer um i wanna so i wanna be wary of your time um and really appreciate your chan here there are a lot of questions um from both you know just zoom chat and on youtube so i want to remind everyone that um you know if you are a hacker feel free to go on to the um sponsor the graph channel um and then just you know paste your question in there uh someone from the graph team will help answer the question um but yeah thanks time for coming everyone really appreciate your attention and um again great presentation david really appreciate it thank you so much awesome guys have a great time 