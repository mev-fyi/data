foreign and welcome to the hack FS Workshop using Durand and time lock encryption joining us today is Patrick McClurg who will be taking us through the session and with that I'll pass over to Patrick to get the session started I think we're much Roy yes welcome everybody to the d-round hackvest workshop uh first we'll go over a little bit about the challenges and then we'll dive into what the round is how it works uh then we'll finish up on what timeout encryption is and how you can use it and then I'll field some q a at the end for any questions you might have along the way uh uh so firstly the challenges are twofold first is for the best app built with time lock encryption that might not make any sense to people who have not come across timeout encryption yet but we will get to that very soon uh secondly uh there's a prize for the best used to do around that solves an everyday problem and improves the security profile of a blockchain use case a game or improves the Durant ecosystem and there's uh two thousand dollar reduce our programs uh for people who make the best apps essentially Okay so what is Durant Durant is a decentralized threshold Network for providing publicly verifiable unbiasable random numbers uh it's based on threshold cryptography as I said um and on supports pairing operations which we'll come to a little bit later essentially when the network is created a verifiable secret sharing process happens and a shared privately amongst all the permit Testaments of the network has created which new single party has access to uh and then they emit Randomness at epochs using the signatures from threshold cryptography it's built on BLS 12 381 has been tested audited by kudelski security and deployed at scale the the biggest user right now is Falcon Network who used the randomness from Durand for leader election and some other proof of space-time related things and currently dran Randomness is available on the fvm and the cosmos ecosystem and kind of on ethereum in fact in one of the previous ethereum hackathons a team-built ethereum integration for drand called orangesus which I've linked in the bottom of the slide here in case and if you want to try it for yourself so a bit of a primer of my dram works the notation is not super important that's for the mass nerds who like all the extras but in essence uh D random it's Randomness epochs each of these epochs mapped to some time on the clock so for our default Network that's every 30 seconds every 30 seconds the nodes in the network gossip are partially signed message over the the number of that epoch and then when any node gains a threshold number of those signatures they can aggregate them into one group signature that's valid for everybody in the network because as I said before no single node in the network ever has access to the private key that signature is indistinguishable from Randomness as they can pre-imagine uh then we pass that signature through a hash function to remove some mathematical properties from it and that becomes or a random number and this happens at every single Epoch everyone in the network gossips all the partial signatures to one another and create the randomness you might be familiar with some existing types of Randomness and I'll just give a brief breakdown of how diran differs from those um so the one most people are familiar with is dare view random built into all Unix machines uh and Linux machines and MAC machines and there's kind of an analog in the windows world it's probably what you use to generate your Bitcoin Bitcoin private keys and to do lots of other day-to-day Randomness operations um the biggest difference obviously is the dev view random is private Randomness and dran's public Randomness so naturally you wouldn't want to give your Bitcoin private key to anybody else unless you want them to take all your cash uh demand hiver all the random numbers are public everybody can read them everybody gets the same random numbers uh Additionally you run you random on your own device but dran is a decentralized network so there are lots of different participants working together to create this randomness and finally d-round is verifiable so if you were to get our number from a random generator you've sort of got to trust in the fact that uh it's implemented correctly that you're using the right generator that the number that comes out is actually random uh but because drand is based on a signature scheme um you can verify the fact that that has been generated correctly and because of the property we mentioned before of not being able to pre-image the signatures uh it's both random and verifiable which seems counterintuitive at first uh so dipping into some more of the public Randomness world for people who built an ethereum before they may be familiar with randow randow is a Dao and a smart contract on ethereum network um where users omit to providing some bit of entropy to Smart contract and at a later Point reveal that entropy and those uh it's a Randomness or aggregated together into a final random number oh do you round differentiates from this is firstly it's unbiasable so you can imagine someone who has a lot of power in ethereum network like let's say a coinbase I can actually take up many slots in this uh a round out contract and they can choose to reveal or not reveal their little bit of that Randomness based on the prior outputs so if you manage to get some number of slots at the end of any round out Epoch you can output you can influence the final result also a cool thing about dram being based on a signature scheme is that it's not just web 3 only so it's not a d-round blockchain per se it's not just on on one blockchain in fact you can get the Iran beacons from any CDN you can even get them from an adversary and because they're verifiable you can know that the dram network has generated that random number um a final project which is very commonly used at the moment in blockchain ecosystems is chain link brf uh chain link brf allows you to request random numbers and they create some uh proofs and write them somewhere before you use them to show that the randomness has been generated fairly uh firstly like randow like the difference with randow chaining is primarily for on-chain applications but also the trust model is very different um you're contacting one party chain link to run that function uh to Output this random number whereas d-rand we have a network of participants and you must trust that there's never a threshold number of malicious parties in the network and so the model's just a little bit different um so a little bit about the networking uh we currently run two networks in production uh the default Network and the facet Network the core differences between them are that the default Network emits Randomness every 30 seconds whereas the faster Network releases Randomness every three seconds uh they have different URLs for for interacting with them naturally and also they run in slightly different modes so in the default Network running in chained mode each Beacon contains a reference to the randomness from the beacon before it this means that they form a bit of a Merkel dag and uh one drawback of that is that we can't do time lock encryption which I'll come to later using this chained mode faster Network by contrast each Beacon stands alone it's not linked to the previous begin through this chain of signatures and that means that we can predict uh all the future messages although not the signatures um for beacons that are going to come out in a facet that's the secret sauce for time block encryption which we'll come back to in a bit uh also my third extra for any math nerds uh in in facet we swap the G1 G2 grips in BLS uh in order to have smaller signatures and bigger public keys because the foundation of the network we create one public key and that every Epoch we create a signature which obviously is the randomness so it means you can save gas costs if you're using it in a blockchain so if you were to go into your terminal 9 and request some Randomness from the dran API you would come up with something a bit like this um the top entry here is the round number so that is an epoch that's a monotonically increasing number every time the network emits a piece of Randomness uh is that a new brand it also Maps a specific time on the clock so uh you can predictably um know when a specific brand is going to become available the next key in it is the randomness itself which is a sha-256 digest the signature um Third Field the signature is predictably the signature um it's a group signature for the entire network so again it's uh the the key pair that was done uh created during the uh distributed key generation process and it's BLS 1231 for chin networks is also a previous signature which like I said links to all those previous beacons uh so the easiest ways to get to around are to use the client libraries we provided one and go and one of typescript those are the official ones of course you can get it through any CDN through any HTTP client you wish but these also bundle in verification the signatures as well just so you don't have to do it yourself also everyone in our community seems to be a rust station so there are a whole bunch of different rust clients for those of you who like writing things in Rust and also actually this one the top one d uh is also a CLI that can do timeout encryption and lots of other cool operations uh so you should check it out because it's awesome uh I've got a slide that says demo time now which is slightly a lie it's more a bit of a Code walkthrough in a demo [Music] um let me kill my presentation momentarily I'm just going to go into the integration tests of the drank client for JavaScript I think it's an easiest way to understand exactly what's going on and at least you can find it later in case you don't really remember what happened in that presentation um so we've got an integration test here essentially you create some Plumbing uh or fetching the public key of the network which you can also do out of band there are other objects that allow you to not have to make requests for them we provide three main functions firstly you can fetch a beacon by the time you can just pass in a classic JavaScript date and the mapping between world time and d-round Epoch will be figured out magically for you if you happen to know the epoch that you want to use you can also pass that in and fetch a beacon just by its round number finally we provide a watch function so if you're for instance building a game that needs to consume Dron Randomness in a timely fashion at every single Epoch you can get an async generator here that will call some callback uh whenever you receive the randomness these are also more or less available in the same format in the go Library so I shunt go into the go Library but any questions on that obviously hit me up and okay so that was how to use derand and a little primer and how it works let's now look into time lock encryption uh it kind of does exactly what it says in the tin it's encrypting something nigh that can't be descripted until some future time has passed uh the Crux is at the dran network is a bit like a reference clock it ticks um for every Epoch and a mid-sad piece of randomness and so we can rely on it to map clock time uh also side note uh my colleagues presented the terminal conscription scheme at real world crypto um so if you want to go a longer form explanation of how it works and all the Gory details uh you should definitely go watch uh the talk of an advanced encryption in real world crypto so diving a little bit deeper hardo's time encryption work well it's simple uh fancy math I guess is a short term uh for those of you whose eyes are just glazed over after uh you know going through school and seeing discussing things like this we're not going to dive into this don't worry I've simplified it uh just a little bit further so I said in one of the first slides that BLS 1231 supports a pairing operation this is essentially exploding some mathematical properties of the equation as it were in such that you can move different things around without changing it so time encryption Works a little bit like traditional asymmetric encryption in traditional asymmetric encryption you've got some public key that you use to encrypt Upland text and the output of some ciphertext and if you take the side protects and some secret key that has a relationship to the public key uh you can combine them and and decrypt the ciphertext and come up with a plain text what time lock encryption does is basically turns the round number into a public key and the signature that gets emitted from that round number into a secret key so like I said before in Unchained mode because each Beacon is not linked to the beacon before it we can predict the exact message and exact bytes that will be uh signed over by the network at some point in the future that means we can we know that message now we can use it as a public key to encrypt something and we won't be able to decrypt it until the dran network emits a piece of Randomness in the form of a signature at a later point in time uh we've built some libraries around it but also a cool web demo which you're welcome to try now it's called time Vault it is a web application for encrypting vulnerability reports so that when you find all those Adobe flaws even if they take you out with an assassin the world can still know what you find uh it's built using tlog.js obviously it's backed by the dran network um I'm not going to demo it now but you can obviously open in your browser and give it a fiddle for yourself all the codes open source it's all in GitHub and there's also a paper on ePrint if you want to know how it works uh before we do the Q a I will give the same not quite a demo of tlog.js again we've got some integration tests in there I think those kind of give the clearest picture of how to use this in practice um but then essentially we bundle some mainnet and Tesla clients in here there's a function called time lock encrypt you pass a round number that you wish to encrypt to in there there's some tooling as well around um mapping that round number to wall clock and and back and forth and then there's a Time Mark to Crypt function which takes also a client and takes your ciphertext um it supports um an asymmetric encryption of the hook called again actually good encryption which works and looks a little bit like pgp if you've already filled up a time Vault you'll see that um the output of a cyber text here is this cool I gain encrypted file which again looks a bit like a pgp cycle text so um yeah I employ you to get involved check it out and try all the libraries um luckily I've lost plenty of time for Q a um so if anyone has any questions about d-rand or time encryption I'm always I see oh there are some in the chat here is linked to the generator random numbers set yes indeed it is a shout out of absolute digest so it's got a fixed length hypothetically you could do your own hash key derivation function on top of the signature as well um there is in fact somebody raised a PR somebody from the community or spr to do that on the dram repost so there's some priority if you want to go and check out how they've done it or uh or come up with your own derivation function uh Tony is it going to be available on chain that depends which chain you're using it is available in the cosmos ecosystem already through the noise Network that's nois um it also d-round Randomness is included in every block header of the Falcon Network um so you can currently access it through the pre-randau opcode if you're building an fvm actor for instance it's not currently available out of the box on ethereum although as I said before um there's a project called orange Jesus with a G and not a j that have built all this for Relevant bindings to do on on ethereum if you'd like to do so yourself unfortunately BLS operations are a little bit expensive as currently they're on pre-compiles on the evm flat but there is an EIP up for them so you should go and uh if you want them go and hassle ethereum people to get it merged uh Max Ken asks do you have a link to the pr for the transformation function function to decrease the length um I can find one for you very quickly yeah so in fact here's some useful things um you can find it somewhere here in the pull request and pull it out for you into kdf yes here it is from Mr Gorman um although there also is some prior art in terms of you know if you for instance wanted to pick from one of ten items there's a cool project called derandomizer with an S the Glorious British spelling and not the American spelling which provide some tooling around doing that in in the correct way to avoid modular bias and stuff so worth checking that out I haven't linked it here but again you can find all manner of projects under the drowned organization on GitHub uh surab asks where can we find some use cases I joined it list which has been discussed um well that's up to you in the hackathon of course and some existing use cases we have seen we've got some people building games on top of Duran so for instance for uh either randomizing item drops or um defining the variables of certain nfts for certain items and games that's been one example we're also working with a not-for-profit called social income who are providing Universal basic income in Sierra Leone and they're working to use dran to randomly select the people um who should receive that Universal basic income we also developed a sample fvm map called B raffle which is basically a bit of a raffle slash Lottery type app for drawing winners from a smart contract uh some other possible use cases or time knock encryption a very cool one which might be hard work in a hackathon but MAV prevention uh minor extractable value if you could for instance uh time lock encrypt the member of a blockchain you could stop miners from either reordering or not mining transactions based on uh gains they think they might get from them other use cases generated drawing anything anything needs to be fair Lottery wise or um and the time lock World things like uh wallet recovery automated uh dead man switches uh auction applications I'm sure there are plenty more that you guys can think up that I haven't thought of and I I hope that's the case I'm excited to see what people build uh how can we get your slides that is a great question I will make them available through uh the hack FS people I'm not sure if there's a centralized channel for that I can also stick them on ipfs after this and post the uh the Sid somewhere for people to retrieve them um yes obviously if you have any further questions you can ping us on Twitter we're also on Blue Skies we're helping with it and there's a link to our slack workspace here as well lots of people talking about different use cases and cool uh things that they're building in there so feel free to get stuck in hey Patrick yeah for the sides if you want to post them in the Discord channel that might be another option as well that's the best idea actually and I will do that immediately after this talk awesome any final questions from the chat well if that's the case thank you very much everyone thank you for listening I hope to see lots of cool applications built on derand on any questions find me ping me tag me answer them oh there was uh oh there is last question can you iterate on the future file encryption uh well one cool iteration on time block encryption that we would love to have is some kind of proof system on top of it right now there's no way to link if I say I'm including something nice to prove that what's in there is actually what's been encrypted uh that's quite a research project and would be a lot of work for a hackathon but if somebody does it that could well be worth the prize but anyway thank you very much and happy hacking cheers thank you Patrick and thanks for everybody for attending good luck with the rest of the week hacking and we'll see you for the next Workshop in a little while cheers bye 