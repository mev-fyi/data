foreign foreign [Music] foreign [Music] [Music] thank you okay hey welcome um yeah hoping that uh we get a few more but you might have a yeah yeah thanks for coming you were uh remind me what you're trying to build or you're still looking around cool cool okay cool more ideas being yeah um yeah I don't know if I should get started but right yeah hey um I think okay okay cool yeah cool all right thanks hours I'm gonna watch the presentation I'm gonna wait for her to come back for sure yeah yeah yeah exciting I know very little but other than the very basic pitch so I just wanted to uh hello okay cool um yeah I don't know if I should wait on the East Global person to come back but they said that they're like uh going to tell hackers I guess maybe you guys came from that I don't know but um yeah I don't know if there's like a thing scheduled right after this there is okay then maybe I should start cool well yeah thanks guys for coming uh we're gonna have a lot of fun uh my name is York from hyperlane uh we're formerly known as Abacus if you heard of the Abacus protocol we rebranded recently um but yeah today we're going to be talking about some developer tools that we expose for you guys to use during the hackathon I know the workshop was labeled with interchain accounts but we also deployed a new middleware today for like interchange queries so we're going to cover both of those hopefully um so yeah first and foremost what is hyperlane in case you guys aren't up to speed hyperlane is a developer platform that enables interchange applications and so what that basically means is there's a smart contract API that's deployed on all of our supported chains and you can use that API to send messages between blockchains so you kind of enable composability between smart contracts which exist on different chains and we have kind of like a novel security model that we do to it that we employ to enable this but I think I want to keep this talk focused on kind of like the developer tooling side of things um as opposed to the security protocol but happy to answer questions there that you guys have at the end so yeah why do we care about interchange applications and why should you be building one uh so today developers that are building dapps are faced with this choice of which chain they want to deploy on when they're going out and you know launching their v0 and I think uh what developers don't realize a lot of the time is that that choice has uh kind of like a lot of Downstream consequences so we we listed a few here uh developer experience the the tooling that's around a specific chain um might be you know limited to to that Chain's ecosystem um you know each each chain has some idiosyncrasies and uh sometimes the tooling isn't as mature on on newer chains or cheaper chains so you might be like trading that off without realizing and then I think this one's probably the should be the highest on the list user experience uh just generally like when you're choosing which chain you're deploying on really what you're choosing is like who is the user demographic that's actually going to be able to use your application um and you know are they going to be required to bridge to some chain that they're not already on which requires them to go through some like third-party application uh usually taking on a lot of like counterparty Risk we've seen a lot of bridge hacks recently um so generally like you don't want to ask users to go through some third-party application um to just to access your app then we have the platform risk so this is kind of like once you've developed a network effect on a specific chain that you've deployed on uh it's very it becomes very hard to migrate that uh application or network effect to a new chain if you decide that the current chain has departed from like some maybe uh you know morals or philosophy that that you want to adhere to maybe it's like some censorship property um or something like that uh It generally becomes difficult to migrate you know Network effects Capital Etc [Music] um and yeah this this extends to composability uh if you want to kind of like reach new user demographics which are on uh different chains or maybe like lower fee chains or higher security chains Etc um if your application isn't designed with uh cross chain composability in mind um you kind of when you deploy to these new chains you end up with these like new siled instances of your application rather than an application where all of the users of your app are benefiting from kind of like the aggregate Network effects instead you have these kind of like siled networks that um you know in the case of like an amm when uniswap goes and deploys on a new chain it's an entirely new set of liquidity and so you kind of have to rebuild the network effects a lot of times you have to deploy these like artificial injections um in the form of like incentives to get uh bootstrap the utility there initially so yeah there's like all these consequences and what people are doing today to go multi-chain or go cross chain really is not scaling well um they're like like I said deploying these incentive programs um and there's like all this mercenary capital and the ecosystem that's just like chasing these incentives and as soon as the incentives dry up they just leave um and so you know it's not a really sustainable model for um scaling to all of these new chain environments however we want our applications to support these new chain environments because like there's all these different you know scalability uh improvements and enhancements being made which make certain user demographics um you know more uh likely to use your application so there's like kind of this tension between the proliferation of like these scaling Solutions and new user demographics and being able to like have an application which maintains its Network effects like across all these different chains um so this is where hyperlane comes in hyperlane is a network that exists between blockchains so it's not another blockchain um you don't have to choose hyperlain you can just like use hyperlane tooling to deploy everywhere and it eliminates this choice so today we're only on evm chains and so you still get this nice property of like only having to write your application logic once and kind of like deploying it uh everywhere in like a symmetric interface and it's built to be this connective tissue that allows smart contracts to communicate between different chains um and so you can have uh like intra app communication um whereby you have a shared State model and some sort of like State synchronization that exposes a user interface on all of these different chains but actually is doing kind of like asynchronous State synchronization on the application side which is like obfuscated away from the user or you can have inter app uh kind of composability so even just like an app that's on chain X and another app that's on chain y they're not natively composable because they're not in the same runtime uh hyperlane like allows you to build you know the aggregator app that makes those two apps composable and yeah like I said you bring your app to users on any chain um they don't have to learn a new experience you know they already probably have a wallet that they prefer a certain custody Solution on a certain chain that they're comfortable with you don't want to like enforce all of these additional uh like frictions to your users just to like use your application you know any friction in the initial like onboarding experience is going to massively limit your ability to like scale your audience and your customer base so um yeah and then get rid of this uh platform risk so uh this is a little bit out of date but we're going to talk briefly about like the lowest level primitive that hyperlane exposes to uh you guys which is the messaging API and we're going to talk about interchange accounts and then um you know I deployed interchange queries today so we're going to talk about that too instead of uh other examples here so messaging API um basically there's kind of two uh smart contract interfaces which are necessary uh to be implemented when um using hyperlane so on the sending side you have to basically dispatch mail to an outbox on the source chain which specifies the identifier of the destination chain that you want to send the mail to the recipient address on that chain to receive the message and then the message itself and you know you can see here that the message is just arbitrary bytes so we're not enforcing any specific like uh application message encoding on you really like this is a very low level primitive and and you can do a lot with it um and then on the receiving side [Music] um the in order to receive a hyperlane message your contract needs to implement this interface called iMessage recipient and specifically this handle function which takes in An Origin chain identifier the sender address on that chain or from the origin chain and then the message that was passed by the protocol and it's important to note that uh I guess um we need to implement this specific interface because uh other and and actually also Access Control uh this function to the hyperlane protocol because otherwise anyone could just spoof any sort of like cross-chain message by calling your smart contract and like pretending that it's uh coming from some chain when it's actually not and that has you know a bunch of security implications which again I'm like trying to stay away from but happy to answer questions um so yeah it's like slightly annoying that you have to deploy contracts on both sides of the message life cycle like the sending chain and the receiving chain uh because it basically means you have to like manage an application which is deployed like on all these different chains and it like can get kind of complicated again like we've built out a bunch of developer tooling to make that much easier um but I want to talk about uh this concept of inner chain accounts um which uh is basically kind of like a middleware implemented on top of the messaging API that like slightly constrains the messaging coding but makes your job as a developer potentially much easier um in terms of like orchestrating and deploying and managing your app across like end chains so the messaging API that we just looked at again like doesn't enforce a specific uh encoding it could be structured you know arbitrarily you could have like Json in there if you wanted to um and if you want to implement like a application specific feature like you're transferring an asset in like a in like an asset Bridge or you want to do a swap or you know whatever it is you have to implement that as like a specific messaging coding um on top of the messaging API but if we constrain the messaging coding to uh basically uh actions which can represent kind of like all the entire set of actions that can be taken on like a destination chain um and we leverage some properties of the evm mainly like uh the create two op code um we can actually like create these uh accounts on remote chains that are controlled only by a smart contract on the source chain and so this allows you to basically like have a smart contract on chain a that that holds assets on chain b or does like Atomic actions on chain B um and um yeah basically the way this works is like there's a inner chain account that's deterministically created from the source uh chain contracts um and that uh interchange accounts byte code basically restricts uh any incoming function calls to the source chain contract so if you want to make one of these like interchain account actions um you basically like relay it through the interchain accounts API from The Source chain contract and then the hyperlane protocol will go and relay that to the destination chain interchain account which will implement this Handler that basically has access control saying you know how we saw the messaging API here basically saying that only this origin chain and this origin sender mainly the inner chain account owner can uh run this function um and so the nice property we get from this API is like uh now you can only Implement hyperlane interfaces on the sending side you don't have to worry about deploying contracts on the receiving side because the hyperlane protocol will go and deploy these interchange accounts for you automatically whenever you route through this API so you can basically dispatch API encoded calls to be made from your inner chain account on another chain um and kind of like the middleware wraps up all of the messaging API uh receiving so an example use case of this type of pattern is cross-chain governance so uh you know the way cross-chain governance works today typically is like uh voting happens um you know usually on one chain um like the Hub chain and then there's like some basically like you know either trusted multi-sig or like Oracle solution to uh take the results of a vote that happens on like a hub chain and actually like propagate or broadcast that result to all the destination chains to like perform the specific like governance proposal that was encoded on the source chain um however with interchain accounts if you have a Dao contract that dispatches governance proposals to the interchain accounts API on the uh kind of receiving chain side of things you can basically just set the owner um of contracts that you want to be controlled by a dow on another chain um to the interchan account of that Dao and you basically have gotten cross-chain governance for free um so there's like one example um but yeah I think like The Interchange accounts API has I guess like uh makes it much easier to work with the hyperlane system so I definitely recommend you guys check it out on the docs um and then I also wanted to highlight The Interchange query system which is like super new uh deployed on testnet today um but yeah it feels like another kind of like middleware developer primitive that basically just makes it easier to work with the hyperlane system so um I think you'll you'll notice in the messaging API that um there's no kind of like native callback support so let's say like you wanted to go and dispatch an action to some other chain and get the result of that action and then like return back to your the calling contract and then resume execution it's not super obvious how you would do that with this API maybe you um maybe it is obvious to you but uh we've found that it's like somewhat difficult for people to understand how to implement callbacks [Music] um and so we wanted to build out this um kind of like interchange query system that just lets you like read Remote Smart contract State on other blockchains um just like a super simple API now now that we have basically on any hyperlane supported chain this now becomes uh accessible to any smart contracts and again the nice property is the receiving contract or the contract which is being queried doesn't need to implement a hyperlane specific interface because we're just dispatching ABI encoded calls to be run against those to compute run against contracts on the remote chain so yeah you can basically with this API dispatch a sequence of function calls and provide a set of callback function selectors to actually receive those query results um so hopefully you're like familiar with function selectors work in the evm but um the basic idea here is like you need to provide some way on the source chain to resume execution or kind of like recover the stack once you receive the message back from the remote chain of like what was the value of the query on that chain and so these function selectors basically say like what functions should I run once my query resolves and I've gotten a return value um what functions do I need to run on the source chain to kind of like resolve that value or like consume that value because we don't have an async await syntax in uh solidity or the evm but uh you know something you could build with this interchange query system which like I was toying around with like hacking this weekend is actually like an async08 syntax in solidity that like gets transpiled down to like The Interchange queries API um just as like kind of a fun demonstration that like you can have asynchronous Smart contract runtimes and um it just takes a little work so yeah here's like a quick um or this is just the API so yeah it's similar it's kind of similar to The Interchange accounts API um except instead of uh it just being um like a sequence of calls you also have to provide the Callback um again this is like compatible with Legacy contracts so you can like make uh let's say you're on polygon you can go and like make smart contract queries against like uniswap V3 you can like go and get price data from ethereum um like sorts of things like this aren't possible right now um and this is an example that I just like put together really quickly sorry for the like lack of uh syndax highlighting but um yeah basically like this is an example of querying ens for the owner of an address from a chain which is not ethereum so you can just like take the ens interface you can you know figure out what what label do you want to query on the ens registry in this case um we don't actually have the hyperlaining.eth domain maybe we should go buy it but um yeah if you wanted to query the owner and the expiry of uh the owner of that domain um you just you know API encode calls to the ens registry on ethereum and then you use The Interchange queries API to go and query that um in an asynchronous way you'll see that we have the like resolve owner and resolve X pre selector here um so basically these two functions will be run with the return value of uh what was uh basically queried on ethereum um we're still kind of at least I'm still thinking about like what the the right interface here is this is like a little awkward um to for a way to implement callbacks but um yeah I just wanted to like give a quick example um and yeah you could imagine building some sort of like so this is like this requires someone to do a round trip between chains um and so like let's say my contract queries some uniswap V3 price Oracle let's say it's like usdc and eth uh I want I want to go get that price and then some other contract makes the same query both of those queries both of those queries are going to do are going to require round trips between the two networks which kind of sucks um so you could another idea for the hackathon is like maybe implementing a caching system uh with this like interchange queries API and ens is like especially amenable to this that's why I picked it as an example because there's this like explicit Unix timestamp expiry attached to every kind of like relevant piece of State on the ens registry so you could like very easily build uh uh kind of like cross chain ens cache um contract that like saves um not only saves round trips but actually uh has like Atomic resolution of maybe uh addresses which are like popular queries I mean the same can be said for like other types of interchange queries this was just the example I picked but uh yeah I think we're like at the timestamp so I wanted to give an opportunity to for people to ask questions um that was like probably a lot to get through [Music] um but yeah yes so it will work between Roll-Ups um and what's nice is you don't have to wait the optimistic period right so um we're kind of all these use cases are optimized for like low latency and high security um so right now I think we're on optimism arbitrum I'm trying to remember what other roll-up chains were on I think that might be it for now but those are the I guess most in-demand ones um but yeah it's very easy for us to expand to new evm environments so if there's like a specific chain that we're not on um and you can check that in the docs but if there's a specific chain that we're not on we can definitely talk to you about expanding maybe like even tomorrow or something like that [Music] um you can that's a great question um so the way our like relayer implementation works is it will only uh include transactions whether they're callbacks or just uh cross chain messages in general the transaction will only be included if uh it's expected to not revert and so what that means is like in your callback uh receiver like let's say you know resolve expert or whatever in the implementation of that function you could have a reverting condition which says this much time must have elapsed between when I dispatched the query and when the Callback is being resolved and that's kind of like how you could schedule callbacks um sorry it's a little hard to hear yeah so like what's the security model basically of like energy queries yeah great question so um so hyperlane is like a example of generalized message passing which is a generalization of asset bridging which has been like demonstrated as like super insecure um and like super shitty and like probably shouldn't trust any of these things um so we're kind of like making what we think is like a fairly novel security uh trade-off um we're uh basically establishing a distributed set of proof-of-stake validators that sits between all of these blockchains um they're actually staking on the source chains um instead and so instead of kind of like guaranteeing that we can prevent fraud in in kind of like let's say the return value of one of these interchange queries um instead uh what we can do is we can guarantee that there's an economic cost to fraud a minimum economic cost to committing fraud um associated with a message that is sent outbound from a uh chain where hyperlane validators are staking and we can do that because if the if those validators sign something which is not committed to by an accumulator that we have in our smart contracts um we can provide a fraud proof which basically slashes them and so we haven't actually defined all of the economics around the system right now we just right now the validator set is permissioned um so to some extent you have to kind of trust the existing operators you can check out our docs and the Discord uh to like both like uh see who the validators are if they're like fairly reputable organizations around the space but also um you know you can talk to them in the Discord um but yeah right now it's a permission set um so you do have to kind of like trust uh the I guess Quorum of signers in that set um but we're hoping hoping and basically the next month or two to transition to this like permissionless proof of stake validator set um where and instead of just like social trusts uh or like reputational trust we have uh like full Economic Security model which foreign basically like most of these other Bridge systems have not really implemented effectively so yeah great question though I mean like that's kind of like the core differentiation of our protocol versus some of the other like generalized message passing protocols out there um is this like Economic Security model that has actual like enforceable slashing conditions and smart contracts so you can like have strong guarantees of what the cost is to commit fraud which is not true of basically like most other security models any other questions cool well yeah thanks guys for coming I'd love to see you guys hack on hyperland there's four hackathon bounties [Music] um I mean in general just like if you use any of these apis like pretty likely that you'll get one of the bounties but uh we have like a defy an nft uh an infrastructure category infrastructure kind of like um I think thinking more as like a developer tool or maybe one of these like additional middleware uh smart contract systems um like the cash thing I was talking about um and I think we just had like a general category um I think it's don't want to mess the number up but I think it's like 10 000 USD in total um up for grab so uh yeah a lot a lot of potential bounties at play here another another great thing about like using hyperlane for the hackathon is like it's fairly easy to integrate um so you could totally stack a hyperlane bounty on like one of these other protocols and you know double your money um yeah cool cool yeah uh this is not Financial advice awesome yeah thanks guys for coming uh I'll be around the venue uh all weekend so if you have questions or need help with anything um we have a booth upstairs definitely come out [Applause] oh yeah last Shameless plug is we're also hiring uh we just completed our uh seed rounds um yeah we'd love to talk to you laughs all right so the notes Here slideshow no no oh yeah this should be foreign foreign foreign oh ready uh thanks for coming um so there are two parts to this session I'll explain the streamer Network and Nico we'll explain the data unions that run on top of streamer so there are two separate prizes one for all good uh one for uh using streamer one for using the data Union Dao um so I'll go through what is streamer how to use it uh I'll then like talk through some ideas of what I think could be uh great hacks and then on to Nico for data unions so what is a streamer so it is a decentralized uh peer-to-peer Pub sub Network it means that data gets streamed to any number of ethereum accounts in real time and the role of the network is to move data from the Publishers to all the subscribers over a decentralized networking topology so if you're familiar with Pub sub channels or topics streamer has streams and they're they mean the same thing and can be any number of Publishers any number of subscribers uh protocol scales based on this principle of shared responsibility where the users contribute their own bandwidth to to support the the topologies so yeah this is more a definitions uh slide so we get asked these questions a lot it's not a blockchain so it's a classical networking Technologies but it does have touch points in the blockchain so it's an ephemeral data transport but we do also have support for data resending through the storage nodes that we run and note there is a liveness requirement for this so the storage nodes store the encrypted data but you need to have the Publishers online to be able to do the key exchange so that's one small gotcha that you need to be aware of but essentially the streamer Network provides this uh infrastructure for many to many data Pipelines our access control is online so this is one of the main touch points in the blockchain all the data is cryptographically signed every single data point uh signed by the private key of the of the user and uh comes with end-to-end encryption out of the box if you choose to use it it's also free to use as well uh with the the slight caveat that you just need to pay are sent to a Ascent or two of for gas to create the stream in any sort of edits on the uh permissioning layer the on-chain access control so in the web 2 world what we're replacing is this uh centralized uh data piece the the data center so to move a lot of data around in in real time uh the the pub sub model is to decouple the Publishers from the subscribers using uh you know some beef Beefcake server in the middle that can scale up and and and handle uh you know anything that comes at it but of course we know that this is centralized and we don't want to build our apps that are dependent on Google Cloud for example so this the streamer Network looks quite different in that it's it's uh appears more as like this if if the web two-way was this vertical flow of data through data centers you know run by the Silicon Valley Giants the streamer network is uh the data flows horizontally through this overlay mesh network uh that is made up from the users of the network for for users that are intrinsically interested in the data from the from the topics or streams of the network so at this point it's good to jump into an example so this is the streamer.network website it's just like any other website loads JavaScript and loads image assets from a centralized point but if you scroll down down the fold you'll reach a data feed and what's interesting about this data feed is that it's a stream on streamer and the data is not coming from a centralized Source it's actually coming from other visitors that are on the streamer Network website at the same time as you so this is a peer-to-peer data feed inside the browser so while you're visiting the streamer.network website you are becoming a light node in the system so this is the network explorer that so I've plugged in that stream ID in the in the top left there and what it returns to me is the visual representation of what that Network looks like so in one of these is the actual uh publishing script but the rest of these nodes are other visitors on the uh visiting the streamer.network website and more likely than not this is where you are pulling the data from okay so on to the access control so um the on-chain stream registry is on polygon uh this is the network source of Truth so it defines who can do what on the network um so on these streams you can typically publish or subscribe and the uh the network looks to the blockchain looks to this registry to determine who can do what and it also unlocks some interesting smart contract Access Control policies um so this piece this module if you're familiar with the lit protocol it's quite similar we rolled our own permissioning system for the network but perhaps it could be composable with lit as well so this is an open question maybe it gets answered in the uh hackathon this weekend so here is the like a different view of the access control uh fine-grained permissions publish subscribe changing permissions edit and delete and whatnot and yeah like I mentioned you can you can start to get a bit creative with these access controls so you could have a token gated uh Pub sub uh channel uh perhaps there's a stake to Pub sub um different kind of uh Primitives that you can bake in to the access control and on our Marketplace that Nico will will speak to more we have time based pay to access subscriptions so this also composes to the access control you pay tokens to uh get a time-based access or subscription access to a certain stream so getting into the tooling now so the streamer client is your best friend to to make all of this work so it's designed to be this wrapper that interfaces with the on-chain stream registry and the network and it bundles in the light node as well so it really kind of uh takes care of you from all different angles uh so you will need a little bit of Matic to interact with the stream registry and we're happy to sponsor this of course so just reach out to us if you need any Matic uh and it's just an npm package so it's uh these uh the stream of client runs in the browser as well as any sort of node.js environment uh also a shout out to the examples repo has a bunch of uh code samples to learn from as well so if you're stuck uh head there and we also have we also make it really easy as well so we can also create a stream using a user interface so just using metamask or whatever wallet that you have available you don't even need to touch code to be able to create streams and edit the access control so it's a nice way to get started I think so this is what's called The Core app you can visit it at streamer.network forward slash cool and it's yeah super easy so this is the stream ID that I'm configuring here so the ID is made up of the um the ethereum account that creates the stream plus some path name and this can also be your ens name it or kind of um uh scoop this up from the ens registry and in the share settings sidebar you can edit the access control but you can do all of this within the streamer client as well and we have docs yay and uh so the the client is uh JavaScript implementation so if you are building uh or integrating with a different language uh there is a solution for you here uh we have what's called broker nodes so this is uh you would need to run a broker node and open up its interfaces so it has three interfaces interfaces websockets HTTP and mqtt and just about every single language uh ever written has these sorts of uh libraries built into them so you can publish And subscribe push and pull into the network using these interfaces if you run a broker node so this is an option if you want to work with a different language for the most part so we have this kind of Gateway into the network if JavaScript is in your thing uh so what can be built uh with the with the network one of the most native and most interesting use cases I think is uh like a decentralized group wallet chat so this is using the network for uh decentralized uh real-time Communications between ethereum ethereum identity wallets so a chat room is just a stream and the participants in this chat room uh have publish And subscribe permissions to write messages these messages are being signed so you absolutely have full proof that there you are talking to who you are talking to and there are no servers here so um you know if you if you don't count whether or the JavaScript came from from the single page application this is a totally serverless experience so um yeah extensions to this creating token gated chat rooms etc etc token-gated experiences this is quite a quite a powerful uh primitive to to build on okay so very long list does it yeah it all fits in luckily um so so what what should you build with streamer um the I think you know obviously your creativity should should guide you but here are some some Concepts that uh often come up as as useful so like I think I talked to the access control policies for streams you can you can do a lot there decentralized metrics Gathering and web3 open data sharing so this is about collecting fine-grained metrics from other decentralized systems and using the network to interconnect and and kind of uh improve on decentralized systems without having to reach for centralized solutions to be able to to monitor the health of of the network in real time so I think this is quite a rich use case and it can be stacked with many other networks that are also sponsors here today wallets wallet Communications I showed you the chat app so this is this is what it is essentially off-chain multi-sig chat and conviction voting so imagine the chat out but with your multi participants from gnosis safe for example you can build conviction over what to vote on and and so on in this off-chain experience group chat plus lens protocol I think this would be fantastic protocol stack interconnection so if you have ipfs and it needs to talk with live peer or whatever then you could use streamers this middleware to have this decentralized communication between your your stack now we have decentralized wireless network proof of coverage so this is a bit of a a long shot for a hackathon but something to think about if you if you can uh create kind of a coverage map for decentralized wireless networks then um yeah it can feed into the proof of coverage algorithm so this is fantastic uh first mile data transport for uh from data providers to oracles so this is um from the provider up until the Oracle the streamer network is a great technology uh solution for this uh Redstone is is one of the the kind of dext generation oracles that are using Us in this way uh multiplayer gaming real-time State share uh I think that's one quite clear and RPC load balancing which is not clear so I will uh speak briefly to this one so this is kind of uh just an internal idea that we have to scale uh the RPC uh centralized point in many blockchains uh so yeah typically if you have this very popular dap and they're polling the RPC it's quite a heavy load for the RPC 10 000 users 10 000 requests a second if it's uh fast polling for example so that's not great what we can offer is to use the streamer Network to uh sort of load balance these uh RPC calls so how this would work is you would have these kind of Watcher nodes that would do the RPC request as many as you want for as much decentralization as you want uh but then your dapps would be uh interconnected and kind of uh pulling in the data that originally came from that RPC load sorry that RPC endpoint they would be um getting it from each other so this is where the shared responsibility of the streamer protocol comes in it's kind of similar to what we showed with the streamer.network website where you're getting the data from your visitors so in this way we take all the pressure off that RPC endpoint and you can kind of start to imagine other sort of use cases where there is this Central uh Point uh or Central data a publisher that can get overloaded so if you have this system where you sort of um protect it with this with the streamer Network where the messages are coming from the other participants it becomes quite a uh an easy scale uh solution so yeah this is something to think about okay um moving moving on to data unions and Nico will take over awesome let's see if I can get this thing a bit down because I'm not as tall as you are uh thank you Matthew uh hi guys I'm Nico I'm the Deborah engineer for dating in dell and Matthew just told you how you can handle all the data stuff and I'm gonna now tell you how you can actually monetize this data so let's jump in so first of all how you monetize this data you monetize it with a dating um what is a data Union it's an organization with an application where individuals participate in the creation of valuable data so what that what does that mean it means members generate data through data units application which crowdsources data and in the streamer context this data can then get sold on the street on the streamer Marketplace and I'll talk about that more in a minute um about the marketplace and with the dating you can essentially um monetize your data streams so with the data the dating endow offers um the data Union framework and this contains a smart contract template that handles payment distribution for the data Union and a typescript based SDK that handles all the interaction with uh with the data Union or with the smart contract and this SDK is an npm package and I will talk about that more in a minute and we also offer server architecture for your member management so let's see how this payment distribution works so you can see here wait do you see if I move my mouse no okay well you see this uh Center contract there and as I said it is a smart contract um and essentially money gets or token gets sent into that contract and then distributed into the different members I'm just going to talk you through how this kind of works so you've got an admin and that's going to be your project right so you have an ethereum address that publishes or deploys that contract and that's going to be the automatic admin and this admin can then add members so you essentially the data publishes right and um then the admin can set a admin fee which will result in this uh I don't know if you can see the 30 for example um and you can configure that in a way you want really um and then if token gets sent into that contract the admin for example gets 30 and your data members will share the 69 percent um of those incoming tokens 69 because uh one percent of that um of the 100 go to the day tune in doubt and we use this one percent for uh funding new projects you know going to hackathon and those kind of things um yeah and once the token gets sent to the smart contract so that could for example happen on a marketplace right so uh your data get your someone pays to be able to subscribe to your stream and those token then get sent to that to my contract and then again your members are able to withdraw that token or they can just accumulate it over time and take them out whenever they want really um right this happens uh so we have the smart contract and we have the SDK and the SDK enables you to interact very easily with the contract um as I said it's just an npm package and you can really just you know it's a it's really those few lines of code we have more interaction with the contract with this uh the essential lines you deploy you can deploy the data Union with the SDK you can set the admin fee you can add members remove members and also withdraw your tokens from there [Music] um alternatively you can also use the streamer core Matthew briefly talked about this um and it's it's essentially front end where you can deploy the data Union and it's got a nice interface where you can add the name um your admin fee and and like and even your streams that you want to monetize um right and then about the marketplace you can then publish the state union onto the streamer Marketplace so they're like different data products where all the streams are set um on the marketplace and then uh data buyer can subscribe to those streams for um token like they will pay for it by the way those token don't have to be the streamer data token that can actually be your own Uh custom token um right we also have documentation there will be a little bit of a guide how you can actually deploy a data Union um one way is with streamer and the other way is just programmatically with the SDK um yeah an example would be for example Ford 18 is um swash so swash is a browser extension it's very easy so you just install your swash plugin into your Chrome browser um join that data Union and then you can share your browser data and earn by sharing your browser data so it's actually quite clever um and then if you're looking if you're still looking for an idea what to build uh amra our community manager he uh did a great blog about some ideas that you can build at this hackathon so feel free to go to this link and check it out I highly highly recommend and yeah we're giving out ten thousand dollar in prices so one track is building with streamer and the other track is building with data Union so I really really recommend integrating this into your project and yeah I think it works very well together streaming data Union anyway and if you've got any questions feel free to reach out to us on telegram you can also join the Discord server of data Union of streamer and we'll be present there too and of course the one of um of if Global as well cool right do you want any do you want to add anything okay so if you've got if you guys have got any questions we're here to answer cool uh no we don't no not at the moment thank you yeah we can we can we can uh we sponsor we sponsor the transaction fee to actually uh deploy the contract uh and and the stream yeah um ideally you do it so if you build with streamer I would recommend doing it um on the front end and then you will you will see like how how you connect um at the payment and how much it costs and all that kind of stuff and then publish it to the marketplace thank you yeah uh so this is this is kind of like The Cutting Edge of what we have uh out of the box on the access control so we do have it's basically in PR at the moment for a very complete code example that is on the uh on the chat um on the chat uh repo so you will need to kind of uh dig there and we have like the contracts that do talk to the access control there but this is like very uh well I'll just say it's not documented at all like this this token gating uh kind of uh twist to the access control it's not it's not like uh the the core functionality of of the network so I guess we we have some catching up to do on that documentation but um uh we have accomplished kind of feature completeness on the chat app that I showed and it's that's open source and uh so there's a few caveats here that um the the the chat app um token getting is just for erc20 tokens on the polygon chain um and there's a PR out there for nft token getting so it's yeah it's very fresh and very uh hackable to to kind of yeah build build this in uh but it's it's not quite as easy as like just uh taking Lego blocks at the moment so we have the examples there but it's um it's quiet Cutting Edge uh I I think it's too hardcore for me I think the access control uh you would need to move to to Mumbai as well so if you if you're super Brave yeah don't recommend that uh we can sponsor the transactions it only costs a cent to to um to do these things so yeah very happy to support that and we will have a full native sponsoring of of all transactions on streamer it it's just not ready uh this weekend so uh any other uh questions okay well thanks for uh staying up so late and uh yeah I really appreciate it and uh please reach out to us if you have any questions thanks [Applause] 