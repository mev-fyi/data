[Music] [Applause] [Music] thank you is the volume okay okay okay so uh thank you very much for attending my name is hermann martinez i'm from nosis i've been working as a software engineer a couple of years now thank you for attending especially because it is 12 30 in the night so i guess a new day a new talk and maybe we can say gm to everyone in the room and now let's focus uh i'll be talking about nausea safe a couple of different points i will start with a brief overview of on the safe architecture showing what are the contracts the services and the interfaces we use then after that i'll show you who is using the safecar sdk there are some defined platforms some dows core infrastructure we also going to see what is the safecar sdk there's a monorepo with a packet with a a bunch of packages inside of it we will see what are them and why should we use it and for what and finally what is the basic flow of the nozzy safe using the safecar sdk how we can create a new safe propose a transaction getting all the owners to sign it and finally execute it so let's start with the safe architecture there are a couple of layers been the main one the contracts there's the safe contract there are some libraries like the multisend that can for example allow to batch multiple transactions into just one there are also modules for example the allowance module or some recovery mechanisms that can be implemented that way also we have a lot of tools related with the safe here today we are focusing we we are going to focus on the safe deployments packets this package allows to track the different networks where the safes are deployed what are the addresses for the different versions then we have the services transaction service client gateway notification service configuration service today we are going to talk about the transaction service that allows to store transactions temporarily to share them across the different owners and collect the signatures from them and finally we have the interfaces a web interface mobile app a cli and the sdk which is the thing we are going to talk about today but before of that before that who is using the safe core sdk some dows are using it so if you are hacking on a project that those may use then it probably is worth checking it and of course nazi safe uses the safe core sdk we are trying to migrate some of the logic in our web interface to use this sdk also zodiac which is a composable tao tooling standard radical which is a decentralized github for dows or yarn d5 volts for dow treasuries and many more so what is the safecar sdk it is a set of software developer tools that facilitate the interaction with the safe contracts and services and it can be used by external applications that run standalone or by scripts that run in the in a backend for example it is available on github and there are some packages inside of it so everything is built on top the on top of the safe contracts the safe transaction service and the safe deployments package that i mentioned before and the packages that form this monorepo are the safe core sdk types this one collects or has the different types that are shared among the different packages in the monorepo same happens with the safecar sdk utils that has some functionality that is shared then we have two [Music] very similar packages there are the save web3 library and the safe ethers library that act as wrappers of the web3js and etherjs libraries and they also export the save contract instances well typed with type chain so we can consider these packages as the internal ones the ones you wouldn't need to use and then there are two more that offer the full functionality one of them being the safe service client this is an api that calls the safe transaction service so all the actions that happen often in this flow for executing transactions can be handled by the safe service client for example proposing transactions to the service the owners can get these transactions from meat and that's well that's basically it for the basic flow then there are different other options for decoding data or getting data for from from a safe and then we have the other package the safe core sdk that handles uh basically the actions that happen on chain like deploying a new save creating a a new transaction that later will be sent to the service execute it etc so today we are going to focus on the safeguard sdk and the safe service client and how they both work together so let's start with the basic flow there are some steps first we need to initialize the sdks the safeguard sdk and the safe service client then we may or may not deploy a new safe if we don't have one with the safe core sdk then we can create a transaction with the safecore sdk propose it with the client get the transaction from the service if we are a different owner who is not proposing the transaction with the client we can decide if we want to confirm or reject this transaction and finally execute it and then in the end we will see some examples of some checks we can do in the interface in case we are building an application that shows a button for example to execute a transaction we can check if it's already executed or not or if it has the all the minimum required signatures or not so let's start with the initialization of the safeguard sdk this sdk supports web3 js and etherjs as we saw before thanks to the safe web 3 and safe ethers library that acts as wrappers so if we go to the last line we can see we are calling the the class safe that comes from the safeguard sdk and we can call the method create which is a static and asynchronous and that receives uh an object with a couple of properties the first two are required and the second and the the others are optional the two required one are the eth adapter this is the wrapper for the what's your ethers library in this case web3 that we can initialize by setting by passing the web3 instance and assigner address designer address will be the owner of the safe we are connecting to the sdk so we can do an action with one owner and then change this signer address to sign a transaction with a different donor the second property is the safe address so we are connecting one owner to that specific safe address and the other optional parameters are a boolean is l1 master copy because there are two different versions of the safe ones that [Music] emit events and one that doesn't depend in it if it's a l1 or l2 network for affording us and the last property is the contract networks that one is useful in case we want to try the sdk in a network where the safe contracts are not officially deployed by us so you could do it by yourself take note of the addresses where the safe contracts are deployed and then build an object with type contract network config and you could specify the chain id and the addresses for these contracts and then everything would work for ether.js is almost the same with the difference that each adapter in this case would be an instance of ether's adapter that comes from the library save futures library and we need to pass instead of a signer address an ethers signer that will be the owner so now we have the safe core sdk initialized we can also initialize the the safe service client this one is much simpler we just need to call the constructor of the safe service client pass the the url where the service is running and the instance of the if adapter for the transaction service url we are providing different different urls depending on the network but it is a service that can be run by yourself also so you should replace that url now if you don't have a safe address to provide to the create method we saw in the beginning we can deploy one for that the safecore sdk exports a class that is called say factory and we can initialize in a very similar way as the previous one by calling say factory dot create this is a static and a synchronous method that receives very similar properties with the difference that it also receives the property saved version in case we want to deploy older versions of the sales in case this one is not used the current version will be used then once we have the say factory instance we can deploy a new save if you go to the last line there's the method deploy safe that receives an object with a couple of properties being the first one the safe account config there is where you can configure your safe for example with an array of different owners the threshold and some other properties that are not included here but you can check in the docs there's also another property the safe deployment config because the safe contracts are deployed deterministically we can use assault nons to alter the data and get a different address where the save address will be deployed so if you want if you want to deploy your save in a specific address with a prefix or a suffix then you can try different cells such announces until you find the one that fits your use case and finally we have a callback that receives the transaction [Music] for the safe deployment in case the the web the web app or the script where this deployment is running ends you can get this transaction hash and check it or track it by yourself later this method returns an instance of the safecore sdk initialized with the deployed account so it's the same calling the deploy save method or the create that we saw in the beginning so now we have our sdk initialized and we are ready to create a single transaction we can do that by calling the method create transaction from the sdk and pass a transaction object that has some properties like two data value and some others also the safe contracts allowed to create or execute batch transactions these are multiple transactions that are executed into one so using the same method they create transaction we can pass an array of meta transaction data objects with the properties to data value and operation and also some options for the transaction that that has this multiple transactions inside of it now that we have a transaction a single or a batch transaction we can propose it to the service with our client in order to make it available for the other owners we can call the the method propose transaction from the service client and pass an object with the properties save address the safe transaction we want to propose the safe transaction has of this transaction and the sender address being the sender address one of the owners who is proposing these transactions and for the safe transaction has we can get it by calling the the method get transaction hash from the safeguard sdk so now we have a transaction that is pending in the service for the owners to confirm it these owners can get this transaction if they know the safe transaction has they can use the service client and call the method get transaction to get it but if they don't know the transaction has there are other methods that allow to get some transactions from the service for example the get pending transactions this would return a list of of transactions that don't have the minimum required of signatures yet so these owners can add theirs but we can also get the incoming transactions or the multisig transactions from the service just by providing the safe address to the method so now is the turn of the owner where they can confirm or reject the transaction in the case they want to confirm it if you go to the last line the safe service client has a method confirm transaction where they can specify the safe transaction has and add their signature to get this signature from the owner in the previous line we can see that the method signed transaction has from the safecore sdk by providing the save tx hash will return it owners can also reject transactions and these rejections follow a different flow we cannot reject a transaction once the signatures are public so we need to create a new transaction that has the same nonce as the transaction we want to reject so the method from the safe core sdk create rejects rejection transaction providing the nodes we want to reject will generate a transaction object that we also have to send to the service collect the signatures from the owner and execute it and if we execute this transaction before the previous one the one we wanted to reject then it will become invalid so now we have a transaction in the service with the minimum amount of confirmations and it's ready to be executed we can call the method execute transaction from the safe core sdk and pass [Music] the parameter save transaction this parameter we have to get it from the create transaction method where we pass the transaction object we received from the service and then we have to iterate on the confirmations from the service and add them to this safe transaction object and once we have this object this safe transaction object with all the signatures then we can execute it finally some checks we can do on the interface if we want to see if a transaction was signed by a specific address then we could check the transaction we got from the service that it has a property confirmations and see if these confirmations belong to a specific owner or if we want to see if a transaction is already available for execution then we can count the number of confirmations and see if it's greater or equal than the safe threshold so now the question is will you be integrated with us or will you be the next integration we are available on twitter on twitter our twitter handle is nosysafe and if you are interested in participating in the discussions we have a discord and a forum that you can check in chat or forum.nosysafe toriyo and that was it from my site so thank you very much [Applause] now if you have any questions okay we have a microphone coming i think yes one two what are the tests what are the best practices for contract upgrades for the gnosis safe um and how often do they happen i guess because i just started deploying a gnosis safe recently and hasn't been updated but um is there a best practice to like subscribe to something to see security vulnerabilities or any information about those upgrades do you mean the upgrades of the contract yeah the contracts are not upgraded very often so when they are it's something that will be public and announced so i don't think there's nothing to check constantly thank you hi there thanks very much for the talk um i'm going to apologize in advance i'm just going to make sure that i actually understand what the hell is going on with these contracts if that's okay um basically from my understanding um you have the ability to deploy a gnosis safe contract once you've got diagnosis safe contract you then have your does that count as the owner is that the thing that actually submits the final transaction when you've batched up your collected signatures um when you want to submit a safe transaction i was wondering if you could just kind of explain to me the interplay between those services a little bit more sorry sorry could you repeat just the last question i was wondering if you could please explain to me a little bit more the uh interplay again between your three sets of contracts sorry to ask you to repeat yourself uh so how the execution happens yeah and how the signatures are checked yes that's okay thank you okay uh so there are basically two ways of collecting the signatures once a transaction is built of chain somebody defines the data the value and these parameters a transaction has and that is shared with the owners these owners can get the transaction has and they can decide if they want to tell directly the contract yes i approve this or or somebody can collect obtain all the signatures concatenate them and call the method execute transaction from the contract and send them directly so effectively you have this the ability to have like a separate keeper who submits that aggregated transaction or if you were to have the situation where all four of your owners were if you had a foreigner safe contract if all four of the owners were to tell the contract directly that they wanted to authorize it you'd be able to do that without having to collect the signatures is that correct in that case there's no need to collect them but you need to provide like a fake signature telling the contract that a specific owner signed the transaction on chain so if you know that somebody is signed on chain then you can make a fake signature a pre-validated signature with his address and by saying by sending that to the contract the contract will understand that fake signature and will check that he did it on chain before cool thank you i really appreciate the questions sorry of course doing that or doing everything off chain will afford gas is there a way to set a timeout on a transaction so that maybe the owners of a safe could agree that a transaction will happen in like a certain period of time in the future is this available in the uh not in the basic functionality okay so once a transaction is proposed for example to the service and all the minimum required signatures are available somebody could like any anybody could execute it okay uh it's a bit of a stupid question but could you uh repeat sort of how the multi-sig works with gnosis safe like just how that would integrate into a contract so if if i understood it correctly that there's a safe contract and that's where the signatures pull am i is that the correct understanding that's where the signature sorry could you uh explain that interface with a multi-sig one like a few slides back i think uh that might have been too far that one the is transaction executable could you maybe explain that just a little bit i'm pretty new to the space so after getting a transaction from the service using one of the methods or directly with an endpoint the service returns an object which is the object transaction of type save multisig transaction response and there you can get a transaction object with all the confirmations that were sent by the owners of chain to the service so if you get this object and we count how many confirmations it has if the number of them is greater or equal than the save threshold then you can execute the transaction otherwise you need to wait for more of them cool thanks i know that a lot of the mev extractors are kind of using this now what do you think are some of the really interesting applications you've seen of this in practice with them what mev extractors i don't really have an answer for that okay people are very uh i'm very forthcoming with that information i guess is there any other question no yeah okay there in the back okay uh i i think this is not this hackathon but my personally my project tried to implement this gnosis safe to manage uh nft so i want to i wanted to make the function that many people can manage nfd in the currency safe bullet but i think currently gross safe bullet requires the transaction to sign in the open c so i think uh open seats like meta transactions so the off chain transaction needs to make on-chain transaction in gnosis safe but i think i checked the gnosis safe implementation and it has the eip1272 that is contract overlapped signature verification so i think agnosticif can use that eip to validate the off chain signature in the smart contract so do you have planned that like sign in using off-chain signature into openc function sorry i'm not sure i understood correctly okay so agnostic safe has the eip1272 that is a contract with signature verification but uh currently if i use hypnosis wallet to sign in into openc i need to make signature i want to make i need to make the transaction on chain but is it possible to sign in using the off chain signature by uh notice safe sorry okay okay okay then we will be at the booth during the whole weekend so if you decide to build some hack project these days we will be around so thank you very much [Applause] [Music] [Applause] [Music] you 