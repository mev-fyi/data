good morning good afternoon and good evening everybody my name is kartik i'm one of the co-founders of eat global and i am super excited to welcome all of you to eat online you're all here watching me on youth global.tv and this is the website and the platform we'll be using for the rest of this month this is where all the summits and talks we're going to be including the closing ceremonies with the final demos and of course all of today the way this works is that you can sign in on the chat and say hello and talk to us this is a live stream so i can read what you're all saying and we also have an amazing summit right after this logistics for the hackathon so if you have any questions for our speakers you get to ask all of them directly in the chat and we'll be relaying them to all of our speakers all right so those of you who are joining us for the first time this event is organized by eighth global and for those of you don't know what each global is it's an organization with a very simple mission our goal is to onboard thousands of developers into the web3 ecosystem and we do this primarily by doing two things we run hackathons and summons and this month is no different talking about summits these are short four to five hour days with amazing jetpack content on relevant topics that let you understand what's happening and the latest that's happening in any given category and this month is full of that we're going to be running five in total there's going to be one almost every friday starting today we're going to talk about dev tools how collaborations endows and needs 2 and the ecosystem and everything else is evolving so check out the website for a lot of those details and the agenda and for the next 45 minutes or so our focus is going to be this hackathon so let's talk about the hackathon this is not only our biggest event of the year but our biggest event ever in our history we were absolutely mind blown with this the amazing crap that we have uh 1600 people are hacking for the next few weeks from 96 different countries spanning 19 different time zones we also put everybody on a map to see where everybody's joining us from not only on the live stream but through our discord email and all these platforms and it's astonishing and astounding how much diversity and this the span of who's joining from where we were kind of being welcomed from uh six continents being represented and uh i am just so happy to see this and um i can't wait to meet all of you and talk to you all on discord and not just the hackers we also have 35 ecosystem partners and 110 ecosystem mentors that are going to be here with us for the next few weeks helping you make sure that your projects are successful and you are unblocked on them and to top it all off we have 350 000 in prizes that are going to be given away and we'll talk about what these prizes are how you can win them and all the details about receiving them but before we get into all those details i want to thank some of our amazing partners who without their help would not be able to make this hackathon this big and amazing so when i quickly think optimism superfluid ave grant style scale labs polygon ipfs and falcoin world coin ens uma aurora epns the graph kronos live pier vern 8 wine ap wine abacus unstoppable domains connext lens spruce covalent table land quick note nft port ballast dbridge teller streamer cismo oasis ceramic unlock and xmtp labs so we're going to bring some of them on to talk about why they're excited to be part of the soccercon 2 but before we get into all of that let's quickly cover a lot of the logistics for this month the goal here is for me to talk about how all these things work team formation how you can get help all the prizes you can win all the talks and workshops that are happening all together how judging and submissions are going to go uh we're gonna also cover summits and just what's gonna be the agenda and after this logistics ends we're going to roll directly into our first summit of this month which is all about devtools and how you can learn about the latest advancements in building on what three so first things first communication is kind of the most important thing we're going to cover everything about this hackathon and this month will be on our discord uh this discord is only visible and available for attendees who are confirmed and have rsvp to hack and all of our partners uh the way you can check this is going according to expectations is you will see an eat online 2022 header on your discord sidebar if you do not see that with all these channels please go back to your hacker dashboard and see if discord is connected properly and that will be your tell if you are running into any issues connecting discord please message anybody on the global team on any other discord channel that you see or by sending us an email and we'll be able to debug why that connection is or isn't working uh or just isn't working and uh these are also private channels so they're only visible to participants which means that anybody in those channels is also a attendee for this hackathon so you can also learn where people are from talk to them and see what they're excited to build as well as there are channels for getting help for any different any protocol that we have on board that's helping us uh throughout this event and for any of our partners who are giving away prizes and also a generic help that you can ask in the mentorship help channel so if you are stuck with anything whether it's about learning how some documentation works or have some protocols set up or just an error that you can't make sense of just post those questions directly on those channels and somebody who's actually an expert in those things will be able to answer them to uh to unblock you almost asap on top of that we're also going to be sending a calendar invites for a lot of the important talks in workshops and especially for key events like submission deadlines judging the finale and everything in between including some feedback sessions that we're going to be regularly running so you can actually understand and get some direct live feedback from our uh some of our partners and mentors uh all of this is also going to be reflected on the website which is the source of truth anything that the website says is what we'll be doing and we really want this thing to be asynchronous there's about 100 countries that are going to be participating at this event so we want to make sure that time zones are not a direct barrier so with the exception of a couple of sessions that are specific to people being on the same call like team formation everything will be a synchronous and you can catch up and keep up with it at your own pace and whenever you like and for those of you who don't know what their website's at it's online dot ethgoble.com you can head over there to see all the latest details about the act all right let's jump into the hackathon itself so officially the hackathon has started which means as of this sentence you can start working on your projects and you can work on your projects with up to five members on your team uh you can also work individually if you'd like and you can have anywhere from one to five people on a project so the max is five you cannot exceed that limit and you are good to start you have three weeks to hack or 23 days to be precise and submissions for your hackathons are due at 3 00 p.m eastern on sunday september the 25th that gives you 23 days until they're the deadline and the next few weeks are going to be covering stuff around check-ins stuff around getting feedback a lot more workshops and talks that you can catch up onto and going through a lot of the internals about different protocols if you are looking to work on some internal uh or some really specific protocols that you need more help and time understanding on top of all that we have now a new feature where you can find potential team members who are still looking to join a project on your hacker dashboard if you go to your team section you'll see that you get to opting to find a team member feature and anybody who's opt-in who's officially looking to either pair up or have somebody join their team can set in their preferences and find other people who are also in that position there are 1600 of you over 1600 of you joining this hackathon so uh there's definitely a lot of you who are still in this position who are looking to find other members to join their team with complementary skill sets and you can now also use this service in addition to all the calls we're going to be doing and have done to to find potential team members so check this out on your dashboard and it'll show you everybody who's interested as well and if it's a match you get to contact each other directly on discord now let's talk about the rules and the criteria for the hackathon one of the key things that must be adhered to is that everything you're going to submit must be done from scratch which means that you cannot work on a project or a site project that you have been working on already that also includes adding features to something that you have done that may be entirely new to just this event but are still being committed to a code repo that was from before this account started we really want to make sure this is fair and consistent with everybody else's experience so you cannot build from a pre-existing personal projects if we are if we find out that this has been the case that team will be disqualified from this event and no prizes will be given to the team and a really really important note is that only rsvp hackers are eligible to win prizes that means if you are working with a team and each of those team members has not rsvp'd and confirmed as a hacker and they do not show up on the team section on your project and your dashboard itself if you win any prizes we will not be giving prizes to anybody that was not listed on the team so it's your final kind of call to make sure that you ping everybody who's on your team to verify confirm and have them show up as a team member on your dashboard if you have any questions about these things let us know you can ping anybody on the team on discord or over email and we'll be happy to answer those questions for you let's talk about judging so submissions are due on sunday 25th at 3 p.m and the way judging is set up is that there are two parallel tracks uh there's going to be a main judging that is about going to be a synchronous session uh this is one of the only key times where everybody must be on an actual call independence of the time zone and that's gonna be from 12 p.m to 2 30 p.m eastern on monday the 26th and then for anybody going for partner prizes there's going to be an asynchronous track where all of you who are trying to go for a price those projects will be sent to each of our partners and they'll be reviewing everything on their own asynchronously and if they have any questions for those teams they will be pinging you directly on discord or email clarifying anything that they'd like to know before they decide who is going to be the ultimate winner for each of those prizes but i want to focus a little bit more on the main judging the main judging is going to be a synchronous call which means that everybody as a team comes on and demos what they built each team will get four minutes to do a demo of what they prepared so make sure you are concise in really communicating what you are doing and what you have done over the past three weeks and this will be a video submission only which means for your demo and your submissions on the sunday the day before judging starts you are required to upload a four minute video or max four minute video talking about what you built with a demo team any other additional information and that's what you are going to be showing to our judges and we see this all the time but we really recommend that you do not do this last minute because this will take a lot of time in making sure it's concise and it fits in the format limit all these details are going to be available and visible to you on your dashboard as we get closer to the submission deadline and we'll be sharing a lot more of these specifics but you can also get a quick peek at what this process looks like by heading over to your eat online info center and that we'll talk about the judging and submission process all together and you can also see some sample previous submissions about really projects that we like on the submission formats and you can use that as a reference and really prepare a an amazing demo for the judging so all this is on the dashboard or just giving you a heads up here and all these things will become more and more common and communicated really well in more specific details over the next two weeks and of course we recognize that there's a lot of you who are trying to get into web3 and are trying to explore what's possible so don't worry this event is designed to be beginner friendly and that is why we have so much focus on amazing talks workshops and the summits and all these things are ensured to really satisfy every type of skill sets whether you're a beginner an expert and this is also the reason why if you are feeling like you are too overwhelmed that you're not able to understand everything that's happening or you want to catch up more you can just tune into the summits as an outsider too everything is going to be live streamed and public and open and summits are happening every friday and for the hackers specifically all the details around from submissions to any rules and edge cases to logistics around the next entire the entire month of september will be listed on your info center including any frequently frequently asked questions and the common most common question we get and uh i want to address is yes everything is going to be recorded so if you're not seeing this live right now on 8th global.tv the same video will be available on our youtube immediately after this live stream ends and you can just head over to youtube.com east global or just go directly to the website online.educable.com to click on the schedule item itself and see the video recording of that event uh we'll make sure it's really accessible to everybody and these things will be there for all of you to catch up at your own pace so no need to uh prioritize something else over this if you have other obligations focus on making sure you are able to catch up when you like all right now let's get into some of the fun stuff which is some of our partners who want to talk about why they're excited to be part of this event and all the prizes and after that we will get into talking about all the summit details and um and kick off with our adaptable summit so first up i'd like to invite kelvin from optimism to share why he's excited to be part of it online and now our feature presentation [Music] it's me the very serious person named kelvin and today i'm talking to you about the only serious blockchain called optimism this uh this is a very serious situation and uh they need to take certain steps to protect themselves if you're building on optimism you better only build serious applications you know how serious i am look at this oh yeah that's right so why should you build on optimism because we are solving the public goods funding problem [Music] why are we solving the public goods funding problem because it turns out the whole point of everything that we've been doing for years has been to make actual widespread societal impact with the work that we've been doing it's not just to take the yam and and to put the yam in the cup and then somehow because you put the yam in the cup with the east it turns into two yams and then and then you take the second yam and you put it and you leverage it and you turn it into into st east somehow and then you put it in the bean pot and the bean pot gives you uh more yams people are doing this with the yams and the bean pots it doesn't make any sense deeper there's no pepe so you gotta be kidding me i got boxes full of pepe but you know what we could be doing instead is having a real societal impact so optimism we made a blockchain right because we realized you know you gotta scale this stuff sorry you gotta still scale this stuff and then we were like wait a minute actually what we're trying to achieve is to use this software that we've constructed in the societal these uh these cryptoeconomic frameworks that we've constructed to achieve something in this case we believe that we can create a better funding model for public goods and we start by focusing on open source software because that's what we know so i'm just saying build on optimism [Music] this guy that was the amazing kelvin talking about optimism uh as a note i had not seen that video before this thing because i was told that i need to react to this live it is incredible so you also get to see what optimism is doing for prizes but hopefully you get a better glimpse into what optimism is from those last two minutes a very serious blockchain all right up next is fran from superfloyd and he's gonna talk about streaming money i'm fran one of the founders of superfluid and i'm super excited to welcome you all to eath online this year this i think is the second time we sponsor wreath online and at superfluit we love hackathons we've seen some amazing projects come out from last year and we're very excited to see what you get up to and what you hack over this month what we do at superfluid is digitally native programmable cash flows using superfluid you can send streams of money without needing to lock up the capital up front and with full programmability which means you can let your mind loose and build some crazy stuff so what does money streaming mean so these are basically open ended transfer of funds you set up a stream and it goes every second it keeps moving money it's fully liquid the recipient can spend the money as they get it and you can collateralize your stream as you go by doing this the recipient gets paid every second there's no delays they never risk not getting paid because they're getting paid every second and there are no intermediaries right it's web free it's completely unchained fully permissionless and anybody can use it so basically you can imagine with superfluid we're switching up a bit the way you pay right instead of paying at the end of a period you basically get paid throughout the period right so the way we like talking about it is that we're moving from recurring payments to ongoing streams right this is the web free native way so what can you do with it you can do subscriptions you can do salaries you can do social tokens right maybe your paint your community or reward for joining your discord you can build some interesting d5 products and of course a lot of games right imagine a game that sends you their own in-game currency as long as you're playing so how do you get started well the first thing you can go to our dashboard that's app.superfluid.finance and here you can start experiencing what my streams are like as a developer we also have an amazing tool called the console which will allow you to visualize whatever people are doing you can see your contract's address and you can start exploring the sub graph as well uh building with superfluid you'll find a lot of interesting and useful tools we've got sdks and javascript typescript subgraph solidity libraries example applications and a list of interesting hack ideas for you to get started uh getting your your brainstorming session going but if not we have also a discord channel where we have a lot of ideas going all the time if your experience at the hackathon is great after the hackathon we would love you to join the superfly reactor this is basically an acceleration program where we will take you from your prototype to getting ready to raise funds or go live in production it's a completely free program that we run only with the best teams out of hackathons so when you're building at a hackathon don't think about it as a prototype think about it as your first step into web3 and into building an amazing project so yeah welcome everyone it's a month long and please come and hack on superfluit awesome that was friend on superfluit and we'll talk about all the superfluid prizes very soon and next up we have jess from avia great style hi everyone my name is jess i'm the developer relations engineer at rv if you haven't heard of valve it's a decentralized liquidity protocol where you can supply and borrow different cryptographic assets ave is one of the largest and most exciting d5 protocols and it's deployed across a number of different chains we're so excited to be participating in eath online and army grantstar offering twenty thousand dollars worth of prizes for you to integrate with and build on top of the rv protocol you must build a project relating to one or more of the price categories and for each category you could win three thousand dollars for first place and one thousand dollars for second place we have five prize categories for the first category we're looking for projects and integrations that can bring more stable coin liquidity into our bay the second category uses the lens protocol to assess the reputation of profiles for credit delegation and the third category looks at accessibility think about what new ways could help users to access the rv protocol the fourth category is an rv4x tool can you help users to access forex liquidity using features like flash zones or d5 integrations and finally the fifth category is to create new ways to compose or visualize rv transactions we as a team are here to support you as well as the rv grant style so please do reach out to us on discord and let us know what you're building on twitter and then thank you so much and we can't wait to see what you build thank you jess and next up we have connor from scale hello welcome to ethonline 2022 my name is connor murphy and i run business development at scale labs scale labs is a core team bootstrapping and shepherding the scale network a scale network was purposely built to bring ethereum to billions of users by providing them zero gas fees and scale is able to achieve this through its transformative multi-chain approach through this approach and leveraging ethereum's base layer of security developers finally have a high performant blockchain with instant finality and once again zero gas fees now what is this exactly solving well currently across the industry many blockchains are monolithic or just single databases and as demand increases we see a squeeze on supply and as many of us saw over the last couple years users have to deal with this squeeze either through increased gas fees slow block chains or even worse the blockchain crashing monolithic blockchains just can't solve the supply demand equation and this is where scale steps in these monolithic blockchains are realizing that they can't solve it by being a single database and they need to pivot to being multi-chain well scale's been multi-chain since inception and as demand increases more nodes enter the network and scale is able to limitlessly add more supply this allows for a ton of gasket savings and scale is building for a future of mass adoption one where we use blockchains every day through gaming d5 web3 and more and unfortunately with the gas fees that we saw over the past year this just isn't possible we would never be able to hit the scale we want to hit with users paying these gas fees and this is why we built scale scales v2 launched this past july and we've already seen massive growth we're working with new dapps every day and working to save end users millions upon millions of dollars we'd love to have you join the skillers please find our documentation here or reach out to any of the core team members on discord or twitter awesome next up we have polygon hello everyone uh this is sundeepan from the polygon devil team and we are very excited to partner up with eth global for the flagship online hackathon ethonline to give you a little bit about context about polygon polygon is the solution of ethereum scalability it's blazing fast it's secure it's decentralized the problem statement that polygon solves is that no size fits at all like different uh use cases are being built out at polygon zika and other types of optimistic roll-ups coming up in in in the future and there is also no formalized framework that's when the polygon solution comes in with the swiss army knife for ethereum scalability with zika roll-ups optimistic roll-ups enterprise related chains security chains and definitely the beloved plasma chain so building on polygon is like developers love building on polygon and hope you have an excellent time this time in this hackathon also uh the backward compatibility polygon is ethereum evm compatible you can use all the tools and infrastructure you already love you don't need to learn anything new uh for this hackathon we are giving out 20k in prices and there are main three tracks the general track is like first price will go five thousand dollars second price three thousand third price two thousand there's also a best innovative dap built on polygons so like we always see a generic kind of dabs built on so but what can be a unique use case did you if you can think about in that case then there's a three thousand dollars price for that track and then definitely some of the unique pro projects being built on polygon will be awarded with the pool price and seven winners will be selected thousand dollars each thanks a lot everyone i hope you guys have a great time building in the hackathon amazing that was sandeep and from polygon and our last one is going to be nikki from ipfs and falcoin and nikki will be joining us live so please welcome nikki to share about whether excited to partner with you don't mind hi everyone my name is nikki and i work on developer onboarding initiatives at falcoin i'm very excited to be here uh to wish you all good luck for eat online 2022. uh hackathons are a great place to experiment and get your hands dirty and build projects and who knows someday some of them might also turn into million dollar raising fundraising companies um i represent ipfs and filecoin and as most of you know we are on a mission to decentralize the internet and buy extension decentralized storage uh while our challenge statement is uh the best use of for nfp storage or repd storage to use ipfs for content addressing and filecoin for persistent decentralized storage it is kind of broad to encourage any and all ideas that might come out of this hackathon uh however uh here's a tip people would love to see some dev tooling solutions um that can help other developers easily use ipfs or filecoin or projects that are web3 versions of web2 apps that are an essential part of our lives today uh the question we are really looking to answer is how do we solve problems that come in the way to really scale and help apps and users move to decentralized storage um i hope that inspires you we have twenty thousand dollars in total in bounties to give away uh for you to use ipfs on call point in your projects we do have a pool prize as well for up to 25 teams in addition to top three prizes um we'll share all of these details on discord and our dev advocates will be there to answer any questions you have or help with difficulties you run into uh we'll be here to encourage you even after the hackathon uh so please think of this as the first step and with our grants and accelerator program and so don't be discouraged if you don't win in this one uh good luck and happy hacking thanks carter thanks jacob thanks nikki that was awesome and you can also check out all these things on your hacker dashboard now all right so before we go into all the other prizes and all the specifics of a prize want to give a quick reminder about how check-ins work and you may have seen this on your dashboard and on the info center but it's a very simple thing uh we're going to do check-ins every week this is a way for us to kind of quickly see how things are going and make sure that you are not stuck and if you are stuck you're getting any help getting unblocked whether it's on the code side or anything else and it really kind of helps us make sure that you are able to really accomplish your goals and uh continue to get to the the end product of what you are excited to build and your stakes are also tied to this thing so checking also helps you get to the path of making sure you are satisfying participating at the hackathon all this thing happens over your dashboard so the way these things are set up is that every check-in will start appearing on your dashboard uh early every week and you'll also be notified of these things so don't worry if you don't see anything now because they are not going to be visible they will start showing up early next week as a simple form that just says how things are going and if you need any help so keep in mind that those things are going on and they also help you really prep for any of the feedback sessions we'll be hosting so you can come on to those feedback sessions and ask any of our mentors or our partners for advice help direct support kind of like office hours and really see what everybody else is building as well and all that is tied all together as part of the next three weeks all right let's go into all of the prizes you kind of did get a sneak preview of some of these things but i'll still go into a lot more detail about every partner that is getting at a price we're going to start off with the ave grand style lots of prizes being given away that is about twenty thousand dollars of prizes from the ave grants team uh and they are separated by different categories so if you are building any project that covers the stable coin and growth category you will be able to receive three thousand for the first place and one thousand for the second runner-up place any ave related hack that tackles credit delegation will be receiving three thousand for the first place and one thousand for runner-up any project on the ave protocol that addresses accessibility will be receiving three thousand for the first place and one thousand for second any avi integration that covers forex and applications around that category we'll be receiving 3000 for the first place and 2 000 for the second in any ave transaction builder related hack will be receiving 3 000 for the first place and 1 000 for runner up then we have the ipfs and falcoin prizes so a lot of prizes being given away as well from the ipfs teams they're going to categorize them as storage wizard prizes so the best integrations on ipfs alcorn network related projects will be receiving best three integrations will be receiving three thousand dollars each denominated in file coin tokens and there's also a pool price category which means that up to 25 teams will be splitting 11 000 amongst themselves delivered in file coin tokens as well so that means a lot of people can potentially qualify and there's up to 28 teams that can win prizes from the ipfs file coin team then you have a polygon polygon is giving prices in a lot of different categories so to scale your applications on polygon as the qualifier you will be receiving five thousand dollars for the first place two thousand dollars for uh three thousand dollars for the second place and two thousand dollars for the third place and the most innovative dap and dapps built on polygon will be receiving uh three thousand dollars for uh kind of the being the best app from all the submissions and then there's going to be seven runner-up prizes where the top seven teams that are leveraging the polygon ecosystem and deploying on polygon will be receiving one thousand dollars each next up we have super fluid so superfluid is also giving lots of prizes i think that is twenty thousand in total uh the best overall hack that uses the superfluid streaming protocol will be receiving four thousand dollars the best hack that specifically covers d5 will be receiving three thousand dollars the best streaming payments project that is around making streaming work for dalles will be receiving three thousand the best gaming related streaming money hack will be receiving three thousand as well and the best futuristic hack around in super interesting futuristic use cases of streaming money will be receiving 3002 and they also have a 4 000 pool prize which means that any other team that is building on superfluid as long as they are making a good and sufficient use case of the protocol will be splitting four thousand dollars each among themselves next up we have world coin so world coin is giving a lot of prizes as well the best overall project on top of world coin will be receiving four thousand dollars the best governance app that leverages the worldcoin sdk for proof of personhood protocol will be receiving three thousand dollars the best social app leveraging the worldcoin sdk will be receiving three thousand the most creative use case of world coin private personhood protocol will be receiving three thousand and they'll also be four runner-up honorable mention prizes each receiving 1 000 each any pool price category which means that any any teams that are building on top of world coin will be splitting 3 000 evenly amongst themselves then we have the very serious prizes from optimism the best nft infrastructure will be receiving five thousand dollars for the first place and there'll be two runner-ups for 2500 each the best games being deployed on optimism will be receiving 2500 uh dollars and up to two teams will be the recipients and there will be two 2500 prizes for the best community infrastructure project on top of optimism and then there'll be 10 prizes for 250 each to the 10 next best teams building cool optimism deployment hacks and leveraging the optimism ecosystem next up we have scale for the best use of scale and the grand price will be five thousand dollars in scale tokens the best project that leverages scale and is on around building projects around metaverse gaming or nfts as a category will be receiving eight thousand dollars in scale tokens and this will be split between those multiple projects not just a single category uh the best partner integration will be receiving two thousand dollars in skl tokens um and there's also going to be a five thousand dollar pool price for scale which means that any other team that makes a sufficiently good use case of the scale sdk we'll be splitting five thousand dollars evenly then we have epns and epns is giving a lot of prizes for the best integrations of the notification api and any wallet that leverages the communication services that apns offers so the best use of epns will receive 4000 for the first place 2500 for second and 1500 for the third place and there's going to be five runner-ups receiving 400 each next up we have ap wine ap wine is categorizing the prices in two categories for the quant connoisseur they'll be receiving five thousand dollars in apw tokens for the best integrations and then also runner-ups for 2500 uh two two places for the best integration of the yield tokenization um integrations into your d5 related hacks and 2500 will be split uh given to two teams uh individually so pipe additional five thousand dollars in second place runner-up prizes then we have aurora and aurora is a bridge between ethereum and near so the best integrations and use of aurora will be receiving five thousand dollars the second place integration for aurora will be receiving three thousand and the third place will be two thousand dollars next up we have uran finance and the best integrations leveraging the urine protocol will be receiving five thousand dollars for the first place three thousand for the second place and two thousand for the third place so any hack that is in the defy category and is doing aggregation and composability around yield strategies is qualified to win ten thousand dollars in total here next up we have ens ens is the ethereum name service and they have a lot of interesting categories that talk about you being able to win a lot of prizes for using ens in a really interesting way so for the platinum category you have three thousand dollars for the best ens integration for the obelisk 2000 for bob 2000 flight x 1500 and the net category will be 1500 and the specifics of each of these categories are also going to be available on the price page so uh you can check out the exact details on your dashboard or on the price page which we'll talk about in a second next up we have kronos so chronos is an edm compatible layer built on tendermint and the cosmos sdk so the best use of kronos will be receiving 2 000 the top five integrations will be receiving two thousand dollars each if you're interested in checking chronos out then we have abacus and abacus is an interchain messaging api between different blockchains and the best use of abacus will be receiving four thousand dollars in prizes the best use of abacus that is building a defy specific hacklet receiving 2000 and the best avis abacus integration that's in the nft category will be receiving 2000 as well and any infrastructure for inter chain and cross chain use cases leveraging the abacus sdk will be receiving two thousand dollars next up we have lifebear so the best use of life here will be receiving five thousand dollars for the first place three thousand for the second place and two thousand for the third place and live here lets you do decentralized live streaming and any creative hacks around live streaming over decentralized networks and doing this in g3 is uh is an excellent use case for you to integrate the live peer protocol and sdk then we have uma uma is a decentralized financial contracts platform letting you build a lot of really interesting d5 applications especially through their optimistic oracle uh sdk so the best use of uma's optimistic oracle integration will receive 5000 for the first place 2000 for the second and one thousand dollars for the third place next up we have unstoppable domains so the best use of login with unstoppable domains will be receiving fifteen hundred dollars for the first place and an additional 1 000 free domain credits for you to in a way scoop up a lot of interesting domains with a lot of different weaponry specific native tlds the second place goes to one thousand dollars uh and uh seven fifty dollars in free domain credits and the third place will be receiving seven hundred dollars for the best integration and then five hundred dollars of free domain credits they also have a price pool of eighteen hundred dollars which means that any teams qualifying to meet the proper integration use cases will be receiving and splitting eighteen hundred dollars and also three hundred dollars in domain credits then we have covalence and the best use of covalent which is a single api for recording the blockchain around all the the data that you're looking to get across different networks uh we'll be receiving pool price categories only which means that all covalent integrations that are sufficiently utilized and integrated will be splitting five thousand dollars equally and they're divided into three changes of reward levels so you can you'll get to learn the details around that in on the price page next up we have lens and for lens we have two categories or two uh one category and two prizes so the category is going to be around any apps that help you enable publishing faster and making that experience better um so the first place will receive 3 500 and uh second place will be getting 1500 for the best use of lens into their hacks around publishing then we have spruce so for spruce espresso control all the data across the web especially through their primitive signing with ethereum so the best use of signing in with ethereum as an integration will receive one thousand dollars for the first place and two 500 prizes for the runner-ups integrating siding with ethereum and you also get to learn a lot about this in our devtools summit especially using tools like wag me and ethers who are going to be covering what's next for those protocols and those sdks and then any contribution that helps make the signing with ethereum library and sdk itself better will be receiving a thousand dollars for making commitments to a really amazing open source uh initiative next up we have connext and the best original project built on top of connects will be receiving two thousand dollars which is any interesting use case that helps you call contracts between different l2's and enable for a new more efficient cross-string communication and the best crosstain augmentation of an existing protocol which is integrating with an existing protocol that previously wasn't as integrated with any cross-chain use cases will receive uh 2000 as well and then there's also a pool price of a thousand dollars for anybody who makes a successful cross call next up we have the graph graph is an indexing protocol letting you query all blockchain data efficiently through graphql so they have two categories the best use of an existing subgraph in your projects from their graphic graph explorer page the first prize will be going to send it will be for 1700 to the best integration that using this subgraph and a second run or a price for 800 and then you also get to contribute sub graphs to the graph explorer and ecosystem and the first price there is also going to be 1700 and then the second best new subgraph contributed to the graph explorer will be receiving eight hundred dollars then we have nft port nfd port is the stripe of nfc so you can get all the infrastructure requirements for being able to essentially do anything you like to do around buying and managing and selling events and they're also doing a pool price of five thousand dollars which means all nft port integrations will be splitting five thousand dollars equally then we have table land and tableland is a decentralized database network that's gonna have the ability to query information on chain writing sql tableland is what you want to try out that's a really interesting tool and the most innovative use of table and in a project especially integrating a decentralized database a relational database will be receiving one thousand dollars for the first place and the runner-up will be receiving five hundred dollars and there's also a pool prize which means all projects that use table land in a really interesting way will be splitting 3 500 equally then we have quick node the best use of quick notes nft or token api will be receiving 2500 for the first place 1500 for the second place and 1004 at the third place and click node is a service that lets you really efficiently get on-chain data whether it's to our rpc or through really specific endpoints that help you aggregate and make sense of nft and tokens directly then we have cismo cismo is a really interesting tool which lets you generate ck badges proving reputation identity without actually compromising on privacy or sharing information so they have a lot of different categories for the privacy fighter category which means the best use of cismo to help people improve their privacy will be receiving two thousand uh there's a simple killer category so the best civil resistance zk badge will be receiving fifteen hundred dollars and the best ck badge all together which is a batch that you've been through the cisco sdk will be receiving 1500 then you have b bridge and d bridge is a generic cross chain interoperability protocol and the most innovative question applications using d bridge we'll be receiving 2 500 for the first place 1500 per second and 1 000 for third place just a couple more to go uh and then we're going to kick off with our deadpool summit so really appreciate everybody checking out all these prizes if you have any questions about the events of the logistics feel free to ask them on eat global.tvs chat so next up we have ceramic ceramic lets you access data in a really composable way that's native to web3 the most innovative application for data composability discovery will be receiving three thousand dollars for the ceramic sdk integration the best integration of compose db as a database layer for their hack will be receiving 1500 and the best use and integration of compose db with a another partner of ours as an integration will receive 500 for encouraging a lot more collaboration then we have teller and teller is an oracle protocol so there's going to be five thousand dollars for a full price category which means all integrations of keller will be splitting five thousand dollars amongst themselves then we have unlock and unlock is a protocol to let you manage and create memberships leveraging different nfts and standards and uh access controls so the most inventive use cases that create unlock integrations and bring in introduced memberships will be receiving 2 000 for the first place 1 1500 for a second and 500 for third place then you have oasis network and the best use of oasis will be receiving five thousand dollars for their integration and then you have odd protocol and it is a protocol that helps you really manage how to efficiently create and manage dials so the best dao powered app with the protocol at the sdk will be receiving five thousand dollars and then we have xmtp labs xmtp labs is a way to create secure messaging between ethereum accounts so the best use of xmtp will receive 2500 for the first place 1500 per second and 1 dollars for the third place and there's going to be a pool prize where every qualified entry will be receiving hundred dollars each for the best use of powered by x and tb into uh their applications and then we have streamer and streamer lets you create really interesting pop sub use cases for faster p2p messaging so the best user streamer will be receiving 2500 for the first place 1500 per second and one thousand for the third place and then ballast so ballast is a weaponry software distribution platform and the three best projects published using their sdk or who uh soft license or ifts or other use cases using the ballast protocol will be receiving one thousand dollars each and a full price of two thousand so all interesting balance integrations will be splitting two thousand dollars evenly so there's a lot of prizes because we do have thirty three hundred fifty thousand dollars in prizes from everybody uh so you can check out all those details on online.educable.com prizes that'll get you all the specifics documentations workshops talks examples of every protocol that's here giving a prize and you can also see that on your hacker dashboard so before we kick off the summit i want to make sure that we make a really quick note which is this is a month-long event we specifically designed it to be this long so all of you especially beginners get to really take the time to learn and understand before you dive into how things are interesting and exciting in web3 so please pace yourself we really don't want this thing to be exhausting for you we really want you to have fun building and learning about what's possible here and this whole month and event is about experimentation it is okay if you don't get to finish everything that you wanted to do but as long as you end up learning more than you did today or the week before is that's our goal and that's kind of our hope so please don't hesitate to ping anybody on discord if you need any help if you want to understand some topic better or if you have a bug that you can't figure out why it's happening we are there to make sure that you are able to er learn and move forward all right with that happy hacking to everybody as a hacker who joined in we'll see all of you on our discord and with that we are ready to roll off with our devtools summit so for those of you who are joining us this is online a month-long event focusing on all the amazing things happening on the ethereum ecosystem we're going to do a summit every week on a topic that is going to be relevant to what's happening in this space of web3 and we're going to start today and this whole hackathon focusing on dev tools and how you can use different devtools and sdks and what's coming in anywhere from best practices to future requests being handled to future versions and what they're going to support for all the libraries that you already use from solidity to ethers everything will be covered in the next few hours so jam-packed next few hours for all of you we're going to kick off with adam who's going to talk about hard hat and anywhere from best practices to tips and tricks that you didn't know then we have tess talking about the solidity best practices and we're going to cover 10 tips for how to be a better solid developer and then garrett is going to talk about how you can actually use vypr to build secure and faster defy apps khan will be talking about how to use sourcify for verifying and checking your smart contracts for potential security risks hari is going to talk about what is happening with the solidity language and the latest with everything that they're thinking about at the ethereum foundation on the solidity team tom is the author of vlogme which i'm sure all of you have used at this point and tom's going to talk about some of the internals around wagmi and what's coming next and we're going to end the day off with rikmu talking about the next big release of ether's js with what's coming in ether's v6 all right enough of me talking in intros i want to kick us off with our first summit talk of the day and that is adam talking about having fun with hardhat so without further ado let's welcome adam on stage hey adam hey how's it going going great i'll i'll let you kick this off and welcome cool thanks so much cool to be here um all right so um i guess let me show my screen um so today we're talking about having having fun with hard hat um so i i guess i preface this by saying that this is not a um a sort of uh walkthrough of how to build um an app specifically with hardhat there are loads and loads of really great um loads of really great um guides out there that that'll show you just that and show you how to build um like all all manner of apps i'm here here today i really want to i guess dig into um hardhat give a bit of an overview of what it is the toolkit and then i guess run through some of the cool stuff um that you can do um that you can do with it so um i guess uh we're gonna go gradually up up the meme um so we're gonna start obviously talk about some of the basics local evm compiling contracts deploying them um we'll talk a little bit about testing um and some of the cool plugins that you can leverage if you're using hard hat um and then some other stuff around like custom tasks evm manipulation forking chains um and contract verification so um a whole bunch of stuff um we're gonna obviously try and do um try and do stuff live um and so we'll see we'll see how that goes um but uh that's uh that's how we can kicking things off i guess just uh to really like orient level set um yes i'm a um i guess uh web 3 developer i worked in a bunch of stuff i'm going to be working with that was how i got into the space and i know loads of folks came out the same way i'm doing a bunch of work with um austin so i've worked on nifty nifty inc which was built with what was formerly known as and that was then then became hardhats i've been using hardhat for a while it's been cool to see the tools that the toolset develop um and i'm currently a pm working on on the graph and so hopefully if if there's time also pull in a um a work in progress a hardhat plug-in which is making easier to develop subclass as well um so a bunch of contacts there um as i said we're going to start at the top so a hard hat is uh first and foremost there's the hard hat network so it's basically a local ethereum node uh that lets you do development and be debugging so that's super cool um in terms of getting started there's really good documentation i'd encourage folks to um jump into that it's actually been revitalized uh quite recently also with the like organization so hardhat used to just be um pretty agnostic it's um it had essentially the evm a bunch of stuff that you could do with it and then a really diverse um set of um plugins um but more recently there's they've introduced the hard hat toolbox which is the sort of bundled commonly used set of packages and hardhat plugins that they use to get um to get started so um one thing i did in sort of preparing for this is that i um aligned that i updated scaffolding um to use the latest version of um of hard hat and i've also pulled over to the um to start using the toolbox um so i'll run through all of that today um so if i've got my i'll share the whole screen if it'll let me yeah perfect all right hopefully you can see the whole screen now um maybe yeah cool perfect so um yes as i said i'm i'm i'm in scaffolding we're going to run through a bunch of things today um within hard hat just to orient folks um there's again great content online on on on getting it installed but like the heart of hardhat in any place is the hardhat config file so essentially this is a configuration file where you say okay when you're running hard hit like here are the things that i want to pull in here are the things i want to use um so one of the first things that you'll almost always do when you're working with with hardhat is is you'll run a local chain so um essentially if i'm running this here i'm running a hard hat chain um and what does that mean it's basically running a little ethereum virtual machine um uh on my on my laptop which i can um deploy contracts to so maybe we'll start with that and if i run yarn deploy um i'll see a bunch of stuff happening um essentially uh to orient folks i'm in this hardhat directory um i've got my hard hat configuration file um which as i said um uh like has a bunch of stuff which we'll talk a little bit about that in a second then we've got my smart contraction here in the contracts folder so this is a super simple this comes with scaffolding um but it's a super simple contract which lets you set purposes um so just so this one doesn't let you um do much apart from set a new purpose um and it emits an event whenever that purpose is set um so what i did was i spun up that local chain so you see this um strain running and then i essentially deploy so actually if i deploy to that network so if i deploy to this network fantastic good start um let's see it seems super deployed so now if i run um back and now if i actually run a local app just so we can interrogate and see some stuff that's going on we can get a sense and this is yeah as i said using the scapulae framework but we're going to really dig into some of the stuff that you can do with hard hat so essentially if we look at this this contract and if we pull it out here if we go to the hardhat conflict just to like orient people to some stuff that's going on in here so um firstly hardhat has this really cool plug-in based model where um you can pull in um plugins which others have developed or that the hardhat team have developed which are relevant and interesting um so one example um is the uh so that's called the local host um so one uh example of a plugin which um is imported here is is the tenderly plugin that lets you leverage loads of stuff that um the tenderly team can do everything from like interrogating local transactions to verifying your contracts the hardhat toolbox i kind of talked about earlier um and the hardhat deploy plug-in is a really great community-based plug-in from wiggle wag which essentially lets you manage all your deployments so just to dig into that a little bit more um deployment um in uh in hardhat can be done in a bunch of ways um but this hardtop deploy plug-in is is really great because it gives you lots and lots of control when you're deploying your contracts so uh to orient you in terms of what happens here um if we go into this deploy folder which is how hardhat deploy works it'll essentially run all of these um these deployments um so this is deploying your contract um and uh so uh when you run um hardhat deploy it'll essentially run through these and run all of these uh like run over these migrations um so this first deployment of your contract is essentially getting deployed here um it's then getting deployed and there's a bunch of other stuff here which shows you some of the power of what you can do with um with hardhat but it's pretty simple to start with so if we jump back to the front end if you've got contracts we can see this first one in here so that doesn't seem to have worked nicely um okay now perfect okay this is good always good live demo stuff um okay let's go up here five four five um cool let's see if we can fix this actually maybe we will see if that deployed okay i know what this is [Music] okay classic node compatibility and then use okay um perfect okay perfect that's uh we're off when we're rolling um all is well now so um if we now go back to the local host uh we can see this contract um so building unstoppable labs and now if i call this a contract firstly if i grab some funds from the faucet so one really great thing about a local chain uh which you're running is that you can pretty much do whatever you want so um here i um initiated a little transaction to myself uh sending myself to me so i can actually start transacting so testing with hardhat okay if i send that fantastic you can see i'm making this uh transaction i set the purpose um and then you can see that the purpose is now updated so i'm interacting with a local chain and so then one cool thing that often um when you're working with hard hats you'll be debugging your smart contracts um a cool thing which you can do which you can't do with a normal chain is essentially console logging so that classic thing that you want to do um essentially when you are um you may be debugging a contract so have a special console um dot log um console dot soul um uh contract which you can import into your contract um so you can start to use some debugging maybe not so relevant to this like in this super simple case but it might be that you want to test why a certain logic branch isn't being passed down and so console logging within your from within your contract will let you do that so to keep moving forwards it i'll save this i'll redeploy my contract um so essentially it gets detected the contracts changed so then needs to compile again it's compiled you can see it's deployed again if we go down here um and now if we go in here you can see that we've got a whole new contract the front end is hot reloaded but now if i re-call a different one hopefully log smiley face you can see that this got console logged here so this is a really cool thing you can do with hardhat um to essentially be uh maybe debugging contracts maybe checking the variables that changes like as you'd expect during execution um i would say the one thing which i've sometimes done when deploying is to forget to get rid of this um this import because it's obviously extra code to deploy to the chain that's one cool thing you can do with hardhat um so let's just jump back to the things um as i said the um there's some cool things um but also potential gotchas when you're using different plugins so uh one thing is that uh if you want to say redeploy your contract um in in this case hardhat deploy detects that actually the contract's not changed at all you might just want to re um and so just reuses the same one it might be that for whatever reason you actually do want to reset the um deployment um so in this case you can call reset and it'll redeploy the contract and give you a whole fresh new app again so that is um the basics the bare bones and this is really cool because you can basically be adding new functionality to your um to your contracts so let's see this is going to be relevant timestamp and if we go public view returns next two five six we can do this and we can do um block number as well okay these two new functions we can deploy these guys um so essentially uh it's a really good place to be iterating and developing your contracts so these will get deployed we know these new two fields which show up here um and yeah we'll talk about um them up again in a second so and then in terms of the next step that you can do with hardhat which um so we've covered pretty much the local evm compilation and deployment next thing that you can do is testing um coverage and gas reporting so let's run through those so if i run yarn test here um essentially i run some tests so so these are some unit tests um which are run actually i've jumped ahead here because you can kind of see um uh this uh at the bottom so um essentially these are just unit tests so if we jump into my test you can see um essentially the tests that we've just run so um what are we doing here so um essentially uh this is getting run on a again instantiated local hardhat node um and essentially checks a bunch of things which you um expect to happen when you're working the contract so for example um it you can test that your contracts deployed properly you can test that when you call a given function it has the effect that you'd expect um and then you can also check for example that an event is emitted um when you when you call that contract so um that's uh again the kind of stuff which is moving to um from sort of hacking iterating working on contracts towards something that looks um more like sort of software development best practices um and so uh again a really rich toolkit and um and one thing that hard hat also recently introduced is their own sort of matches um which um haven't fully dug into but um again uh is moving away from uh where they were using a a sort of um a prior truffle library um but so uh testing can give you a lot more confidence when you're making changes to your contract that they're not having sort of side effects that you wouldn't expect and to make sure that actually when you've implemented things um that the uh result is is what you would expect so um you can also do all that within the sort of um within the hard hat framework there's some other cool stuff that you can kind of get when you're running your tests so this um table at the bottom is one of them um so this is again something that comes in the hard hat toolbox um and if we jump back to the hardhat config you can kind of see where this is configured which is the gas reporters so obviously there's a large school of thought who are very focused on gas optimizations within smart contracts um and so this is one where um if we look at this um this uh this report this essentially takes all of the tests that were run um during the tests and sees what the sort of gas usage was for those tests um and so you can see within this gas currency um this gas reporter thing this is um coming bundled in with the um bundled in with the uh with the toolbox um but essentially uh if you call the enables get true so i mean if i run this again without it you just have the sort of output of the tests um whereas if i run with it again you can kind of see this table which gives you this put and so then you can start to see as you're making changes to your contracts and how that's then impacting different things so for example if we add a un256 let counter equal now if we do yarn test see if i give it a second you can now see that um the increase in gas usage because i've added this new um this new storage update um and so that's again like a thing where you can start to optimize start to keep track of um of the cost of just different actions um the last thing i think i'd call out and i just in the interest of uh time i think i called this in was essentially the coverage command so this is um again similarly running your tests but also giving you a sense of the coverage of your tests so if we jump back to my contract you can see that um my contracts i added a bunch of functions here um and if we look at my tests my tests actually only really uh test out the the set purpose function um so this is identifying if we jump in here that um that actually there are some lines which haven't been covered by my tests some uh the potential functions which haven't been covered by my tests again this is a thing that just comes bundled in with the hardhat toolbox um so again you can not only be running tests and feel confident that your changes are um not having unexpected impacts but you can also have an understanding about actually how thorough your test coverage is so that's testing um there's a bunch of cool stuff there if we go back to the meme we can see that we've covered testing coverage and gas reporting um and so then i guess we can jump into um some of this um like slightly more um advanced stuff you can start to do with hardhat so we're gonna talk about tasks evm manipulation forking and verification um so for example so if we jump back to the code um if we go back to the um hardhat config um again just to worry about the stuff that's going on in this file we're importing a bunch of um like of plugins that are useful um we're configuring um a bunch of um essentially exports or modules and so a lot of these are actually networks that you want to interact with you saw me like changing the network that i was interacting with um so that network configuration is a big it's a big thing here and obviously folks in scaffolding want to interact with a lot of networks here um you've got the ovm the like uh you've got some of the um again uh api keys or like configuration for some of the other plugins um but then at the bottom here we've got a bunch of tasks so within um within hardhat you can deploy you can define a lot of tasks and scripts um so tasks and scripts there's a there's actually a post and a documentation about when you should you should use one or the other and focus on tasks today essentially um these uh essentially little snippets that can be run in the context of um in the context of the hardhat environment so you can start to interact with your um with your chain with your contracts so let's uh run through a couple of those um i guess yeah so if we go on that on this one you can see that i just ran this task which did didn't do much it just uh locked console logged hello world um so that's not gonna say that that interesting but then you can start to see i like other interesting stuff that you can do um so one thing you could do is you could just white contract so you could update um state variables or you could do you could interact with your contracts on chain and through these tasks but the thing i want to now dig into is some of the other things you can do within hardhat which is kind of interesting and so it's um essentially starting to manipulate the evms so if we take this one so this mpx hardhat our if we jump back to here come back here um essentially um we um this is one of these essentially hard hat manipulations you can do where you can interact with the um virtual machine to change some variables so essentially um there are a few of them that i've called out here one is to minor new blocks that's just to add a new block block number to the chain um and this one is to like add that like change the time on the chain so you might want to do this when you've got a variable which is like like maybe you've got a game and actually you can only close the game after a certain amount of time but you'd actually don't like you don't want to wait that amount of time you just want to sort of move forwards in time um so if we go back again to the um to the ethereum app um just because then we can i guess have a look at the stuff that's going on in the front um uh to get a sense of what's going on if we go again add an hour um [Music] perfect so now we can see we mined an empty block so remind that empty block you can see that actually jump forward an entire house these this is a timestamp um similarly the block number is updated so um this thing where you can start to interact with the interact with the chain um and so these feel like uh um relatively small things that you can do and but there are some others that actually let you do other stuff so for example like you might want to um adjust your balance so so there's a help which actually lets you set the balance for a given account so if we go back to this guy i'm using um hello.adamfuller.eth um if we take this um and if we say okay give me eth i'm gonna run essentially this one run give me eth pass my address in here so you can see this task was defined with this name i added this address parameter and then what happens is that the helpers set the balance of my account to five ether so you can see currently i've got 15 so not one so we run in here and now if we fresh i've now got five either um you can see this it's it's not added five it's actually just set my balance to five um so if i then when i change this maybe if i wanted to give myself fifty or forty nine either videos again you can see so my balance again you've got 49 ether here so again just ways in which you can start to manipulate the state um uh and and and and so again so we've gone from like adding the time we've gone to um mining mining blocks we're going to set setting balance what about doing something um even more interesting so this this task lets you take some dyes so um this should actually be die um so this this is a helper which lets you essentially define a um a user who's uh essentially impersonating an account so um to impersonate a sender which then lets you make transactions on their account which you could never normally do in in a sort of normal in normal context um and send yourself some well of any any specified token in in this case so i just interrogate this again this is called take some die given a token address a sender and a receiver it creates this and this can actually be much simpler um um it essentially takes a name takes an api which is an elc20 api it then impersonates the sender account so hearthout will just assume the signer is the sender account um it then um essentially instantiates a contract with ethers um and then transfers um some uh some of that token to you so again this is one where actually um has an interesting dynamic here so we're jumping into another thing you can do which is to not just start your uh for your local evm from nothing but to do it from a fork so this is one where um i'll run a special command so just cancel my local evm and i've run a yarn fork so if we take this see i've started a yarn fork and i'll deploy things to it boy if i refresh so actually i've got 17 um on this which is the account i have if i were to connect um on localhost search my network search network refresh my network you can see that actually it you can see it's fork from mainnet because it's got the amount of that i've got in this account on mainnet um you can actually then uh deploy um the contract in the same way um that you otherwise would um and so then um then essentially um given this i'm now essentially interacting with the chain which looks exactly like maintenance again this is a super cool thing um which hada lets you do because you can actually start to interact with this chain um uh um let's use interact with this chain as if it is a real chain so um so this is one where um essentially if we go to die um refresh this like this is the this is the die contract on um this is the die contract on main net but but my local fork essentially looking at this and so the way that this works if we go to package.json is that when you run fork essentially um you run a normal hardhat node but you specify a um an rbc to use for the fork and then essentially whenever you call for state um that's only on the main chain um that it will essentially defer to and use this rpc um and so that's again like a really powerful unlock if you want to maybe simulate or test what happens i've used this um in scenarios where i wanted to check what happened or or verify that a bunch of transactions would have the outcome that i wanted them to i could fork may not run those transactions on my local evm maybe generate a bunch of signatures that do those kind of things and not worry too much about um and and now i could have confidence when i actually executed them um on them like on the real on the real chain that things would happen as expected um anyway so where was i if i jump back to um what that then allows me to do is then if i say okay let's take some guy um i've saved this so this is um again on the local host network this is the die contract i'm sending from this dive person to and i want to specify my address here i think that's the right one run this um you can see now if we take my address let me take my balance you can see i've got five die i've just given myself five die again if i run that again um and i run the address again i've got tendai um and so again one final really cool um cool thing you can do you can so you can fork the network you can send yourself dire you can act as other people um it's a cool thing to do um with hardhat um final thing i think um so again this is just to talk to the plug-in um like all of the plug-ins that exist on um uh well actually one other thing you can do is essentially verify contracts so one thing i could do if i want to deploy is i could actually deploy to ring could be i could deploy this contractor rinkerby i'll do that now um this is actually deploying live to a a test net one final thing that you can get out of the box is verifying um verifying your contracts um so now if i essentially take this contract um um id um if we actually go and look at it on rinkerby uh that one let's be we're gonna be literally up to the minute if we run in here take a look at this contract did that work like it may not have um maybe we're not gonna make it at the last minute um let's see okay still it's still indexing um but it should show up in a second um one final thing they can do maybe it was not going to show up until this indexes has essentially verified contracts um and so if i run this last yarn verify network network ring could be command with this address call this this will then verify the contract we take the contract here perfect because it's submitted for verification and any minute now it should hopefully come back and it'll be verified and that's it i think i'll wait for the verification result so now if we refresh back in here last thing there's the verify contract and that's that's all i got amazing well uh as usual this wouldn't be a talk if something doesn't go slightly according to plan but uh this was great a lot of interesting tips and tricks and i'm glad that it's recorded because i gotta really dig into some of these commands to actually do this on my own too so i appreciate this adam thank you so much uh i hope everybody in the audience enjoyed this primer as well and uh unfortunately we are a little bit overtime so we have any time for questions but if there are any that come up i will send them to you directly and then we'll answer them back to you uh the person who asked those questions on the chat so thank you so much all right with that we are ready for our next talk and i'm super excited to welcome taz smart contract programmer to talk about validity best practices and 10 tips to become better at developing solidity so without further ado let's welcome test hi hello uh what'd i do can you guys see me see you and we can hear you you're all good to go um let me try sharing my screen and can you see my code editor everything is good all right thanks all right uh so for today i'll be talking about 10 um solidity best practices uh they're not in any particular order they're not in any particular importance they're just some maybe uh things that i learned while uh learning study so and i'll share them with you guys today so the first one is to lock compiler version um so the bad practice is to have a compiler version set like this with a carrot and this would mean that your solidity version can be anything from 0.8 and that's 10 0.9 uh and the good way to do it is to lock the compiler version it means to set it to a specific version for example here we're setting it to 0.8.13 and the reason why we want to log compiler version is uh i'd say that it's mostly for when you deploy a contract and then try to verify it by the time you deploy a contract you might have forgotten which version you deployed it with so it's really helpful that you lock your version you go back to your code and say oh so i i know that i deployed it at 0.8.13 so you'll remember it and you'll have a easy time verifying smart contracts uh the other reason is um sometimes solidity will announce uh bugs and if you know your version then you would know if your contract has a bug or not so that is one recommendation to lock your compiler version okay so uh the next one is multiply before i divide um i see a lot of developers uh new developers asking the question if i have a number like x how do i get like ninety percent of x so one way that you might think that you would do it is to say x times ninety percent so it'll be 90 divided by 100 and here we're dividing 90 over 100 and then multiplying x and the reason why this is bad is because in solidity numbers um there's no decimals so uh numbers round down so when you divide 90 by 100 this will evaluate to zero and zero times any number will be equal to zero so the better way to do this will be to first multiply your number x by 90 and then divide by 100 this way you will there might be some rounding errors but this way you'll get close to 90 of x assuming that x is maybe greater than 100 so that's um multiplying before dividing and in in the real world in the real world you might see code something like this something like calculate calculate uh ratio of shares uh the bad way to do it will be to maybe the okay so first of all here let's say that we have a contract and it keeps track of the total shares in the contract and the number of shares per user the bad way to calculate the ratio of shares is to simply divide the shares of the user by the total shares total total shares will be most likely be greater than the shares of the user so this will most likely return a zero so this is the bad way to write your code a good way to do it is to say that 100 will be equal to 10 to the 18. and then you will first multiply the shares of the user by the multiplier here the multiplier we defined as 10 to the 18. so here we're multiplying the shares by 10 to 18 and then dividing it by the total shares you'll see code something similar to this inside the curb amm contract so they will multiply by some large number and then divide by another number so that their numbers wouldn't round down to zero so that is um multiply before dividing so the next best practice that i learned is to don't name local state variables the same and what i what i mean by this is let's say that we have some smart contract and it has some state variable we'll say the state variable name is total supply and we have some function and inside of in inside this function we might declare another local variable also the same name as the state variable and let's say that we set it to some number one two three and there will be a lot of coding here and at the end of the code maybe our intention was to update the state variable total supply to 456 but when we execute this code total supply inside this function refers to this local variable so what we're doing here is set it setting the local variable to 456 instead of our intention being to set it to the state variable total supply so this is bad practice to have the same name for the local variable and the state variable and the and the solidity compiler will give you warnings so be sure to read the warnings and the better way to do this is to just simply have a different name from from the state variables and the local variables now i want to mention that uh in viper all state variables so this will be in viper all state variables start with self dot my state variable so you wouldn't have this trouble of keeping track of which variable is a state variable and which one is a local variable so this is one useful feature of byproof oh okay so as a bonus um when you're dealing with peer functions again uh pure means that the function does not read any state variable or any data from the blockchain so one benefit of using peer function is that inside the peer function you know that it's not going to touch any state variable so there is no name collision between local variables and state variables so that was tip number three let's move on to tip number four keep contract simple this applies to a lot of programming and especially also applies to smart contract programming uh and the reason why you want to keep your code simple is that uh complex codes are hard to analyze so uh it probably means that the code might be less secure and there might be bugs that are hard to find so you would want to keep your code simple and what are some examples of a complex code well it might be like um inside a function it's calling many other functions and contracts uh so it's hard to keep track of what's going on inside this function so this is this will be a complex code another example of a complex code might be that the contract is trying to do many things for example it might be this contract might represent amm so you'll be able to swap tokens and it might also represent like a d5 vending and borrowing so inside this amm contract you might have other functionalities to like to then and borrow and liquidate tokens so trying to do many things inside one contract is uh is not good practice another this might this is my opinion but it might when i see a lot about bu functions inside the smart contract i think it's um i think it's unnecessary uh complexity inside the code for b functions you can usually move it to another contract so uh we'll see in a second what i mean by this so good good code will be simple contracts it will be simple code uh and inside the contract what i try to aim for is to do as little as possible and if i need to ask the question do i need this function or do i need this view function inside this contract uh the answer is most likely no and the way i would know it is if i'm asking that question then the answer is probably no if the answer if i don't have to answer that if i don't have to ask that question then it's probably obvious that i do need that function so that's how i decide which function goes inside the contract or not and one thing that i always like to say to myself is yagni which stands for you aren't going to need it you're not going to need that extra b function you're probably not going to need another function inside your contract keep it as simple as possible so a good practice that i noticed uh in some contracts in some d5 projects like uni swap b3 where they split some of their core logic from view functions so they will split the logic of a price oracle into another contract from the amm contract for example you have some kind of core contract and then as another contract you have a view contract the core contract if it if there's a bug then you can't really fix it but if there is some kind of bug inside the butte contract then you can't throw this one away and rewrite another one and then deploy it so i think this is a good pattern to split the core contracts and the b contracts that was keeping contract simple and the next tip is to prioritize security over gas so for example um what i mean by this is that sometimes you would see code that are optimized for gas but it becomes really difficult to read the contract so there might be bug but you can't really see the bug because the code is complex for this example here i have some kind of loop and it's trying to optimize for gas so if i take a look at this loop it's looks like a regular for loop but instead of having an increment of the counter inside here i do like uncheck and then increment the counter inside the loop this code is a little bit harder hard to read but it does save gas on the other hand the good practice would be to to prioritize for code readability and security so what you might do is write a regular for loop that everyone is used to seeing so that's security over gas the next tip is avoid unbounded loops and what i mean by unbounded loops here is that there is no upper limit to the number of loops and why is this bad this is bad because there is a there's a limit to the amount of gas that can be inside the block and unbounded loops means that it's going to consume more gas than the block gas limit so at some point your trend at some point your transaction will fail so let's take a look at some examples of the unbounded loop here i have a state variable called accounts and i have a mapping called balances so it will map from account to the balance of the account and to make this a array of addresses accounts unbounded we have a function called join and it pushes an address into the accounts state variable so example of a unbounded loop will be to loop over all of the accounts and here we're just updating the accounts by adding one why is this bad well imagine if 10 accounts if there are 10 addresses in the account then it might use certain amount of gas if there are 100 then it's going to use more gas and if there are 1000 accounts and it's gonna use more gas than that and at some point you'll hit the block gas limit and this function will always fail a better way to to handle unbounded loops is to to have some kind of uh upper bound to the number of loops for example here inside the um input we're saying start the loop from start and end at that end and we do a loop so this function will never be uh it will never fail because we can always bound it from start to end another example of a unbounded loop this is a subtle one but let's say that we have some kind of function and then inside the function it calls another function called test2 and inside the function test2 it takes in the array of addresses and notice that here we're passing a state variable address array about array of addresses but here we're passing it as memory so what this means is that although the state all of the um addresses inside the state variable accounts will be copied over to memory so basically we're running a for loop here so this is an example of an unbounded loop and to show you this uh i wrote the test let me try opening it um bounded loops dot test file and what i did was the first test i i called join three times and then run the test next i call join 10 times and then run the test so what you'll see is that calling going back here what you'll see is that when there are three addresses in the accounts it will use certain amount of gas but when we have 10 addresses addresses in the account it will use more gaps so i'll copy this and open my terminal and then paste it and then you can see here that test gas 2. this is the this is a test with where we have uh 10 addresses in the account it used up more gas this was a subtle example of an unbounded loop try to avoid it okay so the next one is to don't trust the user inputs what i mean by this is that if you have a function where any user can call and let's say that it takes in some kind of address adjustable contract and then inside it here we can see that it's calling into the token and calling the function transfer from but since we're passing in user input the user can put in any contract address as long as they have a function called transfer from so which means that they can execute any arbitrary code and for example what we can do here is have a user the user might have deployed a malicious contract and then they will call this function and inside the function transfer from we that malicious user will put their malicious code inside here for example for this example we just put log the message called hacked and what will happen is that when the user calls the function deposit it will execute and then they will pass in the address of this malicious contract they will call transfer from and execute this execute this code so this is what i mean by don't trust user input and i cannot remember from the top of my head head but i do remember that there were several default hacks where the user were able to put in their contract address to do some kind of hack the next tip is checks effects and then interaction so what i mean by this checks means that first check the inputs effects means that next update the state variables or do some kind of change inside your smart contract and interaction means call other accounts or contracts so the best practice here is to first check user inputs next to update your state variables and lastly to call other external contracts so first of all let's take a look at a bad example a bad example would be to again see over here called withdrawal bad notice that instead of checking it does no check and then next it calls into another contract or transfers the if to message.sender and then lastly it updates the balance of message.sender this is the effect part what you want to do instead is to have something like this check effect and interaction the check will be to check the user input for example amount is greater than zero next will be the effect so updating something inside this contract here we're updating the balance of message.sender and that's the to call external contract for example here we're sending the eve to the message.sender this way yeah this code will will is now vulnerable to reentrance city attack however this withdrawal pad is vulnerable to re-engine c effect okay the next tip is to use re-engine c-guards so in the previous tip we said to use check effects and and then interaction but this does not guarantee that your code is safe from reentrancy attack so whenever you're in doubt then well at least for me whenever i i'm in doubt i always put like a reentrancy log and so that i feel safer than my contract is probably more secure so what do i mean by a re-entrance regard the reentrancy guard is a simple modifier that first checks that the state variable locked is set to false and then it sets it to true and then executes the code and then after the code executes it sets it back to false so that if there was a reagency it would execute this part of the code come back in and this since the lock is true this part will be will fail and this is how it protects from reentrancy let's take a look at an example so here i have a bank you you can uh deposit into it and you can withdraw notice that this function does not have a rein reentrancy guard whereas this one does um to show you example i wrote a hack to do a reagency um and to do the reagency around this command so i'll be calling this withdrawal function once and if the test passes then it means that the re-engine seal is successful so i'll execute this test and the test was successful so that means that the reagency was successful next i'll put a reaction c log on this con on this function called withdraw and then we'll execute the test again this time the test will fail because the re-entrance the log is protecting that function and you can see here that the test failed so that's reentrancy lock if you're uncertain if your contract is vulnerable or not vulnerable to re to re-entrance the attack then just put a reentrancy lock and feel safer with your contract okay the last tip is pull over push so what do i mean by push and pull push means to that the contract sends if or token to some address on the other hand pull means you allow the caller to withdraw if or token and why do we recommend why do we recommend pull over push well first of all if you do a push it might be vulnerable to reagency and there's also a chance that you accidentally send it to the wrong address so let's take a look at some code so a bad way of a example of uh this will be an example of a push would be to directly sending eve to some address but notice that if we were to put in some wrong address here then this would send eve to the wrong address another example might be to like send if many even though that let's say that some of most of the addresses inside this receiver are regular users but one of them is a malicious user and this person decides to reject all if sent to this address then this function will fail even though only what most of the users are regular users so that's another reason why uh push pushing eve to another address is not recommended so here's an example of sending a token a better approach is to let the user pull the token and what i mean by this well it's going to take two steps first the contract approves the user to withdraw from the contract so here for example i have a function called gay beef and it will increment the if balance for the address 2 and if for some reason we put in the wrong address then we can easily fix this and once this if balance is incremented the the user can call withdrawal eve and this will only decrement the amount of beef that was allocated to them so this will be the user pulling some eve into their address and the same example for uh erc20 tokens we can increment the balance of the token for address 2 and let the user pull token and that completes the 10 best practices that i picked up learning solidity amazing that was uh that was great and uh also uh very concise and then to the point now people were super excited there's a two kind of common questions that came up one is in your pure functions example um we want to clarify if that's a typo where it says total supply i think there was a it just says to a supply so we wanted to see if that's where the collision wasn't coming from or was actually like a miss uh a typo um so we'll get that cleared for the birthing who asked that question um and the second uh request is if you are able to share uh these 10 examples so the code whether it's through a slide deck or just to get a repo uh fit much appreciated because they want to okay themselves as well uh i'll send you the links or you want me to put it on directly or in the chat too and we can also communicate that to all the hackers on discord too okay i'll do that uh well thank you okay yeah yeah uh oh sorry in case you want to address the first one you're more than welcome to but yes um maybe create a health issue because i think yes we're almost home yeah yes well thank you so much and uh this was great and uh thank you for doing this thing you're doing this thing super late in cutting your time zone really appreciate it yeah that's all right no problem yeah thanks absolutely all right next up we are going to do a similar thing but for hyper so without further ado like to welcome garrett it's going to talk about how do we actually use viper and build more interesting things and use deepai's example base for getting the best out of the viper link so carrot uh feel free to turn on your camera and uh get started excited to have you hi cartwright thanks very much for having me very excited to be here and addressing uh everyone worldwide i think you nailed it we're here to talk about a lot of topics around some specifically some of the tooling uh that i think makes viper really really great and in particular the use case that i'm going to be focusing on is how you can apply vipre to d5 but uh open to kind of talking about anything what have been some of the kind of highlights you've seen so far you are the third talk and we're just sort of ramping up as we kind of go into uh more and more in depth of different devtools and sdks out there so i feel like people are slowly building towards learning about the internals of libraries that they use like ethers and vlogme and we're going to kind of start from languages to to sdks so that's the plan for today excellent excellent um so i'm yeah i'm very excited to be uh giving this uh talk here let me get my screen share going real quick because this is a bit of a modified version of a less technical talk that i was giving in etham back there is focusing on introducing viper to a broader audience but it was not a technical talk specifically so in this case i'm going to be talking more specifically about some of the tooling specifically brownie and ape works as well as the newer titanic boa so all of these are really great tools they can be in uh for the first to use with solidity as well but titanoboa is native to viper so first i'm going to give a bit of background because i expect most people are very familiar with solidity and i want to talk a bit about some of the things that uh some of the some of the origin story behind viper and how it is that it came to be what it is and where it might be advantageous in some ways uh or it might have some drawbacks so many people don't know this but viper was actually started by vitalik himself this was his concept way way back it was a language called serpent and it has quickly outgrown uh vitalik's initial vision for this so viper is uh no longer directly developed uh by vitalik but it has sort of like evolved and the community took it over and really decided to take this into kind of the next level and while you might think that this means that vitalik is in some way casting aspersion on solidity or something like i just want to start this by saying that i teach solidity for night class so i like solidity i like viper i think both are great languages um and this is not intended to cast aspersions on any particular language but uh just want to give some pros and cons of both and also to point out that all of us are really united in our shared goal of having multiple different languages like the evm uh the ethereum foundation is actually working on additional languages uh beyond just viper and solidity because we want at the end of the day all of us united in wanting more great smart contracts to get deployed so if some people want to deploy using solidity some with viper and we have 15 other languages that make more developers comfortable and feel good writing code like this is what unites all of us so for example one of the other emerging options is fe there's a lot of hopefully we end up with a lot of different ways because at the end of the day these are just human level abstractions and what we're really trying to avoid is writing this extremely raw level byte code because anyone who's had to manipulate byte code knows that it's not as bad as it first looks but it's much better when you have these higher level interpreters that allow you to do that allows you to do like much more significant like significantly readable and understandable options and this gets to why you might pick viper over some of the other languages because more than a lot of other languages i really see how viper as a language has been shaped by its core values so from the start when vipre was launched it decided to rebuild this sort of smart concept of a smart contract programming language around three core values uh the first is security and anyone who's been cryptocurrency knows that this is absolutely critical because there's such an amazing number of hacks it's mind-boggling um and viper wanted to address this with the sexual syntax and say that at the development level it should be possible and actually just fully natural to be able to write secure smart contracts that is if you're a new person writing the code it should have security embedded by default so that you don't have to have an advanced level of understanding to be able to write smart contracts that aren't going to get hacked the second value is simplicity it always strives to make the code easier to understand for the reader even if this comes at the expense of the writer and going a bit further it prioritizes simplicity for readers who even don't know how to code and this is one of the reasons that viper is architected off python because python is code is fairly easy to fairly legible even to people who don't understand what's going on with its human readable syntax and this ties into the final point of auditability because we know that auditors do their best but they can't always catch everything can be very very difficult for auditors to catch all the bugs in code so viper wants to make it difficult to write misleading code and this has fueled a number of different design decisions so if you're familiar with solidity uh when you're getting started with viper you might be confused by some of the things you're very used to in solidity not having an equivalent viper it was chosen to simply not included at the core like architecture level because it sacrifices one of these principles for example solidity it's common to include like an only owner modifier viper doesn't have modifiers because they thought that it would be too much work for auditors to have to jump back and forth between modifiers and the function calls to understand what's going on similarly there's no function overloading because that could be a security risk you could have an overloaded function where you're expecting you're calling one version that's fine and you actually call a different version that does something different um viper is not turing complete because the evm is itself not turing complete uh solidity is technically turing complete but it's running on a non-turing complete evm blockchain so viper within the language caps all of its loops solidity doesn't um you could theoretically write an infinite loop in solidity it won't execute because the evm will run out of memory before it can execute it so viper puts this restriction into the coding and this can be an issue for some people because you have to have all your arrays capped um it used to be the case you couldn't have dynamic arrays now you can but they still have to have a maximum size and because of this viper is not having to use this dynamic array pointer when it's deploying code which means it can deploy very very efficiently but it also has this trade-off in that you aren't able to um you aren't able to have like an unlimited array so for example if you have to define the max up front that can be off-putting some people another one we'll talk about is no raw byte code and no inheritance although this is going to change so no raw byte code means that there's not a way of just injecting raw a couple of lines of byte code here there because it sacrifices this capability of being easy to audit with solidity you can inject raw byte code and as a result solidity actually has the advantage on this if you need to if you need to uh for example like we have we'll talk a couple of a couple examples where being able to inject raw bite code gives solidity this incredible efficiency but it comes at this expense of readability whereas viper forces the readability and relies on the compiler to get the efficiency out of it and no inheritance for now is another drawback which we're going to talk about in just a second um but this brings us to where these different principles and this difference in architecture has really caused sort of in my mind a difference in the ideal use cases so viper has a lot of advantages in terms of it's really efficient in terms of compilation costs uh and generally speaking it's slightly more gas efficient out of the box but some of these things give it a bit of drawback so i'll be the first to say that viper has never really been good at nfts and as a result i think that viper has kind of seeded this ground because solidity's advantages make it a sort of natural fit for nfts so we mentioned that some of these advantages of viper are things like it's very good at gas optimization but nft people don't particularly care that much about gas optimization every nft that gets minted has a theoretical optimum price and it doesn't really matter to the user whether they're paying that to the contract or they're paying that in the form of gas wars and as a result we've all seen the experience of wanting to make a transaction and having to wait because the gas prices have just spiked because there's some new nft drop it costs point zero one eighth to mint and people are spending five hundred thousand dollars to mint it in fact this year um the other side meta um had a uh set some records in terms of the amount of uh gas that people were paying to mint this so even though viper made an advantage on gas it doesn't really matter in this space um similarly like viper might be more auditable but generally speaking like nft contracts are fairly easy to kind of cut and paste so they really benefit from the solidity capability of importing modules you can for example use open zeppelin templates if you're at all not concerned about gas they cost a little bit more but they're very readable so it's easy to kind of be able to plug and play and no one is really particularly caring when they're auditing this because the they're not expecting to get money out they're throwing money at it hoping get nft out and they don't particularly expect their deposit they don't worry if it gets hacked they just care about reselling their nft at a later time so as long as the core nft contract works like you can just use the open zeppelin documents and you'll be fine and by and large like a lot of nft people are not going to be reading through the code so the corollary to this is that viper kind of punches above its weight in defy in my opinion because people do care about things like security auditability and these core values that have been built into viper so it's sort of slight because by far like 99 of contracts are still solidity but i say that viper punch is a bit above its weight in terms of the total volume that's been entrusted in dollars terms to viper contracts um even though it's about like 99 of all contracts for solidity viper has about 10 to 20 percent of the tbl largely through like curve finance urine uh lido finance uh similarly the gas optimization within solidity uh within versus viper benefits viper and that a few way worth of gas savings can be a huge difference when you're talking about smart contracts in d5 it can be the difference between using one exchange versus another so for example it's very common to see one exchange will be cheaper in terms of its like underlying gas usage uh sorry so it's cheaper in terms of like uh gas usage but it might be more expensive for slippage and if whether it's a big or a small transaction you'll uh you'll default to one or the other and finally the a lot of the kind of um underlying um properties of how vipre has been architected at the compiler level includes a lot of higher level math functions and i think that for a lot of the d5 contracts we've seen we're really scratching the surface of kind of more complex functionality built into it and a lot of the math is there and screamingly efficient within viper contracts moreover there's no such thing as a stack too deep error within vipre so if you want to write this contract with extreme levels of complexity it's just a bit easier to do it using viper so my contention is that they're both good choices for um in some cases they might be better suited in a use case both are actually solidity and viper are great for both of these so of course like there's some really fantastic protocols built in both solidity and viper but recently there's been this phenomenon emerging which has been popularly called hot viper summer which is where this past summer more people have been looking at vipre and giving it kind of a second look and trying it out part of this is because vitalik former founder of viper went ahead and started to promote it but the real difference was when viper 3.2 to 3.3 got released and before this there's actually structural differences like you couldn't have some abi types and viper that were supported in solidity and this is one of the reasons that viper really was bad at nfts which was that you couldn't have a bytes4 type and viper before uh version 3.3 and the openc api required this for checking interfaces so it was not possible to get a viper nft on um openc to my knowledge maybe someone figured out a hack but i believe i'm the first person to have done it so i feel uh pretty excited about that so people started taking a second look at viper and found that when they first tried a year ago it wasn't quite there but now it not only has all these efficiencies but the in compiler and the interpreter is really great to work with so this became at this point more of like a preferential choice like there wasn't any structural reason why you might need one or the other and people started saying well let's take a look and see and now there are different arguments against um against viper that started to emerge like some people said the ecosystem wasn't as big as solidity which is very much true the solidity ecosystem is huge uh the viper ecosystem is small but very very friendly and i would definitely invite people to join the discord to find out more about it and this brings us to tooling which is the second thing that was listed as a drawback because there is a lot of advanced tooling that's been created for solidity but in the past few months vipre has really caught up on the tooling level as well particularly when we get to titanoboa to talk about it so as we dive more into this question of vipre tooling i want to bring up one of the first things that people always bring up which is foundry support because viper uh here's one a particular person who tried uh who tried using viper during hot viper summer and found it worked pretty good but was still looking for a bit more deep foundry integration and when you're dealing with complex contracts felt familiar with foundry so uh for people who do want to use foundry we're not going to touch too much on it but i do want to point you to this uh ref uh repo that ox kitsune has been making called foundry viper and it's very actively maintained and it's um foundry template that allows you to compile and test viper contracts so if you want to work within foundry you can do this similarly if you like hard hat there's a hard hat plug-in but a lot of people within the viper community opt for brownie and i wanted to walk through a couple of use cases of some like erc20 applications using brownie so if you're not familiar with brownie it's a python based development testing framework and it supports solidity as well and uh it works very well solidity i've used brownie to build entirely solidity-only repositories and applications but because uh brownie is itself python based it's sort of as a natural fit for vipre which is itself also uh viper based and it uses pi test for its testing suite and if you've had the privilege of using pi test you'll find it's a very robust framework it can do many things that you need to do for building out tests for your contracts including property-based and stateful based testing using hypothesis and then there's a bunch of great debugging tools built into it so it's an incredibly robust framework for testing a lot of these defy applications that are built using viper so curve has built out very extensive extensive repositories in which they have robust testing for incredibly incredibly weird edge cases using brownie and because it's been very efficient at utilizing this pie test framework it's been you know two days there's been not a single backend hack of curve although i'm always afraid to say that because i might look over and see that while i'm speaking it got hacked um but i'm going to walk through just a couple of quick use cases for how you can actually use brownie to quickly get up and running using a simple erc20 token so within brownie there is a bunch of pre-built brownie mixes and these are some templates that people have created and published to github that allow you to just quickly import a project into brownie and i'm going to use the example of a viper token which is going to just clone the repository and create a viper token just like that for us to work with and we'll pop into here and i'll take a look and walk through what this uh default token looks like and it's still on version 2.0 uh but this should still work fine if you bump it up to version three or higher uh which is where brownie is now i'm sorry viper is now and walking through the uh walking through the syntax here you can see that the entirety of this is actually legitimate python so this would uh be pythonic itself in terms of all the syntax uh with these first 20 40-some lines there is all this uh through line 31 is all the contract level state variables so we're able to include everything we need from the erc20 token in terms of a single hash map of balances and allowances and that gives us everything we need to be erc20 compliant line 11 here is the check for that line 14 through 22 we're defining the events that we're using to log and emit our constructor function uses the underscore underscore init function and everything else most of it is actually the docs strings because viper one of the nice things is the compiler is also very strict about making sure that the docs strings are properly formatted and as a result most of the code here is actually just the level of documentation provided but we see it all the balance of allowance approved all the classic erc20 functions are included here within viper you have to have your internal functions preceding when they're called so in this case uh the transfer function is utilizing this which simply does a assert to check if the balances are viable and then it makes a transfer transfer from works about the same first it checks the allowances then it updates the allowances with the using subtract equal value and then we return true so included within this repository is also a variety of tests so you can see within the pi test framework you always have a conf test which is going to be the fixtures in this case there's only the one to create a token and deploy it and then loading through the tests we'll take a look at for example test approvals all the tests are written out here i'm going to run the tests on this side so we can see what it looks like and we have 38 tests in total the tests all they've compiled you can see them running they're going to be fine here because we don't have any particular issues with this i'll walk through what it looks like in some of the debugging tools inherent in brownie uh so we can see what it looks like when the tests fail but as expected the sort of simple viper contract we have is everything that we need and if you want to also you could fire up a console either by running brownie console or you can uh run some scripts and pop into the console that way so coming with this is a script that just deploys a token to the console so if i run this script and then i run this in interactive mode it's going to drop me on the console when i'm done with it so i'll run the token script it's going to deploy a token for me this is the most recent token deployed here and now i can use this console to do any amount of interaction with this that i'd like so it comes built in with uh in addition to all the functions it has a few different kind of properties built into brownie to access these contracts so for example i could transfer let's send account one half my balance and this is going to default to accounts 0 unless i pass a specific object but now i have a full full transaction which i could use to query a bit more information so that's been added to the history object here so i could look at history minus 1 and check the gas used on it for example or i could get more information about the transaction which is going to give me the hash the from two addresses and all the events contained within it and there's also the capability of running a trace on it which is quite nice so this was a very simple uh transfer you can see it called transfer and then it called the internal transfer function and it gives some of the gas usage so so the gas the transfer function just used 315 gas and then the internal function uses the bulk of it plus uh 2021 644 for gas so where this is useful is when of course not when the tests go well but when the tests fail so let's change one of these tests to fail and see what happens so let me look at tests let's do a test transfer and let's go down to let me do transfer from actually and i'm going to change actually instead the test let me change the contract itself and we're going to change this um say we made a bug in this and instead of transferring money we transferred a thousand times the money we're going to run our tests again and but this time we're going to run them in what's called interactive mode and when you run an interactive mode it's going to give you if the test fails it's going to drop you onto the console that we just saw but it's going to drop you in the console at the place where the test failed so in this case this was a revert because of an insufficient balance and when you're here you have access to anything within this test so if we look at the tests specifically we're on test transfer uh the first test here and it failed so we have uh for example token and accounts and amount are all available to us we can see what the amount was we can see what the token is we can try to transfer ourselves if we want or you can look at the most recent transaction that was attempted kept in the history log the final element and you could run a full trace back which gives you a pythonic style error message telling you exactly where in the contract it was so you can say okay this was it line 105 on token transfer sure enough the line that i was uh i was fussing with right here it's saying that this is throwing an insufficient balance so of course this is a pretty easy uh easy test to figure out what went wrong here but it when you're dealing with many much more complicated testing the capability of being able to bounce into the specific line that you failed on sort of like a break point and work with it is fantastic so uh this is like some background on brownie which is a fantastic tool but for people who are new to this i would actually recommend um well one last thing to point out is there are some more advanced features built into brownies such as the capability of seeing a full coverage audit so this is actually just going through the code showing the op codes on the side but also showing the graphical view of how well my code has been tested so i can guarantee i get 100 test coverage um there's also like a gas profiler built in so you can pass the gas flag and see what the gas usage of all these functions were so uh brownie's great and it's an incredibly robust tool but that being said if you're new i would actually recommend that you instead of starting with brownie you go with the next evolution up which is a framework and here we see the the gas profile come out here and this is just giving the average low and high amounts of gas used for all the function calls which is useful for seeing which functions are using gas anyway ape frameworks is you can think of it as the successor to brownie uh so brownie is great but the it's not really building out in the way that ape frameworks is a ape works is a clone of brownie so you can think of it as a foundry is to dap tools as ape works is to brownie so ape works is rewriting brownie all the functionality they just showed off also exists in ape works but they have a much bigger plans for going forward and they also have a bunch of great educational tutorials you can walk through so their ape works academy has the capability of cloning a erc20 token and deploying it in the rc721 nft they have more that's coming and a great community so highly recommend you check out ape works i'm not going to go into too much depth on ape works because it's largely very similar to what we just showed off the brownie but i will show off the kind of equivalent of how you would create an erc20 token and the very friendly way in which they do it so we're uses this templating system within a frameworks and this is going to create a erc20 token it's going to ask for it's going to ask for a few different uh initializations so i could say eath token we'll call it eth token eth token 18 decimals we'll add a pre-mint pre-mint amount it's ownable i'll have a minter roll it's mintable burnable permitable and just like that it's created this uh eat token repository for me right here with everything already filled out for me so even friendlier than brownie as you can see in terms of the uh the user interface and actually building this out and it's um much more recent vipre version which is nice 3.3 i'm running a bit shorter on time so if i want to go through the kind of more newest tool which is titanic boa titanoboa is this natural execution layer for viper language code and titanoboa is in my opinion sort of mind-blowing it allows you to execute raw viper code directly within python so this is incredibly useful for things like being able to create jupyter notebooks and within it actually like interact directly with um live smart contracts and pull the stats natively into all the advanced mathematical libraries that you can utilize using python such as you could use sklearn on this you could use pandas data frames so some of the things that you can do using titanoboa you can do storage enumeration and what we can see by this uh the example which i'd walk through if we had more time is you're actually able to read through all the storage variables of a contract including uh mappings so if you want to see like uh mappings are not generally readable as key very value pairs so if you have a mapping you can't easily enumerate it within the smart contract but you can using titanoboa just rip through all the storage enumerations so you can trace and enumerate the storage with this syntax here in this case we're loading a contract minting three times and then checking the three balances and looping through them very recently they added the capability of doing mainnet forking so just beware as you're doing this this is caching the rpc results using level db so subsequent state fetches the state are very very fast and this is very useful for running uh simulations against the actual mainnet state so this is where you can take live code and run it through your jupyter notebook and come up with very nice uh beautiful graphs so here we see a test function being ran through ipython deploying it and this on this um connected to a local mainnet fork is able to pull live data from the blockchain uh gas profiling is another really useful one i showed how you could get the function level uh gas usage using brownie or ape but if you want to get line by line gas usage you can enable gas profiling and walk through on every single line uh the gas usage of every single statement so this has been uh i i feel really bad about this because i basically had to write something very similar uh mostly by like trial and error when i was trying to build out a recent contract and then after i did that and launched and shipped my contract this got released and this would have saved me so many hours of being able to kind of figure out the specific lines where there's issues also i can do up code patching so this is the capability of patching arbitrary opcode implementations directly into the virtual machine in case you need to run some finely grained tests so this here is an example of using s-store which is tracing all the touch storage slots by address anyone who is familiar with um foundry will be familiar with uh user-defined cheats and this is now available using titanoboa as user-definable pre-compiles in this case um you can see it registering it and executing this raw call as it is touching this right here so this is a simple example printing the sender uh to standard out but anything that you can do in python you can now do here so you could uh you tracing you could do http requests this kind of opens up the full power of python to uh this here um you can execute arbitrary code so you don't even need to spin up a contract like in the previous examples we were writing a contract deploying it and testing it but there's also a boa eval function where you can evaluate raw lines of viper code and get the result directly to standard out and for debugging revert reasons so in this case this is uh there's two types of revert reasons you can get the revert reasons here this is a general mechanism to filter on the physical revert strings uh so this could be brownie net spec oxygen style reverse strings or even compiler generated checks and here's an example of the compiler revert reasons so if the compiler is throwing an error you can actually load this in and see what the error that's being called is so titanoboa is becoming a very very robust and powerful tool for all of your smart contract uh needs the team behind vypro is big ambitions um big tech sucks on twitter is one of the founding team members of viper he is very ambitious plans to get viper to the best user experience and developer experience for smart contract languages uh safest and most performant language for evm programming and highest use smart contract language for new projects within the next six months to one year so if you're interested please do join us feel free to reach out to me i write a daily blog on defy stuff except weekends on curve.substack.com you used to be able to find me on twitter but because i've been supporting the free alex movement i'm no longer findable on twitter so find me on lens instead or if you're old school you can find me on linkedin and finally if you'd like to join the viper community the best place is the discord where the team hangs out all the time and returns in almost real time uh feature requests so it's a fantastic place to be and they're incredibly proactive and get some help so if you follow this qr code we'll see you in the discord thank you very much here that was uh absolutely amazing thank you so much for going into so many deep dives and uh telling us about all these tools uh even i didn't know about the last one so that was that was great and learning for me too um we had two questions one of them was actually answered by another member but i'll just ask it because we're also recording it which is uh when you were doing the the testing um was there a way to verify the contract once deployed with the same way in brownie or or is that only for testing in that part looks like the answer is you can verify it but uh when i maybe add any other colors to that uh please do no i think the they nailed it right on the head it's 100 you can do that using brownie uh it's also like uh brownie works i should have mentioned that it works just as well for um if you wanna work in a developer local chain if you wanna work on a mainnet fork or if you wanna go directly on mainnet so i actually do most of my smart contract interaction directly on brownie on the mainnet just because it's like easier for me to query and see what's going on under the hood there awesome and the other one was uh people wanted to know what is your terminal setup and what a terminal app do you use [Laughter] so as you see i'm fairly old school um like i um do everything i don't ever use like any ide or anything i just do everything directly within vim uh and then i i am basically using brownie and python for everything so yeah i don't i'm i'm boring okay well thank you so much and uh i really appreciate taking the time today my pleasure thank you it was garrett talking about viper and how you can get started with building more secure defy apps and also simplifier testing speaking of the last question which was around verifying code uh this is a very timely question and a talk i want to bring on khan who's going to be talking about sourcify simplifying a lot of your needs on making sure your contracts are safe and easy to read and verified so without further ado please welcome yeah thank you kartik hello everyone um as kartik mentioned um i will be talking about sourcify and source by verification we at sourcify also are doing source code verification but more in an open and decentralized way but we are actually more than that we are also actually an initiative for more human friendly contract interactions and that's now i'll talk about how we can do this so i'll start with just a normal day in webtree just an example that you have probably all we've seen if you have been in webtree space for a while and it's this so it's a daily thing now um although this has improved slightly that we every day we encounter interactions with contracts that we have no idea so when you see this this is like what is happening what am i doing am i talking to the right contract am i doing the right thing and at the end of the day this basically is the same thing as telling the contract just shut up and take my money i have no idea what i'm doing and the good thing is we can change this so it is a difficult task it's a difficult thing but uh that's what we are striving for but as i said a typical web pre-interaction nowadays is still a yolo signing nightmare what we like to call this interaction signing on the wallet and just hoping for the best and at the end of the day what we want to achieve is something on the right instead of something on the left i know these have changed recently in most of the wallets but still we don't have really comprehensive messages that regular users or even the developers can understand easily so let's dive into what you can do to achieve this there are two sides of the equation there are things that you can do as a smart contract developer and as a wallet developer so let's dive into what you can do as a smart contract developer it kind of just a quick interruption if you're sharing your screen we are not able to see it so you might want to oh one more time thank you there we go it works right yes perfect oh okay so these are not seen i guess anyway so um let's dive into what you can do as a smart contract developer first thing you can do is to use the nat spec documentation so the nat spec documentation is part of the solidity specification is part of solidity documentation and it is a rich documentation for functions between variables uh and it's a special special form called ethereum natural language specification so it looks like this it is similar to jstoc if you are familiar with the jstoc and you can find the that spec on in your contract it's uh mostly in the on top of the functions uh it has it has a dev field which is for the developer uh documentation which then we have notice fields for the user documentation then we have the documentation for the parameters and the nice thing about nat spec is that it supports dynamic expressions what does it mean it means that the fields you can see here for instance the old owner and new owner of this user documentation can become this so when you are showing the users the user documentation you can fill these arrivals dynamically and instead show the values to the user and even better you can show something more human readable to the users if you have for example a reverse ens name okay so we know what's user doc and dev dock is but where can we find it where can we leverage find and leverage these fields um these fields are in the solidity contract metadata um i'm not sure i probably probably most of you are not familiar with the contract metadata it is actually introduced in 2016 with the earlier versions of the solidity but it was actually not picked up by the community so it is a json file generated by the solidity compiler which contains metadata as the name suggests um but it consists of four main fields firstly api then user doc dev dock as we have seen in the previous slides then we also have the compilation information and the information about source files so the first two fields are concerned with how to interact with this contract the metadata's contract of the metadata and the second two field the the next two fields are concerned with how to reproduce a contract compilation and the file looks like this it is a json file as i told you and it is let me show it i'm sorry i can just write this yeah oh there we go so um it is a file like this and in the output fields you have the api dev dock and user dock and you can see the nut spec fields are embedded here for example the one we talked about the nut spec comment we talked about is here replaces the owner old owner with the safe in safe with the new owner and the other information here are as usual the compiler settings the evm version the optimizer settings source information and the source information also contains the content of the source file although not always and the hash of the source file okay now we know where to find the dev dock and user dock but where's the metadata where can we find the metadata if i can find this file and if you use the solidity compiler it's obtainable with the metadata flag so if you pass the metadata flag to the compiler on a terminal and the contract you will get the metadata file it is also available on frameworks um if you're using truffle uh after you compile files you can access metadata so you can access the compiler artifacts actually and in the artifacts you can find the metadata in the json fields if you are using hardhat it is also in the artifacts and since hardhat version028 you can find the metadata of each contract in the large build file and is also embedded somewhere and within the contract bytecode but not the metadata itself but the ipfs hash of the metadata file is appended to the bytecode of the contract when compiled so the solidity compiler by default actually embeds this information along several inform several other information at the end of your bytecode and this is also deployed to the blockchain um you can turn this off but by default actually this additional field is appended at the end of the bytecode alongside the functional part of the code that corresponds to the contract we have written and this ipfs hash of the metadata file acts as a somehow as a compilation print or a digest of the whole compilation that you have done [Music] and [Music] if you publish this metadata files that means you can access it through its bytecode so as we said this is an ipfs hash of the metadata file so if you get the contract bytecode and decode this ipfs hash then it's available on ipfs if it's published or pinned by the author of the contract um there's actually a nice tool to see this in action uh that we call playgrounds in here we can you can go to um you can fetch your contracts and i'll we also have some example contracts here let's have a look at this for instance if if we want to see the code bytecode and the metadata of the ethereum deposit contract it will fetch the bytecode of the contract then we'll decode this part the highlighted parts which corresponds to the fields that we talked about and then we if we decode this we see there is ipvs hash and the solidity version of the contract and here using this this hash the metadata files actually fetch from the ipfs and we can see the metadata file here okay um so we used an aspect documentation and the second thing we can do is the source code verification on source file so before diving into more maybe let's let's have a look at what source code verification is i'm pretty sure everyone has seen this green check mark if you are interacting with a contract or looking at the source code of a contract and you see this and you're happy because then you know everything's verified everything's checked marked and this is what you see in the easter scan um when you are looking for the source code of a contract um but how do we know that actually a random code on github is not is is is this actually corresponds how does it correspond to the code of this contract on blockchain so if i give you this code for example how do you make sure if this is actually the code corresponding to the contract on blockchain and not just a random contract so this is how it works so we have the solidity files which are our source code then we also have the compilation settings this is when you are compiling your contracts this is just a default thing and what we do is we take the source code files then we take the compilation settings and we feed these into the compiler and we recompile everything this is actually when the second part of the metadata file comes in handy because this part gives us the information about how to reproduce a contract compilation and if we have this in hand then now we can make use of this and see if we can reproduce the whole contract compilation so we get the source code files if you are verifying a contract you you give us source code files you give us the settings you have then we recompile everything then the compiler outputs the byte code of the contract the the code that the machines understand not not the human readable source code but the bytecode that is deployed on blockchain and then we also have the contract that we want to verify for instance if we have this contract at this address then we get the code of this contract from the blockchain then we see if these codes match so if these match then it means the source code you provided in these in these slides and these settings are actually matching the contract on the blockchain and in sourcify we actually have two types of matches one is the partial match when the byte codes match and the second one is the perfect match as we call this is when the bytecode plus the metadata match and if you recall uh the highlighted fields at the end of the contract by code uh this corresponds to these fields so when the black fields on the match that would be a partial match but for a perfect match you need the byte codes to match as well as the metadata match and if you recall the metadata acts as a compilation fingerprint that means if we have the metadata fields matching as well the compilation as whole is exactly the same as the original contract and yes this crystal this will cryptographically guarantee the whole compilation is exactly the same as the original contract so even the solidity files are exactly the same even the commands variable names even the white spaces are the same and how does it work so let's let's see in the case when something matches so we again have the source code files then these files are hashed by the solidity compiler the compiler hashes it actually when you are compiling the contract then the hashes of these files are embedded in your metadata so when we looked at the metadata file we saw that the hash of the source files are also included so the hash is embedded in the fields of this source file and as well as the other files then the hash the ipfs hash of this whole file is taken metadata file and then the ipfs hash is embedded and encoded at the end of the contract bytecode as we have seen before then we see if the one on the left the one we recompiled is actually matching the one from the blockchain and if it's matching it's a full match it's a perfect match as we call now let's see what happens when you make a change when you add a comment change your variable name anything so again we have the source code files but this time a different source code file with a slight difference and that causes these source files hash to change then the hash in the metadata file will change and consequently the hash of the metadata file will change now we have a different hash and this different hash will be embedded at there will be appended at the end of the bytecode so the last field will also change and this time you will be having only a partial match not a perfect match but excluding the last part of the contract bytecode this will give us a partial match okay then now we know how what source code verification is and how can you verify contracts one way to do this is to use the source file ui we have a ui for you to verify contracts you can here provide us with the metadata file as well as the source code files and give the contracts address and the chain then we can recompile the whole thing and see if it's a match and we have several chains i think at the moment close to 30 different evm chains that we support and where a contract verification is possible we also have an api where you can provide the same information through an api programmatically and we also have the documentation where you can see how to make use of the api uh we also have extra tooling for example with the hardheads we have the uh hard deploy plugin that you can easily verify your contracts after deploying so if you have deployed a contract on mainnet you can pass artheads network mainnet sourcify and this will verify the deployed contract on source file we also have a remix plugin if you deploy your contracts over remix you can easily pass the contract address and contract chain and the plugin will verify the deployed contracts we recently also have the foundry support so using foundry now you can also verify the contracts by passing the verifier flag and sourcify and this will also verify your deployed contracts on foundry we also have a nice feature called automatic verification also as monitoring so this as the name suggests automatically verify the contracts that are deployed on the blockchain so i'll do a short demo about this so here on remix i have a simple contract called storage soul and this contract itself as well as its metadata is already on ipfs so i'm going to deploy this contract on the gurley test network and then we will see how the automatic verification actually works in action so we are waiting for our transaction to be mined right so our contract is deployed so i'm going to sourcify and i'm going to check the contract if it's verified on source by it is currently not um so this makes use of the ipfs hash that is deployed and it listens to the blockchain for new contracts on the blockchain if it finds a new contract then it will check the metadata at the end of the contract then tries to pull every information all the source files and everything then it will do every compilation itself so this should actually work in seconds so yeah as we can see the source pipe monitor has captured this contract creation and automatically verified the contract because the metadata file was already published on ipfs and the source file was already there on ipvs yeah currently this is only done for the ethereum mainnet and the test nets and yeah this automatically verified verifies the files so that means actually uh the second step was the source code verification on sourcify then it actually becomes publishing metadata and source files on ipfs so you don't even have to go to sourcify and verify the contracts the only thing you have to do is publish your source file as well as the metadata in a reasonable amount of time so it has to be done when contracts are deployed we have a buffer i guess around five to ten minutes so you have to publish that uh five or ten minutes after the deployment or even before maybe and this is only done on the ethereum and testnets um so we also have the contract repository uh which is both served over the http and ipfs so every file that we verify we serve also on the ipfs for the later uh for later fetching and it is under an ips name with a dns link under repo sourcified dev and it's updated every six hours currently so you can also see it here right now i'm showing the repo that staging source by dev because the main server has just got an update but it will be also available in a couple of hours so you can also here download the whole repo or explore the repo how the contracts are structured so we have the contracts we have the full match then we also have the contracts sorted by chain id but i guess um this is taking some time to load yeah ipfs is not always the fastest network unfortunately but most of the time if you want to search with an ipfs hash that worked pretty well okay so these were the things that you can do as a smart contract developer now there is the other side of the coin what can you do as a wallet developer for your users um so again remember the first two fields of the metadata file and they were concerning how to interact with the contract so these are api user doc and dev doc and as a wallet developer what you want to do when your users are talking to a contract you want to decode the contract call which is in byte code and show your users meaningful message so what you want to do is get the user doc and decode avi on contract interactions and for that remember what you need is the metadata file because the metadata file contains the api as well as the user documentation so what do you do you fetch the metadata from sourcify's repo right no please don't do that because actually the information you need is already there so you don't even need us need sourcify to do that you already have the ipfs hash of the metadata file on the contract by code so what you do what you should do actually is to get the contract by code fetch the metadata with ipfs size because remember at and in this field you can get the ipfs hash of the metadata file then fetch it over ipfs then you have the api and user documentation then you can show the users uh more human-friendly messages so using this information of a verified contract you can actually show something on the right instead of something on the left um so our way of human friendliness so to say is just one way so we make use of uh human readable descriptions with not spec comments in the metadata but there are more ways to do that to achieve this for instance there is the eip 4430 and eip 3324 which where the idea is to have a describer function inside the contract which upon when when they are called it returns a human readable description and then runs the function that is called so the advantage is that it can decode things like an ens commit but this also means you have to have extra data in your contract that is deployed there is also a recent eip draft by dan finley there the idea is to give the user the information about the contract on the first point of contact so when you for instance visit uniswap.org then you will receive you will receive the api and the method describers from websites then this will be saved on your wallet and the nice thing about this is it's backwards compatible and it's flexible but it's not bound to the contract itself um yeah but also apart from being a human friendly there are many more ways for a better ux so you can do you can decode the contract calls you can warn the user if they never interact with the address you can say if the contract is verified block if the known scam address if there is a large amount or if there are large fees with the amount additionally you can show the users how many times this contract was interacted with because a quote-unquote safe contract will have more users and a scammer would maybe have a less use less less interactions and when was this contract deployed an older contract is probably more legit and as well as if this contract is audited uh or and if it's or and by whom it supported it so there are a lot of things actually we can do and we can do better so let's have a recap what is sourcify technically we are an open source automatic smart contract verification service we have a user interface an api and tooling to verify contracts we also have a publicly centralized content address storage of verified contracts for everyone to access and more generally we are an initiative we act as a base layer and public good for other tools to build on top of an initiative to foster the use of the contract metadata nut spec and full verification and we are also an ongoing effort to improve smart contracts ux safety and transparency so thank you very much for listening and i would be happy to answer questions if you have any thank you so much um i'm looking at the q a i don't think we have any that are specific to this but people want to be able to kind of see the slide decks if we're able to also share that with us uh we'd love to uh make uh i'll just uh there you go um there you go so uh i'll be able to kind of relay that to to the audience and also we'll be able to put the links up but this was really good source of is getting better and better we've seen this happen uh the stock uh talking about every kind of few months to in the past year and uh massive improvements and that's awesome so thank you so much and with that we are a little bit behind but also we're ready for our next talk and uh i want to thank you so much count for talking about sourcify and without further ado like to welcome ari to talk about everything that's happening in the solidity ecosystem so welcome back after our last year's devtools summit and uh excited to have everybody also learn about all the things that are going on in solidity uh am i audible yes you are perfect i'll let you take over from here and we can see this uh looks like uh you are now on mute i'll just uh ask you to check for that setting one more time yeah i know what there we go okay perfect is that better yes yeah i would like to start the talk with a question to the audience um it usually works better when there's a live audience and when people can shout the answers but i'm still trying it here so the question is simply like what is the most requested solidity feature since the last two years uh you can just like type your answer in the chat or wherever you want i'm gonna look have a look at it later and we're also going to talk about it in the second part of the talk until then let's forget about it and talk about the next thing which is a very simple way to do something in solidity so typically um so you have an interface here it is a erc20 interface that only has a single function transfer because that's all you want in this case uh you want to like encode um a call so how do you do this usually so since the beginning of solidity we had this feature called avi dot encode with signature uh and this like this is very useful for like doing this thing the syntax is a very simple api encode with signature and then the signature of the contract and this has been around for since the beginning of solidity perhaps but this is bad in many phase many ways and why is it bad it's actually not typo safe what does that mean so here is the same thing but with like two typos one is a space after the coma and the other one is you wind instead of you win 256 you can see um 256 here and this actually leads to a different encoding of the call data and this is really bad and moreover uh imagine if you actually change something here maybe the function um maybe the types it doesn't really get reflected over here so this is like a feature with a lot of foot guns and we have to really rethink if you should really do this um it turns out there is a better way to do it so let's look at avi dot encode with selector so it's pretty much similar to the last one uh except that you use abi to encode with selector and you have to make a reference to a function so in this case it's minimal erc20.transfer.selector which would like automatically put um the four bytes of the selector here and then you can encode with the two end value which is the parameters so even this is not very good and why is that it's actually not type safe the problem here is that okay imagine if you actually use a uin parameter instead of an address in in the api or encode with selector it actually compiles and it will give you uh probably a different answer depending on what the value of two is so this is also bad we shouldn't do this um is there a better solution that actually fixes both these issues yes there is and that is the abi or encode call so this is both typo safe as well as type safe um so how does it work it pretty much works exactly like the last two ones except the name api or encode call and then a reference to the function here it would be like minimal erc20 or transfer and then the parameters um in as a tuple so if you make a typo here the compiler would complain complain and if there is a different type um instead of two let's say you win the compiler would complain so you don't have to worry about like shooting yourself in the food so as i said before it's time safe and typo safe you can avoid a lot of foot guns it's available since zero eight one one um and in retrospect you know we have to even you know these two features we have to even think if we should even put this in the language anymore we have to probably deprecate it um at this point and it's already in use currently here you can see alex's contract which is doing like a deploy of um you can also save closest saves on chain and he's already using aviator encode call and you can use it too okay let me go back perfect um so what can we do next after we have abia or encode error um so as you might already know like in the last year or so writing tests and solidity has become incredibly popular because of like daphub and now foundry and this pattern comes up quite often which is foundry has this idea of expected word which is you want to make a external call and you expect the call to reward with some bytes as you might already be using i mean as you might already know by now so already has this idea called customers which allows you to have properly encoded error errors instead of just strings uh it's more gas efficient uh in most cases and also just more elegant so what you can do um to test this would be something like vm.exe reward and then just put put what whatever data you are expecting to report and this is an example from opencs new contract c port um so if you look at how they are doing uh it right now it's abr encode encoded selector with the signature of the error and then the parameters so recall that errors and functions are encoded identically so you can actually reuse a lot of things that are done for functions also for errors um but we can actually do better here you can actually introduce something like abi or encode error with similar semantics to api or encode call we don't have this implemented right now but there is an issue and there is somebody working on implementing it so you can very likely expect it to land on the compiler soon so this is how the same code would look like which is again type safe and typo safe and just more elegant [Music] yeah so now let's go back to the question from the beginning of my talk which was um what is the most requested solidity feature perhaps for the last two years and even more um um and you can look at the results and a lot of developers have made in the survey and there is one thing that really stands out which is fixed point arithmetic and that is indeed the most requested feature um for solidity since ages so before we talk about like what's happening i want to like i want to make an introduction to like fixed point arithmetic what is e1 fixed point arithmetic um effectively you can't think about it as working with fractions or floating by numbers although the use of floating point number is a bit of a misnomer but you get the idea so typically you start with a base we call it b and this is going to be for example 10 raised to 18. 18 is typic 18 is a good typical number because um e has 18 decimals um one either is 10 raised to 8 in v so you represent a number p by i mean in real terms p by b by storing it as p um so as an example if you have one way which is actually the fraction 1 by 10 to the power of 18 either you store it as one instead of like points or uh as one so the number of points first row like 18 times or 17 times then one would be represented as one um in the evm and the way to interpret this would be by thinking about it as like 18 decimals so you are already implicitly using this if you are interacting with a erc20 token for example they have this innate idea of decimals for example uh in usdc it is six in diets 18 and you don't really you just like add them like any other numbers and that's my next point which is addition and subtraction requires no change you just add you just subtract it's exactly the same but the next things the next thing is more interesting multiplication and division they are entirely different now so if you want to multiply two numbers p and q that are you know in stored values uh i want to make this distinction of like stored value and like the actual value like the actual value would be p by b and the store value would be p remember so p times q in this case would be equivalent to p times q by b um i mean you can like try to work your way to like this calculation but this is how it works and similarly for division if p and q are stored values uh the actual stored value for p by q would be p times b by q so this is fixed point 101. um now let's talk about some like history of exponent arithmetic and why why uh doesn't solidity already support it so solidity has the type you fixed and fixed for a very long time and also in the api so ufx stands for unsigned fix one arithmetic fixed point type and fixed sign for uh designed just like you went and end and what do i mean by it's in the api i will talk about it later later but just remember that it's in the api already but these types are actually unimplemented and therefore useless if you actually try to do anything with it you would try to get you would get a compiler error if you actually end up using this somehow but many of the programs you can compile but without being able to do anything with it um yeah so going back to the question why why don't we have it um we were pretty close to like merging a lot of things into the language but in the last minute we decided no um and one reason is because it's such a contentious issue there are multiple different implementations uh and there is no consensus in the community on like how this should look like to give an example there are multiple ways to implement fixed point types uh one is you can ask the question should it be decimals or should it be binary and how many decimal points 18 20 24 or 6. um and there is this third point which is very interesting um it's i i would like to call it the the shadow overflow or some people call it the phantom overflow so remember that this is the most basic calculation p times q by b um so p and q are p q and b are 256 bit numbers but the multiplication p times q may not fit inside 256 bits but there can be cases for p times q by b e such 256 bit number but p times q is not and how do we handle the situation like should we reward should we actually do the computation there are people who say that we should reward there are people who say we shouldn't reward and actually do the computation um in a painful manner and this also like brings the question of like chaos efficiency like if you are doing um rewarding early would be easy but whereas actually handling the shadow overflow is much harder so let's now look at how many protocols implement fixed point arithmetic one of the most famous example would be perhaps the vad math uh introduced by maker as far as i know it is actually decimal it uses 18 decimals in fact and it reverts in the case of shadow overflow which is you know if p times q is um it doesn't fit in 256 bits then it's it's going to overflow and it's very it's relatively gas efficient because the computations are very simple a modern implementation of this can be found unlike solvemate so you can see the reward happening here for example so let's go back perfect um yeah so to summarize it's 18 decimals it's decimal not binary it's relatively gas efficient and it doesn't care about shadow overflow it will revert early and the next example is in unicef v2 which actually uses a binary um fixed point type with uh it's actually 112 bits now 122. it's a typo um and it actually uses shifts instead of division where uh shifts are actually cheaper in the evm than uh division shifts are three years and division is five gas so there's a very minor efficiency improvement here and it actually doesn't care about shadow overflow at all like it turns out that this overflow case would never happen and they ignore it and it's very gas efficient because first of all you use shifts and second of all they don't care about this intermediate overflow now going back to unisa v3 this is where things actually get very interesting as far as i know they use binary fixed point but they use something called the full math and the full mat is a very very interesting function originally implemented by remco so you can see this like very interesting piece of code with a really complicated uh mat um what they're doing here is um what they're doing here is trying to get rid of this shadow overflow so in the case where p times key p times q overflows but the value p times q by b is well defined unisa v3 or the implementation by remco still manages to compute the actual number and this is very impressive but unfortunately there are a lot more checks and there are more complicated arithmetic operations uh involved in this computation and that means there is more gas um so we saw like three different implementations the vodmat the units are v2 binary units of v3 fixed point i mean you're going to use a v3 with binary and the full math so the question you ask is which one do you implement uh the units of v3 is perhaps um the most canonical implementation but unfortunately it is more expensive than the other simpler ones so can we find a better solution um than this probably we can um so remember that the key computation here is sorry the key computation here is p times q by b [Music] and if we can compute this value in full precision we can actually do the um unisa v3 full math implementation um cheaply and we have this proposal for a new op code in the evm which is called maldive which actually does this computation so it's going to perform p times q by b in 512 bit arithmetic but in the end it truncates it to 256 bits so where do we go from here so first of all um it's not clear to us if fixed points as a type should be belong to the language but we want to have like very good support for fixed point arithmetic in the language um and one way to do that is by allowing users to build their own types and operations on the type and the first step towards this is already there which is user defined value types so you can try to implement your own type in this case it's fixed 18. it's exactly like you win 256 and more importantly there is no change in the api so the api is going to be exactly the same as as if you use uin 246 but it's more type safe i mentioned before you know i will talk about abr issues about you fixed so the type you fixed actually exists in the api but this wouldn't have the same selector as the real transfer functions so this means that the new ufx which is already present that you api it it doesn't have any backwards compatibility so if you want to try to interface with let's say die or ussc um die would have 18 decimals usdc would have six xmls this function wouldn't even be calling the right one whereas if you use fixed 18 it actually has exact abi compatibility so this is the very first step towards you know fixed point types in the language uh and the second type is to implement maldives in the evm which is probably gonna take another like hard fork in the in the evm um and the third step is going to be implementing operators for fixed point types um this can be done in whichever order we want so just to give an idea of like how operators would look like so here is how the checked multiplication and fixed point numbers would look like if you have moldov and evm so i didn't mention this but there is a very ex there is an exceptional case in the maldive which is around zero so the eip currently proposes a um a special case for moles of a b 0 where the 0 would be treated like 2 or a 256 and the goal would be that this is going to help with checked fixed point multiplication um and this is an example of how it would look like um here you're using like fixed point eight user defined fixed point 18 and perhaps a syntax like this using check mall as star for fixed 18 and then you are user-defined fixed multiplication can be used anywhere in the language so what can you do now so the maldive eip is still um it's a relatively new proposal we want to get as much feedback as possible for the eip feel free to like talk to us um we want especially to get feedback about the exceptional behavior around the value zero so that is a b 0 is treated in a special case um there are ways to get around it uh if you don't really you can treat ab0 as zero but then there is like more gas to actually um deal with this um truncation detecting the truncation case um the third thing is of course we want to see if there are other uses for maldive especially for implementing cryptographic operations perhaps you want to implement evm inside evm then you might need to calculate for example uh mod mulmod modex things like that would that do you see a use case for maldives in any of these other applications let us know um and of course we would like to get your feedback on the syntax for user defined operators um so i mentioned how the using statement is currently being i mean this is not currently implemented but this is the current proposal um so we would like to get feedback on how this looks and how this implementation feels to you and lastly you can find more notes about fixed point arithmetic and this hackmd i will be linking i will be linking oh here is the link to my uh talk and that's it amazing um hey i'm not kartik i'm jacob just kind of jumping in um i just got to work on some stuff behind the scenes um awesome talk if anybody has any questions feel free to drop them in the channel um and i will service them over to to harry i guess i had a i had a quick question it's it's sort of i guess related a little bit to the topic like um i know just from my experience programming with uh floating point in different implementations in different languages um precision comes up a lot as a potential issue um and given that like with blockchains where you know writing contracts that are largely dealing with with money and that kind of thing i kind of curious like what your thoughts are about like being able to both come up with you know great specifications for floating point but then also like teach people on the risks of of uh of precision when it comes to to dealing with these primitives yeah that's a very good question i mean um so when dealing with decimals there are two approaches one is uh fixed point numbers the other one is floating point numbers um floating point numbers are incredibly popular um in like the usual computations because they are very fast implement uh most processors have some instructions to deal with them uh but the issue is that it can be a little bit counterintuitive to understand it and also this floating point errors um so if you look at um historically maybe like 20 30 years in the past um the equivalent of like the the equivalent of like maybe this 500 million smart contracts hack smart contract hacks would be rocket failures so a lot of these rocket failures um can be traced to bad floating point implementations or how people did not um or how the accuracy of some numerical computations uh um event i mean some numerical computation did not end up being accurate enough because of this repeated plotting point um errors and uh hopefully like the fixed point arithmetic makes this a little more apparent um so the issue with um the issue with floating point errors is that almost every floating point operation it has a error associated with it so if i go back if i go back addition and subtraction it has a small error in floating point implementation but in fixed point implementation there is none similar to similarly in multiplication and division there is an error term in division and evm there is another term but other other things like addition and subtraction multiplication there are there wouldn't be any errors um in in fixed point implementation so first of all the answer is we think fixed points are the way to do it but of course if you are introducing division there is going to be there are there is going to be errors and you would need to have some understanding of um rounding issues unfortunately yeah and then hopefully those don't trickle into to too many really bad outcomes at some point on the line awesome okay great well actually i think kartik is actually back from behind the scenes so i'm going to invite him back on stage and i will disappear and i'll let him wrap us up but uh thanks for the talk i really appreciate that and i've learned a lot about how the team is thinking about uh implementing these primitives uh i i was just away for a brief uh break but i did watch the rest of the talk so uh thank you so much arios was a greater review and i i feel like uh we gotta get you more here because uh oftentimes there's a big feedback with that we you know we get to close when we work with houses of devs uh trying to figure out how to do more interest into the solidity so uh this has been really helpful and uh and thanks for also uh linking to the slides because that's the most common question we get and how do they catch up on slides and we'll share that with everybody else perfect thank you really appreciate it so uh that was hari talking about all the stuff that's happening with solidity and up next is tom and i'm super excited for this talk because tom is going to talk about walk me this is a been a tool and an sdk that i've been using more and more personally to and i can't wait to uh have tom share about some of the internals and what's uh possibly next so without further ado let's walk to town hey everyone super excited um to be here and i'm not gonna talk about getting started with wag me um this is the first time i've probably talked about lag me and i'm like really excited to share uh how to get started maybe some more advanced um details and ways to use library and then talk about sort of what's coming up next on the roadmap um one second i just have some stuff on my screen trying to move the zoom stuff out here um okay uh so yeah i'm tom um i'm the author of wag me i'm currently a front engineer at mirror and you can find me on github and twitter at these handles what we're going to talk about today is maybe a quick overview of wagner for those aren't familiar walk through an example of how to get started quickly if you're working on the hackathon or side projects this will be helpful for you and then some pro tips and things that people aren't always super familiar with when they get started using magme but they'll help save you some money with rpc clients make it easier to develop daps and move quickly when you're building and then lastly we'll just go through a little sneak peek of a feature that i'm really excited about it should help everyone be more productive um so yeah if you're not familiar with wagmi it is a reactfix library for ethereum um takes a bunch of commonly used functions patches them up into hooks um so that way you can use them for a variety of different things i initially released this on january 4th of this year and since then it's grown quite a bit a bunch of projects have adopted it from like you know ens foundation sushi swap strip crypto a bunch of others and it's been cool to see lately some folks building developer tools on top of wagne so if you've seen rainbow kit connect kit or third webs sdks you know what those are all about wagner itself is great but what these folks have done is took the library and added their own twist and abstraction on top of it to make it really easy to connect the wallet deploy and interact smart contracts and similar things so you should definitely check those out if you're not familiar and yeah i mean it's grown a lot so um quite a few get upstairs and downloads per month now and hopefully we'll keep growing as we add more stuff that people are excited to use and here are some quick links if you want to check it out as i'm discussing or if you want to check it out later doc site we don't have a discord everything is mostly done asynchronously on the github repo so you can check it out there or follow us on twitter to get updates so yeah uh right now wagner has 25 plus hooks dealing with things like wallet connection um ens information interacting with contracts signing data and sending transactions so i just like highlighted a few here use connect is really great and quick way to connect wallets to your application use enf's name is really good for fetching ems name for an address we have this hook called use contract reads which behind the scenes does multi-call and which will save you a lot of money on your rpc requests and falls back to just regular reading if the chain that you're using doesn't support multi-call you sign message is useful for signing basic messages and personal sign but also if you're trying to do anything with scion with ethereum you should check that hook out and then another really cool hook is use weight for transaction which you can pass transaction hatch to it and it will update the status of the transaction goes from submitted state to the network as its mining and then as it's confirmed that way you can show some updates to your users and we'll talk about that one a little bit later but wagner isn't just about hooks it does actually quite a bit more um there's built-in wallet connectors for metamasks while ethernet coin baseball injected wallets these are the most popular covers most of the use cases people have there's been some community-led efforts for additional connectors like gnosis has worked on and has a separate npm package you can install for their connector and it's exciting to see people add more and more so that way if you have different use cases or on different wallets to be supported all you have to do is extend an interface and implement a few methods and you're good to go there's also quite a bit of caching and request enhancements that we released a few months ago this way like if you're you're not thrown into situations where you're spamming your rpc something like alchemy so you can keep your bills down um and make sure stuff is like pretty snappy and fast for users so if you fetch their enf name once and they come back and reload the page later they'll they'll automatically be there so you can use it we also do some things where we're able to automatically update data as wallets change as blocks are mined and as users switch around and use different networks in your application the other really cool thing that some people have been playing with lately is wagner has a vanilla js client um so mostly people interact with the react hooks but what you'll see in a moment as we go through the quick start is there's a vanilla js client you can use um which allows you to use wagne in instances where you aren't using react um if you're trying to use it outside of the react tree or if you want to use it with a different framework like spelt or view or something like that and another interesting thing um that you can check out in the repo is uh wagney has a pulled test suite running against ethereum which uses anvil behind the scenes to spin it up so if you're interested in testing your dapps wagney has a connector which will you can set up to use anvil or hardhat or something like that just to make sure that when you're deploying things everything out there um is working so move on to go through how to get started um with the wagon here so the first thing you want to do is install lag being ethers you can do this inside of an existing project or a new project when you're getting set up this example uses pn mp but you can use npm yarn or anything like that i've set the versions here explicitly so that way you know if you're trying to follow along later you make sure you're using the same version um wagmi hasn't hit 1.0 yet and there's been some api changes over time as we like move to get to 1.0 just so we can make sure the developer experience is getting better and better so if you're following along with this later just make sure you're watching what versions you're on so yeah once you install we'll just create a client this is the vanilla js client was talking about earlier the only option that you need to provide out of the box is the provider which is just an ethers js provider wagon is built on top of ethers and so by supplying a provider here you make sure the wagon client can connect to the network and the other thing that i've added here is auto connect true most people probably want to set this on what this does is allows whenever someone refreshes your app if they're connected with their wallet before the refresh or they come back later they'll make sure that the connection is restored so that way they don't have to sign back in when they reload the page so yeah you create your client and then you wrap your app in a context provider so you just import wagner config which react context provider pass the client there and then you're good to go you can just start using the hooks like i said before there's a bunch of them here's two of them as an example say we have a profile component and we run want to render out the connected wallet address and also optionally will fetch the ens email one address is defined so yeah it's pretty easy to get started and most people should be able to add this in to a new app right away and if you have an existing app something like web through react or used app it shouldn't be that hard to migrate over so here's some pro tips i wanted to walk through the first one is setting a chain aware provider so what this means is before you can see we just had a static provider added here get default providers and ethers method which has a whole bunch of rpc providers behind it and sets it up so it's automatically on mainnet and what you want to do is make sure your provider is initialized with a chain id and so the create client provider function has a chain id argument that then you can pass into your provider so that way like if you're connected to one chain let's say the net and then you switch to optimism the underlying provider which wagner uses to fetch and update data will then be on the right network so yeah in this example i'm using alchemy provider just passing it the chain id and now that's string aware and it's good to go and what this means is when you're using hooks here by default so i'm using this use contract rehook by default this will read on the chain that the wallet is connected to but you can also set it to read from a specific gene if you want so this is only going to be making requests for mainnet so it's set to chain id one the next pro tip here is for configuring chains so uh it ends up becoming if you have a multi-chain uh app it becomes uh unwieldy to in your provider uh function when you're creating your client to like make sure that you're using the right providers for certain chains um so like for example uh in this in this case for mainnet i'm trying to use alchemy for optimism i'm trying to use in pura and for optimism early i'm trying to use alchemy again and this is like a super contrived example but sometimes you do want to use different providers for different chains either an rpc provider doesn't support the chain that you're using right now or you want to use different a different rpc provider maybe a different api key for an rpc provider for like a test network or something like that so you could you know go about doing this in sort of the way that i have out here you probably clean it up a bit but instead of that we created this api called configure chains and what this allows you to do is specify a list of chains that you want to use ahead of time so in this case main net optimism optimism gurley and then a list of rpc providers that you want to use and what's great about this is a couple things one it spits out all the chains that you passed in a provider object and websocket provider what it actually does is it takes the rpc providers you've listed out and it creates them in like a fallback ethers provider so that way let's say alchemy goes down then it will fall back to the public rpc provider so this is really good because sometimes you know rbc providers go down inferior will go down and you can fall back to alchemy or vice versa and we'll set this all up for you all you have to do is put them in order that you want them to be used inside of the second argument of configure genes and then like i said instead of having like a provider a websocket provider function block where you're having to list out a whole bunch of different cases here you can just pass the results directly there and similarly you can take the chains that is spit out from configure chains and pass it to any connectors that you're trying to set up so in one go here i'm able to set up metamask set up my provider and websocket provider and all i do is call a function telling it how i want it to be set up that's configuring chance so another tip that touches a little bit on react and can help with performance in your application is using account callbacks it's usually count as a hook that shows um the current address the connector um and some other like flags on whether or not you're connected and something that a lot of people commonly do is if they want to check to see whether someone's logged in or logged out of their wallets connected or disconnected and how that state changes they'll just use a effect from react and they'll manage all this on their own um which if these these can start piling up you could have like you know a bunch of these in your app if you're trying to constantly inspect whether someone's connected or not but what you can actually do instead is use account has these built in to them so there's on account and on disconnect and whenever these fire off whenever these change you'll be able to use use that data instead of having to manually track this on your own so that's pretty useful one to get started with um the last pro tip that i wanted to go over is the transaction life cycle so likely if you're doing something in your app once you've connected your wallet you might want to be sending off transactions to the ethereum network and so this sort of follows three steps the first is preparing your transaction what this allows you to do is set up the request you're going to be making um maybe you know you have some arguments that you want to have set up you have like a minting site or something and what this allows you to do is once the user hits like mint by preparing the transaction you've already done some of the computation ahead of time of what the wallet is going to receive so that way on the second step send transaction you'll see a prompt right away and so you'll be able to confirm and submit that to the network um and then last year once you've sent your transaction network uh you can wait for the transaction i was talking about this a little bit earlier with the use wait for a transaction hook which allows you to sort of watch as the transaction is mining maybe show like a view on etherscan or view on block explorer link while that's happening and then once it's succeeded you can show a link to the block explorer show confirmation state that type of thing so what this sort of looks like is you use the used pair contract right hook here you pass in an address for your contract a contract interface so here's the basic example of mint function name and then if that function has arguments you can pass those into so what this will do is once this component nft loads it will take this data formatted into a request which can then be sent off to the network using use contract right so this just takes that config that's returned and then once the user clicks mint presses the mint button right we'll send it off to the network and then as it relates to waiting for the transaction to confirm what you can do is use the use waiver transaction hook and it takes a hash from use contract rights data and then you can use as loading success flags um along with some additional information that isn't pictured here to show some uh different states to users of your application so that's sort of like the steps that you want to walk through when you're doing this you want to prepare the transaction you want to send it to the network and then you can optionally but probably best practice from ux perspective make sure you're showing the status of the transaction whether it's loading if it's exceeded or if it's failed um so lastly here i wanted to go over a quick sneak peek of something that i'm really excited about i think it's going to make it a lot easier for folks to work on their apps make sure it's everything is more safe and easier to get started working with contracts so what this is is some avi type inference there's great tools out there one of them type gene which you can use to generate types at compile time yeah it's your cli tool you can use based on your ebis but something that's coming to agony students the ability to uh just use the typescript compiler to automatically provide like static typing for your different contract ones so this is using use contract read but you can imagine the same concepts being extended to use contract right and all the other contract interaction hooks so here's an example i have this api here which has two functions one that is owner of one that is balanced has some inputs and outputs associated with them each um and then you can see that use contract read you know takes in a function name and some arguments as well and this is all actually typed right now so if i you know misspelled owner of what happens here is i get some feedback from typescript that says owner app is not assignable to and then it tells me the correct ones so i can change it back here works similarly well for arguments so if i made this a string instead of a number then i get some feedback too you know if i just to show you that this actually is working if i change this to string then it is valid um if i change this to an address you can see here that it doesn't follow like the address format so that doesn't work um and then similarly like you know one of the greatest things about typescript is the the autocomplete um that you can get in development so you can see here that all my function names are auto-completed um if i'm working on arguments here you can see that these are typed as well with the library we're using here too which we wrote for this specific case and we'll be open sourcing as well it works for a lot of complex types too there's like 100 coverage here of the api spec so like if we changed um if we change let's say we change this input value here to a tuple type just do this on the fly real quick um which just follows the abi spec so we can grab let's just grab this we'll grab the address here and we'll grab actually let's grab owner what we see here is components of forgotten comma all right so now uh this function needs to have a tuple as an input so we see here that um these are both the same so let's change this to token id to make it unint 256. all right so now we see that the arguments need to be owner and token id so we can go ahead um and add those in so owner and token id and we're good to go and so this this works um even on the arguments inside here the type difference and also we can have like deeply nested tuples another cool thing if we switch this over to balance of we have fixed support for um fixed length arrays so i can make this input an address of fixed length array of two so i can add in here um i only have one address so you know it says requires two addresses so now if i add in another one if i add too many you know it gets mad at you so all the same stuff and then other cool stuff here is the response type data is also typed so if i change um balance here to an array and you can see that the data here is an array of uh like a number or big end return type so yeah that's um the api type imprint stuff super excited for this to come out it's going to be a great way for people to add and to end type safety to their ethereum applications um and yeah it works for overloads follows the uh contract api spec all these good things um oh yeah to review yeah and then type safety for contract interactions like really easy this way you don't end up deploying a change where you've misspelled the function name or sent an argument in the incorrect format covers the entire api spec with typescript there's the open library that we wrote for this that would be open source so you can use it in your own apps you don't have to just use it with wagney and supports yeah more complex types like fixed length arrays tuples with keys addresses any combination of these things also supports function overloads stuff like that so yeah you can keep on the lookout for that very excited hopefully we'll be releasing that soon and lastly i just want to say thanks to global um yeah it's pretty awesome that y'all are doing this and then also a huge shout out to family in context to our two of the github sponsors for wagney and then lastly if you're interested um bitcoin gr15 kicks off next week so you can go to wagney.sh gitcoin if you want to support or check out uh what's going on for that and that's it thanks for uh tuning in amazing well thank you so much tom and uh this was great that's a pretty amazing uh preview on catch the autocomplete that'll save all of us a lot of time my obvious question is uh when um yeah probably not going to commit to a certain deadline but yeah definitely looking forward to getting this out as fast as possible yeah we're just on vacation for a couple weeks so okay so in the next two to three months yep so yeah oh yeah definitely it's great definitely amazing um and and maybe another one would be that uh obviously uh the libraries become such a kind of rapid sort of uh integration into a lot of the new apps recently uh i'm curious like what are some of the most common uh questions that you get in terms of feature support requests or or just kind of patterns that you would like people to sort of take away uh given that everything is still um largely valuable why should people think about using the library in terms of best practices or things that you may consider in the future or should would not consider the future and just getting some clarity around that would be great yeah totally yeah i mean the first thing i'll say is just because everything is still so early as it relates to the library there's still you know stuff we're figuring out um edge cases people might run into and so i would encourage anyone that's using the library and runs into an issue or feels like something is like a little bit of a sharp edge to like drop a note and like they could have discussions or create an issue just because like we take the feedback to heart and really want to make things very good another thing is a lot of people like want specific hooks for things that you can actually already do with like the contract related hooks so people want to hook for like reading nft balances or like you know setting a token allowance you can actually already do these things maybe it's not as quite as obvious but if you just pass in an api and a contract address you can just you know call function and go right ahead i think once we have um the type difference it's going to make it a lot easier for people to get started with those things so yeah so i feel like uh no that makes no sense yeah i feel like the the abstraction here is like the hoax piece not the ability right and the fact that you get to use it easily is kind of the the aim um with the reactions totally and then one other thing i'll mention too is like we like this is all starting with react and we're definitely very focused on reaction um right now just to sort of like get to a certain amount of coverage um that we need so that's like really really good tool for everyone but definitely have plans in the future i think if anyone's been paying attention to what um react query and that stuff has been happening there they've switched you know to being a framework agnostic um definitely something we're very interested in we have like a vanilla js core which the react package uses but it'd be great to be able to support other frameworks in the future like view or spelt um so yeah keep on look out for that nothing soon but yeah well uh the the teaser is good enough this is uh this is exciting um well i appreciate this and uh i'm really happy that you're able to kind of talk about the library for the first time here and uh it seems like a lot of what's going to happen uh in the future is probably closer related to our next talk which is rick moo and uh given uh you're gonna get a preview of what's going to be possible in need there's v6 uh you may want to stick around then also listen to what uh what he's up to so thank you so much tom um and uh without further ado i'd like to welcome our last speaker of the day and that is richard moore talking about ethers v6 hi hi how goes things are going great how are you excellent excellent kind of just woke up so that's a very familiar exactly so you know it makes sense all right well great to have you rick uh let's uh let's talk about v6 and see what things you can uh tell us without also committing to excellent um yes let me find the keynote uh can you see that everything is great okey-dokey and the little bar for zoom is covering the button there we go okay um so i was kind of expecting more q a at the end so it might not be enough so we'll figure that it would go along um but for those that don't know ethers is like i don't know what the target audience is in terms of like familiarity with with ethers but it's just the library for interacting with ethereum blockchain and that sort of thing so v6 is up and coming i was hoping to have it out a while ago but the beta is coming along and uh i've got a big release i was hoping to make by this talk but didn't quite get finished last night um hence waking up before so brief oh there we go ah so yes one of the biggest features of v4 is i'm moving to modern script or javascript features um prior to like v5 and before i only targeted features that were available in es3 so it does mean that ether's v5 will probably work in like internet explorer and like browsers circa 2010 um but that's becoming less and less important especially for ethereum and so moving to the modern es features gives us a lot of like really cool uh abilities that javascript's added in the last you know five years so uh one of the big ones that people seem to always want and i am kind of looking forward to getting this out there is bigents biggents are now built into javascript um things like september 2000 that kind of the last holdout which was safari out of them so everything should basically have access to big ends these days there was a lot of issues like before using big big number there was a lot of extra commit extra code you needed because it was like dot mall this dot add that um you did you instantiate big numbers from uh their their static constructor before you're doing anything with them so nice thing with the nice thing with big ins is they're built into javascript they just work you just add this little n to the end of your number and now you can have numbers that exceed the value that uh ie754 can support and it also means you can do other cool things like you can just multiply them together there's no complicated things you need to worry about that way and you can just check them if they're equal to each other use greater than less than um i mean that was a point of of uh difficulty for a lot of people especially when they're using test frameworks and they just want to see if this one value is greater than another and the existing frameworks just use um like inequality operators internally so um lots of cool things that way one kind of downfall of bigints i'm still trying to figure the best way around is you can't json stringify them and so i do expect some people have issues where they have a value they want like a computed structure they want to jsonify and so there'll be a special function to help handle that sort of thing um but so let's begin um another really cool feature i i mean back in the day was using python this is just built into language es6 proxies are freaking awesome uh basically it is an object that if you if you're familiar in javascript if you have an object and you call a func you you call a method on it and that method doesn't exist it just fails the cool thing at the proxy is before that failure it gives code a chance to determine do i want to do something or do i want to fail and so if you have an object called the if you have object foo and you do foo dot bar if bar doesn't have a value it'll just fail but a proxy will give the code a chance to say do you want to do anything with bar and so in v6 one of the big things you do with this is contracts because now contracts can take a a property you're trying to access and kind of make it better educated guesses of what you're actually trying to do and find for example the math that you want to call um if you're familiar with v5 and you've got like really complicated big apis from third parties you probably also see like a thousand warnings in your uh console log saying like duplicate api definitions you have too many balanced ofs you have too many owner of because each one of these had a different signature because slowly allows you to overload signatures so the cool thing is you only get those type of warnings now if you actually try using something that's ambiguous um and that kind of leads into oh maybe it's a few slides ahead i'll get to that in a second um but yes basically it gets rid of all those errors that people have been receiving um that were kind of required for ethers to throw up at the beginning because it wouldn't know whether you try using them or not um right package exports that's actually why the latest version's a little bit behind i'm trying this out basically in prior versions of ether's v5 it was a massive model repo with 20 some odd sub packages and each sub package is managed and and has its own ts config and package json and all this crazy stuff and it also meant that when you installed ethers some things would start getting out of sync and if you blew away a bunch of stuff but not everything and then an npm install you start you start getting issues where versions of the library within ethers for example ether's project slash provider might not be compatible with the version of ethers project slash contracts you have and so then you got these really crazy warnings and errors that make no sense because it's basically just the build systems completely lost and so you had to delete the package json or the package lock your yarn locks all those crazy things delete the node modules then do a fresh npm install and things just worked but it was a lot of hassle so now using the the new the package exports um it's just everything is in one package ethers and if you do slash providers it knows to pull in a specific set of files and so the big advantage that this really helps is it makes tooling much simpler tools are just much happier now with a normal build process the ethers v5 has a convoluted crazy build process to handle how typescript deals with composite packages plus how the bundler munches all these things together and so yes bundler2 and tool support is much better the other cool thing with this ethers slash provider thing is you still get all the great benefits of tree shaking because the exports kind of steers the bundlers and steers the toolings as to what file to look at and so because true shaking really only works effectively on a per file level um these exports kind of guide the the file processing part well and right basically publishing is much easier for me maintaining one package that i have to modify and not worry about having like a thousand sim links for and then the sim links sort of get like unsynchronized over time for one ways or another for setting up a new machine um anyways it's just much easier so uh i'm kind of belonging to my slides very quickly and i'm a little bit worried i'm going to be too fast um hopefully kartik is thinking up some good questions for me or keeping track of things um another big advantage of v5 is the dependencies i mean i think sorry v6 i think vb5 had dependencies around nine or ten dependencies with this we're down to um five dependencies the web the web socket library is only necessary in node um i can't quite see all my slide i think it was 60 million um but anyways they're basically a very popular library that has a ton of downloads um so it's maintained i feel like an important thing people don't look at when they look about dependencies it's not just how many absolute dependencies you have it's kind of how many different authors and contributors you're depending on because of those defenses and also the kind of the quality of of the author when you see these packages have very few downloads you almost ha i feel uncomfortable because it means that they're probably not worrying too much about the security and all it takes is one of your dependencies dependencies dependencies dependencies to like fail and also in the world is just lost and we've seen things like the eslint hack i mean there's always the possibility of supplying chain hacks so if we can reduce the number of people we have to rely on um but also increase the quality of the people that we rely on we help protect ourselves from all these supply chain problems so tslip for example i mean it's only included in v6 because it drastically reduces the size of the library to include all those little helper methods that typescript injects for you once but again microsoft is a fairly big company if they got compromised they would suffer some sort of like fallout and like pr nightmare so they're heavily incentivized to keep keep all their security up and running ws has a crazy number downloads it's only used in node i don't personally know the person so i can't that's my one kind of like concern paul paulo paul miller the the author of the noble classes he's awesome they're all audited and he's a big security guy as well so you know we can kind of i trust him more than i trust random other projects i've used in the past that maybe take a long time to get back to their their uh like non well it's serious issues that sort of thing and then there's ethers if you're depending on ethers you're already depending on me being secure and so my other library asga sjs which ethers uses um is kind of in the same security threat model so anyways the goal is to kind of like bring down dependencies but also bring down the number of people that responsible dispenses um that's kind of my take on that um okay now back on to like more cool v6 things so this goes back to the proxy thing i mentioned earlier um because the proxy can kind of decide at run time we get all these cool abilities the next two slides will cover those um so first of all we have a typed contract interaction uh historically if you saw this abi the um as you can see there's two methods called foo sorry yes as you can see which method is called foo so first of all in v5 if you load this api you'll get warnings in your console saying duplicate duplicate definitions of foo which makes sense there are two of them and so if you just did contract dot foo as you can see in this first case it doesn't know which one you actually meant to call because a address can also look like a number um so in the first case it would still fail as it does in v5 but in v6 we added the typed object and so typed lets you kind of hint to the contract by the way this some adder parameter is actually an address and now it's no longer ambiguous it knows that if you're calling foo and the first value is something but the second value has to be an address then it can find the right food at all um and keyword contract interaction so this is something that i've just started adding so it's still very bleeding edge but this is a feature that i've seen a few people ask for they want to be able to basically call um a contract method using the key keyed arguments so this is something you're probably familiar with the kw args if you're using python um excuse me it can make code a little more readable in in many situations and so if you pass in one of these type keywords objects it realizes that all the parameters are not being passed in positionally they're not being passed in um based on the order of the the parameters as they show up in the uh api but actually by their name and so for example in this example so in this example you see i'm using from to in value but the order doesn't really matter if you wanted to you could specify the two and the from and then the value you could imagine constructing these these um objects somewhere else if this is available throw that in and kind of like codifying or procedurally generating this stuff and so this will also be useful for a lot of um like frameworks that need to uh kind of call functions in a constructive way based on other information they may be pulling from other places um is there anything else to say on that so i think that's good for now um right so another big thing that's changed in v6 is how providers work so not how they work for from users points of view but how they work internally when v5 came out it was very heavily influenced by v4 which was helping with v3 and so on and so on so back in like 2017 it was a very different landscape basically everyone only used http providers the um socket providers were still kind of like a niche thing websockets were expensive to run um now there's a much more um it's much more it's much com much more common to use web sockets and even ipc i don't think ipc is still that popular but the thing is once you support one you might as well support both because they're both basically the same so there's been a lot of work just to abstract and change the model so that internally they work better from a long-lived socket connection so for example websockets uh as a result one thing people always want with web sockets is they want it that when there's a hiccup when the connection drops they want the websocket to reconnect and just continue on trucking is actually quite difficult to do especially in how v5 was structured because you could imagine if you were streaming if you were listening for some event and then there was a hang up and you reconnect you may have missed events during that time you need to kind of know which was the last event you saw so you can kind of re-subscribe to old events uh or pull for the old events and replay those but you can't start uh emitting the new events until the old events are processed because you still want to keep things in order basically there's just it's a consistency nightmare um so in v6 there's been a change in how the overall model works so these are all abstracted away so each uh provider kind of gets to decide how it's going to process these and so the websocket provider has its own custom mojo thing going on so that it knows how to reconnect restart uh and kind of keep all the events consistent on that note the crap i lost track of where i was going with that um oh yes pausing that was the other cool thing i think that might actually be on another slide though maybe i'll save that for the next slide i think it's there um so right uh basically by using filter ids we also gain a lot of abilities because now we can uh actually get uh orphaned events from even a polling connection some back ends do not support filter id but things like inferior do and so we can use those which also helps some of the problems with talking to a large backend cluster of uh nodes making sure that everything comes in consistent consistently and in order um also there's new plugins available so that for example it's much easier if you're trying to build something on top of aws which might want bare authentication tokens um and generalized contract runner type this is a little bit of a i'll try giving a quick overview basically a contract runner is something you pass into a contract to run it um historically a v5 that's been either a provider a signer or null and depending what you pass in kind of dictates what type of things you can use the contract for um by generalizing the contract runner uh there's now a higher level interface that anything can influence it happens at provider influences interface it happens at cider influences interface um the cool thing is you can now build your own random weird things that also into this interface which gives you for example some really cool things you could do for mocking purposes if you want to build some sort of test contract runner that's going to feed fake data but that's meaningful to the to the contract if it asks for it and it'll think it's just talking to something speaking its language um right here's the the pausing thing i was mentioning so basically providers can now be paused you can pause resume restart them and so this is this was kind of almost free because we needed this this functionality for the purposes of being able to restart a websocket provider um like the events on it and make sure everything comes back consistently so this is an example where if your application is goes to the background if they click a different tab in the browser you might as well turn off all the providers that are running events and triggering things and updating the ui um because you're a using bandwidth you're paying for those inferior requests or or alchemy or anchor you're paying for or even like just contacting your own server to do things you're paying for that infrastructure you might as well pause it when you're not being used maybe they close the tab later and then anything you were updating wouldn't have mattered anyways or when they come back later you can then decide do i want to continue replaying all the events that happened while my tab was gone do i want to just replay the last 10 minutes to catch up my ui so it looks nice or just elliptic state so i think this will help a lot of people as well it makes it nice and easy to pause a provider um network plugins so another big issue with ethers is some people want to use ethers on networks um chains that are kind of insane like they they just break the rules in ways that made either no sense for them to break or in ways that from my perspective as a like ethereum semi-maximalist um didn't really think was a great idea but i also don't want to preclude those people from having access to ethers i don't want them building their whole own other library that maybe has other problems or i mean in general it's just nice if we all work together and that way anything they build on top of ethers other ethereum people can use as well and so network plug-ins kind of allow um weird networks to be weird and you know just treat it as that's an okay thing to be um so for example uh so some examples i will give of this our cross e s support e s actually supports um any chain any chain in the universe you want ens supports it the problem is you need an ethereum connection for that for a lot of networks so for example if you are on um finance smart chain and you want to get a binary smart chain address you need some way to talk to l1 ethereum to ask for that so this just kind of provides a way for networks to to figure out how to connect you and talk to l1 chains um different chains have their own way of computing intrinsic gas costs that's not really that interesting for most people that's just something kind of used internally by contracts when they're trying to estimate gas um so for example uh in terms of eip 1559 priority fees the mumbai what's that one polygon the polygon uh peeps kind of chose weird values for those and it causes a lot of confusion when people use ethers because the way they use the ap 1559 is not really the way that 1559 was intended to be used and it's certainly not the way it works on ethereum and so this allows people to build and just kind of attach a little plug-in to their network thing by the way um when doing gas estimation you use this other criteria to kind of like uh mung the values um it also lets you add or add extra fields or missing fields of the transaction there are some chains that actually compute transaction hashes completely differently this makes it nice and easy for them to kind of uh shim that in there without having to have their own complete instance of every provider under the sun and it also allows you having custom urls because in general i try keeping ethers quite lean which means focusing on kind of the main chains people use but for example ether scan does have a binary smart chain uh api and so this means that the network object can now encode that so that if anybody wants to use a binate smart chain with ethers they just need that one network object and once they pass it into a provider the provider knows all those weird exceptions um excellent and i think i made it through and i guess i took longer than i thought i might but yes that's v6 in a nutshell um from what i could throw slides together in the last few days for so that was still great and uh all right so i have i have a few questions but they're largely uh meta questions because um you were very concise and articulate on what you're trying to do and it's very very easy to understand like what this does and while you're doing it um i i think um maybe kind of just let's start with like the more obvious one um obviously didn't get deployed today but what's the the timeline on uh oh yeah when should we see v6 coming out so there is already a v6 beta it's been up for a few months now so if anybody wants to use it um just npm install ethers at v6 dash beta um the exports stuff is kind of new i've just started i just found out kind of that it was widely supported by most of the tools i need um this week so i started porting everything over to use that um oh oh sorry i ended up disabling the screen share in case uh anyways oh there we go okay i thought maybe my device hung up my head up on you um right so i only discovered like this week that um it's widely supported so i've been kind of like adding that so that was what was opening it up today it didn't quite happen um but hopefully this weekend people will be able to start using the new version that has the package exports but yes um it's already available it's on github if you go to github and look at the branches there's a branch called v6 beta and the new one that will be coming will be v6 beta-exports that's the one that will include the exports instead of the crazy monorepo the monorepo still isn't completely off the table i'm just hoping it is because the export is so much more useful and so much easier to develop against um tree shaking is way nicer um um okay so others a set of questions um broadly kind of speaking uh and and these are kind of mostly meta questions but like i like that the inference piece i like how uh you're trying to conform uh es6 to python um and uh and the network plug-in or just plug oh actually maybe one guess so i like the network plug-in architecture like sounds really actually extensible and this is how you get it to apply to other evm chains um is it just specifically for network plug-ins or is it overall just a a hook system that you were thinking talking about but you just refer to the network plugins as the example um so there's two there's two places i kind of put plugins one was in the provider one was in the network it is mostly just to handle kind of exceptional cases for now um they are hooks things and i mean once people have hooks they'll use them in weird and crazy ways it'll be awesome and i'm looking forward to that but the main purpose that i'm putting in for is just kind of like for a headache reduction when people have some weird network and like this thing's not working for me and i have to give them like this big work around or they have like reinforced this whole thing um it'll be easier if i just say like just you know hijack this hook on the network and or add this hook on this network and then the the provider will kind of know what you will need to do the other thing is it's also extensible that if some weird ones weird networks comes along and has something that i don't support it doesn't need to change the um the api for the provider because i can basically add the special logic into the provider necessary they can add the plug-in onto the network and then when the the provider is running it can ask the ask the network for this new plugin that didn't exist before and kind of go from there so it just means that i can stop changing interfaces like the the signatures for for methods because someone has some new thing like historically i haven't been able to i don't mean backwards breaking changes so they say i want to do this thing and i'm just like i'm sorry but there's nothing i can do about it because it'll break you know there's over there's almost a million downloads of the week now of this thing it's going to break a ton of people if i just make this weird change for you um so it gives me the ability to still make weird changes for people who need weird changes without hurting everyone else that's amazing um on to the meta questions how do you decide when something is ready for release and which features should be part of a like a major version upgrade versus like a minor or testing like what's kind of been the design or philosophy behind this thing because v6 has been in the works for quite some time um how you get to how do you get to a new version exactly um it's very i mean it's it's very much an art um it's it's very like i remember i i think it was eight months into v5 when i first told some people like oh i've got some really cool ideas i wanna do for v6 here's what we're gonna do and everyone was like eight months uh it's too soon and so i kind of like i i just kind of started wrapping more and more ideas in until eventually got away from me and then it was like it was not no longer something i could complete in a short period of time and so that's why it's what like two years later since v5 has come out um so i think in the future i'm going to be a little more aggressive trying to release more frequently um in terms of major versions in terms of minor versions minor versions are required anytime that um you're breaking kind of forwards compatibility and patches are just um nothing bad is changing but it's absolutely it's not an easy thing to do and even trying to figure out what features to include um so for example uh if i was willing to wait another six months because right now um there's still a bunch of craziness involved for fetch fetch is in the browser fetch happens to now be in node 18. if i decided to cut node 14 and node 16 out also to my life become much easier or if i waited six months for note 18 to kind of but the thing is you kind of have to it's like buying a new computer right like my dad's trying to buy his new computer and he keeps every time he has enough money to buy a new one he's like oh if i wait another three months it's gonna be so much better it's like but you have to kind of find that happy balance between like the pragmatic side and the well your core principle is like preserving backwards compatibility then i feel like you uh you have to kind of deal with the polyfills for quite some time exactly exactly and for me backwards compatibility is an important feature this is something that people do not really get and they're like well why don't you just do this don't just drop support for that like i'm the maintainer so many legacy like iphone apps and these sorts of things when these things like drop compatibility it breaks like it's just a week of my life that disappears now because somebody dropped support for one little thing and that little thing was used by some other little thing i used and like i said it's like it's turtles all the way down the dependency tree goes right down to the floor that bottomless dependency is borked and now you're worked so um yeah i hope that the websocket library is not using left pad [Music] and uh all right so uh two more questions um one is how do you uh granted obviously so much of um i would say web3 infra right now relies on ethers um how do you kind of look at how people are using the library or how people are using other abstractions that use the library just now we just talked about walkman just before this and kind of see how it's being implemented versus what you think you can help simplify and abstract for others do you kind of care about that how often do you actually do these things and how can those decisions end up influencing future features and uh sort of what's the process like there and then i'll close off with a simpler question and uh cool yeah i mean i mean i absolutely love other things using it it's really cool i mean i just saw the last few minutes of the walk me uh thing and i was like i was just like i was really impressed by the way it was able to detect errors and i was just like man i feel like it's really cool to see all these things built on top of ethers um that extend it because it means that it's something i don't have to write because the reason i have made these in the first place is ethers is i i made ethers for me even today ethers is largely for me um it just happens that i make it available for other people as well and so all these other things i see out there for it are awesome because it now means that i have this extra ability using my own library that i mean going back you can even imagine like syntax highlighters like writing a syntax highlighter is like boring and annoying if somebody else out there wants to write them for me and let me use them like it's it's awesome um so yeah i mean that's one of the big things as well i'm seeing with with that's one of the reasons why i want things like um the types the keywords type things exactly like i basically want keywords to be available so people who are building frameworks can continue building frameworks that kind of expand and enhance the capabilities of ethers because that way someday i can use those frameworks and save myself time and effort um and if it makes things more secure and better for them like why not um because this is one of the things i find in common when you build nice abstract libraries you'll often find a feature you add that's like increases abstraction it makes it easier for frameworks to interact with your stuff makes it easier for you when you need to interact with your stuff sometimes because you often do have these very abstract high-level ways you end up needing to interact with things and having already extracted them for the frameworks to make it easy for for code to operate with it it makes it easier for you to write your own code that operates with it if that makes sense yeah it does i i think abstraction is also an art and uh you end up learning about kind of how in a way these uh things are codependent so as as long as it helps you anywhere from improvement to make your life easier in the future that's a pretty good way to look at it uh final question um how do you usually collaborate with open source contributions on the project and if somebody wants to get involved how can they contribute to ethers oh uh so i i wasn't sure if your first question is that with external partners or oh sorry external contributions so just on the get out when you are complaining or suggesting or submitting pull requests like what's kind of the process and how can they get more involved if they would like to absolutely um so generally i prefer i mean i'm truly that's one of the things i'm trying to change with the v6 i'm trying to be less making limiting um but i've historically been very tight with my code and i don't like other people just just um modifying it so i actually usually pref like there's definitely pr's i appreciate the pr concisely shows the problem and but i still usually make those changes myself there are weird like attack vectors from just merging prs so i merged them manually um there's actually get pull up i should give them a shout out as well i'll be announcing they've integrated with ethers because ethers has its own process because ethers doesn't really merge prs it kind of the pr examine and i merge manually but now i've got a script that runs and anyone who has been tagged in one of my commits for either a pr or an issue i really love issues as well if someone wants to open an issue and say rather than building a pr because the pr is actually quite a bit of effort but if you've identified the problem is like oh in line 37 of this thing is a plus or is it less than or equal to which would be just less than um like just a quick example of you know that sort of thing it's something that i can change very quickly and easily make a uh and then push the fix it for and i tag all my commits with the issue numbers and that sort of thing so the cool thing is the script now just picks up the fact that you reported a bug you don't fix the bug you just report the bug um if you reported it and it gets tagged yeah so don't just report bugs because if you just open up and report a bunch of stamp it's not gonna count it's only for ones that actually get tagged as as solving something um but they get added to the contributors file and the contributor's file has a json equivalent which is then fed to get pull-up and they can use that to like issue a pull-up so there we go so yeah it'll issue you co-op um and so basically yeah i mean i'm always open for if you have a question please use discussions if you have an idea discussions also has an ideas thing if there's enhancements you can jump right to that but usually i'd recommend starting a discussion on github about a new idea before jumping to the enhancement but basically i do everything through github um everything is an issue everything is a discussion or a pr um i also listen to twitter if people want to tweet out to me it's at rickmore uh i do keep in mind so i mean there's definitely climaty issue things we have to worry about so i do keep a complete synced copy of all of my github discussions issues etc etc locally so that if there ever is like a tornado cache like event against ethers for whatever reason um then there i have some way to at least mirror a lot of that data but for now basically everything goes through github and any aspect of decentralized decentralization happens on my side on a private um clone of all that data so awesome that was great well thank you so much and uh can't wait for v6 to come out very soon excellent thanks thanks all right that was rick moon talking about a preview to v6 and with that we are at a wrap for our dev tool summit so thank you everybody for tuning in thank you to all the hackers that got excited about what's going to happen for the next few weeks and what you can do to simplify your life on the developer side and with that happy hacking everybody and we'll see you all on discord and until then next week's summit take care and goodbye and enjoy some low-fi beats see everybody you 