hello and welcome everyone to the stock we're peeking into cairo uh workshop joining us today shaha and ellie who will be taking the session and yeah and with that i will hand it over to them to give a quick introduction to themselves and kick the session off okay uh terrific so i am uh ellie bensasson uh co-founder and president at starkware uh how do you wanna yeah i'm a an engineered starter and i'm the co-creator of a cairo okay so um on eath global so so we are starker is one is one of the sponsors of global and we would like to invite you to uh build on cairo and what we will do for the next 50 minutes or so is first of all give you a little bit of explanation of how cairo relates to l2's starks zkp's and and that's the part i'll do first i'll take roughly 15 minutes and the rest of the time shakhal is going to walk you through hands-on uh tutorial to see the full cycle of how one can write code in cairo and actually get a stark proof and have it automatically verified on ropsten you know full cycle later on during the session i'm sorry during the eve global we hope that many teams are going to build we have some tutorials on amms voting and a bunch of other things and we hope people will build on it um so and and i'll now give a little introduction and after that i'll take some questions and hand it over to uh okay so the purpose now is going to be a little bit of just a state alignment um i'm going to share a screen so do you see uh do you see my screen yeah okay so the question i want to answer first is why are we learning cairo cairo is is a programming language and i guess most of the listeners already know quite a few programming languages so why learn another one and the short answer to that is that this is a language that is best suited to build daps on l2 that have the exact same security that is offered by l1 but has at the same time exponentially greater throughput or exponentially lower gas cost and this can be achieved directly today using cairo this is the way we are building our systems and those of you who will build systems can deploy them today on mainnet or you can do that also through starknet by summer so this is a system that is up and running we have a few of our systems in production we'd love to see more teams build and use this infrastructure that allows you to get the power of zkp's and the exponential scale they offer at your hands so how do we get that scale so everyone would like to take throughput of ethereum and you know 10 exit or a thousand exit which is what we do actually achieve with with cairo and starts so but what does cairo got to do with it why can't we just press some button and just have it automatically scale um or how do we or in other words how do we with cairo um get to get this exponential uh speed up or exponential reduction in gas cost um you know what's the magic here so the answer is that what happens behind the scenes is that the computational integrity of cairo runs of executions of programs written in cairo can be and is automatically and efficiently proved using the stark zkp and placed and verified on a blockchain so all you have to do is write code in cairo and execute it and then um these executions can be asserted and proved to be correct verified on chain this whole system is already spinning and working and then you can consume the outputs of your computation that were done off chain you can consume them on chain and we have a full system that works this way we have three systems in production that are using this framework and we'll have more uh up and running okay so let's now answer four questions what do we mean by computational integrity what are cryptographic proofs which are the method that that we use uh within the field of cryptographic proofs what are starks and uh what are uh errors and then some of these terms are going to look magical but we're going to answer each of these four questions in the remainder of my part and then we'll see the whole you know cairo system working okay so integrity um roughly says doing the right thing even when no one is watching and in the context of computation it means you would like other parties to run programs and report the exact output that program gives them but the problem is that often people have incentives to misreport the outputs for instance if i'm processing many transactions on you know some l2 version of uniswap maybe i'd like to put my transaction first or maybe i'd like all transactions to just pay me money um you know how can you trust the output of my computation how can you trust my computational integrity so how do we get it well if you look at the conventional system for instance banks basically uh we trust them and they're a bunch of you know accountants and regulators that look into their computations to assert computational integrity but it's kind of opaque to the public if we go to blockchains like bitcoin or ethereum the way they achieve computational integrity is by naive replay of computation which means that everyone every node in the network is repeating and replaying the same computations and processing the same information this is precisely what limits the scale of blockchains this is what makes you have you know in ethereum a tps of 10 or 15 or something like that because you want everyone to naively replay the computations that everyone else is doing now starks achieve computational integrity through math and cryptography and in particular through cryptographic proofs so now we're going to answer the second question which is what are cryptographic proofs so they are systems that have two main components there's a prover and a verifier the prover is the one doing the computation it is the one executing the transactions in our case it's going to run cairo code but it could be some other computation some circuit or some solidity code or some you know c plus plus code so there's a prover running the computation and in addition to running the computation the prover takes upon herself the extra burden of generating a proof of computational integrity which is a computationally complicated task and the nature of cryptographic proofs and this is backed by many years of research is that true statements statements of the true evolution of a program and its state do have good proofs that can be efficiently generated by computers whereas false statements don't have proofs and you cannot generate for them even if you are a very strong and powerful um you know party running the computation you still will the math and cryptography prevent you from producing these proofs okay that's the prover now the verifier checks the proofs okay it doesn't need to trust the approver at all it's a piece of software um and the math and crypto that you know has been researched for like four decades um proves that uh the verifier with its work can check whether a statement is correct or incorrect now what are we proving we are proving statements of computational integrity that have the general form that is specified by a quadruple quadruple is a specification of the computation a program an initial state of the system before you started the computation a final state of the system after you ended and a time bound and if you have this quadruple the statement that is captured by it is the following there exists a bunch of auxiliary inputs such that if i run the program that's the first parameter starting from the initial state that's the second parameter um with the inputs that you are not shown you will end up in the final state the third parameter within less than t steps so this is a statement of computational integrity and it pretty much covers what you would think as as the formalization of computational integrity it is that a system has evolved correctly according to a computation the four parameters just specify what it means exactly to advance the system there's a program it starts from an initial state it ends at the final state and there is a time the number of steps it took to reach that thing and for those of you with a bit of a mathematics and computer science background you cannot eliminate the t parameter because this would violate you know the undecidability of the halting problem because you need to know for general computer programs you need someone to tell you what is the time and when they finish because otherwise they could run forever and you cannot really decide anyways but that's beside the point back to our topic cryptographic proofs are systems that have approver and verifier and allow you to reach computational integrity by asking the prover to prove statements of computational integrity in a very general format that programs have evolved correctly and the verifier can now verify the correctness of these so what are starks there's a very large family of different cryptographic proof systems and those interested can can can we can share more information on on i wrote a blog post on cambrian explosion of zkp's um describing a little bit the different parameters that that sort of uh break this is the the set of zkp's up a little bit more but zk starks which is the technology that we use in which cairo is tied into have the following properties first of all zk means they have privacy which means a zk start proof is one that does not reveal any information about the auxiliary inputs that went into the computation in the context of cairo this is not something we're supporting today it is easy to add it and we will add it to the future but it just uh you know the core technology of our computational integrity proofs does have this property but we're not deploying it today the s in stark means scalability which is exactly relevant to the uh issue of gas cost um it means that in our proof systems right which have approver and a verifier you get two things simultaneously the time required to prove a statement scales pretty much linearly actually quasi-linearly with the amount of computation actually done scales like t times poly logarithmic in t which is very close to t it's called quasi-linear and at the same time verification is exponentially small in t meaning exp verification of a batch of t transactions does not take t steps as a naive replay it takes only log of t steps which is exactly how you reach scalability you need two things you need the prover to be efficient which is given by its quasi-linear running time and you need the verifier to run in time that is exponentially small in the amount of computation being done which is what we achieve and that's why we have a verifier on chain that runs in time that is exponentially small in the amount of computation that is being asserted t stands for transparency the t of stark which means that there's no trusted setup it's a very important property for trust and for scaling and another aspect which ties directly into cairo is universality any computation can be proven any program its computational integrity can be proved by the same framework of uh the z of z k stark so now how do we get a stark to be written for a computation that you have in mind and uh there's uh a lot of math going into it there's something called an algebraic intermediate representation which is a bunch of polynomial constraints those of you who know a little bit about snarks or may be familiar with the term r1cs constraints so errors are the succinct analog of that in the world of starks and that's how you describe the computation you basically write a bunch of polynomials that capture it now if this sounds complicated then indeed it is and initially for each computation um we had to write by hand a bunch of constraints and capture it and this is very scary to do and very hard and doesn't scale very well so um um you know shahar and his co-creators of cairo came up with a brilliant uh uh suggestion of defining one single small set of constraints that actually define the specific computation that is the analog of a cpu like a chip that can run any program and came up with a programming language in which you express things for the cpu and that programming language is cairo so now the way we at starkware build our systems is by not by handcrafting a bunch of constraints as is done in other projects for scaling and as we used to do in our earlier iterations we now write programs in a very nice developer friendly programming language that is cairo and all of these programs get compiled into one error and all the algebra is abstracted away and everyone's happy and and so summarizing cairo is a programming language in which it is very efficient to express general computations much like other programming languages but um cairo is specially designed so that proving computational integrity can be done efficiently and incorporated in a blockchain we have a full tooling that brings you from a computation run into a proof on blockchain and into consuming the facts that are proven there cairo in our view is the just right programming language for proving stuff it is general enough it's turing complete you can express any computation but it's also efficient enough to generate proofs for it um it is production grade we have by now three uh production deployments for you know dydx immutable with nfts and diversify all of them their code is written in tokyo is written in cairo and this is the language in which starknet which will be our l2 rollup is going to be written so um my speech is done i'll maybe answer you know a few questions and hand it over to shakha to actually show us uh the internals of how to work with cairo okay so if there are some questions i can take like let's say two questions oh i see there's a question from mark b in the chat okay i'll answer the two questions that are here now are there any examples on how to invite evoke a cairo program from within the context of an existing dapp written in react.js what is the high-level flow of how it all works together to end maybe you can answer this briefly um well if you're the app is using the ethereum then it's quite easy to use the cairo today our sharp service lets you prove any kind of program you want and it deploys a it puts some facts in a theory so in your the app you can query this a global with called fact registry or cairo you say oh there is a effect which means this current program ran with this and this input or output and you can use it in your the app you specifically said the between with the gs i'm not sure if you're using ethereum or not then if you are even it's easy okay so i'll answer the second question and that will be the last one i'll answer now and hand it over to shah what is stark net this is a terrific question so till now starkware which is the company that both shahar and i work in um we had these uh bespoke systems that serve customers so you know we um partnered with diversify to build a scalable spot trading system for them using cairo we partnered with dydx to build perpetual contracts and margin trading for them using cairo we partnered with immutable x for nfts uh minting and trading at massive scale and all of these systems are written in cairo integrated through the service called sharp that shuffle is gonna describe in a minute and uh but but you have to talk to us you have to work with us uh that's the way the system is right now but um by summer um we are opening an l2 a stark rollup on which will be very much ethereum like meaning permissionless deployment of smart contracts permissionless deployment of transactions decentralization um you know nodes running approvers and operators and sequencers just like so think of ethereum but at much higher scale and it gets its security from l1 of ethereum um by being a rollup but at the same time it has massively greater scale because of the scalability offered by starks and it also has just like ethereum complete universality because smart contracts are going to be written in cairo so a very good reason for developers to start learning cairo today is to start writing smart contracts that will be deployed on starknight because we will port over all existing cairo programs in particular the stark systems that we have deployed for our customers and any other contracts that will be written by them and they will be the first things populating starknet which will happen by the summer so now is the time to start learning and with this i i will hand it over to shaha hi there let me just share my screen okay so i'm shahar hi i'm going to show you some hands-on example how to work with cairo from the level of the code to putting a proof on sharp and using it in the app in ethereum uh well some of the things i'll show you if you have no previous experience with cairo didn't see it then you might just have to uh take it for for granted i do suggest you look at these uh links if this is interest interesting to you and you want to know more how to do it all these links basically will teach you how to do the entire amm example by yourself i will just show a small part of it and all the resources you need to know about carol are in our website kind of dashland.org a few words about the current language first of all it is designed for efficiency on top of the stocks and unlike regular cpus where we use a bits here we use field elements so the basic uh the data type in pyro is a field element this might mean that sometimes you will have if you're not careful you have weird results in your computations i will show you how to do it safely and also the memory is a immutable which means once you write to some variable or some memory you cannot change it to always be this way cairo is young it's developing we are adding new features all the time and quality of life all the time so at the beginning beginning it was very clunky it's a lot better now to get a lot better hopefully soon another thing in cairo is the buildings to make a carroll even more efficient we use some say hardware components which do some specific tasks very efficiently and this includes for example doing hashes and verify verifying signatures we are not writing these explicitly in carbo we're just communicating with the with this hardware this building using the memory so we will usually have some way important to the memory where we can communicate with this uh building and another building we'll use is the range of pdr this helps us do safe math it makes sure some field element is in the range of zero to some number and it's in bounded range and the other built-in outputs things to the public art another very important uh building block we've encountered the the dictionary sometimes it's easier to write things with the immutable memory with the read write memory and so this is some construct built inside cairo using immune memory but gives you some interface you can use like it was mutable memory it's like a dictionary you can read and write things and get the new instance every time and then the last video i want to discuss first is we have some sometimes implicit arguments and those are the things in curly braces maybe i'll touch later but curly braces move the implicit arguments okay let's uh go to the code so this is cairo and specifically our example the automatic market maker and i took the liberty of deleting the body of this function this is the swap function where the user wants to swap this amount of a token they get in exchange a bit opens and this is what we will implement right now i'll just say give you a quick introduction to this code so we can start working these are some imports we have from the standard library we have and this structure represents the state entire state of the amm you can see there are the balances of token a and this example only has two tokens token type a and token of type b and these are the basically the liquidity we have inside the the amm how many free tokens and how many free tokens there are and the airmen will always want to keep the product of these two constant in addition we have this account dict like i said before this we have a dictionary this is a how we use a dictionary this is going to be sort of a mapping from the account id to these structures accounts which account we hold the public key of the owner how many eight tokens he has and how many metropolis he has they also have this max balance visit which is a cap on the balances this is important for safe math so we don't have overflows and the last bit is this function which don't have to understand but we will use it this one basically modifies an account this thing clearly braces like i said is an implicit argument if we test eventually building things like let's see this function which assert that some number is in range actually implicitly use this building we'll see because it's an implicit argument this function takes an amm state entire name of state currency difference in a defensive b and it returns linear state after doing this difference let's make it bigger okay okay so this returns the new state after applying the difference and it turns the public key and so it can be easier to verify that the user indeed signed on whatever we wanted to do so now we want to implement the swap function like before it gets the range of pointer as an implicit argument it gets a previous state in which you want to act and it gets a swap transaction which is the little guy here it has a the account id that wants to swap and how many of token a does he want to swap and we need to return the estate so let's start first thing first we want to verify that the transaction is valid and in this case you can see we have token amount the type is field element but we want to verify it is in a bounded range so we won't get overflows if we do it by the insert and then our e function we this is the assert non-negative and low equal this needs to be non-negative and they were equal then maths don't i know easy enough and we don't have to explicitly verify the account id it will be verified when we call modify account because modify account will need a valid account id or it will fail okay this is like the core of the swap function or dmm want to compute how many tokens will the user get back you want to swap this amount of tokens type in and we compute how many he gets of token b [Music] okay so as i mentioned before we want to keep the product uh the same so if a0 and b0 are the initial amounts in the amm we want this to be and user gives away a so the amm gets plus d8 tokens and it gives back this delta b tokens we want to compute delta b in this case that would be equals i'm just doing the math really quickly don't have to follow it 0 times a over a 0 plus e so using the formula is like starters amm formula this is the amount we want to give him back so let's compute this if we use the division operator we actually get division in the field so this is not what we want to do instead we want to use this function unsigned if a remainder which does integer integer division we want to give it this expression and okay the initial and b amount is total b balance divided by easier plus the x initial a balance plus d a and let's assign this to let's call it token b amount okay so this was just computing this formula next thing we want to make sure that the token b amount is within range because we have this multiplication here and the amount can grow above max balance so we want to make sure it doesn't make sure be amount also yeah and here i am i don't see any transaction this is local so just use token all right okay so we computed the amount he needs to get back and it's valid so we just need to uh apply it let's try by modifying the account and let's copy the signature so i have it modify account this is in the piece document state start by let's say let's see the main documents here and we give it the current state the counter the columns right from the transaction and like i said before this function will also verify that the camera id is valid and it will also provide us back the key of the user so you can see that he indeed signed on this transaction and defect the user wants to give his a token he wants to get back bittorrent okay and this function returns the state to divide it and the key now i want you to notice here that this is called in the same name as this argument we got it's not real it's not immutable this area in the memory still has the previous state yeah this but stage will now uh point to a new area in the memory it's just a rebin it's equivalent to saying state zero when you say something like this and not having the other arguments but the memory is still immutable if we were to try to use it in other places with the previous state we still could okay so now we modified a user account and something we need to do here is to verify a signature basically we use a an ecdsa building and using this public key and some hush on the transaction i won't do this now stay out of scope but let's do it here okay yeah now we want to modify uh modify the account of the user and i want to modify the liquidity of the ammp right the user gave his tokens and the amen got them so let's say the new state so you state payment statement and you start filling it up see these just copy from the previous state dictionary of the accounts it was modified here but we haven't modified it since let's say and okay and now i want to modify the balances so token a balance is since we deduced from the user we want to add the mm open a balance and the token b balance we added to the user so i want to introduce from the amn yeah okay and we have we are not done yet because we need to verify that these balances are in range for example that they are not negative negative so the amount still has the right amount well not too too great so do the same thing we do every time this is using balance to with the max points both of these you know we will return the new state okay um okay this is basically the function now let's say find all the my syntax mirrors we'll use the caro compile command it's kind of compiled give it the amm hyrule file and output to avm lg yeah let's see uh oh yeah whenever i did is here so you get the second argument the remainder but i don't need the remainder so you can underscore here yeah yeah okay this is a valid syntax equals is only for a simple like commands not compound so i need to use search this is the right command sir this equals this okay and it was compiled eh now we want to run it let's see and it runs and i just want to explain a bit what happened in the run at least a lot of parts of the program that i have not shown you basically the programming outputs at the end some structure that says something about what was the previous state and what is the new state you can see we have token a before talking before in the account before this route is the root of the miracle tree with all the accounts in the leaves and the develops after before and this is after so this is the output we get here these were balanced before balance after this is that basically this this thing is a sort of effect and it is true regardless of any state in any word just says if the previous state was this then going to this state is valid this is like a timeless fact and this is basically what we do with shark let's look at charge i can use a recovery.sharp command to submit this program and this run actually a two-shot what would it will do a if we run it sharp we'll use a tropic service we provide software and we prove it in our provers and we publish this proof unchained on ethereum and right now it robs them and then every contract attraction can query our contact and see how this fact is correct which is just this effect it's just some catch up on the mmr output and the program hash so if you have um you want to communicate let's just see an example how i can communicate with this okay this is an example of how i can write an ethereum contract to communicate with factoring in sharpening current so our contract will have states to have the current current account route and the current amounts this represents everything we need to know about the ama it also has the program hush the car program hatch and this is basically the address of a sharp verifier all right stopwatch is verified so um the function here looks very simple okay we give it the program hashtag we claim it's evaluate the output of our program and the function will compute this fact hash that based on the current program hash and the hash of the entire program output after it completely hash if you ask sharp is this fact valid and if it does it knows that this is a valid output which means it represents a valid state transition and since the developers is one straight transition we first verify that the what program output for the previous values of the previous token amount is the current amount the previous p amount and the previous count route is the current encounter and now we notice uh i can safely move to the this new state that the program outputted what it does say it's that simple maybe maybe it's not simple it doesn't look like very simple right now but it's a very small contract and the cairo is not that big okay first of all i want to i want to answer some if you have some questions i'd like to answer them now before we move on to the next i want to show you how to use the amp demo so if you have some questions now i'll be happy to answer let's see um start from the last question can you paste the after scan link for the transaction that resulted in okay we can uh this is the fact we can look at it we it's the job key i don't think we we provide the transaction hash itself when we run the the demo soon we will have swaps in there i think but we're going to use the cargo shark status to see what's up with our job well it's processed means it's currently in our approvers and i can fetch it later and send it the transaction itself but then in the mm demo we'll see it better i think hey what else is there a waiting period for finality similar to optimism well no as as you saw in the solidity contract once we we have this straight transition we know we can move to the tweet there's no finality because there's no way this proof is wrong it's cryptographs that we correct and can do this move to the new state will current web 3 walls be able to independently verify these proofs we need but first verification is done on ethereum everybody can do the verification the verifier is open source everyone can verify this proof we are putting it as a fact on it on robs and just because it's very easy to onboard this thing very easy to use but you can verify it's proof anywhere where is the current program running you just someone said well first of all before as you can see you can see i ran it locally before the car car program it runs here and it also when we send it we all already send the result of the run of the cover program uh if you are asking about proving then yes it is we are proving it on our machines starcraft machine on aws yeah um also we have a playground if you go into our site and there is the car playground which you can just play with things right run compile and to sharpen so on a very easy ui you know site what else can we verify signatures yes we can verify ecdsa signatures for our curve this is the acdc built-in that they mentioned before you can again look at the tutorials you know our site to see how it's done it's not complicated if you want to verify you see the same on some other curves then it's going to cost you can propagate events from l1 to l2 and 2 from l1 well basically the interaction with l1 is like i've shown here you if you for example want to output things from a l2 to l1 then you can add here some some list of a or something like this which will be some list of numbers and and then after it's updated you can do some for loop on these events and process them here and you can also do it in the other direction by uh start your screen yeah yeah thanks um yeah i liked it before i can add in the output some list of events and and then read them here do some follow-up in the contract in the program output and read them i can also do it in reverse which is a bit less intuitive but it's like in another incoming events i actually need to uh guess it here and i was not interested so kind of uh get it as a as program input we we guess what um what we will get from a from the l1 and we put it in the output and here we verify that these guesses were correct we probably output we read this incoming events array and we verify that it's indeed what we set we can only see your terminal we can't see your code right now really oh god now now we can see yes now i can see okay okay sorry it's going bad yeah um yeah these are the things i i've added to the outputs like this [Music] and this is how we we can communicate between the cairo and the like l1 ethereum we have good things we can ask the outgoing events and uh the incoming events that we guessed if we can process the outgoing events and do something based on them and we can verify that the incoming events are correct there may be something that we saved in the storage in this state and it would be up to the guy that uses the current run to give in the output input what he currently sees on the theorem so if for example i want to send something i might add a function in my contract and function send to l2 and what it basically does is push some something to the state it will list the state then a third party will do the current one and say hey listen in program input i'm giving you a there are incoming messages incoming events you need to take care of i see it because i see ethereum you can see what's going on i send it to sharp sharp puts effect and then i call update state with and program they give the incoming events then i can verify oh yeah this is indeed what i sent you i i what i have my storage so i pop them from the storage and and this is a good fact okay uh okay third party is you okay it's not a third party it's the first party or something it just it's uh the guy who runs the carol run basically needs to look at the theorem and and what he needs to read from there and do the current one as we know waiting yeah unless i haven't answered one more question because i don't have time to know that the input is correct correct in what sense i can give any input i want and get an output in return this is just a stateless thing i think i prove just a it's a fact that says hey if i take this program and give it some input then i i can get this output this is a valid output the person that is the needs to validate this output is the contract like in this in this lines i verify that the output indeed corresponds to something in the current state in my storage in the contract and i can verify other stuff i can verify here the incoming events i can verify here everything when you call cairo money to provide the correct things from from ethereum but the verification happens on the contract after the fact is written after everything is submitted the chart finishes and then you call up the state with the program out of the claim is correct and this verifies that the previous state corresponds with the l1 state okay i'm done uh if you have more questions you are welcome to join our discord and you can see it in our site you can email me and i'll be happy to answer questions thank you very much thanks so much shaha and ellie um for the really great session and yeah i've kept a note of answered and i will post them in the sponsor star queer channel discord and um yeah the stalker team will get on answering those but yeah thanks everybody for joining the session and have a great day 