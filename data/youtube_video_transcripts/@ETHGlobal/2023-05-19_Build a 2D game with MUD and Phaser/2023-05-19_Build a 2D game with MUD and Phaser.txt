foreign [Music] and welcome to the lattice Workshop build a 2d game with mud and phaser joining us today is kushaba who will be taking us through this session and with that I'll pass it over to kushaba to get the session started hello everyone so I don't know if everyone here was at the the react starter kit um or the react Workshop yeah the react Workshop was just focused on productivity tips to like get going quickly with react um this is going to be that but focused more on 2D games in the browser with phaser which is a typescript based game engine um I'm not going to try and focus too much on like writing actual game systems because they have like a ton of edge cases they get really hairy really fast um I want to get dip into it a little bit if we have time but I'm mainly gonna just try and give you a bunch of tools like I have a very opinionated starter kit that I have put into mud um which is like the phaser template if you do if you use create mud um it's like I suggest you use very specific tools you let lay out your Sprites in a very specific way like it it tells you how to make tile sets but if you do all these things it'll just let you prototype your app really really quickly um it also looks like people are rolling in so I'm just gonna not Super Start this second um but again just a disclaimer if you have no experience with phaser it's totally fine it's like a very lightweight engine um it's more of I guess just a bunch of tools slapped together and you can use as much or as little as you want and then at Mud we've created a layer on top of phaser to help with making basically infinite autonomous worlds because if any of you have tried to make like an nmo before with like thousands of entities on screen if you just blindly render them to the canvas you will crash people's browsers so our tools basically make it so you don't hit massive performance issues when you're when you're making autonomous worlds um so yeah I would suggest phaser if you just want to get going as quickly as possible just like get something on screen and get it playable it's like minimum viable looking good and playability um all right I'm just gonna get going let's hope everyone's here so I learned from my last one I'm super zoomed in is this good do you think this could go bigger yeah that's good yeah that's good that's good okay okay so once again I have this teaser starter kit this this phaser starter kit is just the phaser template clone from create mod so you can you can use that yourselves um I am going to broaden bug dab so I have nothing in here right now I have no systems I have no contracts the only thing I do have is a pre-built tile set so you can see there's a bunch of grass on the screen here um or it's supposed to be grass doesn't look super great but the creating the tile set is outside of the scope of this Workshop I would say I use this tool called tiled t-i-l-e-d we'll post a link later um I believe it's free it's open source and we've built some tools into tile to help with making tile sets and importing that into phaser so that tile set is created let's just take that for granted here um and I've configured phaser to like use that grass tile as the default tile set um so if I go over to my trackpad here to like scroll around this is basically an infinite scrolling canvas at this point and we with the tooling that we've created means you could just scroll forever in any direction and it'll just keep going and it is like unrendering the tiles that are off screen so you just have a viewport and as long as you stick with using our tooling only the things within your viewport will get rendered and you can technically have an infinite World like an on contract infinite World where there's entities at like thirty thousand thirty thousand and negative thirty thousand thirty thousand and they can exist together and people's browsers won't freak out um cool so today um we're just gonna really great goal like if we if we get it done very quickly is like a player can spawn we render a Sprite for them um they have some attributes associated with that player they can move around maybe movement is gonna get tricky um and then also we seems like a little more of an interesting map here because and I'll go into some strategies on like how you can make a map without like massively blowing up your contract storage um and also quick plug if you want to see all these tips in action we're running the sky stripe play test tomorrow which is the game we're developing internally at lattice and it uses all the same tools that I'm presenting today it's just been in development for like I guess like eight months now um and we're just like really pushing the limits of what's possible in an on-chain game it's a it's an RTS game if you know what that is um so check it out tomorrow at uh 10 30 Eastern Time um if not whatever it doesn't matter let's just make this okay so first things first let's add a position table I'm gonna assume you're familiar with the basics of of mud configuration at this point um I'm also going to be cheating a good amount during this like I can't be live coding all of this especially with the game systems like so I have like the the completed project elsewhere that I'll copy paste from um okay position is going to be X X and Y we're not doing a 3D game so there's no z um I generally use int32 because it just plays really well with our Infinite Canvas like you want to be able to go negative or positive in every direction and I know it's not like infinite it's like like in 32 is like pretty well bounded but if you're going beyond the bounds of in 32 like chances are players aren't even going to be interacting with each other so it'll be okay um cool so we have the position configured um once again this should Auto generate the position table let's just check yes okay position table was generated so let's make sure a player can spawn into the game um I'm not going to focus too too much on this but they just we're gonna have the player like give an X and Y position for spawning now first thing we're going to do is we're going to turn the players address so I'm going to assume that every single address that interacts with this contract is a player and this could mean like a smart contract or like a traditional wallet um so anytime you call spawn whatever wallet you use to spawn that's what's going to spawn and like your address is then forever going to be considered like a player entity in the world okay so let's do player and I've gone through this before but like this is this is a a silly thing we have to do in mud we have to use our internal message.sender function because we like we use our own message sender internally within the mud framework to track things so you need to use our message.cender which sets the sender that you are expecting basically um and then just for the sake of getting this working we're just gonna We're Not Gonna check anything we're just gonna set the position right here of the player um this does mean without any checks that of one wallet could basically spawn multiple times and teleport all over the map we will fix that later and we just have to import the position table from the code engine cool okay keeping is very simple so we can get straight into like the TD of the 2D portion of phaser so if we check over here everything is running correctly and the mod Dev tools okay so first concept that I want to introduce to this this phaser starter kit is we have client-side systems that are running um they are sitting in the background always and like listening for changes in client state so this first system we're going to write is going to listen for new positions to come in and in our in our world the only thing that has a position is a player so we're going to create a client-side system yeah so it's in this folder um there's two layers to the client there's the network layer and the phaser layer Network layer has anything to do with transactions you know um communicating with with the contract phaser is everything that stays local um we have registered systems here let's create a new system create players system now there's no specific uh naming convention you need to use here I just generally do this um this is this is the special thing that's going to get you what you need you you are importing the phaser layer and this is going to give you all the information you would expect to to have so since we um declared that position table on contract we will have the position available here first you have to go to the network layer then you have to go to components and grab the position okay so now let's define this client-side only system um first thing I'm going to introduce you to is an Ender system so okay we have to grab the world the world is just the thing like it's a client-side representation of your entire world um then we give it a query these these queries can get pretty complex you can have there's three options there's has not has and has value in our case right now all we're concerned with is grab me all the things that have position so I'm just going to say has position now what gets returned here is so this will this function that we're putting here this callback function will get executed for every single entity that matches this query so in this case we want to create Sprites that represent every single player in our game um I think I'm going to cheat on this one because this code gets a little hairy cheating cheating okay okay second second important um feature that I need to introduce to you is the concept of our our object pool so baser is split into uh scenes by default we load a main seed for you a scene is just a collection of objects all rendered together that all interact with each other in most simple games there will be one scene and that is just this big plane of grass right here um you could have like if you have different rooms possibly you could have different scenes for each room and travel between rooms um you can also even render phaser UI elements in a UI only scene possibly um for now we're just going to use one scene just know that it's there I'm going to grab the object pool from that scene so the object's pool is our like interface above phaser if you interact with the object pool and you set Sprites and you set attributes on those Sprites purely through this object pool interface you can be confident that you will not be rendering too many things and like overload the browser this is purely a a performance saving thing you could go into raw phaser and render Sprites yourself but it will get out of hand if your world becomes too big so the first thing we do is we grab a sprite from the object pool now the object pool is set up in such a way that if this Sprite does not exist yet it will get created and it'll be blank so you just have an empty shell you could put whatever you want on it um then you take that object and then you call set component on it and in this component is basically a collection of attributes that should all get run together whenever the the thing is on screen and this callback is going to get called every single time it comes on screen so for now we don't have any animation available let's just make a rectangle and we can say rectangle Set uh you know set height I'm gonna why is no set signs yeah okay okay okay 2020 sure sure sure you can set your little Style red okay so whenever a player comes in is going to spawn a red rectangle we haven't set a position here so it's going to show up at zero zero well let's just get something on screen let's get the full flow going between the contract and the client once again I'm going to cheats second thing is we provide input helpers for you this is a wrapper around phaser input helpers and we're going to grab the X and Y um from the events that is happening important note um world X and worldwide is what you want to grab because we're in an infinite canvas you could be in the center of your screen but you're actually in like a crazy you know negative coordinate at the edge of the universe so you need to grab the the world coordinate if you've just CR if you just grab X and Y here you're going to grab the screen coordinate and you're going to be wondering why you're spawning in like a vastly different locations than You're Expecting um Ben we're going to convert this pixel cord to a tile coordinate and then we have the aisle height and tile width as constants as part of the starter kit these grass tiles are 32 by 32. and we are just uh limiting the player to not spawn at zero zero I'll explain why later now and then we have to link up our contracts Paul to our client system call okay so this is just a little wrapper function for calling our contract locally let's grab that okay so now every single time the player clicks it's going to spawn um let's see what happened so why is it not working ah right I forgot to register this system locally thank you okay so now this this system is listening in the background we've registered that click Handler we've registered that system that's listening for positions okay I've hit spawn at negative four zero okay this is not negative four zero this is zero zero but we have spawned something that represents our player cool great um the next thing I'll go into is like okay how do we actually move this player to respond to their actual position that's going to be a different type of system which is I mean we just call this a vanilla system this will trigger every time something gains a value every time something loses a value or the value gets updated so you you need to handle on your own all those different situations and know what you want to do in this case in all those situations we want to set the position of the thing to that value that we can say has position again grab the entity out of that update and I'm gonna cheat cheating I'm cheating cheat okay what are we doing here so we want to grab the the on-chain position of the sting we want to take that that on-chain coordinate and convert it back into a pixel coordinate so the the thing that we did with the the pointer event we want to do that in Reverse to get it back into the phaser world and then we want to grab the object out of the object pool again and so if you want these to act on the same entity you just need to pass the same entity in the first argument here um and like okay we have to change this to rectangle otherwise it was just going to grab a different thing that we can do later okay so now um since I didn't limit spawning to only happen once I believe I should be able to just like repeatedly spawn on this player and move around the screen yeah so there you go so every time I click it's sending a transaction changing my position this client-side system is responding and moving this red rectangle great I hope you can see how like with these simple pieces together you can start to create a world where above like thousands millions of entities are constantly moving around and your client is just responding to them live um okay next thing is let's make this not a rectangle let's make it something more interesting let's make it an actual animated Sprite so this assumes you have animated Sprites laying around I believe they said uh the eth global set you can just use Sprite packs that you buy online I suggest the website H dot IO it is like very very cheap Sprite packs you can get something for like five bucks that does professional looking I use it all the time um I have a spray here that we made in-house it's a little Golem character guy um we are going to hop out of the actual phaser client and I made an entire art package that is the only thing it is designed for is getting art into your game so two okay it's like at the top level of our package we have our client contracts we're going into art we're gonna go into Sprites and in Sprites the folder structure is totally up to you and in our case we're just going to add a Golem folder and we are going to add in our Golem Sprites it assumes that they are numbered sequentially and they are yeah it's just a frame by frame sprite animation we drop those in there good okay once those are in there there's a special command you can run inside of the arc folder export so what this is going to do is it's going to take all these Sprite animations let's I mean there's only one but let's say there's hundreds of them it's going to slam them all into one PNG and it's going to export an atlas.json it's called which tells phaser where in that PNG to look for all of your animations this is just once again a performance improvement over like loading every um image individually which just like takes up network resources it is way faster to just grab one massive PNG load it into browser memory that can get cached and you're just searching through that over and over again so we run export if everything looks good it will get exported grades then we can come over to our client once again and okay the first thing you'll see is it generated this this Atlas file we can see our Golem in here I mean it's so tiny but trust me the gollum's in here yeah and that's this massive Json blob that you'd never ever ever want to edit by hand don't don't do it I don't suggest it so what this gives you okay now this is this is getting into the weeds a bit but this is this is necessary you need to come into your to your constants here and just name this this animation whatever you want we're just hooking these things together now so we have a Golem animation tool and then there's this file configure phaser this is the massive massive file for all the things phaser related I am cheating once again here is the Golem animation pre-created um slightly different key so this matches what we were talking about before it's like there are four animations zero through three that's the name of their frames you choose a frame rate and you point it to the the folder structure that you're that it's in why is this complaining ah I know we make them strings okay so if you've done this correctly that animation is now loaded in internally into phaser but we still have a red square on screen how do we actually get that to play uh let's change this from rectangle to Sprite first of all so now it's a spooky green box because we have no texture associated with it this is your worst nightmare um if if you forget to link things up your game will be littered with these green boxes don't let it happen um now we can just go Sprites dot play animations Gollum there we go we gotta Golem cool and this didn't need to change because we're just changing the position so man I'm really running out of time yeah game Game Dev is is a little more complicated than uh making a to-do list so it's tough [Music] I think another really important thing I could tell you all right now is how to render a more interesting map because we just have this this boring ass green background here let's get some actual texture on the map let's create a new system create map system okay so not only do we have an object pool for you we also have a virtual tile map the reason this is different is that the object pool is for dynamic objects that can move we can do even more crazy optimizations with tile Maps because they're not going to move the map is not going to to change if you do want to change it is possible it's just a little harder but this is very very useful for like backgrounds that are just going to exist and you want to infinitely scroll through them and be performing let's grab scenes Main ah I believe it is tile map I'm cheating I'm cheating I don't remember okay ah okay so what are we doing here so we're going through run to the main scene we're going through all the maps we're grabbing the main map technically you have multiple Maps per seen as well once again probably not gonna need it if it's it's a simple uh prototype project but it is possible to have multiple Maps loaded at once the put tile at function is just going to take a coordinate and the the type of tile that you're you're putting in um I grabbed this like simple noise package from npm I'm just going to create some natural looking um variation of terrine for us and this tile set here this is auto generated by that art package I was talking about if you want to see how that's generated you can go into the art package check out the readme it goes into like how to generate the tile set and tiled but for us it's just a simple tile set of three different extras grass mountain and forests and it's just going to go through an arbitrary number of tiles and add tiles to them and let's register this system locally reload there we go oh yeah we got such an interesting map and once again we can click around and change the position of our guy because I did not let it spawning man okay kushaza what what do you think in three minutes should we just go to questions I don't think we have time for another yeah just go to questions yeah okay I wish I wish I could get more done um I'm down to stick around if people are but oh also someone was asking for the uh the repo do you have a link to the repo oh I do but the the it really ends just like the base phaser template that you get spit out from create mud um and that even has like the tile set in there and it has like example Sprites uh yes you get the Golem Sprite for free go crazy make a Gollum world we also have Sprites available for people if you're really starved for assets we have thrown any questions we may I'm not sure how long it would take you to do it but maybe maybe you have some time to go through what you're wanting to do yeah yeah I'm down stick around let's let's just go for as long as we can bonus time yeah more more bonus features so let's make movement that's the easiest thing to do right now so the cool thing about adding movement to this game right now is you already have a client system that's listening for position so if we just add the contract movement system it's going to just get picked up by our normal um the the normal client-side system that we have before uh let's go back into our contract player system also I'm gonna all right I'm gonna add some checks to players that you can't spawn more than once or else this is going to get confusing yeah but we have a question from Francisco uh would you be able to generate the world based on an input um yeah yeah you can I mean so right now the world is purely client-side so yes you could generate this client-side world based on an input um if you're talking about contract side that's a little more complicated right um there's two strategies we've gone with in the past which is in opcraft we have purlin noise running on chain and every single time you go to a location and you want to act on it it has to run the purlin function for those X Y and Z coordinates determine what is at that point and then grab it then so it's like lazy evaluated Maps um what I do in Sky Strife because it's a more complicated game it's like a more strategic game is we literally upload state for every single coordinate in the world that describes what is at that point it's pretty bloated it's very gas and efficient but it allows you to make a very interesting world that is more handcrafted um if you want to generate worlds like that where it is like a handcrafted kind of feel we have this concept of post deploy and this will just get run every single time you deploy your world right after World deployment and you just go crazy here create custom maps if you're even further interested I can show you the wacky system I've developed with Sky Strife where we actually have a visual map Creator but definitely don't have time to um explain that now I hope that that answered your question there's a lot maps on chain are like a loaded topic I would say so I'm going to steal some things from the uh the spawn system I wrote before so okay a few key things one we want to make sure that the player cannot spawn at zero zero because zero zero and solidity land means you don't have a position um I'm avoiding adding an on-chain index to like figure out if um you have the position table so we're grabbing the player we're grabbing the player's existing position we are requiring that it's zero zero meaning you haven't spawned yet cool then we're going to check are there players at the position you're trying to spawn at this requires a module a built-in mud module called keys of the value what this does is every single time you update the the position table it's going to store an on-chain index of that value hashed to The Entity that is at that value so you could do things like and ask like hey what is at one one which is an incredibly helpful query to make on chain otherwise you can't prove or disprove that their things are blocking each other geographically so we have that installed so we're just checking have you not spawned before and are there not players at the position you're trying to spawn otherwise go crazy small think or hot reload probably died that's start that over now I'm gonna all right I'm gonna stop live coding I'm just gonna start grabbing stuff okay so here is no that's a portion of it oh man I went crazy before and I started implementing combat too we're definitely not going to have time for that okay so first thing let's do here is let's define a direction enum mud has the ability to Define custom enums as well which is very very helpful um we're gonna grab this enum um let's make a zero like oh I always make the first one zero unknown so we can test the error case where if someone like passed in an invalid um Direction so we are accepting the direction as an argument and we have to import that direction from code gen I always do that okay so we have Direction here let's make sure it's not an unknown Direction once again we're grabbing the player and we're we basically have to make this check all the time like has the player spawned yet if not you you're not able to move eventually this could become a modifier in this system and then be reused across functions and then we're just going to simply based on the direction modify your existing position by one in whatever Direction and then set that new position here okay now we need to make sure the player can actually do that client side this doesn't require more input linking and we have to create a client-side system to make this happen uh oh man we also need to make a clock hand side constant that matches our enum when client side enum generation I know wait uh uh alvarius you're here do we have that am I just like am I forgetting because I do this all the time um World send moo okay we got moved we got spawn dope now let's just make sure the player can actually do that as part of our player system let's come in here and not only do we have we have the pointer controls here we can also link to um e-binds as well so we have uh on key press so the first thing we're supplying here is like a matcher on like did was this thing pressed that we expect in this case we're going to have W which is going to go up um so if we go up we are going to send the transaction move erection dot up great I'm only gonna do W for now because that's just annoying to to do all that so let's start this whole process again if everything is hooked up correctly we're going to spawn we're gonna hit W we're gonna move up pop open okay yep our transaction succeeded me this end of terrain hidden w ove transaction blam moves up got picked up by that previous position system that we created now it is a changing the position of the Sprite what else I mean okay let's add combat  it um we got time also okay I'll add the rest of the I'm going to turn on copilot for this one because copilot loves doing this yes yep you you are correct thank you thank you okay all right so now we should have Bowl directional movement okay I just put way too many transactions so it was jumping all over the place but as you can see we can move in any direction great all right so this is not a super fun autonomous world right now because you can't even interact with each other um also I can show this is like I mean you basically get multiplayer for free is what I'm going to try and show here uh I'm gonna spawn right next to yep so now we have two players and then they can technically just walk next to each other and if we wrote our move system correctly I cannot move down into this person please work nope I did not write a class correctly fantastic that's great demo Gods thank you ah why oh I just didn't do the check that's why right ah players at position yep so this this players that position query is going to utilize that um that module I was talking about before like the keys with the value module oh we got a good question from nunox by the way is it possible to inject State without checking tables on a chain custom map where I don't register ever x or y a coordinate but I have a client side yeah yeah you can have a purely uh purely client-side map no problem very very easy to do in phaser um that's just like you know standard Game Dev if you want a purely client-side map that also influences chain State without living on chain that's when you need to go into procedural generation and use something like Pearl and Noise okay so we're just going to check that there are no players at the the position you're trying to move to I just realized I wrote a bug there um that is not what we want we want this the new position not the existing position okay we are going to redeploy our players are going to disappear we have to spawn again okay I just want to make sure this is not broken okay one two one all right we are next to them please do not move into the other person yes and it's not working you just have to be played you decide to say please and it works yep now okay so there combat's gonna be the last thing it's probably gonna take a little bit um but this is a good introduction to like the the idea of an entity component system so if you've watched our mud talks a really long time ago we were all in on entity component systems on chain more recently we haven't been talking about them because mud 2 is technically not an ECS framework but you can Implement an ECS framework on top of mud 2. that's what we've been moving towards so coming out soon-ish no promises it's like a full-featured opinionated ECS game engine on top of mud and that's basically the mental framework that I use when I'm making new games so in a traditional like smart contract struct way of of storing things we would just add this health field and strength field for combat onto the player and that would be fine and good but then if we wanted to add something else that add health and strength we would have to add it onto that struct as well and we have to change all our client code and all of our systems to know about players and monsters you know if they both have health and strength let's not do that let's just create in our mud config um I'm gonna cheat change health and string so technically these held in strength uh tables could be applied to any entity we're just going to apply them to our player in this case but if you created other entities in your world that are just standing around waiting to get attacked like a what I got a breakable barricade or a monster um you could add these components and our systems would know how to interact with them so let me just modify the player system so the first thing we need to do is like when you spawn we need to give you these attributes and this is going to require some more Imports um okay now I didn't test this at all when I wrote it before um that was the last thing I was able to do before I had to start preparing so let's oh this works and let's just like run through what is ideally supposed to happen and if it doesn't happen we can we can debug but in this case we are checking if there's no so we know we don't want to block we don't want to say you're blocked in this case we want to say if there's no one there yeah you can move but if there's someone there then you initiate combat with them and you apply your strength to their health as damage and then if their health goes below zero or hits zero you are deleting them it's a very very simple combat system but this will allow engagement between different players and you can imagine if there's hundreds of players dactions will form there will be rivalries there'll be guilds there'll be Wars um let's hope it works okay quick check yes checks out mind you there's not gonna be any animations or anything to represent this combat so it's probably going to be very boring but if it is successful one of us will disappear that's how we know this combat system is working okay so I move once to the left I've appeared and I'm just going to start hitting left a bunch of times aha okay it is changing the health of the opposing entity ah and it removes you remove the position okay so it worked the combat worked I didn't write our client system to take into account things disappearing okay this will be the last thing we do this is actually a good full circle thing we want to it's fine and exit system so when something loses their position we want to remove it from the world then no one can see it anymore don't tell me what is the what is the method I'm looking for don't tell me remove okay that's fair and yeah the character got removed there you go you gotta the working the the first workings the very basic 2D game in a two-dimensional World um I will commit this and post it somewhere and then everyone will have access to it after the call um we could keep going but I'm very tired I've been working very long pair Fair looks like we have one last question maybe from Francisco he has his hand raised here yep what's up Francisco oh yes sorry for uh for the last question okay um you can Implement uh Maps probably that run locally inside yeah how would you implement that I mean uh you could make my ID it's about implementing a map based on an input from uh user for example and then maybe have some coordinates in the map that are points where the the user can reach and make some challenges or obtain some items okay so you so you want the maps to be purely client-side but you want the contracts to actually interact with those Maps yeah so that would be okay that is that is the realm of procedural generation like you're basically lazy evaluating the map at every moment that you make a transaction on chain and you're gonna call out to a purlin noise function or some noise function some procedural generation function in our case we've used purlin noise and we have utilities for this that we can give you later and the at the moment that the transaction is executed you're asking the noise function hey what is here now this doesn't take into account like user input that's that's the the crappy part about this is like a user can't really influence this map other than like changing the seed that goes into the noise function but then that would change the entire um so I guess you could have a mixture of generated map and also like user created things so maybe you could have a layer of the map that is purlin noise generated and then you have one layer above that which is like a user puts a treasure chest on the map they know the terrain that is there because of the purlin noise function but then the treasure chest actually exists as storage on chain and they're gonna need to set you know the position of it and the contents of that Treasure Chest that's it's gonna have to live in storage there's no way around it um but at least you won't have to store the entire map on chain like the noise function will take care of most of it and then just the user input um would have to get stored in storage does that help at all I'm gonna take that as a yes um all right we have another questions are these characters nfts how's this is very helpful thank you okay great no problem um I'm used to client server multiplayer game development for blockchain games yeah okay so if you're used to client server multiplayer game development we're literally we're literally doing client server damn development but the server is the blockchain that's it a ceiling difference um and every single time you want to take a user action it is sending a transaction to the blockchain now is this going to run on Main net tomorrow no it's not it's not going to run on mainnet tomorrow that's not really what we're concerned about here we're building for the future we're building in a world where gas is cheap where chains are fast and storage is free which we believe will be at very soon um so if you design your world in a way so that it is kind of infinite it's expandable it lives on chain and completely public you can you can basically develop in the same way you're used to um accepts the packets that you're sending back and forth take a little longer to finalize that's but that's the main trade-off you're making it's like every single time you move you have to wait at least a second for the the block to finalize okay we designed around that and yeah to go to your question like this is like are these nfts uh they don't like adhere to the nft standard but they could like they could very easily adhere to the nft standard and I we have mud modules and plugins built for the nft standard for for the erc20 standard there's nothing stopping you from doing this um there's nothing stopping you from composing these characters with other existing contracts um this just needs to be built foreign yeah just yeah any uh EDM compatible layer 2 um you know the the layer twos have their quirks but we for sure for sure have deployed to optimism and arbitrum and I correct me if I'm wrong I believe polygon and things have just gone fine um I don't have like an out of the box example with the op stack but we have an OP stack example like that you can deploy yourself and then you could take this and deploy it on that op stack but I don't have like an old bind into one though sorry all right answer maybe one more question then we'll wrap it up okay yeah one more question um Conan states can States be private based on permission Okay so it depends on what you mean if you mean reading no you can't that's that's the other big problem we have with building on on public blockchains right now is that Allstate is public it is not possible to do fob of War unless you do some wacky ZK Shenanigans like Dark Forest if you want to talk about this I can explain it later on Discord it is difficult and it's like it is possible but it's like Cutting Edge basically of gaming for now assume that all component state is readable by anyone writing though writing there's this concept of name spaces and mud every time you register a table you are telling it specifically what namespace has access to it by default they are all registered in the root name space so only the um the root like the deployer can access them um but users can create their own namespaces and deploy their own tables and then they would have access to those right access to those tables and they could give right access to other people however they want um yeah okay that is that's all we got that's all we got time for yeah a little bit of Discord um now I'll be at office hours too and yeah and specifically like I I mainly focus on the game development portion of this so any Game Dev questions at me I will answer it I am I'm passionate about uh this stuff awesome cheers for thank y'all both for the live recession and for walking us through the demos and thanks everybody else for attending so this is the last of our workshops for today we just have our team second team formation brainstorm recession in about five minutes so please join that if you weren't able to earlier and yeah this recording will be available shortly after shortly so cheers thank you thanks everyone see you later peace 