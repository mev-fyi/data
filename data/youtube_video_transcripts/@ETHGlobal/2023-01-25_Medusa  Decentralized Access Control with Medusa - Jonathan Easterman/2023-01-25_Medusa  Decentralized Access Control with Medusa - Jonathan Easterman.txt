well um hi and welcome everyone uh this is the decentralized access control with Medusa workshop and we have Jonathan with us today who is going to take us through everything so I'll hand it over to you and uh feel free to kick things off alrighty hi everybody um thanks for for joining us today to talk about Medusa and how you know you can use Medusa in your applications to manage access to data in a decentralized way um let me just share my screen foreign great and not that slideshow all right um can you all see that just wanted to confirm before I continue yeah perfect okay great so right so um right so today we're going to talk about Medusa um Medusa is a project uh by protocol Labs specifically by the kryptonet team which is a research lab within protocol Labs um I sent a link to the slides uh in the chat and so there's also a link on this front page if you want to talk to us in our Discord you can find us there of course I'm also in the global sort of hackathon Discord so you can find me it's it's at J a Easter um and right so I'm a software engineer on on this team working on Medusa I also have a teammate Nicola and he's sort of a research engineer and so together uh we build we build Medusa great so the sort of outline for the talk today I'm going to quickly just go through some slides so I'll give you the high level sort of elevator pitch for Medusa kind of how it works um and then we'll talk about an application that I built with Medusa that's called only files um to give you sort of an example of what you might build again give you a little bit more insight into how Medusa works and then we'll you know we'll play with the demo we'll sort of go to the site and uh and kind of interact with it and then after that's done we'll review some documentation uh just some key things like like smart contract addresses and that sort of stuff we'll look at the SDK and probably also what we'll do is we'll just jump into the code for for this only files kind of demo application and that will give you the best idea of what's sort of required to integrate Medusa into your application right and then I also have QA here but I think um just just sort of as I'm presenting if things come up you have questions um just sort of send them through and I will answer them as a as I see you okay so so the elevator page so I'll give kind of two different ways to think about Medusa one way is that it gives you programmatic access control on chain so that's a bit of a there's a lot to dissect there so let's just break it down by each term so Access Control what is that so Access Control in a simple way is that you can control who sees some sort of content or data um there is an additional element to that which is that you can control who updates data but um that's sort of out of the scope for now for this presentation um we don't support that with Medusa yet so it's more about uh who can sort of access encrypted data who can decrypt it and see it um and then programmatic meeting I can write these rules of who can see this data with code and on chain meaning I write the rules in smart contracts um using Unchained conditions or really using uh things that can be verified on chain in order to give access to to data and then another way to think about it kind of more broadly is that Medusa is sort of a network that uh allows a smart contract to have a private key um because without something like Medusa you can't at least on a public blockchain you you can't have a smart contract use a private key because uh everything is public right the storage of the contract is public metadata transactions Etc so you need something else um to make this happen um and of course if you have a private key you can do things like encryption and decryption um and you can also do signatures um but for purpose of our talk we're going to be talking about encryption and decryption and how that you can use that to sort of give access to data so and then you know the sort of different components that go into a Medusa enabled application application is a sort of three-fold you have on the left you have like your application um and your application might consist of a smart contract and some sort of front-end mobile app you know web web app something like that and so we have a few different examples here the first one is this only files example that we'll go into but you can think of only files as an application that implements like a simple policy which is um I upload some content so that could be um you know that could be text it could be images it could be uh audio video any sort of media or any sort of file really um I upload that I sort of give a description I give a price and then I list it for sale and then basically and when I list it for sale I basically I set a policy and the policy is that whoever pays the price that I um that I sort of I set gets access to the file that that's kind of the simplest access policy that I can think of is just you pay for it you get it but you could do other things like uh you know you could have anything sort of content attached to to nfts so maybe like holders a particular nft get access to a private mailing list or any other sort of unlockable content um you could do a decentralized document sharing platform so something like Google Drive um where you know and maybe your policy is is like uh anyone with the with the email address that ends in a certain domain so ends in your company's domain so for protocol Labs like uh anyone who has the email that ends with at protocol.ai um and and not something that's a bit more challenging to implement I think if you wanted to prove that you own an email address maybe you could have some sort of ZK proof scheme um and you could verify that on chain um that's a bit outside the scope but you I think you get the idea uh there's many different applications that you could Implement with Medusa and so in the middle your smart contract is going to interact with the sort of the Medusa contract on one of any number of chains um and really you could think of the Medusa contract as it does it does a couple things it does some sort of interesting uh uh it uses a bit of cryptography to sort of prevent replay attacks and maybe I'll get into that later but really at its core the Medusa contract is sort of like an inbox and outbox it's basically just a way for you to submit requests to Medusa and receive responses um and then on the right you have the Medusa Network and so the Medusa network is essentially uh you know a set of many different nodes and those nodes all hold you know shares of of a private key and essentially they run a protocol that says uh that they sort of receive requests to re-encrypt some data um and so re-encrypt meaning uh taking some data that's that's encrypted that Medusa sort of can is encrypted for Medusa towards Medusa's private key producer can sort of change the audience to to someone else so you know Alice can kind of say to say hey we do so I want Bob to see this file that I that I've sort of registered with you and Medusa can perform an operation to um keep that file encrypted but now only Bob can decrypt it um and so this is sort of like a threshold encryption protocol that Medusa runs and and and the other part the part there is that uh the sort of threshold part right is that you have you need a threshold or a majority of nodes to sort of see the request validate it and perform the operation before then submitting a response back back on chain so that was kind of a lot and if it's a bit fuzzy right now don't worry because I think we're going to go over it a few more times you know in the slides or in the docs in the SDK Etc but that's sort of at a high level how things would work um I'm just gonna check okay um so so only files so going a bit more in in detail into this so you only found essentially a site for a bunch of sort of secret content that people can pay to unlock or to download it and so yeah the like I said earlier the policy is that whoever uploads some content can set a price and whoever wants to You Know download that content can can pay that price and then they can they can do that and the tools for this particular demo are I guess threefold so one we have filecoin um to mainly just to to store our encrypted files um we have a blockchain and so you know we could use the fbm and Medusa is deployed on on the hyperspace testnet so you could use that um we also have it deployed on arbitrum Gourley um but essentially you need a blockchain to to write your policy in a smart contract and you know in solidity uh for now but maybe in the future in other for other platforms um and uh you need to set the rules and you also need a medium to collect payment right uh and then the last piece is Medusa which sort of handles re-encrypting or unlocking content um based on on payment being received right so now we're going to go through this is going to be kind of like a uh like a flow diagram we're going to basically just go through the flow of how you know a request and response cycle works for this this only files application so we start with uh we start with Alice who has this top secret document um and Alice wants to so to list this document for sale so the first thing that you'll do is is locally you know on her computer um using this you know only policy application she's going to encrypt uh her her secret document and so the output of that encryption will be two things she'll get her encrypted file and she'll also get the key that you know that encrypted the file and I could also decrypt it so like a symmetric encryption key and so uh the encrypted file we're we're going to set it aside for the moment but essentially she'll encrypt the file she'll get the key and the file so take the file and store it somewhere so on on filecoin on ipfs um in other places um and then for now for this doc we're going to forget about the file because actually Medusa instead of operating over the file it's going to operate over the key to unlock that file and it's kind of a subtle difference um but the the importance there why we do it this way is is really to save uh save money on gas right because otherwise we'd be emitting events or maybe even using storage on a blockchain and if we have this variable length file that could get really expensive but if we operate over the key then we just have a sort of a 32 byte you know constant uh piece of data for to pass through through a blockchain right but the kind of key ID the the the idea there is that as long as someone has the key to unlock something then it's it's almost the same as if they sort of had that file itself um but anyways I just thought it was important to point out because this gadaga may get a bit confusing just with all the keys and all different terms but just just keep that in mind that Medusa operates over uh an encryption key to an encrypted file so the next step is that we're going to take that that key which isn't encrypted itself but we're going to actually encrypt it so we're going to take the key and we're going to encrypt it towards Medusa so at this point only you know a threshold of nodes coming together could could actually view the key and in fact they won't um but but that's sort of the only way you can lock this key at the moment and so and the next step is you know so Alice has done all this locally on her computer and then she's going to submit this encrypted key to the only files application and only files is basically gonna you know in a transaction and then the sort of only file smart contract will call out to the Medusa contract and basically basically say like hey this is a new uh piece of of encrypted sort of content right so this is basically a registration step so now the network is sort of aware of of this content and then uh sort of separately and you know in another transaction Flow In Another Time Another Place Another individual Bob is going to go on the only file site and and he's going to see you know Alice's sort of content that she's advertised um he's not going to be able to see the content but whatever Alice or what description or other information you want to provide uh will be there and Bob's gonna decide okay yeah this seems valuable you know I want to pay for this I want to unlock it so Bob you're going to see the price on the website and he's basically going to click a button to send a transaction to say you know here's one eth I want to unlock this file and so uh the basically the in in the only files contract or really in the application contract you would verify sort of the policy you would check okay Bob is trying to buy Alice's document what is the price for houses document it's one eighth and did Bob pay one e oh yes he did okay that's a valid request and so um it'll then forward the the request to the Medusa contract which will emit an event and the Medusa nodes will sort of listen for these events uh to know to sort of start a new operation a new re-encryption uh sort of operation so right and so then these nodes are gonna you know they're all gonna basically receive this event at some point and they're going to sort of start this this re-encryption protocol and as soon as a majority of the nodes have sort of they sort of they've also done some validations on that request and they've decided to run it um they're going to gossip between one another to send their their partial result and as soon as one of them basically receives uh enough uh partial results of this re-encryption they will they'll be able to aggregate that into a sort of a fully re-encrypted key um that only Bob can can read and they one of them will send uh this key and a transaction back on chain um and then the you know they'll send that to the Medusa contract which will then do a bit of a look up and see uh basically find the address for your contract and call back to it and basically say hey here's the response um you know you do what you want to do with it and in this case what we're going to do is you know our application contract will emit an event so that our front end can sort of read that event um and so Bob can you know receive the the cryptic key you know on his computer or device and then now Bob can decrypt the encryption key so now he'll get the the key in plain text which he can then use you know to download Alice's encrypted file and decrypt that and so now through this you know this this whole big flow Bob finally paid for this file and he got it back and he downloaded it um and so so again that was kind of a lot there's kind of a lot of terms a lot of different Keys you know if it's a bit confusing don't worry you don't necessarily need to know all this to build with Medusa um and and for sure you'll sort of see other examples you know through code or through Reading um that that might make it a bit more clear and then quickly I won't spend too much time on on this but I just thought I'd include these slides just for extra information just give some details about some implementation details of Medusa and some links to you know our uh our smart contracts and also our SDK and also you know this more information just on the status of of the pro the project we're sort of in a builder net uh phase right so we've deployed on hyperspace we've deployed on arbit gorley we're looking for users um to give us feedback uh to build applications with Medusa and this is sort of our kind of our timeline for what we're doing next you know when we when we'll go to mainnet um and kind of what the future of Medusa might look like okay great so so now I'm going to switch over to uh actually we'll go to the demo but so this this whole this only files thing I've been talking about let's let's kind of see it uh so we'll go here and right so you know not not the prettiest uh front-end sight uh but but mainly here to exercise um exercise Medusa just show you what it can do so at the moment um I'm actually on the sort of arbitrum network by default and the reason for this demo why is this because uh there's faster block times on on Arboretum and so you know whereas hyperspace is like a 30 second block time so that would kind of take us a while to get through this so I'm just gonna do it here but if you want to use it um this application arbitrum you can sort of enter this parameter or sorry on on hyperspace you can enter this parameter it'll switch networks for you um great but I'm not gonna do that now so let's go through here so basically uh what we have here is we have a form so this form is like to to upload a file so let's let's do it so we'll upload you know this this picture from stable diffusion which is like an astronaut on a horse right so we've uploaded it we're going to set a price um or sorry we haven't really uploaded anywhere we've just sort of loaded it on onto the page we're going to set a price I'm going to put .001 East um I'm going to set a description you know this is a pick of an astronaut worst one of you know want to advertise correctly there and actually I missed a step and maybe I let me just go back uh briefly so I've come my wall it's already connected to the site normally you'd have to disconnect your wallet and so the next step is you want to sign in and what signing in with Medusa what it really means is you're gonna sign you're basically just gonna sign a message and from that signature we can sort of deterministically derive a key pair for you and so if you don't really know what that means don't worry you don't really have to um but if you do the reason why we do it this way I mean you probably see the other places as well but if we do it this way this means that we don't have to store any extra keys for a user you know over time basically as long as someone has their you know a scene phrase to sort uh to some sort of private key and they have sort of like a web through wallet like metamask or you know or something else then they can just sign a message and we can always reconstruct their Medusa key um so it's nice and I guess we don't add any extra State nothing to sort of keep around right so so we've signed in um now we can so hit this button to sell the secret and what it's okay that's interesting always live demos uh something new okay so we'll add you know what I'm gonna make this I just want to make sure I have enough eth here I do okay so I'm gonna make that money uh or actually just for anyone else you know I'll make it zero that's gonna make it free I said you just have to pay gas fee to do it so it'll be free um we're just we're gonna sell it so first it's gonna it's just encrypted it it's gonna upload that encrypted um file to ipfs and then it's going to ask me to once that's done we're gonna send a transaction to Medusa um to sort of register this new ciphertext as we call it but really this new file great so that's done and so now we should be able to see this is my unlocked content but down here okay great this is sort of this is what we um we just uploaded and then there's a button here to view an ipfs but it this is encrypted at the moment uh we can't decrypt it yet so if we click that we're going to have a link to something that can't render because it's just sort of encrypted you know uh garbage right so but now let's let's unlock it foreign what we're doing if you remember that other diagram we're sending a re-encryption request and basically we're we're gonna send the eth which in this case it's free so we don't have to actually send anything this will be a valid uh request and now we should be able to scroll up and see it here is it does it want to download did I have some other error there it is okay so in that sort of uh that delay there is basically downloading the file um decrypting it and then it's displayed it here so that's sort of the flow again it's kind of a simple rudimentary demo but it shows you sort of what's possible um great so that's that and just let me just make sure okay um so now I'm going to go over to this documentation site so this is docs.meducinet.xyz um let me just throw that in the chat for if any of you want to kind of follow along and look at this later great so from here I'm not going to you know go through the entire documentation end to end I think a lot of what I said will probably be repeated here but I'll just go over some of the important tidbits I guess first there's this about page this gives again kind of more of a higher level and it also goes a bit deeper into the cryptography behind Medusa if you're interested this will give you kind of a fuller picture if you really want to know exactly how everything works but if you just sort of want to kind of hack something together then you come here to this kind of developers Tab and so the first thing that's important to know or sort of the I guess parameters for interacting with Medusa um so you have arbitrum you have filecoin and the respective test Nets here so you know you have some links if you want to see it on a block explorer that uh you have that but really what's important is this Oracle address um this dkg dkg address is not uh really that important for developing but just for those who are interested uh to sort of create this shared key amongst different nodes we run a dkg which is a distributed key generation process and we do that on chain as well so we use a Smart contract to sort of an intermediate yeah intermediate a mediator uh for for the dkg process so yeah so you have Arboretum growly you have hyperspace um and then we'll look into some of the details of the contracts for for Medusa so um this isn't too important but some of the yeah the data structures I suppose that that we use we have this notion of a ciphertext and a re-encrypted cipher so the ciphertext is sort of what gets registered initially the re-encrypted cipher is what is really the response of a successful re-encryption request it's what's created when something is uh is is unlocked by a user um and and we have I'll mention this here we have this sort of a d-lac proof a really a proof that we attached to ciphertext and what that does is it basically it um if we didn't have this then then you could replay another person if they want to unlock some content without paying for it or fulfilling the policy they could replay uh the ciphertext and sort of register a different cyber attacks that is the same data and basically claim that it's theirs and then they could you know uh they might be able to unlock it that way but we attach a proof to it that basically says this ciphertext is is tied to um an address the the sort of original encrypter okay here we have sort of an interface for the encryption Oracle and again if you want to see more of this code it's the links in the slides and I'll just uh I'll put it in the chat maybe in a second um but this is sort of the interface that that you building an application the the methods that you would call on Medusa's like encryption Oracle contract um and really the two important things are submitting a ciphertext so that was that you know that's basically registering a ciphertext with Medusa and then later uh requesting re-encryption those are really the two important methods that you would call and uh right when you're registering cyber attacks you're going to give decipher as well as the encrypter I sort of mentioned that about the D like proof that sort of ties the ciphertext to an address and then when you're requesting your encryption you're going to give an ID that you know that you would uh that you sort of is created when a cyber text is is registered right and then you're going to basically give the public key of of of Bob or of whoever you want to request uh re-encryption for so whoever is going to eventually unlock this data you provide their public key right and then in your client and the your smart contract that you would build the only method that you need to so you need to basically call at some point you would be calling these two methods and then you would Implement a you know a method which is it's called Oracle result it's basically the Callback that you know once uh I do says re-encrypted some data it's going to submit it give you a response back it's going to call this method right and so we'll call this method and it'll give you the request ID what the Callback is is being is being made for and it will give you the result this re-encrypted Cipher that your user can then use to you know unlock some content um great and then uh I think yeah we have an example contract here so this is kind of this so this contract here is kind of a stripped down version of this only files uh contract but it does something very similar and so we're calling it debate like a decentralized eBay here and uh we'll sort of just go through um we'll go okay so we'll just go through it so yeah so you you start with you have the address of the Medusa Oracle um that you're going to call to and so remember I'll just go back here that would be one of these two either this one for arbitrum or this one for hyperspace um and then you know you need to keep some storage in your contract like for if someone's creating a listing you're going to keep some metadata about that listing so like the price maybe a description in this case we're just keeping the price so we're keeping a mapping of a cipher ID which is kind of like maps to one piece of content and someone could buy to the price for it um and then you really have like I said you have three methods here you have this submit entry so this is like when someone's creating a new listing they create it and you know what we do is we sort of we call out to Medusa and we register this new ciphertext with Medusa and then we also store the price that the created the upload of the content uh decided right so we store that for later um when so that when someone buys goes to buy it we can look it up look up the price and make sure that they pay the right amount and so that's down here in this this buy entry function where right we like I just said we look up the price uh and this is actually a bit of a bug this listings should actually say item to price uh but anyways we look up sort of the price by the cipher ID if you know some if the person is buying it didn't didn't pay enough then we would revert and after we've sort of checked our so this is this method really is like you know it's this is the example of checking implementing your Access Control policy and checking it right and so once you've checked it in your contract you then call out to Medusa and Medusa handles sort of the re-encryption of this data right um and Medusa does do some additional checks but really the only thing additional that it will check is that is that um the cipher text that your contract is asking to re-encrypt was originally submitted by your contract that's sort of the only check that we make and all any other policy that you sort of want would be implemented by and you know in your contract in your application um great so once we you know we request a Medusa to re-encrypt we're going to get a request ID and in this case we're sort of returning these things but I think to in develop in an actual application you'd want to admit an event so that your front end could uh could sort of consume it and use it right so in this case if someone is submitting an entry we probably want to admit an event so that we can show you know show it as a listing uh down here in our in our uh in our app right and then um you know even here if someone is as paid for an entry and there's maybe they're waiting for a response to come back you probably want to give them some feedback in your application so you would do that through by emitting an event of you know the relevant probably the relevant ID and maybe any other metadata that you might have um and and for sure you know we sort of do that here in this last method which is this Oracle result which we said we had to to implement it's sort of in this is from this interface [Music] um so so we do that we do all we do something very simple we basically just we receive the response which is you know the request ID that the response is for and then um the cipher and and again this is a bit of a bug this this type here should be uh the re-encrypted ciphertext um but because this the cipher represents the response right and and this is also important as well I don't know if we include the modifier but of course like to keep your contract secure you really only want the uh Oracle to be able to call this method so you know you should have some sort of modifier or some sort of check that whoever that only the Oracle can send this to you right and but what we actually do in it is very simple we just emit an event that our front end will consume and we basically say for this uh you know for Bob's request uh here's the response great so let me just check uh I think um you know we're sort of I've gone a bit longer than I thought I would just going through that um so let me just answer uh there's a question here can the files be re-encrypted for a period of time um that's so you're sort of asking if uh if at some point you know access could be removed uh in the future it's it's something that comes up like like whether you can revoke access or like you said for a period of time and then the access is gone it's it's very it's it's kind of a difficult question or it's not a different question but it's a difficult problem um because you can imagine like as soon as you give someone access to something even in sort of a web 2 setting right they could always download that data and sort of have it forever right and and it's kind of similar with with filecoin like you know you can encrypt something and you put up on filecoin but depending on what storage deal you've set up everything like that file may be there for a long period of time so once you give someone a key to unlock it it's difficult to be able to revoke that key but we have been thinking of so I guess to answer your question in the core Medusa protocol that's no that's not part of the protocol but there may be some things that we can Implement on top of Medusa um to sort of to implement this like this being able to revoke access or only have something access for a period of time um and that might include you might need to use some other tools like maybe like ipns or some other way to deal with like mutable content or or another way to introduce like a another layer of indirection so that you can kind of remove access later but um maybe we can talk about this more uh like uh like I said you can time in the Discord so maybe we can chat more about that because it does come up it comes up quite often it would be really nice to have and we're thinking about ways that we can make it work um all right so so I'm gonna wrap this up because I think uh I'm over time at this point um I just want to see if there's anything you know if you want to see uh how to use the SDK there's a couple of pages here this encryption didn't use a decryption from Medusa um there's also uh like I said the SDK is here and I'll put a link in the chat so you can also go uh you can also see it here um and there's a little bit of an example of how you would use sort of the different things the sort of three key operations that you need to do are really just getting the user to sign to create a signature for you so you can drive a key pair for them and then you're going to basically encrypt uh you know you're going to call this encryption method which gives you your encrypted data your encrypted key um and then you know at some point you need to save that encrypted data somewhere that's not in the SDK but you know you can imagine you save it in filecoin and you sort of have a sid a CID and you keep track of that maybe in your contract as metadata and then the last operation is decrypt right so given you know later someone's gotten a response um you can basically put in that ciphertext the the re-encrypted ciphertext the encrypted data and then you'll get some plain text out so that's kind of in a nutshell what you'll do and so I guess the point to show you here is like the SDK there's not that many lines of code that you actually need there's maybe like three to four um and then when you write your smart contract I mean you saw an example here this was quite short you could have a more you know Advanced or more complex policy for sure but ultimately um you know at least you can sort of write those rules in in solidity something that hopefully I think a lot of you are familiar with rather than you know a different DSL or something along those lines but anyways we have more questions or want to talk more um then we can we can chat in the Discord um so yeah thanks thanks everyone for for listening thanks so much Jonathan that was great and if anyone is looking to connect uh with them again I will tag all of these links and um you in Discord and everyone will know where to ask more questions so thank you so much for your time and appreciate everyone popping in for this workshop and have a great day all right thanks everybody bye 