[Music] [Applause] [Music] uh my name is alexey or cloudhead i'm one of the founders of radical which is a stack for peer-to-peer code collaboration sovereign code infrastructure and um and yeah today i'm just going to kind of talk about how it works uh how to use it uh what we've got what's coming up etc i've tried to fit everything in in 30 minutes but uh if you want to know more you can go on radical network um and and you know i'm basically going to sort of go through the get started um stuff and put a little bit more and some explanation of how everything works um so first of all um yeah what's the idea so the idea is is essentially to create um a decentralized alternative to something like github so a way for developers to collaborate on code and to publish that code in a distributed peer-to-peer way and so to to achieve that we we created an architecture that is quite a bit different from the the traditional uh you know client server architecture uh and i'm i'm gonna talk about that a little bit but um first uh i wanted to just kind of actually go through uh the the steps in creating a radical identity and and uh project and all that stuff just so you kind of get an idea of how it works and then i'll explain a little bit um the the actual architecture of it the design and the inner workings so the first thing is um yeah so the [Music] the way to set things up is via cli so that's kind of the onboarding uh we do is via cli so i've already installed this because otherwise you're you would have to wait 10 minutes for it to build um but essentially uh there's a there's a brew package that's slightly always behind master and then there's a you know you can also download from source so i have this installed locally and it's called rad radical and if we just type it like this you'll see a list of commands um and it's also going to tell us that you know this is the first time we're using radicals so to get started um type red auth to authenticate so i'm going to do that and this is essentially going to ask me to create an identity and these identities are completely owned by the users so they they live on your own device and then they can be replicated to other devices so you kind of own this forever and um i'm just gonna fill this in and so this is gonna i'm gonna create a key pair um and so the the passphrase is really passphrase for the key pair so the the keys the private key is encrypted and it's telling me okay like you have a peer id which i'll explain but essentially it identifies this device so my laptop in this case and a sort of personal urn which is multi-device so it's kind of my user id that is across devices um then it's telling me okay let's um you know you can initialize the repository uh uh initialize the radical project from git repository with rad init um and so what i'll do is uh so i have this this folder here with a bunch of stuff and i'm going to um uh get clone one of my projects from github so do this and i'm going to initialize a radical project from this github project essentially so you can clone any git repo we're going to go inside of it uh right just a regular git repo and then i'm going to call red in it um i'm just going to go back here and uh project name so this project is called rx it's a pixel editor written in rust okay cool i asked for default branch master all right it's going to initialize this now it's going to ask me whether i want to use my radical signing key to sign commits and i'm going to say yes because this is going to well we can do pretty cool things when you're when when we use our radical key for signing commits like link it to ethereum and uh to the rest of the radical ecosystem so i'm going to say yes you don't have to um and okay so the project is created it's giving me a project id which again is in the form of a urn rad git plus some unique identifier and um i can now um yeah i can always show the project i like this and i can also now push this project to some remote and um so let's see what this what this says okay you can see this so it's essentially saying okay select a c note to sync with and these are essentially remote servers that kind of constitute a peer-to-peer network and um users can choose where to push their code and you can also have your own seat node but since that's not set up here the cli asks you if you want to push to one of the sort of public nodes that we operate ourselves so with the the foundation operates um so i'm going to pick a um i'm going to pick a node i might have already no yeah i'm going to pick this node um and so it's it's gonna do it's it's its thing and now it's um so a couple of things it's in the output here um we're using again this uh this radical key which is also an ssh key so it's compatible with all sorts of ssh things um okay syncing the project id we see that it's syncing it to this seed node here and then when it's when it's done it's telling us that we can view we can view this project online through a web interface so i'm going to um i'm going to copy this into uh the browser i have here um and so that we can check it out so so this is the project and so this is this is essentially a um a web front end to uh the the radical network and um the interesting thing about it and it's kind of hard to see um but um the the code here is actually being loaded from the seed node i pushed to so it's this uh this web front end has actually many backends in the sense of any seat node can operate as a back-end to this web front-end and you can actually see here it's going to look very small but the the seed domain name is up here and i can put any seed in here and it's just going to load it up and show me the code from there um in in the in the interface you kind of also see if i zoom in the name of the seed here which is telling me hey that the source code is actually being fetched from from from the seed and if i click on this um i'm actually going to load uh the the actual seed node um so the seed has a lot of projects it has the one i just pushed i was testing the demo so it's kind of two separate projects with the same name but there's a there's a lot of stuff on here right um and uh if you go to um for instance on the on the main page you can see that we have our seat nodes here uh the ones you can choose from and we can browse them and uh right if i go to um to this test project it says it's loaded from here and so all of the data is coming from that different c note so you can have your own seed nodes that host your own code and it all kind of interrupts with the same ui all right cool any questions so far otherwise i'll keep going yeah so i mean obviously you have your code on your machine also ideally um you can also push to multiple seed nodes there's nothing wrong with that and uh we're also working on a peer-to-peer network for c nodes to replicate data asynchronously between them so yeah the idea is that um your code is going to be in a bunch of different places yeah uh cool um yeah so let's let's go let's go back here um so let's look a little bit at how some of this works um so radical is obviously it's it's based on git and um we use git not just for for code uh like like developers but we also use it to store um all kinds of artifacts so things like the these identities that i spoke of and so um yeah let's let's look at what that looks like so i'm i'm inside this this project rx right um we saw that if you do rat dot you can see the project id we can also do um uh this is kind of just an alias but we can also say hey let's look at the um the the history of this um project and what this is what this is gonna output is is not the source code history but it's the history of this identity and identities are super important radical because it's kind of what let's it's what lets you have projects hosted in multiple different places but in an unforgeable way right so um you know if you have a uh if if we compare this to the github model or github gitlab model um if you have the same project on github and git lab well there's no way to tell that it's the same project right they're two completely different it might be the same code and the same repository but there's nothing that allows you to say that oh these are owned by the same person right or that the username on on one system is the same as the same person as that username on a different system right so the the radical identities kind of solve this problem by um shipping this this document which is just a really adjacent document that is committed inside of git but not in your source tree um and is signed by the owners of the project or the maintainers and so if we look at this um this json there's there's this thing called delegations and delegations is essentially uh signers it's like it's it's users who can sign on behalf of this project essentially and if i do red self this is going to query my own user identity and you can see that my urn matches the delegation here so i as the creator of the project i am the first delegate essentially and then the payload is um you know the stuff i filled in so name description etc and you can see here um this this key which kind of points to a previous version of this document so these documents are upgradable and uh and they work kind of like a multi-sig so right right now if i want to change anything about this project i can um just do an update because i'm the only signer but if there's if there's multiple delegates then we'll have to to have a quorum of signatures to update the document and then a a second update will a second document will exist that will point to the previous one um cool questions i'll keep going uh okay so what are the other things i wanted to show um right so let's look at um let's just look at uh the um our own um our own documents our personal document or identity um and so these um these are very extensible so the the the format essentially has an extensions area where you can uh provide um any kind of metadata you want with a certain schema and so one of the things we're working on is for instance associating these radical identities with uh ens right with with ethereum um i'm not going to go through the whole flow here because i would need like a wallet and stuff like that but i can i can show some of it or like part of it um so there's an ens command essentially and here it's telling us that the local identity so this this one up here is not associated with any e s name right um if i do uh something like if i do well if we just look at what we can do there's a bunch of things we can do and the the you know what we're working right now is like having this this setup flow which does a two-way um attestation between radical ens and then ens back to radical um this already works but you need to you need like an rpc node and stuff like that so i won't do that but i'll just show like the the local side of things and and i'll use this this command here to do radions set local i use my ens name and it's just going to ask me for confirmation and so now it's going to output essentially the new payload which has some extra information in it and if we uh inspect my username again now you'll see that there is the first uh the original identity and then there's the um new version of it that points to the that replaces the the previous one here right um and in here you see a separate payload that has an ens name and and this is good like we're using this to build start building uh features that essentially um link code with money or code with uh ethereum and on chain state essentially all right cool um let me just see uh what else i had in here not in here but in here oh yeah um [Music] so one thing i wanted to show was um a little bit of how the uh architectural looks uh under the hood um so i'm just gonna open this thing and i'm gonna move it here so what we've been looking at essentially is is this part here right radical user and we've been in our working copy essentially so this is the uh um yeah just the checkout the repository checkout and the way things work essentially is that when you do uh when you do a rad push that i did earlier um what it does really is it doesn't get get push rad with with us with a kind of rad url and we have a remote helper that catches that push and it actually pushes to a local a local repository we call the monorepo because it's a repository that stores all of your code across all everything essentially all of your code all storage all your all identities are stored in this git repository that is stored that is local to your machine and all nodes have their own mono repository and we use git as a transport as a protocol to replicate things between between nodes essentially and um yeah so what happened when i pushed is that it first it copied the refs to this mono repo and then it did a rad sync which essentially copies from the monorepo to a remote node and so in this case let's say you know this is like the the maple seat node for instance um the the the refs the all the git objects were copied to the other side and uh and on the other side again it's since it's just in the end git repository it's fully git compatible so a regular get user who doesn't have radical installed could do a git clone or can do a git clone directly from that uh repository via bridge and the reason we have a bridge is that this mono repo is not just a regular repo it's sort of like a repo of repos and i can show that a little bit if you guys are curious um and then to to to go back to the the question that was asked earlier uh on top of this there's a peer-to-peer layer that's in development that essentially uh allows well asynchronously replicates objects between different nodes um according to a sort of tracking configuration so essentially a node or a user can say hey i'm interested in replicating these five or these 20 or 30 projects um just keep in sync and then you know as long as your your demon on your computer is running or whenever you activate a radical it'll sort of synchronize with the the peers it knows about and copy all of the refs and objects that you're interested in um yeah that's uh that's pretty much it so um you know there's there's other capabilities already and lots of stuff for developing but you know if you just want to list projects you have a red ls you can um via the um i'm not in not in the project [Music] tracking is how you essentially collaborate so um essentially this is how you add peers to work with uh add and remove peers which when you do that um essentially it starts to track their changes that's why it's called tracking and so you have a remote a remote for all of the the collaborator collaborators on the project and you can manage that and you can also list um i mean this is not going to show anything here because there's i'm not like there's no one else on this project um but um yeah you can list um remotes on on various seat nodes uh uh when you're collaborating with someone um yeah i think that's that's about it um we're pretty good on time if there's any any any questions happy to answer them oh and in uh in relation to the hackathon uh uh so we're we're um you know we're sponsoring a uh we have a prize for someone who would implement the best sub command on the cli um there's lots of kind of things you could do but just to explain how this works essentially it works like git if you have a command called like rad hello in your path then um typing rad space hello will invoke that command so it's really just a matter of creating binary and executable [Music] in that format like named something like this that takes parameters and then um it'll be sort of it'll be picked up automatically by the by the cli installed locally so it's extensive one that way cool questions comments concerns no all right now there is a question is there any incentive for hosting your own signal we're working on it at the moment there isn't except you know if it's your own code i guess to just keep it available um but yeah this is something we're interested in and and we're working on so could you like uh have your own push everything there just to be safe and then maybe push also to uh exactly yeah exactly and um one thing uh one thing that's maybe interesting regarding your like having a personal seed note is um we use ens for um we use ens to to map between you know user identities and seed nodes so you can let's say um wait that's not it let's say i go to clown head radical eat so this is a my ethereum address or ethereum name under uh under the radical uh domain so um this is automatically getting mapped to my seed node and so i can browse my projects here right and so this is kind of how we're using um uh ens to one of the other ways we're using ens to map between ethereum and the sort of physical server world um so you have a yeah one of the the ens keys is called seed host or it's like uh the key is a bit different of course but it's it's that's what it stands for um and uh that's how we can map between developer identities or orgs and projects hosted somewhere [Music] um i guess so on the website there's a couple things you can do the main thing at the moment i mean yeah the main thing is like if you want to register a name under radical eth so an ens name [Music] the only advantage really over like dot heath is that they're kind of free forever so you just register you just pay once the tx fee and and you're having yes name forever essentially um and then there's other things like we we're reworking this but um uh i don't want to connect right now because i don't want to get docs but my uh yeah like um you can you can essentially create orgs and stuff like that on here um you can edit your ens records um so like um the page i had before um this one here come on yeah so there's an edit button so you can edit all of these records from here also uh with your metamask or whatever um and what else um yeah there's more stuff coming up also we're gonna have like um the ability to sign in with ethereum on a seed node to be able to essentially take actions as that node so do like server-side authenticated actions uh and um and things with um with uh also monetization so sending money receiving money stuff like that we have a team working on uh something called drips which are since essentially money streaming and uh yeah that's going to be part of this also so yeah it's for all the ethereum stuff essentially you want to yeah that's that's kind of what i said right like the yeah names orgs uh and uh incentive related things funding etc um if there's really anything else yeah we have agnostic safe integration also for orgs so you can you can there's certain things you can do with that [Music] is there a chance that these repositories you could just their data right could you address them on ipfs and then use igfs notes like put them on ipfs yeah you can do that the reason we don't do that by default is that it's not very efficient because the the representation ipfs is like ipfs is good for for big files essentially or it's best for big files um when you're representing a git repo it's like thousands of small objects and um the the git protocol um is optimized for that so it'll it'll actually like the git protocol is an interactive protocol so when you connect to a node um uh sorry when you connect to it to a git remote then you pull or you push you're gonna have a negotiation phase where it's like hey these are the objects i have and you're gonna ask the other node what objects it has and then you'll just kind of the the remote will create a pac file which is like a compressed archive of only the things you don't have on the fly and send you that and then you're going to open that pac file and apply the the updates locally and and that's something ipfs can't do right it has some optimizations of course but it's not it's really not nowhere near as uh as fast and good for that use case we tried it actually a while ago yeah yeah good question is it's possible to maybe extend it functionality to include this stuff on top of it it's not really needed i mean um we are sort of extending git's functionality but without modifying git itself um i mean so this is actually something i wanted to show briefly um yeah so um if i look if i do this i can see sort of the the actual get refs that um are stored for this project and you'll see these these regular get refs that like all uh repositories have so essentially your branches are stored this way um but then we have a kind of subdirectory um under rad and you store other things like the the identity the related related identities uh a pointer to um yeah a pointer to your own id and then a um a document with all of the signatures for uh all of the graphs essentially and so it's it's it's quite powerful like there's a bunch of things like um like for example um for configuration we use git to like so the the the default seat that you're uh you're using for a project is stored under git under the configuration um uh yeah we essentially get is is already really extensible and so um we're actually not at a point where we've hit any barriers or any issues with with that yeah all right all good thank you all [Applause] [Music] [Applause] [Music] you 