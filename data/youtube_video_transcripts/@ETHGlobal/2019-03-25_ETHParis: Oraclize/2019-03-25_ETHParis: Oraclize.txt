hello everyone so I will do a quick introduction on our class so how many of you know what noir Holies accept so I don't have to waste half an hour to explain that maybe just a few minutes so we have rebranded like a couple of days ago to approvable to better represents like our new strategy going forward you will see that in the initial part of the presentation so what we have traditionally been doing is solving the Oracle problem what is that problem basically the blockchain applications live like in a world garden they are not capable of reaching out to the Internet and it's impossible to get data like study it is Mark contract for instance so what you want to do is basically somehow circumvent a limitation so that you can implement data rich smart Contras and have maybe a smart counter that triggers a payment or some actions depending on real world events so on paper the solution has been called the blockchain Oracle basically and this is something the interiors existed for for a while even before a theorem came to life but in practice the need for Oracle's is very recent because of the complex the complex and smart contracts and dubs that are being built today so the Oracle is basically an entity that somehow it's not important how right at the moment connect the external world with the blockchain the blockchain is like he's related so in order to keep the rest of the presentation consistent and to facilitate the understanding I think it's useful to like define the main entities with just three simple names one is like the application in the blushing space we typically call it up or you know smart contract it depends but this is basically your piece of code that is basically in need of data this is the data the data source so basically is what you would like to reach out to and normally in a normal application you would just do maybe an HTTP call to their web api so something to get data from there so that's typically one line of code in most languages right just call the API maybe it's a public API no need even need of authentication in like a few seconds you are done you have the data is probably in JSON formatted so you can read it very easily and very quickly unfortunately from the blockchain it's not possible so if the application is is related you have the Oracle that solves the problem and the Oracle could be could be anything it doesn't need to be provable it doesn't need to be your class it doesn't need to be a chain link or witness I mean it could also be the data source directly pushing the data to the blushing for example Thomson Reuters which is a very common financial data source as an integration with the blockchain so there is no need to use a third-party Oracle to connect Thomson Reuters data with your application you just go to Thomson Reuters and they do both data source and Oracle unfortunately this is not very scalable because it's unlikely that all the data sources on the Internet will adapt to the blockchain and we integrate with it here on minute you know for different reasons so the ambition here is basically to enable a seamless connection with all existing data sources with the blockchain with no need for the data sources to adapt and do the heavy lifting and the hard work that for example Thomson Reuters decided to do so provable is basically enabling death we have been doing that since 2015 on aetherium we launched on September 2015 on the hill main net and the the way we have decided to do it at the beginning was driven by the context of the market and basically there was nothing on aetherium back then so we had to design a protocol to get the data we had to run the you know the actual article so be an open operator to keep the service up and also we had to try to understand what people wanted because there was no one building applications in need of data on the blushing back then so it was a big gamble we decided to take and actually the attraction started coming a couple of years later so what does it mean well that an eye statically approvable which it was called like oracle eyes 1.0 if you want has been a centralized service because we were the operator running the entire thing so this seems like to make little sense because the application like the blockchain is decentralized this is the value proposition in most cases like let's keep this decentralized we don't want central counterparties sit in most cases the data source is centralized like you want to get it from a single web api or from a few web api is that maybe the end of the day get their own internal data from the same source so what happens well that basically here you don't really want to compromise the security of the system you don't want to lose the decentralization and you don't want even basically the data to be tampered with during the delivery process so the Oracle in between needs to somehow guarantee that the data has not been tampered with and it is safe garbage in garbage out if the application is perfect decentralized and transparent but then you feed it with garbage the payment maybe is going to be triggered correctly but on wrong key inputs so wrong it was right that's what you want to avoid and we have been doing that by providing some guarantees we call authenticity proofs so do you think this the proofs are basically some proofs that try to show that the data fetching process that the Oracle did from the data source has been done in an iterative way so that basically there was no possibility to manipulate the data and that data is authentic so this these are the integrations we are currently running like we have integrations with all those different Colossians because like 80% of our work is off chain is in like securing the data fetching process and generating those authenticity pros then there is a small integration layer on each one of those block chains and as we have announced few days ago on a theorem we have been just running our own integration as on all the others but we will be supporting for the last mile also other protocols such as chain link or wit net and few others that basically FDA aim to basically decentralize and the network of node operators right now we are the only node operator on the main net basically for a general-purpose data fetching one day if people will decide to value the centralization of this service they may decide to choose you know chain link or something else and maybe delegate this task two more two more knows the mod 2 more not know the operators so in the rest of the presentation I will be showing the existing interface of fertilise which is the one you find on every block chain and on the hill main net and this is the one that is being used by approximately 1,000 projects on github so if you go and get up and look for your class API you will find like I think now it's a bit more than 1000 repositories making use of that for the day written projects and these are some statistics that we have collected to basically show what those projects are bidding like all those data rich apps and I think it's quite interesting to see that a big chunk is gambling right the blue one is gambling surprise surprise 80 remain net as the entire ecosystem basically and has you know huge ambition to decentralize finance insurance and so on but data rich dubs at the moment as for the number of applications list and is mostly leveraging like crowdfunding which is icos and assets and tokens that use it internally for Dino logics and gambling ensure a finance is here insurance is here so they are part of it but the number of our applications is still limited so I don't want to spend too much time now on explaining how this works because we will be around me and the rest of my team here so if you want to ask some questions more technical questions on how this works under the hood we will be happy to to answer but in general these are the two keywords right blockchain of course that's the interface like where you want to use the service on and this is like how we secure the data fetching process so the authenticity proofs are based on technologies and like Intel SGX legend on us TLS notary which is the software isolation technique and few others the idea is always the same which is basically let's prove the securing clave a secure insulated process provable is related process has done data fetching so we couldn't tamper with it so basically the guarantee you have right now with the traditional Oracle is 1.0 service is that if Oracle eyes the Oracle answers then the answer is correct because you can check the authenticity probe but the Oracle may not answer so this is the risk you're taking with our traditional approach and that's why projects such as chin link are trying to decentralize that so that basically it's easier to basically expect that it will answer which is important if you want an application that keeps running for a very long time and you are afraid that the Oracle may disappear in a couple of years or in something like that right still if you are a developer and you expect to bid on something like that you have to do basically your own math and decide what you need because decentralization is like very important but right now we don't see the actual market valuing it much like we see it also with ICS we see it with many different like other components in the network we give the tools to the community and we do a lot of work to give the tools for the community and nobody cares they just want to you know buy the NFT they want to invest in the now they want to invest in the ACO before the contract is verified before the contract is public they just don't care so we don't know yet how much people will value the centralization if they don't value it at all the entire blockchain movement will probably fail so we hope they will value it at least a little bit but we don't know how much they will value it so the idea is that the existing Lorelei's interface and fits really well as for gas efficiency for example if you don't care too much about the risk of the Oracle potentially not answering in the future so if you're building adapt where for example you are the administrator that's probably not a big deal because you are the point of failure anyway and people are trusting you so that's not a big deal but if your application is supposed to be fully autonomous and run forever with no changes or something like that you can you're encouraged to look for some other approaches that give you those kind of guarantees but our aim with the traditional interface which is why we have decided to keep it to keep the traditional one is to be as efficient as possible so since the traditional Oracle eyes 1.0 interface doesn't need to support a decentralized service the idea is that using that one you get the cheapest gas cost you can because the layer is so thin that is it's impossible to make it cheaper for example you don't need to use token to you know secure the decentralized incentive system you don't need to have different layers in between to solve disputes or anything and that like as thin as possible why if you want the centralization other things we will be operating on other networks such as chaining which is here as a sponsor as well and you can just basically use our class white cynic or Oracle eyes and other nodes or just other nodes it's up to you so basically these are the features of the of the provable service and in general the existing interface we have is also like very simple typically you just use one function where you specify the URL you want which is the API call in 99% of the cases you want to to make so you will see an example short very simple basically this is the line of code this is a sorry the contract is quite old I will show you an updated version in a second but the logic is the same basically you decide how to secure the like the data fetching process so what kind of authenticity proof you want here we have selected here let's not worry you can select others and here you're just saying reach out with the Oracle this is my task I wants to get the data on it hidden try the hidden price in US dollar from crypto compare if the process is a synchronous so basically the first transaction will reach out to the Oracle then the Oracle needs to basically process the D query and it will send back a transaction so the Oracle will reach out to your contract holding your callback function and the callback function guess what contains the result and the authenticity proof and the authenticity proof can be verified if you look in our documentation you will find more details it's out of scope here but you can verify the proof depending on the way use the service there is a different cost to verify the proof right now the for example if you ask for a random number from a ledger device like a ledger unless we have a custom application it is open-source and anyone can verify you can check that the random number we generate comes from there and you can verify on the blockchain at the authenticity proof at a cost of approximately one 100,000 gasps something like that and then you can do whatever you like with the data right you can just continue from where you left the your logic flow in the in the application so that's the part for the random number generator so if you care about this use case which is basically gambling few others probably we we have released a paper analyzing the differences between these trusted computing based approach for the generation of random number outside of the blushing and existing ways to do that without using trusted computing like the most trivial approach is commit reveal scheme right there are many other ways to generate random numbers we also know you know about the other upcoming approaches to generate randomness on chain we may be with the beacon you know on future at Union point O two point O versions but they all have some kind of limitations like for example in the case of the beacon you have just one random number every you know six minutes in the case of like commit ravish scheme it doesn't work well with applications where the bankroll for example in casinos is shared among investors I mean it's quite complex but if you look the for this white paper we released a couple couple of years ago there is a complete analysis comparing like the trust assumptions we make here with the trusted computing technique with all the other existing systems of course you can use it also to delegate on abstain context the execution of a piece of code is the same logic like in say instead of asking to the Oracle you basically get data from Web API you ask the Oracle to execute a piece of code and give you the result one nice side effect of using like trusted execution environment is that you don't need the process to be fully deterministic because it will just be executed once you want and and you will be able to prove that that execution has really happened within a trusted execution environment however if then you want to maybe aggregate this data with something from other node operators or something from other Oracle's that do the same you need to ensure in your on your side that the execution is deterministic or that you have defined an aggregation method that makes sense for example if you generate around the number of course you know the different like orcas will find a different one so then you need to understand how to aggregate it in a way that makes sense and doesn't break the security properties so yeah this is basically the description of Oracle eyes 1.0 which we keep offering so it works with any web api and these are the technologies you can select at the moment and yeah this is basically what has been used in the wild by most projects like on the main that we have process 1 million transactions to date um in like four years basically so some useful links if you're developers a developer basically this is the support channel on git er here there is the hilum api one for the interim interface this is the documentation dr. Jose Teague contains pretty much everything and I will show you some examples in a second this is the main slide if you are developer you should probably take a picture in case you are interested to use it so basically if you want to use a relies on a private chain this is possible and is being done by like a lot of people especially during development you can just download this tool called Eaton bridge and the theorem bridge is basically a node tool that injects the Oracle is contracts and interface on your local chain so that you can test it in memory or on your own local setup basically so you can test the or class-based contracts on any context with without needing to change even a link a single line of code it just works in the same way as it would on the main net or on all test nests we are integrated with all test nests basically you can also use it just in memory if you are familiar with remix like remixed ott remote or you go to the official one and in the settings section there is there are some plugins and there is your class one you can just click the record button and it's integrated straight away in the memory execution you can test it there are some other useful pages here to verify the proofs of chain if you prefer this is a tool so you can verify if for example the 1 million proofs were sent back on maintenance are valid or not so you can see if we have ever cheated in the last four years basically that's pretty much it so I will show you now like this is a test query page the test query page does what you would expect it to do basically you define what's the query for example here you just say fine this is an HTTP GET yes very simple and this is the API I want to call could be any API there are some helpers such as the JSON one so that you can filter down the full response to just the piece you want but you don't have to do that it's just for gas efficiency then you just click on test query if you want you can also select you tentative for testing is not needed in production definitely then you wait and here on the bottom you will find or I should have duplicated the screen and basically you get the result is exactly the same you would have by doing the HTTP call yourself that's trivial but doing it via this page gives you the exact response you would get by a provable basically so if you go to our key table repository there are many repositories and for each helium like a tea room examples is a repository which contains many examples so I guess nobody is using serpent anymore today we had an API for serpent as well but in solidity you just go here there are more complex examples within the folders in the main one you have this simple examples such as I don't know diesel price for example it's the exact same format you have seen in the slide right just a request query you define the query this is a XML you can use XML filtering and you get it in the callback right well the documentation doctor to recognize society again if you go to the etherium section there is a quick start and you find also best practices during the a curtain is not that important to follow them maybe because you don't have time and typically everything is just put together pretty much randomly from my experience but if you go to production please go back to this section and read it because it's important also for security considerations to prevent common mistakes or issues last but not least the remix dynamics integration so that's the plugin basically it's quite useful to get started because without having to substitute to setup the idiom eternal bridge on your local chain or to send a deal transaction the main net you can just use remix and do an in-memory execution and test this setup with your class integration this is just a stupid contract that basically keeps getting the price of a theorem in Bitcoin anything by ID cracking API it does it continuously so this is really bad to run on minute because this gets very expensive very quickly but I mean for testing it's quite interesting so again to enable it you just have to go to settings and plugins here you find a list of plugins that are integrated with remix or Christ has been the first one being integrated so that's why it's here if you click you find something like that which I admit looks ugly but it works and does the job so now you basically have to somehow move this window which is always challenging I did and then you just compiled the contract this contract where I already compiled it well let me do it again because you compiled the contract and you you deploy the contract it should like in the constructor this is reaching out to our cries so when you click on deploy in theory yeah the plug-in will show you the you have reached out to our allies with a query if we show you some details on the query and the fact that there is no result yet because it's being executed off chain now right this is assimilated like execution of the blockchain in memory and also the integration with our crisis just in memory is just being and life and here our class has returned the result and sent back the transaction so then in the console you can just read what it did and go on as usual with romick's and this is quite convenient for testing also something that should work is that when you click on this ID here which identifies your query it should send you to an external page to check the query status on your class panel so you can see under the hood what's going on if you have selected the proof what's the proof and how long it took to generate all this kind of stuff that's that's pretty much it if you have any questions I think we are still between 1 and 60 seconds left thank you [Applause] any question sportiness is a very interesting word so if I was asking you what's the temperature here I'm sure the majority of you will go on Google and ask Google and consider it trustworthy the reality is that you don't know even where Google got this data from so trustworthiness is not within the scope of the Oracle it's on the developer to choose what your application can consider trustworthy so my suggestion is to select independent data sources or the same data when possible like the temperature is an easy example and maybe you can find you know five data sources or something and try to aggregate data coming from them still this gets very expensive this is why it's all it all comes down to the cost of decentralization like do you prefer to like give to your users of your application a cheap interaction with the contract with wine on true point of videos or do you prefer to make it super safe but make the interaction much more expensive I don't know I think it should be on the developer as a choice and this will be reflected on the adoption of their platform which depends on the use case I guess I mean the role of the Oracle is the one of proving that the data is authentic and is coming from the data source then if the data source has compromised the data or is lying that's not a problem of the Oracle that's the problem of the data source the developer has chosen which was not trustworthy after all so the Oracle is not about this is not about trusting the Oracle is about using the Oracle as a data transport layer to get the data from the Internet when you write a piece of code in Python out of the blockchain or in whatever language you like you call a Web API so is the data trustworthy well it's not a problem of the library you used for the request you have to it depends on data source on the web api your calling thanks again if anyone has questions I will be around [Applause] okay 