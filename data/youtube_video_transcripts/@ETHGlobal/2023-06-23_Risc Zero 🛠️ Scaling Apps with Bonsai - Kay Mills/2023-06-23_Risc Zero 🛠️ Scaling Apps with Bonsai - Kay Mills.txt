foreign [Music] welcome so today I'm just going to be talking a little bit about creating projects that use the risk CRZ KVM for off-chain computations you're going to be using this through the Bonsai proving service which we are going to make available at the hackathon so we're providing a little bit of Early Access it's going to be temporary and I'll show you in a moment how to reach out and get that from us I also want to show you our two bounties and help you get familiar with our Dev template so this is going to help you understand how to go from a local project setup to connecting to a real proving service and we're going to save just a little room at the end to gently touch on so your knowledge proofs so let's start talking about why you would want to use a zero knowledge proving service so we're going to let you build better onshine applications because you can use general purpose CK Computing to take care of the off-chain bits that you don't want to have to run through the evm and I'm going to break down just a little bit the benefits of this so the first one is obvious off-chain computation right everybody likes paying less for computations executed outside the ebm but because this is ZK after we take care of the oxygen computation we're going to give you some results that anybody can easily validate without having to run the computation themselves and because it's zero knowledge you also don't need to know exactly what inputs were processed and what code pads were took or taken to trust the computation so if you played with ckvm in the past um you might remember that you were restricted for running programs that were long or memory intensive I just want to give a quick shout out to a new feature we now split your program into many tiny programs that can be proven and in fact they can be proven in parallel so just a quick recap here we've got a fast general purpose VM lets you not only check your computation but also assume everybody else is going to agree the computation was good and you don't have to stop until your computations are finished so in fact our new ability to split up work we can basically parallelize the proving process so if all that sounds good let's go check out the hackathon projects open this weekend so we've got a couple of bounties and the first one is obvious let's do some Gap development um here we're looking for kind of an interesting demonstration of adapt that uses the Bonsai proving Services through our E3 lay and it doesn't necessarily have to be something that's an incredibly beefy off-chain computation it could just be something that allows you to make a DAC that's slightly more complex we also really love educational pieces that are really clean well documented demonstrations of simple use cases and just as a quick heads up we would love for you to try out our services at this hackathon but if you want to do local development it's also just finding these are mock services so because we created something that has a pretty smooth process from doing local development to using the real proving service we'd consider your submission of your local code check in good enough you don't need to demonstrate that it runs we can do that for you and we trust that it executes so how I just talked about a little bit we have a Dev template that I'm going to link to in a moment and from that you just have two files that you modify so you'll modify the app contract which is written in regular solidity and then the provable zkvm program that holds the auction computation so you'll be writing a little bit of rust but just enough to perform your computations so there's no need to do any circuit construction and I guess I lied you should probably include tests but don't worry those are included in solidity too we've gotten you started and you can run those right from the command line locally so here we're looking for kind of an interesting use of an off-chain probable computation but again it can also just be something that allows your adapt to be slightly more elegant or is educational and feel free to reach us reach out to us on the risks here at Discord which you can find off the main risk zero website we would love to help you work on something that's exploratory or inventive and if you get to the end of the hackathon and you want to tell us what your experience was like we have a second Bounty for that so this is our second Bounty that we wanted to do just as a way to say thank you to folks who give us really rich feedback at the hackathon and the nice thing about this is you can actually apply to one or both so if you go to work on a project you get stuck and there's some really crunchy thing you want to give us feedback on um you know we prefer that was not the case but you're still eligible for a bounty if you just want to give us really rich feedback about it we'll be rewarding the top two respondents with 500 each so here you're going to be sending in an initial feedback form and that form and it implies consent to have a conversation that's up to an hour we respect privacy online is perfectly fine telegram Discord if you want to chat with us in person it's a pretty tight window in between the 2PM end of judging and the three o'clock awards ceremony so we will probably do some follow-up contact rather than do things at the event but I just wanted you to know that there is going to be a conversation expected as part of that follow-up for feedback and you won't be evaluated obviously on the conversation because it'll need to happen later so just try to make sure that you fill out the form in a way that indicates you know you're giving that a you gave it a good shot and you really tried to work on a project and be you know you're committed to giving clear instructive feedback about what your experience was what you liked what you didn't like how you felt about it and all you have to do is provide feedback so with that said um it's probably time to better understand what you can build at the weekend so let's take a look at what you're going to be developing so what you're going to bring is pretty simple you are going to bring an app contract which we've already provided in our template you just have to add a little bit of solidity code a computation that you would like not to write in that app contract and then a program to compute it which we've gotten started for you you just need to add the computation there by default the template comes with calculating Fibonacci it's just a silly example of something you might not want to do using the evm so again the two languages you're going to be working with are rust and solidity so just plain rest no circuit development and just plain solidity there's going to be an invocation calls callbacks but other than that it just looks like a regular app contract making a regular function call um so once you've built that we're going to run the proof and handle the results assuming that you are proving on our Bonsai proving service and we'll get to what you're building in a minute but I just want to emphasize you're working on your contract and off chain program locally here with full solidity tests and simple deployment steps and this way you can just focus on solving your problem this weekend instead of learning a new API at the hackathon so here's some things we're not going to ask of you and I wanted to cover these because you know you only have 24 hours to work on a project so you don't have to write a custom proof circuit in a weekend or at all you don't have to think about ebm performance for your off-chain code you can just go ahead and make sure you're writing I mean you still do have to care about performance but you're trying to write good rest and you're not running this inside of the evm you're running it inside of a general purpose virtual machine that for our purposes you can think of as rent as just being a co-processor an off-chain co-processor you also want need to make API calls directly to Bonsai so for this particular kind of project you can leave the calls to our relay and we'll handle it for you so you also don't need to develop with unfamiliar tools a lot of you will be familiar with Foundry so we've done the local part here as a full self-contained Foundry project with full access to Foundry tools including some Forge tests which we've gotten set up and started for you so what you're going to be doing is just modifying those Forge tests and adding your own checks right now we make sure you're accurately Computing the Fibonacci sequence and I'll show you more about the tests in a moment there so you're also not going to need to spend a lot of time on your environment setup we're going to start out by mocking the entire proving service and let you essentially flip a switch with environment variables when you're ready to use the Bonsai proving service so it's going to be pretty fast and easy and you can go back and forth pretty cleanly so we're pretty excited to not make you make any large code changes before you deploy so if that all sounds interesting I'm going to start unpacking the project structure in this next section so this is a very high level view I'm going to have a little deeper architectural view in just a moment but for now I just want to explain the basic moving parts and how they work so it's a little bit cartoon but here's the blockchain um and here is Bonsai just FYI bit of a tangent um you won't actually be deploying your app contract to the blockchain for this weekend hackathon what you're going to be doing is running everything locally here using that local Foundry setup and calling out to our real proving service so this is a picture of the final product in the final vision of this your contract lives on the blockchain talks to a relay contract also deployed on the blockchain so we're going to start out reaching out through that relay contract which will communicate through the eth relay onto Bonsai and we'll manage the calls between the blockchain and the proving service for you and then we're going to run your program off chain using inputs from that smart contract call prove your code was executed in a way that anyone can verify and get it back to you right in a callback function so it sounds like a lot of moving Parts but I just want to emphasize this contract on the left and the provable off-chain computation on the right are the only two pieces of code that you need to be touching at any point in this hackathon so with that said let's take a little bit of a look at the um at what you're going to need to set up so there's three basic steps you're going to need rest you're going to need a Foundry and you're going to need the bone size starter template project so you're not allowed to start early at the hackathon so for this I am going to be having moments where you can pause in this uh recording but I'm going to assume that if you're pausing and doing setup steps or writing code or making modifications that you are inside the hackathon window all right that said rust installation um if you haven't got rust on your computer you are going to need it for the next bit so if you want to pause here this is a good time to get that installation set up and similarly here's The Foundry setup I have shown the commands above um if you want to go ahead and pause and get that set up I'm showing below what it should look like if you run the command Foundry up and you do have it on your local box at least that's what it looks like on my machine and then lastly I'm going to take a moment pause and get the template so you're just going to be cloning the project here or forking whatever your preference is and I've just gone into the template directory structure and I just want to highlight a few of the pieces you're going to need to care about there's a lot of code here but really you can just focus on the readme that's got the setup steps we just went through most of the slide content to follow if you really want to stop and just get right into it and use this video again um if you get stuck or you need more information I won't be mad um in that case just go ahead and go to our prize section and get information from there about how to get access to our proving service and find out more about the bounties let's say if you learn well from videos let's keep going and talk about contracts this is going to have your local app contractor modifying and methods folder with code for your off-chain computation it's a little bit buried but I'll show you where to find it there and then finally a test folder with as I mentioned before some Forge tests written right in solidity so in a moment I'm going to walk you through running those tests in a few different modes but for now let's just keep looking at the options for running so we've given you four options for executing your off-chain computation and the first one is the default it's the simplest you're just doing a local execution we actually using our mock Services call out to the command line and just run the off-chain computation right on your box so you're going to get a local execution and it's pretty Zippy because by default we don't have any of the proving part we can just do the execution part since we figure in the development in the early development Loop you don't need to prove to yourself that the code you just wrote uh does what you expect and then the second mode you can think of as kind of a gentle test mode you're going to have a local contract that lives in Foundry um and then a local proof that you're executing again from the command line using mock Services the deployed version you're going to have a local contract still coming from everything contained in Foundry and but you're actually going to be proving on the Bonsai proving service and as a preview the final version you're going to be able to use the deployed app contract with a deployed um relay that's going to connect through our E3 lay and prove on Bonsai and even though you can't do this this weekend we really have the three options for you um it is we are planning on having it be fairly seamless so if you write an app contract now you would be able to deploy later and through on Bonsai I mean caveat caveat this is a work in progress we reserve the right to change all code we're not guaranteeing that you can do this immediately but we think this is a really great start to having a live um working contract that uses an off-chain computation so oh I guess I should say one final note um you don't need to proof on Bonsai to submit for a bounty program um we'll allow you to just write a local contract run the local proof um this is just to let you play around with the real proving service so hopefully this should give you a rough idea of your developer workflow right start with execution only go to local proving and then go to proving on the Bonsai proving service uh and with that said let's go and figure out how to set up each of these modes so I promised earlier it was pretty simple and we're going to stick to that there's just three environment variables you're setting so the first one is a bit of a toggle between those first three modes I mentioned the exact execution only local proving improving on bonsai and you'll notice that the empty string is to do local execution only and that's to give you kind of a really clean developer workflow but you should be aware that by default you are not running local proofs so Second Step we're going to set the Bonsai API URL environment variable and the Bonsai API key and both of those are pieces of information that will get to you if you fill out our whitelist approval form it should be pretty fast turnaround during the hackathon if you're watching this before the hackathon and you want to get a head start we have included the URL in our contract or sorry in our Bounty information on the prizes page and we're also going to include it in just a second here so go ahead and get your keys by filling out that form but if you don't have them yet and you want to get developing it's pretty seamless to then set this URL and key later set the Bonsai proving mode and get started oh and I apologize I did not change this slide it actually should say set Bonsai proving so these are the three you're going to need so here we've talked about the three different modes you can use if you are running uh the Bonsai proving Service as the Bonsai proving service if you're doing a mock and just executing your off chain computation locally or if you're doing a no proof version and just doing local execution so I'm going to show you here let's get the remote one first I'm setting the bone side proving environment variable to the Bonsai and for this I do need to set the URL in key environment variables as well for obvious reasons I am not going to show that here but please reach out a little bit later in this Workshop recording I'm going to have a link to a sign up sheet you can do to get whitelisted and to get access with the URL and key you can also find that off of our Bounty prizes page so with that said we're going to run this remotely with the full setup so this should take a second and I just wanna while this is running I'm going to real quick pop over to code down in the guts and just mention you know it's experimental use at your own risk but we are double checking that your results are coming from the computation you thought you were running and also that um there coming um back from the uh from the relay that you expected it to be coming from so let's go back here this should be just about done great so we've got just around 30 seconds and let's take a quick look at how this runs local so something you're doing in Bonsai mode where you're actually using the Bonsai proving service that you're not doing here is in the background we do run a call to upload the off-chain computation you're going to run to the service before we run it and so then [Music] take another second there we go so our tests have passed and let's do the final mode so by default we're going to run an execution only and the empty string will work but if you want to get back you can just set that to none and you'll see that this one is pretty Zippy so I recommend it as you work on your project you stay in this mode while you're just figuring out what you want your off chain computation to look like so you don't have to wait for the full proving mocking cycle um or approving in mock service cycle to complete alone let's go ahead and stop this and I'm going to jump back in and in just a moment we are going to take a closer look at what we're actually executing in this and let you walk through a little bit of the source code through here okay so now you've gotten a chance to see the test section and we're going to go through a brief Code walkthrough so this will get you an idea of how the setup actually works under the hood and I'm going to start with that finished product which again we don't have here at the hackathon but we have something pretty close to it um the finished product is where you actually deploy your contract to an ethereum Network and use our Bonsai proving service so where you'll be able to get during this hackathon is working locally from your box with the app contract and connecting to the real Bonsai proving service so I've taken the ethereum Bonsai interactions that we saw in the left right kind of cartoonish mode and made them vertical and that's just to fit in a few more moving parts so remember there's going to be two files you'll be editing here's the first one it'll be your app contract and if you're taking a look at this at the hackathon or before the hackathon this might be a good time to pause and open up both of these files so you're going to look in the contracts folder I mentioned for Bonsai starter.sol and in the methods folder I said it was a little bit buried we're methods guest Source bin fibonacci.rs so I recommend having both of them open for this next little bit if you don't have it downloaded just popping those open in a browser so you can look at the source and follow along and kind of see how all the parts fit together okay so this is a bit of a slide deck experiment here we're working with both the infrastructure and the code but I think because there's so many interactive Parts this is how I want to show you how everything plays out and for demonstration purposes um like I said we're looking at the upcoming fully deployed version um with the contract on an ethereum network but it's going to look much the same when everything's running local on your box so we're going to start with an invoking function and let's take a quick look at that here so notice we're reaching out through the Bonsai relay and we've selected our callback here it's going to be store result so evoking function oh and just FYI we are capping the gas cost here with that 30 000. so that said our invoking function which is out to the relay contract Bonsai E3 laid to the ckvm program and or sorry to the Bonsai proving service which will hopefully execute improve the CK uh VM program so let's take a closer look at the source code for this it's going to have a few components but I just want you to get an idea of the shape of an off-chain computation what it's going to look like and how simple it really is um I mean caveat caveat again you know if this is your first time coding in Rust it might not initially look simple but when I say simple well what I mean is you're not solving the problem of how to write a circuit you're not solving the problem of how to work with a custom DSL you're just solving the problem of how do I write my computation so here's the off-chain computation the first thing we're doing is we are reading in the value that we passed in from our contract as input and decoding you know from the byte code and storing it in a variable so you are going to need to know what you used as encoding on the other side but you know since you wrote the app contract that's no big deal and now that you've got your variables you can run your computation so the off chain computation here again it's a little bit silly but we're just running Fibonacci to make sure that we can do a more complex off-chain computation um and we're going to send the results back by committing this as a data slice and what that means is we're going to be sending back a piece of information that I will discuss later in the special ZK section but for now what matters is this is everything we want to get to the app contract so every variable that you've committed at the end of your computation gets sent back to the app contract and I'll describe this later in the gotchas section but you want to make sure that you are sending those variables back just like any regular function so we want to make sure they make sense off the wire on the ethereum side so also notice we're doing some ethi encoding here okay so now we're done with the zkvm program which we called from the app contract through relay contract through the Bonsai a3lay we're going to go backwards up through E3 lay relay contract end of our callback and now let's take a quick look at what the Callback function looks like so if you recall from the invocation we picked store result and here's what it looks like so this is also in that app contract you should have open here um it's going to be storing the results of our computation but first it's going to do a check remember I said um when I talked about running tests that we do do some Chucks here this is where those come in now that we run those checks we're going to store our values we've picked a cash just as a way to do this for demonstration purposes but you don't have to make a cache for it you can do pretty much anything with the results that you wanted to do with the app contract and now so this is the final fully deployed form of the project and I'm just going to show you real quick how the local project is set up what it does and how it differs from this final form so okay so now we're going to ask how the local development setup compares to a deployed project so that you get an idea of how you're going from what you're building locally to how you're using a real Bonsai proving service let's take a quick look here this is going to be the local version so this is when you're running the execution only in the local proving modes you'll notice everything is contained in Foundry you've got an app contract with some invocation and callback functions it's only making mock calls to Bonsai um because what's really happening is from the command line we are running the zkbm program we're generating the proof and we're getting the results back to the Callback function so everything here is happening locally both the app contract side and the proving side so here we're going to be there we go so here's the bone side proof mode and this part you'll notice that you still have everything contained in Foundry but this time we're using the real relay contract connecting to the Bonsai e3lay and reaching out to Bonsai which then generate generates a proof after running your off chain compute in the form of the CK of again program so once you turn on proving with the Bonsai prove mode setting you're still going to be using these contracts in Foundry but you'll be hitting the real E3 lay and then running your zkbm program on Bullseye so there's a bit of a middle step here we've handled behind the scenes if you're wondering how the compiled version of your zkvm program gets over there when you first make your request we're going to do an upload to the Bonsai proving service behind the scenes to make sure your program can run over there now this is just a preview but you'll see it's pretty similar between what's contained in Foundry and what we're actually going to deploy on the ethereum network you'll deploy your app contract we'll have a deployed relay contract and everything else will proceed the same as it did when you're using a local setup that reached out to bonsai so here at the very end I just want to add on a few programming gotchas and go a little bit deeper into some ZK knowledge but not too deep just enough to kind of understand a little bit of the magic we're adding here in the form of a ZK proven off-chain computation so the programming gotchas are between the relay and the ZK code so on the relay side we do want to emphasize this is experimental that means not only is it subject to change but you know we prefer during this hackathon you not run millions of dollars through it the Callback is only going to check for a value execute identifying the executed program and also to make sure that it's coming from the relay that you think it's coming from and we um we went over that a little bit when we ran through the tests but I just want to emphasize that here for Security's sake you technically still have some responsibilities over making these checks and you should be aware that inputs aren't stored when you ask the dkvm when you ask Bonsai to execute the ckvm program so for now you're going to be needing to send them as parameters every time you run an off-chain computation um and then programming gotchas on the ZK side are pretty simple um as far as the DK code goes you're going to have to decide what you want to send back to your app contract so those results need to be explicitly shared back um it is in Rust so you are going to be hopping out of solidity briefly um but we think it's you know as rust goes fairly straightforward and you want to remember to set the Bonsai proving variable when you're ready for a proving run so that you're not just doing execution only now here as promised we're going to get into a little bit of zero knowledge information and I'm just going to start by describing what the VM does instead of building your own circuit you're going to use our zero knowledge VM it has kind of a processor based architecture and one of the advantages is you know we've got assigned registers we can expect some very predictable behavior and at a high level you know that you ran the expected computation that you actually ran it it's not just saying oh this you know would run on the ebm so when it comes to inspecting we're actually demonstrating that each low level operation made changes in roughly the way we are in the way that we expected and that's going to tell us at a deeper level that our computation ran the way it's supposed to and we can do that all without having you generate any custom circuits because it is a general purpose virtual machine so for our purposes though this step we can just consider a sufficiently advanced technology what I really want to focus on is that when this is all complete we're producing a receipt and this is the really important part for our purposes you'll see the receipt reference to some of the source code you're going to be playing with now why did you not understand um what these pieces are and what the language is that we're using for these pieces so this is the really important part for our purposes the receipt is just one artifact I want to focus on because it gets us two different pieces of information first anybody who has it and reads it knows your computation executed correctly right according to our off-chain notion of correctness and they're also able to see the results you chose to share so just like we saw with the ckvm program's commit method this is going to be how the app contract gets its return values that's going to be on the receipt as well as confirmation that your program ran the way it's supposed to so with that said you might be wondering you know where we're going to store these results and the answer is in a roll-up but we promise we're not trying to lock you in and it's just our scaling solution so you're also not under any obligation to use our roll-up these results can be stored anywhere though possibly not in the sackathon weekend we're also not trying to do an ebm style roll up so again our proofs are independent of on-chain logic and they just say your receipt checks out which means your proof checks out which means we're sure your computation checks out um and so with that in mind um let's get back to the hackathon I want to do a quick review from the essentials for the weekend so here is what you're going to need you're going to need rust Foundry and the one size starter template project and here is what it's going to look like when you develop locally and when you prove on Bonsai from a locally stored contract call and as a reminder you don't need to do the system on the right to qualify for the any of the bounty prizes so if for some reason you haven't gotten around to receiving an API key or URL for us by the end of the hackathon please don't let that stop you from submitting we'd much rather see an interesting creative piece that said we think the process should be pretty quick we'll try to get back to you and get you whitelisted and get use and URLs and keys I just want to make sure that you know you don't have to wait for that so here is to quickly review our two bounties the first one is DAP development and again this could be interesting dap this could be an interesting or powerful off-chain computation or this could just be a nice educational piece and we want to try we want you to try out our services but if you want to just do local development that's just as eligible the second Bounty is going to be developer feedback so again use the link in our prizes section you're going to work with our developer template and provide us with feedback and then a commitment a very brief one to follow up if requested so this is going to be about providing some rich feedback about what it was like to work with our template and with that said let's see hang out at the hackathon I'm going to be describing real quick here's a few ways to get in touch with us we've got Discord so if you go onto the risk zero webpage you can quickly find our Discord and join you can reach out and talk to us in person we are going to be hanging out during team formation if you've got some project ideas and want to float them by us or you know bounce them off of us and try and get creative with it I'm more than happy to help you talk about ideas that said you know the project ideas do need to be your own so we're just there to answer questions and if you want help during the hackathon we're going to have folks there where we'll be floating around if you'd like to come talk with us about what we're building before the hackathon we will be posting a side event on Friday that you can see linked via the prizes page is going to be an event page there and then lastly if you want to talk to us after the hackathon please feel free to join our community Discord reach out ask questions and keep playing 