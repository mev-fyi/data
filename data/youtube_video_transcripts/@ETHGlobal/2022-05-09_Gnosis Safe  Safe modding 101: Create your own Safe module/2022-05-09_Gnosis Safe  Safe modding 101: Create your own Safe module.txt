hey everyone just gonna wait for a couple seconds for the live stream to get set up great hey everyone good morning good evening um good afternoon depending on where you are we have german from hypnosis safe doing a workshop on safe modding 101 create your own safe module questions go into the zoom chat in german we'll answer them at the end of the workshop and with that i'll pass the mic off to german hello everyone and thank you for having us so uh i'm hermann i work at the nosy safe team and today i want to present you how to build or how to create your own safe module so today we are going to cover three uh three points the first one will be the safe modules architecture what are the components that uh that are present in this architecture and how they are connected and also why we need them then we are going to talk about how to manage different safe modules and what are the operations that we can execute for example we can enable a module into a safe we can disable a module we can execute a transaction using a module instead of the regular common flow where the signers need to sign etc so in general we are going to see how to use them and lastly we are going to see and mention some repositories that contain different safe modules and sun some examples so that would be where to find them let's start with the site modules architecture if we talk about an external own account the architecture if we can call it that way is pretty simple right in order to execute a transaction we just need a single key to sign that transaction and then we are ready to execute it however if we are using a nazi safe account which is a smart contract that also acts as a as a multisig we can handle different or multiple keys and we we can define how many of them are needed or are needed to sign a transaction and make it executable we can do this this step or this action on chain submitting every signature to the contract or we can do it often and if we do that of chain we can use a transaction service that we collect all the required signatures and then we can call the smart contract just once with the transaction we want to execute and all the all the signatures concatenated and attached to the transaction that is the the regular flow however there's a different way to execute transactions that or where the signers of the of the multisig are not involved and this other way is using safe modules safe modules that are used by third parties the third parties are any accounts out there in the network that can call a method in the safe module and the safe module is a an independent smart contract that is deployed in the same network as the nazi safe the noisy safe before we can use this module designers of the safe need to create a transaction and sign it all together to enable this module and once this module is enabled then the third party any account can use it and this module will send a transaction to the nozzysafe and it will be executed without the approval of the designers so we have two different flows using designers or using the module in case at any point in time we lose our our keys and we lose the control of our safe if our safe module is about or is implementing a recovery mechanism somehow this third party individual or multiple accounts could create a transaction for example to replace the multiple keys that's one of the functionalities that could be done in this environment so the main thing is that safe modules extend the functionality of the safe you can even implement different ways of how uh not all the owners for example have the same weight when they have to sign transactions for example if we have five keys and we just require three of them but but we could define different logic uh where one of the owners for example or one of the third parties involved in this module is more important than the others or whatever that depends on what you want to build there are also some safe modules for a kind of safe module that is called safe modifier and is also a smart contract independent of the nozzysafe that implements some interfaces from the nozzysafe because the the important thing about the modifiers is that they are placed between an aussie safe account and a safe module that of course is used by a third party design modifiers act as a filter for the transactions that are sent from the safe modules to the nozzysafe they relate the transactions but depending on the logic inside these modifiers some of them could be relayed or not there's also the possibility that we want to change multiple safe modifiers to have different filters and an oc safe can have enabled multiple safe modules as well as the safe modifier that can enable multiple safe modules and of course because the safe modifiers are a kind of modules we can have some of them enabled to the nazi safe at a time so that was basically the architecture or the different elements that can be that are in place and now let's see what are the some use cases for these modules as i told you before modules can expand the functionality of the safe and some examples could be regarding roads the common flow to execute a transaction using a safe is by having different signers and at least we need some of them to sign something but with a safe module we could forget about designers and grant some admin rights to specific accounts allowing them to [Music] execute transactions or calls to specific addresses calling specific methods and a specific parameter parameters and if the conditions that are defined are met then we allow this this now admin addresses to execute this these transactions without the need of the approvals of the safe signers we could also define some spending limits to certain accounts where we allow them to withdraw or to send some funds out of the safe without any other authorization we could also talking about recovery mechanisms implement a recovery mechanism like social recovery for example we could deploy a module that has set different accounts that later in time [Music] they could altogether create a transaction that replace the [Music] the initial signers of the safe if we prove that they are not reachable and that we lost these keys or for example and this is just uh these are just examples of what can be done we could define secret questions and for example encrypt the the answer of a question for you in case you for you lose the your keys and if you know the answer and provide that answer to the contract then you can again execute this transaction to replace the original signers also save modules can define allow and deny lists of the target addresses that can be called or decide if a safe module is is now in use or if it's not in use anymore and modifiers as we saw before they can implement time logs or cooldown periods where if you if you have a module and then a modifier and then the save and the module executes the transactions sorry sends a transaction to the safe but that transaction is received first but by the modifier and the modifier for example has defined that every transaction needs to wait for one day then other received transactions could be enqueued and wait there for one day that's just these are just different possibilities but if you are interested in safe modules what you can implement there the logic it really depends on your needs so now we saw what was the architecture let's see how we can manage them what are the different operations these operations are we can enable the module in a safe we can disable the module we can check if a certain address is enabled we can get the list of all the modules that are currently enabled and lastly we can execute a transaction using a module so let's see all of them a little bit in detail and this is just the different steps we need to accept we need to do in order to execute a transaction using a module we saw them before we need to deploy a new safe or use an existing one we need to deploy a new safe module or use an existing one we need to enable the module from the save and then after that that module is ready to execute transactions so now we have uh two different point of of views here we have the point of view from the safe that will receive these transactions coming from the module and we have the point of view from the module that is sending the transactions to the safe let's start with the safe and let's continue with the module so nazi safe dot sold this is a super simplified version of the nozzy safe contract that among other things it is a module manager the module manager is one of the safe core contracts that implements all the logic to uh perform these operations that we saw before like enable a model disable a module execute a transaction using a module etc so when we set up a new nazi safe there's a call to set up modules and if we see the module manager contract also super simplified we see that there are two variables we have the sentinel modules that is set to the address zero x1 that we will use later and we have the modules variable that is a mapping where the keys and the values are addresses and when we set up the modules we are going to use the sentinel module the address 0x1 as the value and the key as the key and the value of that initial module mapping with this mapping we will build a kind of a linked list where if we want to add a new model we are going to use it as the value where the key is the sentinel module because if we want to navigate through this mapping we just know the sentinel module so we check that key and get the value that would be a module that is enabled for example then we also need to store this module as a key and point to a value that is the sentinel module if there are no modules enabled or if we have more modules then the value of the key that was a module will be a different module and we are going to have something like a linked list that we could navigate uh forward but not backwards until we find the sentinel module so knowing that we can enable a module knowing that uh a module cannot be noun or cannot be the sentinel because we need the sentinel to identify the beginning and the end of this linked list and we cannot add a module twice we can also disable a module very similar but the opposite action and we have to validate the module address and check that it was already enabled we can see if a module is enabled by checking if the module we are passing to this method is different than the sentinel module and if the value of this key using the this modulus the key is different than 0x knowing that there is some some value there we could also return or get all the list paginated of the modules that are enabled in the contract we can provide to this method an address that we call the start for the first time will be the sentinel address and then the page size depending on the amount of modules we want to get and this method will iterate in the list in the mapping and in the end we will get an array depending on the page size of modules and the next module that we can use as the start address of the following page and finally and one of the most important operations is execute a transaction this is a public method exact transaction from module that can be called by any account in this case modules will call this method but there's one very very very important uh check that must be met and is that the message.sender must be enabled knowing that only the modules that call this method only if they are enabled they can continue with the execution else otherwise anyone could execute a transaction and that is something that we want to prevent only allowed modules and depending if this transaction is successful or fails then different events are going to be emitted perfect so we saw the side of the safe and now we are going to see the side of the module this is a very simple and incomplete module that we call a custom module and is a module later we are gonna see what is that it has a target that somehow was set before and it has a public method that receives some properties of the transaction we want to send to the safe to execute it to value data and operation [Music] and if we see there's one call that will return the boolean success and that code is using the target the target is the save that has this module enabled or if we are using a a modifier then it's the modifier because the module will send this transaction to the modifier and then the modifier to the safe so whatever it is we are using that target and called the method except transaction from module and passed this these properties so we saw what are the different components in this architecture the modules and the modifiers also how to handle them how to add them remove them get a list of them and now we are going to see some examples or mention some famous modules that are used these days first of all some repositories that are very useful first one is the safe contract that you can find in the account safeglobal from github save contracts is where all the the safe core contracts are and there you can find the specifically the module manager where these operations for modules are defined then we have the safe modules also from the safe from the same account on github and this has the implementation of a couple of modules that the team built specifically the allowance module for example and finally we have another very important repository which is from zodiac inside the gnosis account and zodiac is a composable tao tooling standard that is built on top of the nozzysafe and they have implemented different modules and modifiers that are used by by quite some doubts so let's see some examples uh i provide here the links so if you are interested you can check them later uh these are the for example this module is the one that is used here the custom module is a module this was implemented by the zodiac team and if you go to github you can see this module that has a target which is the account that is receiving the transactions that are sent from this module there are some setters and at some point we have a method that is called exec that is internal so you could use that from your module it has some logic and we can see the the the call to the method exact transaction from module that is in the target as we saw before same for the modifier the modifier is also a module implements some logic that is inside the the nozzy safe in order to handle all the modules that can be enabled into the modifier so here we can find the modules the sentinel some errors and events and we need to overwrite one of these methods for example the exact transaction from module that is public and that anybody can call and here we can define the logic of this modifier also at the end here we can find the functions that handle all the logic regarding enable disabling modules etc and then we have some examples for modules for example the allowance module this module is like a registry of transfer allowances that can be used by a specific accounts knowing that a transfer allowance is specific for a safe for a token and for a delegate account so these delegates account accounts will be able to move some funds depending on the allowance that is set without any other interaction from the signers of the safe also another module that exists is the exit module the exit module uh is similar to the molok taos uh rage quit and it allows the participants for example of a dao that is built on top of the safe and that has this module enabled redeem some tokens in exchange of a portion of all the funds that are stored in the dow or in the safe and we have also some modifiers like delay modifier that we mentioned before where all the transactions are queued sometime and then they can be executed later in time or we can have also the roles modifier and the rose modifier uh allows an aussie safe for example to enforce permissions on enabled modules and these permissions are granular and role based so we can define if a module is associated with a specific role we can define [Music] the type of calls that this module can execute and the addresses that the target addresses of these transactions they must be approved inside this role or also the functions that are called and also the variables that are used so uh knowing these three big topics now the question is will you build the next safe module in the following weeks with us we hope so so uh that's all for from my side you can find us on uh twitter on nazisafe and we also use discord and our forum and we are also we have a specific channel in the 8th global discord so thank you very much everyone for attending and i hope this talk was useful for you i think you have one question in the chat yeah it says can save be created and managed by an external smart contract not interested in building gnosis features yes sales can be deployed by uh by the safe factory and they say factory has a method to create proxy and to deploy analysis and that can be called it's just a call you have to send to this contract i see there are no more questions in the chat [Music] but if you have any other questions that come times to you later we will be in in discord and we can check that there all right perfect thank you so much for taking the time to do this wonderful workshop with the hack money hackers um yeah as uh drummond said that um he will be reachable he and the team will be reachable on the east global discord uh in sponsor gnosis safe uh so if you have any questions definitely feel free to reach out there um and with that being said thank you so much to the rest of you for joining today's workshop we do have one so yeah go ahead one more thing we have two bounties for this hackathon uh one is free like building something on top of the save whatever you want and the other is specifically building something using the role modifier so that was it thank you perfect sounds good thanks for the announcement um and yeah we do have one more workshop after this a scaffold eath one so hope to see all all of you there as well um otherwise have a great rest of your day or evening or morning 