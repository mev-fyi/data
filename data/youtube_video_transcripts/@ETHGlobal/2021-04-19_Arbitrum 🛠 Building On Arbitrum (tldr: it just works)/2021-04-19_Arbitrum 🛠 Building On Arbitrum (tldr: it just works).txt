everybody thank you so much for joining us this morning um i'm really glad to host you with arbitram this morning and um so if you have any question on this wonderful workshop feel free to ask any question in the chat this workshop will be on how to build on arbitrom basically it just works and with us today to present you this we have fred lax and daniel goldman who will be taking it away and introducing himself just now um awesome thank you we will take it away from there um first of all thank you to eath global and uh the scaling ethereum team for uh for having us and organizing this so uh welcome to our workshop this is building on arbitrom um my name is daniel goldman i am a software engineer at off chain labs i am here with hi i'm fred i'm also a software engineer at opting labs and we hope to give you a sneak peek on how the developer experiences when working on arbitrage yeah so we're going to focus on sort of what you need to know in order to build on arbitrary um just as like a quick summary you know probably if you're watching this you're familiar with the theory i'm probably familiar with some layer two but just like two sentence summary of arbitrarium uh basically it is a um arbitrary roll-up is what we're going to be talking about this is an optimistic roll-up style layer two solution supports generalized smart contracts on uh on ethereum uh and is trustless and permissionless inherited security directly from layer one um all good stuff uh and again we're focused on sort of practically what you need to know in order to build so um as we get into this i think a good mental model uh that is useful to have and we like to sort of frame things this way is we can think about the various pieces of um of arbitrary in terms of like this line this abstract line we draw and there's the above the line and below the line components um roughly speaking above the line is like the layer two parts below the line is the layer one parts so if we start by just thinking in above the line terms what we mean is we have arbitrary arbitrary is a block chain if we kind of just ignore everything underneath it right ignore the rest um we can treat it like any other block chain right even though it's not an l1 and has this other relationship with ethereum we can kind of act like it is right it takes transactions it has blocks there's a state the state gets updated it has certain rules it enforces and so on um so modeling uh you know sort of having it in your mind that way is useful and as we'll see um if you're developing if you're just doing something only on arbitrary thinking of it as its own chain you'll see it is very very very similar to developing on ethereum um as far as the below the line stuff waiting for the animation to sink in there um so where ethereum comes in is it it kind of comes in in two places one place is ethereum uh is where arbitrary gets its security and that's like the massive hand wave that we're just going to do that's the part we're not going to go into that's basically the arbitrary protocol um if you want to you know learn more about those details you can see um our cto and co-founder harry gave a talk on friday uh which which is on scaling ethereum website on youtube um where he does more of like a protocol overview and deep dive and then we have this documentation inside arbitrary which is linked here which is kind of like the arbitration protocol bible at this point um so we're not going to sort of talk about those security properties we are going to talk about this other thing that ethereum does which is basically the direct interactions between ethereum and arbitrum um which can be all sorts of things but it's kind of the most important one is moving assets right depositing ether depositing tokens with drawing ether and withdrawing tokens so we'll uh we'll discuss how we support those and of course we have to support those in both directions um thank you fred for the animations um but uh okay so that's what we'll be covering generally but again we're gonna start with just above the line so what i mean by above the line is let's say you want to build something on arbitrary and again you want to just build an arbitrary as though you were building on ethereum you're deploying something directly to arbitram it doesn't have any sort of direct interactions outside of the arbitrary chain itself so what do you need to know in order to do that what do you need to be able to do and basically if you're a adapt developer already you don't need to know anything new um you can use for example hard hat and you just you know you can see this i don't know if you can see my cursor but you can see um the url you just point it to an arbitrary node instead of an ethereum node and it'll just work uh and then in terms of interacting deploying other contracts publishing transactions reading state you can use ethers web3 all of the tooling that you know and love it all just works exactly the same way that it does on ethereum um and that's basically it that's all you need to know uh thank you for coming to our presentation we can uh ask any questions but before anyone leaves we're just joking there are a few gotchas uh when you're actually interacting with arbitrary and for example uh we've by now we've had a few test nets up uh for over five months i believe and initially we had block numbers in the l2 be the same as l1 and we actually changed that to get rid of some weird edge cases that actually started showing up and now the system that we settled in and are pretty happy with is having the notion of l2 block numbers the arbitrary block numbers and l1 block numbers and we do this exactly so we can keep this seamless experience because when developers are using for example lockdown number for timing assumptions we want to keep that and not break that kind of contract but when you have a sequencer at play that starts getting a bit weirder so the design we settled with here for example is that whenever you're inside a smart contract and you call for example block.number you get the l1 block number so you can preserve timing assumptions and when you're looking through the json rpc interface or from outside the chain and where you're interacting with like a block explorer you see the arbitrary block number and of course we have the necessary importances so you can have access to both of them in both places but we're talking more about the default block number you get exposed to the second gotcha is we actually use arb gas instead of gas and that is because when you're in the layer two we have a different set of constraints in a different metering system and how we account for the computation done and the effort done by the network to actually accommodate your transaction is a bit different for example call data costs are mostly like the dominating costs when l2 isn't under congestion and what that means practically is we have our own system for metering gas and for example if you have a hard-coded gas limit on a static call or in a transaction you're sending in that might not be the same in our gas so those are small things you need to tweak that don't necessarily affect the logic of your contracts but might not work out of the box in certain edge cases yeah and just to be clear arab gas as fred said it's like the metering is what's very different in arbitration but the actual asset that's used for our gas is still ethereum that's how you pay for gas exactly and the third collection yes exactly it's our base currents that gets bridged over from dl1 right the third gotcha is we don't have a contract size limit that is bounded by the l1 so the reason for that is actually interesting because the way we do our proving which is interactive proving and harry talks a bit about that on his presentation if you're interested to go deeper into why that doesn't actually limit us but that means that when you're actually deploying contracts to arbitrary we still have a limit but we set the limits in a way that we believe that our software can handle and it's much larger than the l1 and the combination of all these gotchas is that pretty much we have a few up codes that might not behave the way you expect uh the first being like blocked coinbase we don't really have a minor mining floor blocks to create an l2 block so that doesn't really make sense in our context same for block difficulty and the three other options are the gas limits the gas left and the gas price which instead of telling you like the gas using the l1 metering system it returns you the arb gas limit or the arb gas left or the arb gas price and in terms of interop when we look at all these clutches they're kind of quirky but they usually work out of the box we haven't found any weird contracts that break weirdly and they're quite easy to catch and prevent but the more interesting side is when you're actually doing interoperability between the layer one the layer two and back and all that and there are three key components you need to keep in mind when you want to do that using orbit room the first one is the inbox and what the inbox does is it's the incoming interface for transactions that you want to send to our bedroom and outbox is the opposite it's the outgoing interface so the inbox deals with l1 to l2 transactions as the alt blocks l2 201 transactions and the third sys the third component important for interop is arbisis which is a pre-compile it lives in the l2 and using this pre-compile you're able to trigger l2121 transactions so this is kind of like the high-level overview and we're going to go deeper into a bit of each of these thank you fred um so yeah we'll start with um sort of interoperating upwards which is to say from from layer one to layer two from ethereum to arbitrarily so um a way to think about this is in sort of the normal case if you're interacting you know kind of above the line with arbitrary um you you you you create the transaction and you sign it uh sort of the way you normally would and you hand it off to this arbitrary node which aggregates transactions and post them in batches right and when they get posted in batches this is a roll up so the data is going to get posted on layer one and then these these messages get queued up on layer two and that's where they get executed right so that's kind of the standard way of doing things we're talking about interrupting we're uh with layer one or from layer one to layer two we're kind of doing the same thing we're getting a message into arbitrary but instead of doing it kind of from the outside and posting it in these batches we're doing it directly from a layer one contract um and basically the way we do that is we can just do that so we have this feature where you can have a layer one contract make um this external call where it includes some encoded data some api encoded data um of like the message that you want uh that you want arbitram to call on layer two so you can do some stuff on layer one and also do some stuff on layer two in a single transaction um the sort of textbook case of when you'd wanna do this is bridging tokens uh particularly depositing tokens right so depositing a token means what well it means on layer one you're sending it to a contract where it gets escrowed and then on layer two we're saying okay the token got escrowed let's mint some token uh where it's where it's available we'll talk about withdrawing later um but um right so this lets you do that right you can do those two things now an important consideration here is it's very important that uh this operation is atomic which is to say we want either both to happen or neither to happen um but not one um in other words you can imagine a situation where you escrow the tokens on layer one so that l1 transaction succeeds but then the arbitrary transaction reverts right and now what's happened is you've just sent some tokens to a contract and nothing else happened and you lost your tokens and that's bad because you like your tokens so what we we account for that uh that's the sort of retriable part the way these interactions work is they create what are called retriable tickets and basically what this means is if you're doing this um when you use a retriable ticket if the layer two side of one of these transaction reverts for any reason but i guess you know the important one here is if it reverts uh due to insufficient gas insufficient arb gas you um you can kind of just try to re-trigger it so for about we have some some time period about a week it kind of lives in this retry buffer and you or anyone else can just execute it again so in this case okay your tokens didn't get minted because you didn't give it enough gas you just try again with more gas and you're safe and uh yeah so basically as long as you use this for for any sort of operation where you're where you're doing an l2 thing from layer one if you use this retriable ticket you should be safe right because uh you're you're you're guaranteed this this um this atomicity and it is a bit weird if you think about it like you have a contract on the l1 that needs to pay l2 gas and it can get annoying to manage your funds with those dynamics so what you can do is the l1 contract creates a ticket and then you have a new way an externally owned account on the l2 that pays for the gas that that contract created yeah so and that's the other thing that this you know this is uh we're very happy with like how this method has settled we think we covered everything the other thing that's handled here is those yeah those dynamics of like there's layer one gas to pay but also layer two gas to pay and like what if you what if you overshoot it right what if you give too much cash relay or two or something basically with the retriable tickets everything also gets refunded safely so in the worst case scenario you overshoot it you'll just have your extra ether available on layer 2. it's a little more a few layers of complexity there that it's hard to just like explain briefly but essentially there's no way that you can lose funds um so this this covers all those those nasty corners uh nasty corner catches and to be clear um you can do this with anything so you can encode any sort of layer two contract call from layer one um the example i gave here is the bridging tokens and i wanna go a little deeper into that example um so you can look at um our bridge uh we link to it somewhere in here um but our token bridge basically um on arbitrom there's no there's no native notion of tokens there's no native notion of a token bridge we don't need it all we do is we leverage things like these retriable transactions to build this bridge basically as a tap right um so it has contracts on large one and layer two and they communicate with each other in these specific ways um in terms of the bridge itself the the sort of uh layer one to layer two communications that need to happen is we say okay there's some erc20 contract on layer one we need to create a con a sort of paired up corresponding contract on layer two right when you deposit it's gotta end up somewhere uh at its own erc20 and basically so that is one case like the first time you interact with one of these tokens through the bridge we deploy a kind of standard rb rc20 contract on layer two uh which includes like the standard open uh opens up linear rc20 stuff along with some additional stuff to handle bridging minting and stuff like that um obviously we need to be able to deposit tokens as we described earlier so once we have a layer two pairing there we can deposit um and then we also added this nice feature which is mint and call so minting is like you know the layer two side of depositing if say you wanna like deposit something on arbitrarium and immediately uh you know stake it into some lending pool you can just do that in a single transaction and and as with before that call part is arbitrary um so yeah you get a lot of flexibility there um yeah i will yeah so we've seen how the flow goes upwards uh when you're going from the l1 to the o2 but when you're going downwards from the l2 to the l1 there's also some interesting interactions to look at and the way you can trigger a l2201 transaction from the l2 is by talking to the arpsis precompile and you can there's a function in this pre-compile called sendtransaction2l1 and you it allows you to trigger an arbitrary call on the l1 as well and how this works is you give it a destination address and any call data you want to be triggered on the l1 and that's it pretty much at least the start of it after that you need to uh arpsis rbos matches many of these l2201 transactions together into a single micro route and this merkle root is then part of an assertion that is made by a validator on our protocol and how this works is after you wait for the roll-up confirmation time which is part of every optimistic roll-up sending messages from the l2 to the l1 you're able to trigger this call and how you trigger it is you give a miracle proof of the inclusion of your transaction in that assertion and all this is part of the outbox that we mentioned earlier and we have many convenience methods that help simplify this flow for you yeah and i'll just say also you know in this case like once again um you can encode any l1 contract call from l2 so it's generalized and here we don't necessarily get into some of those complications with gas because basically whoever triggers the outbox message is just paying for gas on l1 right um so it's in that sense a little more straightforward than the other direction but yeah in both cases we we can do generalized contract calls uh in in both directions um yeah and this also comes with a few small clutches and there are two main ones the first one is after your transaction gets included into a merkle root it can be replaced on the l1 until it actually succeeds so that means if your transaction reverts you can try it again and be it because you're out of gas or because of an external contract dependency and you can keep on retrying the second gotcha is that the metadata for a transaction isn't available in the traditional solidity syntax because it works let's say sort of like a meta transaction so for example if you do message.sender uh you're not gonna you're gonna see the outboxes or the ridges address you're not gonna see the actual l2 sender so what you can do is you can create the outbox to know the message.sender or the l2 block number and timestamp in which this transaction was created yeah and so there's sort of a more general gaucho that i think most people now understand about optimistic roll-up or any optimistic style layer two solution which is when you're going in the one direction there's this delay right which is to say from l2 to layer one you have to kind of wait for the dispute period and this is just sort of the fundamental security property of rollups so in some sense it's unavoidable um that you'd have to wait for this window however um the good news is that if you are uh withdrawing something that is fungible which is to say ether or some token we have all sorts of ways of speeding this up right um and the techniques here you know basically we like calling them liquidity exits also atomic swaps but with all of these things listed here the general idea i'm just kind of looking at the clock debate how much you totally want to go into oh just um so i won't go into too much detail but general idea here is you want to move some token from layer two to layer one instead of waiting and doing the slow withdrawal some untrusted third party can say hey i'll just take that from you and i'll send you tokens directly on layer one okay and basically the idea is because this is a rollup everything is transparent um everything is published on channel at least in call data they can see that it's going to be valid and they sort of you know absorb this cost in terms of time preference um so in terms of our in terms of uh we have one implementation that does something like this that's our token bridge link so in our token bridge we just include uh the simple method that like lets you do a version of this um we've had other third parties that have built really cool stuff um hop exchange does something where it kind of batches withdrawals together uh and then a liquidity provider can you know see that they're valid and kind of provide liquidity at the destination um connects is kind of in some sense a very different approach where you don't actually do a direct withdrawal you just sort of do this um atomic swap the hash timelock contracts across you change that would be like the way i get my my uh my token from arbitrom to ethereum is i just send some of that token on arbitrary and they send me some on aetherium none of them actually crosses through a bridge so um seller has its own mechanism all these mechanisms um kind of have their own pros and cons um it's also kind of a really broad and interesting design space in terms of coming up with new ways of doing this ways of incentivizing liquidity application specific fast stuff um so this is definitely if you're thinking of hackathon ideas this is this is a good thing to ruminate on which maybe we'll talk a bit more about later um yeah and in terms of when you're busy building smart contracts not just about the solidity or the viper working or whatever it's about the whole infrastructure and tooling setup actually working working for you and that's something that we have that comes from our from actually rbos and us sticking to json rpc interface uh from geth and we have things like chain link the graph at truffle onboard js ethers and they all work against arbitrary out of the box and the cool thing is that much of the tooling actually works because of the json rpc interface and there has been a start in actually moving forward to having feeling that understands a multi multi-chain worlds better but all these tools work really well when you're looking at a single chain such as arbitrary more or mainnet but when you start looking at like different chains interacting together earlier one two three or two these are things that still aren't there there has been a community push to improve all these but it's actually a very big thing for this hackathon at least in my opinion that is there's a huge space to build things with this mentality yes and on that note uh we'll just quickly go over our prize bounties for this hackathon so you can see one of them um is best arbitrary related tooling and the stuff red was just talking about is definitely a fruitful place to start is to think about what tooling out there could use better multi-chain support um and yeah it's sort of like fred said the ecosystem's kind of in this midway point where it's starting to happen more and more uh you know while it's block explorers data providers are are sort of integrating this multi-chain stuff um but there's still a lot of work to be done including some low-hanging stuff tooling we're also including stuff like data visualization uh uh you know getting stats on arbitrary anything around there um is fair game for that prize misuse of arbitrary scalability that's kind of uh the most broad that's kind of the above the line price right so just build something cool that sort of thing you might build on ethereum but build it on arbitrarium and we're especially interested in ways that you like really take advantage of the scalability gains so maybe something that would be priced out practically on layer one or even literally impossible to do on layer one because the contract's too big it's past the size limit or transactions require more execution that can fit in a block stuff like that um it's definitely uh stuff we're excited to see um best use across train interop that's a lot of the stuff we talked about now this kind of l2 to l1 l1 to l2 messaging system uh and there's all sorts of stuff you could do there i talked about moving liquidity in faster ways uh you know there's also again some application specific stuff uh it's kind of cool think about how you can design an app where it has some messaging built in um yeah you can go wild um uh best integration with the arbitration protocol is maybe is actually maybe kind of the broadest but this is stuff that some sort of um application that kind of interacts with let's say the the fraud proven dispute logic kind of sort of um so for example having some like insurance market where you can uh get some crypto economic guarantee that that an arbitrary assertion uh uh finalizes the right way something like that um um again that's another category you can you can really go wild with but yeah we're very excited to see to see what people come up with we've already spoken to a few and people have cool ideas um cool so um yeah what now as far as what's next again if you want to get started building you can just get started building um um the uh we have this token faucet you can use to get some test net stuff directly on arbitrarily meaning like test net ether which is covan ether our chestnuts overclosen um and also we have just some test net token that we deployed that you can play with we do not have an official token um it is strictly a testnet thing um this rbts is uh is a client-side library a typescript library um which basically it abstracts a lot of the details particularly around bridging tokens deposits withdrawals tracking balances kind of extracts that away so i definitely recommend uh using that if you're doing something that is related to bridging bridging tokens um also a lot of the stuff we talked about is documented but i will just say like the documentation is in a state of being updated so feel free to just if there's something that is confusing or something we mentioned here that you can't find documented just reach out to us happy to answer it we'll probably just send you a link on like a branch that's not yet merged um because most of it should be out there somewhere um uh and yeah yeah yeah we also created this repo called the quick start interrupt and what we did there is pretty much this presentation is the high level idea and if you want to get hands-on and see what are like the specific code segments we're talking about you can go there and check uh these slides are over at the eat scaling discord if you want to check it out and if you open the quick start interrupt you can see for example the creates retrievable tickets that i saw someone in the chat was asking about that you can see for example how to trigger an l2201 transaction as well and it has pretty much the general overview so you can start coding we also have a small document the testnet contract addresses that has for example the inbox address and those kind of things so you can get started building yeah some other infrastructure like uh we have the wrapped ether is already deployed things like that so you can uh it's a good place to start if you're deploying um here's links feel free to reach out to us we'll be active on disk we're generally active on discord but especially now during the hackathon um and yeah the inside arbitrary that's the one we mentioned if you really want to do a technical deep dive that is the place to start and probably end should have everything um um quick shout out we are hiring so please reach out to us if this sounds like something you want to be a part of uh there's all sorts of roles open and i think with that uh most importantly you can follow me here on twitter you can follow fred as well um um um we can open it up to questions so yeah if there's any questions from the chat or i see we have a nice little crowd here on zoom feel free to just uh unmute yourself and chime in but uh yeah i also um thought we could take this opportunity to share some of the ideas that fred and i are you know we've been sort of brainstorming on like what would we do if we were part of the hackathon uh which we are not because that would just be unethical but um there's there's definitely a lot of stuff that could be done here um i do have my personal favorite and maybe i'll start by sharing that which is there's a great space for execution markets to be created because if you remember going back uh daniel could you go back to the downwards slide yeah if you look at the downward slide the thing is you have two transactions that need to happen here you have the first transaction which is to trigger your l2201 transaction and then after the rollup confirmation periods you need to trigger the l1 transaction and there's a really cool space there for you to create an incentivized execution market so that users don't actually need to execute that second transaction because anyone can trigger it and you can do some pretty cool setups for that and that's something that please someone built uh i'm begging you yeah so yeah i mean especially for things especially for things that like where the you know as a user you kind of want to just be able to set it and forget it right so that's different than a withdrawal where like i want to have access to my money and maybe use it next but if this is like you know the result of the token vote or something along those lines as long as it migrates its way to layer one eventually you're happy so the ability to just say here's a fee someone will execute it later it's a nice ux and yeah fairly fairly low hanging as far as as far as things go um i think another one that i sort of alluded to is you know and kind of related um stuff like yeah for the stuff that you can't do like fast liquidity exits for like withdrawing a non-fungible token or any like sort of non-fungible bit of data in the abstract sense um you know you can build so like you can't directly inherit arbitrary and ethereum security for any sort of fast withdrawal in that sense but you can if it's acceptable for an application you can build some other security consideration so you can have like an you know you can withdraw an nft and then basically for example have this like crypto economic claim that i swear that you know this token that i have on layer one represents valid ownership of the nft and if i end up being wrong i get slashed that kind of thing um i think you could you could probably generalize that in some in some interesting ways um um so yeah i think reaching those those cases because like this is just fundamentally one of the limits of optimistic style roll-ups um thinking about making that more uh you know like kind of broadening the type of fast exits we can do even if it involves some different security assumptions is a is a cool space to explore but um yeah and in terms of places to see code and get started uh we have the interrupt quick starts that we mentioned and what that does just reiterate is you know the classic creature style contracts that people do when starting off uh you can have a greeter on the l2 or greeter in the l1 and they greet each other but we also have a token bridge implemented that wraps around all that and if you want something a bit more hardcore and some more intense codes that's also a great place to look at yeah so the solidity code of the token bridge that's that's the most extensive use the most extensive usage of our of our interop stuff um and then yeah this this this rts repo if you look at some of the tests i think is probably the best place right now um uh we can just like see how to instantiate things and how it works but yeah if you're literally just doing deposits and withdrawals rps is going to be the easiest way to do it um if you want to more directly interact with the contracts our documentation will does show you how to do that um and uh yeah um excited to see what people come up with i always love like a minute or two if anyone has any questions but otherwise we will again will be monitoring the discord and uh taking any questions there thank you so much daniel and fred um there's some questions in the chat not anyone wants to pitch in um verbally uh yes i didn't i didn't say that sorry let me know there's a yeah there's a few questions that came from youtube in the chat worst case you can always uh address them in in the discord uh or like the two minutes that we have left to recover yeah can you um fred do you see them i think i'm just scrambling with tabs here so uh we have like a a minute left so big a few log hanging ones there's a question which is can we verify contracts on the block explode so right now we don't have contract verification built in but what you can do is you can always just compile the contract yourself and see the created bytes codes from that and you can check it against like the block explorer it does show you the deployed bytes code or you can create yourself the json rpc interface and see and verify the contracts effectively let's see where can we access the slides has been found if we could review the size limits what is it and in what cases would you come up against it so sometimes people write very big contracts with a lot of logic and with super classes that they inherit from and the contract gets very big and then you can't deploy it so what you do is instead of inheriting you do a composability setup and the downside of that is that you need to do external calls for that and i don't know all the theorems here are probably also just need to rewrite your contracts which is which is inconvenient so yeah and also external calls prices went up recently i think it was two days ago so that's also not very nice and the cool thing is your design isn't constrained by the system itself it's constrained by yourself and i we do have a limit but it's pretty damn high uh i'm curious to see if anyone's able to get it if they do please send on our discord with codes that actually make sense yeah thank you guys i think we'll wrap this up um i see there's a few questions that are remaining feel free to go in the discord post more questions um daniel fred and their team will be there and uh and help you brainstorm and debug whatever you you may have may encounter so thank you for this amazing session uh i really appreciate having you and um yeah oh looking forward to seeing the cool projects that come out of this 