hybris dmm or the dynamic market maker so uh before we start off i just like to say that um i'm really glad to be part of this um defy hack fund the hack money so i'm really looking forward to all the different uh daps that everyone will be building so to get kick started just a little bit background of uh kyber so kyber is an on-chain liberation protocol or the dynamics can contribute and access uh before we start off i'd just like to see that 3.0 our next major milestone this vision has been expanded further to represent the protocol as a liquidity hub that aggregates liquidity from a wide range of sources to power instant and secure exchange for any application so as you can see in this slide over here we're already undergoing our 3.0 upgrade kyber 3.0 will transition kyber from a single protocol into a liquidity hub of purpose driven protocols that are catered to different defy use cases this is the biggest change to kyber's architecture and token model since its inception and will be implemented over two phases which we call katana and kaizen so the first release katana has already been released out there and it includes the new kt token we have done a token migration quite recently and an upgraded kyber dial as well and including that is of course the dmm so in this diagram over here you can see that the dmm is one of the liquidity protocols to be developed and be part of this liquidity hub and alongside that there could be a professional liquidity protocol a derivatives protocol and other unique protocols that can be part of this hub and the great thing about this is that makers and takers have the flexibility to be able to interact directly with these different protocols or to be able to use a single endpoint to um uh interact uh with all these protocols in aggregate right so um yeah now i'm here to talk about more about the dmm so the dmm is uh defy's first dynamic market maker a next generation amm designed to maximize the use of capital by enabling extreme high capital efficiency and reacting to market conditions to optimize returns for liquidity providers it has two main features which we call the amplified liquidity pools here in this amplified liquidity pool or a programmable price curve we introduce a amp which significantly significantly uh amplifies the pulse reserves the curves are still a constant product so if you're familiar with the x times y equals the k constant product function but um of virtual balances instead of real balances so thanks to the virtual balances which are amplified significantly from real balances the dmm pools can achieve moderate spread and slippage rates compared to an amm using the um simple constant product function given the same capital and the other major feature is the dynamic fees trading fees are basically adjusted dynamically according to on-chain market conditions this is measured by moving averages over a period of time so in a volatile market which means that it's a higher than usual volume fees are automatically increased to an optimal level reducing the impact of improvement loss for the liquidity providers now for periods of low volatility fees decrease to encourage more trading from takers so tl dr for amplified liquidity pulse less inventory you're still able to provide a high liquidity and for dynamic fees you are able to achieve a higher earning potential and reducing the impact of impermanent loss so the core idea of token swaps has been with kyber since the beginning and is reflected in the design of the dmm where you can swap from one crypto asset to any crypto asset so this idea where you can swap or have this token soft functionality that can be embedded into any application enabling the value exchange to be performed seamlessly between all parties in the ecosystem um end users can swap tokens conveniently across many different interfaces while developers can build innovative applications helping to build the world where any token can be used anywhere so now with the dmm which is completely open and fully permissionless anyone can contribute liquidity anyone can create pools with different factors it is fully on chain which uh simplifies integration especially with the if you you have your own smart contracts as talking to smart contracts like the dmm is straightforward and there are no external oracle risk because the dmm has no um or has no use of oracle's so talking more about the first major feature of the dmm which is the mfi liquidity pool here in this slide we have an example of a 100 000 trade on a pool with a 1 million of liquidity right so with a typical amm which is the you know the normal x times y is equal to kmm you would be experiencing a 11 slippage with that 100k trade in that one million pool but in the dmm and using a am factor of five which means you're amplifying the um liquidity from one one million to five million then you would be experiencing instead a two percent slippage and for a higher amp factor let's say a hundred then instead of a million you would have a hundred million you would then be experiencing a point one percent slippage instead and this is with a 100k uh us dollar worth of a trade right so with this uh most pairs then can enjoy like 15 to 30 30 a better capital efficiency um most pairs especially like stable coins or with uh pairs with very strong correlation can have m factors from 100 to 200 x that will provide way better slippage compared to typical amms and for pairs like wpdc and eth which has some correlation then you can still achieve a higher capital efficiency of 5 to 10x by providing a let's say 5 5 to 10 m factor value so um the the key determinant of the potential capital efficiency and risk of impermanent loss is the relative price stability between the pool's assets there is room for improvement in capital efficiency and negations of impermanent loss by using different amplification factors which will result to different price curves and fee models for different pairs so in this table over here we try to quantify the price stability between a pair of token x and y as you can see here on the left side so in this table over here we have amplitude and sigma mean so amplitude means that the max ratio divided by the mean ratio across a given period a high amplitude means that it represents a bigger shift in the max price ratio between the two assets and for the sigma mean the it is the standard deviation of the mean of the ratios so a higher the deviation the the greater the volatility between the ratios so you can take the first example over here which is apple fourth and eth it has a very high amplitude and sigma mean which means that there is a weak to no correlation and therefore if you create a pool using this assets you need to use a n factor that is not so large maybe one two let's say 1.3 to be able to cover the uh price swings right due to the volatility so the price wins could be quite large um but for assets like wptc and eth where there is some correlation so let's just say in theory that when btc price increases or decreases the price of eth follows as well then you can use a moderate amp factor of let's say five or so since they are they have some correlation and therefore you can expect the uh swings of price not to be as volatile or as large now for um stable coins which have very strong correlation or similar assets such as the stablecoin usd pegged assets like usd team usdc you can definitely use a very high amp factor like up to 100 or 200 because the uh the volatility right or the price difference from one dollar does not deviate so much therefore you can definitely use a very high amp factor for these types of assets so in essence the lower the amplitude and variance the higher potential there is for high levels of capital efficiency and low impermanent loss which means that pools of a given token pair uh the the stronger the correlation between the assets the higher the amp factor we can use when creating a pool and um here we just want to visualize like how the dmm's price curve looks like or the how the constant product function looks like so the first um formula over here is something that's quite familiar if you aware of like a unisop or sushi swap or the other typical amms for dml we can define it in the same way except that you know x prime times y prime is equal to x k prime and we define the variables as such where you multiply uh x times y against a which a represents the amplification factor and k prime we can represent it as k the constant product times amplification squared and therefore um using this formula we can construct the diagram on the left the purple line over here is the um the constant product function and the black line over here is the um real balances so again like uh the the purple line is the virtual balances and the black line is the uh uh real balances so in this graph since the total reserves are amplified price is bounded which means that it does not scale to infinity like a typical amm with an amplified curve there is a max and min price so once the price hits the upper or lower boundary then one side of the reserves are depleted meaning that let's say you have an amplified pool and the price of the token increases so much then once it reaches that upper price boundary then you can expect the token inventory of the pool to be completely depleted and users can then trade only in the other side which means selling tokens back into the pool here we have a more concrete example so on the left we have the dmm pool and on the right we have curve finance so on the left on the dmm pool we have a tvl of 10 million but we're using a m-factor of 100 which means that the amplified liquidity or the effective liquidity is actually 1 billion and on the right of on curb finance there we're um comparing it against three pool which is comprised of three different stablecoin assets the usdc and usdt and this comprises of a total tdl of 1.9 billion and here we're trying to trade against two stable coins usdt and usdc using the same amounts so 30 000 usdt and seeing how much usdc will be getting back so you can see that the rates or the values that being that are being returned are quite similar right despite the fact that the amount of tvl in the dmm is significantly lesser than the the curve pool over here and this is due to the amplification um mechanism that we have for the dmm so going back again to dynamic fees right we described earlier where our trading fees are adjusted dynamically according to on-chain market conditions so again in a volatile market which means higher than usual volume fees automatically increase to an optimal level reducing the impact of permanent loss and for low volatility fees decrease to encourage more trading which results to more fees being collected from the optical volume and we believe that this offers better flexibility compared to fixed fee tiers on other platforms here's another example and this is taken from the analytics page of our dmm and you can find this in info.dmm.exchange are seeing information about an eth can see um pool over here so i'm trying to add liquidity into the spool with an amp factor of 1.9 which again means that whatever um liquidity that is in this pool we are amplifying it by uh times 1.9 right and because of this amplification the price again is bounded so we have a min and max price both in knt and eth so you can see here like an e in eth it would be 0.004 as the max price and the min price would be 0.0024 once it hits any of these boundaries then one side of the liquidity is completely depleted and based on this m-factor the ui as well would give you a range of the fees or the dynamic fees that will be used in this pool so it ranges from point fifteen to point six percent uh meaning that point six percent is charged during uh high volatility uh trading periods and um the total liquidity for this pool is 3.7 million and for the past 24 hours it's about 200 000 in volume and from that 24 hours about 500 530 has been collected in fees and this represents an annualized return of 5.17 of fee over liquidity or basically like what you would say like the apr right for this type of um yeah for this type of pair with this amplification factor and um just also to note is that um for any pair you can actually have many pools with different amplification configurations so this is just one uh pool that has an amplification factor of 1.9 you can have another that has five another with an factor of 10 etc so it depends on the liquidity provider's uh strategy so now we get into the more interesting part of like how you can actually um integrate with the dmm through um smart contracts we have a javascript javascript sdk as well and i'll cover that briefly later on so yeah so how can you integrate with the dmm right and one way is again through smart contracts you can write your own smart contract and directly interact with the dmm from there if you've ever interacted with smart contracts of kyber unisop sushi swap and other exchange contracts before then this should be quite familiar to you to keep things simple and brief we'll cover functions that fetch pool and rates information and functions that execute orders or trades so the first example over here is how you're able to fetch pools from the dmm we have a function called get pools which you can call from the factory and uh get an amplified pool as well so as there can be multiple pools for a given token pair again like for example a pair of eth can see you can have several poles that represent different factor configurations and you can fetch all of this pool addresses and determine which pool would be most suitable for you to query rates do trade execution or you know do liquidity provision um yeah so just call this get pulse method and just input the token addresses of the pair that you'd like to query like let's say in this example we have usdc and usdt and it should return all the pools that is available and if not exist so far then an empty array is returned for for each token pair there should be at least there should be at most one an amplified pool meaning only one an employed pool can exist for a token pair and this basically a uh this pool basically exists as some kind of like it's a type of like a typical amm where the x times y is equal to k um constant product function and supports the infinite price range and in theory um because price our prices are infinite in this um an amplified pool then there should be always been liquidity in this pool here's an example contract where i'm trying to fetch rates from the drm so in this example i've already imported the contracts of the router and the factory because i need those um different contracts to be able to call um different methods from them to be able to fetch information and i'm doing this between two stable coins usdt and usdc so i'm going to demonstrate three different methods of how you can fetch rates um the implementation will be in the next slides but yes three different methods over here so the first method over here which is our recommend recommended method is to query for the best pull off chain and pass it as an input into this function so basically using the get pulse function you can get a list or an array of different pools and then from there you can determine which pool has the most liquidity or whatever your criteria is and pass this instead as a argument into fetching rates so one of the functions for fetching rates is called get get amounts in the other counterpart is get amounts out get a mods in means that i want to get the equivalent amount of a destination token given an exact amount in so in my case it would be 100 usdt whereas for the function get amounts out i want to get exactly this amount out given a let's say a sum minimum in um yeah so the only inputs that you'd need is the pull addresses again determine uh something that you will be able to determine off chain and then the token path which is constructed from the previous slide from the source token usdt and then the destination token usdc and it should return an array of amounts the second method is to use the unamplified pool and while it is convenient it may be sub-optimal and the reason why again is because an amplified pools even though it represents a typical constant product function curve um it might not be giving you the best liquidity but at least you'll be assured that there will be liquidity there because prices scale to infinity and it's as simple as just getting the single address because only one token pair can have one amplified pool and passing this as the pull path into the get gets amount in function now the third method is to use a pool found in the first index of the pool array and if there's no pool found then it just returns an empty array and therefore you return like a zero rates so instead of like um sorting through the different pools returned by the factory you will just get the first index and use that as a means for fetching rates or doing trades but again this could be sub optimal because the pools in get pools the the posts returned are unsorted therefore you might not be using the pool with the best liquidity or it could be even a pool that has no liquidity left so um instead there could be a combination of using the first method and another method that we described here which is uh logic where you can have in a function on chain or you can have this kind of logic off chain and basically um you are getting all the pools using get pulse from the factory to fetch all the pools for a token pair and then you're sorting it by liquidity this can be done by fetching each post k last method which is uh basically whatever pool returns the highest kls value has the highest of liquidity so the best is to do this off-chain where you uh sort the different pools return and get the posts with the highest k last and pass it as an argument into the first method of fetching rates which is uh this one over here that would be the most gas efficient way but if you are needing to do this fully on chain then you can do a combination of the recommendation over here this one and then passing it to a function as the list of pull addresses to use in your fetching of rates or trades this examples over here you can find them in the docs site in docs.dmm.exchange the full list of examples are there as i've demonstrated here as well in the previous slides so um here's an example of a swap execution where i'm trying to trade from one each die we have uh many different um swap functions and it depends on like what you're swapping so in this case since i'm swapping for e3 tokens then i'm calling the swap exec eth for tokens but if i'm swapping tokens to e then i'm calling swap exact tokens for eth and if i'm swapping tokens to tokens then i'm swapping and then i'm calling swap exact tokens for tokens so for the arguments over here so i don't have to go into them in detail you can just find them in our documentation in our site yeah this can be said as well for any token that you where you would want to utilize a different pool paths so for example i would want to trade from usdc to wptc pool and then lastly to eth so i would just need to find all the different pools and pass that as the path uh into this uh function over here and the rest would be typical like for the any uh swap function that you've seen previously and for a description of the other arguments you can find them in our site as well um yeah but again if you used um or if you ever interacted with sushi swap or unisop then this kind of argument should be um quite familiar to you as well now for tokens that have fees built in we call them a fee on transfer tokens so tokens for example they could be like a gold or some stable coin where when you transfer them some fees is taken out of the balance from your transfer um this is supported in the dmm as well we just have a very long function name for this which we call swap exact tokens for tokens or swap exact ether tokens supporting fee on transfer tokens i know it's a very long functioning but it's quite descriptive and it has the typical arguments except that it supports this fot or fian transfer tokens um of course for the dmm you are able to call functions to add liquidity directly as well so you can create a pool using a the third argument as the m-factor so we we define them in basis points over here so in this example where i'm creating a pool for die and use usdc with an n-factor of 50. and if i want to create the pool and add liquidity at the same time in a single transaction then i can specify this arguments as well where i specify the two different tokens the m-factor to use and then the liquidity to be provided more description again about this function can be seen in our docs website so uh one thing to add is that like other amms once you add liquidity you will be receiving an lp token deck or what we call a receipt token that represents your share of the pool and for each different um pool again each different pool can have different factors you will be receiving a different um uh lp token so you can have an lp token for an eth knc pair that represent an n factor of five and an lp token that represents an factor of 10 for the same token pair for removing liquidity we use the erc2612 pattern the permit pattern where you can just approve or sign a message that allows you that allows the contracts to spend your lp tokens to burn them and retrieve your liquidity back um yeah and you know the usual like arguments that you just need to supply into this function which you can find more um in our docs website um and for the javascript sdk uh just to go through it briefly um it has the typical functions where you can query rates and information and for you to be able to construct a trade as well so we have an npn package called at dynamics sdk if you just install this you will be able to make use of the libraries to for example catch token data uh and pull data for example yeah like this example over here where i'm fetching um pair data and from there i can get the mid price of the two uh tokens in that uh pair um so so that i don't elaborate more you can just find more information about this in our docs website but yeah you can use this in your hack as well now to wrap up um the dmm is committed to security so we are audited by chain security and is insured up to 20 million we have an ongoing bug bounty as well so if you find any bugs in our dmm contracts please let us know and you'll be rewarded accordingly for that and some brief statistics since its inception we we deployed it last april 5th it's been a bit of uh around two months um there has been a total volume of 100 million with about 18 million in tvl but with the different amp factors in the um different pools we have a total amplified liquidity of over 1 billion in the dmm we have an ongoing proposal as well to deploy the dmm on polygon network and this covers the liquidity mining as well on that network so this this proposal should be concluding in the next few hours so if you have some kntc staked in the kyber dell and you haven't voted yet please vote on this proposal and you can look forward to be able to interact with the dmm both on eth and on polygon network as well so for our bounties we have over 8 000 worth of uh prizes in knc to be distributed to the different um hacks first price is three thousand dollars et cetera et cetera if you're not one of the top three um projects that have won a prize um as long as you've hacked something on the dmm then you could be eligible for at least 500 dollars to uh with your project right but of course prizes are to be awarded at uh kyber's discretion and um just to give you some ideas about your hack um using the dmm you can for example create a yield farming or yield vault integration using the dmm itself or maybe it's lp tokens you can utilize the lp tokens in some interesting way one great thing is to build a better visualizer of the different factors and you know price ranges of the different pools such that you can visualize them like have a graph and see like what are the price boundaries for example and um yeah so just throwing out ideas over there and uh hopefully you can build something quite interesting in this um this hackathon so here are uh some final references like to the exchange documentation etc we have a intro video about the dmm as well to describe whatever i've talked in this presentation you can find it in kyber's youtube channel and if you want to read about it you can just visit our blog at blog.com.network and find more details about that there so um that's it that's it for my talk and um yeah i hope that i'm really looking forward to all the different hacks that you guys will be building um if there are any questions then i would gladly look into them right now yeah i think there's about we can maybe handle the three questions that are um in the zoom chat now right so the first question is um how does the dmm compare to uniform v3 so the concept of the dmm and unisoft v3 uh unison b3 uses a concentrated liquidity concept and for us we use an amplification concept the concepts are actually quite uh similar right where we're basically being able to amplify balances from uh real balances right but the implementation is completely different so one um significant difference in implementation is that for for the dms case each configuration is a different tool whereas for unit swap they have a single pool but your position is represented as an nft so i think that that's like a brief um summary of it but uh yeah like uh like concept wise i believe that it's quite similar um yes so the second question is so amp factor is an extra parameter that is based on perceived expected stability of the current price from swappers um yes so you basically can configure the steps uh yourself um it really depends on your strategy so for example if you believe that uh certain assets have strong um um correlation like for example maybe eth and something that is very closely to eat let's say like rap etc for example then you can um you know have a large amount of amp uh value over theirs because um again by having a large value then it means that you're you are having a more concentrated like a price swing right it doesn't like uh deviate between that uh price range um okay here's another question all exchanges are showing different usd usd t rates can you explain why it was okay um so the reason why there are different rates from across the different like dexes or decentralized exchanges is because um uh there's this um kind of like inefficiency right when it comes to um on chain right where um in order to update rates you need to do a uh on-chain transaction so let's just say you have a difference of price between um uniswap and kyber if let's say the price of unisop is much higher than kyber then somebody will be able to take advantage of that by selling on unisop and then buying on kyber but in order for the rates to normalize or like to be as close as possible then people would need to do on-chain transact transactions for this and as you know um transactions are only mined like every 15 seconds on average on ethereum and it really depends on like the market activity as well like if the market is quite volatile then you can see um price differences to be quite large between the different dexes and this is where that's why there's a lot of arbitragers and bots that are taking advantage of this um different uh price rates because it's a very uh profitable um situation for them basically yeah i guess that's all the questions yeah that's um all the questions and if anybody has any more questions for anton you can find them in the uh sponsor kyber network channel in discord and i want to give a very big thanks to anton for taking such a jam-packed session um there was a lot of content in just 30 minutes and yeah if it would also be great if you could share these slides in the spot the sponsor channel so that everybody can um go through these slides again in their own time but yeah big thanks for joining us today anton and thanks everybody else for joining i gave my pleasure as well thank you everyone great 