can okay bernard floor is yours all right thank you uh thanks uh thanks for having me thanks everybody for being here and uh since fluence uh has a couple of challenges up uh with uh various prizes for this hackathon i want to go over a small workshop 30 minutes and if you have any questions just to shoot the main point here actually is we want a building composed by three protocols with fluence and aqua as part of the website jam and uh as nisha pointed out i'm bernhard and i'm with fluence labs so the rest of the presentation is pretty much unpacking that statement which is the head in the headlines and uh just as an overview for you not familiar entirely with left fluence maybe is that it's a peer-to-peer application platform and allows you to create applications free of proprietary and central a printalyzed apis and uh and actors such as major cloud providers and at the core of the fluence pwp solution is a protocol which is very compute specific and that basically means that developers have to bring their own store distributed store to the solution to the applications and we can do this by integrating with peer-to-peer solutions like ipfs file coin ceramic textile etc which enables now a really wide variety of decentralized use cases and as part of the solution we provide it's everything is open-source by the way it's very permissive mit apache 2 development stack so you can actually program peer-to-peer applications through workflows and service compositions without relying on anybody in between no centralized intermediaries and so it really really gets you right into the the wheelhouse of web 3 and particularly web 3 off chain which is the really important part here [Music] so fluence in a nutshell so if you look at it from a network perspective on the right you have a little mock-up network three nodes basically peer-to-peer and the greenish uh round circles are client peers which could be a browser could be a very thin edge device for example and the peers so nodes in the peer-to-peer network commonly are referred to as peers and one here is marked relay relay peers or relay nodes are nodes that are accessible publicly there could be nodes or peers behind that relay that are not directly accessible because of that or any other some other restrictions so really it's just a node that's publicly accessible and that allows you to route to possibly inaccessible publicly accessible nodes the nodes that say service on top of it are sill nodes and basically what you do in fluenz as it is this application platform a general purpose application platform you create services and then you deploy these services onto one or more nodes so if you have some something very simple like hello world you create a service that basically takes an input and comes back with you know hello your name whatever you deploy these services onto different nodes one or more and then you can compose these services into into an application now in order to be realistic we don't expect everything to be on the fluence network per se which it by itself actually is open and permissionless so anybody can join run nodes and be part of the network and allow you to integrate with external resources already available could be microservices some basic api services and of course ipfs and we call the services adapter services and you have to write them which at the the most minimal basically are wrappers around the api of that external network service and some of those services adapters are already available for you including an ipfs adapter so if you look at those those this little network on the right and you see the services deployed so now the big question of course is how do you actually access those services how do you chain or compose those services into an application it's peer-to-peer so you don't access those services with a rest api or json rpc instead what you do is we have a dedicated programming language called aqua which is very very high level super economic dedicated towards marshalling and composing these distributed services on a peer-to-peer network into applications and we'll get into examples just a little bit and all that happens on top of flip p2p so you really get this full peer-to-peer stack and you even got a very simple very powerful language that lets you allow that allows you to program these services into applications which if you do it right actually ends up to be a decentralized application which is the really important part again in the context especially of off-chain services and applications so how does it work we have two foundation parts one is called aqua and one is called green so we call it aquamarine aqua is a set of tools including a programming language that facilitates the composition of those distributed services now what are those services where do they come from those services actually web assembly modules and it's actually web assembly interface type or wazi 32 it is not your general binden uh webassembly you generally see in the front-end browser environment nevertheless it does run in the browser and marine is actually the general-purpose runtime that allows you to execute those services so what you end up is you you write those uh modules and they're fundamentally shared nothing and then you provide some linking instructions and then upon deployment of on a peer you actually create a service which is a virtual construct over those modules and the linking instructions and for that you actually end up having aqua vm which is a virtual machine that runs on every pier as well as marine on every pier that processes the compiled aqua descripting language which we call air which is the aqua intermediate representation and we'll go into this a little bit more by example it should become very very clear and it sounds a lot more complicated than it actually is from a user perspective what that does is a highly distributed peer-to-peer environment and that allows you to really build distributed applications by composing services where the business logic is totally separate from the workflow so that actually promotes tremendous reuse and a few other web 3 attributes like decentralization and and auditability in a decentralized manner you get peer-to-peer applications so this is particularly important of course if you are looking at messaging applications and you fundamentally end up with zero trust applications if you've been following sort of the trends and i t zero trust frameworks are super important trust nothing essentially verify at every step and this is exactly what happens in this period peer network so those green dots here are what we call a particle and we'll get into this in one like on the next slide but basically what happens every time you execute a service on a particular peer you have an ingress and an egress and there are verification steps at each way and that gets you by default to a zero trust composition a composition of zero trust services which extends to zero trust applications which if again if you uh uh uh since we are operating in an off chain open permissionless network this is super super important and getting that out of the box for you is is instrument is a tremendous help and ease of burden for developers so the green dots let me go back one more time the green dots here so we said we have this this aqua script right we compile it into error and then we sort of process it with on the aqua vm which is on each and every one of those peers deployed as is marine which then actually executes the services so how do we get from this peer to peer how does that actually happen and this is one of the core foundations of the fluence model it's what we call a particle you can think of it as a smart package and basically what it is it is a conflict-free replication data structure that combines data the execution sequence as expressed in aqua and some metadata and what basically happens is that you have a forward chaining data model a push data model that is very different from your traditional client server model instead of having a call out to your server getting the result back to your client pushing it out to another server getting the result back you end up with this forward chaining of the data package and since it is a free replication data structure guaranteeing eventual consistency you actually end up with a very very thin client requirements and basically what we're doing is here so we're calling the uh the recalling we send this particle you can literally think of flinging it out let me just go back here if we start out at this client here let's just say it's a browser and we want to call a service hello world what we're literally doing is we have the data which is say the name so it's hello name that's the service we're flinging it out onto the network and then the network starts resolving the attached script the airscript on where to go what to call how to update that data structure and at the end get you back with what you expect to get back and this is this is this is uh at the core of the foundation and this is an extremely ergonomic way of dealing with general purpose peer-to-peer networks and it's extremely powerful because unlike on-chain we have three solutions like in the blockchain if you think about it every every transaction gets recomputed by every node so we end up with uh eventually with the longest jane wins solution and that of course has a lot of problems not problems but constraints including scalability constraints attached to it on the off chain side where fluence comes in it allows you to build these decentralized offchain applications and the network itself is well it's not infinitely scaled but it's highly scalable because no node reruns your compute or your application it's just run once but what you end up with is you end up with a with this conflict-free conflict-free replication data structure which allows you to audit and actually rerun the computation and test that computation for correctness and that is extremely powerful again particularly for off-chain because it gives you certain guarantees you wouldn't otherwise have so let's actually go from the conceptual and uh and the academic to some code a little code example here and look at what it does so if you look down at the code this is aqua code so if you're familiar with python or or scala or you know javascript for that matter typescript it should look very familiar the part that's missing here and this is what you see up in the little diagram is we have a service we have a webassembly module that takes two parameters a string and a boolean and it returns a string and basically it's a fancy hello world so where the string let's say is the name and the bool determines the type of greeting so if we have uh uh our name is web3 jam and our boolean the greeter is true the service returns a string that says hi web3 jam if the boolean is false it says by web3 jam so it's not it's it's just a fancy hello world what we're doing in line one through two we are creating an interface binding to that deployed service so that service is out on one or more nodes and every time you create that service on the network you end up with a unique service id which is a uuid for basically and which you see here this is the reference so if we want to bind that interface to the actual to an actual service on a particular node we need to give it the service id if you are familiar with solidity or especially solidity this is very very similar to what you see in your apis and then from line four through eight we actually write our aqua code so this is where you compose your services and one of the extremely powerful aspects of that is that even though it's not i mean i wouldn't call it content addressability but there is location addressability all you need to know as a developer you need to know where your service is on which peer which you should know once you deploy the service or if you use somebody else's service they should give you the the location of that peer which is the peer id here and the actual service id associated with that service and then of course you just provide your parameters to execute that service so what we're doing here so this is where it gets really cool anybody who's ever done any peer-to-peer programming uh particularly at the lib p2p level you will appreciate the uh enormous convenience and ergonomic of aqua basically what it says on this note on this node this particular peer id where we have it's a string it's basically the peer id which is usually starts as one two deep whatever we bind this service interface to this service id it's right here then we call that function associated with this interface which we just call greeting we give it the name and the greeting type so this is the name the string and the boolean and we get a result back that result does on that particular node we initiated this through our particle this one once it's compiled this is our execution script attached to the particle uh now we want to get the result back to the actual client and this is what happens here if you look up in the diagram this is exactly what's happening here and and this this shows you the data push problem so how is lib p2p uh utilized at the the nodes the actual nodes the peers they pull that make up the peer-to-peer network sit on top of peer-to-peer lib pdp sorry and uh so the whole gossip uh the data exchange uh the security model the end-to-end subscription this is where uh lit pdp comes in does it answer the chat question i hope it does if not post more and and so instead of having to go down in your traditional peer-to-peer programming resolve all this how to resolve how do you do discovery it's all taken care of for you or it's very easily accessible at a very very high ergonomic level this is what aqua brings to the table now once aqua is compiled it's it's not by code but basically it looks like blasp like closure for example and it's machine readable and it's very very not fun to manually program we had to do it until aqua came along so you are all being saved a lot of pain and suffering and so in order for the hackathon to to really accelerate so i understand there is a lot to be learned if you want to bring on fluent offchain because i presume most of you haven't haven't dealt with it yet so we got pretty extensive documentation but we also have ready integrations and examples so for example we have an ipfs library that allows you to directly integrate with ipfs using aqua so it's all this is i mean this is the important part you use aqua to not only program the stuff your services on the fluence peer-to-peer network but also in this particular case what's on the ipfs network so you can you can actually what you can do and there's a very extensive example in our examples what you can do is you can actually create a service deploy that service or put that service on ipfs and then use aqua to load that service from ipfs to whatever nodes you want to and the way this happens this is where this is our ipfs library from fluent and the way what happens is you basically have an integration that runs ipfs as a sidecar to the fluence node and then at the file system level transfers transfers uh cid referenced data blobs to the fluence node which then is accessible by services deployed in that particular node so now i may or may not have to but i will tell you the following in the web assembly you don't have sockets and webassembly are single threaded so there are some and there's a strong security model through sandboxing particularly uh web assembly interface types so how do you actually interact with the outside world this is like one of those uh outside inside jobs like you have on blockchain no it's not part of the marine environment what it allows you to do is through explicit permissioning it allows you to break through the or punch through the webassembly sandbox and actually interact with permissioned binaries on the fluence node that solves a whole bunch of problems including saving files locally as well as using curl among other things or predominantly curl to actually interact with the outside world and as i said i mean web assembly modules themselves or web assembly it is single threaded so there there are limits you can you have and through marine we are reducing and fundamentally eliminating a lot of those constraints that come with it so you can actually program uh very very easily to interact with the outside world in addition to the ipfs we have i just we haven't we have examples on how to integrate ceramic and run ceramic now i'll get to that a little more because i want to look at the code with you guys and go through it then uh actually i listed uh some of uh previous hackathon examples so we have an example from a previous hackathon for a really cool project where it basically uses and creates and manages nfts on ethereum testnet i think it's uh cool and i'm not quite sure and uses fluence for that so this if you're interested in nft and off-chain management or nfts in some shape or form this is a great example including a simple nft contract to get started from a very recent hackathon we had with with ceramic we have multiple solutions on how to use decentralized identities ceramic self id from fluence and using aqua to program it so if if that kind of authentication is something you need in your dab don't worry it can be done and there are some really cool building blocks available from previous winners and lastly as an example there is a increasingly complex ethereum integration example uh jarrah is doing it and he won also a previous hackathon and he he keeps on working on it and extending on it and there is a lot of interesting ways on how to interact with ethereum using influence as an off-chain complement any questions i see yes okay what are decentralized identities decentralized identities is a standard that lets you that lets you wrap public keys and on the back end private keys so you can identify through the key and authenticate uh it's i think it's the id org and one of the the most premier use cases right now is uh it's called microsoft ion which is based on an implementation a merkle-like implementation called site tree who are looking into replacing it your traditional quote unquote traditional login approach with uh you know username password using the ids one of the interesting part of the ids is because they're chainable so you can actually uh start building a trust relationships uh and uh it's it's a pretty good project it's in the draft stages of the web 3 consortium but uh look it up it's it's it's taken the uh particularly the web 3 space by storm because it's the underlying technology for self-sovereign identity or is is pushing it's positioning itself as the underlying technology for itself sovereign identities okay so any questions so far i know i'm going fast i know i'm going fast but we don't have we only have half an hour and if you have questions keep asking or keep bringing them up all right now let me switch to [Music] so just so you know uh when you're using affluence we're we're a relatively young project from uh go to market perspective been around for several years but uh really pushing uh the features now on the project and if you're using vs code for example we have an aqua extension which helps you with some syntax highlighting and we also have a dev container a dev container basically is a development container that includes all the fluence tools everything you need including a node and you can run that as part of the vs code container volume so you can so hang on it's labs here and uh okay why can't she access it because i probably uh uh has typed it okay uh okay there we go okay so def i just saw it okay here it is it's it's extensively i'm not going to install it now because it takes a little bit but it's extensively documented in the fluence documentation on how to use it and it's used in multiple examples in the quick start category in our example so if you want to use that have a look at that anyway the point was vs code integrates very nicely with with aqua and some of our other tools so let's just have a look real quick how do you interact with uh ceramics and uh as i said so we could have then gone through the ipfs code however there are at least three videos i've done on how to use fluence with ipfs they're on our including at least one previous global workshop so you should look at that because not much has changed in terms of in terms of features and i didn't want to redo that because if you wanted to go into uh ntfs particularly dynamic ntfs ceramic might help you even more so for you so ceramic is built on ipfs and it's very interesting because basically it's a it's an append log type database and you can anchor commitments onto you in your pen log in ceramic on blockchain so it brings a immutable capability that has yet reference anchors that are immutably committed onto the blockchain it's ethereum or i think near is also a possibility and ceramic has two well it has multiple apis one is the command line api and one is the http api so basically what you do is you create a stream they call it streams and it's not unlike a document and uh you basically start pushing your data which could be a kv store for example now installing ceramic locally is very easy there's no big problem however the ceramic ipfs back-end does not uh uh interact well with the actual ipfs back-end so there are some challenges in installing it and we've done it for you we have three test nets and the test net that has full ceramic nodes and the side car available is the stage testnet and so now i gotta oh i am really low on time i've implemented for you so you can basically use that that those very uh ceramic services and uh as is and basically access ceramic from aqua so we have these services and they basically wrap the uh cli or https so one of the the the interesting aspects of cli versus https api from ceramic is with https for some reason you cannot create a stream but cli lacks a whole bunch of chain information such as which chain you're on pinning and chain health and a few other things also since there is some anchoring happening it's only the hdp result that shows you whether or not an anchor is pending or actually committed all right now look okay so let me go back to the chat real quick yeah that threes see it's the the web three consortium yeah that's that's the one you you're talking about okay take more ten more minutes all right yeah i don't wanna i mean i'm sure everybody has things to do so let me okay so i obviously have done a few things before because that now i can't find them okay one of the parts so as i said before services run on peers and they get executed on the marine because fundamentally a service is a virtual construct that links multiple one or more webassembly modules into a seamless api if you will now for a variety of reasons you can actually run run that marine runtime locally and that allows you to uh to [Music] to test and interact with your with your code locally so here we have this is what i implemented uh for the ceramic adapter to interact with ceramic and everything that's http is prefixed with http if it's not it's a cli so one of the things we want to do is we want to create we want to create a a stream where is it come on i'm i'm blind now i'm going blind create stream there we go so what you do is the in order to call these services we call it then we use the uh domain the namespace which is uh adapter and uh let's generate custom adapter and then we wanna do uh createstream and uh we use a kb uh uh jason string where our key is fu and our our value is the bar open all right so we run that and we have an error no connect and that is because my local ceramic daemon isn't running so let's bring that up and let's run that again and here you go so not unlike uh ipfs you get you get an id and it's called a stream id in [Music] in ceramic and we can now check using actually the http interface for streams using the local uh node i have on i just brought up and it tells us now a lot of things but the most important part is here let me make this a little bit bigger is here so the anchoring status of our request to write to the ceramic stream is pending in terms of uh of uh unchain anchoring and it's going to take a while for this to uh to come through now if you look at the show stream just for just from the cli perspective you get a much poorer information content that's why you really almost want to double up on cli and uh and uh http okay and uh if so this would be a decentralized key here because ceramics actually enables that on its streams as well okay let me get to this question at the end uh about the multiplayer now all right let me let me i'm scrambling now because i'm obviously already over time and i didn't get anywhere near where i wanted to get let me get go immediately to the prices this is why everybody's here let me go to the challenges we are offering and the prizes and then i'll go back and see what we can do so we have two types of challenges one is the nft challenge and one is sort of the best use of uh fluency when you're there obviously in both challenges we want you to use fluent and aqua and uh in the nft we have two two two tracks if you will you can choose either one and one is basically a dynamic nfc lifecycle management the fluence in aqua and the other one is to build an auction protocol with flints and aqua for off chain nft nft uh trading and the reason of invading and even the dynamic nft's off chain is important because right now a bid on layer one ethereum for example costs you several training and two hundred dollars just for the bid that doesn't mean that the bid is guaranteed right to win it just means you place the bid and uh and uh here's a little bit more detail on uh on the those two challenges now dynamic nft lifecycle and this is why i actually kind of i i think it's one of the coolest things in nft at a i mean by a long shot this is actually to me this is where nfcs are super valuable and uh i would be super excited if somebody was uh taking this up in their challenge and go for their bounty and basically and this is where ceramic comes this is why actually because it makes it super easy to do so for example think of a sports person card or a politician and now you want to actually update their metadata according to external events and you can use fluence to source your oracles if you will if that's what you want to call it uh and and drive these uh these dynamic updates to the ntfd metadata so you could literally if you're uh if you're ntfs nft nft represents a football player or a basketball player or whatever a soccer player as a game runs you can start updating the metadata the stats on that player on that persona you can do the same for politicians if you're if you're into it i actually think this is really interesting because uh there's a lot of uh uh uh pools that uh monetization pools around uh uh politics and uh bed pools and uh crowdsourcing pools and uh actually linking that with dynamic nfts to me is like super super interesting because uh uh you can almost look at like widgets now in your your browsers in your application web applications backed by uh immutable decentralized uh data structures and to me this is this is a very very exciting area of nfts the other part was uh to do auctions as i said the high gas on a per bid on a per bid undertaking is is prohibitive to do anything unless you have like super highly expensive mfts so you're sure if you have a digital artwork or a cryptokitty that sells for 160 000 and it costs you to i don't know 300 to to run through your auction and put your bids in no big deal right but if you have uh less expensive less valuable nfts then when the gas costs exceed the value of the actual item it just doesn't make sense and again you can start tracking on ipfs or something like ceramic again you can start tracking bids and since you even though the log itself is immutable you set these anchors on chain where you can track exactly what has happened and then where the immutable data points are so if you have like i don't know 10 bitters one way of looking at for example if you could write 10 ceramic streams and uh and and one for each bitter basically and really track those those bids uh very very nicely and keep anchoring those bids on on chain very very inexpensively and so those are the nft related uh examples we have if you have a use case where you think in the nft area that's not mentioned reach out to us we're certainly open to uh to to entertain uh other approaches and then best use of your app if you have a dap and you want to use some off-chain component to it like fluent we would really like you to look at fluence and aqua and things like oracle's indexing cross-chain indexing are super interesting from a compute perspective and then again with ipfs or ipfs related solutions like textile or ceramic you can you can you can build these peer-to-peer decentralized data layers that uh bring a lot of decentralization and and even actually like really good performance particularly compared to the unchain solutions uh to use to your dab i think i'm definitely out of time i uh i saw nisha blind so this is good i'm sorry i didn't get quite as much done as i wanted we have uh telegram we have uh a lot of channels discord there we have our own there's the one with the global you can reach us we are distributed through uh north america and most of europe so with a little bit of luck we got 24 7 coverage and that's it from my end i see a few questions okay i think everything's been answered so i said i'm sorry it's a little rushed if you have questions please reach out we're super excited to be there thank you for having us thank you for being here and as i said we're really really looking forward for your contributions and solving those challenges thanks everybody yeah thank you so much bernard thank you to fluence for sponsoring uh what through jam this year um a really great workshop and again i want to emphasize that um if anything comes up with fluency or if you just want to talk to bernard i know this workshop was a little bit rushed but you can always uh hit him up on our discord and all the other platforms that he just mentioned so yeah everybody have a really great day thank you again and i'll see you at the next 