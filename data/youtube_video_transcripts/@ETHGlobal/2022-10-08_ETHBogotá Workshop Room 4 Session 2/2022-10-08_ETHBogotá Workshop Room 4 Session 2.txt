foreign all right hey everyone can you hear me well is everyone still awake all right so welcome everyone my name is Peter I'm gonna talk about scroll tonight and first of all thanks a lot for joining us tonight I know it's very late and I know most of you are just as jet like this I am so really appreciate that you joined also before we start to all of you who listen to the the optimism introduction uh one hour ago I want to make a public announcement so scroll is in fact the only serious blockchain out there and the best layer 2-3 here so I just wanted to correct the optimism team there so any questions all right so who who heard about scroll hands up okay quite a few So today we're gonna see how you can deploy contracts on scroll and I'm also gonna go into some details about how scroll does what it does and and what is it so scroll is a layer two to ethereum and it's a ZK evm based layer too so our goal is to scale ethereum so we want to have you know more transactions lower fees while we maintain the same level of security as layer one so it's a ZK rollout and why is it a ZK evm basically we want to maintain very high level of compatibility with layer one so the idea is that when you develop on scroll it feels exactly the same way as when you develop on ethereum you don't need to learn a new language you don't need to learn any any other tools you don't need to understand what the xeronage proofs are everything is done under the hood and you just develop your depth and it's fast and it works and it's safe so that's the idea so we're going to start by looking at how you can get started with our testnet and the most interactive part of this Workshop is hopefully you scanning this QR code which you can use to sign on to our test net So currently we're in a permission test test net phase so that means you have to sign up you have to get on the white list and once you get on the white list you can get some tokens you can deploy some contracts Etc so you can either open scroll.io early Dev or you can scan the QR code is the same thing you feel it and after a few hours we will put you on the white list and then you can start building and we also want to encourage you to join our Discord and then you can also ask technical questions there give us some feedback uh all that stuff all right so we're gonna have a very simple live demo here if it all works okay so so when you get started on Scroll once you get on our white list the first thing that you want to go to or the first website is pre-alpha.croll.io this is our so-called pre-alpha test net and this has all the information and all the tools that you need so metamask configuration faucet for getting getting funds and a bridge to bridge from layer one to Layer Two so a bit about this test net so in mainnet of course layer one is going to be ethereum and Layer Two is is scroll uh but in this test that we're actually maintaining a simulated layer one so we have scroll layer one test net and scroll layer two test net they are both maintained by us so first thing that you want to do is just simply add these networks to your metamask so that you can send transactions and and query the blockchain on these two Networks so after this you're going to have two new configurations the metamask and this automatically will configure the RPC address and also the chain ID okay that should be pretty straightforward and the next thing next thing you want to do is get some funds so so as I said we're not operating yet on ethereum we're not operating on ethereum test that we're maintaining our own layer one so you need to get some test ethereum and once you're on the test net you can just request some funds and you will get one test ether and 100 test usdc tokens and then you should be good too so after that you should have some test eth and before you can start deploying on scroll the last thing that you want to do is move your funds to Layer Two So currently from the faucet you get your funds on layer one so you don't have any tokens on Layer Two so you you need to use our bridge and it's a very simple ux you've probably used plenty of you know similar depths you just enter the amount send the transaction and under the hood we're maintaining this bridge from layer layer one to layer two and it's uh relaying uh tokens like eth erc20 tokens you can also relay nfts which I think is kind of unique or not so uh not something that you see so often but actually this bridge is also it's an arbitrary message Bridge so so if you want to build something using this bridge then we're also open to that so just reach out to us so by the end of this onboarding process uh you open your meta mask and now you finally have some funds on Layer Two so it's time to start building and I'm going to use this open Zeppelin wizard here which some of you might have seen this is just a very simple tool for putting like implementing tokens with no coding you can just uh choose the features that you want to have so we want to implement an erc721 nft token and let's say it's a scrollers nft this is probably going to be one of the first nfts on Layer Two uh so it's a historic nft and the only feature that we want to add is that it's going to be mintable so we're gonna be able to meet new tokens and that's about it that's the coding part of this so-called workshop and the next thing I want to show you is how to deploy on scroll and I'm going to use remix for that but as I said the main goal with scroll for us is that we maintain 100 uh even though we are a zero knowledge proof roll up or a zkevm we maintain 100 compatibility with ethereum so you can use remix you can use hard hat you can use Foundry all the other tools that you that you're already familiar with so here just click on open in remix to to open this code and I'm just going to use remix as I would use it on ethereum so notice that we don't have any scroll specific here solidity is compiled into evm bytecode as on other evm chains and then you can just simply go to the deployment part to deploy and scroll so select the scroll add to test net and choose the injected provider metamask and you see that I have my uh balance here and just click deploy and then it should be deployed so at this point if this deployment fails for you when you when you're doing it change chances are that you either don't have enough funds or that you are not on the white list yet so feel free to register or reach out to us and make sure that you're on the white list and now we have a contract deployed on scroll it's actually fairly straightforward just as another example I'm gonna mint one token to my own address so call this save mint function again just confirm the transaction is going to go through within a matter of seconds and uh now we can see it on the blockchain Explorer I minted one token to my address thanks so that's the example with remix and for a more detailed tutorial you can go to guide.scroll.io where we have all kinds of guides about our current test net including a contract development or deployment tutorial and this is an example repo that we have again it's just a very simple contract I think if you've developed an ethereum this should all be very familiar to you and you can either deploy with hard hat or you can use Forge create to deploy with Foundry as you would do another change so back to the presentation so you might ask me like okay so what is the point why what's going on Peter why are you telling me stuff that I already know and I would argue that if this is all boring to you that's kind of the goal that we're aiming for so the goal with scroll is that you're building on ZK evm you're building a layer two but you don't have to learn a new language you don't have to learn a new new tooling a new ecosystem you can just use your existing tools out of the box and it works exactly the same way and when I say exactly it's not actually 100 percent the same so we have like some slight modifications uh if you're familiar with the vitalik's classification of zkevms we're aiming for type 2.5 which means that there are some slight differences between layer 1 and layer 2 like the gas costs might be different because some operations are more expensive in a ZK uh roll-up and the other thing is that some op codes might not work as as on layer one for instance self-destruct is going to be disabled but I think for most apps that that should not be an issue so now now that you understand that scroll works exactly the same way from your perspective as ethereum let's dive into some technical details of how we implement this ZK AVM stuff so here you can see like a high level architecture so we're operating on Two Chains as you would imagine layer one and Layer Two and in our case layer one is the ethereum mainnet and the two main components there are the roll up contract and the bridge contract so the roll-up contract is basically maintaining the state of the layer 2 Chain it maintains uh the data from the layer 2 Chain that's the data availability yeah the content of the data availability and it also receives the zero knowledge proofs and maintains the state route of the layer 2 Chain the bridge contract as you just saw in the example it's for bridging assets from layer one to Layer Two as I said it can Bridge all kinds of contracts sorry all kinds of assets and this is pretty familiar uh pretty similar to other chains and now we get to the juicy part which is actually the layer 2 implementation it has let's say four major components so one is the sequencer node which is responsible it's basically maintaining the blockchain so it's a fork of go ethereum it's responsible for collecting transactions creating blocks and yeah just maintaining the blockchain itself then we have the relayer which is a strictly related to the bridge contract so it's for relaying messages between layer 1 and layer 2. both ways and then most crucially we have this component called roller so that is the prover in our system that is the component responsible for creating the zero knowledge proofs so the way it works is that for each block the roller receives this block or received some data related or derived from this block and using the ZK evm circuits it creates a proof for this block so what does it actually mean so you could imagine that currently we have state a so stage root is a now we get a new block and now we transition to State B by executing that block uh so we have the state transition from A to B now what the roller does is that it creates a proof for this execution of this block and then using this proof you can actually prove that this transition from A to B is correct you can prove this or verify this without actually executing the transactions so that is the essential part how zero noise proofs are used in in all ZK roll ups is that you create this proof of the state transition which the rollout contract on ethereum can verify independently so in our case we have a decentralized network of rollers so if you have a couple of spare gpus and you want to earn some money you can actually uh during mainnet or the next testnet iteration you can actually join our testnets you can spin up your gpus you can create some zero noise proofs and you can earn some rewards for this and to maintain uh this connection between scroll and the rollers we have a coordinator so coordinator is simply responsible for assigning blocks to the rollers receiving the Xenoverse proof and verifying it uh yeah these are the main components and if we zoom into the roller itself like what is the workflow of the roller the input for the roller is the execution Trace so for the block you could imagine that we generate all kinds of informations about the execution of the block so that includes all the op codes that were executed all the storage entries that were updated all kinds of information and that is the input for the circuits and the ZK evm itself which we are developing uh along with the ethereum foundation is a collection of circuits for approving these uh different state transitions so we have an evm circuit that proves that the opcode was executed correctly then for instance we have the storage circuit that proves that the storage updates were also executed correctly and we have a whole bunch of different circuits proving different things these all create a different CK proofs that we aggregate into single proof and that is the output of the roller and just one final diagram of this whole process like how does it how do we all put it together uh in terms of time so on this diagram you have time as the x axis and we see the process of uh of the zkevm so you can look at the sequencer the sequencer is creating the layer to blockchain so it's creating blocks one two three four and all these blocks are first of all committed to ethereum so we have the data available in ethereum at the same time the coordinator will assign these blocks to different rollers based on some some algorithm and the rollers will start a proof generation session so this is a pretty expensive computation but this only has to be executed once and later we only just verify this proof that was created so for each block we create a proof and then finally we can aggregate these proofs uh into single proof and that is submitted to ethereum to the roll up contract and that is verified independently by the contract so that is how it all comes together hopefully to all of you who didn't know how ZK VMS or ZK rollups work this kind of demystifies some of the main ideas zooming out a bit so again our reason is to scale ethereum so it should be faster it should be cheaper and it should be just as secure as layer one and that is what ZK evm does and in our case so there are many different companies working on ZK EVMS and there are different design trade-offs to be to be made in our case we aim for as much compatibility as we can and that means that we're aiming for bytecode equivalence so that means that you take the evm bytecode let's say from remix or from heart hat that you deployed on layer one and you can the in exactly the same way deploy it on layer 2 and it works the same way then we have a decentralization as a main design component so as I said the approvers or rollers are decentralized from day one so decentralized during the minute launch and eventually the sequencer is also going to be decentralized and finally we're pretty much aligned with the ethereum ecosystem so we're aligned with ethereum's roll-up Centric roadmap and we're also building the ZK VM together with the ethereum foundation uh so there's a lot of like uh very highly skilled ZK Engineers working on this if you're interested in ZK all of this is open source so I encourage you to look into it I think it's pretty complex but this should be a very uh interesting thing to you and what can you do so we are a sponsor at this hackathon so we really would like to welcome you to build on scroll as you see if you've built on ethereum before then it's very seamless very easy to move to scroll and uh you can build all kinds of applications because scores is the general purpose layer too for instance you could build some more complex amm taxes that might not be feasible on layer one because of the computational burden or similarly some Landing pools with some more more complex uh borrowing computations or I think a very exciting idea is a Webster web 3 social apps which I think current systems can actually support the user experience that we would expect from a social app but layer 2 blockchains especially ZK AVM might be an excellent fit for this or you might want to just build some simple nft projects or if you're interested in ZK you can just build a ZK dap on scroll and the advantage here is that we have a lot of Engineers that are super experienced with ZK so if you're if you choose this route then we're more than happy to guide you and give some help so we have two bounties one is for the most Innovative dap and the other one is for the best CK depth and all in all you can get like five five thousand dollars so yeah if you're interested please please join or please just find us uh it's me we have our team members sitting at the back so feel free to reach out to us and ask some questions and finally some resources for you to get started first of all you should go to scroll.io early Dev again to get on the white list for our test net and then you should go to guide dot scroll.io to find all these tutorials on how to deploy it scroll how to get funds all that all that kind of stuff yeah and finally uh here is the most important resources so on the right you get these slides so you can review all the links and everything on the middle is the Discord of scroll please feel free to join and on the left is my telegram so if you have any questions to me or you have any issues you didn't get on the white list Etc please feel free to message me directly yeah and we're also hiring by the way so if you're a zika engineer if you're interested in you know infrastructure engineering feel free to reach out to us as well all right that's uh our workshop for tonight thanks a lot for joining do you have any questions yeah go ahead yeah thanks for the question so the question was that like how much is proof generation is uh reliant on gpus what is the specific requirements that we have here and how does this relate to you know ethereum after the merge becoming more and more green uh so I think GPU accelerated CK is a breakthrough in the last few years and that's what makes really easy KVM possible so previously we had more stuff running on CPUs and that was not really practical for any you know any practical purposes uh recently we have GPU acceleration and that makes it practical in terms of running time and I think in the future we might have some Asic hardware for this so in terms of the environmental impacts there is some similarity here to mining for sure because we have a decentralized network of provers the consume a lot of energy to create these proofs I think there are some very interesting or very important differences though because in proof of work you to like useless work I mean it's useful in terms of proof of work but the computation that you execute doesn't have any uh useful results by itself in our case the computation that you're doing is is actually useful because you're calculating these Decay proofs that many many people will use to verify the state transition in the future so so I think this is not really the same thing or the same uh concern as as proof of work and also there won't be so much of a armed race here because whether it's profitable for you for to to create proofs uh depends on the depends on the utilization of the system basically the more blocks we have the more transactions the more rollers can join the system and contribute but this is linearly uh you know directly related to the amount of usefulness of the network as opposed to proof of work where if your neighbor gets more computing power then you're also forced to get more competing power to remain competitive I hope that answers the question any other questions what happens if the coordinator makes a mistake uh so what kind of mistake do you do you have in mind yeah that's a good question like if if something goes wrong what happens and also given that some of these components are centralized on day one is there any kind of cheating that scroll can do or the maintainer of the coordinator can do so the way it works is that before we even do an SDK proof generation we commit the block data on layer one and uh yeah this this data is available for everyone to see on layer one and this at this point it cannot be changed and so this is the comment phase and once we have the proof that is what we call finalize when we make it final uh you know it cannot be reverted what's on layer one so so what can go wrong if we look at the coordinator uh it cannot really fake any proves because all the data is available on layer one so only a correct proof will go through and if the roller let's say fake fakes the proof we can catch that at the coordinator level because it's fairly cheap to verify that the proof is correct but even if we don't verify that the coordinator level the rollout contract will verify the zero noise proof and will revert the transaction if there's a there's an issue with that that said I think there's an interesting question here of uh auditability or like how can we make sure that the zika evm is correct because it's a extremely complex you know set of circuits there's not that many people with these kind of expertise who can review and audit them uh so I think the most crucial part is to make sure that this component of the system is correct and for this if you're any any of you is uh you know ZK Enthusiast uh we would invite you to come learn about our circuits and once you have a good understanding start reviewing and start seeing if there's any error so there's going to be bounties for this we also hire people just for this purpose to make sure that the circuits are correct uh so that's the efforts that we do thanks for the questions maybe one last question if if you guys have any any more okay thanks again for joining at 10 pm I really appreciate it and hope to see you around at the hackathon so enjoy um so this Workshop is on transaction insights uh to give you a little background on what transaction insights is it's a it's a feature that we've exposed to the metamasknaps platform that allows snaps to render certain insights on transaction data so we make it available we make unsigned transaction payloads available to snaps that have this transaction Insight endowment to be able to make these insights so I just wanted to show you guys some links that I have available that you guys can read into to learn more about the API so we have something called sips which are snaps Improvement proposals and so this transaction insights feature was specced out in sip3 if you guys want to just take a moment to you know jot down the link or whatever you can do so and these sips are open to discussion so if you guys feel like uh the API can be improved upon or you'd like to see new things inside of it you can join the discussion um and another link that I'm providing here is uh for a cape too so we use this standard to um uh basically identify different chains with so there's this whole concept of namespaces and chain IDs that we're using under uh Casa which is stands for chain agnostic software Alliance and so we're using this standard for our chain IDs now to get started on the actual Workshop itself so I would like for you to clone down this repo first this is the template typescript snap repo so the first thing we're going to do is just get the link here um and we're just going to clone this down up foreign here that's good cool all right so uh um if you look on GitHub it should be template typescript snap is is a repository um if you guys just want to take a minute or two just to clone that down um and then there's also a a certain build of metamask flask which I'll ask you guys to install into into your Chrome extension um if you guys aren't familiar with flask flask is our basically our Canary build of um of the metamask extension in which we've released a snaps platform so I'll get you guys the link to that in a second cool so uh if you go to this link here uh you'll see this metamask bullet guide um and it'll walk you through how to install flask um so the build that you want to use is on this link here um if you just follow the steps if you want to take a couple minutes to do so please do that what's that oh it's on Discord okay does everyone have this build installed already no okay so just take a couple minutes to do that different from the regular what's that yeah we have the transaction inside API available in this build we haven't cut a new release yet so we're using this custom build I'll give it another minute or two um so people can catch up so once you have a flask installed please open up uh the the repo that you just uh pulled down um so this is uh just a template uh basic template uh typescript template for for a snap and this is what we're going to work off of uh to create this uh transaction Insight snap um so what you first want to do is just uh run yarn install to install the dependencies cool um so you'll notice that we're importing on our PC request Handler um we have different Handler types with the addition of this on transaction Handler so we're going to be pulling in that instead and so the type of this will pull in a transaction and a chain ID if you remember what I mentioned about Cape 2 this chain ID is a cape to chain ID for demonstration purposes we're not going to like parse this chain ID or do anything special with it but I just wanted to let you guys know that this is the type of chain ID that you should be expecting uh when when uh you know writing transaction Insight snaps uh so we want to be able to export on transaction um so the call and then so we're just going to delete all this out of here um and so the the return object is expected to be uh having an insights key um and inside of this insights object you can add in whatever sort of uh key value pairs you'd like uh so for demonstration purposes we're just going to spit back the transaction chain ID um so you basically need to just save this and then we need to add in uh the permission for um transaction insights which I just need to double check what it is exactly cool so now you just save this um and I think we should be pretty much there you don't need to touch this index HTML file it's already good to go so it picks up on this snap ID since this is a locally hosted snap we're not deploying it it's going to use this local prefix so everything is set up for you already you don't have to worry about touching this now the next thing we need to do is basically just build and serve this snap and we'll do that here so we need to do yarn build and yarn serve cool so this is um starting the server on localhost 8080. you can choose to change where the server is hosted in snap.config.js so you would just change the port if you if you wanted to so now we'll navigate to localhost 80 80. cool so you'll see this prompt here we're only concerned with the connect button uh because uh there is no like UI interaction within the DAP itself so transaction insights uh they're displayed in the confirmation screen of of metamask uh when interacting uh you know with contracts or even EOS so we'll first install the transaction Insight snap here and you can see that it's requesting certain permissions to be able to display a confirmation and then Fetch and display transaction insights uh so we're just going to approve and install it and now it's good to go um now we're going to test out this uh snap and see if it works on uni swap cool so you just connect your wallet um and we'll do a simple uh eath to wrap teeth swap cool now if you notice there's a extra tab here that you wouldn't see otherwise it has the name of the the transaction inside snap now this this snap only shows up because it has this endowment and uh you know it was able to do this because we gave permission to do so now if you click on it uh you'll see the transaction payload and the chain ID that was sent to the snap and it basically just spit it back and this is pretty much it um this demo was to illustrate you know how this works you can do a lot more interesting things with uh transaction Insight snaps you can use services like tenderly to run like a transaction simulation and and get more insights that way um you know you can write transaction inside snaps to maybe detect phishing on on on different dapps um the world is your oyster with transaction insights um yeah it's pretty much it um if you guys have any questions uh let me know um and I will open this document back up I have my telegram here I have my Discord here and these links are here for you to follow if you need yeah this is it [Applause] cool I'll just leave this here for like a minute or two more 