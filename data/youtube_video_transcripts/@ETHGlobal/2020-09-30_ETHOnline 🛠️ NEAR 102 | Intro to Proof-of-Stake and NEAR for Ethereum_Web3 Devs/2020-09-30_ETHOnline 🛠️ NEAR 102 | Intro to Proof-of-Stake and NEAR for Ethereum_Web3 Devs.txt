click the link right there and i'm not going to keep the chat open because it takes up a lot of real estate here in the in the slides so if you want to watch a recording of this there's a couple of them at these links at the top and otherwise i'm going to go through the presentation but i'm highly interruptible so what that means is if something doesn't make sense or more likely if if you know something about what i'm saying maybe more than i know about it and you want to interrupt and kind of uh you know correct me or add a little bit of you know color or texture to the conversation don't hesitate um i think i think that's really the best way to make this work so i guess the fastest easiest way to do that is just to kind of type something in the chat and then heather will be your voice um uh to interrupt me and then we can kind of talk through whatever it is that you have in mind so um you know we've got about an hour together um i'll do my best to to make sure this hour is is useful for you and um and so we can you know just kind of get started with that so so this workshop is uh intended uh you tell me if it works uh to be an intro to near protocol for ethereum developers i myself am not an ethereum developer so i'm taking a big risk by claiming that i can actually make a workshop that's an intro for ethereum devs so you'll see along the way kind of where i've i've done my best to learn about the ethereum ecosystem and building on ethereum here on the first slide again you'll find the recordings at the top right a couple of uh install steps if you've never installed node on your computer then i wouldn't do that now but if you have it then you can install the near cli the command line interface for near in just a couple of quick minutes and you can make a test account for yourself on year and that way whatever it is that you see me talking about or doing you can just verify yourself all right um so um why near that's probably your first question so here's why near is cheaper faster and easier to use that's our claim i'm going to do my best not to read off the slides but i'll talk kind of around and about them so when you're building contracts on near you can use assembly script or rust those are the two languages that you use to to build contracts uh that that you can then compile to webassembly wasm and then you deploy to near and uh that's different from ethereum in that you would use solidity typically i guess there's another language viper i don't know how popular that is but you would use solidity um and uh and then you would compile that to uh you know what whatever the evm byte code is that it expects and then and then you would deploy that to the evm uh so with with uh nier you're building on languages that have these communities that are not necessarily specific to uh to blockchain so rust obviously um is a high performance systems programming language with a lot of type safety rich tool chain huge community the rust wasm connection is is really tight it's the maybe the most mature wasm uh compiler out there um and so uh so if you're dealing with high value contracts you want to you want to use rust so any contract that's going to be dealing with a lot of value you want to use rust but assembly script is familiar to um to javascript and typescript developers and in fact it's a strict subset of typescript so if you are familiar with front end dev then assembly script is just a snap to pick up it's really easy and you know the mental models of near don't change across these two languages so if you're coming from javascript or typescript you want to get started right away dive into building contracts with assembly script figure out how near works and then if you want to learn rust you can you can go and do that if you're already familiar with roster if you come from like a high performance systems programming background c plus plus or whatever and you're familiar with uh with types or strictly type languages because the rust type system is unforgiving uh then then go for rust right off the bat nothing wrong with that okay so that's that's kind of the the high level story in terms of development and and the argument there is that it's cheaper to onboard devs the you know learning and development troubleshooting debugging process is faster and easier to use because uh because of the maturity of these tools in production um gas fees are are designed to be lower so orders of magnitude lower than those of ethereum just out of the box from like the primitive level operations and obviously those can be changed through uh governance processes but but at genesis on mainnet test now whatever they're super low so there's also these mechanisms where contracts can earn fees they get currently at genesis they were set up as 30 of the the transaction fees go to the the contract itself are allocated to the contract account which means developers have a mechanism for revenue uh collection that's like baked into the protocol and and so that that lowers your total cost of ownership of contracts obviously and some other benefits there um and um uh you know in terms of kind of it being uh snappy uh we're talking about like one second block time three second finality which is significantly faster than ethereum so that's the argument uh why you would think about nier is that it's cheaper faster and easier to use okay uh and and obviously uh you know ethereum uh uh and and the ethereum network and the ethereum community uh is um is where it's at it's where it's been and and where it will likely be in the future and so um i think the argument here is really uh that we'd like to play uh with and alongside of these applications and you'll you'll see a bridge in a minute here where we're talking about connecting the two networks sharif we've got two questions just uh what lawson interpreter do near clients use and what aspects of the rust tool chain speed up development um yeah so i think we use wasmer and uh i think wasmer wasn't time and there's another one maybe but i think it's wasmer uh is the short answer to that and and if you want to dig into that i'm happy to to connect you with uh with the the devs but if you go to near.chat you'll jump into our discord and you can ask there and devs on the you know the core dev team will will be able to respond with more detail i think the short answer is wasmer in terms of the rust tool chain that make things faster and cheaper to build with in general when you're building software i mean i hope uh i don't come off as like a know-it-all i'm trying to answer your question here so let me see if i can if i can do it justice when you're building software like a big a big part of the cost of development uh comes from the maturity of the tools that you're using so if you're if you're building against like an esoteric language or a custom built language or a language that has sort of an isolated community then typically there's going to be rough edges in the tools um testing debugging um the the kind of the development testing debug cycle itself might be a little bit slower setting up a test environment setting up a dev environment all those things are going to be a little bit uh rough around the edges compared with an environment where there's you know a large community of developers that are innovating for for many different target environments um and so did you know whether you're building on a mac or windows or linux or whatever you're you should have a smooth experience basically the more mature the language in the community and the tools that they use are so hopefully that answers the question in general any kind of custom language is going to be a little bit rough around the edges compared with a general purpose language so that's the argument i'll just keep going heather if there's more follow-up maybe you can just kind of interrupt me again i'll assume that's okay all right so several examples and starters if you go to near.dev you'll see maybe 12 or 15 examples some of them are written in rust and assembly script and and basically you know you can go in you can check out the source code all of everything i'm talking about including your protocol is all open source so you can check out any part of any of these tools or systems that i'm talking about here and the the examples on nir.dev you can actually run right in gitpod which is a web-based editor that we're using to it kind of gives you a visual studio code like experience you can go in there and just start tooling around without installing anything locally so that that's pretty cool and and of course you know these examples are going to range from like random things that we've decided to build to you know uh erc 20 and erc 721 uh clones uh you know that that kind of stuff so implementations on on near of those of those specs and and we call them something a little bit differently on the air but you'll you'll be able to read more about that so anyway these are examples you can just kind of get started with and you can actually get started building a new app in just a couple of minutes so if you want to start typing like now and see something work in the next 30 to 60 seconds npx create dash near dash app and then whatever your app name is in this case it's banana and then just run the you'll get an assembly script contract by default with a plain javascript front end by default you can switch that to rust and react but i would recommend against that because with rust you're going to need a little bit more tooling to do your development compilation process a little bit slower assembly script is going to be super fast and then if you're not familiar with react obviously that's going to add overhead to your learning process so just like plain javascript is the simplest code you'll find there so npx create dash near dash app and then whatever your app name is it'll generate a folder build the thing you jump into that folder npm install and then near npm run dev will create an account deploy this app to testnet for you and it'll load on your screen you'll be you'll be up and running it's pretty fast if anybody's curious just shout out in the comments and i'll do it for you really quick to kind of give you a sense of what that feels like so in general same same but different we're talking about ethereum so talking about primitives for example and here i've just picked a few things so account state transactions gas and and blocks um with accounts you're talking about on ethereum two kinds of accounts is my understanding so externally owned accounts and then contract accounts and you know there's some things you have to know as a newcomer to ethereum like externally owned accounts are basically the uh you know um i don't know last 20 bytes of maybe the implicit key generated from the public key of the public private key pair or something like that i might be getting that wrong and and like the external accounts are the only things that can generate new uh calls uh contract accounts don't have a key pair they're controlled by the contract so there's some like specific constraints on accounts and what you can do with these accounts that that makes perfect sense once you get it with near there's basically just one kind of account you may or may not deploy a contract to that account and it's fine whether you do or don't the account holds its own state can have many keys unlimited number of keys per account and so so in there's a detail there you you'll notice that like nonces are are kept on the uh keys not on the account uh for example um and so um uh so with state uh ethereum state is replicated across every node and you've got this kind of single threaded machine that's moving with near state is isolated to whatever the home shard is on your account mainnet is currently only running one shard on your test net is running one charge we have a guild called the sharding guild a group of people who are dedicated to kicking the tires on a multi-sharded environment i think they've got four shards running right now that was the last i heard a couple of weeks ago and um and so what what happens is when you deploy an account as a developer you don't think about what chart it goes to the protocol decides where to put it and then if an account gets particularly hot like a cryptokitties account and starts consuming the capacity of a shard then the protocol reserves the right to move that account to its own shard to isolate it so the other accounts can take advantage of whatever the throughput capacity is so i think it's 200 transactions a second is the upper bound if you kind of tune the transactions but it'll almost certainly be lower than that for sophisticated transactions i guess uh so so 200 tps per shard is like the upper bound on that and then and then it would scale you know almost linearly per shard this the system uh and so with near you can think of it as like a multi-threaded system each each shard is operating as its own thread and then they get reconciled through consensus over time um i i guess the closest thing to that in the in the the way we talk about this stuff is like a bunch of side chains that they get that get merged into into some kind of like home chain or beacon chain or something like that i'm not a blockchain protocol expert by the way so if i'm not making sense at this point please forgive me uh transactions um with ethereum you've got the idea of like a transfer a contract deployment and a function call um and you know contract deployment is like you send a transaction to a particular address and then like the protocol knows that when you do that that it's going to take whatever the data payload is turn that into a contract account that's generated from whatever your public key is on the eoa that made the transaction you know incrementing the nonce one so you get this automatically generated contract address there's a bunch of this like implicit stuff that happens in ethereum with transactions and so with with near conversely you've got these eight basic actions and you compose those into a transaction that you then send to the network and to deploy a contract for example you just um you know make an account and then you deploy a contract to it you can make a single transaction that has create account action um you know deploy contract add key and then invoke a method in one transaction and do that all at once if you want as well those are choices that you make with those actions you can basically compose these actions into a sensible transaction then send it you know sign it send it to the network gas price in ethereum is determined by network load and profit motive to make sure that people kind of keep the machine working the way you would expect whereas near's gas price prices is algorithmically controlled so to try and converge on 50 congestion in a shard so if if the the shard gets over congested then the gas price goes up uh at a maximum of like one percent per second one percent per block basically and since the block is about one second that that's about how fast it will go up to try and uh disincentivize people from from you know using uh the network and then if the uh congestion goes below 50 then the gas price will drop at the same rate one percent per second one percent per block uh to to encourage use of the network so there's that kind of stuff it's a little bit different and then ethereum currently is proof of work obviously moving to proof of stake soon and um there's um a consensus at a rate of of one per uh 15 um seconds or minutes i'm sorry i forget right now and that seems like a silly thing not to know off the top of my head and with near blocks are produced with proof of stake a consensus at a rate of one per second so um so that's kind of like the the high level of these primitives in terms of some features um there's um this um kind of standard comparison so erc20 with uh fungible tokens erc 721 with with nfts the equivalent is nap21 to match the erc20 and then ndp4 to match the erc 721 and and the the differences in in these neps um the idea is that uh that we're taking advantage of the sharding mechanism and how accounts are used and so that there's a few slight differences in the interfaces there and and some new proposals for improving on those as well are currently in in process for a transaction result you check scan on the ethereum side you just kind of look it up there with near you can use near explorer or you can use the cli to check the the transaction status by passing in the hash there's a couple of special data types and i just kind of wanted to draw some parallels here so with ethereum you've got the address type you've got the mapping type with ethereum all accounts are string type and so you can you can validate using a regex basically is valid account id um and um and for mappings we've got a set of of collections so so this this the storage and nears all key value pairs and then on top of that um that key value pair uh data structure we've added some other abstractions right like a double ended queue or a vector or a map or whatever uh and so there's a bunch of those and they'll anything that's in blue in these slides you can you can click on a link to get to it and just to remind you i posted it already in the chat but it's bit.ly slash near-102 to get to the slides uh so um so any of these links you can click on that'll take you right into the the list of the collections in rust or assembly script for example ethereum has a payable method nir has a payable uh macro that you put on rust on rust methods and in assembly script you just have to check to see is there some attached value and if so you might want to throw or something like that and then there's an event model in ethereum where we don't have an event model in the year but you can pull this particular rpc method called experimental changes with some parameters and that will give you filtered log events basically if a filtered sense of what's happened on chain and then to run a node you would use something like ganache i think a state-of-the-art ethereum with near there's a near up it's a python script that kind of you know manages whatever it needs to do in the background you know spinning up uh nodes and so on and you can tell the nodes to run in localnet or testnet or mainnet or whatever with some some command line switches so that gives you kind of a high level comparison of maybe some features in terms of deployment again i'll just remind everybody if you've got questions you want me to stop or go back or something like that just interrupt in the chat if i don't hear from you if i don't hear heather interrupting me i'm just going to assume that you want me to keep going and that the pace is okay because you're not saying slow down um so um so for uh for ethereum deployment um you know the idea is that you would compile this contract byte code uh compose a transaction attach the byte code maybe some initial value sign and send the transaction to the special address that then creates the new account deploys the contract and you get the new contract back right so with with near similar you compile the the byte code and then you compose this transaction but the action that you use is deploy contracts it's one of those eight actions you can also add things like create account with it if you don't already have an account that you're you're deploying to you might want to add a key to allow you to control that account you might want to transfer some value as well when you when you do that you sign and send that transaction and then you you receive the outcome basically and of course you if you have a full access key maybe i shouldn't say of course because you're just learning this but every near account can have many keys i think i mentioned that before and the keys can be one of two types full access which basically lets you do everything including send money delete the account deploy contracts and a function call access key which is constrained by a budget a set of methods and a receiver the receiver can be the account itself on which the key is set or it can be a separate account that you can use as like a proxy budget so i can use a function call access key to spend a developer's money in like a trial basis to call a contract account that they've deployed and so you could use that for like a freemium model for example to onboard people without having to create an account and and do all sorts of stuff so anyway so so we can we can kind of mess with these these actions is the the idea here um and then just kind of looking at this as a picture ethereum transactions near transactions um they all kind of you can kind of think of them as having this metadata you know attached value and then like some kind of payload so metadata maps nicely here origin vrs details from the the signer you can figure out who the signing account was in here you actually have the signing account and their public key is included in the metadata of the of the uh the transaction destination ethereum calls the recipient near calls the receiver uh uniqueness there's this idea of a nonce and and then the nonce is really like part of the um the key in in and then cost control you you would handle that through a function call access keys if you wanted to set limits on budgets uh so that's part of the metadata an ethereum transaction you set the gas price in the limit and then there's this idea of recency with the block hash because of the proof of stake is my understanding so you have to include something from within the last window of time that window is set at genesis as a configurable kind of limit on on how uh sort of proof of recency for the transaction um and and i i think it's set uh something like four hours or uh whatever it is but you can look that up uh it's just part part of the genesis configuration and then value is basically just attached ether the native token in ethereum and attached near tokens in um in your protocol so nothing really different there and then in terms of the data if for example we're making a function call uh the the data would include like a selector of the you know the function signature or whatever some some prefix i guess first four bytes or whatever it is of the function signature and then arguments encoded in some way and then on near the actions are these eight actions that break up into these four categories so identity related actions like create account delete accounts security related actions add key delete key there's two kinds of keys full access and function call access value uh you know for transferring and then staking where you kind of lock value up uh to maintain the integrity of the network and you earn some interest on that and then code where you deploy a contract or make a function call so that's kind of the deal there here's a little bit more about each of those eight actions i'll just take a breath for a minute and let you let you read this slide any questions how's the pace should i speed up or slow down sometimes i get to talking a little bit too fast i don't see any comments so it should be all good or every or everybody is asleep face is okay speed is near perfect yeah okay wait was that a pun oh well done nice well played sir or yeah okay so moving on um mapping concepts so if ethereum and near here custom language custom vm on ethereum so obviously the pros are like all this stuff is designed for the blockchain so maybe you can even formally verify it there's a there's a bunch of of good stuff there and it's it's proven it's been around for years now and it's it's managing a ton of value the cons are you can't really reuse solidity anywhere you can't like bring in libraries from anywhere um you know it's just like it's just solidity in that custom language on nir you're dealing with assembly script and rust the wasm vm and so you know some of the things that we talked about before the tooling the community and uh and obviously some cons is that it's not designed for blockchain so like some things you can do like anything that reaches out to the machine any libraries that that sort of expect there to be a clock for example like that's not going to work or a file system obviously that's not going to work so because it's a resource constrained environment on chain so it's a little bit different that way but but it's you know kind of pros and cons here of some of these ideas and then pros and cons just on near of using assembly script versus rust for sure if you're coming from a web dev uh world like assembly scripted probably would take you like an afternoon to to get to you know intermediate or expert level uh in writing assembly script and if you're familiar with typescript it's even it's even faster it's like just like a no-brainer but the compiler is immature and so we don't recommend assembly script for high-value contracts prototype to your heart's content but the minute you're going to manage a significant amount of value rewrite your contracts in rust and it's the type safety and the maturity of the compiler that gets you that gets you that that safety basically all right so we can talk about some differences here because near is sharded and and accounts can be kind of moved around by the protocol to to maintain maximum throughput you know across all shards yadda yadda the um there's this idea of like asynchronous calls so this is a view of asynchronous calls i've been trying to figure out how to explain this best so here's here's maybe like draft number two to try and explain this the the top half of this is what like stuff you already know as a developer has nothing to do with near the bottom half the internal stuff is uh asynchronous calls from inside of your contract code that's the new stuff and i'm gonna go top right counterclockwise strange as that may seem counterclockwise abcd in order to explain these okay uh on this picture here we've basically got um in inter external and internal uh batch and then promise so uh the the promise is what you would see like if you look up like javascript promises on mozilla developer network like that's what that top right hand side is and there's a similar thing in contracts where you can like make a call to another contract you can fire and forget it'll happen at some point you can fire and register a callback to come knock on your door whenever that contract is done doing its thing you can pass parameters over and you can expect parameters to come back uh obviously structured types that you would set up those those arguments whatever you're expecting to the data to move back and forth on the outside of near we call the payload of instructions a transaction once it passes the boundary of the network and it's happening inside including these promises we call it a receipt and there's a term collision there in ethereum because i think a receipt is like what you get back when you when a transaction gets processed but in in near a receipt is what you call a transaction once it's been kind of the signature has been verified and validated the account's validated it's got enough budget to actually do the work and et cetera et cetera it's on the inside of the network then you call it a receipt and those receipts can you know kind of propagate around multiple accounts around the network you know kind of causing other receipts to be generated et cetera et cetera depending on these cross-contract calls so that's a is that the promises that you know from javascript and there's an equivalent inside of contracts that you can do that with and then b this this idea of a batch you can basically use uh linear libraries to to create a transaction putting together a bunch of actions those little yellow stickies inside the blue one and then you can send that off to the network to be processed as a batch action internally you can do that from a contract as well any of the eight actions that are supported by the network you can compose into a transaction and and and send that over the wire i'll show you code right now so here's what the kind of standard top right hand side uh a looks like this is just standard promises in javascript this is moving now counterclockwise b this is how from the outside you would use our api to create a deploy contract transaction where you load a wasm file off the file system and then compose a function call action calling some function with some arguments at attaching some value gas in this case and then you would push those on to the transaction just an array and then you would sign and send that transaction to some account on testnet in the last line there so so this is a batch action from the outside of the network inside the network from inside of your contract code you could create this contract promise batch it's a mouthful but it's basically this this collection of actions that you can you can execute and so you would say um you know make this batch for the account the banana on testnet i want to create the account transfer some value add a full access key that is related to mine if i'm the one who's you know signing the transaction that invokes this code the the sender public key um and then i want um to create the account called peel the banana on testnet transfer some money add a full access key and deploy a contract there then i want to create the account called eat the banana transfer some money add a full access key deploy the contract there um and so so all of these things will be applied uh as as uh you know as the code reads basically as these batches so here's the transactions this collection then i want to apply this other transaction with a collection of three or four actions in there so hopefully this makes sense and then uh the last one now d uh we're at the bottom right hand side of that quadrant i can call kind of a fire and forget in this case peel the banana you know using fingers is the method on the account peel the banana.testnet throw some gas in there there's no parameters in the empty quotes and then maybe i want to eat the banana using my faith this is the method on the eat the banana contract lots of gas no parameters and i can pass in a callback as well into this but this example doesn't show that and so so that that's kind of the promise but from inside of the contract code so that would be completely new coming from an ethereum space is my understanding all right so that's the end of the intro to near maybe we can pause there and take like a a deep breath any questions any comments any concerns did i say anything misleading or absurd that somebody wants to to troll me over or something like that anything that we need to talk about any feelings we need to get out about that if not we can just dive into the rainbow bridge there's one question here from leandro eth2 is going to run on ewasm some features that you're presenting won't be native question mark also coding in a s or rust i'm not sure i understand that question and i don't know enough about eth2 to say anything useful frankly so forgive me i do know a lot of layer ones are using wasm as well and rust and so it's it's not an uncommon combination if that's where e2 is going but i really can't uh speak uh in any meaningful way about that um in terms of assembly script or rust i i'm not sure what that means if you're talking about with eth2 i have no idea if you're talking about with near we support both assembly script is easier for javascript and typescript developers to get into rust is better for high value contracts i'm i'm sure that you must mean something else by that last question i just can't imagine what it is he says okay cool all right so rainbow bridge is this bridge and just keep firing away questions if there's something i'm missing or something else you want to follow up on just just keep asking be selfish with your requests and maybe generous with your your support if someone asks a question i'm not answering it effectively if you know something about it dive into the chat and be generous there that that would help so so rainbow bridge is this uh connection between um uh near protocol and and ethereum and i'm gonna do my best to explain it to you in the next few slides here this is a picture of what it looks like uh there's the setup this use case example and then you can extend it uh from the top to the bottom there setup use case extend and uh the two networks and and all the kind of moving parts so at the at the top level the the sort of the foundational layer of this i mean you can flip this whole thing over and call it like the base layer but there is this pair of light clients that live on on either network so in rust written in rust is an ethereum light client that has been deployed to near protocol and that client sits there it's a contract listening for headers that are sent by some thing that's off chain uh and uh you know you could imagine it's an oracle or it's uh you know a collection of you know virtuous uh servers run by community members cooperatively or maybe competitively somehow to try and get like the right kind of data into this like client effectively headers from the ethereum network okay and so we talk about trustlessness in that area there but it's it's not part of the story so there's some maybe it's like a node program or a shell program some script that's running this this eth to near relay that's sending headers from the ethereum network to this light client sitting on near that's that's written in rust and deployed on your protocol it's an ethereum like client the inverse is true in written in solidity there's a near light client sitting on the ethereum network listening to a near to eth relay that's sending headers from near protocol those like clients are like the base layer of truth where the network can watch each other on top of that we have provers and these provers right now are simple but you could extend them you could write other ones to prove other things the ethereum prover the one written in rust living on near is able to prove that an event has been recorded on the ethereum blockchain effectively you give it the event and say was this event recorded and the ethereum prover will you know interrogate the light client for headers and merkle proofs and other fancy things and basically say yep i see evidence of this event happened on ethereum it was recorded i don't know whatever you know time ago and on near the near prover interrogates the near light client near proverbs written in solidity lives on ethereum and interrogates the near-light client about transactions that have been processed by near protocol in the same way has this transaction been processed by near protocol then your like client finds proof of that and says yeah it has all right so from there we can do things like build this particular use case where we have a token locker on ethereum that lets you lock tokens uh erc20 tokens and this mintable fungible token contract on near that lets you mint any p21 equivalent to erc20 tokens on the near side and so what you do is you lock up tokens on the ethereum side uh the relay sends evidence of that to the ethereum light client on near the mintable fungible token uh contract interrogates the prover uh hey did these tokens actually get locked on ethereum and when they have been then it mints those tokens the equivalent uh you know wrapped version of those on your protocol right so here's an example of what that looks like so let's say we've got these rain tokens and we say we're going to do that we you know tell the the token locker to take care of this we confirm that we're going to transfer these tokens some locked event is emitted by the token locker the prover verifies that um and then we wait uh you know for these blocks essentially 25 blocks fairly conservative bit there a little fast forward if there was more value we could wait longer obviously on the near side we tell the mint the mintable fungible token to mint these things we need a little deposit because it the data to track that minting is going to cost money on near and then our tokens arrive on the near side of the network and we can reverse this by you know burning these uh rap tokens um and then they would be unlocked on the ethereum side so so this video is available on the slides and it basically like walks through this process and then these blue bits of text are links directly into the code base where each of these things happens like you know the approval locking the token emitting the locked event waiting 25 blocks etc all that all the blue text there is basically uh available uh so sorry i didn't mean to kind of rush away from that i was trying to avoid the video replay okay so hopefully that gives you a sense of what we're talking about we're talking about locking tokens on ethereum minting a wrapped version of those tokens on near and this is this bridge technology that we've put together and there's there's a bunch of sample code all open source you can check all this out we just wrapped up a hackathon or are wrapping it up this week i guess to encourage people to play with this tech and then here are those four steps that you saw earlier one two three and four with some overlaps and an activity diagram i guess what we'd call this um and and there's you know all the different components there the eth node the locker uh the contract and so on so if this helps you kind of visualize what's going on it's just a different perspective on that same thing and then here are some of those repositories so the example is this thing on the left erc20 to nep21 and it's it's just github.com your examples and then that repo and you can run everything locally there it might be a bit tricky to set up but the docs should help you with that and then on the right hand side we're just going to github.com near and we query rainbow to see the half a dozen repositories that are related to this bridge specifically the cli rainbow bridge cli is what you would use to run the bridge deploy contracts things like that get things set up the token connector is a generic token connector across the bridge it's not specific to rain like the example on the left here it's a generic token connector that you can reuse for other things and it's written in rust mostly there and then rainbow bridge rs and sol are the two kind of sides of the you know the the rust side would be like the ethereum light client the prover that runs on near and then the solidity side would be the near light client improver that runs on ethereum the lib is some factored out components there for you from dealing from the front end because it's in javascript so hopefully this gives you a good sense of how you can get started with the bridge and then here's like you know using the cli kind of getting started there some of the costs of running the bridge it's expensive is the simplest way to say it right now to run this thing but we're working on that so you can get a sense of kind of the prices there they're pretty pretty high to kind of get things working on the bridge all right so then maybe your question is how do i get started with these toys here it is create new app we talked about that earlier and you can actually do this right now if you want to follow along with me so so before i dig into that any any questions about the bridge any questions or comments about the bridge that we want to cover nothing in the chat so far okay yeah no worries i'll keep going if you think of something feel free to interrupt so how do i get started it's it's this near uh you know create new app uh just like create react app it's creating your app and we talked about this earlier basically depending on the things that you pick you get one of these four uh generated um applications right and so this is like a simple demo that you can use to explore near and how it works i recommend that you start with the default which is going to be javascript and assembly script the one on the far left you can add you know react to it if you'd prefer that you can use rust the two on the right again there's not too many different things here i've highlighted in yellow some visual anchors to help you quickly scan the file systems and some bold files to compare some of the things that are kind of the critical components those would be the anything in bold is what you want to look at first when you when you generate the project basically that's where the meat and potatoes are and so here in step one you can literally do this right now if you've got node installed you can run npx create near app banana whatever your app name is you'll get this output here yarn dev yarn test yarn deploy just like npm you know run dev or npm run test yeah um and so uh you know at yarndev or npmrundev it's one of the scripts in here it'll you know run nodemon to watch your project get things kicked off and then you'll see this appear this browser will open up to port one two three four if you're not signed into the wallet you'll see something like what's on the left you click sign in sign in create an account whatever it is on on uh near wallet on testnet and then you'll be able to you'll see the greeting here on the left-hand side you'll be able to change the greeting in the text box click save and then you'll see that updated little piece of toast a little bit of toast pop up and say hey your message has been changed on chain and you'll actually be able to see that in the explorer if you want and then and then uh uh you know here's some questions for you to kind of encourage some exploration so if you want to get a sense of how this stuff works you can ask yourself you know where are we setting up the connection to near and if and if you want to look for yourself you can or just search for the the the word key store and that'll take you right to the code where the the connection is happening where do we log into the your wallet there's the hint to search for it which lines of code wire up the contract there's the uh bit of code that you can search for to get get right there and then if you want to control stuff you can you kind of maybe mess around with this little challenge but coming from an ethereum background this is probably trivial for you so hopefully that uh that gives you a sense of what's going on and fundamentally this this is is probably um already uh in your comfort zone but you're talking about contract development ux development right so you can either develop contracts with assembly script or rust as we said and then you're using near api js it's it's modeled similarly the ethers js i think is is the inspiration for near apiges so you might notice some similar interfaces and structures there and that just wraps the json rpc api that we've got um and so that's your two kind of interfaces for development extension customization here's a picture from very high level your dap on the left using this api to send and receive with the blockchain layer contracts certain assembly script or rust that you deploy they get loaded into this virtual machine read and write to storage based on their execution and then response comes back here's what a like cycle looks like again coming from an ethereum background most of this is probably a shrug for you probably pretty obvious and then there may be some interesting bits here where each account holds a contract and state you can have one and only one contract per account and what you'll see is if you type at the command line near state and then account name you'll see this metadata come back including the amount of value that the account is holding a code hash that's all ones if there's no contract deployed to that account or some other fingerprint which is the um the the sha-256 digest encoded as utf-8 i guess if i remember correctly whatever this code hash is of the contract byte code and so it's it's not all ones if it's if it's something other than all ones you know a contract has been deployed to it and this fingerprint will always be the same for any given uh wasm file any any given byte code the fingerprint will be the same so you could check whether or not an account has a specific contract deployed to it we we don't currently have deterministic compile uh on our contracts but we're working on that and so if you have the same already pre-compiled contract you can redeploy it to multiple accounts and test because the fingerprint will be the same but if you recompile the contract from source it may not necessarily generate the same thing or print although i expect it's such a high priority feature that we should have that's in um and then for data it's just key value pairs in this case encoded as base 64. um and um and it doesn't have to be but but in this case it is and then if you decode those you'll find you know just key value pairs as you would expect some of the higher abstractions like the vector and dq and map and stuff will have these kind of prefix structures where you pick a letter or some some text prefix for whatever the data is and and then for rust contracts there's this reserved keyword called state where the contract code will actually live and if you have any data that you're storing with the contract it'll get serialized into this this value and then when you're talking about writing contracts here's what some of the assembly script looks like here's what some of the rust looks like for the for the data aspect of it and so near bind gen you see is this um attribute or decorator or whatever for for this this posted message class there's you know uh you know this is for the guestbook example there's the whether or not it's premiums a boolean the sender's string and then you put in some text and then we kind of check here to see attach deposit based on uh the the transaction that was used to invoke this message that that decides whether or not it's premium you capture the sender as well from the context and then here's kind of the similar the equivalent rust basically on the right hand side so near bind gen you've got some serialization there for uh for putting data on chain uh you're you're struct and then this this method to create a new a new message and and the same tests in the behavior side uh we've got a message limit adding a message uh you know we make a new posted message and then we push so the distinction here is that in ethereum my understanding is that basically any variable assignment that you do in ethereum gets recorded on chain maybe that's wrong i guess you can have some variables that are set as memory uh that are ephemeral but generally when you assign a variable or whatever that's going on on your contract that gets recorded on chain it's not so with near you have to explicitly call storage set storage right that's happening inside of the the persistent vector uh class here it's it's basically calling that if you look at the source code somewhere it'll be like a storage set or storage right uh and so the the posted message again is even higher than that because it's our custom domain object that we've made that represents a message and so you're not going to see any kind of writes here but whenever you push this message onto messages underneath the hood that's getting written uh to the chain and then get message you know we're kind of reading this back and returning this collection of posted messages again the same thing here in rust where we've got this guest book as like the main contract and then we can add a message and get a message uh here and you'll have to forgive me i wrote this but uh didn't didn't test the rust side of this code so if you find a bug in the rest side of the code that's on me no matter what the output is always a wasm file and with assembly script uh you can actually the wasm is really easy to read this the the sorry the what uh webassembly is text representation so the the wasm you won't be able to read obviously but the webassembly's text is this other representation it looks like a kind of a lisp i guess and you can you can see a bunch of the the names of these these tokens like get message the name of the functions you know add message get messages you can see them right in the code and you can practically read uh the the what format uh to see what's happening on the stack here you know getting things pushing them on stack popping them off etcetera and so so that that's the watt format um and with assembly script contracts because the compiler is so close uh to the uh to the code there's not a lot of machinery in there for assembly script so that the the files are much more readable with rust there's a lot of machinery it's going to be hard to read the wac file like this and then we we could walk through the guestbook but i think we're close to running out of time here with eight minutes so i'll just continue unless i'm interrupted by questions um so so again the guestbook couple of main folders assembly and source and here's the data model so posted message you've seen this here's a little bit more explanation of what that looks like i'll just let you read this probably faster than me speaking it out and you have access to the slides as well so there's the data model here's the behavior we just saw this a minute ago some configuration so we know like where the network is and then the front end so here we're connecting to near wiring up the contract we get this object a javascript object that's like a proxy for the rpc interface excuse me with some methods here that we can call and then the the application that you know that loads this up this is a react version using some hooks and we request sign in the wallet handles the redirection to the wallet back and forth your private key is stored in your local storage and then a little bit more here where we like add the message and then get messages as a result of that promise resolving and then we load the page so whenever you add a message you kind of the page refreshes okay so that's the end of the presentation we've got about five minutes left for questions or comments or or corrections wide open for feedback on this stuff this is this is not definitely not all in my comfort zone uh maybe a half if i wanted to be ambitious of this is is stuff that i'm very comfortable with but there's a lot that i said here tonight that i i would appreciate your critical feedback on uh slides are at bit.ly slash near-102 near.chat is where you can you can get a hold of us on telegram near dot help is kind of a high level overview of all the ways you can get in touch with us and there's a couple of recordings of this presentation on the first slide here in the top right hand side if you want to check those out as well awesome thank you so much sharif good feedback here really like the s2 near will we trying this thank you sharif from leandro and thank you from everyone at each global this is a great presentation wonderful yeah my pleasure um if anyone has any more questions um feel free to unmute yourself jump in and if not you can always reach out to the new york team at near.chat as mentioned earlier you definitely want to integrate near into your hack for it's online cool 