cool uh hello cool thanks andrew um hi and welcome everyone to the protocol labs workshop uh minty fresh nfts with ipfs joining us today is yusuf and we'll kick off the session with a short workshop video clip and then yusuf will be taking some questions at the end uh one last reminder for everybody to just take their spark for nft hack if you haven't done that yet if you are struggling at all please don't hesitate to reach out to myself or anyone else on the youth global team cool and let me just quickly grab the video clip and we'll kick off the session hi i'm yousef from protocol labs and lately i've been working on minting nfts with ipfs and ethereum because i'm writing a guide on how to do just that and in order to figure it out myself and to really explore the space i wrote this command line application called minty and the guide is based on the app and just walks you through the code and i'm just going to do that in person now and hopefully when you can learn some interesting things about how ipfs and nfts can work together so um the guide first of all uh kind of gets into why you would want to do this and i think for me the most compelling reason is that with an nft right you can't generally speaking store the primary data for an image or so on on the blockchain because it's incredibly expensive to do so um that state has to be replicated across every node and validated and all that a gas or whatever the equivalent might be for your blockchain platform so you link to these things that exist off-chain but if you use a url like an http url so like linked to data stored on a cloud bucket for example that url can point to something different tomorrow than it did today so any nft that's minted containing that url has now had its meaning changed out from under it right so ipfs is a pretty natural solution to this problem because ipfs uses content addressing to locate content so when you add something to ipfs it generates a hash and the hash is used to find who's providing the content and the only content that that hash could ever point to is the content that created the hash so there's no way to ever change the data without just breaking the link basically so that's a pretty useful property and the other nice thing about ipfs is that if the original provider of the data goes away but anybody else on the network still has a copy then it can still be retrieved which is nice because you know you know the crypto landscape changes quickly i guess is a way to put it and it's certainly possible that an nft platform could shift or disappear and you would still want the nfts themselves to have value because the blockchain would presumably live on right um okay so getting away from the motivations for why you would want to use ipfs for entities how does that actually work right um so that's why i wrote minty and and we can take a look at what it actually looks like right now so here we are i've got the minty repo checked out and i'm going to start a local environment which means i'm going to run a local ethereum devnet and also a local ipfs node and now i have sort of blank ethereum network to work with and so i'm going to deploy a smart contract into it with this minty deploy command i should briefly mention that i've npm installed a bunch of stuff all right it's going to create a deployment.json file and i'm going to overwrite the old one that i had lying around and then that has some information in it it has the address of the contract and the abi these are the pieces that future minty commands are going to use to connect to the diploid contract so if i run minty help real quick we can see like what minty can do right so i can make a new nft and give it the path to an image file i can show uh some you know details and metadata about an existing nft i can transfer a token to some new owner and i can pin the data for a token to remote service which we'll get into in a few minutes and deploy we just saw so and i also if i want held on a specific command i can ask for it by saying minty help mint or whatever command i'm looking for so okay now let's mint a new token so i'm gonna say minty mint and then i'm going to give it the path to this lovely ipfs logo i have on my machine so all right give it a name logo it's a great logo and there we go so it has minted a new nft hooray it has the token id1 and it has the ipfs url for its metadata and also at http url for my local ipfs gateway so this one the first one i could put into brave or ipfs desktop and resolve the content that way or if i don't have those installed i could go here and just view it in chrome so this is that same metadata that's displayed in the minty mint output and stored as json on ipfs and inside that json actually you can see here we have the ipfs uri for the asset itself or the the image file so and that's this uh this url here so here we see the ipfs logo and that's that's great so that's that's all our data in ibfs and associated with a token id and so if we want after the fact we can view that data again with minty show and i'm going to pass in a flag to also get like the block that it was mined on and who owned it at the time of its creation because i connect i can transfer uh the token to a new address and now if i run minty show again it'll say oh then this guy's the owner now but it was originally created by this guy over here um all right so that's pretty cool um but how does this all actually work right that's what this is all about it's like figuring out the process of doing it um and specifically how you do it in code right um so here we are in a javascript uh file this is a node.js application although the same techniques should work in the browser once a hue prs land and js ips so we've got here i am reading that deployment info json file that i showed you earlier to get the contract api and address and then using that i'm using ethersjs which is a smart contract interaction library to connect to the contract right and now i have an uh contract instance that i can call functions or methods on right and here's my local ipfs instance and it's actually driving that local ipfs daemon over its http control api but again soon this will all be possible using an embedded js ipfs node on like completely contained within the browser so that's kind of interesting but there are some considerations there that make it a little trickier to set up so we're in the interest of simplicity minty is a command line okay so i've set up my ipfs and my blockchain connections and now i want to create an nft so here we are in the create nft asset data method um i am going to add the data to ipfs and i'm doing so like if you one thing to kind of call out here is that i'm wrapped i'm putting my data inside a directory on ipfs um and the reason i'm doing that is because since this is an example app i want things to be like kind of friendly and uh distinguishable from on the in the output so it's easier to tell like which is the asset and which is the metadata if i include a nice human readable file name so if you put your ipfs data into a directory you can get these little human readable file names as part of the uri but if you don't want to store that human readable bytes on the blockchain you might want to escape this part so anyway you get you got your data into ipfs and now i have a cid and then i'm going to make sure that it has that ipfs colon slash prefix to turn it into a uri and because we have those human readable names we add that to the end as well and then i'm going to make that json metadata object but by taking the name and description passed in by the user putting the uri in there in the image field which is its standard location in the errc721 metadata schema although as an entity platform you have pretty much free reign to define your own metadata conventions uh this seems like a pretty good baseline that everybody more or less tries to um be compatible with because it gets you some nice features like wallets or out of the box so people can kind of give you an overview of nfts even if they don't support your platform specifically um okay so now that i've got that metadata object i'm gonna stringify it i can convert it into like you know just a json string and store that into ipfs as well so yeah one with those i am going to either use the default owner address or the one passed in by the user and mint the new token and the way that works is i call the smart contract function passing in that metadata it gives me a transaction because i can't get the new token id out immediately the way this works is like calling the smart contract function because it modifies blockchain state it has to wait until that a block containing the transaction has been mined and confirmed by the network before we know for sure that the new token has been created and so we once we have this transaction we can call dot wait on it that's going to hang out until the transaction is confirmed and give us a receipt and the receipt is going to contain events that are emitted by the contract so i should take a minute to like check out the contract itself i'm using um a base contract from open zeppelin which is very comprehensive and does everything that an erac c721 token should do and lets me make this contract very simple so the way it works is it first it's going to add that ipfs column slash for you so we only have to store it once in the blockchain instead of for every token and then you have a counter that gets incremented with everything token and that becomes the token id the token is issued to the new owner and safe mint does a check to make sure that the owner can receive tokens because it's possible for one for another smart contract to call this function and to be the owner of the new token but for that to work the contract has to support a receiving focus okay so then you also have this set token uri where we take the metadata uri passed in by the user and associated with the token id and that's really it otherwise it is a fog standard erc 721 token um as implemented by opensupplement so all right so back in in minty.js we have um that base contract right when when it does mint the token it's going to emit a transfer event this can be event so it gets emitted when token changes ownership but for a new token the from address is going to be all zeros but at any rate we don't really have to check for any of that because we know there's only going to be one transfer event in this transaction and all we care about is the token id so we pull that out of the event arguments and return it to the user so that kind of takes care of token creation for us we we now have everything we need and we return some data to the user and then another bit of code formats for display so then uh yeah if you want to get the data out again it's pretty simple we go here and call the smart contracts token uri function which is built into the base contract and this time we don't have to mess about with receipts because this token uri doesn't modify any blockchain state so a read-only function and just return more or less right away based on information that it's already in the blockchain and then so once we have the uri we use that to fetch the ipfs json using this little helper here which just pulls the data out and treats it as a json string versus the json so that's cool and um in the git ft command this is where you can optionally get like some historical info um and that works by like querying the record of events that have applied to this token id before so you like yeah and uh ethersjs that we're using you build a filter for the transfer event and say i want to give me all the events from this token and the first one is going to be the creation event so that's the that's what we care about is getting the creator's address and the block number okay so now we can add a token we can get a token uh transferring works pretty much the same way um right we just call the transfer function and wait for it to be completed and then uh now there's sort of one missing piece which is that we've so far been adding ipfs data to my local ipfs node which is running on my laptop and sometimes i like to turn my laptop off so when that happens if somebody tries to request that data they may not be able to find it there's a chance that they will because the way ipfs works the data is first going to be stored on my machine and then advertise the network anybody who requests it will temporarily keep a copy around in their local ipfs repo and provide it to the network as well and that makes it more resilient and shares the load across the network but those copies are temporary and we can't fill up everybody's disk with uh redundant data so uh if you want your data to persist long term um without running your own ipfs yeah infrastructure like a ipfs cluster for example which is a highlighting you can request that a remote service pins the data for you and makes it highly available on their ipfs infrastructure and one of the nicest services that i know for doing this is pinata who is also by the way they have excellent resources for learning about nfts especially as they relate to ipfs on their blog which i highly recommend so if you haven't signed up for pinata already they have a free tier it's really easy and takes a couple minutes and then you'll get yourself a access token um once you have an access token i'm going to skip the whole creating and fetching the token for brevity's sake but once you have one if you set it to the pinata api token environment variable minty will pick it up right by default and let you pin things to pinata if you uh would rather use a different service or you just don't want to mess about with requirement variables or whatever you can edit the configuration in this file config default.js and paste your token in here or replace pinata with a different service and now so now that i've done that i should be able to say minty pin 1 the token id it will look up the uris and everything from the blockchain and ask pinata hey will you please pin these ipfsc ids for me and pinata will go and connect to my local ipfs node and also um my local ipfs node will try to connect them and pinata is gonna be like hey you have these this data my name is like sure and then pinata stores a copy and keeps it alive indefinitely um or you know as long as i continue to pay my pinata bills i guess although i have yet to exceed the free tier in my experimentation okay so now we have the data pinned and if i want i can go to i can say ipfs pin remote ls and give it the name of the pinning service and then it will go and ask pinata for a list of all the pins that i have created and so that way i can confirm yeah okay yes it was added um so cool that's um most of the minty functionality right there and there's certainly a lot of work that could be done to take this and turn it into a fully decentralized gap that runs in the browser i'm personally really excited about that work and i'm you know eager to see where the where that ends up um so i and as someone who's relatively new to nfts there's there's just a lot of exciting movement happening that i am happy to be a part of now so uh hopefully this has been helpful uh if you have questions for me personally please hit me up uh you can email me at y-u-s-e-f protocol.ai or try to find me on some kind of social media which i occasionally check thanks very much cool great thanks so much yousef that was great apologies that i wasn't on full screen for the first minute or two um yeah uh we can open the floor to some questions uh that have come up in the chat um yeah yusuf if maybe you want to give yourself a quick intro say hi and then jump into the questions yeah hi everybody thanks for uh sitting through my pre-recorded thing my my bandwidth at home was a little sketchy so i figured that was the safe bet um and there's a few questions in chat that i could go through real quick and then we could open it up for some more stuff so um first we've got to store metadata on ipfs while minting via another platform like a gui minter um that's definitely doable you can either add any way you get data into ipfs is fine and then you should be able to take that ipfs uri and send it off to gui platform although this there's a little caveat that the platform will probably need to add some kind of support for ipfs you could add a gateway uri instead if you it's like if they only support http uris but that's sort of dependent on the platform specifics um and then there's a question about what types of files do you not store in ipfs there's no real restriction as far as i know like ipfs is pretty much agnostic to what kind of data stores it's just bytes as far as it's concerned um the only practical restriction would be like what kind of data is viewable in the browser or whatever whatever you're using to present the token right so probably an image file or video is cool but maybe not like a executable or something like that um there's good questions about what guarantees are there for storing ipfs data long term and ipfs is you know it doesn't guarantee persistence of data right that's uh something that we're trying like protocol labs we're really focused on filecoin as the eventual answer here like we think that there's a really huge potential for using filecoin as the long-term persistence layer for this kind of data um the the movement along those lines isn't really ready to present publicly yet but we're internally figuring this out and trying to package it up in a friendly way for people to use and when that does happen it's very likely to be using ipfs as the interface for managing and viewing the data and then it gets shuffled into file coins sort of behind the scenes um and i actually have something to say on those lines in a little bit once we get through these but as far as like why pinata is expensive i can't really comment on that because i don't know their economics very well um yeah so i there's a good question that just came in uh from youtube saying um who's responsible for paying for pinning right like um should it be the person who minced the nft is it the person who owns it and so on um that again i i don't have like a super satisfactory answer for it because i think it depends on like the goals of the nft platform to an extent it might be worth the platforms while to like sort of eat the pinning cost in order to gain adoption or it might be advantageous to like allow users to add their own to to sort of take care of the pinning of themselves i don't know um ideally in in like the perfect future land when the sort of pin to file coin functionality is is rock solid then that would be what i would recommend so i mean but that's not a satisfactory answer today so i think today um it's more it's like sort of a compromise between you know making things super easy for the users in which case the easiest solution is for the platform to kind of subsidize the pinning for at least temporarily and then the the more decentralized version is to encourage users to also pin the data themselves and then um oh somebody's asking about argh weave um and i you know i uh i would say i don't know a ton about artweave although i've been super curious about it and i've been researching it a lot in the past couple weeks largely because of the the nft use case is a good fit so like you know coming from a protocol lab's perspective like obviously i i want everybody to use ipfs and filecoin but i think you know it's certainly worth exploring our weave and if they have some interesting properties that make it you know attractive for this use case um i think again like i don't want to like get to like take a side on it really although i suppose like as a pl employee i'm like honor bound to to show our stuff but i i mean i do think that ipfs is a good fit for this kind of data as well but i think hopefully there's like a good you know synergy story to to flog a buzzword there or whatever that we can complement each other in the future and so i'm actually spending a lot of time uh personally just researching this because i find are we pretty intriguing um and then yeah oh so um isaac is asking if i know the general cost and sizing and instances of painting nodes i think that if you're really optimizing for cost you would probably as an nft platform run your own ipfs cluster which would be less expensive than delegating to a service like pinata um and in that case it's just basically the cost of running some ec2 machines plus whatever storage you actually end up using for the nodes but specifically for you guys here at nft hack i as the first pl employee to be speaking here i get to be the one to announce that we're launching a beta program for this thing called nft.storage if you type that into your browser you should be able to sign up and we're going to subsidize uh storage costs for nft storage for everybody that's participating in nft hack for the yeah indefinitely in the definite future there's basically we're going to store your data for free up to a few gigabytes and let everybody have a chance to play with this and it's going to be stored on ipfs and pinned and then also we're going to take the data and shuffle it into file coin so that we get experience with that whole process and then we'll you know you'll be able to see the file coin like deal c ids and so on that are backing up your data so this is brand new it's i've just gotten live this morning so and but there's going to be if you stick around i think it's saturday alan shaw from pl is going to be talking about it and he'll give you all the details and get you you know get sort of behind the scenes of that a little bit more than i'm able to do um oh you know the code is available on um it's on my github organization right now but we're probably going to move it into like an ipfs docs examples repo soon and the two the guide that i showed at the beginning i am hoping to have published by the end of the day today and that will live on the ipfs doc site so um i yeah uh it's cool if anybody i um and now like i realize i've been talking for a long time so if anybody has any questions that you want to toss at me uh please go for it yeah anybody's free to unmute themselves and ask use of their question live um if you're a bit shy you can drop it in the chat but yeah feel free to ask the questions live um yeah uh there was a question from youtube uh about um if anybody knows what the cost of pinata pinning is recently or yeah is the code showed available on github yeah the code is there on um let's see let me yeah drop the link again here that is yusuf nepora slash minty is the github repo um and [Music] yeah the the pinata pricing um currently there uh yeah that i'm looking at their page now they have different tiers for and likes tailored to nft platforms they're like nft platform launched here they're asking 500 bucks a month and then scaled here is a thousand a month but i don't know when you would be likely to hit those limits uh as i have not tried to run a production entity platform yet so yeah i would so about pinning in general right um basically pinning means that like there's two aspects to it there's like a local pin meaning my my if i say to my local ipfs node please pin this content that just means my node is never gonna throw it away unless i unpin it right so um but then there's a service named uh or you know like pinata right they will also pin your content keep it on their nodes but with an additional guarantee that like they're going to be online all the time and have enough replication to make it you know available to anybody who requests it so there's a common misconception about ipfs that like when you when you add data to ipfs that it gets like broad like replicated across the entire network right away or that it's sort of like on ipfs in the same way that like data is on the cloud if that makes sense but really it's it's much more similar to um like a peer-to-peer file sharing service like uh there's like the bittorrent protocol there's a lot of similarities at a protocol level although there's a lot of differences in terms of the use case and everything else but like when i have my data on my ipfs node it doesn't automatically get spread out so there that's why like the remote pinning service kind of is uh part of the story here because they need to they're like generally speaking for data that you want to be like super durable it's a good idea to ensure that it's like you sort of have like a guarantee to that effect um and again if you're like running your own infrastructure you can provide that guarantee yourself with ipfs cluster but especially for startup platforms they might not want to do that and it is definitely possible to run ipfs nodes on aws you can start your own pinning service if you like or you can just the ipfs cluster will just let you pin any content you uh to it directly without having to use the service api necessarily yeah and once again nft.storage is the thing that you guys should go check out thanks so much youssef um that was a really great session and yeah i think you got through almost all the questions there's one last question here i think that you can answer in the chat and then we'll wrap it up yeah unfortunately i'm not qualified to answer anything about sia because i just i'm not educated so uh but possibly someone else from pl that you may bump into at nft hack would be able to it's just not anything i've had time to look into yet yeah that's great um there is the sponsor protocol labs channel that everybody is free to reach out in if they've got any specific questions or um yeah haven't had time to ask them um during the workshop but big thanks yusuf and everybody has a great afternoon thank you thank you so much for having me yeah thanks joseph bye 