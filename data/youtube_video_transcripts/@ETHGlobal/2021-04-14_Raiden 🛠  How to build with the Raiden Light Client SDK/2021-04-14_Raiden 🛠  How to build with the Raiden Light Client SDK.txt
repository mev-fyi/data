all right welcome everyone uh welcome to uh the stream and uh today's session on raiden um i'm seanan part of the uh the global team and i'm here joined by andre from raiden very nice to have you thank you it's very nice to be here with you as well wonderful guys yeah so super excited for this one um andre you can feel free to take it away but as for questions uh please feel free to post them either in the youtube chat or in the zoom chat uh we'll answer questions uh right after the main presentation is up but feel free to ask questions anytime thanks don okay all right andre i think you're good to go okay so hello everyone my name is andre vitor from i'm from brazil i'm 29 i'm 29 years old a software engineer and living currently in sao paulo and working for our brain bot almost four years now in the reading team uh which is uh one of the first calling solutions for ethereum and we will be presenting uh their results and and some uh code walkthrough uh and demo illustrations over the latest reading light client and as well as a background on them payment channels network technology for scaling payments and transfers uh and presenting the rating protocol and then some hands-on demo so yeah let's start and quickly present my screen i won't ask if you guys are seeing it because it works every time so i just assumed so um so raiding raiding uh protocol and the light client um implementation and client um so let's start first with the payment channels i'll just do a quick intro so everyone is in the same page after this uh so as everyone knows and this has been the hot spot of the debacle from scaling solutions and blockchain technology which is late year one scalability issues which mostly comes out of the requirement for global consensus so what this means that everyone needs to agree on the current state of the network or at least after being on the on as a given um path for the giving state in the past for the uh current the state of the light client of the blockchain state and the accounts estate balances uh contract states and so on so this requirement for go for global consensus is one of is the strength of blockchain technology because it's fully decentralized but it's also its achilles need because it's hard to actually ensure these consensus in a safe way without uh while still keeping the work the workflow and the flow of transactions going sadly so yeah um this is mainly caused or it was the main main improvement and the technology breakthrough from blockchain is it started with the proof-of-work algorithm which allows anyone to propose blocks and to have them accepted over these consensus rules but they can be reared and proof-of-work is what dictates what's the latest and most up-to-date view of the state of the blockchain and in order to have your transaction safely settled on the blockchain you need to wait for a specified amount of time a specified amount of blocks uh which means that there will be a low probability of just getting reorganized your transaction going out um but of course this makes the number of transactions and the ensuring validating these consensus a bottleneck of the network because global consensus is required so payment channels is a scaling solution for layer 2 which uses layer 1 depos to reduce the consensus requirement from global to local so there are local channels which can be which is an abstraction those channels are an abstraction and you only need to have consensus over this local channel with your partner so if you have a channel with someone you only need to agree with them on the current state of your channels or the current tokens or any kind of asset transferred to them back and forth you don't need to inform and to have to have everyone agreeing on this state of the this local perspective of this limited set of the blockchain state in this case it's the chain of state the deposits going in each side of the channel and being transferred back and forth between the partners so payment channel networks they allow uh you to transfer to nodes that you don't have a direct chain with because if you have to open a channel with every p you want to transfer assets to this would be extremely uh slow and also capital inefficient even more than what we already have because you would need to lock that um the number of channels uh the number of tokens in a channel with everyone that you intend to transfer tokens to so with a network of payment channels instead you are able to keep only a limited number of channels and to meditate payments through this channel's network so if you are connected with a partner uh that sometimes is called a hub that have several channels for example five channels or is overall well connected and balanced with the network you are able to transfer to nodes that you don't have a direction with by transferring to them with a specific instructions on how to forward these payments forward and to get it to your target and only after that you would be settling those tokens and they would be forwarding this as well to the next mediator and then the next mediator and so on so the advantage of payment chain of network is that the through output or the transactions per second transfers per second in this case increases linearly with the number of participants instead of getting injured by the number of participants and the number of payments and transfers going through the the network this would actually increase linearly with the number of participants so as many participants are participating in the network as a higher the capacity and the throughput of this network this layer to network so here is my example alice and bob they design an example for a channel a payment channel they have a smart contract which dictates how the rules for this payment channel and they each side can depose arc 20 tokens for example on their side of the smart contracts and then they depose only once they open the channel this is one transaction they deposit these channels it's one transaction per each each side and after that they can do an unlimited amount of unlimited number of transfers going back and forth in these tokens between them without having any on-chain transaction in this mean time of course as long as these transfers are backed by their respective deposits or their respective balance so you can if you have received all tokens from bob alice can actually transfer out that they had deposited plus how they that bot had transferred to them she can transfer to bob or can transfer to someone someone else through bob so this is my demonstrating demonstration of how routing a payment works so there is a service that will give you a pad in this network of well-connected nodes and then you'll be able to route payments only through channels that through partners that you have a direction with right when it's yes so yeah how they already network implemented this so payment channels is a more or less generic implement idea this is actually the same idea behind the lightning network from bitcoin and radian network as i said is one of the oldest uh implementations of a scaling solution for ethereum uh on the interior network layer one nitrogen 1.0 so far so the radio network how it works it's mostly composed of a set of contracts deployed on ethereum net and also uh on all the test nets mainly it's the the main network that you use and it uses a federation of metrics.org transport servers for offshoring communication between nodes and discovery as well as it uh and trust this federation to be able to uh connect direct to webrtc peer-to-peer communication changes between nodes so they can talk uh more efficiently and and faster through those peer-to-peer and rtc uh channels without actually having to go over the metric server but the most they fall back the uh the last layer of communication of offshore communication goes over metres which is very reliable in the sense that it can be reached since it uses http pooling in the background it actually can be reached behind net over mobile clients as well as on node.js and several platforms there are several libraries implemented um everywhere in order to communicate with metrics federation of servers this federation currently is not connected to the main matrix.org federation um but it's open uh and currently just a created list but eventually this will also be registered on shane at the list of uh currently participating nodes in this federation the transport servers are free are provided by community and we ensure that this will continue working so besides those the free transport servers we have a set of incentivized services provided to the network namely pet finding and monitoring services but finding is responsible to keep a bird's eye view of the network topology as well as capacities and being able to find uh the most efficient path towards your given target on this network and monetary service of course is responsible for allowing partners to go offline without incurring the risk of losing their received assets because since this only the payment channels only require local consensus you any node participating it on it and willing to keep their received uh assets would need to be online 24 7 and that's why we need those monetary services on lightning network it's called watch towers that are going to act on your behalf properly incentivized in case it's needed to to act in case the partner has closed uh your channel while you were offline so currently we have two major clients implemented already in two different languages we have the rating python implementation which is the first reference implementation mostly focused on servers and personal computers as well as the light client which we call the light client because it's using typescript transpired to javascript and intended to work in browsers and node.js environments but it's not the light clients in the sense that it depends on a full client to work this is actually a full implementation of the reading protocol um in the form of an sdk or a library that we call reading ds and to major interfaces for it user interfaces so the dap is our web ui interface user friendly and the cli is a restful express node.js api client which can uh which is compatible with the rating title and restful api so it's interchangeably both clients can be intelligently interchanged accordingly and still be able to work on the same applications together as the back end of any application built using those uh reading rest api so yeah this is more or less how it's built the the network this camera architecture so we have a core of nodes that are well connected to each other here in one and two and three and we have light clients or it could not be litecoins but any client that is not willing to actually depose and commit the phones on several channels instead they open a smaller number of channels with the core of the network in this case a and b could be like clients working in the browser running the browser and uh that finding serves uh the set is responsible to keep and a view of this whole network topology and be able to find the path between a and b for example when a requests it as well as when b receives a transfer it is it will be updating monetary service with the the latest balance proof that it's received and then they can go offline safely and when trying service will act if entry in this case the partner close the channel with b while b was offline so yeah this is the rating protocol this uh the wording protocol mediates transfers on this network of payment solutions uh using um locket transfers or a hash time lock mechanism where a after getting the path between nd which is a target through b and c but they only have a channel with b they then compose a locket transfer to b having d as target and going through b and c so b upon receiving this locket transfer creates a similar locket transfer to d through c using the same secret hash and then c does the same when d receives the transfer identifies itself as the target and a as the initiator the target requests the secret for that specific transfer from a and then it can reveal only to d through transport and this the secret that hashes to that secret hash for this hashtag lock mechanism and then d can safely really reveals the secret to see in order to claim an option payment if c for any reason does not want to cooperate on this off chain protocol and tries for example to become unresponsive d can go on chain and register the secret on shane and then they are sure as soon as they have received the secret that they will get paid because if the c does not collaborate they can go on shane register the secret and this will allow them to then later in the future when they want to settle the channel to claim those tokens that were received on this specific transfer uh c upon receiving the secret of course needs to now knows that d has the capability of going unchained and requesting this payment if needed but to avoid that the need for that they unlock the transfer to d by sending an unlocked balance proof to d with the same amount that they had previously sent but now the out c also knows the secret so they can reveal back to b b unlocks to c then b reveals back to a and a unlocks to b and then you got a payment fully safe uh fully safely mediated payment through this network between a and d without actually then having direct channels between each other so with only a channel with b a was able to transfer to d as soon as they knew the route and they they managed to perform this off chain protocol through signed message between each other so how the rating actually are actually already in transfer workflow works so the client needs to deposit utc if they want to pay for a route from pfs or if they want to have monetary service monitoring their channel and they are willing they are need to go offline for any reason of course it's after the posting to dc they also need to open a channel in order to transfer tokens through this network they may check that the target is online in order to that if the target is offline they don't even need to start the transfer since it's not going to succeed anyway both nodes need to be online in order for the transfer to work and then they need to get a route that if it's a direct transfer so between partners connected to through a direct channels a direct channel they don't need to request a route because they know that departure is or isn't online or if it's a mediated transfer they request the pfs and pay for this request a small amount with several orders of magnitude cheaper than on chain transactions in order to route this transfer through the network then they initiate the transfer if it succeeds it it should succeed quickly or else it's going to uh keeps retried until it expires when the trunk if it for any reason it happens that the transfer expires before succeeding or for example the sender went offline or for any reason after they come back online they see that the transfer failed and they are able to assign a locket lock expires and masses and make their locket transfer liquid again so there's a small locking amount usually around 12 minutes that where they these phones are virtually locked in this channel and just transfer even if it has not succeeded into uh did not go through but after that they can just expire it and get back their phones and then do whatever they need to do maybe try another route maybe uh withdraw this from this tokens from the on-chain channel uh upon receiving transfer of course the node needs to update the monitoring servers if they are if they plan to go offline or for any reason if they are staying online all the time for example which is the case for full nodes they don't need to update the monitoring service but it is highly advisable since it is as i said this is just local consensus this is a requirement for this network so how is the actual large colorant architecture this it's primary target platform our browsers which contains the most restricted set of interface and it is as it's the most secure or they strive to be the most secure platform because it has the highest exposition to clients and to applications web applications running anywhere in the web the browsers are quite restrictive on security features and therefore it's hard to make something truly innovative and cryptograph uh safely cryptographically safe to actually work on browsers so we choose to target browsers because this limited set of assumptions or a browser tab or a browser application is not always online it does not have good uh guarantees on persistency and so on so our id is if it works in the browser it should work anywhere so the browser is the most limited set of um of features and after that if it works in browser it should be easier to uh have some more relaxed assumptions for example mobile and better devices as well as servers and personal computers we also target node.js it is a quite common platform denominator and available from iot devices to servers and the clients is fully written in typescript uh and it's type save as well it's transparent javascript so it runs whatever uh the javascript uh javascript code can run so the sdk or the library red mts is in the base it communicates with the radio network and ethereal blockchain and its interface currently is the dap and the cli so yeah you can use the dap directory uh those are the main use ways for you currently right now to use the depth uh the the light client so you can use the dev directly it's kind of a people like experience where you can redirect the user to the wallet the the large client step where they will perform their transfer so you can pass token target amount and even payment id over parameters they will perform their transfer on this deployed depth instance and then you can detect that on your system on the backend and react accordingly for example by providing them for the resource they just paid you can also use the cli uh which is a node.js client but this is mostly intended for servers and backend implementations since this needs to be running 20 or should be running 24 7 most of the time and you can also import and essentially the light client sdk directly and so the litecoin sdk is a quite easy to use uh api where you can use and implement a fully new client by leveraging the radium protocol uh risks and algorithms implemented in the life client sdk or light client rating as reading ts library which is available on npm.js so it's the most proof approach but leaves more decisions to the developer so with whom to open a channel with how many to depo how many tokens you depose on udc or on a channel and so on the cons of it is that if it's running on web this is mostly iso uh uses indexeddb uh to keep state because the light client of course since it is not global consensus it require its stateful so it requires some mistake to be kept on your client um and since this this state is isolated by origin or website if you do that on the web you are going to require from your user to do the onboarding for each uh instantiation each implementation in each part it it place where you implement this while you use the depth directly you can rely on the state uh being shared so let's do a quick demo uh first for the depth so let me just refresh this this is that instance you can access it at http and this is a pwa uh implementation in client so you can install it on your system and run it fully uh offline but let's not do that now once you connect it will generate a private key which is actually derived from your main metamask or whatever provider you are using main metamask account this is created by signing this message which gives you a warning that you should not sign this message outside of this domain so it's specific per blockchain per network and per domain and you can just sign it and it will login and it will all the tokens and i either use it for onshank transaction is is still offloaded to the main metamask main provider account so you can use it from girly here so you can you can keep your stash still on your main account which is uh interactively prompted for any transactions being done being made but of course you can um the this sub key account which you can see here is different from my metamask account which got generated this account here can be used only for signing the messages that go back and forth because you can actually use the metamask account directly but then you would need to sign several messages in order to perform a single transfer so let's do a small transfer you can see here and that i have a single channel with 30 tokens of this test token deposited on it the state is open you can just type an answer address here for example this is my uh hub my my partner address so i'm going to perform a direct transfer since i'm transferring to someone that i already have a 10 week so let's do 0.1 uh you can see that it is keep it selecting the route because this is a direct transfer so i don't need to to request a route then let's perform a transfer the secret gets reviewed on shane the secret gets reviewed to the partner and then the transfer was successful this usually takes between half and four seconds depending on network conditions i'm in brazil right now the hub is on germany so it takes around four seconds to perform this transfer sorry but you can see here these two way faster and was completely free once the user has on board so this is the client you can manage your channels here if you need that you can close it and settle it in order to withdraw the tokens from the channel if needed besides this if you don't want to use the deployed instance of the light client radio network client you can also use the radio sdk and raise nts which is the engine for the radiant protocol here recent typescript as i said and running fully in the browser so it's not offloading tasks and responsibilities to a full client somewhere this is running entirely in the browser uh signing out the messages cryptographically verifying on chain and events and signatures everything running in the browser so here i have the smallest possible raiding light client implementation using the sdk just to showcase how it works as you can see this is just as simple as the simplest possible html we have the simplest possible almost package and this is the whole source code so yeah most of it is just this function here right you can see the whole onboarding process happens here i already have this account on board but i will show to you guys uh so i first you need to connect to metamask by requesting the account from it when you do that if you haven't connected to the site website yet you get notified by matamask that this website wants to access your account you can select the account that you want to to provide to offer then you can instantiate rating here there is a nice utility here where you can just pass the provider here we are passing we are telling radiant that we will want to use the first metamask account for it you could specify a specific address or private key directly here if you want and so on then we subscribe to channels updates and we start reading this will think the state if needed with the blockchain if any event was lost in the past then we can ensure that oops we can ensure that uh the service tokens are uh funded so the user depos contract which actually is used to pay for pfs and monitoring service is funded so here i'm requesting the the user how many tokens they want to depose and then what so yeah and here i can ensure that there is a channel open uh in this case i am asking using just a window.prompt so it's the simplest possible approach just to demonstrate that i can just ensure that the channel is open here in this case i'm suggesting this hub that i just show have shown to you guys and then the amount to the post and once this is done i can once the client is started i can just perform a transfer so i will show it to you here i can start the client mata mask will ask me to sign that same message in order to generate the delegated account this is deterministically generated from the main account so it's just the hash of the signature the signature of this message here once you sign it will sync and as you saw it took like two or three seconds to sync with the blockchain so it's quite fast now i can perform transfers and this simplest dummy application will ask who i want to transfer to so let's say that i just want to transfer to the hub that i have a tuna with it could be your node it could be any node online on the blockchain on the radio network right now we have methods to suggest partners here as well let's just transfer 0.01 tokens um so it's transferring exchanging messages um yeah we can see here the transfer was successful um it did not show a dialogue but we could have uh just create a dialog here i can [Music] transfer to show success but from the logs here you can see that the transfer was successful a full-fledged client like the that we'll have a proper dialogue as i have shown to you guys uh but yeah this is enough to to have your transfer going so let's try a different one now i'm a data transfer to this other node here that i have online on the net the same token network right so let's copy its address then perform a transfer i will paste my this client here address to it you can see here the uh yeah i need to start just reload this because this does not have fabrics but on the dap you have a full-fledged application this is a light client written like 60 lines of 70 lines of code so yeah this is simple but on a full-fledged client you could implement all your the error handling that you should so yeah that's the start it syncs quickly you can perform a transfer paste the address let's see i want to transfer um 0.2 tokens and they need to perform now a mediated transfer because i don't have a direct channel with that node but this just worked so you can see here the transfer got received even though i don't have a direct channel with that node i just have a channel with the hub so of course this is their payment channels network is a very powerful approach especially for iot and solution use case that require fast small and often uh transfers and this uh is the perfect use case for our payment channels and the light client and radio network is already ready uh and the rating the main rating python client is already deployed on mainnet so you can use it right away right now and the light client is not yet green light to the mainnet but you can hack on it on there also if you want and you can also test it on girly as we are doing here so just start and transfer after you get on board which is the expensive part but this is a property shared by all the second layer solutions right now we are trying to check on improving that but after after you are on board the the user can perform as many payments as they want free fast and cheap fast cheap and scalably on this radio network of payment channels that's it for me um questions remarks any any anything that i could help here what do you guys think even a demo that was awesome there was one question uh if the receiver has to be online yes the receiver has to be online mainly because it's it's required that the receiver sign message in order to request the secret from the initiator or else the initiator is not going to review if they initiate or reveal the secret to anyone else they could get robbed so it's needed to sign this mess and this is what gives the security features of the ready network where you only actually only paid what you sign it for not what you deposit so the post is only a backing of the transfers once you have it back on chain you can sign the balance proofs off chain and you safely perform this transfer but yes without the payment channels the receiver needs those to be online but with transfers taking even less than one second this is usually not a big problem because we have one sec we can have super second finality on the radio network so as soon as the transfer protocol was completed as soon as you verified the signature of the message that you have received you can be 100 sure that we will get paid this is the security feature of this uh network so even ethereum 2.0 solutions they do not uh provide this uh property so actually we are looking forward to ethereum 2.0 because it will reduce a lot the cost of onboarding users on our solution but payment channels the state channels payment channels is a specialization of state channels solutions are actually complementary to charging and roll-ups strategies for scaling ethereum so we are looking forward to that they both will work great together hopefully more questions uh so someone asked here how does raiding avoid the gas prices well unfortunately it can't yet this is an issue for all second layers calling solutions everyone needs to onboard at some point and to onboard you need to pay gas for that and to off board you also need to pay gas usually so this is a problem that we are actively working towards improving because right now you need to pay for onboarding the user so they all the user needs to onboard they need to open a channel on chain they need to lock the tokens in a deposit on chain but after they have done that they perform the transfers full of chain as often as they needed you could perform 10 uh transfers per second without burning a nice eyelid so it would work fine for example for iot devices working and paying for energy or for paying for megabytes of data downloaded or uploaded or to pay for minutes or even seconds of video watch it you could implement this refraining small scalable fast payment work great for it but yeah for to onboard it's still a little bit expensive and yeah so i gave here two examples mainly you can use the dap directly as a user or as a developer by pointing the user as a pay wall for example uh to the depth and then the whole the user will be able to use their already instantiated uh light client depth account in order to pay uh for your specific request or you can implement the sdk directly which opens all the doors possible this works on node.js this works uh any anywhere that javascript can uh and then you can implement your own client without having to uh to think and to ensure all the safety's guarantees that rating provides so the whole rating protocol is implemented in the reading ts package and you can use this on your application right away for iot for web anywhere browser browser or javascript works it should work so you put an x amount paying fees once until you don't spend our ex covered for payments so yes hopefully if you can lock a amount high enough and you have this specific use case where you perform many payments small payments after several payments of course you you already have gained what you would on gas fees if you were doing all of those transactions clogging the network another property of state channels and payment channels is that only the less latest transaction goes on change so it adds privacy the no one needs to know every small um every small transfer that you performed you only only the latest final amount is satellite on chain and needs to go and needs to be visible on chain and even that we are we are looking on solutions to improving that using zero knowledge alternatives and algorithms for this so perfect suggestions for it hackathon i think we have published some of them jacob has been working on that there are several alternatives that goes into the direction of integrating reading with the latest uh on chain scanning solutions like a relapse this would be great to see something in that direction the the smart contract part of reading is just as much contracts it's not it's not special in any way it's just a normal smart contract so you can optimize that using the standard uh solutions out there uh but if you want to implement real also use cases actually using rating for end users that would be great as well for example paywall solutions pay-per-view prepare minute periphery megabyte or maybe even a small robot ping for its energy or its connection link using rating that would be something quite interesting [Music] um yeah so jacob has shared the link that would help on that so yeah the about the origin token and this is uh interesting talk it's mostly related that we wanted to support any token network of course right now it's quite a little bit limited the number of tok networks that can be used on mainnet right now it's a die and that rapid heater but we want to open that for everyone but not every token is useful for the service providers so it's important that the service provider use a centralized or a shared uh token that they know that that will be will work regardless of in which token they are serving their services so this common denominator this centralization point four value on services provided on the network needs to be stable and that's why we we have choosing a specific token for that all right we are a little bit past time i want to be conscious of everyone's time here so thanks so much again andre for showing that very very cool presentation very informative very educational very good clear presentation um and as always if anyone has any questions please feel free to ask um on the discord sponsored raiden channel and i'm really excited to see what everyone builds off of raiden thank you guys thank you very much and looking forward to see all your guys ideas and projects implemented on top of it 