uh and we have johan as uh our speaker for today um and he'll be taking you through the session um and with that being said um i'm gonna pass it over to yuan to introduce himself and get the session started perfect thanks uh let me hop over and share my screen um with my slideshow yes all right so hello everyone um and thanks for the introduction so uh i'm john and um during my day-to-day job i'm the product lead at consensus diligence and so at consensus diligence what we do is on the one end we do audits um and this is probably what we're uh most well known for um but we also have a product site so we've built mythics um as a vulnerability scanning tool and right now we're actually working on a new product called diligence fuzzing which um has some relation to the workshop that i'm going to be giving today and i'm going to show some sneak peeks as well um but the workshop today is really going to be all about scribble which is a super nice tool that i'm gonna explain in a second uh and how you might apply it uh to your integration with uni-swap contracts um so let's see i'm first going to give a brief introduction into what scribble actually is what specification languages are what property based testing is um before diving into uh deep into the the subject matter um which is gonna be me scribbling as um erc20 token so what i'm gonna do is i'm gonna walk through a smart contract that implements in here the erc20 interface and i'm gonna add specifications along the way so that you can see what the the workflow is like and what kind of properties you might specify uh and then i have for example setup of how a smart contract might interact with unit swap and what kind of properties you can write to make sure that your integration is doing what it's supposed to be doing with you and swap and not something else um and uh i'll finish with a small wrap up um i'm gonna try to do the the the workshop part for about 40 minutes so that we have enough time for questions and to dive deeper into custom topics all right so before i go into what scribble is i i want to talk about what properties are and properties what they are is or how we can define them is a logical statement that you expect to be true well and and uh as there's two examples on the slides uh the bottom one is is the most relevant one because usually we're talking about code when we're talking about properties uh so for example a function might only be allowed to return positive numbers um the key of this sentence is that it's something that you expect to be true so whenever you are writing code that interacts with other code you're basically making assumptions about how you think that other code will work when you call into it and this is also where a lot of bugs come from when you think something is supposed to be done doing something but it is actually doing something else so your assumption is invalid and that's why you want to test those properties those things that you expect to be true and that's where where scribble comes into play and what it helps youtube um so scribble is a tool that we built um it's been released for i think about a year now we released it around this time last year and it's basically two things combined on the one hand it's a specification language like a programming language essentially and on the other hand it's a runtime verification tool so a specification language is essentially something or a language a programming language a formal language that you use to write properties in um scribble is based on solidity wherever we can um so that it's easy to use and you write these properties as annotations or what we call annotations this basically means you write code comments that in this language next to the code that you're describing um [Music] which looks like this uh so here i have a really short example with a really trivial property um but it does highlight how it works so we have a function this cannot be hacked that's doing something um and we have a property that says that this function is only allowed to return uh numbers higher than zero not zero um and you see that the property is like right next to the function that it's describing um now this is great you can write properties about your code and it will like define what it's supposed to do but uh we kind of want to have something that we can actually run that we can test with uh so that's where the runtime verification comes into play so we take these properties and we translate them into solidity code that checks the properties so that afterwards we can run the test feed or we can run fuzzing or symbolic execution and it will look for different ways to trigger these assertion failures and it will be able to tell you uh when there is a way to trigger a property violation so this slide shows kind of a rough example of what instrumentation could look like on the left we have the original property and on the right you see how we instrumented the code by adding an assert at the end saying that the result is bigger than zero now this is a trivial property there's lots of things that you can do with scribble that i'll show later that are that produce more complex instrumentation um this instrumentation is used for testing only and won't show up in your production deployment um for various reasons for example gas usage but also secured you don't want to add a necessary code because it increases your attack service so here's one way to think about testing with these properties or also called this is also called property-based testing and it's essentially you can think of it as an extension to parametric unit tests so in a parametric unit test what you do is you essentially separate the test case from the check that you're doing um so here in the slide i have in python example of this on the top we have a function that performs the test on a particular test case so what it does it calls the add function and then it checks that the add function returns the sum of the two numbers and then on line six and seven we have something that puts in the parameters um and and runs essentially all the edge cases um [Music] struggle essentially replaces this top part where you write your checks as critical properties and then all that's left is to do to find the edge cases and we've replaced that with fuzzing which will automatically try different things so fuzzing will automatically come up with all these inputs like one and two eight and three zero and one and in the end you get this comprehensive and extensive test suite all right so that's really the summary um of of the whole [Music] the the tool uh and now i'm gonna go into my ide and show you how everything works um or how you can go about scribbling if you wanna follow along um there is essentially two tools that you need to install and i'll show you the command for that in my terminal right now uh so sharing my ide now and you are gonna need um the scribble tool installed that's that's the main one uh so you can install that using npm uh like this uh it's really easy that's all you'll need um to follow along there's a second thing there's an extension for vs code called vs code scribble which adds syntax highlighting which makes life a lot easier all right but let me jump into this first example and i'll share the links uh for these after uh the presentation um so here i have a smart contract a vulnerable token that implements the erc20 interface in specific there's a bug in the transfer function which allows you to cr create tokens by sending tokens to yourself um what happens if you send tokens to yourself is that you compute your balance [Music] but after subtracting the value that you're trying to send you compute your balance adding the value you're trying to send but you're using the balance from before the transaction so without the removed value and then you're writing it um so essentially this is will be moved and not used and you end up with this code which will create tokens um and there's various properties about this smart contract system that if we would define and test them that would catch this bug the first one is one that i'm gonna describe about the whole contract which is usually called an invariant so you can write those like this and the inversion that i'm thinking about is the one that says that the total supply must be in sync with the balances mapping and you you can write that like this we take the unchecked sum uh this removes overflow checks uh which we won't need in this case of the balances mapping this is the values and say that it must be equal to the total supply and that's it this will catch the bug already but there's a lot more things that we can do we can also define um and if succeed statements uh this is kind of like an invariant but instead of stating something generically that must hold all the time we say something about how things are allowed to change so what we can say here is we can say that the old total supply is equal to the new total supply and you can see i used a non-solidity feature here namely the old keyword and what happens is what i'm essentially saying here is that i'm taking the value of the total supply variable at the beginning of the transaction and comparing it to the value of the same variable at the end in summary this properties essentially says that the total supply won't change which means that this token isn't deflationary or inflationary it's the constant supply so that's an interesting one now we can dive into the different functions like lower level elements of the code and describe properties about that that are more fine-grained and describe something about the particular behavior of that function so for example here let's dive into the transfer function um we want to say something about successful termination um we want to describe what should happen if the function actually succeeds and in particular if i want to probably say that if i send 10 tokens to you or any amount of tokens to you that you receive that amount of tokens so let's write that down if i send tokens to someone who's not myself um then i'm using an implication here again this is a feature that we added to make property writing easier and more expressive uh then i want to check that the old balance that i had which we can query like this and here again we use the old keyword minus the value which is an argument to the function is equal to the balance i have after sin uh after executing this function and we can do something similar here for the recipient uh so what we can say is the old balance of the recipient plus the value is equal to the balance afterwards let's see uh we could also say something like um this function can only succeed if the old variance of my of myself is larger than the amount right uh this kind of duplicate uh or larger than or equal to this duplicates this check but it makes sense to write the property anyway because this way we get to essentially double check our work and make sure that we're actually the code underlying is actually testing this property let's write one more property here which says something about the case the error case that i was just describing about when you send tokens to yourself so if that's the case if the sender is the true address then i want to say that the balance before is equal to the balance afterwards right uh and now if we check these properties we expect this to fail but we also expect this property to fail and i'm actually not in the right directory here so let me go into scribble exercise one now i can use the scribble command line interface to take these properties and translate them into code that checks so let me do that real quick you can do that by running this command arm files contracts and then our vulnerable erc20 now it will find that i had a typo and there's actually multiple typos so i i usually make small mistakes like this when i do a demo which is great to highlight the error reporting that this tool has and you can see here how you get a neat like little error description that described that balance doesn't exist and i know it doesn't exist because it's actually called balances let's try that again um where i forgot it somewhere oh over here fixed let's see what am i yeah it's not called amount it's called value so you get this iterative approach to fixing your bug similar to how you would maybe write some invalid solidity syntax run the compiler and it will tell you how to to fix things and [Music] now if we dive into our property we see or our our code we see that a lot has changed there's it's not really readable anymore and this is also not our purpose but i'm showing it right now so that you can see what the actual instrumentation looks like so there's a lot of code added that will check our properties so for example here you see that we measure the value of total supply then we call into the original allowance function and then here's a check with that total supply value and we're comparing it to the total supply after the call so this is our if succeeds property that ensures that the token isn't deflationary or inflationary let's see there is also a call to check state invariance and if we go over there we see here that we're comparing this value called underscore balances dot sum to the total supply this is our invariant that would be violated uh if we but if we exploit the bug and that's in the transfer function um and this is really all there is to it now you can see that we add two statements here one is an emission of a log event and one is an assertion the blog event here is used by our tooling in in the back end to figure out which assertion failure matches with which property and this is to improve reporting to you so that it's easy to figure out what properties are are correct and which aren't but there's also an assert false here and we added this because it's pretty much universal all your unit tests will fail if they trigger a property violation which raises an assert false which means that if you now have a test suite and i believe we actually do let me see if we have a test suite and we run it then it will encounter this problem the the assert or which triggers the property failure which triggers the assert and the test will fail so if i clean up and quickly compile everything i think this will actually not work because i made a mistake in this property a truffle test yes we see here that a property was violated and which caused the the whole test suite to fill um which is great um i would usually recommend though to use something like fuzzing because fuzzing is great uh as it finds all of these little edge cases on its own without requiring you to provide them um so i actually ran a fuzzing campaign on a smart contract such as this with instrumentation just last week um and i'll walk you guys through that yes so there's a lot of data here and i realized that i should have done the easy mode that doesn't overload you right away um and just has the the necessary data so there's a few fields here um we have test cases per second this gives you kind of the speed of the fuzzer and in this case it's zero because the fuzzer stopped um we have the total code coverage achieved during fuzzing we have the amount of time that we fuse we have a neat little metric here that describes the chance that we missed something or it really describes the chance that we'll find something else like more coverage in the next hour or so and we see that there's some errors that the fuzzer found um and we can go into the code and actually look at those properties or those those errors that got raised and see what's up uh so we have a property here that checks whether the balance sum is equal to the total supply and so if you remember this is kind of like the invariant that we wrote um there's also a nice window here that gives you the counter example that the buzzer used to figure out that this property is actually not valid or that it's violated um this is a test case essentially that exploits the smart contract and here if we inspect the the trace which oh it's folding for some reason all right you can see that the origin uh this is a little bit this never happened to me before the origin here is the same address that we're sending to so we the fuzzer found a trace where it from its own account called transfer to transfer tokens to itself uh and it will mean the this amount of tokens essentially to their own address which raises the problem raises the emission and triggers the alert in in this framework that we have on the left here you have a bunch of green bars and these are exactly what you expect them to be these indicate the coverage that the fuzzer was able to achieve so we see here that we were able to cover of the transfer function except for this little bit um which makes sense this is what would be covered if the property is violated which we can see here but since this property is valid the property that's being checked here this code is unreachable and we don't expect our to be covered here um that's also one of the reasons why we won't reach 100 coverage here all right so that is really the basic workflow that we have when fuzzing or when doing property based testing we first write scribble properties then we take the smart contract and instrument it and give that to the fuzzer to automatically try tons of input and to be sure that the code is doing what it's supposed to be do now i have a few examples set up that um kind of show you how you could use this if you were working uh or interfacing with a smart contract um or with with a uniform smart contract and i am using um unisop v2 for a lot of these examples because it's just a little bit easier to reason about in the amount of time that we have uh right so let me open up this again and yes so i didn't really bother with the implementation of the function this is just to highlight the idea so here we have a contract that has some functions that oh this should be payable it has a function where you send e into it you give it an amount and a token and you have it take care of the rest um in this case i'm expecting this function to go into a universe for pair to make the trades maybe it has some custom routing implementation i don't know but from the perspective of the property i also don't really care because all i want to check is that the effect that i want there to be is actually taking place so the first thing like the effect that i want this function to implement is that after the transaction i get amount more of tokens so i can write that in this property here which says uh old so we take the verb the value of this expression at the beginning of the transaction of the balance of return value we add amount to it and we say that the new value must be higher so this is kind of like a slippage check the second property says that we don't leave eth in this contract accidentally [Music] which you want to make sure because otherwise it might get stuck and now we can instrument this and run our fuzzing and what's great about this is that this property doesn't need to concern itself about how the function works and what the underlying logic is it just needs to save the function is supposed to be doing in the end so you get to reason on this simpler higher level [Music] another example is this where we have a a contract which has some liquidation function uh so people have positions um i have used this amount value to indicate the size of their position and they have their position in a particular token um usually you have some way of liquidating positions when maybe for example the price goes in out of a particular range um but you want to make sure that you get enough back when you liquidate such a position so here what i'm doing in this property is saying that if the liquidate position function succeeds so if it runs successfully then i get at least this amount back this amount of tokens back so first i compute the size of the position uh i assume there's some oracle price that gives me like the value of that position and then i say a one 95 percent of that um back and then we have this second line which then describes well i take my balance before add the minimum amount that i want back and i say well after the function my balance is bigger than that so here we make sure that we get at least 95 cents on the dollar back um a third example which applies more to unison v3 is when you want to do some magic math uh and you want to make sure that it does what it's supposed to be doing uh and i am saying it applies more to universal v3 because there is a little bit more math going in there and here i took a function uh without implementation again that's also in uh the uniswap code base um which i believe in the bitmap library which takes a input and returns the most significant bit and now there's these properties that the uni swap guys are testing themselves but that you also want to be sure that your custom implementation of that logic satisfies um so in this case there's these two very complex statements that i took from the code base from uniswap which says that this must be true and i encoded them as properties so we can then instrument this give it to the fuzzer and let the fuzzer figure out whether the code actually implements these or imp has an implementation that satisfies this property or whether it doesn't and let me go back in because i have one more example that i want to show uh and that is something that really only is is super specific to university 2. where um if you remember um the way that you used to do a swap is you transfer tokens into the contract and then called the swap function separately so you could even do three transfers into a pair and then call this function or do it all at once it was up to you but a key thing that you want to make sure of is that you don't leave any tokens in the pair after you're done so that's what this property checks it checks that after this function succeeds or if the function succeeds then the reserves so this is the internal bookkeeping of the pair are equal to the actual balances of the tokens that the pair holds so now again regardless of the super complex implementation that you might have that performs several trades maybe it does routing maybe it it it goes to multiple exchanges it doesn't really matter we just want to say that at least this property holds which says that the pairs doesn't have any extraneous amounts left after we're done and then we can trust the fuzzer to check that this is actually the case awesome all right we have a bit more time so there's one more property type that i want to show which is in here so in of the examples before i've kind of highlighted a few different types of properties we had invariants in global if succeeds which describes something about the whole smart contract and we had these if succeed statements which describe what a function is supposed to be do there's a third type which is called if updated and this is a great type of property when you want to say something about how a variable is allowed to be changed so maybe you want to say something like this variable is only increasing in this case we want to say something about access control in specific we have an ownable contract where we want to make sure that it's really only the owner that's allowed to update the owner variable so we say that if the owner is updated then the owner well before the update must be equal to the center of that transaction or and this allows the constructor to write to it the message signature is zero uh and this is only the case whenever you are running the constructor which doesn't have a message signature or it has a zero message signature and if you now go into this exercise [Music] and run scribble [Music] you can see how scroll went into the code look for the place where we're updating the owner variable we record it and we add a check that makes sure that well in fact the message sender before is the one that's sending this uh transaction uh and and performing the update and the great thing about this is that it works with inheritance so if you have this contract with this honorable contract and you inherit it and it has this property in there and you instrument or run scribble on this higher level contract it will take this property into account and add checks wherever your higher level contract writes to the owner variable and this ensures that even if your higher level implementation which inherits from this even if that violates this property we'll know because this check got added all right so really the way that uh you can get started easily with scroble is well first of all you installed the tool and the plugin but then you write just one or two properties to see if you can get a feel for like what what kind of properties are true for your smart contracts and how you can write these properties and then what you do is you just run this instrumentation and then you run your unit test feed which will cover various edge cases throughout your program and maybe or smart contracts and maybe already trigger something and fight and it might find bugs already um that's the first step the second step would be to go into um fuzzing a little bit more so um there's the diligence buzzing platform which i really like but i'm biased of course um but there's other tools as well um and go and try one of these tools uh reach out to us for example i'd love to set up a trial fuzzing campaign if you set up a few uh properties yourself and then we you get this tool that will automatically try and figure out whether any of your properties can be violated and [Music] you can fix those problems the next level or the final level really is to set this up in continuous integration to make sure that you're always checking and always buzzing and always making sure that the code that you have um deployed or that you have on your in your repository is all doing what it's supposed to be doing uh you can think of it essentially as running your units as sweet but much much stronger like like a unit as sweet with millions of test cases all right so that kind of summarizes um or that's kind of the the body of that the workshop let me share this slide for a second with that i'd like to open it up for questions well first of all thanks everyone for hanging out here um you can find us on the internet uh consensus audits on twitter uh we also have a nice website we have tons of articles explaining how you can go about scribbling how you can do fuzzing uh how you can think about properties um and we have a lot of great resources there so i really recommend checking that out and so we have some time for questions now i'm also going to be in the discord and you can also reach out to me anywhere maybe twitter i'm happy to help with anything scribble and any scroll related questions all right so now i have time for questions let's see if there are any in the chat i guess not i guess the the workshop was quite quite uh satisfying then and that it didn't raise any open questions or it answered any questions awesome [Music] feel free to unmute yourself to ask any questions as well all right i guess your workshop is so thorough there are no questions um well uh we'll just end it off here then um unless you know you have anything else that you want to be presenting to everyone no no i guess um if people just try these the this workshop exit involve uh themselves they'll maybe run into some questions and so yeah the invitation stands um as as me and i'll i'll try to help you as best i can awesome well thank you so much for joining us today euron um and thank you for such a great presentation uh and for the rest of you feel free to connect with on on discord have a great rest of your day everyone thank you bye 