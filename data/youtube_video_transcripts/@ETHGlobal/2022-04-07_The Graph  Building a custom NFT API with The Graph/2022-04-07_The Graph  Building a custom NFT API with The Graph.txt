chop on behalf of the graph on building a custom nft api with the graph questions go into the zoom chat and nader will address them at the end of the workshop and with that being said i will pass the mic off to nader all right thank you for the intro and um really happy to be here i am been involved with dalles you know ever since i kind of got into web three maybe a couple of months after that um since then we've actually launched a dow in the last week at the graph called advocate style we're working on another dow i've also helped launch or did launch developer dao and participating in friends of benefits um and interested in a bunch of other ones so it's cool to be here you know for um for the topic of dao's uh but in particular like from the perspective of a developer what i'm going to be talking about today and presenting a workshop on that you can also take and do at your own pace or you can do it like today or you can do it a week from today whatever the the content is open source and you can pick it up at any time but i'm going to be building an api on top of a smart contract and a lot of dows including developer dao are kind of built on an nft or an erc20 contract so i think um the example that i'm going to give today will hopefully be a good example for people that are thinking about building out user interfaces or applications that interact with the data from their dao smart contracts so that's what we're gonna be doing today we're gonna be building an api on top of an nft smart contract and um it's quite a bit of code that we're gonna be going through so i'm gonna be kind of going through it fairly quickly but i've done my best in this workshop to create a piece of content that allows anyone to kind of take this completely end-to-end without having to worry about like messing up anything because all the code is copy and paste so anything that i'm doing here it should be very well documented in this workshop so um feel free to try to follow along um and but also consider that like if you do not want to follow along in the sense of like building this yourself you might just follow along and watch me build this maybe check out the code and stuff in the workshop and then try to build this on your own at a later time so with that being said i'm gonna go ahead and share the link to the workshop here um the main the main two things within this workshop or just the readme itself so the readme is like a step-by-step uh guide for you to use and be able to build what we're building and let me go ahead and share my screen to kind of like take a look at this so this is the github repo it's github.com3 it's the very first project that should show up in my repositories uh custom nfc subgraph workshop and i also pasted the link there but um the two main things to think about here like this readme file is really just a tutorial kind of and then the code base that we're gonna be building is linked here there's no need to actually clone this because like if you want to be successful here you might actually want to build this from scratch so what we're going to be doing is like doing that just doing just that building from scratch and the nft smart contract that we're going to be working with is the crypto coven smart contract so if i go ahead and click there you'll see that on etherscan we have the crypto code and smart contract and we see that we can link to the actual contract code and um we're going to be kind of referencing this a little bit in this workshop and then the last thing that i'll point out is that most um or actually i think almost all if not all erc 721 contracts are you know written fairly consistently they have mostly the same functionality and one of the functions that you'll often see is a base uri um or i'm sorry a function called git base uri and this kind of returns the base uri for the ipfs metadata and this is something that we're going to be working with in particular here with the crypto curve and smart contract so if you want to get the metadata off of almost any nfc you can usually go copy this ipfs hash and go to ipfs.io slash ipfs or any ipf as gateway paste in the hash and then paste in the number of the token often it ends with json and then here if we wait a couple of seconds this should hit the ipfs gateway retrieve the metadata and then kind of give you an idea about the information that's stored on this token and once this returns at some point we can kind of take a look at it and get an idea around the metadata that we're going to be working with so i'll give that a second maybe i'll paste in one that i've retrieved recently because it might be cash so it looks like it's taking a little time for that to come back but we'll come back and look at that in just a moment but uh but really all this is going to be doing is returning a json object and in that json it's going to kind of give us information or metadata about the nfc so it'll be things like what is the image what is the uh the the name the description other information about the nfc so with that being said we're gonna go ahead and start off by going to the graph.com and if i go to the graph.com here you're gonna see that we have uh this drop down here with different products and if you go here to the um the tutorial you'll see that we're going to be opening the graph hosted service so you can either click this link to open it directly or you can go here and click on hosted service and this is the service that we're going to be using to build our api now the graph has two different types of ways that you can build apis one is with the hosted service which is a centralized service that was the original iteration of what the graph was but more recently we've released the decentralized network which is more of like a web 3 way to build out these apis so depending on the features that you would like you would choose one or the other but ultimately we're kind of moving towards building everything on the network because we want everything to be decentralized but as of right now there are certain features that are not available there and in particular with ipfs if you want to interact with an ipfs gateway you cannot do that from the decentralized network so therefore we're using the hosted service now um to get started we're going to go and like sign in and this will essentially just ask you to authenticate with your github repository if you're using the decentralized network it'll just ask you to authenticate with your metamask account and then once you've signed in either with github or metamask then you can now create your first subgraph so what i'm going to do is click on my dashboard here and i'm going to click add subgraph and here we're going to kind of give this sub graph a name so i'll call this eth global and then maybe crypto coven api or something like that the subgraph name can really be whatever you like and then the subtitle will be an nft api for and or let's say for the crypto coven smart contracts so with that being said i'm going to go ahead and click hide because this way it doesn't show up because i've actually built a couple similar to these and since we're doing just a workshop i don't want this to show up for for everyone else to see and then with that you're going to be given your boilerplate i guess you could say or your the place that you're going to end up deploying to within the dashboard so now if i go to my dashboard i should see that this one shows up here and it says like not deployed yet so this is going to be where we deploy in just a moment once we write our code i'm going to try to refresh this gateway and i'll give that some time and then i'm going to go back here to the workshop okay so we've already done this part we've gone to the hosted service we've gone to the dashboard we've created the subgraph and now we're ready to start writing some code so the code that we're going to be writing is going to be done using a boilerplate project that the cli will essentially scaffold and it's really kind of like a starter project that you'll use for almost all of your sub graphs and a sub graph is essentially like the the term that we use for a graphql api launched or deployed to the graph and to kind of get started you need the graph cli to be installed so you can either use npm or yarn and you can just copy this command here and say npm install g at graph protocol graph cli and this will go ahead and install the graph cli and then after this is installed you'll have the graph binary and then using that binary you can do a bunch of different things most importantly to get started it'll allow you to scaffold out an example project to get started with all right so after the graph cli is installed you should be able to run graph and see the graph binary is there and if you want to run graph dash help it should give you a good idea around some of the commands that are available so now that we have the graph binary installed we can run graph init and this will walk us through and like set us up with all the different things that we need to kind of get started but instead of just running a knit alone we can actually pass in a few flags to kind of define a few different properties that we'd like to work with so i can go down here and i can see that we have a couple of ways like i mentioned that we can do that but for us we can go ahead and go to this command here where we're going to say graph init and we're going to pass in the contract from which we're going to be creating and that's going to be this crypto coven contract address we're going to set the protocol to be ethereum we're going to set the network to be mainnet we're going to set the contract name to be token and then we're going to pass in this flag called index events which i'll walk through in just a moment so i'm just going to copy this entire command here and this will go ahead and initialize a subgraph with a few different configurations now i mentioned earlier that we're going to be deploying to the hosted service so i'm going to choose hosted service as opposed to subgraph studio for the subgraph name you'll look here and you'll see that i have like your username slash the api name and the way that you would get that is it's going to basically just be whatever username you have so for me it's debit three and there would be slash this so you could just say you know type that in or you can even go here to the slug and the url and just copy that because that's going to be the same so either way you would say your username slash the api name and for me that's going to be debits three slash eth global crypto code and api and for the directory to create the subgraph in this is up to you this is just going to be the folder name if i was building a full stack project where i had a front end and a bunch of front end code i often use the naming convention of just subgraph that way like anyone that comes into my code base knows this is a sub graph as opposed to if it was standalone but since we are building a standalone project then i'll just leave it at uh at this name here the the network that we're going to be indexing is ethereum mainnet so i can keep that as the default the contract address we pass that in here so i can keep that as the default as well you'll notice that there's a little com a little check mark here that says fetching abi from etherscan so what this is going to do is like the cli is going to go to etherscan using this contract address and it's going to go find the abi which you can also find at the bottom of any contract that has been verified on etherscan and this abi is like something that we're going to need to scaffold out some boilerplate code that is specific to our smart contract and it's really cool because the cli actually went ahead and fetched this and like saved it locally for us to use so we don't really have to do that for the contract name we're going to use token because the nfc is you know a non-fungible token so the name token just makes a lot of sense but this could really be whatever you would like it to be so we'll give this a second and what this is going to do is like go ahead and create that boilerplate code and while that's doing that we can go back here to ipfs and we can see that the ipfs gateway it did indeed return our metadata so for the cryptocurren ipfs hash slash the token you get all this information so we have the description we have the external url we have the image we have the name we have all this information so like why is this important well it's important because the whole purpose of us building out this api is that we want to store and make queriable information about this smart contract and the information that is uh pertaining to it so by default erc 721 um doesn't give you a whole lot of information you'll you'll get stuff like the token id you'll get things like the owner you'll get things like the the base uri all that stuff but typically what you end up needing is the metadata that is linked to the combination of the base uri and the token id so therefore what the graph can do is it can basically call out to ipfs and it can read the information that comes back from ipfs like the description the image and all this other information and we can actually index that and store it and make it queryable and hopefully that will make if that doesn't make a lot of sense now it will once we're done building this thing so um once the subgraph has been scaffolded out we should be able to go ahead and open this up in our text editor whoops i'm going to go ahead and open this up in my text editor i had to change into that directory so this is the boilerplate for the subgraph that we're going to be building so the cli just you know generated all this code for us um there are three main pieces of code or i would say three main files that we're going to be working with to to define and create the um specific code that we're going to need for our api in particular one of those is the schema.graphql this is where we define our data model so in our case our data model is going to be a token type the token type is going to have different fields that we want to be made available for our application to consume or query so like i mentioned earlier that metadata is going to be kind of like important for us so those are going to be essentially fields on our type so what i can just go ahead and do though to get started just go ahead and delete all that so we don't need any of that code i'm just going to delete everything and save that so we have the graphql schema this is going to be our data model the other file that we're going to work with is the subgraph.yaml this is the main configuration for your subgraph this defines everything that you need to know about what's going on in your subgraph this is the main entry point for an indexer that is going to index the data from the network that you're indexing like this is where the indexer looks to understand what's going on in your api so like when you deploy this it first reads the subgraph.yaml it's it then finds information like oh okay we're gonna be indexing ethereum mainnet um this is the contract address that we're going to be indexing um you know from here we're going to be going a little bit more into depth in the actual specifics of our own subgraph and things like that but these top level items would could be things like i think we currently support near um and we could also say instead of like you know ethereum mainnet maybe we're gonna be ethereum would be more like a placeholder for evm so maybe we'll want to also instead index arbetron or polygon or whatever so you can kind of define all that information here you can also have multiple data sources so here we're only indexing a single contract but there are so many applications running on the graph that have multiple contracts that are indexed in a single subgraph so that's just stuff to keep into consideration so we're going to come back and update this a little bit in just a moment so those are the two first two files we're going to look at and then last we're going to look at the mapping which is the i would say business logic for our subgraph but to get started let's go back to the graphql schema and what we're going to do is go here to our workshop and you're going to see that we have these entities defined in our schema.graphql so the first entity that we're going to define is the token so i'm just going to copy that code there and paste it here so that's this code here and the token entity is going to be the main entity that we're really worried about for this for this api um we want to query for tokens so for the single entity we'll name it token but this will also be available for us to query um you know plural of or an array of we have information like really base information like the id the token id the token uri and things like that but we also have stuff that is coming off of ipfs so if i go to ipfs here you'll see that we have this external url so that points to a centralized it looks like a website like cryptokovin.xyz or maybe this is i don't know if it's centralized but you know you know the idea is that it's not like a um ipfs endpoint or something this is actual like url we also have information like the image so i can click on image and you'll see that the image is right there so all this information is important to us so uh what we would like to do is in our data model define fields for the description the image and all these things so that's what we've done here we have the external url we have the image we have the name we have all this this information and we want to make this queryable meaning that we can hit an api endpoint and we can say give me all the tokens and then i might want to do stuff like i want to search for tokens that have a description that matches this or i might want to do some full text search that contains this word or i might want to say i want to find all the tokens and all of the owners of those tokens and this is another thing that's pretty powerful about the graph is that we can do relationships between two different data types so right now we have this single data type of token but we're next going to create a type of user so we're going to say type user we're going to give it the entity type this is um important and it's kind of like a directive that's graph specific and if you tag any type with entity this means that we're going to be able to index it and for the for the user type we only want two different fields on there we want the id of the user this is going to be their address this is going to be their ethereum address and our kit in this case and then we also want to define a one-to-many relation relationship between users and tokens that they own so this way we can do bi-directional queries we can say we want to get tokens and their users but we can also say we want to get users in the tokens that they own so you can kind of query either way um and the way that we make this happen is that we add this at drop from directive and this is cool because it allows us to easily model relationships between data so i'm saying derived from the field owner this owner is going to essentially be an address that address is going to allow us to kind of like define the relationship between those two items and the last thing that we want to do is we want to define a full text search field and this is really really powerful because obviously full text search is one of the most you know powerful features that you often interact with on client-side applications it's just super nice to have it just makes the flexibility of building ui is just so much better and and the experience is a lot better so with our um full text search uh directive here at full text search we can define things like um what is the entity that we want to make searchable so in this case the only entity that we're worried about making searchable is the token entity so we're going to say the entity is token the fields is going to be an array of fields within that token so for us we're going to say we want to make the name the description the type and then these horoscope fields of sun moon and rising so this is uh this is going to give us a query called coven search that we can pass text into and get information back which is going to be really nice once we kind of are done with that so that's our graphql schema i'm going to be going a little faster because we have eight minutes left i want to make sure i finish the next thing that we want to do is go back in our subgraph.yaml and what we want to do is we want to update our entities to match our entities defined here so we have a token entity and we have a user entity so we can match that by just saying token user the next thing that we want to do is we want to set a start block and the start block is the indexer is going to go to the contract address and it's going to start looking for transactions so if we give it the first transaction to look for it can kind of know where to start as opposed to starting at the very beginning of the of the ethereum network right so to do that we can just look for the start block on etherscan there's also a new a new tool that that someone from the community created just this week um let's see find it yeah so it's start block dot versus dot versus cell dot app so i can like paste in a contract address so let's go ahead and try this out i guess um we can paste in this contract address whoops and then this should give us the start block and let's see if that matches the one i have yep that's right cool so the start block that burcell you know gives you the star block or you can go to ether scan either way so i'm going to set the start block and then the the last thing that we want to do is is define the event handler now um the way that we index data from these networks is that we look for some way to identify some state update within the contract and then when a state update happens then we know that there is some information that we can use to kind of like understand what's happening within that state update typically like a function call or something and we can take that data and we can do whatever we'd like with it now there are a few different ways to listen to different state updates but the the most important and i would say the most popular is an event so when someone emits an event then that means that we can like listen for that event and um and we can do stuff with that data so like if someone updates some state within the contract they might emit an event and i guess in theory you don't even have to kind of make a state update you could just actually emit an event so either way as long as an event is emitted we want to be able to listen to that now in erc 721 you have this transfer event which is really really powerful because it's called when a token is minted it's called when a token is sold and it's also called when a token is just transferred from one party to the other so just with this single transfer event we should be able to get almost all the information that we need about every token and keep up with the updates as they happen so this this transfer event is what we're going to listen to and then we want to call a handler function so this means when this event is fired we want to call a function within our subgraph so we have this handle transfer function and this is where we're going to write our business logic and if i go to src mapping this is where we're going to have a handle transfer function here so i can go and just delete everything else and um i'm actually going to delete all this stuff and the only thing that we're going to work with this handle transfer and um to work is more easily with both from within the subgraph we want to talk to the ethereum network like we would from a front end maybe using ethers.js or web3.js the graph typescript library offers some helper functions but even more specifically to that we can actually use the abi that we have for this contract along with the library that we provide together to give you a nice interface to talk to the smart contract to read the contract so to get that code we can actually just generate it from the cli by running graph cogen and this will look at your graphql schema as well as your subgraph.yml and generate some code that's going to be showing up right here in this generated folder so what we're going to do next is you know go down here i'm going to go ahead and import some imports we have an ipfs and json helpers from the graph typescript library we have apis that allow us to interact with the the smart contract itself as well as like an event for type safety and then we also have a couple of apis that allow us to interact with the graph node and you can think of the graph node as the database where we're storing this information so the functions that we'll call are things like token dot save or user.save and things like that now this is the business logic of what's going on um and i'm getting close to being out of time so i'm going to probably not walk through all of this but i will hopefully walk through a bit of it just to kind of give you an idea what's going on so i don't need all that code actually i just need this much here so um we have the ipfs hash hard coded here now you can also read this ipfs hash from the contract obviously but um if someone's updated the ipfs hash maybe some metadata has been updated and therefore it might fail so like you have to consider do you want to read it from the contract or you just want to hard code it here in this case i've hard coded it the handle transfer event is again the only function that's going to be firing that we want to listen to and we have to think of like two scenarios here what we want to do is we want to think okay if this token has already been saved in the graph database then we know that we've already kind of set a few different properties on that but if it has not then we want to go ahead and set a few basic properties so like there's two main pieces of like i would say there's two main cases here the token has been created or it has not been created so if the token has not been created what we're doing in this code here is we're essentially just like creating the token and the token is going to need to adhere to this schema here so we need to go ahead and whoops need to go ahead and set all these different fields so we're going to set the id the token uri ipfs uri and we're doing that all within this mapping and essentially what's going on here is like we're getting this event the event has the token id it has the user that's transferring it from and the user that's transferring it to and then using those three pieces of information we can get all the other information that we need how do we do that well all we need to do is know this ipfs hash to call out to ipfs append the token id and then we get that metadata by calling the ipfs api here and like getting that so like i'm not going to go through all this just because of timing and stuff but really all we're doing here is we're calling ipfs like you could think of it as just like fetching that that metadata from ipfs and we're saving that to the the token object and then we're saving the token uh here to the store and then we also are doing the same thing with the user if the user doesn't exist we go ahead and create the user uh the user only has a token id um associated with it so um with all that being said we're now ready to deploy and then we'll be done so what we're going to do to deploy is we're going to run graph off and graph auth will authenticate our cli and it's going to ask us subgraph studio hosted service so we're going to choose hosted service it's going to ask us for our deploy key i'm going to go here to my dashboard and i'm going to copy this access token and then i'm going to run yarn deploy and this will go ahead and deploy our api and then we should be able to test it out now after you've if you've like compromised your access token you can actually go to dashboard and refresh it to get a new one so don't worry about that but um we're going to wait a couple seconds and then once this build is complete and it's deployed we should be able to refresh and see that we have our api syncing that means our api is now starting to be indexed so all of the data that we defined is starting to be indexed and we can actually start querying it so we have a query playground here so we can go ahead and say okay i want to get the tokens and uh these are the fields that i want returned um we can actually go here on the right-hand side and see that we have this graphical i'm sorry it's um schema introspection editor or viewer where we can say we want to get the image the description name external url we are that so whatever we want to get and um now whoops when we run that we should see that and then we can do stuff like click on the image or open the image up and see that we have crypto coven showing up the external url should have all the metadata or not the metadata but it should show you like something like that um all that stuff is there and then the last thing that i'm going to show off is the full text search because the full text search is pretty cool so we we defined this this field called coven search so i can um use that to search for any text so maybe i want to say chaos or something like that then you'll see that like anything with the word chaos comes back um if i want to look for the word acta you'll see that anyone with the name octa comes back so we have a full text search we can return any information that we want we deployed all this and we indexed it all within less than 30 minutes so that's pretty cool if you wanted to build out your own indexer from scratch it's typically a very very resource intensive process people i've known have spent weeks or even months building out their own indexer so um this was a fairly short demonstration um i did have to run through things fairly quickly to kind of like get to the end we did still go over on time but i appreciate everyone's patience today if you want to learn how to build on the graph i would check out the docs i would check out our youtube channel where we have a bunch of tutorials and stuff and i would check out this exact workshop thanks awesome thank you so much nader uh that was super interesting and i'm sure everyone on this call and who has been watching on youtube have learned a lot um so once again thank you so much for taking um some time out of your day to do this for all the dow hacks hackers um for the rest of you we do have some workshops left for the rest of the day so hope to see you all there and with that being said i hope you all have a great rest of your thursday or friday depending on where you are 