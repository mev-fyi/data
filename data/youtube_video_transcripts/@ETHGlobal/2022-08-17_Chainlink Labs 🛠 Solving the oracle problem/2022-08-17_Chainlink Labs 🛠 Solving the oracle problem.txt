[Applause] [Music] hi i'm richard one of the developer advocates at chain link labs and today we're going to take a look at what is chain link and what are a few of the products that chain link offers so let's dive in all right so first question what is chain link in order to understand that we need to make sure that we have a base understanding of a couple of concepts the first of which is what exactly are smart contracts and what's the purpose of them a basic definition is that a smart contract is a digital contract it's stored on a blockchain it automatically executes when certain parameters are met now why are they important well they're important for two main reasons in my opinion first they're transparent that means anyone can see what the terms of the contract are and they enable you to know exactly what's going to happen when those conditions are met additionally they're distributed combined with transparency the fact that they're distributed means that you remove trust from the situation in a traditional world contracts rely on a third party and they rely on trust that the parties involved in the contract are going to do what they say and honor the terms of the contract even when legal systems are fairly robust this isn't a guarantee it's a almost always most likely things will work out type of promise and that is something that smart contracts can remove smart contracts replace that third party they replace the trust no longer do you have a trust-based system of agreements now you have a system of agreements which allows users to rely on cryptographic truth so we have a truth-based agreement system instead of a trust-based one so that's why smart contracts are so important and so powerful that transparency the removal of trust being necessary for them to function and the distributed nature of them now in order for smart contracts to work they live on a blockchain and blockchains rely on the different nodes within the chain reaching something called consensus what about consensus how do we reach an agreement within a network of nodes for certain values let's take a look at a simple example what's one plus one we can all agree that one plus one is two it doesn't matter when i ask you that question it doesn't matter where you are when i ask you that question it doesn't matter about any other input into the system one plus one is two this is a deterministic value and blockchains work exceptionally well in fact they rely on deterministic values to reach consensus if you think about us as a network when you ask me what oneplus one is i'll tell you two and when i ask you the same question you'll give me that same answer that means we can reach consensus we could come to an agreement on what the answer is we all agree that it's two now what if i were to ask you a little bit different style of question what's the current temperature it depends i mean it depends on where you are when i ask you this question there are other factors that determine the answer to that question that's a non-deterministic value any time that you can ask a question and the answer could be it depends you know that it's a non-deterministic value and the real world is full of non-deterministic values in fact pretty much everything in the real world when it comes to data is non-deterministic it's going to depend a lot this brings me back to smart contracts they have phenomenal power much like genie phenomenal cosmic power but deterministic values mean much like genie itty-bitty living space right they're confined to blockchains traditionally smart contracts can't reach out to the outside world that's referred to as the oracle problem now this isn't a limitation that we can't overcome right we can do something about that we can help our smart contracts interact with the real world and oracles are a solution to the oracle problem and that's exactly what chain link is it's an oracle network in fact it's a distributed oracle network so just to make sure that we're all clear and oracle is a device that interacts with off-chain data to provide that data to smart contracts essentially this unlocks the full potential of smart contracts now you may be wondering could i set up my own oracle the answer to that question is yes you could set up your own oracle and it would work you could bring off chain data on chain and you could you could own that but i see that as a bit of a limitation because if you notice we have a decentralized network that is the blockchain and now you're effectively centralizing it with a centralized node for your oracle if something were to happen to that node or if that node were to be a bad actor well you're kind of in trouble because you have centralized that and that again is what chain link offers it offers a decentralized oracle network so the oracle network that chain link offers is much like the network of a blockchain where there are multiple nodes participating but they are participating in a decentralized fashion so there's three main things that we're going to talk about today when it comes to what chain link offers the first is data feeds next is vrf or verifiable randomness functions and the third is keepers so let's take a look at each of these and walk through a quick demo of how to use them we'll start with data feeds data feeds as the name implies are about bringing data on chain feeding that data into a blockchain and what does this data look like it can be any data it could be market data bank payments retail payments it could be anything that's available via an api the most common use case that we see are asset pairs so let's take a look at data.chain.link and what this looks like in practice if you head to data.chain.link you'll see various data feeds i mentioned that these are asset pairs and if you take a look here the first one you'll see is eth in terms of usd let's dive into that one what we have on this page is the trusted answer that's going to be the aggregated response from various oracles on the right side of the screen you can see all of the different oracles and the price that they're reporting there's a few things to look at on this screen the first is that trusted answer that's going to be the aggregate answer based upon all of the different values reported by the oracles this is how you can overcome the issue of bringing non-deterministic value into a deterministic landscape like the blockchain each node reports the price that it thinks is the proper answer to the question of what is the value of eth in terms of usd for this data feed we take those prices and we use the median value to bring the data that is non-deterministic into a deterministic answer given various inputs when taking the median you now have created a deterministic question given a set of inputs what is the median value that will always come out with the same answer this is how you've taken a non-deterministic value and brought it into the blockchain and made it deterministic on the left hand side we can see that trusted answer as well as the trigger parameters those are going to be what causes this price to update on chain so if the price deviates outside of the threshold that's set or if the heartbeat comes up that will be just a time-based trigger if we scroll down on this page we can find more information about this including the history as well as more information on each oracle node and the data that it's reporting at the bottom we'll find the users of this data feed these are the people who are invested in keeping this data feed accurate and up to date let's head back and talk about the next product verifiable randomness functions now you may have gone through a course or learned about how to get a random number on the blockchain using some sort of seed like the block hash this works to create a fairly random number but there's a small issue with that and the issue is that those values can be known before they're mined onto the block what that means is that a malicious actor who is adding blocks to a blockchain can know the outcome of that random number ahead of time and based on that they can decide whether or not to add that specific random number to the block that they're mining essentially i like to think about this as if you were rolling a dice and you can't necessarily determine what value is going to be rolled when you rolled it it's still random but a malicious actor could essentially re-roll that dice until they get the outcome that they would like that's an issue especially when you need random numbers that are verifiably random that's where chain link comes in chain link will provide a verifiably random number from the oracle network to a smart contract and this prevents the miners from being able to act in that malicious fashion additionally i mentioned that it was verifiably random there's a cryptographic proof included with the random number that will demonstrate how that number was generated next let's take a look at keepers chain link keepers are a way to automate smart contracts we talked earlier about how smart contracts are like genie from aladdin and one other factor about smart contracts is they are exceptionally lazy they're not going to do anything without an input something needs to call a function within a smart contract in order for it to execute that's where keepers comes in keepers will allow you to take a smart contract and based upon either time based or a custom function execute the code within that smart contract now again you could create your own node that would call smart contracts much in the same way as you could use your own node to get a piece of information off-chain on-chain but the keepers network again brings that decentralized network where you have again the benefit of decentralization and you can ensure that your contract will be executed in the same fashion now let's dive in to some code and take a look at each of these products a little bit more closely and see how you'd actually use them in a smart contract so the first thing to know is that when it comes to examples and code with chain link you're going to want to go to docs.chain this is the best place to start when it comes to finding up-to-date information as well as examples we'll start with data feeds if we head down here we can see that the supported blockchains is broken up into two different areas the first being evm chains the second being solana solana is separate because it's kind of a different beast if you've ever used any of the programming tools around the solana ecosystem you'll know they are much different than solidity so that's why it's broken off into its own space let's start with data feeds if we head to data feeds we can learn about data feeds and we can learn about using data feeds that's where we'll head using data feeds right here on this page you can see an example contract and this contract will allow you to get the price feed for eth in terms of usd let's go ahead and open this in remix now if you're not familiar remix is a web-based ide for solidity this means that we can both deploy and interact with contracts on blockchains it's pretty great and you can do it all from your browser let's take a look at this contract and see what exactly we're doing the first thing you'll notice is that we're declaring the solidity version then we're importing a contract called aggregator v3 interface that's going to give us the interface to the price feed aggregator contract we have our contract called price consumer v3 on line 8 you can see that we are setting up a price feed that is one of those aggregator interfaces there's some notes talking about what network we're going to be using as well as what the aggregator is and an address something to keep in mind each asset pair aggregator has its own address you can find those in the documentation i'll show you that in just a moment we have our constructor which goes ahead and sets up the price feed and keep in mind constructors are only run when a contract is deployed they kind of set up things that need to be configured when that contract is deployed and finally we have our function get latest price it's going to return one value the price now this looks a little strange we have all of these commented out values and the reason for that is within solidity you need to account for every single value that a function returns this latest round data function will actually return a round id the price when the round started a time stamp and what round it was answered in but we're only interested in the price so you can either comment them out or just delete them completely it looks a little strange because essentially the signature for this function would be comma into price comma comma comma again those are commented out there just for readability and understandability of this example contract finally we take that price and we return it that's it it's a pretty straightforward and simple contract but let's take a look at how to deploy it if we head on over here to the deploy and run transactions we'll need to ensure that our environment is our injected provider that will take the wallet from your browser and inject it into remix so that you can interact with the blockchain in this example i'm using brave and i'm also using the brave wallet but it functions basically the same as metamask we'll also need to select the correct contract anytime you have a contract that imports other contracts they will be available here to be deployed so just keep that in mind to make sure that you're selecting the correct contract and finally we can click deploy we'll need to approve the transaction and wait for it to actually be deployed we should see a green check mark down at the bottom of our screen once it is deployed all right we've got that green check mark and we can see on the left-hand side we have our deployed contract if we open that up we can see all of the functions that were deployed within our contract now we only have one it's get latest price let's see what it returns when we click it we can see that we get this price and this price seems like it may be a bit out of line with the current price of eth but there's something to remember when it comes to pricing data solidity doesn't have the concept of decimals that means that we need to somehow account for decimals and the way that we do this is by multiplying a result by 10 to the eighth power in this case so we'll need to insert our decimal to understand what this price actually is if we were to go one two three four five six seven eight places and insert a decimal point there we would see that the price returned is actually 1917. so just like that we have gotten a price data from an off chain resource on chain that's awesome and i think it was pretty simple and pretty quick next we're going to take a look at vrf or verifiable randomness functions let's go ahead and take a look at that now again we'll start at the documentation page so docs.chain.link if we scroll down we'll go to randomness or vrf now here again we can learn about how to use randomness how chainlink vrf works but i'm jumping straight into get a random number for this one we're going to need another asset not only would we need test net eth but we'll also need testnet link tokens this will allow us to create a subscription that we can fund in order to get our random values so if we follow the instructions here we can open our wallet and make sure that we are on the go early test network i am we can then go to the go early faucet and get some test net link or eth if we need them and then we can go to the subscription manager now subscription essentially the way i like to think about it is it's a bucket of link that we can allow other contracts to use so we'll create a subscription it will autofill our address if we've connected our wallets you may have been prompted to connect your wallet when you came to this page the first time we'll create our subscription and we'll need to approve that subscription once that's approved and verified then we can go and fund our subscription and while we're waiting for this to approve something to keep in mind is the way that subscriptions work is we need to create a subscription we'll get a subscription id then we'll create our contract to interact with that subscription and when we deploy it we'll let our contract know about the subscription id once we have deployed our contract we'll come back to our subscription and let our subscription know about the address of the contract we've created essentially we need to let the contract know about the subscription and let the subscription know about the contract alright so we've got our subscription created and now we can add funds to it i'll go ahead and just add five link again we'll need to approve this transaction as well while we wait for this to happen let's head back to the documentation and take a look at what we need to do next we've gone ahead and created our subscription we've added funds after we add funds we'll need to add that consumer that's going to be the address of the contract that we deploy but we haven't deployed a contract yet let's scroll down and see if we can find an example create and deploy a vrf v2 compatible contract fantastic we'll go ahead and open this contract in remix and take a look at what it does so again kind of similar to the other contract we're declaring the version of solidity to use and we're importing a couple of contracts from chain link the first is a coordinator that will allow us to request that randomness value and then we have a consumer that's going to be helping us here in this contract go ahead and consume the values returned from the coordinator we see that our contract here is using that consumer base v2 we set up the coordinator interface we have a few values here we have a subscription id that will be that subscription that we just created we have the address for the coordinator one thing to keep in mind this address again will change based on the chain that you're on at the end of this demo i'll go ahead and show you where you can find these different addresses we have a key hash the key hash is also going to be dependent upon the network you're on we have a callback gas limit this limit is going to be the maximum amount of gas that the fulfill random words will be allowed to use depending on what your fulfill random words function does will determine how much you need to set this to for the example this will work just fine we have a request confirmation that's how many blocks need to be confirmed before the request is sent back to us number of words in this instance it's two that means we'll get two random values back now words is a computer science term that is technically correct but sometimes i think it can be confusing to people when they first come to these contracts when we're talking about vrf and you see words just think random values we have an array to store the random values returned we have a value to keep track of our request id we don't really do much with it in the example here but if you had multiple calls for different things being made you could map a request id to a specific thing take for instance nfts if you are using random values with an nft you may want to map the nft id to the request id to keep track of which request is for which nft and then we also have the owner of the contract we have our constructor which remember constructors are run when the contract is deployed this constructor takes the value in we'll need to supply our subscription id then we set up the coordinator the owner and we also set that subscription id to what we passed in next we have our request random words function this function essentially reaches out to that vrf coordinator and says hey i'd like some random values please and it passes in all the information that we've said above like the key hash the subscription id the number of confirmations the gas limit and the number of words that we're looking for once that coordinator actually generates the random values it will then come back to our contract and call the fulfill random words function this is where you would use those random values in this case we're just storing them but if you wanted to do something with the random values you'd put that in here and finally we have a only owner modifier just to make sure that only the owner can request random words all right so let's take a look at deploying this again make sure your environment is correct as well as your contract you'll notice this contract it needs a value it needs that subscription id so let's head back to the create subscription and grab that subscription it's asking us for a consumer address that's going to be the address of the contract that we're about to deploy but our subscription id for this example is 101 now when you create a subscription your id will be different well back here we'll give 101 to our deploy and we'll go ahead and run this transaction confirm it and we'll wait for that green check mark that means that our contract has been deployed successfully while we wait let's go ahead and take a look at where you would find the different values for the different chains i mentioned in data feeds that we could take a look at that as well here under data feeds in our documentation you can see contract addresses and all the different chains on which we have data feeds you can see each of the chains and the asset pair as well as the address that you would need to provide similarly under using randomness for vrf we have a contract addresses section as well this will include the coordinator the link token some different hashes depending on which gas lane you would want to use if you're on a main net there's multiple gas lanes most of the test nets just have one gas lane but you can find the different information that you need for different networks here in the documentation all right we should be deployed and we are fantastic there's a couple things to look at once we have given our contract address back to our subscription so we'll copy our contract address this is the contract that we just deployed and we'll put it here as a consumer again we'll need to approve this transaction and once this is approved we can go and actually look at our subscription it'll have some interesting information like the history what our current link balance is how much each consumer has used of that balance and information like that all right our consumer has been added let's go ahead and view our subscription so as i mentioned here you can see all of the information about the subscription and let's go ahead and call our subscription here so we'll request random words we'll approve this transaction and once it's been successfully submitted we should be able to see it in our subscription all right it's been submitted before we head to our subscription we can take a look and we can see our request id cool let's head to the subscription and refresh this page and take a look at what it says now so you can see we have this pending transaction that means that we are requesting randomness but it hasn't been fulfilled yet remember we have to wait for those block confirmations the amount of time that this takes can vary depending on which blockchain you're on how fast blocks are mined as well as how many confirmations you're requesting confirmations you can increase the number and end up with a more secure random number but the trade-off is speed so more secure but slower or a little bit less secure but faster again it's a verifiably random number so you can trust that it's random when it comes in all right so we refresh the page and we can see now our history no longer is it pending we have our randomness and we can see that we've gotten a response back in our subscription page we can see how much link it cost and we can see that you know our one consumer has spent that same amount one nice thing about this subscription interface is you could add another contract from the same subscription and have two consumers or more using that one source of link if we head back to our contract in remix we can now take a look at the random words something to keep in mind this is an array so it's going to have two values because that's how many requested in this contract arrays work with a zero based indexing system so the first value would be zero the second would be one so if we look at the first value zero we can get the result of a random number again if we take a look at number 1 which would be the second value in the array we'll see that it's a different random number so just like that we've set up a subscription and deployed a contract to generate proven random numbers in solidity that's awesome let's head to the final thing chain link keepers all right as always we're gonna head to docs.chain.link as our place to start and then we'll head to automate contracts because that's what we want to do we want to automate a contract with chain link keepers now when it comes to contract automation keepers version 1.2 just came out and there are two ways to automate contracts now the first is time based if you're familiar with operating systems that are linux based you may be familiar with a command called cron cron is essentially a time-based triggering system for linux unix systems chainlink keepers uses the same sort of interface to generate the time-based automations if you're not familiar with what a crontab looks like or how to set up a crontab i recommend a website crontab.guru it will take you through everything you need to know and explain what the different values in a cron tab are we can take a quick look at it now this website will let you pick random crontab values and it puts them in what is essentially plain english at the top cron tab is broken down into five different sections it's going to be the minutes the hour the day the month and then the day of the week the first day being the date of the month this is a great resource if you'd like to look into it more but just something i've found helpful when it comes to ensuring that a cron tab i create is doing what i think it's doing but let's head back to the documentation we're going to take a look at time-based automation first and then we will take a look at custom logic and we will do the same thing in both of them and what we're going to do is we're going to deploy a contract that has one value a counter and it will increment that counter on a regular basis so the first thing we need to do is we need to head to keepers.chain.link again this is going to be similar to vrf in that we'll need to create a new upkeep similar to vr subscriptions but slightly different so let's register a new upkeep and i mentioned that we're going to do time based now we're running into the first problem we need a contract so let's head to remix so it's remix.ethereum.org and we will create our own smart contract we'll just call it count.soul all right what do we need for our basic smart contract the first thing we'll need to do is tell it what version of solidity we need and we can just kind of follow along with the same values that we've been using we also need to name our contract we'll call it counter and within counter we can create a value a uint called counter and we can make this counter be public that means anyone can access it outside we'll need our constructor and we don't actually need to do anything in our constructor here so we'll just have it other than set counter equal to zero so when this contract is deployed we'll set our counter equal to zero and then we can create a function and we can call it count it'll take nothing in and what it will do is it will say counter equals counter plus one this will allow us to increment our counter now this function we're going to need to call it from outside of our contract so it will be external that means that we can call it from outside but not inside and that's it this is our entire contract it looks like i'm missing a semicolon up here make sure you have your semicolons and yeah we've got our contract so let's go ahead and deploy this contract again we'll make sure that we inject and we pick the right one and we'll go ahead and deploy now when this is deployed we can then have the address and give that to our new upkeep that we're creating that upkeep is going to need to be informed what can actually be done with our contract if you verify a contract on the block explorer of that network the keeper interface can go ahead and read that information in this contract's not verified we'll copy the address of it and we'll come here and we'll take a look at what we need to do next it couldn't fetch the abi because the contract's not verified so we'll need to provide the abi that's the application binary interface essentially it lets other programs know what can we do with this contract where do we find the abi in remix right here under our compiler we can make sure that we pick the correct contract and then there's this abi button right here when you click it it will copy the api to your clipboard so we'll head back and paste it in we can see it gives it some information about what the inputs are and what the different functions are and we can do next now that we provided the api the keepers interface is aware of what functions there are available in our contract this is a pretty simple contract it has one function so we'll select that function and click next here's where cron comes in so this cron will give us some things that we can do like you know every 15 minutes every hour the first of every month we'll pick every 15 minutes to start with and then we'll change it to be maybe a little bit faster so we'll say every minute we want this keeper to execute so every minute we should see an increase in our counter we'll name this upkeep we'll say count we'll give it a gas limit and we can go ahead and just go with the default here again this is going to be a limit based upon the amount of gas that your function needs we do ask for an email address this is to provide information based on your upkeep if you have an issue like you're running out of link or something like that and we can register our upkeep again this will take some confirmations from your wallets and it will also transfer some link from your wallet to your keeper this does take two confirmations and once they have been confirmed our upkeep should be ready to go all right our upkeep has been registered let's take a look at it we can see here all of the history and all the information as well as a projected time of next execution this one's pretty straightforward because it's running every minute once our upkeep has run we should see that our counter has increased now while we're waiting for this upkeep to run let's head back to the documentation and take a look at custom logic again we'll need to register a new upkeep and we'll need to have a contract that is deployed that's a keeper compatible contract so if we look at creating a keeper compatible contract it requires two things the first of which is a check upkeep function that will return a boolean as well as possibly some data that lets us know if we need to actually perform upkeep and that tells us what the second function is it's perform upkeep so with a check upkeep function and a perform upkeep function we have a keepers compatible contract now there are example contracts here and we can scroll down and see one this contract essentially does the exact same thing as our other contract but it's a little bit more involved because we are using that custom logic so let's open this example in remix and take a look at it as well so again we have our solidity version and we import keeper compatible interface we set up our contract named counter and we create our public value of counter we create two other variables as well the first is an interval that's going to be how often we want this to run in this case remember we're doing the same functionality but we're using custom logic instead of strictly time based logic we keep track of the last time stamp that's going to be the block dot time stamp in our constructor we'll pass in the interval in seconds of how often we want to update this and we'll set our last time stamp to the current blocks timestamp as well as setting our counter to zero we then dive into two functions the first is check upkeep which takes in some call data as well as providing the upkeep needed and the perform data if we have it in this example we're just passing back upkeep needed that boolean value true false so upkeep needed will be determined by looking at the block.timest subtracting the last time that we did something the first time this runs that'll be when the contract was created but as we'll see in perform upkeep it could be the last time that we had performed upkeep and seeing if those two time variances are greater than the interval if it is that value is going to be true and we need to perform upkeep so what does perform upkeep do again it takes in that form data and it checks once more to ensure that we actually need to do our upkeep and it's important to do this because you always want to make sure before you make a change on chain that you are actually needing to do it so we check again that block timestamp minus the last time stamp is that greater than our interval if it is we'll update the last timestamp and we'll add one to the counter it's doing the exact same thing it's a little bit more involved because this perform upkeep and check upkeep methods allow you to have any validation that you need to check if you actually need upkeep you could look at things like pricing wallet balances essentially the sky's the limit when it comes to what you can do with custom upkeep functions so before we dive into adding this to a keeper let's deploy it first same thing that we've been doing this whole time injected and we'll make sure that we pick the correct one here we'll send it an interval we'll say 60 seconds and click deploy we'll confirm this and while we're waiting for this to deploy we'll head back to our other time-based keeper if we head here and refresh our keeper details we can see that hey it's actually run twice while we've been waiting so if we look at our contract that has been deployed and we take a look here at what our counter is set to you can see our counter has now changed to two so this contract is incrementing itself automatically on a time based interval of one minute roughly again the time based intervals of very low values like that can be less than perfectly accurate just because we're requiring a block to be mined when we check so depending on what chain you're on that could be a little bit tricky when it comes to very small time based values just something to keep in mind all right so this counter is working on a time-based interval that's amazing we'll go ahead and close this down just to keep things simple and we'll head back here our contract is deployed now so we'll copy this contract and we'll head back to creating a keeper so where do we need to go we need to go to keepers dot chain dot link all right and we'll register a new upkeep here and this time we'll pick custom logic we'll enter the address of the contract we just deployed and it'll try to verify it as well if our contract was verified it would be able to ensure that it was a keeper compatible contract because we haven't verified it we can still deploy this keeper but it's relying on us now to make sure that the keeper contract is a keeper compatible contract we'll provide a name again so we'll just say count two we'll give it a gas limit and we'll go ahead and give it the same one we gave it before we'll give it some link to start with we don't need any check data but we do need an address and we can register our upkeep once this has been confirmed we should see upkeep kick off pretty quickly i often get questions about upkeep and how can we ensure that someone doesn't call perform upkeep other than the keeper in my mind one thing to keep in note is best practice is why wouldn't you want someone else to call perform upkeep that's going to be the function that costs gas if someone else wants to pay my utility bill for me awesome let them do it but make sure that you have your perform upkeep set up in a way that it will not be a problem if someone else calls it or if it's called repeatedly that is why in this example we are checking again to make sure that upkeep needs to be run it's always good to make sure that that one only runs when it's actually needed so just something to keep in mind but locking that down so that only the keepers network call it i think that that's not something to worry about you should focus on it from a how do i make sure that no matter who calls this it only actually does what i want it to do we head back here we can see that our upkeep has been registered we go ahead and view our upkeep we can see here we've funded it we've created it we'll need to wait for it to actually run all right we refresh the page and we can see hey look it actually did run and we performed our upkeep fantastic let's head back to our contract and take a look if we open up our contract and we check the counter hey our counter is one we have an increment encounter again in this case it's based on time but using custom logic that we defined not just strictly based on a cron tab and this really opens up the opportunity for automating anything that you can come up with so that is some of the products that chain link has to offer i really appreciate you taking the time to walk through this and if you have any questions feel free to reach out you can find me on twitter i'll put my twitter handle right here and yeah have fun building i look forward to hearing from you and seeing what awesome projects you come up with 