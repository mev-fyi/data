go ahead for sure how does that look Emily um cool Twitter's app yeah there we go yeah so good awesome we're gonna get started welcome everybody who signed up for this session hopefully you're in the right place we have with a Scott Bigelow how do you pronounce that yep you got it perfect Scott's gonna be going through some of the techniques to discover solidity vulnerabilities and we're super excited that he's gonna be sharing some of that expertise with us Scott if you want to just start off by giving a little bit intro to your background before aetherium how you got into the space and what you're doing now sure thank awesome thanks for the introduction yeah so my name is Scott Bigelow and I'm currently working with the etherium foundation on something we're calling the spot check program where currently it's just myself and it's a program to provide resources to projects that are that are have either shipped or are about to ship to provide some high-level security auditing and guidance services there is a lot of projects that are that are nearing completion debts this could be the first aetherium project that they're shipping and so we're providing just a little bit of guidance on some of the best practices before they had made that because I think we all know once you hit main that with your contracts these these issues are really difficult to recover from you know either we're acquiring like redeploys and migration or you know maybe there could be some loss and so whatever we can do to provide something before they get to that immutable point it usually has a really big benefit for these projects sure now we haven't actually fully published this thing unlike a blog post or anything we do have a mission statement here yeah but really it's projects can get this sort of feedback and guidance and we'll also be scanning the blockchain and proactively looking for issues in smart contracts that are usually that hold funds and are vulnerable and we can figure out who's smart contract they are so there's really two sides of it there's the product of monitoring and then be kind of consulting services but for this I've been working in aetherium for for a few years now probably since about maybe early 2017 I worked on augur shipping augur v1 I worked again for another company called amber data which was a which is a blockchain Explorer they provide a lot of really nice data for an API but yeah I just really found myself drawn into the etherium space and really the security aspects of it because there's just so much on the stake you know every single block is a bug bounty that is being declined you know for anything that is that is wrong out there and what we can do to help projects before those bug bounties get cashed in by you know by blackhat is it just it just makes the ecosystem just a lot more positive place to work it so should I just go into it then yeah that's a great summary of what you've done what you're doing now do you want to just give a quick outline of how you're organizing the session when you'll be taking questions sure I think organizing might be overstating it yeah so this is a I'm hoping to have a pretty informal session here I have a bunch of stuff I would like to to run through and talk about but I'm really hoping for four questions you know in the middle I'd like to to know when we're talking about things that are interesting and maybe things that that aren't it's hard to know you know who to target in in this but yeah if you could please just like like chime in and and and engage about these topics that are interesting or weak we could take them in a different direction I'd be very open to that so so please please if you don't ask questions we're gonna be sitting here all looking at each other awkwardly in about 20 minutes so if you could save me from that it would be it would be a huge favor all right so let's let's talk about aetherium security one resource that I like to use here is this swc registry there is a kind of an outline it's a little bit technical in in the way that these things are written up but it's it's a fairly decent resource for all of the types of ways that smart contracts that we found smart contracts can have problems they all have these identifications you can kind of talk about them whenever using auditing tools they'll be like oh you know you've got a you've got an SW c-135 here but it's it's it's kind of helpful to kind of have these identifiers for these things and they have pretty good you know a pretty good description sort here I really like the cast test cases they have for these you can go down and look at some codes and for some examples of ways in which these these smart contracts are secure or insecure and then they'll look they'll show you a way that it is vulnerable and they'll show you a way that they were able to fix it the problem with this list is that it is very long and so unless you are doing aetherium security work all day every day I you know where do you start how do you go from looking at this list of you know technical definitions of ways that smart contracts are you know can be vulnerable to actually improving your own code to avoid some of the most common pitfalls of of smart contract development and one of the ways that I would like to promote here is I'd like to really just call out a couple of these methods and talk about ways that we can look at our code to to avoid those specific issues and so I actually have a list here and it is just take out here just five so of these around what is this maybe like 50 and the other yeah 36 there are there's not five that I think are really really important to talk about and when I am doing my audits of projects that are about to be released literally every single one of them has been be one of these five issues not to say that these other issues don't happen but a lot of times they are it's just around something that people don't really do anymore or it means that you're doing something crazy like going into what they call solidity assembly where you're writing these really really low-level codes or sometimes it's a honey pot where these these are these are vulnerabilities that people intentionally put into their code some of these are you know people will try to to create these like tricky smart contracts that would you think revolver bowl but art and many of these are for watching out for nefarious authors and assuming that's a theory and project creators are not nefarious a lot of these aren't actually going to apply two ways that you can practically improve the security of your code so let's let's start with one of these this is one that I've been seeing a whole lot it is call and so SW c106 we have unprotected self destruct instruction I think many of you might if you've been around the space for a little bit longer you might recognize it better as this one we do so first of all I mean do people does my first interactive point are people familiar with this the parody multi-sig self-destruct that occurred a couple few years ago yes it's pretty famous pretty infamous love it feel free to unmute people if you should shine man or ask a question yeah please right so so what I find really interesting about this is that this happened like what is this late 2017 this is this parody multi-sig hack like literally everybody knew about it but the problem is that so many people knew about it that we don't really talk about it anymore and so I have been working with projects in the last couple of years that have fallen prey or have created code there's vulnerable to this specific thing but because it's so ingrained into the people who were around in late 2017 we don't talk about it anymore and then people who join in 2019 they don't know about this right because it's so obvious that it's hidden and there's many projects are vulnerable to this issue in in in kind of new and novel ways but it's still the same underlying issue and issues related to let's call this or is it this one so many projects nowadays are coming up are deploying with something called an admin proxy where they'll deploy a contract where they can later turn around and say like hey I know this contract usually runs this code but now this contract is gonna run this code over here our familiarity look familiar with the admin proxy system or should I talk about that more I'm good with that good with it like you got it you understand everyone knows we're talking about here yeah yeah it's mostly too delicate call that that performs that thing right it's exactly right right so it's a delicate call but but the owner gets to come along and say hey I know you're delegating over here but now I want to delegate over here basically and sorry basically you can arbitrary update implementation that correct and it's a hundred percent right right and so you know normally when you run a smart contract you are you're looking at it like this right it's like I deploy this thing this code it's ad libs of this address and it has this storage when you run an admin proxy instead you use your storage but reference somebody else's code through a delegate right so you're like well the only thing the code here does is delegate to this other code you still write to your own storage but the code over here is the one that gets executed right now what what many people forget and this is what they forgot when they had this whole parity multi se thing is that this over here this one that you're delegating to itself is a contract you know with its own storage with you know with its own ability to self execute and if this thing contains a self-destruct somebody else could initialize and then self-destruct that called just like it happened with a parity multi-state years ago but one of the things that that we found more common is that let's say that this contract itself instead of having a self-destruct right in it because that's become a little bit rare let's say this code itself has a delegate call in it well an owner anybody can come along and initialize this become the owner of it and then delegate call to something that does a self-destruct right so there's there's another path to self-destruct if you can take over a contract that itself has a delegate call and what we're finding is that people who are using these these admin proxies to - you know reference another contract they've kind of forgot about this thing or they weren't around during this whole parity multi-sig thing and you know we can end up with a situation where they and they've lost this contract because of a delegate call and now their implementation is you know is totally hork now luckily because the hopefully if if it's an admin upgradability proxy you know it's not the end of the world but it could cause some some harm for for the way some of this logic executes and one of the things that I did in response to this it's kind of an aside here maybe it may be I'm sure II think I have this so I wrote this little program here this is more kind of on the that the spot-check side that it basically looks scans the blockchain for things that are delegated to pulls things out of a blacklist sees if the things that are delegated to can perform a self-destruct or a delegate call because either one of these allows the path that allows you to destroy the code and then it also checks to make sure that nobody has initially nobody has initialized the contract to see if to see if maybe there's because there is some B's already initialized and it already has an owner then this thing that gets delegated to is it's kind of safe theoretically it's very good yep we've got one question citing you yes yes yes hi so basically if the source contract is like for example killed okay so in the admin proxy contract be affected because you can also you know point out to another address if there are any set of methods over there yes so like if the source contract is killed on like something crazy happens with it can we also be can also like to like we can absolutely yes right in some points on this yeah so yeah that's that's exactly true if we if we're using this admin upgradability proxy then yeah you could it's like oh somebody just killed my implementation they killed this one over here but because it's an admin upgradability proxy okay well now I can apply a new one now I know that I should I should be the one that initial or I should make sure that it can't be initialized later directly and then I can repoint to it and so long as the implementation there's good then things should be okay now while that while that code was dead some weird things could happen because it's going to do a delegate call to nothing which succeeds right there's nothing wrong with delegating to nothing and then if somebody set like for ether to your actual address the one that actually is the proxy while there was something deleted back here this code likely just accepted for ether and didn't do anything with it they didn't do the things that the user was expecting so there's still some really bad artifacts of that while the code is deleted but if it's an upgradability proxy yeah you you can't fix it so do you think like each and every smartphone right should have setters and setup functions do you know actually provide these functionalities so that like one can upgrade the delegate goals but here's the problem first of all it's this is a very like religious debate because in a way it's like hey look I can fix all my problems but then you know hey look my system comply kind of lacks one of the key features of ethereal and which is you know decentralization from operator control also this vulnerability is created by this lunar ability is able to be fixed they're also created by a user you know a project trying to maintain this upgradability control right it's kind of funny because you to fix that the problem is the solution right yeah the separation of implementation from code allows you know allows you to fix it but also caused this problem in the first place yeah I I kind of I usually I mean I think that this is like training wheels you know this is just me like you know my opinion about this I generally think of when you do this it's kind of like a nice training wheels for like hey we just launched those let's see if it works you know hey there's a problem let's fix it but I think that eventually you know it's really nice to get to this part where it's like this code can't change I can't change I don't need to worry about oh my god these project people didn't handle their private key right and they took everybody's assets like that's just not no not a Superfund post-mortem to write up yeah yeah so usually income when it usually projects do this I'm like hey watch out for this problem also it'd be nice if it didn't do this eventually and I think most projects agree and you can actually go from this to this really easily without redeploying if you just burn your owner Keys region hey I'm gonna transfer mine I'm gonna transfer ownership to zero to the zero address you have effectively done this so there are kind of ways to upgrade yourself later yeah good question good question it uh one other question so this is this is kind of only a vulnerability if one of the contracts has a self destruct coded into it right absolutely right it's self destruct or a delegate because you can always delegate to a self destruct okay delegating to another gotcha gotcha right right yeah exactly so but if it delegates to if it if it delegates hard-coded to a contract that doesn't have a self destruct then that's a good absolutely and I mean unless that contract if there's a dead end in the delegation that's again absolutely absolutely right yeah and so when I have this thing here right so yeah one of the things I look for it's like the so uh in in this code here I I'm able to over a bunch of blocks I'm able to get all the things that are delegated to I have a black list of things that I've already checked are safe I have you have to have a self-destruct or delegate in the delegate recipients call and then I make sure that it doesn't have any storage written that would likely be from an initialization because that means I couldn't come along and initialize it just curious how are you checking for self destruct is that looking for the the opcode in the employed contract yeah yeah it's actually it's pretty simple really so it's just this small little typescript function that iterates through it and the only thing that's weird about about going through byte code byte by byte is that every byte code is you know all these things are like you know like one bite except for pushes like when you do like push 32 the next 32 bites aren't opcodes but they're literals and so the only reason that this isn't just like lurch looking for that code is that I actually have to skip those because it's very common for the self-destruct or delegate opcode to appear in an address that's getting pushed into the stack or like a you know some other literal so you actually have to like skip that stuff yeah it's pretty simple to just go through that cool thanks I was hoping to actually find one because like I usually find about one a week and I'll usually just initialize it and burn it and try to contact them but half the time I can't even figure out whose it is but it's fun to to do that although it's less fun to do it when gas prices are like 30 gray that's less fun yeah guys it's crazy right now oh one quick soon one quick question around that so is that finding code just finding a possible self-destruct because okay because because you're not sure whether you can really reach it or not but it's just existing in the by in the bytecode that correct exactly it gives you the action it gives me a list of things that I can then go and manually look at and and when things show up there this means normally about when things show up in that list there's probably a maybe 10 to 20 percent chance that it's actually exploitable and it was somebody early who said like Oh what if they delegates like a fixed address that's actually really really common that's something that I've been seeing a lot of in contracts and I think it's because they're calling themselves and there's something weird about Cara know there I've been seeing a lot of fixed delegation and so yeah with that again like it's I got well that's a dead end because I can't provide my own delegation destination that just contains a self-destruct opcode so you know one of the things we do here is yeah we just like look for things globally but you know this is this is the case we're like knowing the history of these things and also understanding about the delegate thing is is a little bit new like there's been a bunch of vulnerabilities that have been discovered because of the delegate self-destruct variants of you know of the oops you know anyone I accidentally killed it my notes here yeah so the protection against this is really to make sure that your implementations initialized themselves in their own constructors or whenever you deploy them initialize them yourselves probably the best to do it in the constructors but because implementations are separated from storage a lot of people don't think like oh this isn't this isn't a contract this is just a bunch of functions I'm writing I don't need a constructor without realizing that the Constructors I think would actually save them and prevent anybody from ever harming their contracts kind of want to comment on that so one thing I've been noticing is that on Open Zeppelin it actually says that you shouldn't have a constructor for the upgradability implementation and that's kind of you know misleading for some people that they don't know initialize it and you like at all I don't know that that's yeah [Applause] so that it that is how Jaclyn Lewis does the job right I'd say that again so I think exactly noise does the job by taking the right below you is constructed from this egg like this everything always takes care of all mmm that could be yeah but in general they they just suggest you shouldn't have a constructor for the implementation stuff so most of the people actually well at least most of the project I see don't use Zeppelin OS so yeah yeah actually I didn't know recommend it against it that's very yeah yeah I can I can find it and sanity no no impossible that's very interesting but you know but it basically puts the onus on you to make sure as part of your deployment process that yeah you are you're running whatever initializer you have in there I I think I think there is a possible reason like for for you know like new people that like noobs that don't really understand having constructor in the implementation might get them confused but then as you said yeah I think yeah it's it's just kind of like a different level of issue right yeah and a lot of times I when I see people using these admin upgradability proxies it's actually not tied into their overall deployment like they're writing their contracts they have all these things in place they're doing it all locally and truffle then when it comes time to do deployment they kind of like manually stitch all these things together to put a proxy in front of it only in Maine that you know cuz it was not really it's not really something they care about in dev and that's another kind of separation between dev and and and main that that provides the possibility of a problem and one thing with Zeppelin is I think their tool does that initialization so if you use their tool it'll handle it but if you like kind of just like your own ruffle then it yeah you might not well yeah that that part I'm actually not sure because they I remembered that they just said you shouldn't have constructor and implementation right so if you don't have that I'm just not sure whether their tool initializes the implementation contract or not if it does not then yeah but that's yeah that's the opening Zeppelin you know z/os stuff okay so I think that's kind of like what's like the big deal right there with those self-destructs is yeah just that I think people need to be more aware of them people who come later in the eff missed it missed the boat on the excitement that was the you know parody multi say-so I was gonna walk through a couple tools that I use to kind of like look at smart contracts this is I wanted to kind of talk a little bit about you know the big one of course which is re-entrance II I mean this is the you know this is kind of like the the premier exploit like almost everything we talked about in aetherium that is a major exploits is due to reentrant see and so was gonna talk about some of the ways that I find these and some of the ways that but I think about them oh look hold on a second got a couple contracts here know somebody to look at that do want to look at these contracts do you want talk about the engine see what do you think ah take a look at it will be cool that's like beautiful oh yeah which one these ones look anyway okay actually know what I mean it's a bad idea let's let's not look at those let's look at those let's not look at stuff live on aetherium right now okay let's talk about Richard C because I just realized I can find if I found something I don't know that would be this if now be the best time to discover that but yeah basically this is dreams yes yeah I just realized I don't like a very intimate conversation but basically those addresses down there which we won't go into are have a delegate calling them are delegated to and are likely not initialized so but that doesn't mean that they're vulnerable because they could be fixed or they could be not you know there's a lot of other ways to protect against it but anyway let's go let's talk about about re-entrance e it sounds like from the questions people are asking here but like you know everybody here it seems it seems like many people know what know what reentrant c is so i you know there's the problem that I've had with reentrant C is whenever I read something about reentrant C it's always this one this one exact function where they use to describe what reentrant C is right it's this sort of like it's like hey if you look at if you look at this code you can see that if somebody has a balance here it reads the balance it sends them the balance but the process of receiving this scent here this call this forwarding of ether would allow them to basically we enter this and withdraw their balance twice or more times so that if they had one either here but the contract can't end they could call into it nine times and they're gonna set zero at the end here but have received nine different transactions you know for ninety feature you know our most people familiar with discs or should we talk a little more about the the function of reentrant see I'm pretty familiar I think the key is there's actually external execution yes well quick but but like this example kinds of limit the scope like some people just see it like hours I send ether then I would have the reentrant sleep problems which is I think that you are see seven seven seven issue yes son yeah exactly right it's not just sending ether so the one thing I think that makes reentrant see a really really really important topic right now is that for a long long time the best practice was oh my god don't ever do this that was kind of the way the people we're talking about about sending either it's like okay everybody stop sending ether from you know to an account using dot call because you forward all your gas and you give them the opportunity to call back in to you and find a buck that has seen if we're supposed to be using was absolutely using AK message transfer that's kind of in the new one or message San which only forwards a little bit of gas but it seems like the new best practice has kind of come back to dock called out value where you send all gas in your ether transfers there's been a whole bunch of yeah so like there's been a big push here for hey stop using transfer and start using call value again so this makes the discovery of of reentrant sees really really important because they're going to be more possible as more and more people adopt this I'm not saying I disagree with their logic here but but yeah it's it's because it's gonna become more important to understand how to look at these and think about these and just protect against them without relying on limiting the gas they get sense to the recipient I also feel like when we when we talk about this it's it's you know once you think about this for a while you can see how a reentrant see here is possible but they don't really talk about why I really like how to think about it or how discover more advanced versions of of discovering re-entrance II like you know this is a makeup full screens down ah sure like that awesome yeah well sorry thank you right so but but how do we talk about ones that are that are more elegant than this like how do we how do we kind of extract rules for how we can think about finding something that's a lot more complicated in our codes I doubt anybody has written this code in their contract so the way that I I kind of think about this is I I look for the point at which control is handed off and that's the you know this message that dot call where you forward all gasps that is a point in which you are handing off control of the EVM to somebody else with all the gaps that you have and now somebody else mentioned in here GRC seven seven seven and other things and there's other ways to hand off control even when you're not forwarding ether so I kind of break this this thing down into like two parts like one is like finding the lines which forward control over to another contract in the middle of your contract in the middle of your function call and once I've kind of established you know found all those lines I highlight them with a highlighter I kind of look for these things it's like anything before that line that is related to control full flow anything where a variable is created before it and then used after and then any storage right that comes after and just start to like like like think about the different ways that those three things can can kind of kind of hurt you and I wanted to walk through a few examples of that so in this one let's kind of like walk through those roles right so we find a line where a ranch se could happen and start going through our rules what do we have here it's like oh well after this we have a storage right this this is the point where you really shouldn't be doing storage rights after external calls if you can help it because you've kind of changed the state in a way that it was kind of inconsistent with how you expected this this function to go I think many of us you know again if you've been around for a long time we have you know the Dow this is it's always kind of fun to look at some of the new rules we have here for for old ones this this dot payout is actually a ascending of ether and see what rules have we violated here that create the issues of of reinsurance e okay well we have a after storage right right so after we hand it off control we wrote storage after that happens we also have a variable that was created before and then used after and then we also have control flow based on storage values that happened above so there was if it wasn't this one it was it was it was gonna be something else so there's there's a lot of things going on here so this again somebody brought up to some time the sevens that was uh no that was a nice little note lead into to this because I want this is what I think is one of the most interesting ones so I think many of us are familiar with the you know swap in a RC seven seven seven issue where if you put seven seven seven tokens on you know swap they can actually be stolen via re-entrance II and this happened I think was about three weeks ago maybe a month ago where this I am BTC was ended up putting like it was quite a bit of it on there and whoever was funding this thing didn't know maybe they weren't here two years ago when everybody knew was here when it does come out yeah maybe they weren't in the ecosystem you know mid last year when it became really really publicized that don't put seven seven sevens in Eunice WAP but you know they kind of missed that memo and so now we're left with this but this one is really interesting because this doesn't seem to really violate any of our the rules we came up with ourselves right the the right doesn't right if you look at this we have send is the way that it sends ether you know to the recipient and then it does a a token transfer and it does a log which isn't really like a storage update it's not a variable setting but still this was able to create a reentrant c and reason is is very interesting so this is the line where the reentrant vulnerability comes from and when it shells out to another program to to this other er see seven seven seven well it has a callback hook for whoever is buying a saying like hey we're gonna grab out to take tokens away from you okay so you got a callback hook for that and then it increases the balance but again like in the context of this function it was at the end so what's the problem the problem is that yuuna swap uses another contract storage natively as if it was its own and so it might as well be its own storage right so here we have the call the the the write that comes after right here but it is effectively a variable that is used directly by you know swap itself and so there it's a we violate that that constraint of don't write after don't have storage rights that come after shelling out to another contract yeah there's there's Thursday after storage right so what's interesting about that is that I think it would be really hard for a like some sort of a analyzer or something to to figure out that there was a problem here because they seem to have obeyed all the rules but you know there's there was there's kind of a problem here and it when I hit production and with the way that people actually interacted with it a separate vulnerability could potentially be a contract that did something funky in balance of right this balance of as a sub as another external call it is but it is a static call so when it when it shells out to balance of it doesn't do so with a call type that is allowed to update stories right yeah so then the real question comes down to it's like okay well once we have a few of these rules and pull it back up again what so ever feel these rules you know how can we find some of the places where this happens and there's really two things that I'm looking for here one of them of course is basically anytime you have you know halt I mean you're you know halt without providing a fixed supply of gas you're gonna have a problem like this but again that's not what happened here right what happened here was a vulnerability based on self-taught token right here's an address she want to pull up the was the contract so like here oh yeah code to this thing really quick so again since this is a delegate contract right this is a contract that only delegates to another to another contract so there's the real one so when this gets set up it gets set up with a user-specified token address it gets stored here and then it gets used later for like coconut balance of coconut transfer so anytime that you're passing in and address to your contracts anywhere you know the question is what am i doing with this address am i writing at the storage or am i calling a function on it's like you know transfer from or balance of or or any of these things because there's you know many token contracts you'll just like grab the address so I'm just gonna write the storage based on this address like oh you have four tokens now you have 0 tokens but any time you you wrap it in an you know as if it was an A or C 20 and then start calling functions on it it's user-supplied and every one of those is a point at which you're handing off complete control of the contract I was gonna we'll go through a couple of tools I have here for for visualizing this a little bit better okay so let's here's one of the things that I I looked at a couple months ago it's called async artwork there's there's a couple of tools that I that I like to use here one of them is slitter which is a trail of bits program it's really good at you know looking your code finding vulnerabilities but also visualizing the code and how things are inherited and how things are related in what fires thing has I'm currently the nice little table that we can look at that and then you can figure out like oh wow I'm passing in an address here I wasn't really thinking about how this thing is accepting an address and passing along with something else the other one I look is mithril and mythos let's start with slither so I have my my things here done in a I'm a bunch of different solidity versions in difference docker images there might be a better way to handle if I just have like a whole bunch of these things built so I can just use a slither that has you know Sol see you know zero point five point sixteen built in and if we run this is this is the text font big enough or should I increase the font size and it looks good okay yeah so you get some you get some pretty pretty uh pretty useful things here so they talk about sending if to hire betray users this is a chance for somebody to reject a call and to make an entire system fail this is maybe you've been around for a long time it's kind of called the the king of ether problem we have you know variables that are never used we have reentry reentrant see these are reintroducing warnings they don't know if a reentrant Eve ulnar ability is created but they are recognizing points at which external calls are being made on on potentially user-supplied addresses and this can be a really good way again we talked about a formula here of you know finding the point first before you start kind of applying the rules about what what to look for when you are kind of before and after every entrance eek all this can be a good way to to find to find those lines to to recognize the points at which you are handing off control and then seeing if there is some sort of an attack that can be created out of that you look at some other ones here I've got another call again I got different versions there's another one yeah this is one that um that I found a vulnerability and the vulnerability was actually what was discovered right here this is one of the most classic re-entrants vulnerabilities when it comes to an exchange is to be executing a buy or sell order and when you get control handed to you from the from the contract because you know you you provided like a bad token in the middle of that call you cancel your order so you're in the middle of of filling something you cancel the order they give you your funds back they've already loaded up the what they plan on giving you and then they proceed to give you it on both sides so you both withdraw and take it's kind of like the you got like a quarter on it on a string right it's it's exactly what it looks like in solidity yeah but this is a bit slither here is a really good tool for for really finding the points where you could start I was actually a yes this happened yeah where you can start thinking about what's happening around this call both before and after and and how can I use that to my advantage let me talk about slither I can show some other pretty cool stuff here so they have different printers print so what's one of the printers function summary okay let's helps to have a much higher resolution here and what you don't be able to see it let me just rate it looks like it's really pretty I'm not expecting anybody able to read this I'll blow back up in a second but you can see here you know we get like you know all the functions you know what the what the external calls that function makes what's you know what storage variables are written in each function and it can really kind of help you understand app of what this thing is doing and so when you're evaluating you know it's like hey I've got this read Antron see here if I could just modify the order book while I'm in the middle of this call you like oh well which functions here modify order book as a result of being called you can start kind of going through those like targeting those as like oh whatever what if I reinterred into this what if I re-entered into cancel order while I'm in the middle of filling this order back up so you can see it but yeah it just it's just way more consumable then than just like browsing I'm doing control F through and just looking for that because there could be different ways that it gets updated via a different path that you kind of forgot about so it just kind of like flattens it all into a really really consumable way there's also let's do bars and off blow it back up again shrink down a little bit not that bad yeah so here's here's these functions these variables are written and these are the conditions that they found on message sender right so you know it's like hey if you want to modify here are the functions where you can modify these things without being admin or without being a token right it's like they again if you're trying to attack order book it's just a great way to see like which function calls allow you to modify which things may be like oh I have to I have to be admin to be in this well I can't I can't no let's check that off the list I'll focus on once right don't need to be admin it just really helps you hone in on the functions that are gonna yield you the most results and I'll do but is this a really good here is this interesting me yeah this is this is really good okay quickly all right great let's do this one then call graph this one's super cool we do a different one AC part work okay so we have here 0 5 16 let's do print call graph and before I do this no I didn't actually run that notice I don't have very many files in here who's got these files let me go ahead and run this so it's I asked my slithered docker container to run this call graph and now when I look here I've got a bunch of these dot files and it created one for every contract in there like the interface for the 721 receiver but we really only care about their you know the real one right the main contract that gets deployed and it creates this little dot file which you can do with it I'm copy that to the clipboard pop over here go to web graphviz I mean really anything that can display a dot file is just like a quick and easy one that I have it shows you the relationship between these these things like how they call them now there's a bunch of solute like it looks a little ugly right well we can actually clean up a little bit so let me do this so I've got this thing in my and I paste bin right I actually don't care about any of things that say require I'm just kind of trying to figure out the they're just the way the functions are related to each other I don't really care about the requires and maybe and maybe in some case I would care about that but today I don't and then there's also another one I have over here which is is approved or owner it's another one I don't really care about it's a modifier and not one that I'm really looking for so let's just do this so I just sort of like just literally pulled those lines out copy it again come back to my browser's paste that back in like okay well this is a little bit more consumable now right it's not quite as bad and you know it just to be really nice high level way to understand like all the different ways to get into safe transfer from like let's say a lot of times there's an e or c7 send some vulnerability safe transfer from is the way that that those callbacks are initiated and yeah this this check 712 anyone received this is this is you know I think this is actually for the 720 ones but has the same sort of callback yeah you can kind of find out like oh that happens on token sold oh that happens on accept bid and take by price like let's think about ways that that this can cause a reaction see somewhere else here and again going back to like the Verrazano off and you can start to really piece together like an attack using these this like it's like a map of how you might want to construct it see here oh I mean maybe maybe you've seen some these tools here this will be stern a car that's here so we have MPX truffle so let's go let's move on from slither and let's move on to when we call it what do we call it myth effects so there's this there's like a mithril program that since this creates but they also have like a nice little page service that allows you to you know run very similar stuff and if you have truffle built into your system you can you guys have just like hey truffle take all the contracts that you are aware of and compile them and flatten them and do all the stuff you need to do yeah probably run ethics it can be extra for ground effects okay I just tried it before it happened oh whoa you say n PX n PX truffle run effects yes you are right yeah yeah you're super right thank you know awesome all right so it's just it's just a cool way to to pass this off and they have a it seems like that if they find more stuff in their mythix than their and their open source they also run it really fast they have like a button that gets way faster to run it this way then then I can run locally provides like a really nice web interface for for like jumping around and so again you kind of only want to find the ones that care about here let's see I just followed the link here from the output again this is just the one that we care about that's the main contract it's deployed and if we go back yeah we can see like oh well there's a loop over unbounded data structure that's interesting it goes all the way down here and yeah in this wow that is kind of adjusting right there you know they could run out of gas if they have too many unique token creators and that's probably that should be bounded somewhere here yeah this one actually looks like it did not it looks like this one actually and I like to run both tools just because this one actually looks like it did not find the the re-entrance possibility but I think it's because of the way that like the 721 is created in one contract and this is used in a different contract and they didn't get kind of like pushed together like you know you have to use that 7:21 with this contract with this async contract in order to find that vulnerability on the 7:21 callback so yeah but both tools are you know nice to use here yeah and then of course even use mithril directly but um just brought it kind of like manually on so that's gonna be sync but this it takes a very long time and it doesn't usually yield as good a results as just running the text yeah and ethics takes a lot of memory space yeah yeah taught me this this for I mean on the some wait for this is probably take another few minutes to run and and the results aren't gonna be as good and the results aren't going to be as pretty and it didn't look at all the contracts but other than that they're both they're both really good tools and it's you know my taxes like 50 bucks a month so it's a you know it's not it's not terribly priced there's also see here I actually haven't use this one so I actually haven't used this one but this is the slither service kind of like myth X and it really enter it integrates with your github and then it kind of acts like a continuous integration for security which is nice because you can see you know just like state changes in your pull request before you emerged I have been like hey you know there's you know I didn't think there was a reintroduce heed before the split request and now I do maybe you should think about that now because it can be really easy to like it's like all this thing's always there if you're not really tracking them as they move forward with each code change it could be not quite as eye opening when it changes not quite as obvious when it changes so does one more and this is maybe one more I wanted to talk about that I thought might be interesting to hear so the other swc that i wanted to talk about where is it that here they are the other has to be see that I thought was kind of interesting was I went down well basically it's it comes down to front-running camera or what the number is for it it's just like it's like order yeah transaction order dependence yeah maybe it's underway that one anyway well this is kind of like maybe like not quite as advanced as vises is the other ones but here's here's kind of an interesting vulnerability that I found in one of the ways that I thought about thinking through it we're going to go through this whole contract and I pulled it down a little bit but there was this project that had this notion of like a text token where you buy a token and you also need to pay like you know some small amount of ether per block for the right to hold it this is kind of becoming a more popular model I've seen and a bunch of new projects there they're calling it like Hart the Harbinger model it's similar to like this artwork as always for sale that's like a like a project for a long time ago and one of the things that you can do in this thing is like oh well you could you could buy something you could buy one of these tokens and if you bought this token it basically looked at what the price of the token was deducted that from the value that you sent in to the to the contract and what you know you would pay whoever you bought the the token from whatever the price was and then whatever was left over that became your deposit for holding that token for however long you wanted to keep holding it for and the code you know the code was functional and it worked but the problem was that the the code was vulnerable to front-running because you know somebody's gonna say okay I'm gonna buy that token for you know 1/8 and I'm gonna I want to have like five eath you know in in my reserves that gets deposited so that I can you know kind of pay this this per second you know holding tax on this token the problem isn't that somebody could at the very very last minute right you know after somebody says hey I'll I'll go ahead and buy that for one II could submit a transaction that says I would like to buy that from 1/8 and I would like to sell it for five point ninety and they would you know only hold it for you know maybe within a single block and somebody who thought they were gonna have 5/8 of deposit when the whole thing was done ends up with 0.1 ether deposit somebody bought and flipped it you know in just a second or maybe even within a block I see if I don't find the code here that talks about that right so they did yeah so the deposit here is you know whatever they had before plus how much they're including - what the prices but that price can change between when they created their transaction and when they shipped their transaction and these ones are these ones are cut off sometimes hard to find a little bit one of the ways that that I think about it is for every token that I'm looking at when I'm for every transaction I'm looking at I'm thinking about go if I called this what would happen I just try to imagine that the block time instead of being 15 seconds is like 15 minutes so when I'm thinking about okay I'm going to buy this but you know imagine you're like looking at ether scan there's like a pending transaction here and there's just somebody standing there looking at it and there's just a huge amount of time maybe maybe even 15 hours like it doesn't really matter how long they're it's just like you know pretend this is Bitcoin right but then we're a slow as Bitcoin what could you do in that period of time and for me like when I start thinking about like really long periods of time it really helps me think about what I would do if I was trying to make money and just hitting refresh on ether scan all day I don't have like a good tool necessarily for discovery discovering these it's really just more like a thought process around the kinds of things that can be influenced Biafra honey I'll stop there order any questions anything the we should talk about well so I just kind of want to comment on this one the way I think about this it's kind of like if there is a lack of confirmation or commitment when I went when someone sends out a transaction is the blockchain state you know like the same as he would he was expecting and so and so typically what I would recommend some project developers is that they have this commitment specifically in the argument not sure whether you yeah bank about that absolutely I thought that was the suggestion here the suggestion here was minimum deposit expected but yeah I mean really when you act with me I think that's probably there probably is the the good like general advice which is if you're dealing with a price that is stored on chain you should probably be passing in an arguments to confirm that it is close enough to that that you want to proceed because that can change very quickly and unexpectedly right I mean like what Yunus walked us right you mean like you know you like hey I wanted to exchange this but I don't want to take worse than this rate because it could change between creation time and execution time yeah so anytime you're reading storage values that can change and negatively impact the user you really got to be passing in another argument so ten one follow-up question so thank you for the presentation I think like especially like the tools and then how you think about it it's really helpful I was wondering whether so do you see any missing parts of the tool like for example what would you want you know like to to inspect these security vulnerabilities better like what kind of tools do you think that is kind of lacking out there that's a good question I mean I think just bringing all the tools to gather because I think you saw like hey look I'm thinking about like I ran this like VARs and off and then I ran this you know that web mapping one and then I ran the one where the calls happen it just it seems like it's still like I don't know it's still a very manual process it's a very maila process and I and I kind of in my brain need to think like okay now I'm looking at tape by price now I got to go over here and remember the take by price you know had these modifiers modified this state and made an external call like it's very I think that if you could just make these tools like really really slick I think that you know and together like I think that a user could start to have their own ideas about it like just based on bubbling that up in a way that is just like you know kind of beautiful right that is yeah imagine if all that data was available on that charge or imagine if I could say like really quickly it's like I'll get rid of the solidity requires that junks up my thing too much I can't see enough right if you could make that easier instead of means it's like pulling things out you know I'm still I'm I'm working with like dot files or the graph bins like if you could may if you could make that like a really slick I don't know what it would look like but something that brought it all together like that's where the discoveries happen they don't happen in the solidity code usually they go they get confirmed in the solidity code yeah because it is really hard to trace through like especially complex projects and then like when I was looking at some project code that sometimes they have like combining the all these things they have a delegate call to other like extensible modules that they have it's really hard to trace right there and I think the graph also kind of stops there because if you do delegate call it's if you just look at the code itself it's going to at an address right which on the smart contract level like just looking at the code it doesn't know where to trace it so yeah absolutely yeah I know you're absolutely right yeah this I mean this whole time we've been talking about about code but yeah this code goes lives on main net and they get to wire it up to other things and we have no visibility into that I got at least I don't I don't really have any like great tooling for understanding what this code does when it interacts with other things out there I mean so mythril can run against a deployed contract and understands a little bit about some of the storage values but it's not enough it's not it's not as good as like slither or mithril when it's running against the solidity code it's not nearly as advanced so yeah that's yeah we lose visibility once money goes into the code right yeah yeah then what do you think about the fork option and truffle oh the economics yeah where you free for maintenance yeah yeah I don't use that I have a different actually interesting I actually don't use it that much I haven't I started doing something a long time ago before that was available and I it works for me I see where it is it looks I mean I've seen people use it and I'm always like amazed and I always think I should totally do that you know old habits sorry yeah so I have this sum so parity has like a whole bunch of these really nice tools for like doing deep inspection of like how calls happen and so I can like put together a whole bunch of calls and ship them to parody using um like it's like parody call and parody multi call that's how I generally do like the kind of like fork thing where it's like hey what would happen if I ran this series of transactions in it but I've actually used for do you use it a lot I do not and and the reason I do not use it a lot is that when you're testing against like main that you have to for example if you just need some dying and you have to figure out how how to get die on the mace main that even if you can have a good notching like give you a bunch of ether but you have to figure out a way to get all those thighs so I think that's kind of the blocker for testing and walking around with it so it so what I not so when I use my system yeah so this is parody call and trace call mini so when I use these things what's nice about it is uh I can have like a from in to be the front can be something that I don't I should have a private key to in fact the front I can actuate the from be a contract address in and but I could pretend like it isn't so that's pretty cool at least they're gonna find the documentation for this because this is super handy yeah cuz then I can just say like I'll just go find like an ad I whale and my first transaction would be like hey die whale what happens at the die whale gave me all of the die and then I did a whole bunch of stuff yeah that's super useful yeah so here we go this is um you can do a so you pass it an array of just like things you want to do and then it returns you an array of the things that happened you know in this case nothing happened but it would give you like a really nice list of things that occurred so just one quick question so this is ran on Komachi or like you like it there's a different set of toilets which like this is just this is just parody like this is like okay you have to have a parody node in the parody not has to be like fully synced now there is a web service for this somebody actually took this and said this is so useful I'm going to make a web interface where you can just basically put these these parity call payloads and then we'll just run it against our node and give you the results I think was even archive node I don't remember the address but I could send it to you or I could post it in the follow-up thank you now this is a recent service or like maybe like two months or three months or something oh it's so but but downside I see it's it's you have to have a fully thing parity node then yeah it has to be a house before you tell people think it has to be parity and I remembered it's like the demo they had was like check out the telex die or something it was like for anybody who's who might be new and they're searching for resources the parity client is actually called open etherium now so if you're searching around online you might see two different names for it and some of the documentation is probably old as well further the previous maintainer z' yeah I mean I'm a huge fan of those tools and I I don't know it's gotta happen to them but for now no but now they work great yeah I mean from what I understand gnosis has picked up a lot of responsibilities I see much stuff there maybe label goes better I think the nether mine client has started supporting similar functions as like the old-school parody stuff yeah but I couldn't be mistaken no no you're really right there that's the one that I'm looking for it seems like they're the ones that are more they plan on pushing the boundaries of some of the RPC stuff a bit more yeah definitely I'm look like I'm probably gonna be switching to that pretty soon just because like some of the disk utilization stuff in another bind is really really nice mm-hmm yeah I can see so there's there are a few questions from the streams you know good if I just feed him to you yeah sure the first one in maybe I asked for more context so maybe this question isn't clear without the context but one person asked back when we were going over I think it was slither in person asked perhaps these patterns should become syntax maybe that was like 10 minutes ago I don't know if that means anything to you perhaps these patterns should become syntax originally with at one point in the think of that means all right I'll get back to your favor context I mean maybe what they're talking about is like you know we're like coding up all these different things and like writing the code from scratch every time and it's hard for us to parse what it does when everything is just like ad hoc EVM code I don't know yeah my guess would maybe they were maybe asking about some more like language features and solidity to kind of insurance and these things maybe yeah yeah I mean totally like with a delegate delegate call stuff I mean not only did not a language feature like that implementation that we went over it that was assembly I mean like literally it's gonna be a pretty sad day when you know all all this code that we're running goes to these admin proxies and it's going like you know you take a hop through assembly every single time like that's a cinema dangerous yeah at the same time like sometimes there are features not bugs Oh totally no definitely didn't do they didn't do the wrong thing yeah bit like the one thing that we do in almost every one of our contracts isn't well supported there's a high lingual high level language there is you know that's you know like you know one of the things that they should have in here in this swc registry it's just like uses assembly at all like like like that's where things go off the rails yeah but it's also like all the features come from come from there or the interesting features somehow absolutely yeah totally but I mean that that's how 0x had there that first major issue is like just assembly you know type 2 assembly bracket yep nope you got a security problem we'll do you want to bring up your question yeah I just wanted to get your opinion on buzzers because you're you know saying how it's it's kind of hard to test up on Manman and you especially when that's it's delegating you don't really know what's getting executed and you know what maybe is your experience with pulling out some vulnerabilities using buzzers I I actually haven't used buzzers that much I probably should add them to my to my mic toolbox to you do you use them and do you find good results from them I I haven't personally used them because that's actually what I'm asking about yeah yeah some of these other tools but that hasn't been on my menu you know yeah has been of my menu either there was a couple when I first started this the spot-check program I talked to I talked to trail bits and they were promoting to tools it was Manticore and Kidner and it kind of seemed from the from the conversation that those are tools that I think one of those is a fuzzer I don't want one of those is a symbolic execution it requires kind of like putting up like really like integrating deeply with the contract like it's something that you were gonna do if you're gonna do like a you know one week or greater audit on something and I generally honestly can't be honest leaders I'm just looking at all like that I'm looking at all the easy stuff because it's like it's out there I haven't really had to go too deep to find what I found and I hope that somebody does but maybe somebody smarter than me but by the way that's yeah it's a Echidna in there's the one yeah yeah yeah it seems like you're like I'm just rolled like slither I get like a table I go and do some stuff it seemed like echidna was sort of like okay let's set up a part party of data integrate with it and into like like plug in that it's pretty to develop inside of it yeah I kind of had an impression didn't like some people from my team has used that before and then yeah it was not it was not as user friendly I would say so yeah it's very hard to set up yeah oh you know it does have the feature that we're talking about here now I think I think tenderly might sorry to interrupt but remember that that call we even like put multiple calls and see what they happen execution I think tenderly came out with a feature for that but I'd have to check I've been to places I went the tenderly debugger and it's really cool yeah I I'm really impressed with listen this stuff I've seen on tenderly plug-in okay pretty don't hack me yeah there's like there was something I did like a bunch like simulator I think they don't think what they called it I maybe can only do one inside of it though yeah maybe that this this has provided some of the features that that I think parody has generally provide provided me before but yeah I'll look for that free service I'm still looking at I was looking for Don my phone here wasn't for that free service that offered that that same kind of like do this then they spend this and I don't need the private keys for anything because I'm not actually doing it yeah is there a place Trent that I could like post a link after I find it so that it could send out to those that might be interested yes so what I was gonna I'll just loop back with you after and we'll collect all the links to the stuff we talked about and we'll drop it in Geist score but put it in the YouTube video description everywhere awesome cool and it I got some more context from the previous question and yes it was related to explicit security by language features the person asking about syntax yeah come to speak of that how do you think of VIPRE because I think that was the goal of cyber right yeah yeah yeah I mean yeah VIPRE supposed to have what built in overflow protection built in have a bunch of built in other stuff I don't know I mean if I mean it seems like it's good to have a language it's like very geared towards security it also seems like very insecure to use such a new language and store millions of dollars on it so it's this kind of like this weird it's got it's gonna have to get like a lot more people using it before I think I would feel safe using it nothing does anything even specifically wrong with it I just want I want somebody else's hundred million dollars on their first now that makes it oh hey scored like I have so can we also discuss few things on like when the transaction fails like it's hard for developer you know to find exactly what's happening and wait like the transaction is failing so like I faced a lot of number of like you know transaction reward as like it's hard to you know find out the just looking at the ether scanning like like the distance yeah absolutely it's it's it's getting a little bit better I mean I think one of the things that is really helped is require messages yeah be quiet good messenger so I frequently faced problems with this but the problem is I think if you're interacting with something else I guarantee you it's like if the failure happens inside of somebody else's contract and they didn't have those messages then then yet you're in you're in bad shape so let me um I'm gonna stop my share real quick and then I'm gonna start it back up again let me show you what I do for that so I basically use be impressed that either scan provides to you know get the messages where the transaction is actually failing so do you say which one mostly is that VM trace I always forget which traces which is that the internal calls one like either stand provides you if you if you like go through a particular transaction on the right side like you will find the three dots vertical dots so if you will be option for VM trees and that might be the one I was just going to show you on the command line because it was a trace that I use so three dots oh if your scans tracers are broken what's going on I didn't get that action in this one so the one I use the one I use is called parity trace actually here let me just shorten let me just show my screen again yeah exactly exactly parry trace yeah parity trace is the one that I use for all these things in fact they make parity trace and that other one I was talking about where I could like do a bunch of things at once I mean it's really two parts of the same coin it's like am I am i tracing a transaction has already occurred or my tracing a transaction that I am considering executing yeah yeah BM trace is what is called the up totally this is yeah this is a I don't currently have a better method than require messages and this I know there are people out there who do who are who do debuggers I just haven't really that's by the way he's talking about this let me find one that actually does something more interesting than nothing just give me an example like how do you know trace the like error messages that one can go and just change in the code and how to find the real transaction is fading exactly I mean when when these things fail and we find one of these I mean yes so like that one so yeah if yeah but if you fail with the require then it will tell you like right here should tell you the reason that it failed there like whatever message you put in there it should tell you that it failed for that reason like oh you didn't have enough dye or you if this is any what case if it's a revert case yes like the transaction tree words so there will be no error message over there so it's really hard to find out the the execution I mean if it is it is a reverse because I had a require and the require could have had an error message on it or it reverts because it had an unknown opcode or it reverts because it's if it fails to require like make that condition right but that should that should just like like what it give me example of one because I'm pretty sure that there should be requires for all those that have error messages out of gas right so yes right so in either  either should run out of gas revert or fail and we shouldn't be getting too many fails because that's just like you had an opcode that's invalid for the other ones there should be like if we can't find any examples of anybody using revert messages well here let me show you you know what maybe this is interesting I'll find a good example here you never say y'all you only see my um chrome screen right yes sir okay trying to find a good example here make your governance good so I own the show my screen again okay so I got this some got this little script here that all does is really just kind of creates a little JSON payload and asks my supposedly local parody node if it has this you know it submits a query to my local parody node for it for a trace called many I have one here this is just something that I was looking at and this is kind what if one of these payloads looks like so if you could structure your things like this payload you could get these these traces but you get these traces and get asperity call this is kind of the thing I was talking about where that would I had that web service you get back results that look like this which are like it's an array of like you know the outputs and what it did and who would talk to and why it did it and you know and all these cool things now what's interesting is that when you have a revert here and I don't know if I I'll need to find a good revert case we have here the result the output will actually have an encoding like an even deeper down in the stack the output will have an encoding of what that require revert message was let me see if I can kind of hard actually now what let's look at I so we'll just take like somebody is like died transaction oh no this is you it's like what's this person doing the transferring guy perfect cool so let's do that input as the original let's go ahead and dump that into our there's our file here and we're generating so and go so that so I'm going to try to send this but I'm sending it from like it's and then the destination of course is gonna be the die contract so we're saying like hey I want you to do whatever train whatever transaction that person just did we're sending it to that contract you were sending it from somebody this is just like a maker contract and I was like testing around somewhere else so it doesn't have any type probably so if we run this now we see that it reverted but we also see that the overall output here is is what it returns and you'll get this like per I believe you'll get this per call per sub call and this this is weird way to do like web 3 - no I'm sorry a hex to ASCII actually like pull messages out of any individual sub call that you have I know it's kind of not very friendly but the ability to kind of like look at the revert message for whatever internal message depth you have is a it can be helpful but I believe that I believe it should bubble up all the way but if it's not bubbling up if something is route anything that fails with a revert message should appear you know in this VM trace we've been talking about does that help for or did I thought I'd go to that was I was really helpful thank you okay but yeah this these things get returned everywhere and so they should be able to get parsed and it's I mean again it kind of comes down to the question about life boy but to Lindy Ilana it's like well this sucks right this is not a great way to have to interact with these things I mean the data is there but should be a little easier to like to get these traces and to inspect them in a way that's that's more actionable you yeah I mean the buggy I know other people do step2 buggers and they have other people have like other things that they do I didn't just do with internal traces that I that I look at and try to understand from there but if you're doing a lot of logic in one function and not making a lot of internal calls it's less helpful right anything else or should we try to think maybe now is a good time to call it or any more outstanding questions yeah I mean this has been super helpful for a lot of people I think does anybody have any final questions nope no really but it was really great thank you Scott awesome thank you thanks for showing up and thanks for the questions we weren't just you know standing we're just sitting here awkwardly 20 minutes after I started so I appreciate ya all the questions do you want to give any like final wrap-up comments on just I guess it's up to you any and yeah I mean general I think your your your practice what you're doing you know it seems like the the skill level that people are showed up here's you know it's pretty high so you know normally what I recommend people do if they are really interested is like there's a couple of the games that we have here there's like what is it ether knots but it sounds like most of the people here are I'll be on that but if you I find this to be like a really just a great way to kind of get to recognize things in your own contracts then there's also the capture the ether these are both like really good tools if you know if your earlier on and you know in your your career want to check these things out this is a great way to see how to identify these things and you know exploit them and make sure they don't happen to yourself and if you have projects that you're interested in having me check out this the spot check program just offers you know free you know several hour you know quick high-level reviews again just looking for the really basic stuff because a lot of times the basic stuff still is out there so you know I'd be happy to take a look as part of that aetherium foundation spot-check program awesome cool really really appreciate you spending this time like I said it's gonna be super helpful for people who are on the call and then also the recording that people can watch and refer to it later if there are some hack many hackers that are interested in connecting with you where's the best place to do that the discord oh yeah I'm on the discord I'm also a APHA pH on Twitter but yeah this core I'm also on the discord to steai hit me up anyway all right final points before we sign off obviously today was the salinity vulnerability session tomorrow we have a session with Ken from the ecosystem support program about how to take your project from a hackathon to main net and beyond how to produce basically how to how to become sustainable how to develop your project outside of short term events like this it's gonna be a really great session I encourage everybody to sign up for that and its end then Thursday is the final yeah I think there will be the final hack feedback session so we'll have mentors you can come you get a ten minute slot to present and get feedback from mentors again highly encourage people to come to that get any last minute feedback from people before you create your pitch videos for judging which is happening all of next week we dropped some links and also send an email about how judging is going to work so definitely check that out there are some requirements you have to make a short video to present with you you're gonna want to make sure you understand what all the requirements are and then Friday there's an AMA with Hayden from Yuna suave so again a bunch of really great events this week as we finish out hack money make sure you're checking in with global team members if you have any last-minute blockers or any issues before submission on Sunday again remember that's Sunday 11:59 Eastern Time so we're super excited to see everybody submissions and can't wait to get on to judging next week it's gonna be awesome thank you everybody for coming we're gonna sign out here have a good rest of the day hey good see ya 