hey everyone thanks for joining we have david from the graph um if you have questions for him feel free to drop them in the chat here if you're watching on youtube drop your questions in the chat there and i will relay them to david so david's going to give us a talk on building with subgraphs awesome yeah yeah thanks david yeah thanks for the intro so yeah i'm dave i work at the graph i've been working there for the last two and a half years and you know we've been working on building out the graph network and we've been around for a while i hope a lot of you guys have heard of us um if not this will all be new to you but it'll be interesting and i'm excited to get started so let's go a little bit of background about what the graph is to start and you know this is just our this is just our home page and what we really are is an indexing and querying protocol that is built on top of ethereum right now right now just what what we allow you to tie into is ethereum and ipfs um but you know we have this vision for the future of a global kind of api for for data for open data such as data on blockchains or data that might be on ipfs or file coin or or whatever you whatever like happens in the future um so just to get kind of started this is you know a little bit here's one of the things that we also like we use graphql in in the stack of what kind of like what you end up building on on the graph protocol is a graph is called a sub graph and i'm going to go into the details of that when i go through the documentation but um that's kind of all you need to know about us right now there's a ton going on about the graph network uh and we're we're getting into that right now in in it towards the end of this year but you know this is about the hackathon so let's get started on that something else i should mention as well is the prizes that we are giving away for the eve online hackathon and so it is one prize of a thousand die for the best use of a sub graph and it is another prize for the best new sub graph so what that basically means um you can go to let's find the explorer here so these are a bunch of existing sub graphs that have been created by the community and what they're doing they're just indexing and offering up at an api endpoint a bunch of data so these might be a lot of names that are familiar to you guys such as like uniswap is by far the heaviest used subgraph out there and if you click on it um you can basically query any data that is on the unitstop subgraph and get back all this like rich information any swap that's happened on uniswap any kind of like trade volume you can get all this here so it's really interesting um there's a lot to it but so that that is basically one of the prizes would be tying into any of these existing subgraphs and using it in your front-end application that you that you're building for that hackathon um so we've seen that before and we've also seen people create their own subgraphs and that would essentially mean you're going to deploy one to the graph hosted service which is what basically the explorer is and these are all kind of featured sub-graphs that we've talked to people and got them to be displayed here on the front of the page but there's also you know over a thousand community subgraphs that have all been built by people over the last couple of years and we're really um we're really getting into seeing a ton of these being built all the time and it's really interesting to see that happen so another thing i'd like to mention about that is what we usually see in hackathons is people building on the graph and then tying it into another project because essentially what the graph is doing is it's allowing you to see rich data on ethereum and displayed in a front end so you might be building on like uh m stable or or uh pooled together like one of these other protocols that also has a prize and or else if there's if there's a grand prize that you can win um all those kind of things like what we usually see is somebody will build like a pulled together kind of front end dap and then they'll tie in a subgraph and definitely you'd be eligible to get both rewards and in some of those scenarios so that's basically what we have outlined for the hackathon and what i'm gonna do is now at this point show you how to build your actual own subgraph um and the best place to start for that is our documentation um and if anybody has any questions right now um let me know heather but if not i'll continue all right so this is just a little bit this is the introduction this is basically what i just talked about if you go to quick start this is there's a little bit of a like fine detail that has to be known here local development is more so if you are running your own graph note and you you have like a really powerful subgraph that you're doing a lot of a lot of work on so we're not actually looking to do that what we want to do is use the hosted service and the hosted service essentially is like our our version of the graph node that's running in the cloud that you can deploy any subgraph to to uh index and query data on for ethereum and so what like i guess a good point to explain now this starts to go into what we're gonna do with the code and and i'll get into that soon but a good thing to go in right now would be you know what exactly is a sub graph um because i've said it's indexing and querying for on top of ethereum but let's get into the details of what that really means so a subgraph i'm going to skip down to this really quickly like the subgraph manifest is kind of what describes it's like the very high level explanation to a graph note what a what the subgraph is supposed to represent for data so if you look at this this is just a yaml file and what it is is it's kind of just explaining what the graph node should index so we're saying okay there's one data source it's an ethereum smart contract its name is gravity it has it's on mainnet because we can index all the test nets and also some of the other evm chains that are out there uh it has this is the address on mainnet this is the block it was deployed on maintenance so that's when you should start indexing it and then we're actually giving it the abi from the smart contract and then we're also giving it handlers that it can basically run mappings on and i'll get into mappings in a little bit more detail soon but all these handlers are basically things that happen on chain that allow us to allows the graph node to recognize hey something happened on chain i want to grab the data from that event and store it in the subgraph and basically from there on we you you store it in there and you build this kind of rich sub raffle of the specific data that you want from ethereum and so as you can see you can run basically the sub graph on on event handlers you can do call handlers as well so any like function calls you can actually get the data from that and you can also do it per block so every single block on ethereum you could actually get data from so this is like these three types of handlers pretty much get allow you to get any type of data you want on ethereum and you can also call contracts directly so let's say this new gravatar event happens on ethereum it's emitted by the contract you can actually call directly into the ethereum node at that time and call any you know public functions or public state variables and get the value that's in there so it allows you to also interact with the ethereum contract as well as what i already just explained is indexing data that's being emitted and i'll go over some code that that involves this a little more hands-on uh later on but this is just kind of high level explanation of some important parts so this is the next part that's really important so the subgraph manifest explains what data we want from ethereum so then this is called the schema basically or the graphql schema and if you don't know anything about graphql i highly recommend you look at their documentation it's really cool api language and that's very well suited for what we're doing at the graph and it's why we chose it and you will see this example as well but it's it's basically just saying you know this is the entity or like object type that is going to be in our subgraph which is storing data in a store or a database right and this is going to allow us to get and set from that store and load from that store whatever we want to do um and as you can see there's kind of these these core core values like id is definitely needed for every single entity it has to be unique and then we have you know bytes string and boolean for and a couple others and you can keep creating them um and you can embed them like a gravatar could also be right here as one of the field types and i'll get into more detail about the schema later but basically the important thing to realize about the schema is it's kind of like setting up your your data model for what you're gonna end up what you want to be queryable in your subgraph and then there's some more details here definitely i would recommend reading through all of this um but it's a little bit too in-depth for just this kind of tutorial so the last one i'll go over here is writing mapping so this is kind of like the the core of the the complexity of the subgraph is how you're handling that data and how you want to store it in the subgraph so as you can see like this mapping right here there's an event on a smart contract called new gravatar and whenever that event gets emitted by an ethereum node we're basically going to run this code and this code is assembly script code which is similar to typescript but it's just a subset of it and it's pretty straightforward we're just creating a new gravatar storing some data storing some fields on um from the event so the event parameters storing it on fields on the gravatar and then saving it to the subgraph store and basically yeah that's so if you combine those three kind of ideas the subgraph manifest which tells the graph node what data to get from ethereum and then you have the schema which tells you how to store it and then you have the mappings which explains how to take the data from ethereum and store it in the store so if you take those three kind of concepts that's basically most of a sub graph which is which is from you know from what i just showed here it's really simple but it can get very very complex um so at this point what i want to do is kind of go over a tutorial and start actually deploying a subgraph so what you can do go to the top of the page and so you'll log into your account through github oauth and you'll get here you won't have any subgrass if you're brand new but what you want to do is you want to deploy a subgraph to the hosted service so that our hosted service in the cloud can actually index your subgraph so we do is you go add subgraph and this is where you just give it a name and so the the example we always use is called gravatar it's just a really simple smart contract that will it's just really good to show you know the power of a subgraph without getting too complex and i'll quickly show like an example of uniswap at the end as well and and how you do that so i'll show you kind of two different two different subgraphs and that should be enough to get you guys started uh global hackathon so you create this on the hosted service and if you want you can hide it so that nobody sees it in the explorer and i'm going to do that for this scenario because this is just an example subgraph and then you create it so now i have this created sub graph in the explorer but it hasn't been deployed yet so i'm going to have to deploy it to here so we kind of have some steps here that that you need to do which is which are really helpful and copy into your terminal and install graph cli so that's what i'm going to do and quickly just go to my terminal here so i got right here i have a blank uh folder and i'm basically just gonna start the start start it as if you know i didn't know how to do a subgraph before myself so i'm gonna add graph cli to my global package and have that installed and at that point we should be good there and then what you want to do is so we're going to do this graphing it from example so this is a command from the graph cli and it's actually very it's just a very simple way of setting up the gravatar subgraph but if you know if you want to start your own subgraph it's also a very good way to get a boilerplate code up for your um up for your project and then go from there so it just asks you to do basically your github name and whatever you just named your subgraph so i named the gravatar in the explorer and if you do that just ask for the subgraph name kind of basic questions there now last time i ran this it it's had some errors with the yarn installation but actually everything checked out when i ran through it so we might see that again but actually it's just like a weird yarn error david we've got a question in the chat um from anne mall asking does textiles threaddb support indexing of its database entries and if not can we use the graft index of projects particular database yeah okay i'm not 100 sure personally about textiles thread db um i haven't looked into it personally um i've heard of them before but to be honest yeah i'm not totally sure um so you know if if animal if you have some more in-depth questions you could definitely join our discord channel and we're super responsive there and and we could dig into it more or there might be someone else in the team who might be aware of of how that works but as far as i know like at the top of my head probably it probably doesn't um but like yeah i would say it probably doesn't but we could dig into it in the future in the discord um so hopefully you reach out to us there anyhow thanks for the question now i am uh yeah i got that error that i was talking about before but it's actually okay so at this point um i've done this and now it's telling me to deploy the subgraph to the hosted service so that's what i'm i'm gonna do you see you have graph auth right here so this is just asking you to authenticate with the hosted service uh and we actually give you an access token right here so i just copied that and i'm going to copy the access token and i'm now authenticated for that so if we now go into the the graph and it created this folder called gravatar we're going to go into it see there's a bunch of files there and we're going to open it in vs code and so this is the folder that gets made and what i'm about to run is called graph deploy but we're quickly just gonna go here so as you can see it gets auto-generated this is the command that um allows us to deploy to the hosted service we don't have to edit anything there right now but we do do this thing called yarn code gen or graph code gen and i'll actually run that right now and so it just auto generated some files for us basically if we go here um great place to start would be the gravity smart contract so this is a very simple smart contract as you can see uh or gravatar registry it's actually called and all it is it's basically storing like an identity on chain um you have an owner you have the display name and an image url which is like uh kind of like um yeah like an avatar that's what i was thinking yeah exactly so that's all it really is super simple smart contract and we're actually gonna be paying a lot of attention to these two events on it um but this is where i can go in so let's say you found this contract and you wanted to build a subgraph from it the first place you would start would be basically looking at the subgraph manifest that i explained previously so you know like i explained in the documents before we have we now have a contract address that we know is on mainnet um where we want to do things and edit the data whenever we see these two events get emitted so we got new gravatar and updated gravatar we just passed the event signature which you can see right here um and the other thing that should be noted is it's important to get the abi for gravatar to actually build the typescript code that we're going to allow to interact with the ethereum blockchain so that's what the yarn code gen command i just wrote or wrote right there was so what code cogen does is it makes this auto-generated code it goes over this api and so the api is for smart contract and it allows you to interact with it on chain right and it simply just creates like setters and getters for these functions now you don't have to read into any of this code um it's auto generated for you but what ends up happening is it allows us to it just makes it really easy for for us to interact with subgraphs and it's part of what makes subgraphs so so useful and also um that kind of you know that data you won't really have to look into but you might have to understand it a little bit and now we are kind of going back to well yeah there's there's three topics here that i want to talk about the three three previous ones i talked about in the docs we also have the schema right here so this is simple it's just a single gravatar so this is like an identity that somebody's storing on chain and you know it only has four fields these exclamation marks it's part of you know graphql's um language but that just means it's a required field you know if i removed that it means that could also be set to null but uh those are things you can learn from graphql documentation or also reading a little bit of our documentation and if we go into the details here so this is the mappings that i was talking about before and essentially what this you know what this line says is hey this event um luckily like we're we're basically importing these events and the this is the entity we made in the schema right here gravatar it's getting imported from the generated code from schema and we're getting these two events which are generated from gravity which come from the json file here um updated so you see there this is basically we have this event right here updated gravatar we just ran yarn code gen and that created these uh events right here so now whenever you go like this event dot params parameters uh you can see all the event parameters like display name id image url and owner on this object that you have imported and if you go to the contract that's exactly the names of the contract event parameters right here so pretty straightforward we have a very simple object we're saying this event happened on chain let's handle it and whenever that happens where somebody created a new gravatar so we're going to make a new gravatar and assign it its id so whenever you make an entity in the graph it has to have a unique id and that id also has to be a string so that's why we do two hacks which is just changing it to a hexadecimal string we store three of the event parameters as fields on the gravatar and then we run gravatar.save and gravatar.save is essentially like a saving to the subgraph store so that entity is now in there and what's interesting about a subgraph is we can now load that entity in the future so we actually have another event here updated gravatar and we're going to handle whenever that event runs so we there's a possibility whenever it's updated that it might have already existed so we take the id and then we go gravatar.load so now we're loading from the subgraph store and we're going to get all that data in the scenario that for some reason that gravatar didn't exist it actually whenever whenever load is run it will either return the entity or it'll return null so in the scenario that it returns null we'll just create a new one otherwise the sub graph would actually have an error and it would crash when you push it to the hosted service and you would have to debug that but we have it we're working right here and these three fields we we set them again and then we save it as well so this is a really simple subgraph um and that's kind of that's kind of the gist of it if if there's any questions here it would be a good time to ask but if not i will i'll deploy it to the hosted service and we can look at what it looks like there perfect um so if you remember we were back here we've already ran install and init and now it's asking us to deploy and i already did run authenticate so now i'm going to run this command graph deploy so right here what we're doing is we're essentially deploying it to the hosted service and yes the hosted service is our infrastructure in the cloud that you can push to and a sub graph will be there you can see these are basically our our ipfs endpoint and our node as well and we're just going to play and we just have to give it a give it the gravatar sorry give it the name that we gave it up here so if you look here um my github name slash gravatar basically you just have to do that and run graph deploy and i'll go ahead dave we got a couple questions from youtube perfect um the first one is in the subgraph manifest is there a way to map over many say 100 erc20 tokens and listen to transfer events from them without manually adding each token's contract as a data source that's the first one yeah there actually is um best place to show that will be the docs so yeah that's a good question it's something that we call templates or data source templates so exactly what um the question is saying it's like well yeah maybe you want to um look over 100 erc 20 contracts or maybe even a good example is uniswap they uniswap is constantly creating a contract for a pair of tokens so it's like there's there's thousands maybe or hundreds i'm not sure of similar uniswap contracts that are all created by the unit swap factory so in this scenario like like if you wanted to do a hundred uh erc20 tokens picked at your like randomly at your own for your own choice you might have to um there's you might have to copy paste them but like usually the the pattern that i see it on chain is something like the unit swap factory where you can just basically source the factory and then watch for every time there's going to be an event emitted that a new pair has been created a new contract on chain by the universe 12 factory and then you just start it'll will write this simple code and it'll actually track all those so this this is just an example um in the docs i'll go over very briefly so data source for the main contract this would essentially be like the factory contract um i think the this the example we're actually using here is uniswap v1 so you know there was a factory on mainnet this was its address and then there's this event that happens called new exchange which is basically a new um smart contract being deployed on chain to trade two tokens so that's what you do for the factory and then if you notice here um i'll even copy paste this so you can see it in like the manifest um or in india's code so it's actually like we have data sources as well as templates so what a template is going to do is essentially we create this thing um it's auto-generated in the code i can show you a brief example here although it'll just be me kind of like um freehanding it but essentially you're saying there's this template which is like um in this case it's a uniswap exchange it always has these four events you pass it the abi and then what you'll end up doing is something like this i'm just kind of like freehanding it but you will you will auto generate that code and it'll come from like up here and it'll just be like template dot uh bind and it'll be like whatever if you created a new exchange um on chain like in the unit swap example you would do like you would take that event parameter and you would take that new contract address and what you're actually doing here is you're binding to this template which is like a uniswap kind of trading contract binding it to the new address and what you've just done is you've told you basically told the graph node to add another whole like data source so yeah it's basically it's 100 impossible to do that um and it's actually very useful i mean we've seen like uniswap itself ends up having like like right now if you swap v2 it might be around like 800 or something different data sources that that single sub graph is tracking so you know there's so many events coming in through that uh through that single through that single uh subgraph and we use templates for that i think was there another question it was sorry there was it was from morgan saying how would you run slash test this locally i don't know exactly when that came in so it could have applied to some things that you've talked about um yeah maybe walk through some basic instructions for for running test um test locally yeah that's that's a really good idea too um so there's this i'll actually run through it here in the code how we would do it and then i'll hop back to where i was in the in my browser and it'll all work out perfectly um so we have this thing called graph ts graph typescript and it's automatically imported when you do graph init and it has a logging kind of like basically like console log kind of debugging for your um sorry there's that file for your subgraph so here we would go import log and maybe it's smart if i quickly go to the documentation and find where we have that login and debugging so yeah under under uh docs assembly script api login debugging this kind of explains how it gets used um i could go into more detail but it's basically just i think it's easier if i just do it and do it right here um essentially it's just a string it's just kind of similar to what's done in rust and then you show up every time you show these brackets it's gonna show the value right here and yeah and everything has to be a string so if we just go event.params.owner and we go like that so we'll actually when i deploy this we'll actually get to see it so sometimes what might happen is yeah you'll run a sub graph and you'll deploy to the hosted service and then it fails and you're not really sure how so this is a really good opportunity to use a graph log and we're going to actually see this info message now when i deploy it to the deploy to the hosted service so i already if you guys remember i ran this command um i'll do it again it doesn't so now that i'm running it again it's actually going to um deploy a different subgraph but let's see what happens so then now essentially this sub graph is what i deployed and now it's actually being indexed by our graph node in the um in the cloud and this is kind of like how you you use this is the this is the playground right here and you can use this to kind of inspect your data uh very easily and then you know you're we're on the left side here you're writing graphql queries to see what kind of data you're getting returned so as you can see like this is data that's on uh ethereum on this contract and it's basically like a couple of people's identities that they made or gravatars so they have like an image url um their ethereum address and their display name and some of these are you know more readable and then they have an id it's just 13 14 12 11. so this is kind of like you know it's a very simple example but it's really rich in when you get into more complex things and so if if it actually fails what you would see is um you know this will say like sinking failed and it'll be red and the best way to debug that is to go into the logs and so now this is kind of like the logs of the graph node and it should give you details on on why it's failing so this sub graph is not failing right now it looks all good um but if you had an error you would you can you can start to like decrease the logs to okay where am i warning only show me warnings or only show me errors and then it'll give you details on on what the error is and at that point you can actually um you can actually see those errors and like determine what they are so something that's going on right now i wanted to show the so i was going to show the the log info in the actual in the playground so i wanted message to be displayed to be showing up over here the thing is it's it's syncing um very slowly right now because it started at block zero and what we can actually do here to try to speed this up i'm not 100 sure if it will work but um i think we had it actually in the documentation so we're here so it might work if i just take this block and we'll see if i redeploy it we might actually get to see those first six million blocks get skipped and then we might get to see that log um message in the subgraph but if not i'll move on um um just one more question saying can you run can you also run sub graphs on private chains um i believe so i'm not a hundred percent sure um i'm just trying to think about it conceptually like i'm almost i'm only 90 sure you can um and if not you can come talk to us in the discord but but i'm also thinking like i know well i know you can run it against ganache because i've done that before in the past so yeah if you're running it against ganache i'm almost 90 yeah i'm like 100 sure that it would work we might have to like give you some sort of configuration but yeah you can definitely you can definitely do that um and so if you see here i'm not sure if uh oh yeah i just saw it there so here we're actually message to be displayed um so i'm logging that that kind of it's coming up as this weird thing because i guess i converted something to a string when it should have been a hex string but essentially yeah so if you know maybe if you're getting incorrect data and you're not sure why you could start logging in a mapping and it'll fail but it'll still print that information um yeah yeah and then you can i was just looking at the chat yes uh and testing ganache does work pretty well um so it also works very well on on test nets like if you're on rank b and you're testing your your uh your kind of smart contracts before putting them on main net it works it works perfectly got one more question um from youtube don't you need to run yarn code to gen anytime you make changes in the manifest adis or schema before deploying um you so what happened there i would say in general almost always yes um what just happened there is i i actually just changed the start block here so it'll still try to deploy if i haven't run yarn code gen and what yarn code code gen does is it kind of creates these these typescript files based off the abi and also the schema so in this scenario what happened is i updated start block this manifest still gets pushed to the um to the hosted service but it didn't actually like changing the start block didn't change any of the code gen uh files that get created but uh the question is a good point because you know if i changed the handlers i would have to change it if i change maybe the abi or the contract address um i might have to change it and especially if i change anything here so like when i when i added this i definitely had to or no sorry no you don't have to run yarn code jen if you're doing this um it's more so just whenever you think anything will change from generated files you have to run yarn code gen but i usually run it quite frequently um if i'm doing a lot of development and i'll even kind of like if you wanted you could uh you could put it before your deploy command and just to be safe because then you'll never because that's that's an annoying bug is when you you don't know why it's broken and all you have to do is run yarn code gen before so you can definitely do that as well it's a good question and yeah thanks and so that's kind of yeah like you can check out the you start digging into the subgraph now the thing about the gravatar slip graph is it's kind of like straightforward and not that complex um and like i said before if you go to like uniswap you can see all of these so this is they've built the schema it has the uniswap factory right the amount of pairs or like exchanges that have been created the total volume in usd and an eth the total liquidity transaction count you get all these interesting things and if you know a little bit more about like graphql you can start like putting other entities as fields on other entities so you have token day data right here and you go into that you have you know the token um the date so this is like basically what token day data i'm not exactly sure but unitswap.info uh this application runs off of the graph so like these charts you're seeing here are actually built with the graph and i haven't um built this sub graph myself like this is the unit swap team that built it so i'm not exactly sure how they did it but it's very interesting to go to like um so if you go to uni swaps github they have this v2 sub graph and this is where you can kind of see a lot more of a rich example of a subgraph in action and they have you know the uniswap factory entity typed out here the token entity for a token on the on in inside a unit swap the pair kind of smart contract that's created for each uh trading between two tokens a specific user and all their positions um and this is kind of minting and burning and swaps um and this is where they probably build like what we're seeing here maybe this is hourly and this is probably pair our data that they're kind of showing and so they're calculating all this data so you can imagine like one trade happens but data is stored for the day for the hour for unit swap total for the user themself for the transaction so like you can get like very very rich kind of subgraphs here and so this is a really good example if you want to look at like some complex uh subgraphs and like see what you can build you know go to use swap and see what they have this is their this is exactly what i was talking about before like they have this template set up so this template tracks a bunch of different smart contracts for uniswap um and then they have like normal one the factory right there and they also have the abis here so like interestingly if you know if i if i were in the hackathon and i wanted to build an ethereum kind of or no sorry a uniswap subgraph i might go to there go to their um github and find what i want to download and you know this is one of the apis they have for pairs so you would um you know go copy this that's not what i want [Music] so ah i wish there was an easier way to get this there we go so copy that um you could use like the graphic example so this is what i did with graphing it right kind of like boilerplate basically replace that uh rename it to pair and you know now i start updating my sub graph so that we can actually or maybe like you could i mean if you really wanted you could just what i did there is i took the pair and now like uh code would be auto-generated from here when i run yarn code gen but also it's like for sake of for the sake of like time um if i really wanted you know you can just start going like this and you know copying all this kind of code over and you end up building your own sub graph now it's not that i mean it's not that simple to like just copy paste and and make it work but when it comes to like the subgraph manifest sure you could like if you're finding the right contracts you want but maybe you want to do something different with like uniswap so you know that they have all this like trading data like this maybe you have some other idea of how you would want to display the trading data maybe it's like like they don't like uniswap doesn't have very rich like user kind of charts it's all um specific to like token trading so that's even a good example right there is like you could analyze all the uni-swap data and maybe show like um an analytics site for somebody who uses uniswap a lot and it'll show them like their daily trading amount and how much they've earned and how much they paid in fees and stuff so i mean that's just one idea right there off the top of my head but you can kind of do this for um you know so many projects out there like you could do it for compound um decentraland like like some of these projects that have a lot of actual like on-chain activity uh ave so i mean like a lot of these like you know this is the ave protocol sub graph it's more about their it's more about how their protocol works and like you know they probably use it for their front end somewhere but once again you could make like a user specific of a sub graph that allows you to log in with like an ethereum address and see all the transactions you've made on ave and that would actually be really cool so that would kind of cover like that's what we're talking about when we're saying like best new subgraph now i mean you could make a subgraph for your own project too um that that you've been working on for for a couple months um and so that would be really cool and then obviously the best use of a subgraph is just like actually using the uniswap subgraph in your own front end i mean you could for another example like you could take compound and uniswap and um ave you know three really popular d5 protocols and then like combined all three of those into some sort of front end and make like a really cool d5 front end for users as well um i also see there's another question right here so i'm almost done um i'm just going to read this question really quickly since you can also index ipfs data i'm supposed to pin the content on one of your ipfs nodes so the graph can resolve it quickly which of your ips nodes shall i connect slash ask to pin content to docs are a little thin on that yeah um i it might not even we might not even explicitly mention it in the docs but essentially um where's the deploy oh it's in quick start oh no actually i don't no i remember where it was um if i just create a new sub graph right now um if you look at the deploy command it shows right here like when you're running graph deploy um you pass this and you basically say uh ipfs and this goes api.ipfastofthegraph.com and when you push it to that endpoint what it's essentially doing is uploading to our own ipfs node and yeah you'll also see that that gets auto-generated right right here in the code as well so if as long as you just push to there it will be on our node and then it'll actually index that data um for sure you want to do that because if you or if you don't um or actually i'm trying to think in my head yeah it's possible that uh if you don't like if you have your own ipfs files and you just uploaded them like it was like profile data or something and you just uploaded them to your own ipfs node and then it was like connected to ipfs but it didn't propagate through the ipfs gateways very well it's possible that our ipfs node will not actually pick it up and then it'll just basically kind of like time out and you would that data won't be displayed in the subgraph so if you run into that scenario um come chat to us in our discord and we can definitely help you with that because it's just a matter of like getting our ipfs node to actually find the files and it can happen that it might not propagate there okay perfect um so yeah basically come talk to us if that happens and we can definitely help you uh and so with that i'm pretty much done i mean i i deployed the subgraph not that one um i deployed subgraph i showed you guys kind of like a a little bit of a cooler example with uniswap and and gave some ideas there and and went over the documentation so kind of close with the prizes there and and what we're hoping to see so um i guess if there's any more questions let me know right now and if not just uh you know either go to the east global hackathon um i'm i think you guys have a discord channel and if not you can also come to our discord channel and ask questions but if there's any right now i'd be happy to answer them we've got two from youtube the first from sahaj can you provide a quick example if possible if you have a user address what how will you go about getting data on if they are using certain protocol and value in it it's a little bit of a confusing question um did you get what the general gist of it was though yeah i think i think i do understand um so essentially like i i hope i i hope i follow what the guy saying but i think what i one of the suggestions that i made was kind of i was like oh it would be cool if you use uniswap and compound um and and like ave and went and looked at like a user profile perspective um and like show them how how they're doing like in all those protocols and that would actually be very very complex maybe a better example would be to just use like just unit swap by itself because um like i said unit swap that info shows more like the protocol level stuff maybe you could show account level stuff so what would happen is essentially like here's uh here is unit swaps kind of like template for events that are emitted on chain and if we go to that's like their subgraph manifest right if we go to the mappings for uh core maybe i'm not i'm not 100 sure but yeah mint event um so what's happening here is like this they're making like this is a i'm trying to okay a handle i'm just looking for okay yeah here so this is like when some somebody mints like a liquidity pair on on the unit swap kind of protocol a lot of this stuff is like uniswap protocol base for like what's happening in uniswap but if you wanted to figure out from like a user perspective you'd start doing it you'd probably make the id like event.params.center so all of a sudden instead of being like kind of like like i would say like the the first class entity in the uni-swap subgraph is like an exchange um and you're looking at how many trades are happening on that exchange but in this scenario um i'll try to open this again over here in this scenario like we want to think about the the uh the end user as the first class kind of um the first class kind of like entity so right here we're seeing all this rich data with tokens and we're making the id the token address now if we go here i think they have a small user identity right here but instead of this like what they're doing like you create the first class entity as a user and you think about your subgraph in that perspective and then you start saying like you start like recording all their trades and then in here you'd add another line like uh trade and then you might start recording like it'd be hard to do but recording like the profits of each trade that you could make and so basically yeah it starts from kind of like what you're treating as like the main entity in the subgraph and so you would and the way to do that is first like think okay their ethereum address is the id i want to use and then you start treating kind of all the event data um through that lens and and that should be able to give you kind of an idea i hope that answers the question got another one from morgan will it be expensive to query subgraphs once the main is launched yeah it's that's a great question um essentially what we're looking at there um like right now the hosted service is basically free to free to run and we've been doing that for the last like two years or whatever and whenever the network launches there'll probably be like some sort of like like grace period where we're still running the hosted service and then we're we're allowing the network to run where people are paying for queries and realistically it should like the whole design is so that it should be like economically viable and the queries will definitely be like fractions of a cent um but the idea is also that these people that are indexing the subgraphs will make some money so i would expect it to be fairly fairly cheap still when it when you compare like to running your own kind of like infrastructure in the cloud whatever you pay there um it should be something like around that price but at the same time we're still figuring all that out and we're also expecting like like if you've ever dug into our protocol where we're doing some stuff um um to like basically batch like like transactions and stuff and queries with like state channels so um what we're what we might actually see is like some dapps paying for there for their users queries up front so like if you're if you're like dharma and you use a sub graph you might just be paying these fractions of a cent for all of your users and at the end of the month it costs them um you know a thousand dollars for all these queries for all their users but also if they've like created their own subgraph and they've curated on it you can actually earn rewards in the graph network so it's just part of the whole like economics of the network um and that's something that we're we're working on and we're excited to uh to uh get when the network comes uh live awesome yeah there's another question from anne mall and then one from fox and then maybe we'll call it after that yeah sounds good okay great so and we'll ask in general can we index data from other sources apart from ethereum and ip ipfs like ceramic um yeah that's a great question right now we do not have anything else basically what there is is ethereum and then all ethereum like test nets a couple of other chains like i'm trying to think like i know x die is possible um poa network is possible and then there's maybe a few other evm chains it's also really easy to add support for those ones we also do have ipfs we are like we do have plans to go multi-blockchain in the future so you know could be like ceramic it could be polka dot it could be something like that like like there's nothing um figured out in that domain yet um because we're really focused on launching the network right now um but definitely like that's that's part of our whole entire like goal is to get multi blockchain in the future so it's definitely something we'll be looking at after network launch awesome um it looks like fox actually has a couple questions so i'm going to suggest that foxy reach out to dave in the discord channel just so you can dig into those ideas a bit more keeping an eye on the time um yeah okay thank you so much dave this is a kick-ass presentation awesome thanks so much for having me and yeah come come chat with us in the discord thanks a lot guys cheers thanks everyone bye 