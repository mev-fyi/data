great welcome everyone uh we'll be starting now emily will be uh giving a talk on developing smart contracts in sway um if you have comments please leave them in the chat and then we'll get to them at the end uh without further ado you can go ahead thanks for the intro let me uh share my screen okay uh hi everybody my name is emily herbert i'm a contributor at fuel labs and today i'll be introducing you to fuel and introducing you to how fuel is the fastest modular execution layer what is a modular execution layer well currently in this space we're seeing that traditional blockchain infrastructures are limited by the amount that they can scale throughput in particular we're seeing that l2s while they do offer a margin of cost reduction for access to the ethereum ecosystem we're seeing that the throughput increase that they provide is modest at best and then what this manifests as is that when there's high traffic to the ethereum ecosystem l2 struggle to keep costs low and a cost for a single transaction may rise to several dollars and i think ultimately what we can say is that if we want to spread the global access to blockchain we need to solve the scalability problem at its core at fuel we believe that the fix to the scalability problem lies within the modular blockchain what is the modular blockchain well in l1 blockchain infrastructures there's an ongoing colossal shift from monolithic designs to modular designs a monolithic design might see the different layers of the blockchain infrastructure being data availability execution layer and others all being coupled together by the same technology but a modular design would see each of those layers being handled by a different technology what this comes out to is that when you have a modular design and each of these layers is handled by its own technology each of these layers can be specialized to increase throughput and to achieve better performance with a modular infrastructure to make this more concrete here's just a little example of what this might look like so here on the left we have four layers that would be present in a blockchain infrastructure we have data availability consensus settlement and execution and then here on the right we have an example of a monolithic and a modular blockchain infrastructure in the monolithic blockchain infrastructure we see that each of these layers is handled by the same technology which in this example is the gear emoji but you can think of this like ethereum ethereum would handle the data availability all the way down to the execution but in a modular blockchain infrastructure these different layers are handled by different technologies allowing each layer to be specialized so in this example the data availability is handled by the rocket emoji but you can think of this being a technology like celestia the consensus and settlement layers are again handled by the gear emoji in this example so this would be ethereum and then in this modular blockchain stack the execution layer is handled by fuel we can see here that fuel at its at a high level is an execution layer for the modular block chain but at the beginning i claimed that it was the fastest so what makes it the fastest well this is derived from the three core fuel pillars uh these will be number one parallel transaction execution number two the fuel virtual machine number three a superior developer experience i'll talk about each of these needs pillar number one is that at its core fuel uses the utxo based parallel transaction execution scheme under the hood what this means is that fuel can take advantage of parallelizing over cpus and threads cores and threads on your cpu and is no longer limited by single threaded predecessors that we've seen in the past and ultimately this design decision allows fuel to be the fastest module execution layer pillar number two is the fuel virtual machine otherwise known as the fuel vm the fuel vm is the executing component that interacts with fuel the fuel vm is designed to learn from its predecessors and learn from the mistakes of the past and learn from modern blockchain paradigms that you and i know today and ultimately the design of the fuel vm allows it to strip away needless computation and wasted resources and offer a very specific blockchain optimized virtual machine pillar number three is the superior developer experience that fuel provides with sway and with fork sway is the smart contract language that runs inside the fuel vm and fork is the tooling around sway that offers the elevated developer experience both soy and fork are in active development right now so now i'm going to talk more about sway and fork and then at the end i'm going to show an example of how you can get started using sway and using fork as your entry point to the fuel ecosystem the best way to introduce sway is to talk about the existing technologies that we've seen in the past so currently if you want to write a smart contract one of the more prominent languages is solidity solidity was written for the early ethereum virtual machine it feels kind of like javascript and it has a lot of domain specific elements that'll allow you to do blockchain specific development so this would be allowing you to write first class contracts allowing you to use contract storage as a language construct and more but solidity has some issues so for one the solidity docs don't necessarily tell you tell you how to do a contract end-to-end there's fragmented fragmented ecosystem and tooling around solidity and solidity lacks many critical safety guarantees for example if you write a smart contract in solidity that could be subject to re-intrinsic bugs and you can also get a stack too deep error and more so i think that ultimately at a high level what we can say about solidity is that it works but because it was developed for the early evm it wasn't developed with the knowledge of the blockchain paradigms that you and i know today fortunately this type of problem is not unprecedented and what we've seen in the past is the transition from c plus plus to s so c plus plus is a systems language that provides the user with a lot of power in manipulating memory itself but in doing this it opens up the domain of bugs to include memory management bugs in response to this the language was developed called rest rust offers much of the same um systems level contributions that c plus offers but one of the features is that at a language level it manipulates the system memory itself to prevent a lot of the domain-specific systems bugs that were present in c plus plus so this includes use after free indexing outside of an array of bounds etc and what we're finding is that people really like this about rust but there's lots of other things that people like about rust this includes the superior developer experience the unified tooling the team organization and much more so that brings us to sway at a high level sway learns from both solidity and from rust and combines both of these languages in its own approach to develop or to provide a superior development experience in particular sway takes from solidity several different things so sway is domain specific this means that sway allows you as a user to write first class smart contracts it has first class blockchain support it has contract storage as a language construct and it has shareable contract interfaces so i learned from rust and that sway feels like rust it has static types with trait-based inheritance it has a verbose and friendly compiler it has unified tooling and developer experience and team organization sway is also written in rust under the hood meaning that it's fast and efficient and easily audible so what do i mean by sway feels like rust well inside of sway you can do a lot of breast like things so what we're looking at here is all sway code and we're going to go through some examples in sway you can create variables with the let keyword you can create mutable variables with a mute keyword and you can add type descriptions with this type of description syntax this way you can also have functions so here we have our function equals that takes two arguments a and b it compares a and b and returns a boolean if a and b are equal in sway you can have if expressions and by expressions we really do mean expressions and what this means is that if expressions can be both in a statement location syntactically as well as an expression location syntactically so here on the left we have an expression we have an if expression that returns a different number depending on the value of foo but then on the right we have an if expression that does a variable a conditional variable assignment depending on the value of food so i has match expressions and match expressions are similar to if expressions and that they can be in multiple places syntactically you can think of match expressions like uh a switch statement or if you were in solidity this would be a chained if-else statement but in sway we actually have magic versions so here on the left we have a match expression that returns a different number depending on the value of foo and then on the right we have a conditional variable assignment or depending on the value of foo bar is either zero or one sway has strucks with the company methods so here we have our struct foo that has two elements bar and bars and then inside of the info block on the lower part of the example we have an accompanying method is vagus true that just returns if the baz element from foo is true soy has enums which are actually proper sum types so here we have our enum sale which has two variants product of the product type and service of the service type the product type has two elements sku and price and the service type has two elements name and hourly rate we can see that the enum sale is the sum type of both the product type and the service type soy has generic types and type inference so here is a another struct like we saw on the struct slide but this struct is different in that it has two generic elements so x and y can contain any type that they want to and this is manifested by them syntactically showing that they're containing the type t so we have our struct point that has a generic type t where x and y are both for that generic type t so you can think of this like oh if i want my point struct to to contain u-64s or i want my point struct to contain u-32 or really anything because it's a generic type you can also have associated methods with those generic types so here we have an associated method new that takes two elements a and b and returns a point with x as a and y is b sway has elevated error handling so uh we can see here in this example that we have this enum result the result enum is a is a type in sway that's used to represent either a success or an error so the result enum has two variants okay and error the okay would be used in a success case and the error will be used in an error case then in this function withdrawal we see that the control flow either returns this success case which is okay or returns the error case depending on what the control flow what happens with control flow so we can see in this example that we're trying to withdraw an amount from our account and if we have that amount in our account or in our balance we're going to be okay and the transaction will succeed and we'll return an okay but if we don't then the transaction will fail and we'll return an error what this ends up manifesting as is when you as the developer are using errors inside of sway the compiler the sway compiler will force you to handle the errors appropriately and successfully before you can deploy your contract this eliminates any of the issues that you might encounter with unhittled control flow and allows you to be confident that your code handles all error cases appropriately and also success cases appropriately what do i mean by sway is domain specific well in sway there are specific primitive types that allow you to do blockchain specific applications so this includes unsigned integers booleans static linked arrays 32 byte values single byte values and the unit type soy also has tuple types for you to assemble these primitive types and user-defined structs and enums that we saw previously as well as generic types across structs enums and functions soy has first class contracts and when you write a contract display it'll look like this so there's two main components here and the first is this defined this abi definition so to create a contract you'll define an abi here we have abi simple auction which has one function bid then we can have then in the second half of the example we're implementing this avi for a contract in sway and then when we do that we're going to implement the function bit so when you're defining a contract in sway it's these two components it's the avi definition then implementing the contract with that api definition where you actually implement the functions that are present in the api in sway you can call contracts so if you remember on the previous slide we have our abi definition which has the function bid and then in this lower example we're going to be calling this function bid using the abi so here we have our contract address that we're defining to be a b 256 value and then we're using the abi keyword to say i have an api called simple auction at this contract address i'm going to create an instance of this in sway and then i can actually call those associated functions inside of sway from that contract address what this means for you as the developers is that uh because these abi definitions are defined and separately they can be exported and imported like libraries and they're shareable so you can uh share these apis across different contract implementations like libraries soy has contract storage and this looks like and it looks like this so to use contract storage you will use the storage keyword so here we have the storage keyword where we're defining that the contract has one data element called data in its storage which is 64. then in this function is where we're actually going to be accessing the storage so in the simple function simple storage function we're taking an amount we're setting storage.data to that amount and then we'll return returning storage.data you can see here that simple storage is decorated with this annotation storage read write and in sway these annotations let the sway compiler know that you'll be accessing storage by reading to it and by writing to it so you can use these annotations to let the compiler know that storage will be accessed and this means that the compiler can offer you specific guarantees about how storage will be handled and can perform underlying optimizations on your behalf there's a lot more features with sway but i don't have time to discuss them all so if you're interested in learning more about the language you can go to our website field.network and then navigate to the swaybook but at this point i will be going through a quick example of what it's like to write your first smart contract this way and what we're going to be doing is we're going to be writing a smart contract that counts the number of apples that we have and allows us to increase the number of apples and then retrieve that number of apples to get started we're going to install everything so we're going to install with cargo install fork fuel core this is going to install two different things the first of which is for work fork i mentioned at the beginning of the presentation is the tooling system that allows you to gain an entry point to sway into the fuel ecosystem so a fork will do your project independential management force way uh will allow you to build debug and deploy your sway code to the fuel ecosystem and more you can think of fork as the fuel orchestrator and if you're familiar with cargo fork is very similar to cargo and in fact fork uses cargo under the hood the second thing that this command will install is fuel core and fuel fuelcore is an additional entry point into the fuel ecosystem to create our project we're going to use fork we're going to we're going to call fork init with the name of our project which is counter example then inside of the counter example this will create a counter example this will create a directory called counter example with our templated sway project and then inside of that directory there will be several files that are pre-populated for us for a successful sway project these are four files there's the cargo.tml file if you remember fork uses cargo under the hood so this allows fork to operate successfully then there's the fork.tama file which you'll use to define high-level information about the project then there's the main.sway file which will contain the code for the smart contract and then there's the test harness file which we'll use to test the contract before we deploy and i'm going to go through what some of these look like in the code our fork dot tumble file is going to contain the information for our sway project that will allow fork to build it successfully with the information that we've given it so this includes the authors list the license that we want to use and the name of the project inside of our main.sway file this is where we're going to be defining the contract that we want to test and deploy there's four different subcomponents to this contract so i'll walk through what each piece means at the top we have the contract keyword this allows the sway compiler to this tells the sway compiler that this code contains a contract then we have our contract storage definition with the storage keyword and in this example with the contract storage we're going to be storing one value which is apples to z64 next we're going to define our abi so we have our api counter contract which has three functions our initialize function which is going to initialize the number of apples our increment function which is going to increment the number of actuals and our git function which is going to return the number of apples currently that we have to us lastly we're going to actually implement these functions and implement the avi so we have our implementing avi for contracts and we're going to implement each of these functions so initialize we'll set the number of apples to zero increment will increment the number of apples by n and get will retrieve the number of apples and return that number to us once we've written our contract we're ready to test it one of the one of the developer experience components that fuel provides is it provides extensive rust and typescript sdks these sdks are modeled after ether rs and etherjs and allow you to interact with sway and fork from inside of rust and typescript so they allow you to build debug test and deploy your contracts they allow you to start fuel nodes interact with the fuel ecosystem and a lot more so what we're looking at here is the test harness file that is actually rust code using the rust sdk for sway there's a lot of code on screen but i'll walk you through what it means so at the top we have our sdk imports then below that we are loading the avi from json so under the hood what's going to be happening is the russ sdk that we're using in this slide we'll be compiling the contract that we wrote on the previous slide and exporting that shareable api to json so that we can do the sharing and then it will import that json to this file using the rest sdk so we're importing that json using the abi gen keyword and then the name of our shareable abi which is counter contract and then we're going to run the test inside of the test we're going to build the contract then we're going to launch a local fuel node and deploy that contract then we're going to retrieve the contract instance and then after that we're going to call the functions that we defined in the abi and we retrieve the number of apples and check to see that the number of apples is what we expect it to be looking at the lower half of this we can see that in this particular test case we are initializing the number of apples so setting it to zero incrementing by 99 incrementing it by one and then retrieving the number of apples which we should expect to be a hundred when we're ready to run the test we can use fork test this will compile the contract and then we'll run the test that we defined and we can see here that our test succeeds and we're done we've just written our first project with sway that interacts with the fuel vm and the fuel ecosystem well you know what if we make a mistake what if we have a bug or we have a typo what if something goes wrong well the sway compiler learns from rust in that the sway compiler is both friendly and verbose what this means is that the sway compiler can detect many programming errors as well as blockchain specific errors and will automatically analyze those for you before you deploy your contract during compilation for instance sway this way compiler can detect uh if you have a match expression that's not exhaustive so if you are using a magic expression and you're matching on a tuple for instance if you don't consider all the cases for that tuple and you haven't considered all cases of control flow for that match expression this way compiler will fail to compile and we'll let you know which cases you need to implement for blockchain specific errors one example is that right now in sway we have the ability to there's an experimental branch which allows you to analyze your code to see if uh your your smart contract will be susceptible to re-entrance ebooks so this way compiler will do this for you and then if it's found that your smart contract is susceptible to reinsured bugs this white compiler will give you a warning that it feels that you've created a contract that might be susceptible to this wrapping it up at a high level today we've talked about sway and fork the fuel vm and fuel but there's a lot of stuff that we didn't get to cover so in addition to providing a superior developer experience with the elements that we saw today fuel also provides fork which is the sway tool chain friendly compiler filting testing infrastructure those extensive sdk that i mentioned an extensive standard library a vs code plugin with automatic save automatic format hover go to abilities a language server that we've had since may 2021 and a built-in debugger gas profiling and code coverage which are all working products so wrapping it up i want to let everybody know that we're very excited to introduce the fuel online hackathon so we would like to introduce the beyond monolithic fuel online hackathon that's happening at the end of this month may 27th through may 30th and you can win up to 100 000 in prizes during this hackathon we encourage you and invite you to use sway and fork to build an exciting product where you can win money i would like to thank all the uh fuel contributors without all the fuel contributors we would not be here where we are today i think it now at this point we have upwards of 40 field contributors which is very exciting thanks everybody uh if you are interested in learning more you can go to our website fuel.network if you would like to connect with us on twitter you can connect with fuel this way or with myself so thanks great thank you that was great uh i thank you for joining us as well uh there are the social links right there but you can also find fuel on the youth global discord channel uh it's under the sponsor link fuel um we do have two workshops going on today still as well connect navi um but this will be available on youtube so if there's any questions bring over discord twitter or anywhere else thanks everyone thank you emily 