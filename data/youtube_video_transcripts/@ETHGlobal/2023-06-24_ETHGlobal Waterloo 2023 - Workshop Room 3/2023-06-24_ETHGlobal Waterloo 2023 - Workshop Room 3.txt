thank you so now on my screen we should keep going so is there any uh room that there's internet in that I can just plug in my computer and let it show that or is it just the workout rooms right now on the front desk um I'm trying to watch the screen shoot somewhere yes or even in that room that you guys hearing yeah we can hook you up there's a couple different places the third floor you probably don't want to go all the way up there yeah even the ab uh okay yeah is that there was one on here yeah okay maybe it's my adapters were you in Tokyo I wasn't in Tokyo unfortunately the show like I was like okay like Japan for like two months everything detailed yeah system diagrams of every cable and I got there like everything set up that's amazing I think it was really like a testament to like how people speak about their work yeah Epic do you guys have like a an in-house networking team is it you work with people for Wi-Fi we have someone that connections with us he's not part of the team okay it's just like me but I kind of hire a team yeah yeah that's kind of the case for most of us required no it's super impressive it's like eight hours of crows on a Monday afternoon no one would notice yeah exactly you know it's like oh yeah actually I would work on the project yeah test S as well uh yeah um foreign usually I promise me it's like do you want to let this USB device connect Ed this one I actually don't have it's definitely the connection here okay try this one again I thought I had ethernet before when I was trying again okay um I might have just have a good luck on the Wi-Fi you can always log in from my laptop if you if you just want to start playing live stream oh I need to start a difference oh nice I know you're doing right yeah yeah I was going to do live demos too okay self-assigned IP there we go so I've got a self-assigned IP which I think it means I can't check I can try manually doing a DHCP and it shows that it's there it shows that it's there but it says something's trying to trying to trigger sounds good you didn't hear from me though the guy's gonna track me down yeah yeah let me see if I can do it looks so small access all right okay I've got Wi-Fi from somewhere yeah test this out with this so This sounds good now testing testing sounds good yeah um Wireless 1021.7 okay I get an idea okay so it must be uh adapters just so you see I get a 10-0 can I steal that ID 10 20 it won't it's DHCP I can give you this I can assign you one yeah because I think I can I can manually 10 20. zero 101 okay that's all you guys I know why that's assigning at 248. so that's right that's a 16. okay yes we're good actually let's see we got a self-assigned IP ad a static address okay 10.20 dot zero Dot 100. it's 255-25.248 router is ten twenty zero one try that give you DNS it looks like it says connectors I I have a nice okay we're good yeah perfect weird I don't know what quality yeah I think I'm I think I'm using let me just double check I think I've got it looks like it's a Santa made DNS server okay I'd put one in in case yeah there's double check it still works okay it doesn't work with the custom teams okay I hope I didn't forecast I wonder if you work uh work connected some something um and ping ten twenty zero one yeah I'll talk one more time I want to make sure sounds good I was the Wi-Fi was doing okay for me okay I should be doing better now yeah oh is that oh perfect yeah that works all right are you guys still ready uh yeah I think we're I think we're good I'll just I'll run with the AP I'll plug this in just in case it's working okay yeah they're probably just a dongle thing not a big deal cool all right foreign [Music] include t-shirt okay okay is it all good yeah they're good let me see plug it in via HDMI it's gonna work perfect amazing awesome well thank you all for coming uh this is a talk on building with erc6551 it's going to be a little bit technically in depth it's going to do we're going to chat a little bit about what erc6551 is um what you can do with it and then we kind of get hands on into how you can use it in your hackathon projects this week um so yeah obligatory intros I'm Jaden I'm one of the developers at Future Primitive which is a web 3 Venture studio if you want to ping me this weekend for questions about erc6551 that's my Twitter DMS are open feel free to ask um would love to help support anyone who's building erc6551 related things uh yeah we're feature Primitives we build all sorts of crazy experiments with tokens so we do we've done a lot of experimental nft projects and erc6551 is a proposal that we proposed based on a lot of the work that we've been doing on trying to push the bounds of what can you do with nfts how can you give nfts abilities Beyond just being an asset that's stored in your account and let them do things um so we've been doing a lot of crazy experiments with that and erc6551 introduces A New Concept called a token bound account erc6551 gives every single nft that's ever existed or ever will exist its own wallet your nft has its own unique wallet address and that means it can own other nfts it can own e they can own erc20s your nft can now own things natively because it has its own wallet address it also means that you can use your nft to interact with applications because your nft has a wallet your nft can now do anything on chain that a wallet can do so you could connect to openc and trade nfts as your nft your nft would own other nfts that it buys and sells and trades on openc or you could trade Bitcoins you can you know vote on proposals anything you can imagine doing with a wallet your nfts can now do too and this works with everything like these addresses you can see on my screen are real token bound account addresses for real nfts and I'll show you that real quick so one thing if you want to start playing around with erc6551 that's really easy to do is if you want to see the tokenbound account address for an existing nft it's really easy so this is the Genesis crypto Kitty this launched at eath Waterloo six years ago was when crypto kitties launched that's the one of the first nft projects so this is a really old nft nobody's you know touched this nft contract in ages but this nft has a token found account via erc6551 and an easy way to find that is to just replace openc with tokenfound.org for any nft any erc721 nft and you'll find whoops I got a deal with viewport sizes or something oh here we go there we go um this is the nft's wallet address this is a unique wallet Associated only with this nft and this wallet can only be used by the owner of the Genesis crypto Kitty you can think of it like a token gated Nosa safe wherever the nft goes ownership of the wallet goes to so you get this NF this nft owns this nft via a tokenbound account and so for any nft you want to see the token amount account of you can just replace openc with tokenbot.org and you'll find it um so yeah every nft from cryptic kitties onwards to the project you launched this weekend it comes with a wallet that means you can make assumptions that nfts can own things that nfts can do things which is some really powerful things you can do in projects You're Building um and she's also had their own transaction history which is kind of cool you can see all the actions that nft is down on etherscan so here's how it works so erc6551 proposes a couple of new smart con it proposes a new smart contracts and a new account interface um inside the EIP so what you're saying here it's kind of like it'll expand as we go through it but you're used to nfts existing on chain right so nfts exist as a smart contract there could be many nfts in one smart contract and usually if there's a user that owns the nft right so in this case we have a 721 contract called nftb and there's a token with id456 and so this user owns nftb number 456. we're used to that every everybody's kind of aware of and nfts are owned by wallets uh what tote what erc6551 introduces is a new smart contract called the erc6551 registry and this registry is what gives every single nft its unique address you can query this registry with the token contract and token ID for any nft and get back a unique wallet address that will be owned by that nft so the registry is a single entry point you can query for all of that data and it works with any nft the registry also deploys the smart contract at these addresses so these token bound accounts are really smart contract wallets that are owned by by the nft and that ownership by the nft owner is enforced at the Smart contract level so when you ask the registry for an account address for your nft it'll give you back an account address that you know will only ever be owned by that nft and so nfts can know multiple accounts in this case you know token one two three on contract a owns two accounts token 456 on contract B owns one account and this account is managed by the holder of the nft so this user owns token 456 that means that they have full root execution permissions on the account they can do whatever they want with it they can use it as a wallet they can do anything you can do with a wallet but if they ever sell this token everything in the wallet goes with the token so when you sell the nft all of the things you've collected in the wallet go with it because it's really the nft that owns the account and then the final piece of this is the implementation every account is really just a proxy to an accountable limitation that implements a very minimal interface and that you can find all that in the EIP but essentially the EIP provides a registry that everybody can query for account addresses for nfts and then it also provides a very minimal interface for implementations um so that's it works on every evm chain wherever you're building as long as it's evm compatible you can use it you can also permissionlessly deploy that registry to the canonical address um it's fully decentralized like we don't own it it's in the IP you can go nuts deploying it and it works with every nft on every evm compatible chain and so you can now build applications assuming that nfts can own things to do things from day Zero um there's been lots of people who have been helping us build this out this kind of originated into projects we were building on but as we've started to speak with other folks and started to collaborate with other teams this is a list of a couple of the other companies that have been involved in helping refine the standard or building on the standard or we've got a working group of like 700 developers who are building on erc6551 if you want to join our questions it's available to you this weekend so um yeah what you've seen already there's a bunch of tooling that we've been building around erc655 well that that kind of core concept of nfts having wallets that's basically all you need to know to work with erc6551 you don't need to do anything special on your nft contracts you can launch the most normal vanilla off-the-shelf template nft and it will come with a wallet and so that's all you need to know all you need to know is your nfts come with wallets now and there's a few ways that you can interact with them one way you can interact with them is via the tokenbound Explorer so you saw this earlier when I went to tokenbound.org when I replaced openc URL you can see that on the tokenbound Explorer the address for any NFC so if I go back to this tab here this is the cryptokitty I I don't happen to own this crypto Kitty but if I connect my wallet and go to my nfts you can see a list of nfts that I own on chain and so for any of these nfts I can go in here and I can see the account contents of the NFC um this is an nft project that we released called sapiens which is one of the first collections to use this natively but what happens is this at sapiens nft owns these three nfts and these three nfts are actually clothing items that the nft can equip so you can see this background is an equippable item and this nft has that background equipped onto its artwork that's possible because this nft owns this background token but what's really cool is you can use this nft can own tokens that are from other collections too so this and this nft is not part of the clothing collection that we released this is from a separate collection but you can also equip this nft as a piece of clothing onto your sapiens nft by giving nfts wallets we let nfts own any assets and you can build on top of this crazy composability layer like you can send any nft you want to into another nft another example here if I go and show you um this is someone who's sent a whole bunch of stuff into their sapiens nft you can see this nft owns azuki and it owns a doodle and it owns a moon bird and owns a crypto Kitty and this just works out of the box because the nft has its own address and can receive any asset um sorry I gotta fix a bug in the the renderer Apparently on this page but that's the erc6551 Explorer you can go there you can connect your wallet you can think of it like eat like ether scan for tokenbound accounts for any nft you can find its wallet address you can see it here and that'll link you off to etherscan where you can see all the transactions it is done it'll also show you everything inside the wallets and if you own the nft you can transfer things out if I click this I can transfer this nft to any other world I can use this like a wallet through the tokenbound.org interface um so that's one place you can go to start building on top of talk about accounts if you want to link out to this in your projects this is kind of like a good default place where people can play around with broken bound accounts but there's a hackathon so we're going to want to build some cool interesting new custom stuff this weekend so we have a lot of tooling we've built to help you with doing that um the first and foremost is a tokenbound SDK so if you go an npm install at tokenbound SDK that's the GitHub repo tokenbound SDK this is probably the easiest way to get started building front ends with erc6551 you're just an npm package away and you can query for the address for any existing nft you can deploy the smart contract at that address and you can interact with a smart contract at that address if you're the owner of the nft so you can build all the experiences that you see on the tokenbot site you can build those into your dap and you can kind of build experiences on top of these wallets and use them as an additional wallet inside your dap um so I can actually show you real quick let's see is this big enough for people to see is this like can people kind of see what's going on here awesome um so this is just a normal this is what you get when you do uh wag me create app wagney's a great front-end development framework if you're bootstrapping a web3 app you can just run I think it's uh npm create wag me and it'll spin you up this project this is basically a super basic project with the one exception that I've added the tokenbound SDK I've done npm install at tokenbound SDK and now it's installed so I just run this server real quick so I'm running the development server I should be able to spin it up locally and fingers crossed that the Wi-Fi works and it'll spin it up there we go so this is what you get when you just create a new Wagner project it has some some things out of the out of the box and you can see at the top we've added this tokenbound account page and so what you're seeing here is this is the address for the sapiens project the sapiens that I showed you and this is the token ID and this is the chain ID so every evm chain has a chain ID tokenbound accounts are tied to a chain ID and so with these three inputs this is the address I get back from the token bound SDK and so in here in my react component it's pretty easy I just added in the token contract the token ID and the um and that's it it uses the chain ID of the provider I'm connected with and down here I instantiate a new tokenbound client passing it in the provider that I'm working with in the front end application if you're using VM it's really easy to grab that it's got a nice little hook if you're using ethers or something you can pass that in as well so I instantiate the tokenbound client here and then it's one call away I call tokenbound.get account and this gives me back the tokenbound account address for this nft and you'll see this address here is the same address that you see in this little iframe here 0x uh oops 0x 5416 is sapiens number zero and we're passing in sapiens number zero we'll get back the same tokenbound account address so you can query that address really easily without having to know anything about how tokenbound works or how erc655 Works under the hood you can get that address information into your applications and then you can start using it there are other methods on the SDK we have a docs page at docs Dot tokenbound.org where you can see all the methods on the SDK you can deploy the account you can execute calls against the account it's all pretty much the same you pass in the provider from your front-end application and you can start executing against those accounts so that's the SDK you've got it's an npm installed away you can start building 6551 related stuff into your front end without having to worry about how any of the smart contracts work behind the scenes all that's taken care of for you you can just use the nfts that your application is already interacting with and interact with their wallets so that's one way to build on top of the talk about it's tokenbound SDK on GitHub another thing we provide is a wallet implementation so n6551 you can actually bring your own wallet implementation you don't need to use ours you don't need to use anyones it's fully decentralized you can build your own wallet for your nfts we provide one that's out of the box it's got some of the nice things you'll expect from a smart contract wallet like 437 supports uh 1271 support so you can sign messages um some very some stuff around delegation and things like that so it's kind of a fully featured extensible wallet that you can build on top of and if you're using the SDK you already are using this out of the box if you're using the tokemout Explorer you're using this out of the box but this is a fully open source wallet implementation that you can start using if you want to hack on building a custom erc6551 account implementation if you want to add custom features to the wallets for your nfts you can Fork this and go nuts and build a custom implementation that's the read before at tokenbound contracts if you're using the SDK you don't have to worry about it but you can totally uh interact directly with this I'll show you another demo of this if I just switch to my contracts directory um I'm not sure how many of you are familiar with Forge but this is this is Foundry this is forged the smart contract development toolkit uh this is a script so this is a smart contract but I'm going to run it locally but you can use the same code inside of your smart contract accounts or inside of your smart contracts that you're building this weekend so getting the token Mount account addressed for an nft is as simple as using this erc6551 accountlib from the ERC reference repo um and passing in pretty much the same data that you passed in in the SDK there's two extra parameters one is the registry address this is the canonica registry is deployed on every chain so this is the registry address the second is a wallet implementation address so this is using our wallet implementation against deployed across chains you can feel free to use it if you're going to do a custom implementation you would pass your own custom implementation address here and then the rest is the details about the nft so a chain ID of one because it's on mainnet the contract address of the nft and the token ID which is zero and then the final argument is assault and so by default this is zero you can use the account with assault of xero but if you're used to using wallets within metamask where you have one seed phrase but you can have many wallets it's the same kind of thing you can have one implementation for a wallet but you can have many wallets for an nft using that implementation just change the value of salt so these are the default values these two for the registry and tokenbound account address and then zero for the salt and then the middle three are your token information the chain ID token contract and token ID and so if I run this all this is going to do is calculate the account address of the nft locally and log it out um if I run this script using Forge it'll run this and then it gives me back the same address Xerox 5416 because we're calculating the address for my nft and the same kind of thing you can use the you can call directly into the account contract from your smart contracts and use the execute fault call functions or the other functions on the talking about account so you can have Smart contracts that are aware of nfts that are aware of the nft's wallets and do really interesting things with them one cool thing about if you're doing this with either the SDK or the solidity library is you're not actually calling in to any contracts you're not making an RPC call when you calculate the address for an nft you're not making a contract call when you use solidity to calculate the address because addresses can be statically computed by the client you'd actually need to make that Network call it just happens locally which is kind of a cool benefit that you get with 6551 um anyways that's the so there's a client SDK that you can use in your front end apps there's a solidity SDK you can pull it in from the erc6551 repo you can also pull in our wallet contracts and start building in your application ah so that's talking about wallet uh one other thing we have is an iframes oh you probably saw when I was playing around with the um with the sapiens nft there's this little thing in the bottom that shows you the contents of the wallets shows you the assets it owns it shows you the wallet address this is something we built for the sapiens project because it's really useful if you're going to be on open C trading nfts to see the contents of the nft's wallet and to see its wallet address right like I can come in here and I can copy and paste the wallet and then I can go over to whoops I can go over to etherscan I can paste it it's really nice to have this information accessible and open seat this is all open source so if you want to use this iframe in your projects it's really simple there is a repo here it's tokenbau slash iframe I believe if you chat with Ray afterwards there's also a URL that you can do it what you do is when you're creating an nft you can pass in a custom animation URL field in the metadata and that can point to a full website so if you pass in an animation URL and you use the token Mount iframe you'll get the artwork of your nft rendered but this nice little account overlay that shows you the contents of the account and the account address within the nft and so that's a nice little way you know in the interim before openc and all the other marketplaces support talk about accounts natively you can build in support for it at a visual level using the iframe so that's at tokenbound iframe on GitHub again we'll be here all weekend so come find us and we can we can walk you through using that um yeah finally Doc's not talking about.org so this is where all the information you'll need to work with the compound accounts is the contract addresses for both the registry and for the implementations um some information on using the sdks the iframe so anything you want to know about tokenbound accounts are using the token bound uh tools is it docs.talkabout.org and if you're interested in the actual EIP spec itself you can look that up at eip6551 it should be on the Erp site and you can read through here this is kind of a really in-depth exactly how it works behind the scenes deep into some of the the theories of it and all of the ways that the smart contracts are structured for building on top but you don't necessarily need to know that but you can go there and see it if you think that's cool finally we've got some bounties we're giving out this weekend so um we're here we would love to see people building on top of erc6551 building on top of this concept that every nft comes with a wallet now uh and so we would love to see you all build crazy stuff with us we have some ideas for you if you don't have stuff planned yet um we've got some prizes for the best use of it just best overall got the best nft use or NPC use case if you want to do some crazy stuff combining nfts with AI controllers that do actions on chain we think that's a really interesting use case if you're around at pragma yesterday you saw a demo of Benny talking with an nft via a web3 chat app and that nft actually executing Unchained actions to send him stuff if you want to do something similar in that vein where you're giving nfts AI capabilities you can you like there's that's the MPC category we'd love to see you build ups uh infrastructure we would love to see some things built on top of this make it easier to build with tokenbound accounts so if you are building this weekend on top of erc6551 running into issues or you know just seeing things that you think should exist like indexers if you want to build wallet connect support if you want to build tooling for getting snapshots of a whole collections talking about account addresses or even if you just want to submit a pull request to any of the open source tools that's the infrastructure category we would love to see all of you build on top of ear651 and contribute to some of the stuff we're doing open source finally if you're a little bit less Technical and you don't want to do like some crazy solidity or front-end stuff uh that we've got a prize for the best on chain media use case if you're you know creating art using 6551 what happens if you have composable nfts that change the artwork um or if you want to do like some interaction design or some visual design or how do we represent this concept of nfts owning wallets and those wallets wanting assets uh doing some visual stuff around that is a category for that so anyways that's erc6551 every nft comes with a wallet now every nft that you launch this weekend in your projects will come with a wallet and you can feel free to use that so yeah thanks so much [Applause] yeah yeah okay cool all right we're going to get started right on time because we're going to get through a lot of cool stuff today guys thank you so much for coming uh my name is Kevin Jones I'm a developer relations engineer working for Edge node working on the graph and I'm also a advocate for scaffold youth part of the build Guild or the middle gittle as you might have heard uh today I'm going to be talking about scaffold eat though it's basically this kind of awesome tool kit that kind of gets you up and started quickly for building dapps so it's really really useful for hackathon hackathons because it is just a really good starting point this is all my contact info feel free to connect with me on whatever you prefer I'm on Twitter telegram I'll be here around two as well I'll be at the the graph Booth so if you guys have questions about the graph or about scaffold eat after this be happy to help you guys out so please connect with me I don't have any slides we're going to pretty much do like real-time demo here um but first of all I kind of want to talk about scaffoldeth there's two versions of scaffold leaf I'm going to be mainly focusing today on scaffold E2 which is the newest uh flavor of scaffold beef there was a lot of cool improvements that have been made to the project and more specifically it comes with nexjs it's kind of revolves around typescript it also uses rainbow kit and wag me and it also uses hard hat we're in the process of making a cool build that actually might support Foundry as well but for everyone here this is kind of what you get with it it's a GitHub repository so if you just search scaffold D2 it's going to show up as the first kind of uh thing you can come in here you can template this and kind of copy it over to your own GitHub that's usually what I recommend and then you can kind of use that as kind of like your project for the hackathon um so we're just going to kind of get started so I'm using tmux which is just like a terminal multiplexer it kind of always has uh it has the ability to have like multiple windows in one kind of console but you could just use multiple windows you kind of always need three windows with scaffold eth because you have your back end which is running hard hat and you have your front end which is running next JS and react and then you have this kind of like third window where you're doing your deploys and kind of pushing your changes right so uh I went ahead and just checked out the repository and already ahead of time and I've also gone ahead and did a yarn install so your yarn install it's going to basically install all of the dependencies for you and get you up and running uh once you're ready to go you just do yarn chain so yarn chain is going to spin up again a copy of hard hat it's going to give you these kind of like hard hat accounts that are available for you to toy around with and start messing around with uh the evm and start testing your smart contract and then in the second window we're going to run our our front end so you're going to start okay so yarn start is going to do exactly that it's going to start up next.js on localhost 3000 we'll open that up in a second real fast a huge improvement over scaffoldeth one which used just straight react nextgs is just really really fast and awesome um and then same thing in this third window we're going to use for like all of our deployments okay so we're going to do a yarn to play now what that's going to do is actually uh scaffolding comes with a smart contract so we can see that our contract got deployed we did a transaction we created our contract and it tells us how much gas we use because we're console logging that stuff into hard hat which is really cool and we also see that scaffold our hard hat mined that block right and then we see like yeah we can optimize our contract based on gas because we know that's there we see our contract address let's take a look first of all I'll bring up vs code we'll get to that in a second but let's go ahead and load up the application so we're going to use uh let's see where's it at scaffold here we go so scaffolding is like I said it's next.js so this is kind of what you get when you launch uh scaffold eat and one of the things you'll notice is that we got this kind of uh wallet that's automatically integrated so scaffold youth has this concept of burner wallets so you don't necessarily have to use metamask you can just use the burner wallet it's ready to go and we have this kind of identity that we can start testing with so I can grab some funds from the faucet by just clicking that that sends some funds from hard hat into my burner wallet and I'm ready to start interacting with my contract so where's my contract well it injects it automatically here into debug contracts so it basically takes the ABI for the smart contract which is kind of like the interface right that tells your smart contract and your front end how to talk to each other and it creates unpopulates all these fields for you so you can start doing testing against your kind of functions and you know you instantly get an output on your variables right so you see like all right cool we have a greeting variable looks like a string we have an owner variable which is an address we have a Boolean that's set to fall false and then we have like a counter and then we have these like reads functions as well we also see our contract address here we see if it has any funds we see what network we're on and we can come in here and say like all right well let's change the ingredient so we have this like right contract so we can tell right now there's a set greeting function in our smart contract and I can change it to whatever so Fubar and hit send and now I've updated the state of the contract so we have this kind of like it's like a hello world contract really basic let's take a look at what it looks like so let's go ahead and load up the directory for for scaffold eth mainly the beauty of scaffoldings everything revolves around yarn so there's like a package.json file that has these kind of commands for you to just navigate and do stuff in scaffoldeth but more importantly there's the the two packages it's a it's a a monorepo so you have a hard hat repo and you have a next jash repo so we can go right into hard hat and we can go into our contracts and go into the year contract and then we can see our contract so this is kind of like I said the hello world contract we can kind of start like hacking away at our contract so I just kind of want to show you guys how this works so we see here that we have like this owner variable let's go ahead and like dump that I always like to kind of get the contract let's also get rid of the Constructor because we're going to make like an empty Constructor and we're also going to get rid of this modifier and let's just say you made all these changes right we're also going to get rid of this withdrawal function and we're going to save that and then we could try to do a deploy now now if we wanted to we could do a yarn deploy if it sends changes in the uh contract it would give you a new contract but we're getting an error and the reason why I want to highlight this is we had this Constructor and we were passing some arguments in it and because scaffold ethuses hard hat we also need to fix the deploy script so if you take out this Constructor which I did I kind of I kind of ripped out the contents of it made it empty we also got to go into the deploy script and look at the actual deployment so if you're not familiar with hard hat it's a you know JavaScript basically uses ethers to deploy our contract and we'll see here that there's a uh we're getting a copy of our contract or we're actually deploying our contract here which is called your contract and we're using some arguments that we're passing into the Constructor so it's basically complaining about that so I'm just going to wipe that out because we were using the deployer account to set a variable at the in the Constructor so I'm just going to save that and kind of redeploy again so if you ever want to like force now it was successful if you ever want to like force your contract to deploy as well like if you do a yard to play again it's going to see that uh well you don't need to actually deploy the contract because it's the same but you can also uh force a contract by doing yarn deploy dash dash reset and it will basically force a new contract to be deployed okay so let's let's take a look now so now our uis automatically changed right we've gotten rid of this owner variable we've gotten rid of uh you know the the withdrawal function and now we're kind of in this new state where we can start kind of like building out whatever we want right so we could see what that might kind of look like so let's close the deployer script because we're not going to need to really mess with that at all but we could actually instead of using so earlier we had this like modifier and we had this concept of like access control that's one of the things you'll learn when you're building on ethereum you need to have some kind of access control for certain functions well you can just actually import the existing ownable smart contract which is an open Zeppelin contract just by importing it like this and then we can take our contract and then inherit that right so we import ownable which is just this uh open Zeppelin contract if you're not familiar with open Zeppelin it's kind of like a collection of contracts that are you know for different use cases and they're kind of like vetted and widely adopted and then we can just import that and use it here or sorry inherit that as here and then save that so when we make those couple changes again we're going to do our change and then deploy a change and see if it goes through which it was successful and then we we you're kind of in this feedback loop with scaffolders you're editing your front end right with uh your editor you're deploying your changes using a hard hat and using using the yarn command and then you're coming in here to the UI and reflecting and seeing your changes and so you can start to do interesting things like maybe we want to see now that we have access to um the ownable we also have this transfer ownership function so we might be able to call that in our deploy script like let's say if we want to transfer ownership to another address or we want to renounce ownership of the contract we can call the renounce ownership which allows you to throw away the contract so you can kind of use composable contracts that are already available from open Zeppelin to kind of start your project so if you're going to use erc20 token or Critter erc20 token then you can get the open Zeppelin one or if you're going to do a nft you can get 721 or 1155s and just import those and they'll just show up here in uh in scaffolding and then we have this example UI which is pretty cool it's just gives you like some examples like one thing I always hear from developers is like all right I'm really good at like writing smart contracts but I don't know the front end components so we're going to dive a little bit into that and show you kind of what that looks like but there's a lot of components that are already written for you that make it easy to build your dap and this is just a really good example of like all right well we have this kind of window we have this like greeting option we can actually say hello world here like this and hit send and it will like update that by sending some transaction and then what we'll notice here is we our counter increased right we get our new new state kind of coming over there and then if we go back to debug contracts we can see that now we've been able to actually send some Ethan to the contract because this example UI not only does it allow us to change the state but it also has a value that it attaches to it right so we're actually sending in some value we're paying for the gas and we're kind of creating this you know interesting function it's not that interesting but it's cool just to kind of see how it works um and so let's let's dive a little bit more into the code of of uh scaffold east's front end so again if you're if you're editing your contract it's in your hard hat contracts your contract you can kind of come in here and do whatever you want if you're new to like uh building on solidity what I always tell people do is go to solidity by example solid by example is just a really cool place to get examples so like an example would be like you know you want to get like a mapping right you can come in here grab the mapping paste it into your smart contract right here right oh something copyright tab boom save it deploy and then we'll see that we got a new copy of our contract and then we'll see that we have this new mapping available in our front end right here it is it's a my map and then we can like check this balance or something like that like grab this and see if there's some kind of map to a value there's none but maybe you do that in the Constructor right maybe you at the time you deploy something you set a value so you can start doing interesting things just by grabbing examples from solidity by example and kind of pasting those into your contract um uh okay so slender by example is great um let's go a little bit more into the UI so like I said the magic just to to scaffold it is it builds that debug contract tab for you which allows you to kind of get up and running start doing some some testing you can also do something like this where you say like all right new incognito window go to localhost 3000 and then you get this like new identity so you not only do you have you know this kind of like burner wallet here but you also get access to burner wallet here and you can start kind of testing different personas that are using your dap and so that's really useful because the burner wallet is actually stored inside of the browser session so if I was to come here and close this again and then also open up another incognito window we would get this kind of new identity right and a new burner wallet right so you can really kind of toy around with like access control or whatever kind of functions that you want with another identity okay so let's look at the front end so next JS is you know awesome it's a little bit um you know if you're if you're just good with solidity and it can be kind of a little bit challenging when you start writing uh you know your front end but the cool thing is under Pages we have this kind of example UI which references the components example UI and then we have this contract data which allows us to get all of the contract data from our smart contracts and there's kind of some examples in there and then also like a contract interaction as well which shows you how to do like uh use scaffold Eat Right which is like a you know a hook that you can use and so you can come in here and kind of like use this you can see like with scaffold eth we have these hooks so we have like one for like using the contract reading the contract subscribing to events or seeing the history so there's all this kind of Interest stuff and then again we use wag me so like let's kind of start hacking away at like a front end so you can kind of see what we would do so what I always tell people is I if you're building an app use the index tsf TS file which is this kind of like home thing which originally just set up to kind of show you like where you should go to do stuff oh also real quick there's a block Explorer which is really interesting it's new but it also shows you like all your transaction history which is really cool you can see like you know what what you called what function was called um and it's just kind of interesting to see like the the history of that uh but yeah so if you want to edit this thing this is index.ts right so we can come in here and we can like just kind of wipe out some of this stuff so let's get rid of this and save that so if we save it boom right we get this kind of like clean slate so you can kind of think of it like you're building your dap inside of this home folder and it's going to be available inside the middle section but you still get access to all the you know everything the Trap ground scaffold teeth okay so um let's just say that we want to do something like this we could say like I don't know um we'll do const and then we'd say like all right address we want to get the address of the smart contract from wagme so we can use uh sorry not from uh use account right and my IDE basically automatically imported wagme for me here so I'd have that enabled so we can see that we have used account access and then we're able to access that and so one example would be like let's uh use uh one of the components that comes with scaffolding is called address so we can say address we can say address equals address like this and then close it off and save that and what did I do wrong address equal oh I need to import that yeah so it's we can go from components example UI I think it's under you just retake said again oh yeah maybe it'll pop up yeah on where yeah oh here there we go thank you I'm still learning like vs code I mean I'm like a a terminal kind of guy so I'm using a Vim you know so this is all new for me um okay so that's just an example so here we can see we got access to the count which is like just a component right and so we can get that we can also do something like grab the balance so we can say like all right well const uh let's grab the balance and by the way I'm not a front end guy either I'm still like uh pretty much green so uh we can say use uh account balance right it's going to also import that for us and then we can also create another one so let's be slow here and see if it actually takes it there we go did and the same thing we can pass the address in here um and sorry boom I'm still learning this AI stuff too like I have this Auto completion did I spell that wrong oh didn't close it up but you get the idea so there's some components are available so now we have the uh address here and then we can also get access to the balance right so there's all these interesting like components in there um I'm not going to get too far into it because you know it takes a while to build out a full UI uh but I but I would say go into the uh examples uh here in the the contract data contract interactions and then you can start kind of doing some stuff um but I also want to showcase one other thing so as you guys know I also work for edu node working on the graph and so I wrote this blog post which was also quite interesting because there there is a bounty available for the graph and so if you want to use scaffold Ethan you also are interested in using the graph the graph is kind of like this API layer I wrote a good blog post that walks you through how to set up scaffoldeth and there's a special package of scaffoldeth or I should say a special branch called subgraph package for scaffold D2 and inside of here there's a complete dockerized version of the graph that you can set up and so my blog post actually walks through like basically all this stuff with scaffolding that I went through at least the basics of like deploying your contract making some changes but it also goes into like how you actually spin up uh the graph and how you create a subgraph using the command line stuff there's again there's also these yarn commands written for you so it make it really easy that you can generate a subgraph based on your smart contract so if you write your smart contract all you got to do is just run these yarn commands and it will generate all the subgraph information for you and then you can publish that to Docker so the one caveat to this solution is it runs in Docker so if you want to use scaffold eth and you want to run it locally this is a really cool way to do that and then you don't have to deal with the internet connection uh if there's any issues but you can also take your sub graph at some point oh that's what I want to show you guys next so let's say that you want to deploy this to a test net right everything we've been doing kind of is local the the next thing you might want to do and how much time do I have I got 10 minutes the next thing I want to do is actually do a yarn generate uh and actually generate a deployer account so you don't want to use hard hat accounts to deploy your smart contract because everyone has the private key right so you need to generate a new uh private key so we store that in an environment file locally and then you can just do a yarn account and you can fund this account so you get access to the address and you can just fund it like you could just go on your phone like if I pulled this up right now I could send some test net there and then you can do a yarn deploy like this net Dash Network and sapolia or go early or whatever test net you want right so that's really useful because you can use hard hat as that Catalyst just to push your contract to a test net and then you could use uh if you stop by the graph Booth there's a sheet that walks you through how to deploy a sub graph using the CLI and you can deploy it to a test net as well so there's this kind of like seamless and options for you on how you deploy your smart contract and then on top of that you can come into the the front end and and if we go to the next JS directory and we go to this scaffold config there's a change a Target network uh key value or uh setting so I could change this to whatever I want so if I want to switch this to sepolia like this and hit save and then take go to my UI again it's going to tell me that well first of all it's going to get rid of my burner wallet because we don't have access to the burner roll anymore so then we're going to say after I actually connect to metamask so we have that option and we can see now that I have my metamask connected I got 10 sepolia eth and now my dap is hooked to spoila right so it's that easy you just um you know change deploy your contract to the test net using the deployer account update your UI then you can take your your application or your front end and you can do a yarn uh verse cell YOLO like that and basically it'll take your um your thing if I did it right now I would say like all right we need to authenticate oh I already did it earlier so then it's taking my contact uploading it to versel and then I have my front end available so that my team can start interacting with it right so it's this kind of full seamless solution where you use scaffolding to kind of kind of do everything um so what else can I show you guys okay um yeah so one thing I would say too is I don't know if you guys are familiar with speed run ethereum so this Shameless plug but speedrun ethereum is an awesome way like after the hackathon if you kind of want to get more involved in uh the ethereum community and and the building Community uh speeder and ethereum is this kind of like set of challenges where you can go through and do different like projects and deploy different things the first one is like an nft then you create a staking app and then you create a token vendor and then eventually you actually get invited to the build Guild which the build Guild is kind of this collection of developers or group of developers community that are all kind of working with scaffold eth and helping the community grow forward and uh so far there's about 770 Builders there's been 784 builds of scaffold youth one and scaffold E2 and then on top of that we have certain developers that want to be really involved in the community and you can actually get a stream and you can actually be be funded as a developer to create and use scaffold ether you know promote scaffold leaf or build on top of scaffolding then help the ecosystem so that's a really really cool thing I also have a pull-up so I would love for you guys to get my pull-up after this um yeah so I think right now I think maybe we can open it up for questions and see if anyone has questions about scaffoldeth or anything that I showed it's got to be at least one question anyone anyone you said maybe on a Foundry version yeah so we are working on uh the the core developers of scaffolding 2 are working on a kind of a cool like Adventure uh Choose Your Own Adventure style thing where like you might check out the repository and say oh I want to actually use Foundry or I want to use I don't know whatever different component right so we're looking to do more stuff like that and that's in the in the works so that'll be coming coming soon uh oh I didn't really actually tell test show as well there are yarn tests so we use hard hat so there's some like urine tests that you can do oh at least there was they got rid of them actually uh so maybe that's part of like the plan is we're going to use you know Foundry tests or something like that yeah yeah two questions is that something that we should yeah I think that's a great question so the question was about the branch being behind on the main branch yeah that's something probably I need to work on and merge it all up um but I haven't gotten a chance to do it I didn't actually write that Branch Simone from Edge and node wrote it which is super awesome um but uh yeah it's okay to use it it's missing the block Explorer uh and I can't think of anything else that's really drastically changed everything else is very it's very it's very close uh in commits it's not that far behind uses I think the older style instead of the new app directory that uh sort of migrating towards that um is there like a flag or an option to switch to that or is there a reason why you should not do that yeah so yeah the question is uh you know we use we utilize an older style of deployment xjs app and create next next.js app um I don't think there's an option that I know of to change that that would that would be something that like you know we would look to you know the community for people that want to be involved maybe that's something you could you know be part of the build Guild and help with something like that but I can't think of anything that you can do right now um maybe in the future we'll switch everything over uh scaffolding 2 is kind of in a really fast prototyping mode right now there's a lot of developers working on it so they're doing a lot of future stuff but maybe that's something that's coming that I just don't know about so yeah fair enough yep another question uh do people in building do client projects like work for clients uh yeah absolutely yeah so if there's certain projects that you need help with um you know we can work with you on that kind of stuff um just come find me afterwards and I can get in touch with uh with someone that can help you with that yeah thank you I thought I saw another question yeah oh my name is Tim here and uh ethereum and or no uh it's your heart it's gonna be a cool project it's going to be interactive or connected to blockchain and it's going to light up and uh um I love it thank you that's awesome man all right yeah it's really good I'll say your operating system and it wipes out everything from your Terminals and you can make sure yep that's good yeah yeah and it's also worth noting that speedrun ethereum right now all the challenges are actually written with scaffoldeth one uh so there you might notice there are some differences if you're going through like what I did but the good thing is there's like tons of videos online for just scaffold teeth version one that will walk you through that stuff so awesome any other questions nope thank you guys so much for coming appreciate it foreign thank you okay so that should be good test test yeah it has to be like it could be like down here still like that's not fine as long as you hear yourself test okay cool test test test I'm gonna hold it I feel like it doesn't go if I click it I feel like it doesn't go if I clip it like I can't really hear the attack like see it doesn't really pick up this is better foreign no the room should be this too yeah it's all from here see I'm okay here okay holding it sorry okay um you're better off to take this off so just Russell oh okay take your lanyard off oh okay yep oh yeah I don't know if you don't mind me yeah just do that a little pinch who's that can you hear me a little bit higher there there we go I don't know if it's oh there we go cool actually hearing the screen so so it's so that's that's okay and you can kind of hear it yeah it shouldn't be too loud as long as like you know that's true do you do you mind if I hold like just hold it at one point okay sweet okay okay cool yeah but if you want you to hold it I don't mind first thing but I 100 know people in here I kind of like holding it but yeah sweet yeah okay okay I think we're gonna get started all right so uh Welcome to our presentation thanks for being here uh we're a highlight so we're a platform to help creators build uh code-based generative art collections so highlight kind of helps creators use no code tooling to deploy collections create data content create a portfolio kind of survey their content on chain but what we're most excited about is code based generative art so we're really inspired by artists like Kim asendorf who's a popular artist in the generative arts space that we're working closely with because we're going to be launching a platform at the end of this month so like I said highlight kind of offers no code tooling with this code-based generative art you're going to be able to integrate like AI models scans we kind of do all the stuff in the background for you to create like beautiful mint pages and all this sort of all these sort of things and this summer we're going to be collaborating with a bunch of artists and Brands just to kind of push the boundaries on code based generative Arts so openc coinbase obviously our friends at eath Global are some of our partners so today what we're going to do is we're going to help you kind of like we're going to walk through what it takes to deploy a collection a code-based generative art collection on highlight and we're going to switch back and forth with like technical explanations of some of the like Cutting Edge like protocol Innovations we've made also some of this new stuff that we've developed on the generative Arts side um yeah and so Sarah's going to walk you through that but before we jump into creating a collection I just want to show you like what an end product looks like so if you come to highlight and create a generative art collection we're going to create this kind of like uh mid page for you um so this is kind of like your typical collection on ethereum or on an evm chain and the way that it works is when you mint a token from this collection what we do is we take a bunch of parameters from the transaction the mid transaction like the transaction hash the block hash the token ID the timestamp like all these different sorts of things sorts of things we input it into the script that the artist initially uploaded so the actual like generative Arts script and with that custom input that's unique to your transaction that script is going to Output a unique nft and you're not going to know what the nft looks like before you met the token so for example you we can like iterate through possible outputs so if I press randomize here what's going on is we're just sending in like virtual parameters so we're like virtualizing a transaction so virtual transaction hash token ID block hash that sort of thing and we're inputting it into the script that the artist uploaded and this is outputting uh what you see here so this is like an example nft that you could mint uh so before sarb is going to walk you through actually like deploying a collection like this um we're just going to Mint one so press mint here this collection is on Gorly it's going to ask me to pay a small fee which I will happily do and as you can see here we have a pending transaction and what's happening in the background is highlight's going to pick up this transaction and then uh you know pass these mid parameters into the script and then it's going to Output a render to our rendering engine and that metadata is going to get assigned to our token so this should complete it's happening right now um once it completes you can view it on a Marketplace on either scan kind of whatever you want but you're not going to know what it looks like it should sign right about now there we go so that's kind of the output cool yeah so uh we've already gone through the actual main page what we're going to go through now is actually the creation page of this uh basically how you end up with uh that main page at the end of it uh as we're going through we'll go through the technical details of it um what basically happens in the background to end up with or how we capture the image or the traits of the token so I'm going to go ahead and create a collection uh so this is basically we provide uh different like different types of collection goes from generative to series to open Edition limited edition and one of one which is basically auctions uh the one we're going to focusing on is going to be the generative Series so I'm just going to go ahead and create a collection uh the first page you see is basically just um it it basically takes you through what's needed to render uh generative art base one of them is index.html which is basically your art and that's what's rendered in an iframe and then you also have the Highlight gen script which is which I'll go through the details of it but all it does is provide a bunch of attributes which are related to the transaction the Creator can decide when they want to capture the image the attributes of the token and everything so again there is uh an example project that you can actually download so you don't have to write this write the script yourself you can just play with it um but yeah let's go ahead I'll just take you through the Gen script so this is basically uh so it's going to be open source soon but uh for now it's kind of like in restrictive mode but I'll take you through a few of the methods of the Gen script that it provides so as uh Asian was mentioning that we basically virtualized a transaction when you actually meant something so we got two methods which are Generate random hash and Generate random address all they do is basically just map through alphabets and create a random transaction so you don't have to actually create a transaction it'll just create a random transaction provided to your script and in the end you can actually see what the output of the art looks like as you keep going down there is so the two main methods that we use here are these are both open source X export 3 which is a hashing algorithm it's available anywhere in the public repository and then sfc 32 what we do with this algorithm is that when we when you actually call so one of the main methods that you call on the script is random which is which works like math.random if you've ever played with it gives you a random number between zero and one but the way we do it is basically it's a pseudo random number generator it takes a seed using these two algorithms and the way it works is if I go to the seed method it's gonna take in so it's going to take in the hash and the token ID to generate a seed and then the seed that gets inputted into pseudo-random damage generator and you have a random number which basically every time you input the same transaction you'll have the same Arc so what happens is when you mint we basically provide the same transaction hash block hash and all those values so that gets encoded on the Chain so every time you open that URL you'll have the same art on the blockchain in terms of creators the two main methods that creators are usually concerned with are they have to play with or the capture preview and set attributes what they do is basically capture preview is if you've ever gone on openc you've looked at an image of a token that's what capture preview does is that you can actually call this method anytime in your script that tells highlight that you're ready to capture an image for the token we take an image of the token and upload to openc and that stays there and same website attributes we take the attributes we open up we basically upload that to openc and then you have that encoded on chain so going back to the creation process I'll just get started with a random script so I have a few bunch of demo scripts I'm just going to run through one so I'll take this it'll basically upload that to our centralized server and at the same time we use RV as our decentralized server it uploads that to RV and it stays there for permanency and then for validity of the code again I'll go through yeah so once you land on this page it's basically a test script page you have your p5.js Javascript file which renders the art so this is basically what the code renders and then these are trades on this side which we capture in live so if you actually refresh or change the attribute so if I'm going to randomize it the trades are captured using our rendering Engine with the script and a virtual transaction so every time you can so as a Creator you can actually play around with changing the hashes transaction hash block hash and you'll see different script different traits and you can just basically validate your art as you want it to be um so again you can not only randomize it you can actually input a custom hash which will come in handy when we go to the next step so if I keep moving forward this is one of the key pieces of the the generative art on addition size you can put it put it to anything like I'm just gonna go with 20. but this part is what allows the creators to say that they have a set of hashes that they want there are to use so you can have a Creator can say like I want only these 20 set of hashes to use for my art so whenever a man happens we put we pick randomly from one of those 20 and we assign that to the metadata and that makes sure that whatever the art the Creator wanted is basically just given to one of the collectors we'll go through the details of like how that happens but I'll just give a demo of like what that looks like so basically as a Creator you can come here you can say I like this one so if you click basically add it adds to the selected hashes and you can keep on changing generate more tokens it'll take different virtualized transactions and you can keep on adding them so you build a list of transaction hashes that basically the collectors would use for the art uh just going back to the the details of it so the way it works is basically you have uh so we've already gone through this part which is that you have a set of hashes but we have a basically evm data manager which listens to live events on contracts uh whenever event happened let's say a minute happens we pick that event up it processes through our pipeline of transaction service and when it ends up at this service what it does is that it basically knows that a mint happened and what was the transaction of that mint so it grabs the transaction details from the evm chain let's say optimism Arbor term or any of the chains and then it uses those inputs which would be transaction hash block hash token ID and it uses the Mulberry 32 which is again open source algo it inputs those values into the algo and this is again this is the algorithm and then it outputs a number so the number can be whatever your collection size is so let's say I just input a 20 if I input these transaction has block hash I'll get a number anywhere between 1 to 20. given that number I'll just use this list of hashes that Creator wanted and just pick one of the transaction hash and use that hash for the art uh a few key things about this this whole process is that this algorithm is independently verifiable which means that the algorithm is publicly available the transaction is available on chain you can basically run the same algorithm over and over and get the same output so even though it's running centralized uh you're always free to just verify that you got the art that you were supposed to get the second part is that we guarantee processing of events in order what that means is if you minted a token first let's say you got token id1 and someone has got token id2 we make sure that the transaction of token id1 gets processed or gets the arc first then the token id2 that's important because there's a point where a collision can happen so let's say someone gets the created hash number one and another one got the one so you want to make sure that the first one who is the valid recipient of the art gets gets it before the other one so this is basically two key details of our algorithm and how it basically assigns them that data so going back back to it I'm just gonna forward through it for simplicity's sake I'm just going to discard this so I'll discard the select outputs I'll go through the next step uh this is again another one of the point where the Creator can validate uh what they're actually trying to capture is actually equal to the live view so this is the art being rendered in an iframe on the live view so it can be uh basically anything it can actually right now it's a static image but it can be moving image but the preview image would be the one that that's a PNG or jpeg or something and that's what we capture at runtime and these are the values that the creator has so they can provide a delay so if your script takes longer to run you can say like I wanted to capture after 20 seconds you can change those values you can change the image resolution and once you validate the art is valid you can go to the next step uh at this point like patreon will come and talk about the details of the protocol sweet thank you sir all right yeah so we ran through all the generative art stuff uh now let's deploy the damn thing so we're gonna just configure a bunch of details about the collection configure details about the mint you know you can deploy this collection on a bunch of evm chains where you support five right now but we're gonna keep adding them for this mint we're just going to go with go early yeah you can basically customize like whatever you want about the contract added to the filter registry whatever you want we'll just put in some dummy values for this Waterloo 2023 upload a custom logo that represents a collection and you can also make the tokens on the collection non-transferable and the way that this works is that we have like the collection that you deploy is highly modular so you can swap in like pretty much any Behavior you want to Define how the nfts on your collection operate so coming here the collection that you actually deploy is basically can refer to a bunch of modules so almost anything that you want about the collection that you want to modify like the behavior you can so whether that's burns transfers how the metadata is rendered if how the metadata can be updated how the royalties can be updated how the nfcs can be minted like what you can have your own custom Smart contracts or use some of our modules and then swap it into the collection and then swap them in and out remove them that sort of thing um so a couple of interesting things about this is one because you're swapping in essentially your own code um you can introduce like any Behavior right so like any conceivable like Logic on chain you can swap it into your collection so that takes collections from like having you know you being able to configure stuff about like the who like who commit this nft or who can update metadata to who what where when right so because you're writing custom code another thing about these modules is they're what we like to call composably autocratic which means that they can like Define their own behavior about if they can be swapped or if they can be removed and like a second order consequence of this is that creators and collections can define a path to gradually decentralize The Collection so like like an example of this is uh you know let's say when we first deploy this collection we have a really simple module for the metadata the metadata is frozen nobody can update the metadata and only the owner can swap this module out and and then the mint happens all the nfts are distributed maybe to each one of you everybody owns the nft and then the owner can swap this module out for a more decentralized module right so module two now says that if all the holders of the nft on the collection vote on updating the metadata to something of their choice they can and also maybe if they vote they can also vote to swap the module out so you've not just decentralized who can update the metadata but you've also decentralized who can Define the behavior of who can update the metadata so it's kind of like a meta decentralization and then yeah maybe after this they vote to also Swap this module out for like like an even more open module um yeah so here's like a really quick sample implementation of what a module looks like this is solidity if you're familiar um I'll zoom in just because it might be a little small yeah so I can update metadata like this example implementation what it says is all the holders of the nft like over 50 want to update the metadata to something they can uh also they got to do it for a certain time uh that time stamp is also an Easter egg it's a Unix timestamp I first want to figure it out I don't know I'll give them like that amount in Gray or something but uh there's also can swap can remove itself so this is like the composable autocracy part uh so in this example implementation this module is like fully locked in like this behavior is locked into the collection and then finally you can Define behavior about transfers right so like here we wanted to make our collection not transferable so all the tokens are uh in this case consensually and untransferable sweet uh so coming back to the collection creation all right so final page before we deploy The Collection now we're going to Define like the mint details so you can sell each of these tokens at a fixed price or you can use a Dutch auction which is a schedule of decreasing prices but we'll keep it simple we'll go with the fixed price uh maybe we'll make it free you can Define kind of all these like mid parameters when it starts when it ends maybe only let each person make two tokens um and then something really interesting we have here is we have this idea of like gated minting so you can create kind of these like really complex Gates that restrict who can actually mint on the collection uh so let's say let's let's create a gate um call it demo um and you can add like a bunch of these conditions so maybe the first condition we want to add is only like holders of board ape with a certain metadata attribute can mint on this collection so we can like go to this condition um come to the board ape kind of open C collection page paste that in uh maybe I don't know board Apes with like a purple background can mint on this collection and then we can add another condition like holds a minimum amount so like you you have to own that board ape with the purple background and you have to hold a minimum of two ethers so it's very like elitist mint but we can change this to all so we you can switch between like an or clause and and clause yeah and so we can just create this complex gate and now the gate is applied to the mint and so so the way that our mint works is uh craters can actually like gaslessly swap the skate in and out um so this is a good summary of our mint architecture so this is what it looks like on chain uh the MIP module is a smart contract The Collection is another that's the one that that's the smart contract we're going to deploy for you guys um we have this concept of mint vectors so mint vectors are just like different ways to Mint on the collection so you can paralyze a bunch of different sales right so you could have a mid Vector that's like only board ape holders can mint at this for a free Price you can have another mid Factor that's going on at the same time that's like for a public mint uh so it's analogous to like mid phases on a normal collection so at the top left you see like the user comes to highlight they want to Mint on the Gated mint we evaluate their blockchain account make sure they can actually like mint on the collection and then we construct uh a key we pass the key into the module we unwrap this on chain with eip712 and then we mint on the collection and because these vectors are off chain the creators can actually come in and kind of edit the Min config without a transaction so that's like a nice detail for them sweet okay so I think we've configured the mint we can just review everything that we've created and then deploy this collection metamask is going to pop up sweet okay yeah so uh so once the band is actually deployed uh we're just going to quickly go through I think we're running out of time but we'll just quickly go through the actual main page so if you land on the main page it'll basically we're done full circle where we started from you have the actual art you can mint it because it's okay like I don't think I have that much either so I'm just going to go ahead and remove that gate which kind of serves as a purpose to show that so I go ahead uh it's kind of happens in a gas plus way so I'm just going to go ahead save it and once that's done I'm just going to go back to the main page and I'll be able to Mint it um again same process once you meant it you go through the transaction uh it captures the attributes and just to round it off uh the way it happens is we have a rendering engine and metadata logic uh again when the transaction happens we capture the transaction values whether the capture details it goes to a rendering engine which runs a chrome headless and it really relies on the attributes and capture preview it it outputs our image URL animation URL attributes and at this point what we do is basically we take these attributes we upload them to RV for decentralization and then we upload them to S3 the way we do dual upload is basically we want to keep updating the tokens but we want to also but anyone can verify that what values that are on chain they stay on chain and nothing from the centralized server changes anything so we we do a dual upload so you can verify anytime the Mad data of the token uh but yeah so that's basically um again the the capture happened it showed the image and it went through it but yeah at this point um like that was just basically a demo but we'll talk about uh there's a competition that we're running and Asian will talk more about it sweet okay so we're almost done we'll take questions but real quick before we take questions uh so we're running a competition uh for for the hackathon you can there's five thousand dollars in prizes you can win up to three thousand it's really simple all you have to do is just we'll give you access to our beta platform which you can find this form on the East Waterloo website but just make a generative art collection with the same like flow that we just ran through we're gonna judge you on creativity kind of any like cool thing that you input input in there and also we talked about the composability the protocol so if you want to introduce like your own modules if you know solidity or you can use our R modules and get creative with it uh you can win three thousand dollars and also the winner of this competition is the official East Waterloo nft so whoever wins we're gonna your collection uh we're gonna distribute your nft to all the attendees at the end of the sackathon um yeah and there's like if you go to this page like if you're new to generative art you can kind of learn how to do it you can get a collection set up in like five minutes it's pretty simple sweet [Applause] thank you [Applause] any question if I if someone has any uh sorry yeah yeah uh which part uh is this one programmatically like uh Yeah so basically if you go back to our tools app so let me open it up you have a demo that you can download so it's basically an example project and you can actually let me open it up but if what it looks like is basically uh this file so you have index.html I'm going to open it with the text edit so basically it's a sketch.js file as a Creator you can have a sketch.js file I think I can open it yeah so it's a sketch.js file it calls highlight token but you can take a look at like how it calls the Highlight token but you download the demo it calls the capture preview and set attributes the one we talked about and uh that's what captures the image and attributes nothing like like generating parts uh can I have what based on tasks oh based on text yeah so uh we're adding we're adding those capabilities but right now it's just basically either any open source script that you can use p5.js or something but yeah we'll add those uh resources soon but we can talk about it more uh yeah those so those are those are the things that we're introducing in our next build so right now this this is basically foreign check one two three one two three everyone ready for air stack all right there you go yeah three minutes when I say air you say stack let's try it again air the screen itself does not be that soon foreign that's why how's that yeah I'll start that he's been doing most of it yeah once I give it to just put it here um is it too small I think it's good come on upstairs all right should we start yeah we're good we're fine yeah all right hi everyone uh I'm Jason and this is sarvesh from airstack uh today today we're going to tell you how I'll show you how to build applications using airstack how to use the apis um high level first of all Air stack is a single API that enables you to query and combine data across chain cross project in a single query in response we have apis today that blockchains ethereum and polygon every transaction since the Genesis block and new transactions within a few seconds as they're finalized as well as very strong in areas such as identity so ens forecaster lens po-offs nfts socials and so a lot of projects are using airstack were identity resolvers for creating recommendation engines for doing all sorts of new types of dataware experiences service is going to show you exactly how to use airstack and what the apis are involved I'm going to show you first the cheat codes really quick and and then Sarah shall go into actually the details but if you go to app airstack XYZ you'll see a Marketplace first of queries that other people have run and have shared with the community so after you run a query if you want you can share it so here are popular queries such as recent transfers a die token metallics balance of apecoin a bulk ens query that Starbucks actually ran and the cheat codes I'll show you is so I'm just going to show you how to write queries from scratch the cheat codes is using our AI generator to write the query for you I actually recommend trying it to start because it's a great way to very quickly learn the apis if you look at on the left hand side these are all the apis that airstack offers and I can write a query that goes cross chain crossdap and the AI will write it write the query for me so I can say show me all holders of orange Dow this is and we have a Chooser you can select it from about 10 000 different tokens pull-offs nft projects Orange that was on polygon and I can say and there are web 3 socials and ens and the airstack AI will generate this query for you and so here you can see it's putting in get token balances of this contract address it's looking on polygon it's getting the first 10 you can increase the number of responses and for each person it's getting the token balance that they have the owners their domains primary domains and their socials and so here you've since we see that orange Dow this token holder his lens name is byron2. lens you can see his ens names and you can see this for the next person next person next person so it's a great way to learn how to use the apis I'll do one other just to show you is you can also do this like in all sorts of directions so I can say for stani.lens show his nfts and their images and so here we're combining we're getting stony.lens as you know obviously is a he's a founder of lens it's an address on lens that's on polygon resolving that to a Xerox address then we're going looking up all of his nfts and also getting images which we've resized so you don't have to go out to ipfs and get them yourself so here is stani's nfts as example so let me hand over to sarvesh though and he'll give you an entire tutorial about how to use the apis over to you sir yeah it's good yep good yeah okay so I'll use uh next couple of minutes to go through what's currently possible with airstack apis and then I'll cover couple of use cases that you can build with the apis right now so in this diagram you can see we are currently live on ethereum and polygon chain and on the left side we have like most basic building block of any of the blockchain based projects so we have all your tokens and FTS balances and transfers for nfts we have option metadata and resize images we have a whole vertical on identity like this is where lot of people are integrating abstract so you can query all the ens domains and their primary domains we have lens and forecaster you can query pops with airstrike right now and then on the last side we have sales data coming from nfts like so we have sales from openc blur and variable we also aggregate this sales data on like an F specific nft level or a connection collection level or Marketplace level and this aggregation runs from different timelines like daily weekly monthly early and lifetime so this slides is this slide is the basic summary of what you can build today with airstrike in this hackathon and these are like couple of use cases that we feel it's very easy to build on airstrike right now this is not an exhaustive list you can add because general purpose product so you can add more to it but to go through the first thing is identity resolver so I'll build couple of queries from this use case I think three or four of them uh but uh if you have any 0x address or any ANS you can actually ask about the lens for Castle co-ops nfts so this is an identity resolver similarly you can build groups if you are building like a chat application and you want to figure out what are the groups you should build so you can build groups based on nft holders for the Ops the event they attended together so this is possible I am going to build this recommendation engine today so a simple recommendation engine based on pop-up so if you have a lens profile and you need to recommend what other lens profile that profile should follow So based on similar events they attended I'll try to build a recombination engine today definitely token balances transfer history token getting is very much possible so you can use token balances API and put a wallet in a token address and check whether the wallet has a token or not uh this new thing that we are looking into how that strike can be used for zika's Association so you can prove what's on chain truth and a stack in this source of Truth and then you can generate proof and validate with some other protocols that that's here today and one more area that we are looking into to build very awesome visualizations on top of our strike so a lot of data on nft sales and ens and Pops so you can actually build a visualization like find me the common wallets who attended each render in each water loop so a lot of those visualizations are possible uh I'll go through the couple of use cases while prepared like the queries that I'm going to build so I'll start with with a simple query uh I want to build a token getting use case uh so I want to build like token balances along with nft images and metadata so I'll go here on the wallet yeah so here I have all the list of the apis but for token getting I want to build with token balance so I'll select the token balance uh I will filter based on a wallet so I will select this as a variable and I will select all the fields that I want as an output so definitely I need amount and because I am fetching ball balance so I need to query name and symbol and if the balance is of nft then it also makes sense to ask about any images from metadata it might have so I'll select those fields and yeah from the token I should also select address and token ID right so these are all the fields that I am going to use for the query now let's go to the filters part so we have very complex set of filters that is allowed so you have and or nor in Clause so all the Clause you have used in any SQL or any database programming language those kind of filters you can build an abstract apis so I'm going to add filter on owner right now and so my query is complete now I'll add a variable so it's Auto completes Okay so okay that's the second let me just reload it yeah now it loads properly yeah quickly build the same query again that's like amount token address name symbol from the nfts I will select images yeah I will rename my query variable to something more meaningful so I will name it identity and I will put it here so in the variables then now I should be able to tell me this little field sorry about this okay I'll just use this one yeah okay we are ready with the query so let us say first I want to build token getting and I want to fetch call balances based on ens name so I just put in nsynophetalic so that's possible ah you might if you are integrating with lens or lens then you can also put a lens profile here so you can also query based on lens profile you can get the same result uh definitely you can put a wallet address so I'll just select my wallet so that's possible too now let's say You're Building token getting so not just owner but you also want to add a filter on token so you will add a filter here and you can just put your token address you see like I have the token so this query can help us help you build the two concreting applications I'll go to the next use case so next use case is more about identity so you want to figure out holders of moon boards collection and along with you want to know about what are the social profiles and the primary NS of those holders so holders are returned from the token balance so I'll again use the same kind of query but and again the token address is Moon birds for me so I will change to the Moon Birds I don't care about owner right now because I am looking for all the holders so I will remove that okay now I am interested in social profiles of the owners so in the owners so owner represents a wallet and you can ask any question about the wallet from this field so you can ask social profiles I'll select the tab name in the profile name similarly you can select ens domains we also have a primary domain if you are interested in that yeah so this completes the query you can just run it so it gets it gives you all the holders of moon birds and it will also give you all the domains and primary domains of those holders let's see some of the interesting data points here okay one more thing you can add ask for 200 records in one go so initially it by default it takes 10 so I will add 200 so you can see you're getting lot more records you can see right this Moon bird is being held by this lens profile who has this ens and this is also a primary NS Forum so you can resolve lot of identities uh with this combination um okay now last two queries are more like a recombination engine that I'm trying to build today so the use case is I have a lens profile and I want to know what all event I have attended that's first part of the query and the second part is from one event that I have attended I will figure out what are the other lens profile who has attended same event so I'll build the first one so the first query is to get the lens profile given the lens profile find the co-ops so the because I am querying on Pops I need to go to the pops API and my input is a lens profile so that's an identity for me so I will select owner right then from the pop-ups uh I will fetch some details about the pop-up event itself so the description and the name of the event uh yeah so this is complete if you want we can change like this variable names these are not that good but I will just keep it same right now okay so this is my lens profile and I can also select event ID yeah okay let me just see what happens here let me try everything here yep so I will ask about the event I'll select some more fields name of the event I can just run this query so you can see I have attended this events one of those event is 8th Denver 2023 so the event ID is one zero three zero nine three so I will just remember this one so here the input was the lens profile so I could say that this lens profile is attended this event now in order to build a recommendation engine you need to also figure out what other what other lens profile has attended the eighth Dynamo right so that's my second query so fetch we have three socials and primary DNS of the people who attended East Denver so this time again I am in povers API but this time I want to filter based on event ID and the event ID of each Denver so I will use this event ID that I got got in the past query and I'll put it here now in this case I want the lens profile of the attendees right so I will go to the owner and I will select the socials and I'll ask dab name and the profile name if I put it here I get the lens profile so not all everybody has a lens profile but I can also select like identity and user addresses so it will give me the wallet address with at least yeah so if you can see like this lens profile also attended ethanver so if you are building any application which has a social angle you can actually build a recommendation Engine with this kind of queries uh I can also like add more records to it so you will see like more data coming so there is also one profile on forecaster who attended the East Denver so combining these two queries I can build a simple recommendation engine ah where I am finding people based on the same activity on pops right OK let me ah showcase couple of more queries ah I want to showcase this bulk social query once okay so we have this wallet API and we have social API so sometime you have a use case where you want to ask for more than one wallet so you want to look up for 100 such wallets right so here we are using something called in clause in the in Clause you can pass array of addresses in one go and you can select ah like put so in this query I am putting like I am finding based on some identity so the identity here is a wallet address so I have 100 wallet addresses and I'm asking for social profiles for those wallets so I am getting all the results in one query yeah so for so you can ask about like in bulk of 200 profiles in one go okay along with this ah if you are building your apps so we currently have two sdks react and python uh I can show quickly showcase how SDK looks like and how you can add this queries to SDK and get the data so this is a python SDK so you need to First install the python SDK and once you have the SDK you need to import necessary files so abstract client is a class that we export and in any of the SDK you will need an API key to integrate so in order to get the API key you will go to the profile page so here I have a profile in the profile you will get your API key you will copy this API key and you put it in the SDK and any query that you would want to run you build on the query Builder and you put it here so you will initialize your query the next thing you will do is you will create an query object and you will just execute that query so in this case you can see I have pops query already created here for service.lens and you can see each query response give me two things an error object and a data object so if error is none you will get the data and you can just use it sometimes you are building an application which requires lot of data and one API cannot give you all the data so you need to use pagination so in that case SDK provides to two ah Boolean Flags in the query response that is next page and previous page so if you have an X page in your query response you can ask for the next page again here so this will give the second page similarly if you want to go to the previous page then you can again go to the previous run the previous page method so I built this small utility function where you can just pass abstract SDK client aquarium variable what this function is doing it's executing the query its collecting the response then it will keep on doing it till it goes to the last page and as soon as it gets the response it will return it in one go and so yeah so this way like you can actually integrate any of the query into SDK so because the SDK is general purpose you just need to work on the query part and put your variables here and you will just run it and it will give you the response like this yeah I think this is it these are the use cases I wanted to cover all of the nfts generated from like minted by white and then query from the properties of those and lefties so you will be able to so for nfts you will be able to query based on ok so the token represents the collection here so you will be able to query based on let me select the tokens API here yeah so you will be able to query based on address name symbol and type yeah you can put the address of the contract and ask it and we have like one more thing that I want to showcase so in the token nfts if you want to query specific nfts of a contract and you want to query based on trades so something which has a background color green right so you can basically go to the attributes and you put like trade type is background color and you put like the value as green right so it will only give you the nfts of that collection who has that background yeah custom properties right ah from Genesis we only have poverts right now ah perhaps and but for ethereum and polygon we have like all the data from Genesis to the live blocks um uh yes we have um uh five two thousand dollar prizes the first three are just for our three favorite projects build anything you want on air stack there's lots of ideas in our notion and then we have a two thousand dollar prize specifically if you build something that makes use of airstack and xmtp or AI or attestation um and xmtp is specific we do a lot with a lot of xmtp projects are building with air stack no we do not um we just think it's uh so xmtb is an awesome way to message people within theorem address and what they've been missing before airstack was a way to resolve say from a Xerox address to an ens or a lens or forecaster Etc et cetera and so we've kind of teamed up together to make that possible and so it's um a lot of applications are making use of that and so if you build something xmtp there's two thousand dollars from Air stack plus another thousand Mexican TP available and then finally if anyone just wants to build a unique visualization of airstack data so if you see right now the response here is a Json file if you want to build something that is just a unique visualization of the response that's another two thousand dollar founder we have as well and just to show you real quickly an example we built a demo app you can look at on demo.airs.xyz which is just a front end to I can say put in any um lens forecaster ens Etc and it is Ping in the airstack apis and giving a visual response rather than the API response so those are the five bounties exactly yeah so if you check out an app called I can show you afterwards um called Converse it's at get Converse they have a recommendation engine built by it's built on top of airstack where if you click on a button that says who can I message it'll show you everyone that went to the same events with even co-ops everyone who you sent tokens to or from um from your transfer history with airstack so it's kind of building it's kind of getting past that cold star problem in web 3 and showing you people you know already based on on chain data other questions anyone all right so if you need any help uh our telegram chat is our team is there 24 7. okay test hello hello is that good you're good don't be afraid to speak up I appreciate it yeah all right I'm gonna wait maybe a couple minutes oh here we go you're gonna be less people dinner just got served got it tough tough competition maybe we can like snipe some people in line because the line's long I don't know anyway um cool all right thanks guys uh thanks everyone for coming um York I'm part of the engineering team at hyperlane and today we're going to talk about permissionless interoperability and what that means um if you have questions afterward or if you want help with integrating hyperlane in the hackathon definitely like come up to our booth or you can ask me questions at the end so just to start today's session I think we need some definitions of the title slide so um permissionless I think a lot of people throw that term around it's kind of like at this point used for marketing but generally like the word permissionless means that a protocol is accessible to anyone there's no kind of discrimination or censorship for specific classes of users to access a protocol interoperability I think our definition that we can use today is composability for applications that are on different uh infrastructure layers and so you know the internet is highly interoperable because we have all these shared protocols that are quite permissionless we have you know HTTP TCP Etc and in web 3 we're just starting to establish kind of these shared standards that allow applications to communicate with each other um but the problem we see today is like the crypto space is facing this scalability problem and people have kind of identified this as the barrier to adoption for the next you know billion users and um you know there's all these great teams at hackathons like this building out these new scalability Solutions um for you know to onboard that uh next next set of billion users but the problem is we're ending up with these like kind of Highly Divergent infrastructure layers that don't actually use shared protocols to communicate with each other um and you know that leads to a big problem I think like if you look at the evolution of crypto we've like continued to diverge with respect to like what protocols we use um I think like maybe the first decade was like just Bitcoin payments it's like a very simple application and then we kind of evolve to these like smart contract VMS and that got a little more complicated and we saw like ethereum and near and Solana all popping up with like different protocols and then we some people got excited about app chains uh because there's like you know different scaling properties that you can have if you don't opt into this like monolithic infrastructure layer like ethereum more recently we're seeing ethereum kind of coalesce around the roll-up scaling roadmap I think vitalik had like a you know seminal blog post about that arbitrum and optimism now do more daily activity than ethereum L1 and these protocols also kind of have their own new standards there's these new DA layers that are in service to those roll ups so we have ethereum 4844 this is EIP that kind of changes the cost structure if you're posting call data to L1 you know we also see Celestia this new like modular da that maybe app chains can post call data to again a lot of different kind of diverging protocols maybe in the future we'll see some sort of like plasma or sharding solution I think there are probably some teams here working on that I don't know what happens I slides oh there we go um but yeah this is a problem um on the flip side at the kind of like looking at this from an application perspective we're seeing a lot of dapps actually adopt these new infrastructure layers which is like super exciting so actually just like a couple days ago Zora which is like this big uh kind of nft social feed and Explorer application that is one of the most popular applications on ethereum announced that their going to be rolling out their own layer 2 using the optimism op stack I think you guys have probably heard of like coinbase's efforts to work on their own L2 there they launched base test net a couple I think like maybe a month or two ago if you look at this website l2beat you can see kind of the evolution of activity over time across these different infrastructure layers and what you'll see is that actually you know a majority of activity has migrated to to ltus and so we need a way for these applications to you know communicate with each other and the problem today is we have highly fragmented market so we have arbitrum optimism kind of the two main leaders I would say ZK sync it's like the fast follower they launched the first validium so people are super excited about that uh and as an application developer when you're choosing what rollup to deploy your application on it's a really hard choice because you know you have to think about what's the security story of this specific roll-up what does the current ecosystem look like is there enough liquidity um you know are my users going to be stuck here if the platform decides to change their you know terms of service or maybe they're going to censor users based on like ofac or something like that um it's a really tough choice there's all these different interfaces for interacting with these things so for example arbitrum optimism ZK sync all have different smart contract interfaces for handling deposits and withdrawals from L1 to L2 moving assets between different l2s there's kind of also highly fragmented like uh Bridge Solutions so depending on you know what applications are aware there's different Bridges available and then more recently we're seeing these kind of General message passing protocols to move arbitrary information between l2s pop-up hyperlane is an example of this um but again there there's just like all these things to account for and and as an application developer you have to kind of know about all these interfaces and you have to custom integrate every single one of these like new Roll-Ups new infrastructure layers and that's just like a really bad place for us to be in um actually just this week vitalik posted about this so like super topical um you know vitalik's like all in on Roll-Ups being the layer that applications should build for and he he wrote a blog post about kind of what the solution space looks like for interoperability between l2s um and I highly recommend this post I don't know what's going on with the connection here yeah highly recommend this post as well as the three transitions post which talks about kind of this like evolution of scaling Solutions and how we can actually you know get users to like adopt these things in a way that's internet scale um but yeah what's the solution to this problem of like fragmentation um we think at hyperlin we think it's modularity um you may have like heard the term modular blockchains it's like also a heavily used marketing term at this point but the main idea is you want to like separate the interfaces which are exposed to applications from the actual like underlying transport layer stuff so you know if we have all these Roll-Ups that have different kind of like security properties I think the three kind of examples we can work with in our head are like arbitrum optimism and ZK sync um all of these Roll-Ups have very different kind of security stories like when they when you can view them as settled what the finality looks like can you use like soft confirmations Etc um and as an application developer like you shouldn't have to think about that or like custom integrate that so instead we can have this like Universal interface that looks like a message passing interface and under the hood depending on the path that we're taking we can actually leverage different underlying transport layers but the application developer shouldn't have to I necessarily understand that there should just be kind of like a community governed uh set of uh standards for like okay if we're going from you know L1 to optimism we're going to use this specific transport layer which is like the optimism bridge to collateralize my deposit um but again like the application developer shouldn't need this crazy like switch case statement of like uh you know if this network do this specific function call so that's where hyperlane comes in hyperlane is this kind of like Universal interface that tries to abstract all these different bridging interfaces through like a what we call this like General message passing interface and so as an application developer all you need to understand is like this dispatch interface and this handle interface so I can walk through kind of the life cycle here but uh your smart contracts or your eoa for that matter can call into this interface called dispatch which basically specifies a destination blockchain via like a chain ID a recipient address on that destination chain and just like an arbitrary body of bytes raw bytes and behind the scenes our protocol will uh you know handle the transport layer stuff um and then on the the destination chain uh basically the handle function will be called on the recipient that you specified and that will also provide the like origin chain sending address on that origin chain and the body that that sender sent and now obviously like as an application developer you want kind of strong guarantees around the content um and kind of like validity of you know messages that you're receiving or messages that you're sending that they're actually going to get delivered um I'm happy to kind of talk about the different guarantees that we have for different Pathways um but generally like because this is a hackathon I think it's like better to sometimes avoid those like you know nuanced discussions of like what the security trade-offs are and just try and build something which is useful or like demonstrates a new use case um but yeah the idea again with modular interoperability is like as an application developer we actually have this interface uh where we allow you to configure your security preferences and your risk tolerances um so we have this like uh interchange security module interface that as a message recipient you actually just configure as an address if you opt into this like configuration layer and the idea is when you're receiving a message our protocol will ask you hey what is your security module mechanism of choice you know we provide a bunch of off-the-shelf components that you can kind of like select from and compose for the various channels so like you know optimism canonical Bridge or you know using Wormhole or whatever it is our protocol will ask your application what security module you've configured for this specific for this specific like origin and sender and body you can actually have control flow on the message body which actually changes the security requirements um and so an analogy there is like wire limits in traditional Finance like if you're just transferring ten dollars across you know two chains you might not care so much about um you know the the guarantees uh that you have in your application and you might not want to pass those costs on to your user but if it's like a million dollar transfer or if it's like some sort of governance action then you might want to like really ramp up the verification requirements um so this is like yeah yeah so so it's it's sometimes it's which Bridge do you want to take um we think that like bridge is like a loaded term um so there's also different flavors of security um you know you can you can you can opt into like Economic Security versus like reputational security or you can have like certain I don't know why this keeps dying um so for example our default security mode for a lot of Pathways is this economic security mode where we have a set of validators who are staking On the Origin chain and they're they're producing these attestations of messages which are being sent from that chain and as a recipient of messages from that chain you can say uh I want to leverage like this Economic Security which gives you a like discrete cost to attack the system and kind of it gives you a lower bound of like hey up to this or I guess an upper bound up to this economic value on this specific message I have like kind of strong economic guarantees that this message was actually sent from this chain because otherwise like the validators will be slashed it's kind of economically irrational and so um that's like one type of guarantee you could you could look for alternatively you could have these sorts of like uh yeah like if you're using a canonical Bridge you have this like fraud proof system where you yeah can can always like kind of do forced inclusion or or those sorts of things but um yeah Economic Security is not the only mode we can do like an optimistic security model which is like a very different trade-off and it's actually like like you can think about it as like operating over the same Bridge or the same tunnel but just like the security constraints that you're imposing on that bridge are actually look very different yeah but who are the validators um so right now we just have like uh right now it's like a white list um but we're like really soon hoping to transition to a fully permissionless like validator model where you can put up any stake any staked asset it actually doesn't matter what asset it is um On the Origin chain and you're basically just like producing attestations it's kind of super easy to run because there's no consensus then the validators are not networked with each other they're just producing attestations on messages that are being sent outbounds just need like an RPC connection to a chain um depends on the Chain uh we have all the information in our docs if you want to check it out so yeah the last thing I want to highlight is this uh I guess modular security Paradigm allows you as an application developer to eliminate this like scary choice of uh being locked into a specific Bridge or a specific uh you know security model or or pathway for your app for your users because you can configure this and so in future if some sort of like you know ZK like client becomes available for some pathway you can just configure that later on um and this is kind of like a way for you to again separate the application layer from the transport layer and we think this is like really important for uh just like application developers when they're reacting to kind of the evolution of all this infrastructure they they shouldn't like impose those things on their user they shouldn't have to tell their entire user base hey we're actually migrating Bridges so you got to go and like unbridge and then re-bridge and then like migrate to our new version like that's crazy so this is just like kind of the the model that we think is better um and it's really a framework for how to think about interoperability we obviously have like specific opinions about like what the default security modes should be um and if you don't as an application developer if you don't specify like your own preferences you will kind of by default be opted into our preferences but um yeah that's the like modular framework the last thing I want to highlight about this like modular security Paradigm with hyperlane is you can deploy hyperlane anywhere so we have a guide right now in our docs that like walks you through all the steps right now it's only available for evm networks but we have um several other environments that are pretty much like production ready we're running on testnet on Solana we have a fuel VM implementation we're working on a cosmos SDK module so really we want to make this protocol and this framework available everywhere so that you as an application developer not only do you not have to choose you know a specific Bridge you don't even have to choose a specific execution environment if you're worried that you know later Solana might become the you know might eat up all the D5 market share or something you know hyperlane allows you to easily like uh have your application exist across all these execution environments and maybe in in kind of the near future your users don't even know which environment they're running on because they just have like this single interface into your application and you decide where it makes the most sense for them to get routed to um but yeah the specific kind of thing I want to highlight here is now uh if if you want to roll it like spin up your own roll up which is kind of I think like you know like we saw earlier something that a lot of people are thinking about um there's like this kind of traditional problem of like okay you've spun your up your roll up but like uh doesn't do anything because it's not connected to anything there's no Bridges operating to it there's no liquidity Etc in the past if you wanted to you know make those connections to existing ecosystems you have to go out and you have to talk to organizations and kind of do BD and establish trust and and like ensure that like you know the bridge that you're getting to come to your ecosystem isn't risky for your users and isn't uh you know gonna just rug you or something um and now that you can deploy hyperlane and you can configure your own security you don't have to do any of that you can start as as a new roll-up you can operate your own um deployment of hyperlan and as you scale up and as you kind of progressively decentralize you can continue to configure the transport layer with uh stronger and stronger like security guarantees for your users but to start out it doesn't really make sense for you to impose those requirements like you don't you don't want to before you launch your roll up you don't want to require that there's like a full like client implementation across like a bunch of different clients or something you just want to like be able to launch your application test it iterate so um yeah we think this is like a big yeah that's a great question um so that's probably one of the biggest things that you need to understand when you are kind of building for this multi-chain future is the introduction of like asynchrony and execution across many chains definitely introduces a lot of complexity and one of those complexities is we don't have strong guarantees of transaction inclusion um at least today um so unfortunately like um the way our protocol works is you pay a fee on the origin chain which covers the gas costs on the destination chain of like transaction inclusion but um you know if that destination Chains validator set is like deciding to be mean or whatever they can just like censor you um and then your hyperlane message won't get processed in future we have ideas about basically like building hyperlane messages into the block proposer like auctions themselves so like we could have you know block proposers like potentially an eigen layer set being aware of hyperlink messages that like want to be included for a specific block and like you know we can have a more sophisticated uh fee market for like message inclusion but right now it just falls back to basically like transaction inclusion which is not something we have guarantees about today so even as a user on a single chain when you attach a fee to your transaction like you don't you you don't have guarantees that it'll actually get mined just kind of like an assumption we make based on like you know the market dynamics that's a that's a good question um so we don't have a native concept of cancellation or timeouts or uh ordering or anything like that like the core protocol is kind of very unopinionated in that respect but um there are middlewares that you can like opt into which can kind of introduce yeah like basically timeouts or cancellation semantics to messages um with the trade-off being that you like lose out on some composability because now applications need to understand that like hey there's this header attached to messages which um you know Define some time out or whatever um but yeah that's that's a great question and something we honestly like I think should think more about um so just to give a few examples of kind of like the developer Primitives and tools that are available on top of this protocol for you guys to use um that are maybe like less intimidating than just this like broad bites pipe uh between chains we have like this this word proud subtraction which is like should be familiar it's like similar to traditional token bridging um where you can yeah basically just like connect uh either canonical token or native token to a bunch of synthetics on a bunch of chains again the kind of modularity of hyperlane allows you to evolve and configure the security of this warp route so you could just as an example which we've talked to with a lot of customers for like a lot of customers are excited about this specific example of like having application specific security so if you're transferring on a warp route you know more than let's say 25 or 50 percent of like all of the circulating Supply on that chain you might want some like administrator in your application to actually like function as a notary or a veto or something just to ensure that like you know your application didn't get rugged by like some Bridge um and with the interchange security modules you can like totally do that really easily so you can have these different like um safety modes we just actually sent the first like token transfer between the Solana devnet that I mentioned earlier and the evm so that's maybe something you can play around with this weekend we also like I said have been expanding to other ecosystems so if you guys are interested in like uh kind of some of those longer tail ecosystems definitely be happy to chat um but yeah this is just one abstraction we also have this concept of interchange accounts and interchange queries which again is like a an API that as a developer you can use kind of simplifies some of this like cross chain control flow so interchange accounts are basically a way for you to have a contract on one chain own assets or do actions atomically on another chain so basically if you're familiar with the concept of like a smart contract wallet this is like smart contract wallet for your contract on another chain um you can basically your contract on the origin chain can like send calls to be proxied by its interchain account on some other chain and you can send assets to your chain account we we think this is pretty useful especially for like Dows if you want to give ownership to some Dow that exists on another chain you can just do that counter factually without the Dow even like opting into it you can just be like hey Dao like I'm giving you this permission to your interchange account um come and you know take me or whatever um and so yeah this is a kind of a powerful primitive for just managing assets on different chains you could do like some sort of multi-chain portfolio management type thing without actually bridging those assets which is like sometimes risky um and then The Interchange queries API allows you to basically make like cross chain view calls so you can like you know go query a contracts function on some other chain um some examples of using this have been like looking up ens ownership or nft ownership on ethereum because like there's a lot of I guess Network effects on ethereum L1 but people want to migrate their application ecosystems to other chains so this can be this is a way for you to kind of have remote views into other chain State and networks and that's it I I guess I'm almost at time anyway um I can't really do the demo because my Wi-Fi has been uh really struggling but I would love you for you guys to check out our docs we have a message Explorer with an API we have ten thousand dollars in prizes this weekend so you know big opportunity if you just want to like use one of these apis you could deploy hyperlane to one of these new chains you could try deploying hyperlane to Zora or base or one of these new roll-ups and have your application do something cool with that um I think we're also looking for people to use warp routes if you use one of these apis interchange accounts interchange queries I'm sure that would qualify so yeah that's it thanks for coming [Applause] um okay because this is this was ethernet oh this is ethernet I just turned off the Wi-Fi I just heard you on the streams gotcha not all good because I really want to build a microwave yeah it should I'll build on Holly it's cool that you could connect like I'm super interested in the the Dow use case because like so many people's Dows are stuck on a specific chain Harmony hopefully the stream wasn't on for that one having a big debate about like yeah thank you you have to hold this in your hand then yeah one one yes well it looks funky on my screen but it looks good for all of you that's all that matters but hey everyone welcome to the last Workshop of the day so you can get to hacking soon I promise this is about getting your dap with the polygon ID verifiable credential so we'll be getting into polygon ID which is like um an ID solution and we'll talk about verifiers issuers all kinds of things this is polygon ID uh I thought I had a oh there it is my slides got all mixed up this is what I get for messing with them right before I'm going on but GM everyone I'm Steph orpilia I'm a developer relations engineer at polygon I'm also oceans 404 on Twitter if you want to tweet or anything or link up there but today I'm talking about polygon ID and polygon ID is really cool to me because it uses ZK proofs and it lets users prove pieces of their identity with verifiable credentials so that they can just present proof of a credential rather than giving up their private data so that works for things like birthdays country of origin and then any customizable use case that you can think of but it's all in the sake of preserving privacy for users and that's really important when we're doing things on chain right because things on the blockchain are permanent and most things aren't encrypted so it's really great to be able to just use a credential and ZK proofs to be able to prove something about you without having to actually put that information on chain okay so this is the first example of something um this is just a data type it's called job held and you can imagine this as a credential it has some different fields so it has employed by technical role and start date so these are some of my examples of job held potential credentials so I'm currently employed by polygon Labs it is a technical role so that Boolean is true and I started back in May last year previous to that I worked at Amazon it was also a technical role in how to start date before that I was at Sony so these are three examples of credentials that I could hold in my wallet that would be of the type job held credential this is another type of credential pet ownership this is my dog teddy um so has dog could be a Boolean field this would be true has cat for me is false I'm allergic but pet count is two so you know I have at least one dog and my pet count is two so it's a little mysterious but all of these are just claims and how do we know any of these claims are true so I could say anything I could say I went to the moon I could say that I work for NASA but how do we know if any of that's true and we know it's true because it's been issued by a trusted issuer who has given a verifiable credential that is actually signed by that issuer if we trust an issuer we can also trust that they're only giving out trusted verified credentials so these can all become trusted issuers or verified credentials by being signed by a trusted issuer so if I said I was employed by polygon labs and polygon Labs actually issued me this credential we could think okay I trust that the company's only issuing this credential to people who actually work there same for the other two places I was employed by so this is just an example is this is your trustworthy like could Teddy the dog say that I've been employed by NASA since 1950 probably not because we don't trust that he's a trusted issuer and this all gets into the triangle of trust and the reason why polygon ID or any type of did works and it all comes back to issuer trust so if the verifier can trust that the issuer only issues credentials to people who satisfy whatever conditions um they have then they can they can accept ZK proofs based on the credentials that they've issued and so in practice this is what it looks like so the issuer in the job held case would be George my previous manager at Amazon hey George he's not watching he's he's like still way back in web 2 but good for him so George could issue me a verifiable credential of job held he can say that yes I was employed by Amazon my role was Technical and this was my start date then a verifier website or dap could come and say hey has Steph ever had a technical role in a job yes or no and I would have something in my wallet that would say true I have had a technical role before so I could present this credential and create a ZK proof based on the credential that says that I satisfy the requirement of having had a technical role so you can think of a verifier that might want to do this maybe it's LinkedIn and they want to give me a badge for being a technical developer or maybe it's my next job and they want to know if I've ever coded for so they're also interested in this but the power of polygon ID is that these issued verified credentials can be used unlimited Times by different verifiers and they're all using that same data that only has to be issued once so you might be thinking like how do we prevent Teddy the Dog from being a trusted issuer we don't actually have to so the verifiers can specify which dids are trusted issuers so you can see in this code allowed issuers is set to all so for this case anyone could actually issue this type of credential and the verifier would accept it but you can imagine that down the line maybe a dow could manage who is a trusted issuer or any other solution to kind of like improve the trust maybe there could be even scores of issuers to make sure if someone had issued a bunch of bad verifiable credentials they were bumped down in the list so I don't know if anyone ever watched Harry Potter I did I watched all the movies I read all the books if I'm on a plane chances are if I have something mindless to do I'm watching Harry Potter but anyway Harry Potter has one of the most famous issuers of all time and that's the Sorting Hat so when someone new comes to Hogwarts they put on that hit the hat and issuer says which house they're in so Harry is famously like on the fence between Slytherin and Gryffindor but then at the end the issuer uh which is the Sorting Hat is like hey harry which house do you want to be in and he says Gryffindor so he's kind of like self-selected in but the issuer which is the Sorting Hat gives him that Badge of like okay you're in Gryffindor and so you can think of that that house as like the verified credential and then Griffin or the issuer is the Sorting Hat and Harry is the person holding the credential and he can reuse that verified credential in lots of different places all over Hogwarts so maybe he's getting into the common room and he's using a Magic Door that's the verifier and it unlocks the Gryffindor common room or maybe he's trying out for the Quidditch team so I can't remember what this guy's name is is it Lee anybody know there we go the team captain can say only gryffindors can be on the team so he's checking against that verifiable credential again for Quidditch team eligibility so that's just an example of how you can reuse these credentials anywhere so what does this look like in the polygon world it's not quite as fun as the Sorting Hat unfortunately but this is what your data looks like so I have three different different verifiable credentials in my polygon ID wallet which is a mobile app uh the first is like almost like an event ticket proving that I went to polygon at the pit which was an event the next is an example of proof of personhood this actually hasn't been implemented yet so if anyone wants to connect World coin and polygon ID that could be a killer hackathon project um but all of this data is stored in your wallet and it holds the VCS and interacts with verifiers once you need to prove your identity so this is what it looks like as that VC is issued so your sense you scan a QR code and it says accept credential offer then the claim is added to your wallet and it's put in your data and then you have some information about the VC that's held directly in your wallet and then this is what it looks like when you go to actually verify claims so verifiers or dapps will have a QR code on their website as well you'll scan the code and it'll ask for a proof request of something specific so in this case it was polygon ID membership are you part of this Dao yes or no and then it generates a proof for you so you don't have to code this or anything it generates a proof that actually shares the the answer to this question so yes or no and then you can manage this from your wallet forever so if you don't have the polygon ID Mobile Wallet app yet you'll have to get it in order to kind of like interact with the the demo site and any of the other polygon ID sites right now we just have a mobile wallet we don't have a desktop wallet yet but that's another cool hack idea if anyone's to build like a desktop polygon ID wallet but currently there are two ways to issue claims so to be the Sorting Hat this is the easy way there's currently only two two types of claims that you can do the easy way which is by using the demo issuer UI so the first one is an age credential so that's what I'm going to demo today and the second one is a country of residence credential so some things you could check with an age credential or like sample use cases are are you older than 13. a lot of social media sites like Tick Tock and Instagram and be real the first thing they do when you log into their app is they say add your birthday you have to be over 13. so that could be a cool use case for adapt as well if you're creating like a social dap or maybe you're creating adapt that's just for kids and you say you have to be younger than 18 in order to like sign the yearbook or post a message so you're making sure you don't get like creepy adults and then for the kyc country of residence credential maybe you want something that's specific to Canada um I'm I'm like loving all of the stories that Canadians say I think it's so cute uh so maybe you you say sorry only people in Canada can use this app and you have to prove that your country of residence is Canada or maybe you're creating like an election app for a specific country and you say you have to be a resident of this country in order to use the DAP or maybe it's something like Country-Wide and it's only for EU residents anything like that could work for the demo issuer UI because it is able to create these two types of credentials so I'm just going to really quickly show you um the demo issuer UI so it looks like this come on Wi-Fi so you sign in with your polygon ID wallet and then you can create claims just to issue yourself as demos so like I said you can either create an age claim or a country of residence claim I'm just going to give myself an age claim so it auto fills all of these fields but the main thing you want to think about is the data that you're putting in the actual claim so this one is for birthday I'm just going to add my birthday or actually no I'm gonna add a slightly different version of my birthday this birthday is August 24th 1994. so I'm submitting this and then it'll create a QR code so I'm opening up my polygon ID Mobile Wallet app and all I have to do to get this QR code in my wallet is scan the QR code so it's asking to issue this credential to me in my wallet I'm just accepting the credential and it's added so now I have this birthday credential or this kyc age credential that I can use all over the Internet and that's kind of the basis of our verifier which is what I'll show you next okay actually before we get to the verifier there's a second way to create or issue credentials and that's by using our dockerized issuer node so this is what you'll need to do if you want to create custom credentials like let's say you wanted to issue people anything basically that's not an age credential or a country credential you'll have to host an issuer node it's dockerized which is kind of nice and then you can just kind of like host them publicly with ngrok and that's how you can kind of like demo your app if you want to go this way so if you want custom issued credentials scan these two links that will take you to the code for the issuer node and also the docs to the issuer node and I put all of the sides by the way in the Discord channel so if you missed anything or need the links they'll be in Discord okay so going back to the triangle of trust we've learned about two things um the issuer which is either that demo issue or a UI or the self-hosted issuer node also we know the identity holder is you and you hold those credentials in your polygon ID Mobile app so the last thing that we are not quite sure about yet is the verifier and this is what receives those ZK proofs and checks against them so back to the Harry Potter example we saw the demo verifier and what it unlocks in this last example the demo verifier is actually a VC gated website so it's a verifiable credential gated website and it unlocks a secret dap or app that you can only see if you've proved your birthday so this is what it looks like and the request is prove you were born before 2023 in order to view so I think that's everybody in here no babies are hacking at eath Waterloo this year but maybe they could eventually maybe a vitalik's kid honestly if he had a kid uh so if you need to prove that you were born before 2023 to view you would be doing something like this in the code so this is kind of like a really simple um query and the credential subject is on line nine it's birthday and you see this like funny looking query language on line 12. it has like a dollar sign LT which stands for less than a value so less than 2023.0101 so we're checking for line nine the birthday field is less than or before January 1st 2023 and so this is the proof request that will send from the front end via QR code and this is what it'll look it'll look like on the front end so a modal will pop up it'll say scan this QR code from your polygon ID Wallet app to prove access rights and if you can scan this and successfully generate a ZK proof it'll send back a successful authentication response to the website and you'll see the next page and so this sounds a little difficult but it's not because I created a template for you all on GitHub and what this gives you is all of the front end and also the server code for creating this verifier website so with the last 10 minutes I'm just going to kind of like walk you through what this template looks like and what it does and the parts that you should modify for your own dapps oops okay so this is that GitHub repo you can see there's two folders in the repo there's a front end and a server so the the great things about this are that it's built with react.js which a lot of people know because it's just like a pretty common JavaScript library it's already VC gated for you with that polygon ID age credential we saw before the birthday credential it's fully connected so that the DAP that you hide behind the VC credential is already connected to a demo dap with examples of how to read from the blockchain and also write to the blockchain so you should only have to kind of like do some frankensteining and just a slight bit of open heart surgery when you're like adding your own smart contract in because it's mostly done where you'll just see examples it's also already styled with configurable components from Chakra UI when I'm hacking I I like go down this Rabbit Hole of all just create the components myself and then I realize I don't have time so I just made that decision for you to make it easier and then um it's also just like ready to interact so it's connected with rainbow kit wallet and it is connected by default to polygon networks but you could replace those with anything you want so to get started with the template you'll just come to this GitHub and you'll say use this template and you'll click create a new repo it'll have you clone the new Ford repo from GitHub down and let me show you what it's got so I'm running it right now it has a server and also a front end the server is making two different API calls to the verifier sdks of polygon ID so let me just open the code quick so this is the server this is the index file it has just like a general welcome page it's really not doing anything here so the server runs on localhost 8080. this is just telling you the two available API routes so the first one is get off QR and that shows you that QR code that generates the proof that's sent to your wallet or generates the request for the proof I should say and the second one is API verification callback that's what uh sends the Callback to your front end saying whether or not you successfully authenticated so you need to be running this server in order to be able to get and post this data to polygon ID oh and then the last thing to mention is that when you're running the server this is in the instructions in the readme as well but you'll want to run nrock on the server so that you can have a public URL for the server because of that callback to the front end um otherwise you'll have some issues with cores and also the polygon ID app has to know about the public URL of your server and if it's just on localhost it's not connected to the internet so the polygon ID app has no way of saying hey this is the response from your API call so that's the server it's pretty minimal it's just built with Express and also sockets there's nothing in the server you should need to modify except for one file and that's proofrequest so inside of proof request we see that credential subject birthday and the query that I showed you in the slides before so this is that query of birthday is less than January 1st 2023 if you wanted to you could change this date or you could totally change the query from kyc age credential to a country credential or a custom credential as long as it existed already in some type of schema so that's the server and then the front end is what's interacting with the server so we'll just open the readme first so each of these folders the front end and the server also has their own readme with a few more instructions um but this is just that page that is created for you know what I'll actually just go to where I'm running the front end locally which is localhost 3000 so this looks almost exactly like that other page that I had except for this is kind of just a full stack template version so I'm just going to quickly prove my access rights to this page with my wallet so as you saw I already created that kych credential and gave myself a birthday that's definitely before 2023 so I should be able to authenticate with a proof and it looks like it's preparing off so once it starts running authentication yep it runs the spinner it said verified proof and it shows me the secret page or the VC gated page which is actually adapt and like I said what's cool about this is this dap is already connected for you to the polygon ZK evm testnet so it's got the wallet connect button all of that's done so conceptually all you have to do for all of your applications is write this smart contract with all the business logic and then kind of Port it into the step so in the front end code you would just start changing out uh just like the the front end things so I'll show you um so I had a demo smart contract my dap that's behind the the gate is just a counter app so all it's doing is I push the button and it's incrementing the counter up one so I sign it goes up to 19 and that's all tracked on the blockchain in the smart contract basically what I wanted to do with the counter dap was give you an example of reading from the chain so this this value 19 is read from the blockchain and then writing to the chain with the increment counter that's updating in value so you have both of those examples when you're doing anything with your smart contract low battery okay so so all of that dap is happening the DAP code is happening in the VC gated app file so feel free to like gut all of this or change it to reference your smart contract I just had this smart contract address here my ZK evm smart contract address so if you change this out then you should also be able to go through and update the read function and also the increment counter is the right function so you can see there's already a con a read contract function so all you would do is change out the function name to whatever your function was using and then the other thing you would update is the ABI I just put mine here it doesn't necessarily have to be there it's just where I rooted it so the ABI will just have all of the available functions from your smart contract so I had two called retrieve and what was the other one increments but all of the polygon ID stuff is created for you so the only things you would be customizing really are the queries and the type of credential so changing the age credential to either country credential or your custom credential that was issued issued excuse me either by the the demo issuer node or your self-hosted node yeah so again this is that uh QR code to the template hopefully it's super helpful but if not I'll be around all weekend and also in the polygon Discord uh to answer any questions and help I love building so I'd love to help you if you run into anything no question is too dumb I promise um and actually if you use this template you're automatically in the running for two of our prizes I just have to plug the prizes really quick we have ten thousand dollars in prizes this weekend so three thousand for a public good with account abstraction so if you wanted to double up on prizes I saw that uh gnosis safe has safe apis they're also giving away two thousand dollars for hacks with account abstraction so if you built something with safe apis on polygon you'd be eligible to win like five thousand dollars pretty good next one is best most Innovative hacks deployed on polygon zkevm ZK evm is uh what I just showed you so this counter app was deployed on zkevm zke evm is so similar to ethereum that all you have to do when you're deploying to it is change the RPC URL so instead of uh Gorly eth you point to polygon ZK ebm testnet that's the only thing that changes which is pretty awesome so you don't have to worry about code you just change the string so the best tax on that are also eligible for 3K and then I just added some random ideas that I had I feel like eip6551 is so interesting the nfts that can own other nfts so super interested in any hacks like that or maybe you're interested in cross-chain hacks uh the protocol before me just did a really cool cross chain hacks Workshop so work with that if you want to do a cross chain hack the next one is directly related to ID which is what we just talked about so two thousand dollars for best use of polygon IDs verifiable credentials so VC gate your adapt just like what I showed you whether it's an age credential a country credential or something custom and you're eligible for 2K there and then the last one is mostly for beginners but I plug it anyway because everyone can win this prize all you have to do is build in public so we want to see your tweets about what you're building so that my social media team can go like whoa eath Waterloo looks so fun so all you have to do is Deploy on polygon and post a tweet about it um linking your smart contract or your GitHub this is the specific link so if you open this link it'll pre-generate the tweet for you so if if you're like oh I gotta submit my hack tomorrow all you have to do is click this button and update literally one thing this should be the easiest thing you do all weekend add your GitHub here tweeted out and you'll win a portion of that 2K all right I think that's everything for me today thank you so much for listening and like I said I'll be around all weekend ask me for help I'm happy to help thank you [Applause] sweet thanks 