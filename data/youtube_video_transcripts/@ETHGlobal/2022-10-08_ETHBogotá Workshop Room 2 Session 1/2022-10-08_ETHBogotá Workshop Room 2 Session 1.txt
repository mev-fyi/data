these notes what exactly does that mean um it means that you need essentially a server running 24 7. uh is that going to be an old computer is that going to be a Raspberry Pi is there going to be a rack server you're going to put that in the cloud are you going to be able to make sure that you can securely access that are you going to figure out how to scale that if your demand grows there's a lot of work that is completely unrelated to someone building a smart contract on ethereum when it comes to actually standing up the infrastructure needed to get your applications out to users but wait what about like clients unfortunately while I'd love for them to exist they're not really here for web browsers yet um they still need to handle a bunch of complex behavior in communicating across the network and they offer a considerable amount of latency and bandwidth costs for historical lookups and they always will unfortunately and so in comes your RPC service this is what metamask uses whenever you use it to talk to an application is what Ledger smart contract integration uses and Trust wallet and guard a wallet and my ether wallet and basically every web app that you've used but what exactly is an RPC stands for remote procedure call uh what happens messages are communicated between the application and the node in Json nodes expose it via https API as well as web sockets it provides the lowest technical barrier of entry for application Developers almost everything can communicate strictly through Json and http who handles this was the miners now validators it's a little outdated and sorry about that is this what gas is for no it's not validators can choose to serve RPC but they have no obligation to do so on the network there's no untrained incentive for nodes to service applications with RPC even though it's the primary way that applications interact with the ethereum blockchain there's offering solutions that we can use private entities have really stepped up to fill the need and some examples of these are inferior Alchemy anchor while these are accessible they're all centralized and require monthly Fiat payments to keep that application Live and running typically the only solution for smart contract developers who and this is really the only way that smart contractors or smart contract developers who don't have the know-how to manage infrastructure are able to interact with the blockchain until pocket Network um what are we we're an independent blockchain with a native token called pocked and no Runners can come onto our Network and earn pox for servicing RPC relays apps can take out that part to get access to that RPC layer what this does is it provides a utilitary market for blockchain infrastructure it makes RPC permissionless and decentralized it all sounds neat but how does that help you as a developer here one thing is you have less risks from outages pocket nodes running in a pretty variety of configurations we have people self-hosting their own Hardware running computers right out of their their worker home office if some people choose to host up on cloud providers AWS Azure digitalocean all the works there's services that offer directly that we have no runners run on talking here ovh IBM Cloud bare metal it's it's not really running in the cloud they're renting that Hardware directly this makes Brazilian to outages at the cloud provider and data center level also gives you the availability for the first time to own your access once an app is staked on the network that relay rate is blocked in as long as that app remains staked what this means is there will always be supportive services as long as you keep those tokens locked up what that means for you as an app developer you don't have to worry about that monthly bill coming in you can't accidentally run up a massive uh compute Bill charge without realizing it because your users decided to go Hog Wild on the interface you can recoup some of that initial infrastructure investment by unstaking and selling in short with pocket Network web for the infrastructure becomes an investment and not return cost to end Developers so let's get started with what you can actually do at the gate we offer free tier through our portal so that you can get started right away today it's an application that we've built on top of pocket Network it's available directly at portal.pocket.network and it gives developers the user experience of the centralized options that they're used to building with today gives them a dedicated RPC URL gives them security configurations for how they protect that URL give some dashboard full meaningful metrics about where that service is flowing through gives you a Lurch when you're approaching your band with limits and the free tier is currently offering it's a quarter million relays a day um and it's as simple as going up getting started registering creating an app you have all that data available to your application page if your availability to set up security set up your notifications and you're ready to get rolling once you have that URL so let's actually see how when you get that URL how you use it we'll start with solidity development environments if you're building a smart contract we'll get hard hat as a popular example it's as simple as in your hardcat config.js JS file specifying in your Networks mainnet here example is our ethame net endpoint and specifying robsten drop in that Ralston URL that you get from the portal rank B and Gourley and coven all right there that when you run anything in hard hat you can just dash dash Network specify the name you're running that live environment so you're building in truffle very similar in your module.exports in your Networks basically the same thing except you have to specify that the port it's going through is 443 because it's it's SSL protected and you have to specify the network ID of the chain but that's normally uh something that you have to do with trouble anyway but just as easily take that format drop in the URL you have robbed in here your rank B you have Corley you have coven again just as simple as dash dash Network and your network of choice and you're running live with us you deploy you can test you can run queries everything that you would do from the console Network remix say you've never really built with us before you want to just drop it in and start using us in a in a more IDE environment all you have to do is navigate to that deploy and Run tab select web pre web free Provider from the drop down and then put your endpoint in right there and you're good to start deploying with us and testing with us in remix live as well so now let's say you're using pocket but in a JavaScript front end in ethers it's as simple as specifying your URL and initializing it in their Json RPC Constructor and you're good to start making queries directly to the chain remote web3js just as easy take that URL just start using it right on the chain but at python if you're building something that lives in the back end take that URL and drop it into web 3 Pi's Constructor and you're good to start querying that chain what about if you're not a d app developer but you're still interested in the space you can use us in your meta mask all you have to do is Select add a network from the drop down enter in the public RPC information that we offer a variety of and then you can repeat that for any of the chains that you interact with metamask with including we have Avalanche Public rpcs gnosis public rpcs fuse polygon a whole variety of public rpcs that you as a user not even as a developer can take access of these are available on our docs under our resources we have a public RPC endpoints for you additionally let's say you're a developer who's not just building on ethereum I'm sure there's a lot of you here today here's an example of how you can quickly leverage us to not just build on ethereum but throw in optimism as well it's as simple as taking those endpoints and dropping anywhere you need to that could again be in the solidity development environments that could again be in any libraries as long as they work in a Json RPC provider or in any of those environments you're good to get rolling on those networks too currently right now we have a full list of it's honestly now pushing close to 40 blockchains some of the big ones that come to mind that we recently integrated starknet optimism Avalanche we have a whole variety and it keeps growing and so what we're going to encourage you today is that if you are building anything with us or if you're building anything this weekend you need to deploy a smart contract you need to build an interface to it we're offering a 2500 price we'll split between any developer who deploys something and utilizes us and we encourage you to uh this link will take you to essentially what we ran down today and even more about how to integrate yourself in various uncovered programming libraries in case you're not a JavaScript or python Dev as well as some other um smart contract development environments like Brownie and um Brownie and ape works so I'm excited to see what you all build open it up anyone just questions on the RPC URL like what to stop if there's like a DNS like outage on that it's like a global DS outage we're talking yeah I mean that's a good question but then we're now talking the whole units down but I'm talking about let's say the ddns for that that URL that uh were provided through I guess through the app like is that like are we hosting that or like in the portal it provides the URL right so that what the portal is is I can go back there um so the portal is an application that's built on top of pocket directly what that means is what that means is the portal under the hood is leveraging pocket Network to um to kind of give that ux development layer to Developers okay yeah yeah the portal is not pocket Network it is built on top of pocket Network okay but for for a lot of smart contract developers the or people building interfaces to Smart contracts uh to actually kind of rotate through um every hour the list of providers that you can receive service to changes so every hour each application gets a list of 24 providers that they can receive service from and so for someone who's used to taking a URL and putting into the app it's a lot harder than maintaining that that rolling infrastructure but under the hood it's not fundamentally tied to that um okay okay anyone else awesome thanks everyone looking forward to seeing where he is built again [Applause] [Music] foreign [Music] [Music] [Music] [Music] foreign [Music] [Music] eventually [Music] come on foreign [Music] come come on [Music] come with me [Music] come to me [Music] [Music] foreign [Music] [Music] [Music] [Music] foreign [Music] [Music] [Music] [Music] foreign [Music] foreign foreign [Music] [Music] shining bright bring me joy inside [Music] foreign [Music] [Music] [Music] [Music] inside [Music] [Music] what's up [Music] foreign [Music] [Music] [Music] [Music] foreign [Music] [Music] [Music] [Music] [Music] let's come together [Music] don't forget [Music] [Music] [Music] [Music] make the same mistake together [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] foreign foreign [Music] [Music] not your commodity [Music] [Music] oh yeah [Music] [Music] who are you supposed to be Germany [Music] not you okay it is but for today we're going to be doing kind of like the the presentation in English and we still will try to kind of like share some some resources in English and hopefully in Spanish soon so do we start okay cool well so hello everyone I am Diego Lee saraso this is Taylor what's Caldwell okay okay I didn't I didn't picture that one okay there you go so we're going to be talking uh a little bit about coinbase a little bit about uh coinbase products and uh Taylor is actually going to take over a little bit almost at the end uh for some demos so I think that's kind of a really important part and especially if you're hackers and you're going to be doing some hacking during the weekend with coinbase products so well you see our pictures there we're developer relations engineers I think that's kind of like a long title just for saying we're developer Advocates or developer evangelists and yeah that's that's it okay important thing that is currently showing is the transition between web 2 to web3 you know and we're going to be talking a little bit about that at the very beginning because obviously not only the Technologies change but uh right now we're kind of like an interesting point especially with web3 in terms of the maturity of the technologies that we're using in our day-to-day you know so like quite likely when you're creating a new dap you're going to be facing some uh well or using some technologies that are could be in Alpha State beta or that uh six months from now could change completely so that is kind of like an important thing uh the other thing has to do about well kind of like the the change in mentality of how things are done between web 2 and web3 and uh I think like well Taylor was going to tell me like this is a good example has to do with AWS and specifically that right now on web 2 because it has been around for so long you can expect that almost everything works you are not really thinking about uh what you are using you are just solving the problems that you want to solve as a developer and then immediately spin like a new instance of uh whatever and it's going to work it's magic you know and it's only magic because it has been there for quite some time and you rely on those things you already can like expect that things are going to work and you don't really think much about that on the other hand web3 almost everything is well being created right now and that's going to be a big part of what our team at coinbase is going to be working on now so this is a little bit how at combines we see what we're kind of like trying to do so right now there are different parts of coinbase so retail uh institutional and all that but at the end uh like kind of like the team that we're part of that is coinbase cloud uh we have seen that we have like that layer that is quite important in between the protocols and like the business kind of like uh value that we're going to give developers and you see and we're going to mention them and we're going to kind of like cover a little bit uh some of some of those specific Parts with like data access as taking trading identity so uh today we're going to especially mention payments although we're not going to focus there uh like the the important thing is going to be around wallet and around node that even this week even today was the announcement for new features with wallet right so specifically today and node was launched two weeks ago which I think it's amazing and is this the one for node yes so this is something that I really like and is because the no team spent a lot of time trying to simplify the entire experience for a developer to start creating a node and to start working with it and that is going to appear in uh Taylor's demo and you're going to be able to uh go to the free tier during this weekend create a new node and immediately you're going to be able to start writing reading from from the blockchain and you are not going to have kind of like a lot of effort this is really kind of like click go and you are ready to go uh a lot of people ask about like hey uh right now the free tier is ethereum if you want to kind of like work with one of the other blockchains I think it's 25 last time that I heard from Sri that we have already working what is it that you do that that's pretty much the moment that you can like talk with us and then we uh kind of like let you have access to that if you can like show us that you're going to work with that but if you're going to have this like a project that you're going to create during the weekend you're still going to um well use ethereum and you have the free tier which is amazing and and then you kind of like pretty much be ready to go um oh okay so this is wallet Okay cool so that's the other product that we're going to be talking about so and uh that we're going to have a demo so obviously if you're going to create a dab you need a way to kind of like well sign your transactions you need to integrate it and that's pretty much a big part of the of the demo showing you how you can easily use uh coinbase wallet and integrate it into your dapps okay so I think I'm already currently giving you ideas for what you can do during the hack we are we are and we're going to mention that the challenges that that we have so if you start creating uh well adapt start having a project an application that you are using coinbase node and you integrate or integrate and or you don't have to do both is pretty much what fits what you need uh using um coinbase wallet then by all means go ahead and do it uh like I said we have like new features that were really today including uh faucet testnet so we're going to go through the I think there's a slide with that so we can show you and I see that some of you are taking pictures of some of the slides so then you are going to be able to do that um uh this is for pay so we're just going to mention it here this is something uh that if you want to pretty much kind of like do the entire on-ramp you also can use but this is not the focus rule for the hackathon I we just wanted to mention it there because obviously coinbase cloud is growing for once and we have more products it's just that for this particular event we wanted to highlight coinbase node coinbase wallet but you have more so my recommendation is that during the weekend if you have the time or after the hack uh go to the documentation and you're going to be able to learn more about all the products and of course try to figure out like how is it that you can use it in your day-to-day projects uh okay okay so these are kind of like well I was mentioning about the different products so here you can see a little bit about that so data access identity payments uh I think for today pretty much we're going to be covering those two so obviously with node we're going to be focusing on the data access and with uh coinbase wallet you're going to have a cover identity but like I said we have more than that and I encourage you to just go and check them all these products and I think this is something this is complete and uh unashim advertisement and is because we have some of the people from the coinbase note team right here and one yeah like over there like okay um and really one of the things that why we're collaborating and participating in these events is because we need your feedback okay so whenever we have a new uh product whenever we have like a new idea of course we get excited about what we do you know but we have all these resources at our disposal at coinbase but perhaps what we're thinking about is not exactly the same thing that you are doing in your day-to-day so we don't want to count like throw features like crazy without really covering what you are doing without helping you in your day-to-day you know like we are providing tools that you need to use and if you don't use them then well then we're not doing a good job so we need your feedback and a big part of the challenges that we're going to present at the end have to do with that we're going to pretty much give you money if you use our products but a big part of that is for you to give us the feedback get you're hands on get dirty find the bugs find the things that you like the things that you loved and the things that you hate because we know that well no product is perfect at any given time we always can improve it so it is important that you give us that um okay okay so uh obviously the let's leave this link there for a second although at the end I'm going we're going to show like a QR code that you guys can go to but if you're interested in learning more in general about the products this is the place to go from there you can go to the documentation from there you can get to the samples from there you can create your uh node uh account and that uh I think are you going to create it from zero the account so Taylor is going to show you how to create account from xero and pretty much 15 minutes after you leave this presentation you are going to have already a node account running and you're going to be able to read and write so on the chain of course uh that's it uh and well there you go no demo yeah so let's dive into some demos so the first thing I want to demo today is the node uh product that Diego talked about so node is our um product that allows you to spin up and self-serve nodes to read and write uh data from the blockchain you can do it in a matter of seconds all from the cloud console that we have on our coinbase Cloud website so let me just exit out of this real quick so if I visit coinbase .com cloud you'll be visited with this um that says get started with node so you can click that and it's going to prompt you to actually log in to a coinbase account so after you log into your account you are now at the cloud console where you can select a bunch of different products that you want to start building with today I'm going to show you how to build with node so here's the console you can go up here and create a new project and start for free today we announced support for gorley test net so everyone here that's uh hacking away and wants to hack away at a test net you can use coinbase node on the Gorly test net so start free here you can give your project a name so I'll just name mine Tay node and down here on the drop down you can select a network um so once you do that notice bun up for you and you're ready to go you'll be prompted with a modal that provides user credentials so a username and password these are your authentication credentials that you can use to actually read and write data from the blockchain using our endpoint if this was for your project you would want to go ahead and copy these to a secure location um and then click next and then the next part of the modal actually shows you a code snippet that allows you to make your first request using our endpoints so if I copy and paste this right now in a terminal let's see so spin up a terminal paste in that code snippet and it looks like I have a protocol error um but I'll show you I'll show you a setup that's actually set up properly using Postman in a second so that shows you had to make your first request and you should get back a valid response um and then you're good to go so after you create your node project you'll have the dashboard full of different metrics so you can see how many requests are being made to your endpoint and stuff like that how much traffic you're getting um here I have a Postman collection that has all of the different apis that you unlock when you do spin up a node using coinbase node we provide a set of advanced apis that allow you to make complex queries to the blockchain so if you're used to building applications by using native ethereum apis maybe you've written code to you know get a bunch of transaction history for addresses or get nft collection data and you notice that it requires a lot of different requests you have to get the contracts the IDS you have to put them all together in code with nodes Advanced apis and nft apis you can do all that using just one simple request using our endpoints so here I have a postman collection and I have um our endpoints for balances and allowances this first example you can see I can make one single request and get token balances for multiple tokens and multiple addresses at the same time in this example I'm retrieving data for usdc and die token for a single address so I can go ahead and click Send here and you'll see that I get data back for multiple tokens just using one request um going even further uh the API endpoints do support both erc20 tokens and ERC 721 token so if you are building nft applications you can use this as well um and then as I go down the list you can kind of imagine what things you can build using these endpoints for example the endpoint I just use right now to get token bounces you can you you can use to build an asset page or asset menu for like a wallet application um if you want to build on that wallet idea you can have a transaction tab within your wallet to get all of the wallets past transactions who sent what to who and what transactions failed and succeeded and to do that you can use this endpoint here called get transactions by address where all you simply do is pass an ethereum address to this endpoint and you can get all the transaction history in the paginated manner um using a single request so here you can see me grabbing transaction data for a single address and provides a bunch of different data things like transaction hash the to and from addresses associated with the transaction the token transfer data and stuff like that um we have a another set of um endpoints that are associated with contracts so a lot of the time you want to read and write data to a specific contract such as getting like the total supply of the contract or the name of the contract the symbol stuff like that it's all on chain data but when you read and write or when you read the data from the contract each of these is a individual request that you make so what our contract apis do is it allows you to get all the token metadata in a single request so you can see here I query for token data for usdc token and I get the total supply of the token the name the symbol associated with the contract itself taking it even further we support nft contracts as well so here I'm getting the data for or the on-chain data for Cool Cats which is the name um and the total Supply now when we talk about nfts specifically a lot of the data associated with them isn't on the contract itself and we store it off chain that's because storing data on chain can get quite expensive so for that if you're building something like nft Marketplace we have a select um we have a suite of different nft API endpoints that you can use to get nft metadata so if you're building a Marketplace we have you can be able to you can create a list a bunch of different collections based on a collection or contract address you can get data for a specific collection to get deeper data for that collection so here I have data for mutantape Yacht Club so things like the address the name the description the symbol we also do something cool where we take the image data for the nfts and we cache them for different sizes so there's the or original size the large size small size and stuff like that um and then building on the nft marketplace uh example if you are building a Marketplace you probably want to be able to display nfts and who's trading what and the past history of where this who's on this nft and to do that we have an endpoint for um getting collection activities so that's kind of a high level overview of the different Advanced apis and nft apis that uh node unlocks these are all available for both ethereum mainnet and ethereum gorley test net yeah sure well when I think I lost microphone here um so well one one of the things that I really like and this is again a little bit praised to to the team uh is that the first time that I was kind of like checking uh everything about node I was just kind of like using well curl you know that's how it was kind of like checking like all the requests when I I was doing like my my little tests but one thing that I really like that I think it would be really useful for you during the weekend is that if you go to the documentation there's a section that is just sample requests you know so like 80 already kind of like covers most of like the big case scenarios that you're going to have of course if you want to go into the details the documentation is there but these ones you can copy paste and of course because I was just using curl I was in my terminal that I don't have my Mac here so now I can not do it or at least not how I would like to I really love the fact that because you have that little request that you can copy then you can go to postman just like how Taylor was doing and you can import that entire thing so you could change just like well your credentials and immediately can modify it if you want to and they don't post money and start making a request so I thought that it was like one of these small things that the team did just to make the life of developers better and and and I think I thought that it was really cool when I figured out because I didn't know about that and I was like just like send on the terminal blah blah and they're like oh there's a better way to do it that is already covered and sometimes uh those small details kind of like show how much the team cares about that experience that they are trying to create for you as Developers yep yeah so reading and writing uh data from the blockchain is probably the first thing you want to learn as a developer and you'll carry that skill with you throughout your journey as a web 3 developer and we're here to make it uh super easy and super simple another key primitive to web3 development is identity and for that we have our coinbase wallet coinbase wallet is a self-cust custody wallet that allows you to store all your crypto assets in Secure manner you own your keys coinbase does not own your keys that's a small uh confusion that some users have so um coinbase wallet just to give you a little bit of context I'm going to exit out of this slide real quick coinbase wallet is our self-custody wallet it's a multi-chain wallet so it supports all layer 1 evm chains as well as layer 2 evm Chains so arbitrum optimism polygon we support it all in addition to this we support Solana which is not evm chain and here you can see an example of wallet we have a few cool features for both users and developers so the first set of features is that our assets page lists chain or assets from across all the chains so if you have let's say Matic from polygon and usdc and ethereum or Solana it's all you can view all of your assets in one simple view if you're a fan of collecting nfts we also have an nft Tab and close to instant nft indexing built into our wallet and then if you're a Trader you like to do some native defy trading we have a D5 tab as well for you to do that all embedded within wallet um and then moving on because I know we're we're talking to a bunch of developers right now um You probably care about the developer features so we build coinbase wallet as a developer tool as well focused on the developer experience so we do support things like test Nets and we recently released testnet faucets built into a wallet directly so if you're a developer and you're used to going to different web applications to grab some test net assets and you have to like sign in with your social media accounts you can instead sign up for coinbase while browser extension today and actually go directly into the settings visit testnet faucets and then click the test net that you want to get test net assets for and then I'll just do it live here um and yeah so you can basically get Tesla assets sent directly to your wallet um so we currently support Gourley and rink B which is soon to be deprecated but um yeah let's just see if that sends test 90th I'm actually not going to wait for it so continuing on with the coinbase wallet demo so you can see why coinbase wallet is a really cool product and why a lot of people would want to use it not just users but developers themselves so I kind of want to show you today how you can integrate coinbase wallet support into the dapps you build and all the applications you build so that you can support this ecosystem of users that are actually using this product so to do that I'm going to go here um and I have an example project it's going to wait for it to load for a second Okay cool so here I have an example um very basic react application it doesn't do much right now it just has a simple button and displays some data so it displays connection data such as the connection status of an of a wallet the wallet's address and what chain ID that they're connecting with so right now the button does pretty much nothing now to integrate coinbase wallet into your dap what you want to do is you want to download coinbase wallet SDK which will allow you to integrate coinbase wallet in a very simple way so to start with that I'm going to go down here in my project and add coinbase wallet SDK as a dependency if you're using node or you probably want to do like npm install or yarn add so here's the code for basically what's rendered on the right it's very simple it's just a simple react component that has some State data where we store some State and then down here we render a button and have a function called connect that doesn't really do anything right now now when you connect a wallet to your dap we have this concept called the provider and what a provider is is it's an API extraction that allows you to read and write from the blockchain most wallets so coinbase wallet metamask trust wallet they'll all inject the provider into your web browser that allows you to use it to interact with the blockchain so in order to get that in our project what we need to do is create a new file called provider and then one second and then I have a code snippet here that allows to define a provider and get that Provider from coinbase using coinbase watt SDK so just going through the code real quick um here I import coinbase wallet SDK into my project and then in order to get the provider to start sending in signing transactions I can instantiate coinbase wallet by passing it some of my app my app name and its logo and then there's a handy function called make web3 provider that lets you retrieve that so now that I have this file I'll go back to my main application file and I'll go ahead and I'll import that um and once we have the provider in our application we can then use it to actually make requests to the blockchain so what I'm going to do now is I'm going to go to this empty connect function that is connected to our um that is connected to our button and I'm going to replace it with a snippet of code so our new code snippet what it does it is it calls that get provider method right here to get the provider and then we use that provider to make two requests the first request is to get the user's account that they would like to use to connect with their dap with and the second one is to read the chain ID that they're connecting with so once we grab these you'll see down here I store them in state so set accounts at chain ID and then whatever stored in state will be displayed on the right so now that I updated the connect function if I go over here to the right and I click um this button this connect wallet button you'll see coinbase wallet pop up and ask if I want to connect so what happened there is the provider just called the request to request my account so if I click connect I should now be connected to the DAP and now the DAP has access to my public address and can make signing and sending of transactions on behalf of me and um yes that's that's how you pretty much implement or integrate coinbase wallet into adapt it's pretty simple just takes a few lines of code there are a few open source projects that take this a step further so if you want to support multiple wallets within your app not just coinbase wallet you can use open source tools like rainbow kit wagme web3 reacts web 3 modal they all use coinbase while SDK and what I demonstrated under the hood and then as well you also get support for other wallets as well so that you capture a wide variety of users thank you um and then I just want to uh so that's how you integrate coinbase well I just want to harp on the fact that koim is what is a we're focused on making it uh develop a developer tool um so we did integrate built-in test net faucets so everyone who's hacking today and tomorrow and throughout the weekend um feel free to grab some test native for Corley test net um and just it's as simple as downloading coinbase wallet extension um I did want to call out our prizes that we have going on throughout the weekend as you're attending the hackathon we do have a bounty of ten thousand dollars split up between builders that are willing to use our node product and our coinbase wallet products um throughout the weekend so if you're building um consider building using node as a product and it'll it'll allow you to be eligible for a six thousand dollar prize pool and then if you're in if you're interested in integrating coinbase wallet or demoing it um as you do your demo um you would you'll be eligible for the four thousand dollar prize pool and everything I demonstrated from node and um coinbase wallet are all available at this link that you see up here um it's a build with coinbase uh Cloud Workshop so it'll teach you how to make your first request using node and how to set up node and also how to integrate coinbase water into your dapps um I also want to call out that we do have a QR code on up on the screen right now and um you can go ahead and take a picture of that and it'll lead you to our link tree which has feedback forms of your experience using our tools so we'd love to hear feedback on what we can do to iterate on all of our products so whether you have feedback on node wallet or any of the coinbase cloud products as you're hacking over this weekend we'd love to hear your feedback so please visit that QR code yeah and that's pretty much kind of like what we had for presentation I don't know if we have like time for QA at the end not uh I don't know how or it was just the 30 minutes okay well uh they're still not kicking us away so we're kicking us out so we're still saying the only important thing uh that I want to mention is that we're going to be around here and since we do know that we have also local developers uh personally I can also answer questions in Spanish and we have like some technical people here directly from the coinbase node team that uh can help you if you are interested in uh well solving any issues that you may have during the hacking but in general I think the the best recommendation that we can give you is to go there and specifically with with node because it just asks for an email so you can create uh an account right there like on the free tier and it's going to take you just a few minutes and right after that you can start pretty much doing what uh Taylor was showing you so it's not a lot of effort for you just to get your hands on the product and immediately start figuring out how to integrate it with your existing projects and of course we have the challenges so if you are interested in uh well getting some money then that is your opportunity to do something during the weekend so that's pretty much it yep it looks like we're out of time so if you guys have any questions feel free to meet with us we'll be available throughout the weekend to answer any questions you guys have with our products but yeah thank you thanks [Applause] I'll return this one 30 minutes right there [Music] [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] foreign [Music] me myself foreign [Music] [Applause] [Music] [Music] foreign [Music] [Music] foreign [Music] [Music] foreign [Music] [Music] foreign [Music] [Music] [Music] [Music] hi hi hi so now say okay so okay so hi everyone my name is Nicola Nicholas and with my colleague Nikolai also we're going to present and explain this motive of the hackathon uh working for Sigma SDK you know doing stuff funny stuff with Sigma SDK the first thing that I want to ask is how many people here speak Spanish okay a lot so foreign Okay so so what is Sigma so Sigma basically it's uh cross chain interval activity protocol allowing General General message passing but also sc20 and nft transfer so with with our SDK and with our like with our infrastructure you can relay message you can transfer tokens you can transfers nfts uh cross chain between evm compatible networks right uh so the basic idea here is that you have chain a and chain B and you have Sigma in between and then of course you can transfer the most popular formats I would say rc20 LC 721 and we use This Acronym GMP and gmps because it stands for a general method General message passing foreign a translator Minnesota Jamar functions um a sigma so okay so and we also with our infrastructure we have also our SDK so of course all of this is open source uh and our with our SDK the the main idea is to allow developers to that usually are familiar with JavaScript or typescript to build uh cross chain applications in an issue like is General uh numbers [Music] connectors foreign okay so we have a so we have a faucet uh UI so you can get tokens from this faucet and also we had a so it's pretty straightforward you just go to this uh this URL and you get the tokens to so in case you want to use devnet you get the tokens and then you can do whatever you want you can pay for your nft transactions or transfer sorry so yeah it's pretty like uh there is not too much hassle to to do this using like devnet and faucet UI and mainly they are the main like Bounty prices for this hackathon is tier one is to build or showcase something using general message passing uh and this is the amount that we are giving for for this and also there is this tier two price in this case it's utilizing uh Sigma SDK and showcase something with nfts or sc20 uh whatever your imagination can I don't know build so yeah and now I I would like to explain uh a little bit in more technical terms how can you use our stuff or SDK and our infrastructure to build custom applications so I'm going to I'm going to show some skills called Snippets then I'm going to show you a demo of a nft application and then I'm going to try to run uh leave them of rc20 transfer so yeah I hope demo got behaves well with me today so basically for you to build with a or SDK you need to provide addresses because of course you need to you need to know who who are the contracts that you need to connect and this is our standard configuration uh for uh to use or SDK so you define this stuff like domain ID the network ID in this case is the chain ID of of a node and then you provide the addresses when you if you run or local setup addresses are provided after everything is running so you have this and then you can plug this and use it locally so is I would say it's a seal environment so you use SDK locally and with the infrastructure locally if you want to use our devnet of course you have to go to our resources and get the addresses of our contracts and then you plug these addresses in this setup format and of course you define for instance here the rpco URL and in this case the rc20 code token the address Etc if you want to uh if you want to deposit for instance in the case of rc20 if you want to transfer some tokens from one network to another uh besides of course of course the setup uh you need to initialize connections and in this case we have two separate ways of doing this because of course this SDK works in the front end and also in the back end so if you want to do stuff or if you want to transfer tokens in the front end you just initialize connection from web3 provider in this case you are going to use a metamask provider so a metamask is going to carry out approval and all the actions behind the scenes with the account and and of course since uh in our infrastructure we have some we have a fee structure uh you need to get uh the fee in order for you to then do the deposit because uh our entry point and I think this is one of our advantages or anti-pro entry point for our application is the deposit on the bridge so you need to provide this fee and in order for you to provide this feed you just need to fetch this this fee data in the case of our local setup free data is like a constant and you get this and then you can play a play with the with it um and of course in the case in the case of devnet also a fee is already provided so there is no no miscalculation you know and then of course you do the deposit and and you define this like parameters amount recipient address and free data and after that you should see if you're running for instance infrastructure in your machine you should see the logs of the message bit and carry out to the other network okay so in El Cason is foreign a subscribe so for SC 721 it's kind of the same configuration but you add this FC 721 100 address of course again another address and you know it's like there is no much change in terms of what you are calling you are always calling deposit method and you are always providing in this case recipient address basic fee and in this case the amount represents the token ID so in a way transferring sc20 and nfts kind of behaves the same in our SDK so this is an advantage in a way that we don't want to provide like a different apis or like a lot of methods and we want to in a way make a developer's life easier and for this we have this like straightforward way to to use or SDK in the case of generic Handler it's a little bit more I would say complex but still straightforward since uh from this week we have our contract is permissionless meaning that you just register the resource in this case resource is the function that you want to call in another Network and then this registration make the function available for everyone and you need to provide this sort of format for the for for the data and the most important part of this is of course metadata depositor in this case is the address who is doing the deposit and then execution data and execution data is uh are the bytes that correspond to the arguments of the function that you want to call in the other network and then again it's straightforward for instance in this case deposit function signature you can get this using web3 JS or srgis providing of course the ABI of the contract and and then you just break another another chain so you just call this create generic deposit data and you provide this like signature uh the deposit function signature the address or your contract in the destination chain and other parameters that are described in our documentation like like Max fee and depositor address and of course the data in this case the color that I want to transfer and then using our contract you just do again a deposit so again it's really straightforward nothing really changed provide domain ID in this case for Destination chain and deposit data and deposit data in this case is going to be bigger because you are not just transferring an asset like an nft or a C20 you're you are transferring like a function call to a to another Network there is like a questions up to this point preguntas okay if you have questions you can ask me later oh okay no problem foreign like more because I want to show you how everything works so first I'm going to show you the video of uh this is our this is our nft example that we have in the SDK is like pretty Bare Bones it's super basic and simple but it's a it allows you to like check the code and then see how easy it is to use our stuff so I'm just going to press play okay so what you see of course you have the front-end application right you are doing stuff with metamask you are doing the transfer with the metamask you have of course the dev tools with the logs and this uh in the right corner it's uh or local infrastructure so this Docker image that you just run and you have notes and relayers working for you with contractual addresses and then you wait a little bit because of course this is not uh this this is a this is really fast but of course it doesn't happen like right away and those logs that you are seeing right now are the locks of the relayers relaying the message to the other network so we should see a result in the say transfer complete so we managed to transfer uh one nft to the other network and this example is as I say it's currently in the in the GitHub repo so you can just clone install and run it and it's pretty straightforward I'm going to try to now I'm going to write try now to run like a demo of the rc20 so I hope everything works so here I have a local setup so and I'm going to run it with the docker you can also use there is a make command to do this but since I like to tweak a little bit the docker file I always ended up to using Docker so now our infrastructure is running and and here is the example of their C20 application also like a really Bare Bones application of for transferring tokens so first we're going to run this command called mint sc20 so what I'm going to do now is going to mean some tokens 99 for me then to transfer so okay everything went smoothly now I'm going to run the server okay so demo code please okay so we have this variable on the application and you can see that we have 99i tokens to this account and then I can try to transfer one or whatever you can put I don't know 11. because we have a lot so you get this message because you are getting Fierce the fee as I show you in this code snippet and then if everything works great we confirm the operation and I'm going to try to put this no oh okay of course demo went to want to put it aside on yes so okay so there is a an issue I'm going to try again if not you can check the the repo so um I don't have access to this okay so let's try this I wanted to show you the logs but since this screen size is kind of weird Okay so first getting the fee and yeah so confirmation and let's wait for it so here are the logs now you are seeing the locks of the transaction being carried out from one node to another so this is the are the locks of the relayers and that's it so simple it's pretty straightforward so yeah and yeah this is this is our this is our SDK this is this is the main idea that we want you to get excited about it like build with us build what in your imagination across chain application looks like and use our open source code user SDK your infrastructure your devnet and yeah and we are going to be here so if you have I don't know questions about if you went to debug stuff yeah we're here to help you so yeah I think that's it thank you thank you questions you go to the next okay thank you so we are going to be here check us in the chainsaw bounty [Applause] foreign yeah thank you so much oh right there oh all right so I think that's the best resolution we're gonna get but uh that's all right so let's all right how you guys doing thank you so much for coming you guys having fun or what welcome all right so uh quick introduction my name is Kevin uh I actually work full time for a Web 2.0 company uh nginx you might have heard of them uh most popular web server out there uh but I also uh am a part-time developer advocate for scaffoldeth oh thank you uh and I work basically in the build Guild if you're not familiar with build Guild it's basically a group of developers that like to build on ethereum uh most of them are fond of scaffold eth which I'm going to be talking a lot about today and I also have a non-profit that I'm I founded in California just to kind of educate people about blockchain specifically ethereum I'm also a mentor for growick which is a free solidity track you guys if you're interested in that it's a free track and uh it's basically an eight-week cohort where you can learn more about solidity and I'm a photography and filmmaker you'll see me running around I'm actually shooting photos for the event today so anyways that's me that's my contact info if you guys want to follow me at all um so what is scaffold eat so um most of what I'm gonna be doing today is actually a demo but I just want to give you guys a brief kind of overview of how it works um and what you need to get kind of go in and get set up uh you need git obviously because you need to be able to check out the repository and then you need node.js and yarn installed node.js is pretty much the prerequisite you need at least version 16 or above so make sure you have that make sure you have the newest version of yarn don't be using like an old version of yarn on Linux there's this kind of old version of yarn that doesn't work properly so just get the newest version of yarn and then you'll be good to go that's really the only tools you need to get going it's going to spin up hard hat for you so hard hard Hat's like one of the main components to scaffoldeth uh as well as react so it's going to spin up react for you and it's going to do a lot of like the magic that you don't have to worry about like setting up a a hackathon project or any any web3 ethereum based project can be a hassle because you've got to spin up all these different programs and make them talk to each other and figure out how you're going to inject your ABI and react and the yada yada everything's kind of already done for you and I'm going to show what that kind of looks like um and then everything obviously that I'm going to talk about today is based on solidity so you know compiler contracts and solidity and that is pretty much the you know the smart contract language of choice for uh scaffold teeth um so if you're a developer how how do you spin it up so the first thing you're going to do is clone the repository you're going to do everything is based on yarn uh yarn scripts if you're not familiar with yarn yarn's really awesome because it is a package manager but it also allows you to run these cool like kind of command line scripts with simple commands so you can do that yarn this yarn that yarn whatever so yarn install is going to do all the dependencies for you and install all the prerequisites so you don't really need to like figure out what version of uh this particular react you want to use or a hard hat it's going to do that for you based on the current version of scaffold eth and then you're going to run yarn chain that's going to spin up your blockchain hard hat right running locally and then you're going to run react on localhost 3000 using yarn start so it's yarn install you only do that once you're in Chains to spin up your blockchain yarn start to spin up react and then you do a yarn deploy and what that is going to do is going to use hard hat to take the there's there's kind of like a hello world smart contract I'm going to show you we're going to start toying with it and just going to ship it and deploy it and that's going to also automatically inject the ABI so if you don't know an ABI is it's basically the way that the smart contract your front end can interact with that smart contract in a way because obviously when you compile down your smart contract into byte code it's not human readable specifically it's not readable from your front end either so as you interact with your application pretty simple uh you start to form blocks and you can start testing right and every time you do a deploy it gets a fresh copy of your smart contract and we'll show what that looks like as well uh so that's pretty much all the slides I don't like doing slides because slides are pretty boring so let's just get right into it um so if you go if you do a search for scaffoldeeth the first one is going to come up is going to be the GitHub repository so the primary repository for that actual scaffold eth is here scaffoldeth there's also this like challenges directory which is linked to like the speedrun ethereum challenges which I'm going to talk about in a second and then there's some examples as well so the cool thing about it is like you can find like ERC 721 example you can find an ERC 1155 example there's pretty much an example for like everything you need to know or need to build on top of so it's a great starting point for hackathon projects right you don't have to worry about you know injecting the open Zeppelin contracts they're already pretty much set and ready to go it's even got a little bit of a front end going for you it's already got ether's JS hooked up it's already got your API plugged in yada yada everything's kind of set up so if you like as an example let's just say you went to like scaffold youth examples and then you did a search here you could type like ERC there's an erc20 new demo there's a simple ERC 721 1155 and you can kind of pick and choose like from that starting point and that's a perfectly valuable starting point for your hackathon project okay but we're going to be focusing on scaffolding the actual main build and that's where you should really if you're just like toying around and like building uh you're going to use that uh by the way all the instructions of everything I said is going to be inside of the repository as well so like the Yarns yarn install yarn chain urine start and pretty much everything I'm going to go through today is in here so don't feel like you have to follow along I'd rather you guys just kind of watch me do it and then unless you're really good you can follow them um and then after you get scaffolding set up I always recommend people if they're still learning to go to solidity by example and like copy and paste stuff from solidity by example into your smart contract and and start testing that way once you get like comfortable with solidity that's when you'll say okay well I want to like test my abilities this is outside of obviously the the hackathon but when you want to start learning more speed run ethereum is a great resource now it's um a basically like a set of challenges that you go through and real quickly one simple challenge zero is you build a simple nft challenge one is you build a decentralized staking app a token vendor a dice game and you go through and eventually you get invited to the build Guild right so uh and then you can actually start kind of being part of the build Guild community and then you you obviously get access to the special chat channels too as well where you can like talk to the developers and other builders and kind of work together to kind of solve these challenges it gets really hard after challenge four so if you can get through these challenges it's a lot of fun all right that's enough chill about that but this is a good scan this if you want to know anything about scaffold eth all the links for scaffold ether in this one high hello card so if you're interested in that scan that I'll give you guys just one quick second and then I'm also going to give a pull-up away so come see me afterwards and I will bring this up and you guys can scan the pull-ups as well okay so let's uh let's get going here so um I I use tmux I don't know if you guys are familiar with tmux but it's basically like a terminal multiplexer it allows you to have more than one window open at a time you can do this in in multiple windows but the general like rule of thumb is you need like three windows open when you're working with scaffoldeth okay the first window is pretty much where you're gonna do the yarn install so you're gonna set up install the dependencies I've gone ahead and done that it takes a little bit over a minute to do okay but once you get it set up you don't have to do that again you're good to go then all you have to do is do a yarn chain yard chain it's going to spin up block the hard hat node it's going to run on localhost that's it you can pretty much leave that window open all the time I like to have it just here in the corner because like you might use hard hat console to like print stuff to that console and you might want to like debug your contract and then over here in a new window in the same directory you're going to do a yarn start okay so what's that going to do it's going to spin up react on local localhost 3000 that's going to take about a minute so we will let that do its thing and then the last command if you guys remember yarn deploy right so those three commands basically we've deployed adapt locally on our Local Host we can see here that we have we saw some contract calls uh let me zoom out a little bit we have some contract calls we have some uh it tells us how much gas was used we can see that react just started on the right now we see more contract calls and we see how much uh gas was used to deploy our contract on the bottom we even have our address so we get this kind of like cool printout it tells us how long it took let's take a look at scaffoldeth so it says I'm on minet oh let me disconnect from metamask okay so this is scaffolding so when you first get in scaffold eat it's basically react right but what's cool about it is it has all this stuff already ready for you okay this first app home you can think of this tab here like everything in here is like where you would build your dap that you're actually building for the hackathon it's like your dap inside of scaffoldeth right and this is a special app.jsx file that's inside react and you can just build around that right so you can inherit all of the you know components that you have in react and whatnot um but what's cool is this debug contract debug contracts folder so what this does is essentially takes a copy of your contract and it builds like a full functional like debug UI for you so it has your your variables your your functions it has your contract address it has the value stored in that all in this one location and then you can really like kind of like test your assumptions as you're like developing right in solidity so uh let's take a look at what that contract looks like so Adam I'm going to use atom um you know you can use whatever you want but obviously Adam is is uh just a basic text editor and what do we got here um we got a packages folder and then we have a hard hat folder and then we have a react folder okay most of everything I'm going to show you today is really in the hard app folder and we're going to be working out of the contracts folder and inside of that is your contract okay so this is kind of like the de facto hello world contract that comes with it so we can see here that we Define a version of solidity we Define a license we import hard hat console so that we can do some logging to the hard hat console we name our contract and we also have like an event that we're we're doing that that basically broadcasts the address that calls the purpose function and the string that they pass into that function and then we have a another variable that we Define and we have the empty Constructor which is not doing anything but we could do that I'll show you about that in a little bit and then we have set purpose which is a function that allows us to change that that variable right we have this kind of like Public public variable here we could change it here like if we say Unstoppable like that and then save that and then do another deploy and by the way you might want to reset enforce a deploy sometimes just do dash dash reset and it will force a new contract to be deployed so I just add small change and then now we can look at the change here it's been changed in here right and so you're able to kind of just do your changes to the smart contract deploy go back start testing that's obviously just a very simple test but let's get going a little further down the contract okay then we have inside the set purpose function it just takes a very it takes a variable essentially a string and passes it to the new purpose and then we log that with console log using hard hat console and then we emit that event right so that the we can capture the event and see that so it's a pretty smart it's like it's just a hello world it's very it's like the simple uh starter contract let's like let's make some changes let's make some interesting stuff so the first thing you'll learn uh you might want to do some kind of like access control so let's just do like a quick uh kind of like janky Access Control uh we'll make it owner sorry owner public or address public owner equals and we'll go back to our thing here and what do we see up here on the top right so this is a burner wallet okay the burner while it's cool because you don't have to have metamask installed it's just using a browser wallet and if like you were to look up open up another tab you still have access to that because it's in the browser right so you don't lose it but if you were to come over here and say oh well new incognito window and do localhost 3000 we would get a new instance of a burner wallet because it's an incognito one right so let's leave that open for right now because we're going to get back to that in a second but my point is that we can just use this wallet and it's empty right now but we can just grab some funds from the faucet clicking that button we can even grab more funds if we want you can grab the address we can come down here to the to the faucet and say oh I want like way more uh let me give me like I don't know thousand bucks sound I'm able to just grab that those funds from hard hat just dump them into my burner wallet so I made silly ready to test I don't have to worry about metamask and nonces and any of that junk right um so let's let's make a change let's grab this address okay and we want to do like access controls now we have access to this wallet by the way the private Keys here as well so you can export the private key that it generates so it's full functional wallet right you can also import private key so if you just want to use like some one that you keep keep using um and then let's go to the thing and let's define that variable save it and then redeploy okay let's make sure it deploys correctly first which it does okay and then now what do we see we got a new variable owner right so what we could do is say like all right let's make sure that only someone who calls this function here is an owner like an access controlled uh function we could do something like a require statement right and we could say required that the message that sender is equal equal to owner otherwise you are not allowed to call this I don't know something like that so what I'm doing here is I'm just basically like toying around with my smart contract redeploying my changes instantly I was able to get up and running with adapt and testing my assumptions so there we go um we have our contract we got a new one and then now if I want to come over here this incognito tab get some funds go to the debug contracts and try to change the purpose I don't know to Foo like this it's going to say you're not allowed to call this right I've done some basic Access Control right but if I come over here and I could say fubar sh send and it lets me right so good bad right uh but let's let's go a little further let's let's actually like wipe out like this concept of like hard-coded addresses and let's use anyone familiar with open Zeppelin open Zeppelin right awesome if you don't open Zeppelin gotta follow those guys um the first thing the second thing you'll learn with smart contracts is inheritance so we can see right here we can do like an import right we can import an open Zeppelin contract and then we can make our contract inherited from that right and you'll see a lot of the examples like erc20 example ERC 1120 1155 721 use this import and inheritance function so let's do that and then let's save that and then let's deploy again so instead of doing a hard-coded owner we're just doing this inheritance method and we don't have only owner that's the thing we got to do is we got to inherit the modifier so instead of using a require statement we're using a modifier which is part of inherited uh Access Control ownable contract but you can see what we're doing we're toying around let me deploy again because I forgot that and then let's go back but what what's different now does someone want to tell me what's different the owner address it's unexpected what owner address is that it's just a random string right well hardat uses the very first uh contract address or I should say the first like uh it has a set of 20 accounts it uses the first account to deploy the smart contract so what's happened is we've had hard hat deploy our contract but it's hold on to the contract now we can we don't have any access control because before we had hard hard the hard-coded the owner so the next thing you'll learn you'll learn with scaffold eth is that you need to be able to change the deployment so if you look right below the contract folder there's a deploy script okay and this is where when you do a yarn deploy this is what's what's being processed right this is what's running and you can see here that we get a copy of our contract uh we we set the deployer as the deployer which is from the named accounts coming from from uh hard hat and then we can see here that we get an instance of the contract and so in this script now we have a copy of the contract here so what we what we can do is call an inherited function right and if you know ownable or ownable opens up and ownable it has what's called transfer ownership function okay and you'll even see it down here on the bottom because we inherit it and you can see it's right there so now what we need to do is actually transfer the ownership of our smart contract to us and so we can grab that address again like this and then you actually you'll see right here that we have a I I have it like kind of like grayed out in there uh so we can just grab that and here we can take the contract call the transfer ownership and then put the address in here so sorry let me grab it again and then save and then redeploy give it one sec that worked nice and fast and now you can see that it owns and matches again so we deployed the smart contract called the transfer ownership function and transferred it to ourself so that's cool we've been able to kind of toy around with our contract and you see how you get in this kind of loop where you like like I said you have hard at running you have react open you're testing your your smart contract building some stuff um and then you just kind of start testing those changes and you can even do things like I'll just do a couple more things here just to show you we're done with the deploy script so we're good now we have kind of Access Control let's pretend that we don't want to actually call only owner on that function because it's kind of boring to have like one function that only the owner can call let's make it a public function but we could do something like um let's require uh like a amount of value is sent um 256 public price equals I don't know point 0.001 ether so we can set up a a variable price and then we can come over here and then we can get back into our requirements right and we can say something like require message.value which is the the transaction value is equal equal to price or we say not enough something like that right so now what if we deploy our change which uh oh sorry when I always forget this you have to make that because it's we're accepting value now you got to make it a payable function so let's make it payable save that and deploy did I spell it wrong I did thank you one more time one more time but you guys can see how easy it is with scaffolding to get up and running with a project um you know using this and start doing some changes so cool now we have a function but what do you see well the UI is adapted and it said oh well now we need to pass some value so then you can start testing and we even have that new variable here which is showing you the value and way so the first thing another thing you'll learn about you know when you're writing smart contracts is you need to send your transactions in way and not in ether and so um you know what this does is it kind of just gives you the variable and if you didn't have this variable here like you could use this little cool green little icon that does the math for you which one ether is uh equal to times 10 to the 18th power in way so what we could do is say okay well now we have this this function we want to change it let's set the purpose to Bogut uh and then we have to pass in if we were to pass zero zero zero one ether sorry let me do zero just if that doesn't freak out and then click this little button that would be the wrong amount it's going to tell me not enough right but I could just grab this and copy this paste it here send boom it worked so now what happens with our smart contract we have it has value right now it's actually storing some value which is cool it's like this little vending machine right so we could probably write like a withdrawal function in there that would be cool right and then we hit that one we would definitely want only owner right so we could use that only owner modifier but let's just do one more thing that I just want to show you with like one small change you could do something at the very bottom of your function that says price equals to price I don't know times two like that and then deploy that change and with one small line in the contract you completely change the behavior of the of this kind of vending machine it deployed successfully and now if we change the uh thing to I don't know uh Colombia boom send now we'll see that the price adjusted right we did this simple modifier right okay so I think you guys get the idea it's it's just kind of like toying and like tinkering around with your smart contracts uh testing your assumptions with multiple identities right multiple browsers if you have problems and you want to like uh you know if you have any issues there's a telegram channel for getting uh getting like problems resolved I'll be around I'll be shooting photos but I'm more than happy to help you guys out if you have questions um yeah that's pretty much what I want to go over uh any questions I'll try to at least some time for questions yep uh yeah yeah so if you're um yeah if you're I mean are you saying like for a test net oh so let me let me kind of show you real quick you can generate an account so you can do yarn uh here let me open this so it's full screen you can do yarn run generate and what that's going to do is generated a special deployer mnemonic it's going to place it inside of your directory which I won't click on it but it's right here so it has the the deploy address the mnemonic is in there so you can inject that into metamask as well so you have access to it and then you can do a yarn account like this and you can also like what I would do is like I have a punk wallet on my phone and it pops up a QR code for you it goes by real fast but you can just scan the QR send some funds to that one and then now you have this kind of like wallet that you have access to the private key right no no this is a it's stored right here on your thing yeah yeah that's your deployer account so yeah that's a good question I was going to show that but I didn't have enough time and I wouldn't be respectful of other people I was going to deploy it and you can also verify your contract with a yarn verify um you can do all this cool stuff uh you can also do yarn Surge and you can upload your um your dap like you can build it with yarn build and then you're in Surge and it'll upload it to Surge you can also yarn ipfs and push it to ipfs so there's all this stuff that's just already written for you you don't have to hassle with it just take a look at the package Json file and it has all the yarn commands and yet one more question yeah no there is a test in there so you can do like a yarn test and there's a there's a test in the hard hat test and you can create and build around that um if I did it right now it would fail because the test is designed for like the hello world one that comes with it um but yeah you can definitely just do a hard hat test and I think that directory is uh right here test my test and you just you write it like a normal hard hat test so it uses chai basically like hard hat and shine yeah one more so uh there's uh sneak peek there might be a future version of uh scaffolding that has Foundry um there actually is one I think someone's already built actually that um it's not I don't think it's in here yet but I would just keep an eye on the repository here and see I could actually check right now um oh there is one yeah so there is one with boundary I think I think it's kind of like yeah I don't know if it's been tested too much but um probably not the recommended one to to use for this hackathon but um yeah looks like there's already one yeah thank you guys appreciate it [Applause] hi the converter I think the next one and this is my pointer I don't know connected yo sorry for you yeah hello yeah yeah sure thank you presentation no no hello hi hi good evening everyone it's okay so hello to the hackers in-house it's really exciting to see so many Builders who has arrived before the main event you know to build something cool so thanks for making it and a bit introduction about myself uh do you guys want to stay Maybe okay sure yeah a bit introduction about myself my name is Tonya working as a senior blockchain engineer at Clayton so I am part of the ecosystem team so mainly building the peripherals of the ecosystem like Bridges wallets and explorers and sdks and libraries so today uh I'll be talking about what is Clayton and and what is Clayton architecture and how does it look at like as a protocol and I'll also show the tech stack and some tools which we have in the ecosystem and a quick demo on one of the feature on Clayton and also at the end of the session I'll provide all the resources which would be helpful for you to build for the hackathon so since we are a ecosystem we have many products running on the ecosystem so if we are looking for a workshop 30 minutes won't be enough so I'm going to provide you all the tools which we have and what all you can build on the ecosystem so it should be helpful for the hackathon so um what is Clayton so Clayton is a evm based code base mainly folk from go ethereum before four years so since then it has been highly modified and streamlined in uh in the evm layer and the execution layer and the protocol layer storage layer and the gossip layer um so Clayton is a service Centric hybrid architecture more like a POA or permissioned validator set in terms of generating blocks and validating blocks so Clayton has a main net which is a layer 1 mainnet and also a layer 2 service chain so service chain solution is also a blockchain where you can have independent validator set for generating blocks and validating blocks it's mainly for scalability and we have we have achieved some interoperability between the layer 2 side chain and the layer 1 Main chain as well in the protocol level and in the smart contract level and Clayton has one second block generation and instant finality which means a block is consensed upon and generated every one second which is quite fast so here we are mainly concerned about the data consistency over data availability if you're familiar with the cap theorem which is you know in the Left End which is the picture which says about the cap theorem and since uh this uh we are concerned about the data consistency it is mainly useful for use cases like bridging you know to Port your sets and Clayton has a two second round trip transaction latency so this is quite fast and we did some tests in the main net and here are some metrics and this is the statistics compared to the other Leon blockchains and it has a two second um you know response time and the average transaction latency is very low so what is a round-trip uh transaction latency so the round trip meaning uh the time which you submit the transaction to the blockchain and it gets processed it gets validated and added to the block and gets propagated to the entire network and it um comes back to you as a finalized transaction the receipt which you receive so the entire uh transaction cycle it only takes two seconds which is quite fast and competitive in the uh industry right now and this is really helpful in building use cases like meta was applications and gaming applications which requires very low transaction latency and you can also build D5 applications and Arbitrage Etc and Clayton can process 4000 transactions per a second so this is also based on the real world statistics in the mainnet and not in the test net so it can do a send transaction and it can achieve 4000 transactions per second and for the other smart contract uh transactions based on the functions it might add some overhead so it might vary however we were able to achieve 2500 to 2800 transactions per second in the mainnet for the smart contract execution as well and um like I said we have a service Centric hybrid architecture so we have this governance Council which we call as the validator uh set so we have some reputable node operators in the mobile data set like binance net marble and make a Dao and uh like I said we have the service chain and which is the side chain it is for scalability and you can interrupt with the main chain so next we'll see uh how does the Clayton architecture looks like as a protocol so since the beginning we have been on POS for um block selection and particularly ibft for consensus uh this is Istanbul by sentence fault tolerance and this uh is mainly helpful for us to have one second you know block generation and instant finality and we have a three node Mo a model architecture uh we have a consensus layer which is the core node and we have um proxy uh proxy node which is around the consensus layer and we also have the endpoint uh node so you might ask why it would matter for any user right but in other blockchain protocols if you see uh no matter what job you do you'll be running the entire code um core node architecture but in Clayton it's little different So based on your job if you are a validator you can just run the code node and the proxy node and if you are a endpoint node provider service provider like API service provider you just have to run the endpoint node so the code node is the consensus layer where the consensus mechanism takes place and the way you generate the blocks and everything and the proxy node is like the century note like a gatekeeper which protects the core node from resource exhaustion and from the wild internet and this proxy node also helps the core node to generate the blocks in timely manner and lastly the endpoint node is the gossipers of the network um so this is the this exposes the RPC endpoints so if you are a developer and if you are interacting with the Clayton blockchain you're more likely to interact with anyone of the endpoint node so you can submit transaction to through the endpoint node and you can also you know retrieve the data through this endpoint node and we do first and first out transaction ordering from the mempool and we also have Clayton specific pre-compiled contracts starting from 0x3 FF and it goes down like f e f d and so on and we also support ethereum pre-compiled contracts so now we can see the unique features which Clayton has to offer when compared to the other blockchain so we have our external account model meaning we have multiple key pairs uh connected to a one on a single on-chain account so what's the difference is if you take in other blockchains you have a private key and a public key and address derived from this uh public key so you have a single keypad attached to the on-chain account but here we provide the option of having multiple keypad attached to a single on-chain account meaning it is updatable if at all if you want to update the uh one single keypad the private keys can also be updated and it can be removed and it can be added so we have this option to have and maintain multiple keypads so this gives us the ability to do Native multisig um you know multisig support but in other layers you have to do the SMART contract level multi-signature you know and it also gives us the option to do role-based access control with multiple keypads for example let's say you can have one keeper to just update the permissions uh or to add or remove the keypad and you can have one keeper just to execute smart contracts and one keypad to you know deploy uh smart contracts so this is quite helpful because everything is on chain you don't have to write a separate layer of smart contract and we have support for multi-format transaction model like a separate transaction model for execution and deployment and also anchoring transactions for the sitechain and uh the best feature is uh the fee delegation which is on chain where you can delegate the fee to a different person so if you're developing a d app and if you don't want the users to pay themselves for the transaction it can be delegated to a different person so if you take the other networks they achieve this feed allegation using a relayer network so what they do is they write their logic in the smart contract and you know do some crypto signing magic and send to the network and the relayer network will pay the fee so it is like a huge complex process but in Clayton everything is done on chain so if you want to do a feed allocation so you can just sign the transaction and send to the fee payer the fee pair will in turn sign the deployed transaction and execute the transaction and pay the fee for it I'll show a demo on this at the end of my session so yeah so we have this on-chain feed allegation without um you know having this complex layer net layer Network and we also have cross chain checkpointing and another interesting feature is the dynamic and the deterministic gas model so here uh based on the network condition and the transaction rate the price might go up and down by five percent uh but in a single block uh every transaction will pay the same fee so we want to be deterministic and as low as possible it's similar to the base fee of ethereum but in other network you have the option for tipping and you can tip for the transaction and prioritize the transaction and you can skip the queue but because of this the price is very volatile but in Clayton we do not have that tipping model because we wanted to keep it as low as possible and deterministic however the range is between 25 to 750 Stone so stone is something similar to gray so you can see it's very less so for simple transaction like send transaction you can you just have to do like 25 and for complex transaction uh it won't go more than 750. so so for this is a very useful feature for the Dr developers you can predetermine how much gas you will be using for a particular transaction so yeah so now we look at the tech stack of the Clayton so the top layer is the the app solution where you can build uh any applications you want D5 nft or gaming on metaverse and the next is the dev environment here we can use all the sdks and the libraries which you will like we also support ethereum Dev tools on Clayton and the next part is the blockchain core which has a two interface if you see so one is the ethereum equivalent interface and the other one is the Clayton specific interface so why we have two different interfaces is that in addition to the Clayton specific features like we saw before we also support the ethereum equivalent or ethereum formatted transactions so for example let's say you're using each dot get balance or e.sign in ethereum network you can use the same exact methods in Clayton Network as well and you can use the same tools and same sdks like web3.js and you just have to change the rpz endpoints um so yeah it's very easy for a d app developer who is building on ethereum to port to Clayton and for using the Clayton specific features like um on-chain multisig or feed delegation or role-based access so you can use the clay namespace which is the interface for the you know create and specific features and for this you have to use a Keva JS SDK which is very similar to the web 3.js so yeah so we have uh we support a multiple interface as well to communicate with the glitter Network um and yeah we have a pre-compass contracts for Clinton Network and we have a governance model with um um different rewarding mechanism and economics and below that we have the consensus layer and storage Network so yeah here are the tools which you can be using for developing your D app during the hackathon so as a protocol we don't want to be opinionated on what tools you should be using or what services you should be using so we tend uh we wanted to provide all the services and multiple options for you to build on Clayton so um yeah so we have a few of the tools which you can use for the hackathon today so the first part the wallet we have a clip kaikas decent and Clinton safe which is a multisig wallet on a Clayton so here if you see all the green boxes has Clayton support and the ones in the green and blue has both Clayton and ethereum support we also support we can also use metamask on uh you know on the D apps which you interact with Clayton and uh yeah these uh ones in the orange we are developing and the team is working hard to release it in Q4 so it will be available soon so the open source tools we have a subgraph surface subgraph service this is like a indexer solution similar to the graph so you can use the sub graph to fetch the data very efficiently and this is free so you can build some interesting dashboards on Clayton as part of the sackathon using this subgraph surface and we also have Dev sandbox so this has all the boilerplate code for you to uh build something you know build something interesting so the thing is we have the boilerplate code to import all the contact library and Deploy on Clayton Network and we have also the front and boilerplate code which can connect to the matamask wallet or the in-house wallet and we also have some boilerplate code to use the cable SDK and web3 SDK so you don't have to build everything from the scratch you can just use the existing ones and you can just have to think of some good use case for this hackathon so when we have contract library and open source decks and we also have ipfs in-house integrated in Q4 and we have sdks like I said caver web3 and web3 unity for gaming especially and we have explorers similar to etherscan scope and creating finder and we are also having a open source block Explorer so the good thing is you can download the code and if you want to propose a new feature you can add it and get some bounties or if you want you can have you can also build your own feature and run it on your own networks it's fully open source so this is a cool thing and we have oracles we have integrated with chain link and with net so even using the Oracle uh Services you can build um on the Creator Network and we have workshops and demos on this Oracle service in our repositories you know we had some workshops for all these how to use this on plate network because that might take a long time right so 30 minutes is not enough to give a workshop on how to install and how to integrate with Clayton so I'm just going to show all the tools available so that you can just go to the GitHub repository and just see the steps it's very straightforward if you're a developer you can just install and start integrating and yeah we also have RPG API providers so you can find out some public RPC endpoints to interact with the Clayton Network and yeah we have also Bridges so our goal is to provide the best building experience for the devs so we tend to make all the tools as open source like wallets and bridges and sdks uh so if you if you I mean if you want to build a wallet but since all the wallets are already in place so you can just take the code and if you can think of a new feature which can be integrated with the wallet like play to earn with wallet or anything interesting so you can just use the code and you can integrate that feature and you know and use it for your own so yeah and this one and like I said we have high performing mainnet so you can build uh applications which require low transaction latency and it can be easily interrupted with other networks because we have a support for bridge and um and uh Texas and the last is the community support uh we provide kgf and krf1 so if you have a very interesting use case so we are also ready to support through funds and um um if you have some Bounty programs as well so you can contribute to the ecosystem and yeah so you know now what is Clayton and how it looks like and how you can make use of the tools to build but still if you have some questions on why Clinton I have so many other networks right so for this I'll give a very simple example so let's take all the messaging applications so messaging is the same but you have so many different applications for just the messaging right messaging protocol but why do we have it because every messaging application has something unique to offer for you right and also based on the region it has the user adoption different user adoption for example WeChat it's heavily adopted in China China region and if you take cacao talk it's uh adopted in South Korea so it has a very huge user adoption as well as some unique thing to offer similarly Clayton also has some unique things to offer and also it has a huge user adoption in Korean region so first we have better usability through the stancilatency and its stability and this on chain feed allegation this is something interesting or something unique which you can build some interesting use case and we are evm equivalent meaning you can develop a d app and run it on ethereum network and without much changes just by changing the rpz endpoint you can deploy in Clinton as well and regarding user adoption since um Clayton is well established in the South Korean market so if you're developing an app it can you can have more users you know it's very obvious and we have a in-house wallet so this is the first wallet which is integrated with messaging applications called cacao talk so which has 50 million users already this is a custodial wallet so even non-crypto users can be onboarded very easily and they can start using your application whichever you're building and we also have a huge gaming company like net marble and vmix running on our side chains which is the service chain so yeah these are some reasons which you can you know build and run on Clayton so now uh using our uh one of the feature you know the uh feed allegation let me show a quick demo so I'm going to make this make a use case like having a gasless transaction on Clayton meaning if a user wants to deploy a contract I'm just taking this example for today but you can have any example you want or any use case you want to implement or to take advantage of free delegation so so in this example what I'll do is a user wants to deploy a contract but he doesn't have to pay for the transaction so I'm just starting the application and I'm just loading this oops oh my God so yeah actually I have to connect to the wallet which I forgot so I'm this is the kaikas wallet which I mentioned so I connected to the wallet so now we have a UI and here in the kika's wallet what I want to show is I have a user and it has zero balance but I'm going to deploy a smart contract you uh with this user so this is a sample Avi and byte code and you can have any smart contract and any use case using this feed allocation so I have just used this because I want to show that he can do a transaction without paying a fee so now when a user initiates this transaction you know he doesn't want to pay for the transaction so you can just sign it so here you can see it's zero clay and now you got the signature now I am deploying this contract so this signature goes to the back end and the deployer who is the fee payer he will sign the transaction and he'll uh deploy the transaction so in the code uh so you can just see the fee pair I have um added in the EnV variable so this is the transaction which we signed from the front end and here we are signing as a fee pair and then sending uh the executing this transaction um through the fee pair so it's just like few lines of code we were able to do a free delegation meaning uh execute a transaction from a account which doesn't have balance at all so if you look at the core I mean here we have the code for that so yeah some front and boilerplate code and some backend code on how to use the cable SDK and how to connect to the Creator Network so you can just use this piece of code and also give the resources to all these tools so so next as part of the sakathon you can build any of these use cases like uh we are mainly focusing on the metaverse and gaming applications because we have very low transaction latency so which is good for that kind of applications but still you can build any applications like gamify governance or defy nft use case but today's problem statement is uh you can build an implementation for any one of the following in the Clayton ecosystem like you can build any tool for the core protocol and you can build any tool for the ecosystem using the subgraph service or any of the tools which I showed before and you can also have a Dao or D5 or nft use case and you can also build some interactive applications using a load trans load transaction latency because this is very much you know useful for interactive applications and it shows the advantage of using this great Network and you can also build any mobile Centric applications so we would expect you to build on the Clayton infrastructure be it mainnet or testnet or local Clayton node or the service chain so now you might be thinking what you can build and what resources you might need in order to build and Achieve what you want right so here I have given us a very simple picture for a Dr developer if you are a Dr developer and if you want to build on Clayton here are the resources so the front end you can have it in react or next year's or anything you like it can be a web application or mobile mobile application and it can have any of the wallet interaction like matamask or kaikas or electric connect so we have boilerplate code for all these uh to connect from the front end and we also provide this public API endpoints so you just need the wallet and you need a front end and for the back end you can use any of the sdks like web3 SDK or cable SDK and this in turn will deploy the transactions in the blockchain so for all these uh you know tools we have the boilerplate code ready in our GitHub repositories so you just have to think of some interesting use case and use this to build so if you want to build something other than the app you can just scan this QR code which will lead to the GitHub repository of all the resources and we also have Clayton developer Hub website where you can look for the resources and yeah we have some attractive price amount and also all these price I mean all these winners will also get a biometric wallet you know Hardware wallet and uh I'll also show the GitHub repository this is too big I can just yeah so here if you see um we have some sample apps and examples for you to um you know take take it and build something on top of it and we also have some starter kits and um so these are the API service and the public RPC endpoints which which you can use to interact with and the sdks which I mentioned and the wallet code so for all these if you click on the specific repositories you have the sample code and you can also integrate with oracles even for oracles we have a separate a workshop in one of these links you can just check it out so so yeah that's it thank you [Applause] foreign foreign foreign oh wow there's a cool hello welcome everyone um my name is Felix lopard I'm here giving the talk that actually my colleague Nick was supposed to give so apologies if it's not as smooth or rounded as he would have given it um and in particular we're going to talk today about ERC or EAP 1271 and how we can Leverage The the smart order smart contract order signature concept for building all kinds of really cool use cases on cow protocol um I hope you guys are roughly familiar with Cloud protocol we are a metadex aggregator where users Place orders just by signing off chain messages and then those off-chain messages get batched together and sent off to a network of solvers that compete for that order flow and try to find the best possible solution um for the user orders matching them together in what we call Coincidence of wants whereas the name Cow protocol comes from and yeah protecting users from Mev and giving a significantly better user experience but that's kind of the background happy to talk also at the booth over like the advantages of cow swap in particular today this talk will will cover really ERC 1271 smart contract signatures and we'll first cover a little bit the basics how how protocol orders work usually and and why this doesn't really work for smart contracts we'll then talk about the easy case of smart contracts that just want to place trades on car swap and then go one step further where we explore this concept of smart orders so even more than just placing a boring old limit order smart contracts can actually Place really cool and advanced concepts and there's a little demo at the end and there's some code in the GitHub repository if you're willing to hack we have a five thousand dollar bounty on the best integration of a smart contract order into Cloud protocol for the sackathon so it might be worth your time to check out this repo at the end and and start hacking so let's begin with the basics how how do orders in code protocol work um here you can see the general struct that describes an order it's really like what what you would expect on a when you're making a trade you have to specify a cell token a buy token you can send the proceeds to some other receiver you have a sell amount and a buy amount that's basically your limit price you have an expiry date you have a fee it can be a seller or buy token so you have a bunch of fields that represent an order on code protocol and then the way that it normally works with externally owned accounts with your metamask is that the order that you're willing to sign gets hashed according to um the Erp I think said 712 is the is the EIP gets hashed into a um into a typed typed order hash and then you with your externally owned account can go ahead and consign this commitment to the order that you're willing to place and the way that signatures work with externally owned accounts is by using some fancy math ellipt curve cryptography you know you don't have to really understand it in detail but um basically you're you know taking two points on a curve and then um have your private and your public key and with your private key you can basically prove that you're in possession of that private key without revealing it and what ends up um being generated is this triple RSV it also doesn't really matter what this specifically means just there is a way of how externally owned accounts can use their private key to attest that they are actually willing to make this trade now the problem is that smart contracts cannot do that because smart contracts on ethereum don't have a private key so they cannot do any ecdsa they cannot you know sign an order given elliptic curve signatures so another signature scheme is needed and that's why the ethereum I mean Community has created what is known as EAP 1271 I think Nick is really strict on that it's technically an ERC and not an EIP because it doesn't need any protocol changes but the basic way that smart contracts can prove that they are okay with um you know with with something happening the way that they prove that they are validating a signature is by just implementing this very simple method is valid signature and that method takes a bytes 32 hash this is basically the order hash we saw in slide 304 and then an arbitrary byte array of what can be interpreted as a signature and that by the way can really be anything it can be some eoa signature that maybe is the owner of the smart contract or maybe a delegate of the smart contract that is signing the hash on the smart contract's behalf it could be just more information that the smart contract needs to then maybe check an oracle or check some other state to decide if it's actually willing to accept the hash that is being passed into but basically what you can think of this off is a Boolean response am I okay with this hash or am I not okay with this hash now the return type is not Boolean it's some magic bytes for Value which has some some you know detailed history of why it's not just a Boolean but you can think of it you know it's a method that says yes or no given a hash is the Smart contract okay executing this the signature and so yeah basically if we go back to the order struct we um again take our concrete order that we want to sign we compute the hash and then the thing that gets passed into our smart contract is we basically invoke signer is valid signature with that hash and whatever we decide to pass in as a signature and so how do smart contract wallets implement this so for example Argent or nose is safe you know pick your favorite smart contract wallet they don't have private keys so they also need to implement ERC 1271. and the implementation can be specific to each individual wallet um you know some wallets might use a might require the user to First send a transaction that says I am a testing that this hash is okay so you might think of it as like a bitmap that for each hash you have a is signed or is not signed and then is valid signatures there's checks for the hash if the the bit is set to yes you could also just blindly trust signatures from certain domains so you could say if um you know certain I guess member of an ens Community or whatever has signed this then I'm okay with it or the way that the nose is safe and I also think Arjun does it is you could um you know go smart contracts usually have an owner they have multiple signers you could just use those signers as delegates and verify the signatures by just checking have enough signers have enough EOS that own the smart contract while they've signed for the hash and this is for example how the noise safe does it so concretely because you know so safe it's also a project very close to our hearts we care a lot about having calcium work nicely with Nosa safe um the way that that the signature verification on their end works is again you have this order struct that gets compressed into a hash that you need to sign and then um yeah the safe interface has like a certain again named struct for for its signatures where then each owner can basically use their externally owned account to create a good old 712 like a good old eoa signature a good old you know ecdsh signature and then what the save does it basically Waits um for enough owners to have created their own individual signatures so if you have a three out of five say for example you need to collect signatures from at least three owners you concatenate all those three signatures together and then the save will say is valid signature true true if enough signers have signed for that hash so this is again just a recap of how it works for the safe you collect all the signatures you encode them into bytes you concatenate them together Insight is valid signature it just deconcatinates them and then checks for each signature are you an owner if so increment the count of owners that have signed and if at the end the number of signatures that have been signed by owners is greater than the threshold is valid signature returns true and this works in cow swap Nick implemented a little script that you can use to actually place these gasless orders from your nose is safe already today here's here's a proof on girly that um this works so you can actually use Nosa safe today to place gasless or you know without having to pay gas orders into into cow swap and that's already quite cool that's that's you know a very good use case of ERC 1271 but there's even a sorry yeah go ahead uh so it's gasless because um you can use your eoa to just sign the message and hand that message off to cow Swap and then Cal swap will pay for the gas basically so you use sign you basically sign with your UA that you want your smart computers you know so save to trade one ether for 1300 and then you send this message off chain to our API and our API will then send it to the solvers and the solvers will take it and settle it on chain and they will still take some fee from your sell amount so it's not that you can trade on call Swap and don't pay anything right like you will still pay whatever the gas would be in eth but in US dollars from your sell amount it just means you don't your UA doesn't need to have doesn't need to have any eth in it right you can just use the signature you don't need to fund your UA okay so this is already pretty cool to use your safe with a gases manner to to do trades but then the real power comes when we um you know you know I don't know I need to plan to have this climax but in the beginning you had decks then you had decks aggregators then you had cow swap as The Meta decks aggregators and today we're going to introduce smart orders the next Paradigm in this uh you know crazy climax okay so um the idea of smart orders is that you implement ERC 1271 similar how you just saw this that the safe does it but you can do it with arbitrary logic you don't actually have to check that there is a some signer that has signed for it using an UA you can theoretically use arbitrary logic you can check in an oracle that you want to investigate that you basically you're always okay to trade if the price is better than what chain link reports or some other logic that that is completely independent of of any actual UA signature and so the way that these smart orders usually work is you create a smart contract you deposit some tokens into it and then that smart contract implements this is valid signature method in some way or the other so yeah you have custom on chain logic and that's it and so one example that we're gonna go through today in this Workshop is a good after time order good after time orders only become valid after a certain timestamp so you can basically place an order today that becomes valid tomorrow and you could place the second one today that becomes about the day after and so you could use good after time orders to implement something like a daily cost average strategy for example and right now in the very native cow protocol order format this is not supported we have an expiry date valid too but we don't have a field valid from and so it would require to change the native cow order format it would require to update the contracts and so it's you know it's very painful to add this to Cloud protocol in its current form but you can just write a smart contract order that basically implements this Behavior and the way you would do that is you just Implement is valid signature in a way that it checks what is the current block time stamp and when that block timestamp is past a certain Target block you say is valid signature true and if it's not you say no it's not yet valid and so you can place this order into the order book the order book will constantly try to check is this order now valid or not and once it becomes valid it will automatically um you know take it into the current batch and ship it to the solvers and it will get matched automatically so let's walk over the code we'll also see it in real life in a minute but let's just walk over the code that's that's required here so this is um this is actually not this is like this the construct for a good after time order but at this point it doesn't do much at this point it just takes in the Constructor and Order hash that you want to be executing and then if um is valid signature just checks that whatever the settlement contract is trying to execute is actually the thing that we have pre-signed here so this is not yet doing good after time this is just a very basic format you you basically say here's an order hash that I'm okay executing um and then as well as signature just checks that we are indeed executing that so now um let's add cancellation because with good after time you also don't know maybe the price changes a lot you know from today to tomorrow and your order might no longer be satisfying its limit price so you might have a way you might need a way to actually cancel this order and get your funds back out so here's just some random scaffolding or like some small scaffolding to allow the owner of that contract to regain the tokens that they have deposited into it and then this is actually the part that adds the good after time into the to the smart contract so we add this valid from field we set it in the Constructor saying that this order is only valid after a certain maturity date and then in the is valid from implementation we just check that block.timestamp is passed valid front if that's not the case we revert and if it's the case we set this magic value which basically means we return true the other thing we need to remember is that the smart contract needs to have the the cow protocol settlement contract approved so the way that cloud protocol works is it needs an approval from whoever is authoring the trade so that it can actually take the the sell tokens from the author of the trade and then send it back the buy tokens so we need to set an approval and then we're good to go this is the entire code I think it's like you know 30 or 35 lines of smart contract code and you have a good after time order implemented the one thing that we added here is a factory because right now every user that wants to implement a good after time order needs to deploy their own instance of that order and so Nick also built a a small Factory contract that anyone can now call with um yeah basically a raw order struct and and some salt just to make it not replayable and then that factory contract will actually deploy the actual good after time contract and also um do the transfer of the inner mounts and and basically return the the the the order ID that has been created not super important you don't have to implement this if you want to use uh um smart orders you could just deploy every order um again and again and maybe some orders don't need to be deployed if you're looking into building an amm or so you just need to deploy it once but if you have something that every user would have to redeploy maybe a factory contract makes sense all the code is in this GitHub repo we don't have to really go through it in in depth but yeah so this is then the the general the general flow um the trader would approve the good after time Factory contract call the place function which then does all the magic basically creates this good after time order instance uh transfers all the tokens in sets the valid from parameter and the order is ready then we just have to wait for the timestamp to be reached um so this okay yeah this is then the last step that is needed right now um our back end doesn't automatically identify when an order is placed on chain so you also have to tell our backend separately hey there exists an order please start tracking this order and please start checking once this order become valid um start settling it we are working towards making this step Obsolete and just having an event emitted inside the smart contract that our backend can automatically pick up but right now you still need to um call our um yeah call our API here's how it will hopefully very soon look like you don't have to call our API anymore then you just emit an event and our backend will automatically pick up that there's a new order in the system that needs to be tracked okay I think this is maybe now good for a demo this should be demo time now so um we have the repository here um I I had to clone it um just because it was made for your rinky B and and rinky B doesn't work anymore so now it's made for girly and so if you check out my GitHub and check for the depcon 2022 smart orders repo there's the readme with the four steps you have to run um but basically what we are going to run is the place order script which does exactly what we discussed so in this repo you will find the the good after time in the contracts uh repository here you'll find the good after time orders which has all the smart contract code that we showed I'm happy to talk about the details of that also at the booth if you have specific questions and then what we're going to do right now is we're going to place one of these orders um we're going to sell with and we're going to buy cow on Gurley and we're going to set the field valid from to be starting now plus two minutes so basically when we place this order it won't be valid but two minutes later it will become valid yeah yeah you can do I mean you can do you can you can Fork from it you can start um you can start from scratch like uh really like I mean this is just one example I'll have a few more examples on the last slide but basically and we can also use the remaining time to bring some some ideas I really think there's like an endless amount of design space that you can do with this anything like that's basically expressible in solidity okay so we're going to place an order using some old account that I that I have um that is going to create an instance of this good after time order and then the script is gonna print out the order ID of the good after time order so we can track it in our in our car explorer okay so this is the order and we should check the time 153 um so in here we can check the order it's open but it won't match right away because it's not yet valid in fact we can actually check our API and we can see that right now the auction is empty so that there there's right now no orders that are allowed to be settled and this is because is valid signature returns reverts in the current state because the block time hasn't Advanced far enough yet and so now we need to kill a minute and a half of time to see this uh become valid turn up another day yeah um so the back end basically has a set of orders that attracts and um it just checks are these orders valid like do the um order creators have enough um balance have they given allowance um in this smart contract order case is the is valid signature does it return true and so it builds periodically every 15 seconds it builds an auction with all the valid orders that are currently in the system and sends it off to this network of solvers who would then go ahead and try to settle the current batch and the solvers return back kind of their proposal of how they would settle the batch and then the back end decides basically measures what is the best solution in terms of price Improvement for the user and the one that had the biggest price Improvement gets the right to then execute that settlement on chain and so um let's start looking at the API this should in a few seconds we should start seeing the order here because it will have become there there it is so this is our order it's now valid so solvers can start trying to figure out how to settle it and then hopefully um this will turn into a field very soon suspense 15 seconds never felt so long no no this isn't so the order has been yeah it has been filled this there this ERC is five years old it just got finalized last this year or so like it had some minor changes really annoying minor changes which made it not backwards compatible but still you know it didn't change fundamentally um but it got finalized this year so we're now pretty certain that that this is going to last uh for the for the future and yeah so basically here now we can see the order get filled um you know we got a nice Surplus this is like our normal console orders would work um but yeah basically you had this this logic that made it good after time here's some other cool ideas and just like you know just the tip of the iceberg of what um we could Implement with it stop loss orders is is one other example so stop loss orders means you're not buying when a certain minimum price is is uh or sorry you're not you're not buying um you're not buying so well you know but yeah you can always place it basically you normally you're selling eth when the price goes up right you're saying I want to sell ether when it's like at 1500 that's a normal limit sell order a stop loss order would be I want to exit my eth position I want to sell eth if it goes below 1 000 because then I think we're all doomed and we go to zero so stop loss orders allows you to basically um take the other side of like cut your losses and and exit if you feel like oh now we're about to go to zero and so you could use an unchain Oracle it's a chain link or something to check what is the current price of course some trust in that price Oracle is kind of you know needs to be considered in the design and then decide I say is valid signature yes if um the price is below that and then I'm basically trying to exit my position and cut my losses Advance good after time use cases would be this um daily cost average or time weighted average pricing where you basically allow for example a dow to sell or buy tokens little by little over the course of a month um but you can also think of other you know cool ideas you could for example Implement an amm in a smart contract order where the smart contract has two balances two tokens and then a constant and you just allow trades as long as x times Y is still larger or equal to K and this way you've built an amm into Cal swap which gets settled at the same uniform clearance prices as all the other users so you would have built an amm that can actually capture Surplus from trades uh you know unlike uni swap where basically you get settled exactly on your on your extends y equals K curve in Cal swap you would have amms that can actually capture price Improvement and capture Surplus and but yeah basically most of these smart contracts don't require any special integration if you're the thing that you are expressing becomes a little bit too complex you might also have to talk to one of those solvers so that they can actually understand what do I have to what do I have to do in order to activate the smart contract order um but for the vast majority of use cases you know you don't even need that you basically just have this on-chain contract that follows ERC 1271 and it will just work out of the box um so this is kind of the the wrap-up of the talk and I will go to the references uh the first thing that we talked about of how to place a gasless orders using notes safe is in the safe cow order repo from Nick and then the adjusted uh smart good after time order prototype is in uh in my GitHub repository and yeah if you have any more questions as well let's let's talk at the booth and I think we have maybe a few minutes for questions yeah maybe like I don't know one or two questions if you have anything at the top of your head but um yeah empty yeah yeah it's essentially I mean yeah so basically I mean cow swap's main value country proposition is that it protects you from Mev so basically a keeper you have to pay the keeper a you know some fee that it basically um it takes your order and then it might take it still at your limit price you you're not guaranteed and the keeper system necessarily that you're getting price Improvement whereas in cow swap you have everyone that is in the batch gets the same uniform clearance price um and by virtue of having to solve a competition and the more price improvements the solver give to you the more likely it is that they win you have this guarantee that there's actually somebody fighting for you getting the best price and um and yeah and but basically yeah there's there's other Concepts as well we personally think that or I mean we as a company think that that cow swap is a uh you know very good way for Dallas to easily you know of course somebody has to write this down um DCA order but then it can be reused by many dials over and over again and the dial can just say okay we want to buy we want to build a position for the next month let's do it automatically whereas right now you have to build this um I looked at the at buntec did a very nice example of such a keeper contract but you basically have to customize it for your company you then have to find a some flashbots Miner or like some Searcher to actually execute it for you so I think there's some user inter like user experience benefits and then also this idea of you know benefiting from other retail traders that might take the other side so basically a view where you earn and you wanted to do a buyback of Wi-Fi tokens you shouldn't be doing necessarily the Wi-Fi buyback against uni swap you can just absorb cell pressure whenever a user wants to sell a Wi-Fi why don't you just buy it as a as a solver so they sound like some of them ideas cool um we are on the Upper Floor and the corner on the left um we'll have people on the booth most of the time and happy to also help people that are interested in hacking this where we have again uh two bounties uh five thousand dollars for the best smart order or smart contract order integration and then another five thousand dollars for the best UI integration built on cloud swap can be combined of course if you build a really nice a smart contract order with a UI then of course you can also um have two both bounties which are five thousand dollars each and uh yeah happy hacking and hope to see you around thank you [Applause] thank you hi everybody Anna oh am I good to go thumbs up I think so all right hi everybody and uh Welcome to our presentation on snarkyjs in the media protocol uh thank you for being here and uh I am Jack Serbia I'm a developer relations engineer at Overland Labs which is the company that incubated the Mina protocol so you can kind of think of a one as like consensus to ethereum or as Mina Foundation is ethereum foundation to ethereum um I'm based in Denver and here's kind of what we're going to go over today so first we're going to talk about snarky.js which is the Smart contract language for the Mina protocol and kind of unique for a bunch of thing reasons we'll get into and then we're going to go through an example where we build a simple smart contract that you know uh verifies that the number you pass in as an argument is the correct uh next number in the Fibonacci sequence then we're going to make this recursive which is something we'll kind of explain why that's cool later but it basically allows you to do a lot of stuff off chain without any additional security assumptions then we'll talk about the Mina protocol which is sort of like a meta version of this it's like a settlement layer for these uh zero knowledge applications and then we can talk about where to learn more and open up to questions and answers um so snarky JS it's a typescript library for defining zero knowledge proofs and it's also the smart contract language for the Mina protocol uh it looks like this but don't worry too much about the code right now we'll get into it more in a minute everything is in typescript so you can keep using the tools you're familiar with uh like prettier npm vs code uh eslint Etc and it's really easy to learn it's actually so easy to learn that you can probably figure a lot of stuff out just with intellisense if you look here we have you know an example of uh kind of a funky looking decorator and then a really good explanation of what this is so you can just dive straight into it and it's also extremely powerful so uh this is for two reasons one is our proof system which is something that we've built in-house it's called kimchi and and uh it has a number of features that make it really well really well suited to a kind of application like this uh it's fully trustless setup so there's no ceremonies uh we have custom constraints for Poseidon uh which is a hash function that's particularly efficient in zero knowledge proofs um elliptic curves and and encryption uh we also have constant proof size uh that's why ovon Labs is called ovon Labs um and it's recursive which means that we can generate zero knowledge for something and then we can actually verify that zero knowledge proof inside of another zero knowledge proof and so this opens the door to a whole bunch of new architectures for things that can increase scalability user experience and and of course also provide privacy um finally it's planckish which means that we can add new features like Dynamic array access which is something we're working on um so kimchi is you know mostly should kind of not be something you have to worry about too much but just sort of know that we've put as as much horsepower as we can into into snarky Jazz and so the other side of what makes snarky Jazz so powerful is that is actually the language itself um typescript method chaining allows developers to think through their programs in a very linear way especially compared to other zero knowledge proof sort of paradigms and so we can sort of see what this looks like here we have this pool is correct color we can just call and on it and pass in you know the thing that we want to end it with and what we get out is is another bull um is white Peg uh and if we want to do something more complicated we just chain these methods together and so this makes it very straightforward think about this is my data this is what's going to happen to it and then this is sort of uh what's going to come out and it makes it easier to make sure that everything that you're doing is is being sort of proved correctly which is a it makes it easier to write code that's secure basically uh we also have custom circuit values and and these have actually been uh we're in the process of possibly changing this to something called struct you can go look at the GitHub and read the RFC for this and and uh leave comments if you want but for now I'll explain how circuit value works struct is largely the same thing just better but even circuit values are very cool and so these provide a layer of abstraction that makes data much easier to think about than it might be um otherwise what this looks like is uh we can take um in zero and all troops everything fundamentally because of the cryptography has to be represented as something called a field element which is just a it's sort of like a un256 with some special properties um but it's required by the underlying cryptography and so trying to represent a more complicated data types in other zero knowledge proof languages can be quite hard snarky Jazz makes it fairly easy with this circuit value maybe soon to be struck which allows you to basically describe a way to turn normal JavaScript values you know normal JavaScript variables numbers strings whatever into fields and then take them back from Fields into into something you can work with and so this in this case we have defined one called pegs and this represents Four Pegs in a board game and we can work with the sort of just the same as as uh as you'd expect finally plenty of the stuff that you need is already implemented in Starkey JS what we have today is support for a bunch of different uh types that are built on top of this field type so the field type can be a little complicated to work with sometimes but what we can do is we can actually compose field types into other things that are more familiar and so we have types for un64 U and 32 and 64. a groupable scalar public key private key signature and more coming soon including hopefully string pretty quickly we also have efficient Poseidon hash function which means that we can do hash evaluations very efficiently in Starkey Jess and this opens the door to things like big Merkle trees and other kind of stuff like that we have efficient encryption and decryption so you can do things like take data um well actually we'll we'll jump back to this in a second uh we have signatures uh Merkle trees are supported in the experimental API right now which is just a namespace in in the API that has stuff that's bleeding edge and we have the recursion API which is something we'll talk more about later in this presentation um signatures and encryption and decryption are unique and I'll just sort of call them out now because what you can actually do with this is like take a value from a trusted Source they can sign it and then you can pass this value into a zero knowledge proof verify that it was signed by the you know the trusted party and then you can augment it in some way so you could do something like prove I am not a citizen of the United States I'm over the age of 21 and I'm not ofax sanctioned or you could prove the opposite it's up to you um so why did we choose typescript this is kind of a common question and the answer is because we're ecosystem focused so the idea is that people who want to work on tough cryptography can do this and they can put their stuff in you know npm libraries very easily and and then people who want to build user facing products can import this and and have access to a whole lot of power really quickly we want to kind of get both of these groups of people working together in order to you know sort of uh really push forward a new class of applications um we're looking for code reuse that's as high as it is in the JavaScript ecosystem um the other thing uh that I think is worth calling out is that if typescript sounds a little bit like a what would you say like um some people have maybe a problem with typescript if you're writing your front end um writing a snarky Jazz smart contract is is only nominally more work uh so how actually the smart contract works is uh actually I'm sorry we'll dive into this a little bit more later I keep getting ahead of myself for now I'll just stick to this so this is snarky Jess uh we've been through all this um how does it work well here it is in five sentences it's a typescript library all the information is represented in one of the snarky.js compatible types so these are all composed of the field type ultimately but like you went you know we know how to turn that into field so everything is under the hood fields or an easier way to work with Fields one of the circuit values that's composed of them Starkey jest provides classes and functions that are compatible with the field type or these circuit values that are composed of them so we can do things like add two numbers together um but not only can we add the numbers together we can prove that we add the numbers together correctly without revealing what they were um and and this is sort of this next thing so snarky Jess after we've written our program it can represent any operations on the field type as what's called a kimchi arithmetization which is basically a math problem that represents the um the program that we wrote and this is important because the zero knowledge proof system is itself kind of a math problem and so we need to turn everything into math in order to be able to prove that we're doing what we say we are um and then finally a user that interacts with the snarkyjs program can generate a zero and all truth that their interaction was legal and this opens the door to a lot of cool things one of them is snarky.js smart contracts on Mina protocol which we'll dive more into in a little bit so uh in this Paradigm developers write smart contracts in typescript and they deploy the verification key to a ZK app account which is just a specific kind of account on the Mina protocol what this looks like is you know we write our application we send a transaction with the verification key which is just an artifact that's generated um it's you can think of it as sort of like a commitment to our code with extra features what is it which is that we can use this key to verify zero knowledge groups that we generate for this code and only this verification key lives on Mina so then the user will run the smart contract in their browser and they'll generate a zero and all proof of their interaction you know proving that it was allowed and then they'll send this proof to Mina and and if Mina will check it against the verification key that's stored on chain and if it passes then the transaction goes through and if it doesn't then it fails um if the transaction does go through then it commits any of the relevant State updates that were associated with the proof so when we do something uh with a mean a smart contract uh the smart contract is sort of getting in as arguments the arguments that the user passes in some smart contracts State you know this is the state of the smart contract prior to the user interacting with it and the you know some values from this state of the world this could be like block height um and so the smart contract actually run in the user's browser the user will get all this information themselves they'll pass it in and they get a proof out as well as the new state of you know whatever value they were interacting with so if I want to send you money I can literally just say I'm going to basically write to your token balance and here's the proof that I'm allowed to and that's all that's needed um that's a rehash of that so how do the ZK apps work well you install your smart contract in your UI um and then you deploy it and that's all and so yeah you can just publish your uh smart contract on npm or GitHub or wherever you can just npm install it import it like you would anything else and and it's a part of your UI it's very straightforward um so now we'll kind of get into an example and uh this is uh hopefully everybody's familiar with like the Fibonacci sequence if you're not um it's the last two numbers in the sequence added together equals the next number in the sequence so one and one two two and one three so on and so on um you know three and two five uh so we'll write a smart contract that calculates the next number in the Fibonacci sequence and also don't worry if this goes a little bit uh will be at the booth we're upstairs on the second floor in the corner and uh if this is sort of uh obfuscated at some point come talk to us and we'll make it clear um but the point is now just kind of broad Strokes so we'll have two pieces of state that we store in the smart contract this is going to be n minus 2 and N minus 1. um these represent the last two numbers in the sequence if we have a method uh so so we'll also add a method update which will let us update n minus 1 and N minus two if we pass in you know the correct number the next number in the sequence uh so in order to do this all that we do is we extend this smart contract class into something called Fibonacci Sequence and now we have a smart contract called Fibonacci sequence then we add some state and we call it n minus 1 and N minus two we set it to the field type and we use the state decorator which if you're not familiar with typescript decorators again come get us they're not too hard to get your head around um but what this basically tells snarky Jess is hey when a user Alters this value uh figure out how to store it on chain and prove that we're updating it correctly and so these numbers will be stored on chain um the next thing that we have is this deploy method this is a method that gets called at the time that the smart contract is getting actually deployed to the chain which is at the time we're calculating this verification key and bundling it up into a transaction and sending it off to the chain um you usually don't have to worry too much about this uh the defaults work nicely in most cases but in this case we're going to use um the this deploy space uh to initialize the values of our of our state variables um and you can do other things here too like set permissions uh again we won't dive into it too much but all that we do is we call you know this and minus two and then we'll call the set method on it and we pass in a value and in this case we're passing in field.0 don't worry about this dot 0.1 you can also pass in You Know Field open parentheses one close parentheses it does the same thing this is a confusing um uh kind of artifact that exists right now um so uh next thing that we do is we Define a method that users can use to you know interact with the smart contract and we just call it method I'm sorry we call it update and we add the method decorator and the method decorator basically says hey um this is a thing that users are going to call when they do prove that they're doing it correctly we can pass in an argument and that will be the next number in the sequence and what we do is we grab n minus 1 and N minus 2 from on chain State we store them in local variables then we uh add n minus 2 to n minus 1 and we check that the value that we passed in as an argument is is equal to this edition of these last two numbers in the sequence and so this assert equals it actually means that like you will simply not be able to generate a valid zero knowledge proof if if new state does not equal n um and so there's no way for a user to call this unless they're passing in the correct argument now what's really cool and I don't know if this was sort of clear by now or not but the value of the argument that the user passes in and all the computation they do is private they don't ever send it out of their browser unless they want to so uh the only thing that that is public is the you know the on-chain state and and you can build a lot of private applications very easily by storing a commitment to something private in the form of like I don't know hashing some private value and storing the hash on chain um so yeah we can uh I guess it's not useful in this case we can prove that we know the next number in the Fibonacci sequence without well in this case I guess we do reveal what it is um because it becomes n minus one but you get the picture there's a lot of cool stuff you can do with this um now uh the final thing that we do is we set these on-chain states to uh you know we move n minus one to n minus two in and we move the the new state to n minus one um this is pretty much the basic structure of the smart contract we have you know a we extend the smart contract method we add our state definitions uh deploy method and then we add the the user callable methods and add the method decorator to them so what's really cool about this architecture is that we can actually make this uh recursive and what this means is that right now the current Fibonacci program that we just built um this every time a user wants to interact with it they they or every time a user wants to do something they basically have to create a transaction send it to Mina pay the fee and wait for it to be mined um this is what's really cool about recursive zero knowledge groups they allow you to move away from this in really interesting ways so um we had smart contract but we also have ZK program and ZK program is what it sounds like it's just a zero knowledge proof program as opposed to sort of a zero knowledge truth program that's also a smart contract and so we can do is we can write a ZK program that actually takes proofs as inputs um so the ZK program we run it and we get a proof out and that proves that we ran the ZK program correctly as well as the outputs um but we can actually also pass these proofs so we can pass proof that we ran a ZK program correctly into a ZK program and this lets you uh scale in really cool ways and so I won't dive too much into what this is now because I think we'll be a little bit short on time and I want to get to mina which is really the sort of important part of this um but uh to give you an idea of uh why this is useful we can basically uh uh yeah so we can uh what would you say we can prove that we have a number of the Fibonacci sequence and we can take that proof and pass it into um uh an another proof that verifies it and so this can be useful for something like let's say we wanted to make take a moving average of values over like 20 years we could do is we could take the moving average for the last 10 minutes prove it and then take the moving average for the next 10 minutes prove that but in that proof we can also include the computation that verifies that the first proof is correct and we can do this over and over and over again and we can just keep one proof that attest to the fact that we've had been keeping a correct moving average for you know 20 years or something and it stays you know it stays very small the other thing you can do is you can create uh like well we'll get into it in a second um so uh how does this work well you write your uh ZK program or sorry you wrap your CK program inside of a proof class and then you pass the proof as an input parameter to your ZK app to verify that it's correct um again this was kind of fast we went over this really quickly but if you have any questions seriously come by the booth and stop us we'll help you get started building something or uh you know just answer any any questions you have so this kind of brings us to the you know the the climax of the presentation which is you know what is Mina um and actually wait I'm sorry I'm going to go back I know this is very non-linear um but another thing that we can do with recursion um uh is we can build uh smart contracts that execute largely off chain and so an example of this is like let's say that we built a game um and I don't know if anybody has heard of the game Mastermind but this is a tutorial that uh we did a while ago we have uh um or sorry another tutorial a workshop that we did a while ago and we have it recorded and so at the end of this presentation there'll be a QR code that will take you to a bunch of relevant links and also that um and so this is a game where it's limited information so I can't know what my opponent is doing but I have to know that they're making legal moves um and so this is a game that would be very hard to build on a normal blockchain it's very easy to build on Mina but it goes a step further uh if you build it in the naive way you have a game that you have to you know send a transaction to mina every time a user wants to make a move but using recursion we can take this and we can set the game up in such a way that I will make my move I'll prove to you that it was correct and then you'll make your move which will also verify the correctness of my move by verifying the proof and send your move to me proving that it was correct without revealing what it was and we can do this back and forth so on and so on without ever having to pay fees or wait four blocks to get mined so the user experience is literally like it would be in web 2. and at the end we have a proof that attests to the correct computation of all of our whole game and then that can get you know settled on chain um so this is obviously really good for user experience um and also really cool uh so okay now we're to the you know back to where we were with what is Mina protocol um well it's a layer one blockchain that proves its entire finalized State using recursive zero knowledge proofs and because of that it stays small you only need 22 kilobytes in order to verify basically that the current finalized chain state for an account is correct and and uh this is cool but it's also really useful um there for quite a few reasons one is privacy as we said the theorem stock contracts found on every node so all the information is public uh uh here's what ethereum looks like uh Mina smart contracts run in the browser and so arguments and intermediary values are private by default um again managing you know keeping the state private if you want to can in many cases be as simple as just hashing it uh so what does this look like we do the stuff we want to do in our browser then we just send State updates and approve that's it Mina verifies the proof and updates the onstain on chain state if it's correct next scalability there's no gas model uh zika apps are on off chain which means that the amount of computation does not affect the transaction cost you can do in theory an unlimited amount of computation in a single Amino transaction you can also do them asynchronously which this presentation isn't about but is another pretty cool feature uh so yeah you can run smart contracts asynchronously on Mina um again come to the booth and ask if you're curious about that so developers can use recursion to build application specific Roll-Ups what are these um oh well uh they're what we talked about earlier I think I kind of forgot the order of some of this um yeah these These are applications where only the parts that need to be verified on chain are verified on chain in many cases you'd actually don't need the the chain to sort of verify what you're doing like if you're just interacting with one other user in in a game or something really you only need to prove to the other person you're playing against that what you're doing is correct as long as you can eventually prove it to the chain and so this is uh a door to some really interesting stuff um decentralization uh it's possible to validate the entire finalized mean estate using only a small zero knowledge proof uh and and so um what that means is that there's no need to rely on trusted third-party node operators like inferior um right now chainsafe is working on an implementation of a wallet that will basically be uh a full meaning node um you know no additional security sort of concessions um and how it works is that it just uses the zero the zero knowledge proof to verify the transaction history right with Mina we do some stuff we proved that it was correct so all the transactions are zero knowledge proofs and then we take these zero knowledge proofs and we verify them inside of another zero knowledge proof and inside of that zero knowledge truth we also also verify a zero knowledge proof that uh represents the last batch of transactions and that one verifies a zero knowledge truth that uh is also verifying that batch of transactions before that and so on and so on and so what we're left with is one zero and all truth that represents the entire chain history and and uh and and proves that uh it was legal for us to get to the place that we got to basically and so then a wallet um can just with this 22 kilobyte stub verify that the proof is correct and and no um you know that things are right it doesn't have to grab all the previous data and sum it all together like an ethereum node does uh this is really cool also because of bridging uh so smart contracts on other chains can Bridge the entire immune estate just by verifying the most recent proof to get into what this means a little bit more um you can write a smart contract on another chain and as long as that smart contract can do the math to verify uh the mean of zero knowledge proof then you can be sure from within that chain that uh whatever State Route is associated with that zero null truth is the legal mean estate route um for a given block height and uh and so the nil Foundation is working on one of these Bridges right now they have a demo working on one of the ethereum test Nets um but it really does work it's it's uh you can go play with it here um and the result of this is that there's no you know like Quorum of there's no multi-cigs there's none of the really confusing stuff there's none of the really hackable stuff there's just um uh basically a smart contract anybody can interact with it anybody can go grab the mean estate anybody can send the mean estate to the smart contract pay the gas fees and in one block uh you have got the whole most recent State Bridge over uh finally oracles um we're working on a product called ZK oracles right now and these will allow users to create TLS uh proofs that bridge data from any website onto the mean of blockchain and so when you go to websites now you get a little lock inside of your browser this means that we did this thing called a TLS handshake it's like a a thing that allows you to know that you're talking to Amazon and Amazon is talking to you and that nobody's in the middle listening to what you're saying and uh the problem is that it's interactive and so it's only the the protocol only really proves anything to you and to Amazon you couldn't send it to ethereum because it's interactive ethereum would have to sort of interact with Amazon for it to work that way and so with zero knowledge proofs we can use this interactive sort of uh protocol and make it non-interactive um and the result is that I can prove that I went to my bank accounts website or my bank's website and uh basically I can prove that like the person at usbank.org sent whatever they sent to me um and that nothing has been tampered with and this is really cool because then we can take this information and we can do something like then augment it so I could get all this really personal information prove that it really did come from U.S bank and then just have a Boolean that says does Jack have more than one dollar um and uh and get a proof that just says Jack has more than one dollar or Jack doesn't and so you can make the information uh you know sort of as private as you need it to be and no more um what else well we actually don't really know everything that's possible yet and this is what we're hoping that you guys here will help us figure out um there are so many new ways that we've found that we can do things that we would not have thought of you know even six months ago and uh yeah that's uh what we're hoping to get out of hackathons like this we hope that you guys try new things and uh and and yeah find new ways of of uh of doing things that leverage all of this sort of new uh flexibility so what makes me in a protocol unique all this stuff um where to learn more um how do I get started uh okay yeah so yeah how do I get started uh well all you do is mpm install the zcap CLI and ZK project it'll start up a repository with a scaffold code a simple contract that will add two numbers together and that's all that you need uh the zcap CLI is our only piece of developer tooling it's very simple it's very straightforward to use and it's very powerful uh it uh um yeah so if you want to get started just do this there's nothing more really uh it should take one minute and you can even uh deploy to uh Berkeley testnet which is our uh test net uh I think we have cards at our booth that we'll explain how to do that again should take no more than 15 minutes to get started uh where do you get involved well we have a well Mina Foundation has a quarterly grants program uh so uh you can get grants by uh building CK apps creating educational content or mentoring and so these are backward looking grants so just do Google stuff and then maybe you'll get a bunch of money um or some money um so here's a QR code if you scan it we've got a links to a bunch of the relevant stuff from this presentation um we also have our docs website which we just revamped like maybe a week ago it's a lot better now we have search and and some other stuff that we've been kind of putting off for a little bit um we have the zcap developers Channel and Discord this is a really great place to to meet other people who are building stuff um here's our twitters and uh what else if anybody else from Mina Foundation or Erwin Labs has anything else I should add yeah Yanni awesome yoni's got the cards Yasin for two minutes awesome all right well thank you so much guys foreign 