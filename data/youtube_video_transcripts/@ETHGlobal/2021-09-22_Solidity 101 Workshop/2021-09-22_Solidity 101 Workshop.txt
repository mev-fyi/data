active workshop i'll let jeff take it away shortly we encourage everyone to ask questions um check in this is going to be a hands-on kind of thing so at that i will um i'll hand it off to jeff wonderful thank you um uh thank you very much andrew uh hi everybody uh good morning good afternoon good evening i'm jeff wentworth the co-founder of a blockchain middleware company called curve grid i'm here to do solidity 101. i do have some slides i was not going to go through them today at all and i wanted to make this highly interactive so um what i thought what what i have up in front of me here is um is remix i'm going to spend about three minutes sort of giving a quick tour of of this web application um and then i would love to encourage you to if you have a question or you've had run into issues during uh during the hackathon thus far when you're coding solidity or you know something you've always wondered about blockchain programming go ahead and and you can either throw it into the chat while i'm doing my little intro or you can unmute and ask it then and we're going to use that as a starting point for a more in-depth uh um you know basically dive into into smart contracts we're actually going to build one up and i'll show you how how we how we uh how we can sort of do that um from scratch so um so this is this is remix um it's always gonna end up tacking on these these um parameters at the end but you can just go to remix.ethereum.org and this is um this has been around for quite some time um and you know was sort of left left to the side for a while uh in favor of some other tools but then the ethereum foundation has come back to it and it really is quite a quite a useful uh you know tool whether you're an a beginner smart contract programmer or you know very experienced on the left side here you've got a number of different um uh uh you know tabs left side tabs um if you when you first get in here you may see nothing on the left side and in that case what you need to do is click one of the uh the featured plugins let's say solidity this is solidity 101. um the first tab is a file explorer and you'll notice a number of different um a number of different files that are already here and you can you can always add more the second one is the solidity compiler tab and it should default to the latest uh solidity which is 0.87 but you can choose any of the other versions in here and they're loaded dynamically that you can turn on auto compile if you have a fast enough computer uh this can be very handy um i don't have it turned on at the moment but we may do that later and then the the the the kind of the other tab here that's very helpful is actually deploy and run transactions and this is a complete blockchain uh right in your web browser excuse me so this has the nice feature of doing everything in a javascript you know evm vm if you will uh ethereum virtual machine you can also either use injectedweb3 this means uh basically metamask or similar web3 wallet or you can connect to a web3 provider right so you can uh if you're running gaff and you have actually like another endpoint here you can specify it directly if you want to stick to javascript vm with the javascript vm you get a bunch of fake wallets with uh fake ether and you can set parameters here once a contract is being compiled in the solidity tab then you can deploy it or you can link to it at an address here so we don't have any contracts deployed at this point so there's nothing we can do um what are these other tabs here we have yeah if you wanted to do um there's some static analysis on your solidity there's some unit testing pieces which you can run here and uh plugin manager and there should be here's all the different plugins you can add uh if you want which can be super helpful so that is the three minute tour of remix which we're going to spend some time in today have there been any questions in the chat no not so far does anybody want to unmute again if you have a question or you're stuck in a particular spot with solidity and you know want to know where to start anyone this will be our starting point for where we kind of kick things off i will give it a minute less than a minute none yet but thanks for starting with remix wonderful thank you derek um okay well if you if you do think of something please do unmute um otherwise what i'm going to do is actually flip back to slides uh and i'm going to assume that you you don't have that i'm going to assume that that i'm going to start fairly basic um but please do please do raise your hand if you if you do have any questions or speak up or unmute if you do have any questions or if you let me go a little bit faster or slower i'm going to skip through a bunch of these um earlier slides and i want to talk a little bit about what smart contracts are first and then we're going to flip back to our remix and and actually do some do some coding in there right uh like basic basic solidity solidity 101. um so if you consider the blockchain right and we're going through this because i think this is important mental model to have when you're programming right so the blockchain i like to think of it as a decentralized ledger or a table or a spreadsheet and if you consider a double what uh if you've ever taken let's say counting 101 not solidity 101 what me it what might be a double entry uh bookkeeping ledger so this is basically what the blockchain is what the ethereum blockchain is um where you have accounts let's say alice and bob and then you have two columns one for debit and one for credit right so let's say minus 2 000 ether from alice and plus 2 000 ether to bob um the point is that uh you know key point here is that these transactions are atomic on the ledger which means uh either the entire thing happens or uh none of it happens uh you know so if you've ever uh dealt with bank wire transfers and you know you've sent money and the recipient didn't get it or you've found money in your account that you didn't expect um which happens uh that's not possible in blockchain the ethereum blockchain either the entire transaction happens or it doesn't and that's what we mean by being it being atomic transactions are grouped together in blocks and blocks are appended to the ledger so you can think of it as each transaction is happening in turn and essentially it's a it's a giant table or giant spreadsheet that's always growing downwards with time what we mean by immutable is that you can never go back and erase something in the middle right so um uh as as the ledger's uh uh being appended to you can always do you know potentially let's say undo but you can never do um you'll always have a record of that right nobody will ever be able to sort of cook the books as it as it were on you account names are actually very large numbers right so represented here in base 16 and if we come back to remix you can see in the simulator we have our accounts here and if i was to open up metamask you would see the accounts there as well so these are uh 40 bit uh numbers 2 to the power 40 so 20 hexadecimal uh characters and they represent the address right the public address of uh of an account um so the the public key side of it it's not the public key it's a representation of of the public key uh transactions can include it can include include computer code right that will run on the blockchain so in this case we're invoking a function called remit uh with some parameters right so so so far in this uh a series of uh um examples we've just been dealing with sending ether back and forth but now we're actually talking about including computer code that's going to run on the blockchain so if we have bob here right who's both receiving ether but also is uh receiving a transaction or receiving this computer code to run on the blockchain who or what is bob this account number well turns out that accounts can also be smart contracts can be computer code uh that runs on the blockchain so again a smart contract is nothing more than computer code that runs on the blockchain um and so this is this is the function remit it's it's similar to um to functions in c like programming languages there's a name and um there are parameters that get passed in uh optionally there's return values and then there are um uh there are let's say qualifiers here which tell you things or set different um uh um characteristics of the function for example is it public or is it private and internal uh which just means can it be called externally um can you send ether to it or not right we're going to get back a little bit more into this so again level set computer programs on the blockchain also called smart contracts they can hold and dispense value or ether they're governed by the rules of their computer code and and like any other transaction or any any other credit or debit entry on the ethereum ledger uh they're immutable uh they can be inspected or invoked by anyone who has access to the blockchain and this is a really key piece from a security perspective so a minute ago i mentioned the fact that there's this thing called private functions that doesn't mean that nobody can see them or access them it simply means that from within the programming paradigm that they're not accessible outside of that smart contract but you can still see the code and anybody with sufficient technical knowledge can access any of the data on the blockchain and so we have to protect access to contracts through some other mechanism they also cost gas to invoke um which is currently so sorry i'm based in tokyo japan uh depending on your blockchain uh or layer two it could be anywhere from let's say five five yen to a hundred thousand yen which is roughly you know five five cents canadian or american and uh to a thousand dollars canadian american and then this limit on gas prevents runaway contracts we're going to go into some of the details on each of these um in a little bit um but it's these are sort of the you know some of the key pieces i want to talk for one second about some adapts or decentralized applications and probably most of you are building a dap you're not just building a smart contract in the hack and in this f online hackathon you're building a complete decentralized application which is a combination of traditional software that means you know web front end potentially a back end maybe a database as well with one or more smart contracts running on the blockchain now i said maybe a database as well when we're thinking about like mental models around what a smart contract is and what the ethereum blockchain is many people say it's like a distributed database that's true but it's also like a distributed um cloud compute system right because we have these computer programs that are running on the blockchain and one of the characteristics of distributed databases like a mongodb or like the ethereum blockchain or distributed compute clouds like let's say aws or like the ethereum blockchain is that um they they have to make a trade-off between um uh i'm going to get this this wrong what's the triangle cap consistency availability and uh as a performance but the the key piece there is with consistency the trade-off that ethereum makes is that it will be eventually consistent right that it's not guaranteeing that when you send your transaction and it gets included into the blockchain that the first time it gets included into the blockchain the first time your computer code runs is the only time it's going to run the effects of it may get undone uh in what's called a chain reorganization and then redone later or may never happen and that's one of the the the issues around the practical aspects of blockchain programming so that's it for the slides i see a note in the chat partition tolerance thank you thank you partition tolerance consistency availability and partition tolerance aka forking any questions at this time before i flip back to remix you can put in the chat or you can you can just unmute yourself if you feel um comfortable doing that okay great so uh okay absent any questions or direction on what to do we are going to start from first principles and create a brand new smart contract uh and um we're going to um you know we're going to see if we get it to compile and then we're going to interact with it because because why not um so what you do in remix is you come in here and it should have a default workspace uh already created you can also create new workspaces if you want by clicking this plus icon here or rename it or delete it you can upload files sorry create new folders publish it to github load a local file or create a new file that's we're going to do inside the contracts folder so i think you need to click the contracts folder first we're going to get a new file and we're going to call it uh solidity101.sol and it's going to open up here generally the first line in any solidity smart contract is uh the pragma line pragma solidity and then you have to give it a okay so what does pragma mean i should i should back up pragma uh is an instruction to the compiler about something pragma solidity means hey mr soul c solidity compiler uh or or or uh hey soul compet solidity compiler i am going to um i'm going to tell you what version uh what versions i support now you can do something like um 0.0.0 um i can't remember what this is like that i think would say like any possible solidity version but that's not very good because solidity has gone through a number of um uh where are we here solidity's gone through a number of uh transformational changes since the first version that's in here 0.1.1 even within so so we have i mean i would call the first one major minor and then um uh point release right sorry again i can't remember what what you would typically call this third one uh but essentially solidity at this point anyways we're not yet it was the version 1.0 because it's been undergoing so many changes so really this is like major and minor it but even within the major even within the 0.1 or 0.5 we see breaking changes to the language and one of the challenges when you're reading stack overflow or looking at other code is that if you're not using the exact solidity compiler version things may not work that's challenge number one challenge number two is when you're trying to combine different uh contracts right like you're trying to import another contract into yours and it's using a different solidity compiler version if you're just using straight solid the straight solidity compiler the command line uh or or even remix uh or truffle um as far as i'm aware at this point sometimes it won't compile and you will need to update one or more contracts to the desired version hard hat which is another um so truffle is sort of like your npm it actually is built on npm but it's kind of like your version manager compiler manager you know build manager for one of them for for solidity hard hat uh is another one uh which is is created by us a different organization uh consensus versus no make labs hard hat does support uh compiling uh multiple versions of different versions of solidity patch perfect thank you andrew and and tom i'm just checking if people are are paying attention major minor patch is the third one but really every i would say solidity shifts everything to the right we're going to use the latest one because why not it's more efficient there's some more fun features in it but i would say that uh 0.70.6 are are popular as uh as well so pragma solidity whoops uh tilled sorry not tilled carrot little hat symbol uh and then 0.8.0 what this is saying is anything within the 0.8 family is acceptable i can also lock it to a particular uh version by doing let's say pregnancy 0.8.7 but let's leave it at 0.8.0 which just gives us more flexibility and um okay so pregnancy solidity zero eight zero whoops contract solidity 101 open squiggly bracket close quickly bracket all right let's see if this compiles minimal solidity 101 compile solidity 101 there we go it's compiled warning spdx license identifier not provided in source file um we will see this spdx license identifier just means like what is the um uh what is the um you know open source or closed source status of this so let's see if we can make quiet this spdx license oops license license identifier so i couldn't copy and paste that mit um compile there we go we have soothed the linter and made it quiet absolutely 100 minimal smart contract here let's try to deploy it uh in remix uh sorry within within this javascript vm so we're going to use our base account here and we're going to pick our contract solidity 101 we're going to uh then click deploy and boom it's being deployed so you'll see in the lower right here this is sort of our transaction log and uh if i expand that scroll down you can see that we have indeed uh with this transaction hash from this address which is my address up here my ox 5b3 ox5b3 with a gas limit of 80 million gas which actually contradicts our gas limit here but that's actually good 3 million is very low um within within uh i think mainnet ethereum the base gas limit something like 15 million now for some reason remix the limit is still 3 million if you get an out of gas error either on contract deployment or on your contract interactions consider increasing this gas limit to something more reasonable like 15 million um that's that's just a tip it's taken 67 000 gas to deploy now gas again is not ether it is a unitless measure of how much um um essentially like a a cost a cost uh with with how much a smart contract interaction took there's a limit on gas on both right transactions and read transactions but you don't actually pay any money when you're reading from the blockchain only when you're writing to the blockchain every uh what happens when we compile solidity is our code here gets compiled down into bytecode zeros and ones and um and then sent to the blockchain right that's what we've done when we deployed it and uh and then when it's executed either in a deployment because that's that there is an execution that goes along with deployment uh or subsequently every op code that gets executed has its own gas cost storing data on the blockchain with a opcode like um s load costs a lot more money than just doing an addition um the evm the ethereum virtual machine when it's executing your smart contract keeps track of the cost of each op code and when you exceed your gas limit that either you have provided as part of the transaction or that is is the gas limit of that block which again on ethereum main net now is something like 15 million i believe um your contract will return with an error out of gas transaction aborted and everything uh gets gets undone so this is another key constraint of solidity programming we need to fit everything within at least the block gas limit um and if you are hitting the block gas limit on ethereum main net you're going to be paying something like two ether in in costs uh which is what like eight thousand dollars uh now um so this is also where we start to talk about like being very very efficient with solidity programming for read functions doesn't matter we can spend as much gas as we want up to that 15 million uh but for right functions you know it's we have to think about being being efficient with them or use a different blockchain and or use a different blockchain that is cheaper so remember how i said that that gas is unitless that's true there's also a a gas to ether exchange rate which fluctuates so here's gasnow.org this is for ethereum mainnet this tells you the current basically exchange rate and the gas price you have to set a gas price when you send a transaction there's no it's not here at all because this is just you know fake money um but basically the miners will bid on will not bid you are essentially bidding for inclusion in a block right so the way to think about it again like mental programming model when you use a cloud computing service like amazon aws um you are charged at the end of every month well first of all if you're on the free plan you don't get charged anything but there is no free plan with ethereum except on the test networks that is the free plan i suppose but let's say on aws amazon web services or google compute cloud or microsoft azure you're charged on your credit card at the end of each month for what you have used in ethereum you are charged immediately when you submit the transaction um and it's not a fixed charge it's a variable charge you're essentially bidding for compute and storage time on the ethereum blockchain this is like completely different than what most of us have have done in the past but this is essentially decentralization right and you think oh my gosh how do i manage this as a programmer well most of the time you don't need to worry about it because your users are the ones that are going to be paying when they mint an nft right they call your function to mint or claim an nft or to interact with your contract they're the ones that are going to be uh paying for it with you know cash on the table not credit card at the at the end of the month hello question from gabriel is there a way to know before a transaction is done the gas price it would cost so uh when you submit a transaction whether it's through the metamask or another web3 wallet in the browser or um if you're submitting it manually through a blockchain node it will estimate it it uses what's called a gas price oracle to give you what it thinks is a reasonable price to get it done in in a certain amount of time so let me um let's go into here start on bsd mainnet but let's go to ethereum mainnet let's go to this account here and you can see that um [Music] uh can we do an easy contract interaction uh no no actually not not at the moment but but what happens when um um let's let's go to like uniswap um it's going to it's probably not going to um so this is a dap right unit swappers adapt um and let's say okay so i have my ethereum account connected here let's do like one i want to swap one ether for like one die uh it's probably going to be smart enough and say like insufficient heat balance but if i had sufficient heat bounce when i clicked swap here it would pop up and it would give me essentially a gas price it would quote it to me and i can adjust that up or down there's a great website what is it f bus ethereum bus transactions here we go ethereum transaction visualizer so this is um this is a lot of um uh this is a lot of animation so i'm not actually going to load it but essentially this shows you what happens for all the transactions that are waiting as they get on the buses the people are transactions the buses are blocks uh i'm gonna so i'm gonna drop that link in the chat and and that's a good visualization of how transactions work with um gas prices if you will okay um where are we here to chat uh okay so how are we doing the time how we're good again shout your questions out unmute or put them in the chat if you want um so we have our we have deployed our contract with 67 000 uh gas on our test blockchain and woohoo there we go so here's if if we go back to the left hand side we click the deploy button we had our contract selected and um we can see our deployed contract here and uh wonderful what can we do with it well actually not a whole lot because there's no functions in it yet so the most that we can do is pass in some uh what's called manual call data some bytes and and click transact and and uh basically like nothing nothing's going to happen if we try to do that so i'm going to do you know let's say zero one and if i click transact uh it's gonna fail because i don't even have a what's called a fallback function defined so people can can send data to your smart contract even if you don't have any functions to find uh if uh if you have a function called the fallback function like the default function to find then it will run when they do that but basically we can't do a whole lot here so let's create a smart contract um why don't we create an nft um you know because uh because it sounds it sounds pretty it's it's pretty topical and fun um so so an nft non-fungible token these are unique serial numbered items so it could be um you know it could be like smartphones it could be uh cars it could be um artwork for collectibles this one collectible is different from that uh this other collectible over here as opposed to fungible items which would be uh like money or like uh bolts in a box in a warehouse one bolt is the same as the other another bolt there's no serial numbers on it non-fungible tokens nft is obviously very topical right now so the first thing that we need is uh we need some way to keep track of uh uh the nfts so what we're going to do is we're going to use an array um let's say let's see let's call it um let's call it like uh inventory oh no okay another question thank you so there's no way to know what a transactional cost from my ide uh no there is there's a function uh within most of the javascript sdks for example ethers.js or web3.js called estimate gas and and also um that will tell you how much gas a function is going to a function call it's likely to take as well as there should be a gas price function or recommended gas price i don't remember what it's called if you call either of those functions it won't execute your transaction but it will basically tell you what it costs to execute your transaction you can display that to your users but that would be one layer up from solidity that would be up from yeah in the in the um the javascript library that you're using so we're here where are we here so inventory um and we're going to say we in solidity we have to give it the um we have to give it the um uh variable type first uint 256 is very common um it's this is a massive number two to the 256 bits but this is like the base you know you think about uh 32-bit computers or 64-bit computers the ethereum virtual machine is a 256-bit computer and for efficiency's sake we usually work in 256 bits even though um you know you think well if i don't need such a big number i can use a smaller one um but but that's the kind of the state of the compiler uh at this point the un256 uh inventory and uh so this is an array of uint 256s and um i'm going to say let's say we're going to have a function called mint and i'm going to mint an nft let's say oh we'll just call it mint function mint uh public and uh there we go and then when we call mint uh what we're going to do is we're going to say um array of of well this doesn't make much sense right i'm just storing numbers here so wait a minute what we actually want to store is we want to be able to store things like um uh struct nft one will store things like a name for nft uh we want to be able to store um an id uh token id let's say uint 256 token id or we'll just say uh id of my nft and maybe we want to store um um well let's keep it really simple for now let's just do name let's just do name and id can you store images from beowulf yes you can but it's going to be very very expensive so you typically don't right at least on the ethereum blockchain if you want to store if you want to store images or you want to reference images generally what people do is store the url which is a string and cheaper uh if you want to store a url let's say i don't know 40 characters and and all the associated logic you do that as part of an nft on the ethereum in that blockchain it's going to cost you about 40 which is the going rate uh in gas at the moment obviously on something like polygon would be fractions of a penny or finance smart chain it'll be you know a few cents um but that's that is one strategy and then reference your image either in a centralized website or a decentralized service like ipfs into interplanetary file system which is also immutable it's sort of like a combination of ipfs is like a combination of bittorrent and blockchain if you will the other option is to generate the image and this is a relatively new technique but the the the way to do it is essentially to generate vector graphic data in the form of svg uh svg data directly on the blockchain and then return that at a function and you'll see that in some cases actually i think uniswap v3 is doing that um there's a number of different um what was it loot the loot project is doing that in their um uh in their uh um in their nft right so if we come in here and so this is by the way this is i'm going too quickly this is ether scan it's a block explorer you can look at what's on the blockchain including for smart contracts that are verified on etherscan you could look at their source code so if we i'm just going to control f and search for svg here you can see that it's actually creating an svg inside of the smart contract and then returning it and they're using some techniques here with these built-in functions for for uh packing uh and so the images that get returned these images are actually svg images and uh where are we here so what's a what's a token uri uh so this is this is this is a reasonable strategy but you are still limited by size but you can you can actually do something decent here or reasonably here so token uri um i don't know token number one uh it's going to return uh this so it's actually um it has actually base64 encoded it and it's returning it as a data uri so i think i don't know if this is going to work or not uh if i just paste it into a new browser window here uh this site can't be reached uh i think i'm missing a um i think i might be missing a um either a comma there we go uh so actually sorry this is not the image here uh this is the json so actually it's returning the json and then it's also put the image into the json very slick actually if i paste this in you'll see now this is generated directly on the blockchain right this svg data pretty cool eh um [Music] yeah did so a question from from max andrew did obviously making 256 was bad um yes he did uh he did perhaps it should have been 64-bit with an arbitrary size big in feature because 64-bit is more space efficient more a standard dev experience or both other times that 256 makes more sense um you know ethereum was an experiment i mean it kind of still is an experiment although now it's really in production um and you know there's a lot of things when you're dealing with cryptography and public and private keys where 256 bits especially with elliptic curve cryptography is a good place to start and to make things easy i think that's why they chose 256 bits but it is a massive massive number um normal computers now don't support it although they probably natively although they probably will someday um so yeah i mean i think it made a lot of sense at the time but yes i think vitalik did write either on twitter or in an article at some point that maybe they should have used a smaller uh smaller uh smaller bit size okay so back to our so we're not we're we're not quite building loot yet we're building our simple uh nft which isn't even going to be yet compatible with the standard uh so here we go so nft name and id uh and uh in fact um um okay so inventory so not you in 5256 we're going to make this an array of nfts and when we mint uh what we're going to do is um uh we are going to simply say um uh where are we here so of type nft and it's going to be in memory that's where it's location it can be a few different places but uh memory or storage but we're gonna start it off in memory and then and then store it to also qualifier we almost always want to make our state variables public because again all of our data on the blockchain is public anyway we may as well make our debugging experience easier there can be reasons to make things private from from also from a usability perspective but from an efficiency perspective but for now we're going to make this variable public so again we've designed we defined a type here for nft we defined our inventory and now we're defining a mint function so nft um memory nft equals nft uh type open squiggly brackets and then we're going to say string is our name and id whoops sorry not string name is our name and uh id is our id and there we go so uh one thing that i like to do is probably a lot of programmers do is let's see if we can compile this and what errors do we get undefined uh identifier uh name uh undeclared identifier name the underscore name and uh if i make this a little bit bigger you see that it's it's gonna kindly highlight uh maybe maybe i can't make it big enough um okay it's not going to do that whoops lost our side window there we go uh but it's it's underline underlining this because of course i have to pass it in it's a string call data um name and do we want to pass in an id well why don't we just auto generate it why don't we just take the length um id whoops [Music] um uh id i'll tell you what i'm doing in a second here so u and 256 id equals uh inventory dot length plus one uh yes plus one why not and um there we go so actually uh we're just going to make it inventory.length there we go equals id and then let's try to compile again uh unused local variable nft well of course we haven't done anything with it so uh that's a warning these are actually all warnings function uh state immutability converted to view so i'm not actually storing anything here i'm just doing operations in memory so it says well don't just call it public so that somebody will pay gas for it make it a view function right and if i'm not even interacting with uh if i'm not retrieving any data off the blockchain i could even make it pure so these are all function qualifiers that they go there but i do actually want to interact so what i'm going to do is i'm going to say inventory.push nft so i'm going to append to my inventory and then compile hey there we go all right let's go deploy deploy i'm going to delete my previous one here so i'm not confused deployer contract it succeeded i get the green check box in the lower right mint let's mint an nft uh what are we going to call it of course it's going to be hello world um i can expand this as well and i can see the variables broken out here why did i use underscores nobody asked this question yet but i'll answer it why did i use underscores um it's just by convention and and the convention is highly inconsistent but often when i'm creating setter or getter methods for example if i had like uh you know uh uh contract may or i don't know what's what's a good one here like owner method here address uh public owner and if i want to update this like set owner get owner i will pass in the the value like i can't i can't pass it i can't call my parameter owner because it's going to be overwritten or it's going to override in terms of the visibility my public state variable whether i'm trying to set so by convention we do we do this here okay anyway sorry back over here mint hello world uh did the transaction succeed yes it did awesome uh okay so i have orange and blue buttons here orange means that i am um sending transactions into the blockchain and actually as you can see here my account um is is losing a little bit of ether every time and fake fake ether um because i'm sending transactions to the blockchain blue buttons mean that i can call a function right you say why am i calling a function called inventory well what the solidity compiler does is it automatically creates uh getter functions for any of your public state variables of which inventory is and it knows it's an array of nfts and arrays are indexed by numbers you in 256. so if i put in 0 here and push the blue button i'm going to get back my struct name hello world id 0. hey we've minted an nft this is extremely exciting uh yeah okay just answered gabriel's question about whether to use underscore before variable ah before variable or not before a variable uh i should also add is typical for um parameters getting passed in underscore after variable you may see four parameters uh that are return values um and yeah uh you're right not not super not super consistent but who owns this nft well we all own it uh because there's no there's no owner associated with it but maybe we do want to have an owner associated with it so let's add address here uh owner of the nft and um this will be the the current uh owner of it so uh where are we here um uh okay so who's going to be the owner well rather than pass in an owner why don't we just say that whoever created it uh is the owner and we do that by um using message.sender and message refers to you see this turned into blue here message refers to the current transaction there's other ones like i could say you know created at uh whoops i created that type goes before you and 256. you created that um created at and block.timestamp block.timestamp actually refers to the previous timestamp um but um but yeah there we go so let's try this again we're going to go a little bit faster this time and in fact i'm going to turn on auto compile green checkbox good to go delete our old contract which we did deploy and then we're going to mint um to say hi and let's take a look at token id 0 and you can see string so there's hi right id 0 the owner is me again message.sender and the block timestamp was the timestamp of the the previous block um so so close enough uh at least on the problem mainnet theory where blocks are constantly getting generated but close enough to the current the current time what if we want to explicitly uh return some some data from a function so maybe i want to say um maybe i want to say what is the how many how many nfts does a given owner have well i'm actually going to need to store a little bit more data uh so where are we here we are going to do uint 256 mapping so mapping is a hash map extremely useful we're going to do it looks like this you can even nest them i could do mapping mapping you know uin 256 to like you and 256 if i wanted but we're just going to do mapping address to you in 256. and balances we're going to call it public and this is going to be i like to comment it here so owner to quantity or balance right and in fact we're going to turn off auto compile because it's just like popping up the messages there at the bottom which we don't need um another question in the chat um can an nft create another nft programmatically yes absolutely contracts can deploy other contracts absolutely and and that that pattern like the factory pattern is fairly common um but what you have to remember is every transaction has to be initiated from outside so if you want to do something on a regular schedule in the blockchain or you know any kind of any kind of automation the initiator of that transaction always has to be from outside of the blockchain um so it's not like it could never be let's say sentient at this point at least uh if you want to think of it like that but yes contracts can deploy other contracts so balances so what we're going to do here is we're going to say when we mint an nft we're going to do balances uh message.sender uh plus plus and um and there we go i also wanted to introduce another um concept here called uh events which are critical so event transfer um let's say uh address address from um address two and um id token id token id uh un-256 doing 256. um remember when we talked about the blockchain and ethereum blockchain being eventually consistent uh what that means is that um uh you don't know when your your your little unit of computation right your transaction is going to run you submit it to the blockchain and it could it could run now it could run in 10 minutes or 10 hours or never right likely you've submitted it if the blockchain is not so busy and you've given it a high enough gas price uh and it's and the the the function succeeds it should complete within you know seconds to minutes um but you you don't have any way of understanding uh when when that has actually happened uh other than polling is one option or um essentially this is almost like a callback or a web hook it's not a web book but it's like a callback is what events are right so when something happens on the blockchain the event gets issued and i my external code can be listening to it this is the recommended programming paradigm for the blockchain do something on the blockchain emit an event and then take and then listen for that and then take further action it is just not efficient to do anything else maybe in really small trivial cases but for example if i have not just one but if i have 10 000 nfts with 10 000 different owners and i want to have a table on my web page that is displaying all of them it's completely inefficient for me to every block go and pull 10 000 balances i'm much better to essentially receive callbacks or web hooks for these events uh from the blockchain and and all the libraries that you're used to programming with whether it's um you know web3js or ethers ijs or our own multibass give the ability to essentially listen for these events so we're going to do that here we're going to say emit transfer and we're going to do address 0 because we're minting it came from came from nowhere message.sender and the token id id all right let's try compiling this again did it work did i think right yep there we go delete the current one deploy contracts um so we can mint now hi and um we can do inventory uh and in fact if we expand this we'll see our event uh this is in a place called logs so from address zero to our address token id zero uh inventory zero there we go there's our inventory if we take our owner we can also copy it from the top here which is handy paste into balances uh and and balance of one okay um just looking through the questions um can you recommend a good resource for going deeper on best practice for variable and function visibility i would say that the solidity docs are are helpful soliditylang.org and then go to docs pick your version because they've changed like the key those keywords probably private peer etc have changed now but let's say version latest or or pick a version here uh uh tom i would say that's that's the um that's the best keep in mind everything on the blockchain is public especially in a hackathon it doesn't matter really but um uh just because something's set to private it's more about um to use some of what you've written up the paradigm or the structure that you're trying to create rather than whether it's somebody could read it or not is there a way to have breakpoint and live debugger yes there is absolutely so what i can do actually is i can come in here and click debug and uh i can be debugging and this is the integrated debugger it's a little flaky it's kind of the best that we have uh you'll see that i'm scrolling through the op codes here so slow dupe one swap one etc etc i can set break points as well i've just set a breakpoint there uh and theoretically go to the next one the last time i did this it hung my browser so i'm not going to try the other option is if you use something like um hard hat they have console.log so i'm not i can't show it to you at the moment because we're just working in the browser but you can essentially if i do like if you google hard hat console.log um there's basically a way to like printf inside of your inside of your smart contract functions uh during debugging only super handy if you want to store sensitive information uh would it be okay to store private mapping for example with my passport id no do not put any private information on the blockchain let me repeat that do not put any information on the blockchain that you do not expect to be completely public it is there forever what you do instead is you store a non-identifiable uh reference like an id number or a guide on the blockchain and then you store any private information off-chain yes can you encrypt it and put it on the blockchain yes you can you've got to be super careful about that as well um it is possible but you know as we know we all have to be you know cautious about about encryption can i talk a little bit more about the mapping um yeah thanks gabriel sorry i'm scrolling down uh i could use i could use memory for for the um why did i use call date instead of memory um there is a technical reason i don't remember what it is i could just as easily put memory in here and that would be fine as well um so that's something i'll probably uh take offline premium discord um yeah you could encrypt data map hash table thanks for helping out chat really appreciate it uh wonderful uh but yeah the thing to remember about arrays and mappings in solidity is they don't have a maximum size as long as you're willing to pay the gas fee they can grow forever and for example it's or theoretically right the the size the index size on an array is uh you and 256 so two to the 256 of just you know more than the number of atoms in the planet earth uh number of elements in a a uh in an array so you're never gonna run of space um yeah there we go we are coming up on time i can run we started a couple minutes late so i'll run just a couple minutes over maybe to show you a few other things um so mint um let's say for example um i have balances here but we haven't we haven't shown uh how to return a value so function get uh get balances um get balance of or we'll just call it balance balance of uh which is actually erc20 uh standard so we're gonna do address um owner underscore by convention uh public view so this won't this will show up as a blue function here on the left it won't cost us anything to run and we're just gonna do return um uh balances of owner not particularly useful function because we already have a public state variable but let's say we made this private here where's my balances private um all right so let's try to compile again file solidity 101 different number of arguments in return statement there we go public view returns open and close bracket i can return multiple values here as well unto 566 compiles there we go to the blockchain deploy uh deployed contracts mint hi uh balance of right we had balances before now we have balance of and um uh copy my contract here and there we go balance of one um yeah if you're running a space of a mapping you're just you're just using the storage capabilities the blockchain yes absolutely definitely uh be efficient as possible with uh with storage um so what are the options for updating contracts on the blockchain there's a few different options you can never go back well actually you can there's a function called self-destruct uh where you can if you call self-destruct i don't know if this this will work function uh function uh destruct uh public um if you call self-destruct um it will actually delete the uh it will actually delete the uh the contract off the blockchain um given one it's it's wants um uh it wants somewhere to send that ether in the contract um invalid type for argument and function call from address to address payable i might not get this i might not get this without google and we're running out of time now there we go it worked um so you can always delete a contract and then it's gone from the blockchain for from that point uh in the future um that doesn't really help you though um but it can be part of potentially part of another pattern which is basically just deploying a new contract and pointing people at that typically you actually don't self-destruct your previous contracts you simply deploy new ones and point people to that in the past uh people just published new addresses of contracts now there's another way uh using what's called the proxy pattern and some low level assembly to essentially have like a kind of like a doorway or a proxy contract which is able to dynamically reroute any kind of smart contract function call to another contract the good thing about this is it makes your smart contracts upgradable the challenging thing is you have to code your smart contracts in a very particular way to make it work if you want to try this and i don't recommend this as a hackathon thing unless you're trying to learn or you know you you uh it's like critical to kind of what you're doing um but you should look at the open zeppelin uh docs around uh uh their proxy upgrade plug-in which takes care of a lot of the the challenging pieces for you right so here's kind of that that you know model of what i was just uh speaking about the other reason to not do this is that sort of violet it doesn't violate the the the kind of um promise that you made to your users that things are going to be immutable but um uh you have to be very clear about that right because if you're able to change the logic of your contract while the storage stays the same you know i could do hey hey like okay upgrade my function and now my you know returning balance of like times four i've got four times as many nfts as i did in the past right so that's that's something else to consider when thinking about smart contract upgrades um [Music] yeah thank you thank you carlos yep uh appreciate you jumping in there as well um so let's say let's see actually let me try this i'm curious if this is gonna work i i don't think i've ever um see compile work yep uh delete deploy um here we go here um mint hi we've minted it uh inventory zero there's our high contract destruct um that seemed to work so now let's try calling um you know inventory zero and uh we get basically no data back right because the contract's been self-destructed um so yeah one maybe one last function and then then we'll wrap things up let's let's implement a transfer function so uh we're gonna say two uh address two and then uh token id whoops you in 256. um so the one the one last thing we talked about security right the required keyword is basically like an assertion which means that you are uh it's a boolean statement followed by a reason which can get ri which will get returned um so message sender is not owner and the logic is require that um uh what did i call it inventory right inventory id uh inventory whoops unscore token id inventory token id dot uh owner equals message.sender so again anybody can read anything that's on the blockchain anybody can call your smart contract but the logic can implement access control and that's how you have to do it then what i can do is i can say inventory um id dot owner equals two i can i also have to do uh balances message dot sender minus minus balances uh two plus plus and i'm going to omit my event my transfer event uh where are we here transfer from message.sender and then to oops token id view auto complete all right let's try compiling file solidity no visibility of course it's got to be public public there we go and delete the old version deploy the new one mint um hello world hello world okay so now uh my address here uh my balance is one my inventory the inventory for token id 0 i'm the owner here let me try let me pick another account to work from and let me try transferring token id 0 to myself right so one parameter comma the other parameter um and i expand that i can see i can fill them in here transact transfer and uh here we go the transaction has been reverted it was not successful message sender is not owner message sender is not owner that's how you do access control on the blockchain let's try this in fact where uh i am going to transfer to the second one so i am going to be the owner i'm going to call transfer again and it succeeded and now if i look at inventory you can see the owner has changed my balance of has gone from uh one to zero and the balance of the new uh one whoops the new one uh has gone from zero to one there we go okay um well listen thank you everyone um if there's no final questions uh i think we're gonna wrap things up appreciate you all joining uh today uh this has been wonderful i think um uh the it's it's being broadcast to youtube and we'll be there if you want to check it out afterwards or direct your your friends to it um i'm available on discord uh in the tech uh mentors and debugging channel um you can find me there um so thank you again and have a have a wonderful day all right bye everyone thanks jeff 