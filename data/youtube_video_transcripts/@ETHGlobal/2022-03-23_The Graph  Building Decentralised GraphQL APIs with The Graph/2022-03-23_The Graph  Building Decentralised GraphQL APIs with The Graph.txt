great and we're live so here i have wishwe here from the graph who will be showing you how to build decentralized graphql apis this rush i'll let you take the stage and if you have any questions in the meantime feel free to pop them in the chat and we can take them towards the end thanks all right um hope everyone can see my screen yes okay awesome um let me get started uh hey everyone thank you so much for tuning in i'm super excited to be here at elf grove today and um lovely to be here uh for the workshop today we are going to be learning how to build decentralized graphql apis with the graph um and we will be using the zora nft marketplace protocol to build an nft api but before that let me tell you a bit about myself i am bish i'm a developer relations engineer at the craft foundation and my passion is building deeply engaged developer communities and i invest a lot of my time to help um devs become successful with the frameworks and the tools that they're using but i also enjoy um creating a lot of content writing blog posts um doing workshops and hackathons giving talks at conferences and all the cool stuff um oh yeah your slides thanks okay yeah thank you cool uh so let's talk about the graph well the graph is a web 3 indexing and querying protocol for blockchain networks like ethereum and ipfs and the graph community plays a prominent role in supporting dab developers by making open decentralized data easily accessible with graphql um but in simpler terms as an analogy the graph does for the uh you know for open data on the blockchain what google does for the web so using the graph anyone can build and publish open apis known as subgraphs that make data on the blockchain more accessible to developers so let me go a bit more into this concept of what subgraphs are and what the graph does for our web3 stack with the graphs is the main api layer that sits between your ui and your data layer as you can see in the diagram um so your your ui layer and the data layer which is basically your decentralized data from smart contracts the graph is quickly becoming a default part of your web3 stack and subgraphs with that are now becoming a web3 standard um and we also get the question often about where does the graph come into picture um well we like to say that the graph is the easiest way to query open decentralized data but let me explain how so we live in this data-driven world right and all of our data i mean not all but so much of our data is stored across huge storage networks and blockchains um and the blockchain evidently gets large number of transactions per day even hundreds and thousands um or a couple thousands of transactions um and so the applications that we're building they obviously need data that is organized the data that is indexed well um so that we can build high performing applications and applications that have great ui ux um but with so much uh data that the blockchains get these decentralized storage getting so much data and so many number of transactions happening per day it is becoming increasingly difficult to index this data for the sake of our applications that we're building and query that data on our front end so as a solution developers are building they were currently building um proprietary indexing servers and writing these servers would have some overhead so this is where the graph comes in um writing the problem with the proprietary indexing servers is that there is a single point of failure that's the first the second thing is that it obviously needs engineering and hardware resources if you're going to build out um a custom indexing server right to be indexing that blockchain data and of course lastly it disrupts the core idea of decentralization so there's a single point of failure lots and lots of input to manage and costs involved with that and obviously it is centralized which disrupts the idea of decentralization at the core and so this is where the graph enters um it's a global open graphql api uh which is why we say that it's the easiest way to index and query your blockchain data efficiently so no need to build out your own indexing server um anymore uh the graph does that for you by building subgraph apis that can index and query your data from the blockchain um and it has also built a transparent and open network of everyone of all of the builders um who are building these subgraphs people who are consuming these subgraphs for their decentralized applications people who are curating on these subgraphs by signaling on them and stuff like that so there is a transparent and open network of builders and consumers that are using the graph which obviously helps a lot with collaboration um and this this entire network is uh decentralized and robust and the graph is also built uh built on top of graphql which comes with its own benefits um of developer experience but that's not in the scope of this workshop so we leave out the benefits of graphql but if you want to learn a bit more about graphql um there are a bunch of cool resources that i'd love to share with you um some of them off the top of my head are how to graph ql uh it's a it's a cool platform with free resources you can also go check out eve purcello's crack your resources she has a bunch of really cool workshops uh she also has a book that she's written on graphql um and i'd love to love to share more of these resources with you so if you're on the hackathon discord server please make sure that you come say hi on our graph internal sponsor sorry the graph sponsor channel and i would love to share them with you um so yeah a global api for use cases that include but aren't limited to things like nft marketplaces galleries and metaverses music and video social and communication platforms and so much more so you can use the graph um build out subgrams for use cases like these and not just that the graph is also powering decentralized finance defined apps are querying on chain data using the graph like trades and exchange volumes total borrowed supplied and staked asset prices pollen balance wallet balances total value logged and so much more and all of these cute little um logos that you can see are some of the best d5 projects out there that are using the graph um powered by the graph also we have some of the most complex applications running out there that allow for richer data on dapps and which are powered by the graph so if you know websites like coin gecko or coin market cap the these are using the graph in production um and when it comes to nfts and dows you might have heard about foundation which is um which gives nft marketplace data um and that and it uses the graph for that and there's also juicebox tao and some of the most famous d5 projects like uniswap and synthetics they're also using the graph and um the graphs hosted service now supports over 25 networks um supporting creators across 25 networks like ethereum near polygon arbitrary optimism and so much more um and last but not the least let's talk about bounties so in this hackathon if you will be building using the graph or if you'd like to um you know test out the subgraph studio for yourself subgraph studio space basically this developer environment that you will be using to build out a subgraph um then uh you can you might as well submit that project of yours and use built in this hackathon to our bounties um we are offering a total of 3 500 in bounties by the graph um so 1500 die will be going to the first prize for the best use of an existing subgraph so um if you're there are two ways to use subgraphs you can either use an existing subgraph sorry there are two ways of using on-chain data you can index and query that onto your data either by using an existing subgraph that is on the subgraph explorer the graph explorer or you can create your custom subgraph to index and um query that on chain data through a smart contract so we have two categories for that the first one is best use of an existing subgraph and 1500 will um 1500 dive will be going to that team um or individual and two thousand died to the best new subgraph so that 2000 die is further divided into two prices the first price and the runners-up um so 1500 died to the best news upgraph first price and 500 to the runnersup um so yeah super excited to see what you folks build and my team will be in the grass sponsor channel if you have any questions but i'm sure you'll have more of them once we jump right into the demo so that was all about what the graph is what it does um the graph network in the community the ecosystem what subgraphs are but i have a demo for you um so let me get started with that um i think i'm not sharing the entire desktop so let me quickly do that and we can go right to the subgraph studio cool um i hope everyone can see my screen i what i have right now is um this really nifty guide that we put together at the graph for everyone who wants to get started by building their first subgraph using the subgraph studio um so this let me actually drop this into the chat for everyone if anyone wants to follow along or maybe come back to it later after this workshop but there are two basic prerequisites if you want to follow along the first one is um you should have node.js installed on your machine and the second one is having a meta mask wallet um metamask followed if some of you might already know it's a crypto wallet that you can use to manage all of your crypto assets um and um you can use that to sign into the subgraph studio so as you can see here um if i can yeah this is the subgrass studio that you can go to by going to the graph.com slash studio um and this is the developer environment that you can use to build sub graphs so i have already signed in using my wallet but this is something that you can do um as the first step of getting started with the subgraph studio if you have a metamask wallet extension um in in your browser um like chrome you can use that easily to sign into your subgraph studio by entering by connecting your metamask wallet while signing in and signing a message there's a button that says sign message when you log in and that should do it for you um so as you can see here this is basically my identity on my subgraph studio i have shared my connected my public wallet here um and that's basically my user info and it creates a dashboard for me um and it's basically like entering my email id um but instead you're using your sub uh your wallet to sign into your subgraph studio and that will um it will create a dashboard for you where all of your api keys will be managed your you can see your subgraphs that you've either created or deployed or published and some of the documentation that you will need and all the cool stuff like that so let's go ahead with the first step and get started by creating our first sub graph so i'm just going to call it um for the sake of this workshop and um select ethereum mainnet which is the network that we'll be using click on continue and what this is going to do is it's going to create a sub graph on the subgraph studio so no code done at the moment nothing at all all you're doing is creating your subgraph on the subgraph studio and what that's going to do is show you a status which is currently undeployed and the subgraph slug which is basically the name of the subgraph that we will be using in cli commands um and a deploy key the deploy key you can see it basically as a key um an api key that you can use as a better token if you're use um using that token to connect it to your front end to query that graphql api that we're going to build or you can also use this deploy key while you're authenticating your subgraph so um as you can see here uh there are a bunch of things um related to documentation uh that you can that is provided to you when you create your first subgraph and this is specific to the subgraph that you created so it will already have all of your dip you know your information related to your subgraph like your subgraph slug and your deploy key which is something that i find super helpful so if um someone is just getting started they don't need to really um you know go into the documentation and look for commands and then paste or or type in their subgraph or the deploy gear or anything all they have to do is create a subgraph and copy this command and that should work out for them so you don't have to memorize your commands if you're just getting started with your first one so building a subgraph can be seen um as categorized into three different parts the first one is something that you only do once which is installing your graph cli so if this is your first time building a subgraph with the graph then um you install the graph cli using either npm or yarn i have already installed it on my local machine and how you can do it easily on yours is if you have um node.js already installed then you should be able to paste this npm command in your terminal or in your developer environment and that should install the graph cli for you so the graph cli is um a cli which is built out by the graph team uh the graph protocol and it gives a bunch of utility commands really cool commands that you can use um to build a subgraph right from your developer environment and a great example of that is the graph init command which is the second section of building a subgraph so you initialize your subgraph and then you write your own subgraph you design it based on your needs so the kind of subgraph that we are going to build is um an nft api and that nft api is going to be used to index and query data from the zora nft marketplace if i can take you to that this is the zora nfd marketplace and um it also has a really cool smart contract um for people who want to use it as a building block um to build um build out nice uh and interesting nft projects um so if you go to the developer documentation you should find out all about that and i'm i believe they also have a new version of their uh zura um developer tools and their smart contracts um so you can check out that documentation later um but that was just to give you a quick gist of what kind of subgraph we're going to build and you should be able to initialize that sub graph using the graph init command and i will go more into it later when i actually run that command but the last section is authenticating and deploying your subgraph so once you're done initializing and designing your subgraph um all you need to do is authenticate your subgraph using the graph auth command and entering your deploy key which is already given to you here um on your subgraph dashboard so you will have to copy it paste it um in your terminal and you should be good to go and then the last part would be to deploy your subgraph um and then it will start syncing here the status will turn into deployed from undeployed and um a cool and nifty thing about the subgraph studio is once you've deployed it you can also test out your subgraph by using the playground but that is something that we will be able to do once we deploy it so let's go ahead and get started um i actually i'm gonna follow along this guide so that i can give you a proper look into what we're building and how we're building and all the steps in the same order the first thing um is installing the cli that's something that i've already done so let me go ahead and copy the graph init command this one is slightly different from the command that you see here on your subgraph dashboard but i'll quickly tell you why that is so if you press enter here it's gonna initialize a subgraph for you um so i'm on desktop right now and it's gonna once this command is executed it is gonna initialize a subgraph repository or a subgraph folder where all of our project and um our code files will be situated so um let me explain what this graph initialize command does init command does so the graph init command has a bunch of um flags like the contract name index event studio and from contract flags so each flag has a purpose the from contract flag that you see here lets you enter the smart contract address that you will be using in our case we're going to be using the zora nft smart contract so we get this from the developer documentation of zora that that i um you know showed you earlier and um so that is basically the address of the smart contract that you will be using for the subgraph um and then there is the index events um flag so this is the flag that lets you that gives you all of the code boilerplate code that you will be needing to handle these events that are emitted from the subgraph um so super again super nifty flag right here um that if you pass into your graph init command it should be really helpful to you in scaffolding your subgraph so you don't really have to write all of the boilerplate code um by yourself the the studio flag that you see here is basically just to tell the graph in it command that we will be using the subgraph studio to be creating our subgraph and the last one is the contract name flag which lets you pass the name of the contract that we you will be using in our case this is the token contract in the zora nfd smart contract that we're using so when you run this command it's going to ask you for a few details and you all you can do is go ahead and accept all of the defaults here i'm going to accept ethereum as the protocol um pass lfgrow as the subgraph slug because that's the name of our subgraph it's going to be different for everyone so you can go ahead and choose yours um accept default here again use mainnet as the network but you can accept any of it um accept default here as the contract address so it's going to fetch apis from etherscan accept the default here as token so as you can see here what this is doing um if everyone can see more clearly it's creating um a subgraph scaffold what this means is this graph init command is initializing your subgraph with some basic boilerplate code depending on the flags and information that we passed early on so it's all independ uh installing all of the dependencies it's initializing the subgraph i'm generating the apis and yeah here it is we're good to go so if you see on your desktop uh you should be able to find the subgraph repository initialized so i'm gonna go ahead and open my subgraph repository um and it should be on desktop lf chrome open it open terminal so let me give you a quick look into the files that we have here that have been scaffolded for us using the graph ended command and the ones that we will be using to edit and basically design our subgraph so there are three main um files that we're going to touch for the scope of this workshop and all you have to do is make some few edits there and you're good to go the first one is the subraft.yaml file the second one is the schema.graphql file and the third one is in source directory called the mappings.ts file so in the subtract.yaml file this is basically the configuration file that's going to define your subgraph configuration so your spec version the schema file that it's going to be using um all of the data sources that it's going to be using to query data from or index data from so you will define your data source this is ethereum the token name the contract name is token network name is mainnet and then you also define the actual source of the data which is the address of your smart contract um etc and it also has a few fields like entities and event handlers so these are the ones that we will be editing but let me before that let me also quickly introduce you to some of the other files that we will be using the second one is the schema.graphql file and we already have a few entities defined for us here but we're going to get rid of those and define all of our new entities what basically we're doing in the schema.graphql file is defining the data that we want our subgraph to query from our index from um the smart contract so for example if i'm defining token and user data as entities in my schema.graphql file then what this means is that my front end should be able to use my subgraph to define those two entities and their subsequent fields that kind of data from the smart contract so first of all it's going to index the smart contract to get that data and then i um should be able to use my sub graph to query that data and serve it to my client or serve it on my front end and last but not the least the mappings mapping.ts file um not to make things super complex here and to keep things simple basically the mapping.ts file is a typescript file that you will be using to define your event handlers and what this does is every smart contract has a few events that it emits when you start indexing it and these events can be any of the things that are happening while you index it could be something like a transfer event or a token uri updated event when the you token uri has been updated um stuff like that so what you want to do is you want to map the local the business logic that you wrote locally on your machine to the events that are happening on the smart contract so that when the events are emitted you have some business logic that is uh that runs when your subgraph is the uh subgraph is querying the data the on-chain data right um and all of that code all of that business logic we're gonna be writing in the mapping.ts file um yeah so i think we're good to go ahead and start designing our subgraph so the first thing that we're gonna do is um you know update our subgraph.yaml file by making a few changes the first one is writing a start block so why we define a start block is that if you don't define a start block for a smart contract it's gonna index from the genesis block and if we know a start block for that smart contract then it's gonna start from that particular transaction or that particular start block and for us um we've already put um the start block for our our um purpose here uh for the zora nifty smart contract uh in this guide and we've done so using etherscan but you can do that yourself by searching for the last transaction by using the smart contract address on ether scan so i'm going to enter this card block here so that it doesn't start indexing from the genesis block but instead it will use this as the first block to index the second thing that we're gonna update is the entities so as i said the entities are basically the things that you want your the data that you want your subgraph to serve or to query and i'm going to define token and user as the two entities um that we want our subgraph to have or to serve when it's indexing and querying the smart contract and we'll get more into it later on um but basically we define these entities here in this schema.graphql file and lastly um we have been given some events and some handlers um using the index event flag that we ran in the graph init command if you remember um but be for the sake of simplicity for this workshop we're only going to be using um the last two to keep it simple which is the token uri updated event and the transfer event um the token uri updated event is an event that happens when a user updates the uri of um an nft or a token um and we want to write a handler for that event um to handle that event using some business logic or some code um here in this mapping.ts file which is why we define it as an event handler in the subtract.yaml file and the second one is a transfer event that happens on the smart contract when first either an nft a new nft is being minted a new token is being minted or an existing token the ownership of an existing token is being transferred from one point to another one user to another so of course we'll also write an event handler um function for this event as well so yeah those are the two events that we will be dealing with for the sake of this workshop um quickly let me save this and let me go ahead and um define our entities so i'm gonna copy this code because i know that we're running a bit over time um and quickly to explain what these two entities does is it's gonna define um a type token and a few fields that the token will have so all of the nft data or the token data that we want our subtract to query we're defining it here as an entity and the second is um a user entity just like the token entity um and what we're doing here is we also want the user data along with the token data right so we are creating an entity here in the schema.graphql file so i'm going to go ahead and save that as well the last thing that we need to do here is write the mappings but before that we are going to run the graph code command and what this command does is let me go ahead and run it first so while it happens okay cool it ran successfully so the graph cogen command basically what it does is um it generates um a bunch of really cool um libraries and functions and boilerplate code for us um and how that happens is that um the graph cli gives us a typescript library that we can use um to be able to write our mappings um here and so once we run the graph code gen command we're going to go ahead and write the mappings here or the event handlers here um get rid of this and then save this cool so just to quickly explain what kind of code we're dealing with and what we're doing here the graph coding command as i said it um generates the boilerplate code that we need to be able to write these functions um it gives us a typescript library so that we can use some helper functions here from generated um file the token file and generated and the schema file in generated so basically what the token file does is it has all the code that we need to be able to interact with the smart contract itself so to read data from it and the schema file has all the code that we need to write functions that can interact with our graph node so we can either read data from it or we can write data to the graph name onto the graph node and store data there so these two event handlers or handler functions that we've written here are basically for the transfer event and the token uri updated event so once the token uh uri updated event uh yeah that event is being emitted it happens this function uh in our subgraph will be run um as business logic and um it will get the updated token uri and save it to the graph node and display it when we query it and in the transfer event it's gonna first check this if block checks whether a new nfd is being minted if it is being minted then it gets all of the details of the nfts and it stores it on the graph node gets the new owner of that um token and then saves it to the graph node and if um no new nft is being minted but only the user um is being the ownership is being transferred then only this part will be executed and then similarly in case of a new user a new user will be created and saved onto the graph node but if not then it will only run this part of the function so that is all that we needed to do to design our subgraph the code that we've written so far should be able to help us deploy a subgraph that will index and query data from the zora nfd smart contract so let's go ahead and actually i'm gonna just to show you how this works i'm gonna copy this code uh this command which is the graph auth command that we will run as the next step the graph auth um command has a studio flag and then passing the deploy key will help us authenticate the subgraph what this does is this local code that you wrote on your local machine will be connected using the graph auth um command uh to your graph studio to the subgraph that you created on your studio so that command has been run successfully and the final one is the graph deploy command which is the graph deploy studio electro command and once you do that it's going to ask you for a version label just write something like 0.1 as the first version it's going to deploy our sub graph and once the build is complete it's going to deploy to the graph node and voila the sub subgraph is now deployed so if you check it has been synced hundred percent the status has been changed from undeployed to deployed and we have our subgraph so to test it out super quick um we go to our playground and we actually should have a sample query here because we have our token data and our user data um [Music] interesting refresh super quick but you should be able to test out um a few oh there it is so a sample query uh here to query the first five um tokens and users so the tokens their id token id content uri and similarly for users all of the user data um for the first five tokens and users will be queried once we run this query and we should get yeah here is the data that we get so if you use this let me actually pause share because i'm not sure if this is going to be safe to you know say for work or not but if we use this yep yeah so this is the nft i wish it was a beautiful um art or something but yeah this is the nft that is there on this link but that's just a simple way of you know testing out your queries and just to test out your subgraph whether it's able to query data or not um so quickly before we wrap up that was all about the subgraph workshop and how you can build subgraph subgraphs using the graph to query on chain data from smart contracts um but before we end if you want to join the web 3 movement you should definitely get involved with us you can go to the graph official website at thegraph.com or you can visit our official docs at thecraft.com docs um if you want to follow us and our events and the cool stuff that we do and the product updates you should definitely follow us on twitter and say hi by tweeting at us at graph protocol and our discord is the graph.com discord if you want to seek more support from our team of engineers and our amazing community and also showcase what you are building um and of course i'd love to have uh help answer all of your questions if you have any um and meet with you all in the elf grow discord servers so make sure you come say hi on the graph sponsor channel and that's all for it thank you everyone thanks bishop for the informative session um we can follow up with questions over discord and see everyone there thanks bye 