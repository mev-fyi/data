[Music] [Applause] [Music] then you have some functions uh to let's say uh push money into the vault or uh like the either like deposit or mint deposit is meant for uh so it basically does the same thing but one uh you specify how much underlying amount you want to deposit and the other one you specify how much how much sorry how many shares do you want to get from your deposit and then the kind of the logic takes care of how much underlying to take from your allowance on the erc20 uh withdraw is practically the same so you have withdraw and redeem draw it for your underlying so you say hey i want to withdraw say 10 die or if you hit redeem you say hey i want to redeem i don't know 9 yv die shares which is the volt sure token then you have a lot of utdt or view functions which are here they find us external but we the erc like the vault wrapper or the 4626 use then uses them as well like inside the code so you will probably have to redefine them as public uh variables oh sorry functions uh but yes basically how do you convert shares to assets how like some internal accounting or uh everything is pretty flexible so if you do have well you will see uh as we as we go through but here you can add like specific logic depending on uh what you are wrapping in this case obviously we'll see an example of the v2 volts of yearn and then there are some functions either for user facing or for integration contracts which are okay let's say i want to deposit 100i how many shares would i get so i can check or i want to withdraw i know x or yeah i want to redeem x amount of shares how many underlying or assets would i be getting then i have some kind of functions that set some yeah well here it says limit logic um sometimes you might have a vault that doesn't really want your money uh per se we usually have walls that do not have or have like a big deposit limit but in some cases you want to just limit a vote or certain iteration to a certain amount of money either one because you don't feel comfortable uh holding i know billions or millions of tbl in a single contract because you are not going to effectively use them so they will probably debut the apy for the the users that are already in or uh for any other uh reason you might find uh there is also the same uh kind of functionality but adapted to volt shirts which is max uh amount of mental issues um the same with withdrawal sometimes you might have a ball that let's say it doesn't have the possibility to give the underlying back or does require some other mechanism for you to get your withdrawals let's say in the case of urine we do have some votes that have a big buffer but let's say if you're a really really big whale or you're involved that most of the assets are being utilized in locking strategies you might either one if you're an integrator and you're probably like in the partners program for yarn you probably will ping us and say hey we are planning on withdrawing i know uh 500 million how can we coordinate and we will unwind the strategies for you to be able to get out but if you're a user this can also be uh useful for let's say yeah knowing how much can you withdraw one either without incurring losses because there are some possibilities that when you withdraw if you hit a strategy so if you go out of the buffer that the vote has and you need to go into a strategy that might be a lossy strategy you might incur in some losses will go into this uh over uh and then obviously it's the same function for redeem so basically you have uh just really few functions uh one for each one for sure management one uh for uh underlying management so you will see a lot of like internal accounting but most of these uh yeah should should be like uh yeah quite common for you guys if any of you have been uh working around uh urine or uh yield bearing tokens uh so what we did here what we did here is uh vodropper which is basically a contract on top of a urine v2 volt which is rooted in viper that basically is kind of a proxy for your deposits or withdrawals or for your interaction this contract per se is not on your c20 so it's not it doesn't have a token itself it's just uh routing uh funds in and out both underlying and shares for the depositors and uh let's say if you also want to uh let's say add a fee or whatever it can also root uh fees into another separate contract the idea of this contract is to not hold any value at all so uh we started constructing the contract we yeah right now it's like pretty simple this was hacked quite uh fairly quickly so there might be some incongruencies we checked it and it looked fine but if you guys see anything that's wrong ping me on twitter or whatever we'll open up the source code for this so you can open up issues whenever the repo comes up so since this is one contract right now we have a constructor for the wall this can be also a contract that has a clone functionality so you don't have to deploy the contract again and again and it's a little bit cheaper uh to deploy obviously you might really want to customize uh these wrapper contracts for yourself but if you do customize them and you want to tackle different volts or multiple volts it's also recommended to have some sort of this cloning mechanism to yeah basically not waste that money cash on yeah deploying the same by code over and over again so here we find gold token and decimals these decimals are defined just to avoid having to do one extra call you'll see this in a moment uh we and now here comes the tricky part where we have to comply with all the interfaces required by this new beautiful eip uh so it's quite similar to what we have on vaults v2 but there are some naming and some uh yeah since now we are required to both handle deposits via let's say deposit which takes shares and mint which takes ah sorry which deposit that takes underlying and meat that takes shares we'll have to do some tricks around but yeah so first this is the first sample asset we used to have it as token so for us it's basically the same but this is like an easy way to kind of rename it and then okay into the fun part so deposit here it takes an amount of assets so let's say 100i and a receiver the receiver doesn't necessarily has to be the message sender in the case of you wanted to or and i don't know whatever wanted to deposit for another person but the deposit does take the internal deposit function does take message sender so if we go here uh which is that just uh below the like at the bottom of the contract it's an internal function that takes the depositor so the message sender is our depositor in this case which is the person that we are going to take the tokens from there is no logic obviously to take the let's say for you as a message sender to set a depositor into another uh for another address because obviously you will be kind of training the allowance for another person um so here it's quite simple uh we set some values in memory just to avoid having to re-access the same storage slot over and over again uh if we do have uint 26 max which is like basically try to deposit as much as possible we do check either which is take the minimum amount between the user balance or the allowance the user might have infinite allowance as well but the actual balance might not be obviously infinite even 26 number or the other way around the user might have a ton of balance but only allow the ball to access like specific amount like 100i uh if not we will take the amount that's a pretty fine amount by the user which is might be also correct and if it's not correct either we'll have a robot here trying to transfer from a user that doesn't have allowance etc or that doesn't have the uh actual balance uh so the first thing we do is we drain the uh we drain we pull the funds from the user which is it's yeah from the depositor yeah let's say correct to the the phrasing here from the depositor into the volt wrapper so we are not actually sending this directly into the vault because we we re uh we required to have this font spin the volt wrapper for us to be able to call the deposit function later uh this is a weird one but we need to check uh so you have two options here one you initialize uh when you initialize the word wrapper you set allowance infinite to your vault which i think it's okay uh or uh second which is uh kind of easier but you are just screwing your first depositor is you have your first depositor approve uh like give the max allowance into the into the vault so yeah you probably want to be the first depositor this might not ever run out possibly not sure how it will run out but there is a check for uh if it's not enough you can like re-approve etc but should be okay to take this outside just to uh one save some gas on deposits and secondly to have uh yeah basically more control over the the allowance from the wrapper to the vault um uh here we need to check if the uh volt dropper has some dust in the underlying so we check let's say somebody mistake cleanly oh mistakenly send one die into the wall wrapper instead of doing an allowance and calling deposit uh it will up sorry it will mess up somewhat with the account internal accounting of this function so we check pre post balance in the main one in the middle we call deposits of all deposit should be here uh well deposit though this is in viper but it's it's pretty easily and self-explanatory you can check that as well in the urine volts repo if you want to we check how much tokens we have left so there is a possibility that the deposit doesn't really take all of no actually no the deposit will take all of the amount that you send but this is done just for avoiding to um yeah give give some gas and then if there is anything that might be refundable you send that back to the to the depositor uh here in the wall deposit you set the receiver so this can be either yourself or it can be a third so yourself not the depositor itself or a third party that the depositor choose um let's go back up uh so for me it is practically the same um oh well obviously the deposit function returns both the assets that it used and the new minted shares and it means emits and a deposit event for mint is the same the only difference is that the user specified specifies the numbers of shares for the withdrawal which is a little bit tricky and it really depends on kind of how and in which state you are hitting the vault uh so we have a bunch of different uh kind of scenarios that might happen uh so yeah you as i said the depositor right now or the withdrawal let me check what's the actual name here okay the sender for some reason is the the one that has the vulture tokens so remember this sender doesn't actually so since volt rubber is not on your c20 you are still interacting with the vault as uh and as it being the behaving as the volt api so the that has the deposit we draw all the functions but since also the vault is an erc20 because it it has its own shirt so it does the accounting of its own shirt it behaves like a newer c20 obviously in viper you don't have the open separate near c20 so probably here you have like transfer blah blah so everything is kind of implemented uh internally um uh which i've heard is more gas optimized so shout outs to viper uh and then yeah it's basically kind of similar but the other way around so we do need to calculate how much available shirts does the volts vault has or does the user no sorry does the user has basically to withdraw then we calculate depending on the pps uh of the vote so this is the price per share let's say you enter in a new wall probably the pbs or not probably but the previous would be one if that vote uh through a strategy receives uh profit uh the pps will increase if receives losses the bps will decrease so on and so forth yeah basically some internal accounting which if you really want to go deep into it you can that's pretty straightforward then we take the volt shirt tokens from the sender into this address so because as you remember we need to hold this uh first to be able to interact with the vault and uh differentiation with the deposit function is that the withdrawal function doesn't really need allowance because when you're interacting with the vault the vault uh doesn't really need you to give allowance for its own token to itself because it would be dumb uh so you don't need to to handle that you just hold your token so you can interact with whatever like internal vault functions that you want without giving it allowance and here we also do check uh pre and post balances to one uh okay and here comes kind of the different scenarios so there's a possibility that when you withdraw you might not get all the amount of say underlying that you wished for one because of the offer we talked about maybe you go over that and there are no other withdrawal strategies so we have a something called withdrawal queue where we set the more ec or liquid to withdraw strategies on top those charges also might not have any withdrawal uh liquidity or withdrawal underlying on them so as you go into the queue you might end up without uh fulfilling your full amount obviously if you withdraw less it will be possible to cover up like for you for a moment but if you withdraw a  ton of uh underlying uh might get trickier on the more uh illiquid votes so yeah here we withdraw and so we have to do some checks to know uh either um how many actual shares were burned because obviously if you say hey i want to withdraw a hundred shares and this is also a differentiation between deposit and we draw on both v2 you deposit underlying but when you withdraw you withdraw with your shares uh since in the world wrapper we are accommodating for both withdrawing saying hey i want to withdraw a hundred ion or i want to withdraw 100 or 99 uh vultures we do accommodate for both uh but here the vault v2 might not really need to burn all your shirts because it obviously if it can only give you 50 of the estimated underlying that you are that those shares are sorry are worth depending on the pps so the price per share it will only give you it will only burn uh 50 of your shares obviously because if not we are basically writing everybody so you send the let's say the estimated amount of shares per the amount that you kind of want to get you specify your receiver as well and then this volt withdrawal will return you so what's b2 core will give you how much underline you got for those shares and here this is why we calculate how many shares were burnt and if we do have any unused shirt and use shares steel we do return them to the sender so that's that's practically it then we do have some [Music] obviously the same functionality with redeem so in this case this uh kind of is the more native approach or the the one the approach that is more similar to v2 and this is the weird one which uses assets instead of shares and on deposit is the other way around we usually take assets as deposit and mint is this so this is why you see a different accounting prior to called calling deposit or withdraw then you have some as it says here some accounting logic it's really simple so you really need to know the total assets that the vault really has uh this is just like approximately the call to the same function in v2 uh you need to know uh well we went through the same eip so everything is practically the same here we just accommodate for uh for the decimals and the price pressure etc etc we also have a max deposit function so the limit function that we we talked before which might be useful for one avoiding rewards on the ui uh and secondly and i think it's most important to also let let's say integrators know the exact max amount they need to get so probably you would call max deposit and then deposit that max amount that might be in some cases the max you wind and max sorry unit 256 same for me and same for withdrawals and same for uh reading so yeah so let's go into the more interesting stuff this is kind of boring and an introduction but i think it's good to know um so i think i wrote a to-do here let me check uh okay so yeah on max deposit let's say the eip 4626 kind of lets you do whatever you want inside so if you want to take fees on top of the deposits you you can if you want to limit deposits or to block deposits for certain users etc etc you also can same for withdrawal you can add both fees on deposit on withdrawal you can add fees depending on the amount being deposited or which one or depending on the difference of the pps increase so let's say you don't really want to make your users lose money but you want to take a percentage of their profit so and this might get tricky but you can uh kind of save how much uh kind of relative bps a depositor has and then take a percentage out of it so like a percentage out of their apy increase or pps increase let's say a way to do this i think it should be pretty easy so uh you would define let's say via receiver here that let's say it's c4 address uh uh and obviously this won't compile uh just for a little bit of loss and here on deposit you can uh basically run some percentage of it uh let's say you want to do oh sorry this is a weird computer uh so you get the token you want to do let's say you want to transfer from or yeah okay let's do this on deposit so we we can uh both run deposits uh on uh shares and on underlying um [Music] so here where we are transferring uh let's say we can do something similar let's go base let's say we want to send from to uh well but you know you get the gist so maybe we can do this amount so we get a tiny percent from the user and then we do sorry amount so we update so it's quite uh easy to add different type of fee mechanisms for you to earn on top of what the depositors have obviously is always a good practice to be transparent with your users so if you are doing this like make them know that you're taking a small cut either on withdrawal or on deposit um and then yeah or or if you also want to uh build up some more complex stuff around the pps increase just for you yeah not to have your users lose money on either the positive withdrawal uh yeah that's it no no if you any of you guys have any specific questions that we uh that you might want to to tackle or we will okay awesome thank you guys [Applause] so [Music] [Applause] [Music] you 