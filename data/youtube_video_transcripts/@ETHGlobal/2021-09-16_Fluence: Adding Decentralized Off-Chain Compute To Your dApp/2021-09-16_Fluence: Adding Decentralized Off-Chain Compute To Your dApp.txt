all right stream is up perfect so welcome everyone to the adding decentralized off-chain compute to your dap workshop uh here we have bernard from fluence who's going to be leading it so yeah if you guys have any questions feel free to drop them into the chat and you will get to them as soon as possible but if you guys are not able to get your questions answered or if you have any questions after the workshop feel free to contact him and the fluence team through the sponsor fluence discord channel all right bernard all yours all right thank you very much all right as it's been pointed out my name's bernard i'm uh part of the fluence team and uh thanks for being here and thanks for having me and uh thanks for um being interested in the hackathon it's gonna be awesome time today i wanna do a workshop kind of thing program decentralized compute and ipfs with aqua and the next 10 slides also are basically all about unpacking that that headline so let's dive into it fluence what is fluence fluence is an open permissionless peer-to-peer protocol that's focused on compute aside from the protocol we provide a network and a vast open source tooling uh repository that allows you to uh in our opinion really really take on distributed in particular peer-to-peer programming at uh at a level of uh ergonomics and convenience you probably haven't experienced before and we'll get to that the way things work sort of roughly word eye view is we use web assembly interface types as our highly portable compute modules they execute on what is called the marine runtime which is a general purpose web assembly runtime built on wasma which we have on each network pier and then you from these modules you create services so webassembly modules themselves share nothing and how we build services which are logical constructs we do them by linking those web assembly modules to json file which establishes the uh uh dependencies and now you end up with uh very powerful service constructs that allow you to execute external effects including download upload modify and replicate and uh and interact with other networks or or participants of other networks as well and uh if you look at the right there got to uh peer-to-peer network the the greenish things are sort of i don't know could be clients could be browsers any kind of client iot and then we get a couple of services here and as you can see you can write adapters essentially to interact with the outside of the fluent peer-to-peer network basically bring in your traditional uh web to apis microservices or actually web 3 networks like ipfs and this is where we're really going to focus sort of throughout the workshop and now if you look at this so you get this peer-to-peer network you get a bunch of peers you get a client and you get services that are hosted on node so i guess there is a way to deploy those web ascending modules with a configuration onto these nodes so now you're looking at it it's like so how do you actually program this for most of you not most of you but for those of you who have experience with blockchains which is probably the biggest peer-to-peer i don't know consumer these days you interacted through json rpc or even rest endpoints influence this is not the case and the reason this is not the case is because it's a general purpose environment where pre-specifying uh json rpc endpoints is impossible because you as a developer create those services so the question now is how do you actually harness those services how do you compose them into a application and this is where a special purpose language fluence created it's totally open source everything's mit apache 2 or both to to program distribute networks and uh and services now the interesting part is it doesn't just apply to the fluence network you can actually use aqua to uh to compute and compose services uh not compute just compose services that uh uh include networks outside networks and outside applications and that's actually really powerful and we'll see this how you can use uh custom services in conjunction with ipfs to through aqua which is i mean you'll it's a tin line you'll see it it's it's it's going to be awesome and we believe the ergonomics of aqua are such that it really kind of commoditized peer-to-peer programming in it by itself so what does it look like so it was a lot of talk a lot of how wonderful it is let's put the pedal to the middle here the rubber to the road go right to the bottom this is a very simple example of a hello world service so the assumption here is we have a service already deployed on a node and that service is a greeting service with the function grading so basically that greeting function which we would have written in rust and compiled to bwazi 32 takes two parameters a string and a boolean the string is the name and the boolean is basically whether or not we greet the caller so a boolean of true and the string of joe or if online for example would be high ether online and false on the boolean would be a buy is online so fancy hello world so lines one through two basically show you how to create the interface within aqua this is now this is literal aqua code and uh how that how we can map that to the deployed service through this webassembly modules through what's called the service id the service id is unique as you create a service from those modules you can literally create 10 services from the same modules if you want to on the same node and you get 10 different service ids which has other advantages if you want to do this and then lines four through eight are the actual aqua function this is the composition if you will of that greeting service and that gives gives us a result at the end basically you know the hello or the hi or by whatever the name is and in addition to the name and boolean the name and the greet the string and the boolean we saw in the greeting service uh signature we also have a node and greeting service id parameter the node is the peer id of the of the node or the peer on which the service has been deployed and the greeting service id is the unique id associated with that service which is comprised of reusable webassembly modules so what we're doing now is we're basically saying on this node on this peers specified follow my cursor here we bind this interface this aqui interface to the actual web assembly interface we then use that binding and call the function greeting which is part of that interface with the provided parameters upgrade and name and then we return the result and then that's it this is you just basically harnessed a distributed peer-to-peer service in basically eight lines and if we go back and look at it from a diagram perspective so what you basically did is let's just say you're in a browser and for a browser you need a relay for those of us a little newer two peer-to-peer networks a relay is a publicly accessible peer because not all peers because of that requirements may be publicly accessible but they might be accessible through appear browsers are not directly accessible so they have to go through a relay at all times and so basically what we would have done is we would have called from this pier on the relay and then on the relay it would have determined okay let's just say this is our service our hello service we call this service we execute it there and then we bring back the result which could have gone to the client we initiated with or some other client and if you look at it this basically on the on the little sequence diagram there so we basically we initiate this uh greeting we call it we execute it on that node and then we return the results by the relay back to the client here if you expand that model you'll you'll very quickly realize this leads to a very very different request response model than you usually see in your traditional client server environment your response model is request response back to the client request with that response back to the client and on and on it goes so if you wanted to do a say a credit card authorization and i don't know let's just say you want to use stripe for that and then you want to send your customer a sms of the outcome of that credit card authorization you basically in a typical client server environment you call stripe then you get the response back then you call your semester with twilio and you notify the customer and that is it so request response request response in a in in in a properly or properly but in a commonly designed peer-to-peer application workflow like we're looking at you don't necessarily have that at all what you can do is you basically can forward your response to the next uh to the next service so if we look here and let's see if we want to do this uh this very example i just said and you have i don't know out here you have stripe and twilio so the first service we call uh stripe get the response then feed it directly into the next service which i don't know here micro somewhere over there is a twill io and then you get back your okay or whatever to your browser you make this a large number of hops in a request response model and all of a sudden what you realize is you have a very very thin client everything happens on the network and that's extremely powerful because it allows you to minimize the client requirements and i mean i'm sitting here with a pretty damn nice laptop and a pretty fancy phone but the majority of the 8 billion people out there are not running this big network uh these big laptops or uh desktops they're chrome os type uh situations and same on on phones so thin clients and then if you add edge edge devices various iot devices are going to be a huge volume and they'll extremely benefit from having this redistribution of the workload to the network and that's one of the things we're super super excited about the other part of course is why do we do what we do well first of all if you again if you look at it if you look at that workflow you stay in control of your data and to us this is a really really huge web 3 benefit and you also don't have any centralized brokers which means uh you're not tying into various cloud environments necessarily and also you get a you get very very censorship resistant it's not censorship proof but it's definitely censorship resistance and there's a lot you can do in terms of deploying multiple services on multiple nodes and different geographies that really really strengthen the resilience to censorship okay so this was aqua in a nutshell and we'll look at all this in much more detail however if you go back so we have hang on one more time if we go back here and we have uh we have aqua so now we know that we we have this location addressability of a service through aqua in the network through the node id and the service id and um now you asked and then i told you that we have a request response model that actually forward change responses without having to go back to the client at any given time unless you literally need the result to update a browser page or whatever it is it's nothing has to go back to the client so the question now is how do you do it and there's one more there's one more foundation component you should know we call it the particle you can also think of it as smart packet basically party particles are conflict-free replication replication data structures they combine the data and the execution sequence and a whole bunch of metadata let's ignore the metadata for the time being let's look at the data and execution sequence the execution sequence literally is the compiled aqua that script those eight lines you saw it gets compiled into what we call air which is the aqua intermediate representation which is a low level machine readable language output it's not by code but you can think of it as by code it's at the same level of abstraction at least and uh what happens is you create when you compile this aquascript you create your let's just say in the browser a typescript client which actually automatically is generated for you through the com the aqua compiler and then you create this particle so if our name was uh global and our boolean was uh true then we create this particle with the data name and string and we literally like fling it out on the network onto the first relay we can get to from the browser then at that browser at that relay we have aqua vm it starts checking uh word where's the service which node is it on this node is it a different node and if it's on a different node it forwards that particle to that node the aquarium there now starts checking okay we got this greeting service here we execute it we get the the uh high east global output and uh then it checks where it's going and in our case it's going back to the client and this is super super powerful it's uh basically a push smart data it's a push data model instead of a pull data model and it really really uh adds a lot of issue a lot of attributes and capabilities that i'm not entirely going through today but security in particular about data ingress data or particle ingress and egress from a vm from processing perspective plays a really big role in these smart packets okay uh anybody have any questions at this point i know i'm going fast so if i need to sit down tell me okay hang on let me look at the chat here no okay all right oh that's that's cool all right no questions uh so what we're going to do now is we're going to look at fluence at the ipfs so i told you at the beginning that fluence is a compute protocol and basically it's sort of to certain extent requires developers to bring their own store with influence we have adapters for file services on an old sqlite and few other things and one of the few other things is ipfs ipfs itself being a web3 optimized protocol it's peer-to-peer so it's a perfect complement to the fluence compute and what we've done is we basically build fluence nodes with ipf ssi card that is an ipfs node is deployed so with a fl on the fluence node and so let's switch here and let me go to the demo real quick let me show you what we're doing here okay come on okay so let me overlap that with code as well otherwise it doesn't make much sense what we want to do is the following we want to create a service that does something and then deploy that service to the fluence network and then use that service as a storage for that service we want to use ipfs not necessarily your local network yeah your local storage so let's start with the uh let's start with the service okay so the service we want to build basically is a service we want to build basically calculates the size of a file okay that's all there is to it this is in rust it gets compiled to uh webassembly it's it's pretty straightforward it's only literally the simple part of rust not too complicated there are no uh no lifetimes there are no generics none of that because uh in webassembly we pass everything by value and uh with this little uh macro here with this little keyboard we actually provide to compile instructions to use the the appropriate types and the compilation in 2032 so basically the rest is just pretty standard we you read from the file and you calculate the file size very simple so what we first would need to do is we are in the service directory here and what we want to do is we want to build that ros code into our compiled target which is y032 now of course i've already done this i think yes i have and what we're doing is i'll show you this in the build script basically there's a there's a bunch of noise in there but what really matters is this uh marine which is our our compiler extension to rust basically builds and builds this web assembly module and then we just copy that module in a more favorable location which we call artifacts and here this is this is it this is this is our our file size compute web assembly module and if we want to use it we need to deploy it to a node on the fluence network and there's different ways of doing this and one of them is to do it with ipfs and i'm gonna be very very uh huh that's suboptimal hang on i'm looking at looking out looking something disappeared okay so i'm going to use the ipfs desktop now i told you we don't want to just any use any old node ipfs node in this case we want to one that we control through not control but that's associated with affluence node so what we're doing is we're we're now we're in the web interface on how to uh uh nice not nice okay this is not good dang it it's just working that's embarrassing let me try one more but we're going to get the same thing probably uh let me try language try it one more time okay so this is no good might be a node error node is not running sorry that's what what i'm saying the there is a node the request is sending is that that node is not running maybe okay it should be running but it's not ipf is not or maybe a flu on snorlax all right okay let me regroup here okay uh always fun when something works and then it doesn't of course it never does it when you're not live okay what we wanted to do was we wanted to take that service put it on ipfs and then deploy it with ipfs onto the fluence network and in order to do that we use aqua aqua as mentioned before is the distributed language we uh we have to handle those things and this is what aqua looks like so basically we have some services and this is the deployment aspect of it so basically this little function here tells fluence compute to go to ipfs and and add a module it does this by creating a blueprint on the node and alexa is working on it and [Music] you know we might be able to do this live after all he was just there in chat [Music] oh if i succeed that screen share okay all right if and we create the service for that for that module so okay so now now follow me mentally uh it would have been much nicer graphically but we created a we created a ros code to calculate a file size we compiled that ras code into webassembly rosi32 and for that we have now a web assembly module we take this module and we copied onto an ipfs node which i wanted to do with the desktop in order to do that we want to know the ipfs sidecar to use that is we need a multi address of that of that node which i wanted to get from the browser and uh now we have that file sitting on ipfs and you can deploy it you can access it as long as you have the cid you can do just about anything you want one way of us wanting to do is is we wanted to do this with with aqua and these are the functions we need to call in aqua in order to take the module from ipfs and deploy it to a node of our preference and it starts with deploy service and we should just basically go through it so the return of the deploy service is your service id and the service id as i said before is the unique identifier for the service on a particular node on a particular peer so the location addressability comes from the peer id service id tuple which we uh briefly touched on before so what we're doing now is we we're going to find a relay and now we want to get from ipfs with the cid and the multi address this is ipfs is the multi address which we provided earlier on and then we just go through building the service from the actual module because as i said before uh you can build multiple services from the same modules you can different services from reconfiguring your uh modules and basically the way it works is you basically take the uh module and then you just compute the hash of it you then create what's called the blueprint from the hash which basically uh entails all your dependencies and you get a blueprint id and from that blueprint id we can now uh create the unique service id so everything up to service id is totally reusable and then the service id is unique unless of course it doesn't work then you get an error which by the way we okay i've seen chad okay all right uh let me switch to alexay to do the share let me stop right here alexa are you ready hello i was watching youtube instead of zoom so it was a bit late so that okay let me close a few of the wrong apps okay so i'm sharing i don't know why but uh also the localhost stopped working so i had to use this it's a localhost that's not different sub-network anyway hello everyone i'm alexey i'm developer at fluence and i saw that it wasn't working for bernard so i came here to help so as bernard was describing we have ipves demo that allows us to connect to some node in the fluence network so here we connected it automatically retrieved the ipfs address from the fluence node because each fluence node is side card with ipfs nodes so they run together um and every fluence node this is connected to ipvs node through webassembly fluence adapter through web assembly ipves adapter deployed on the flinx node and it knows address of ipfs node so it reports here and we have can connect there through ipv5 desktop let me restart it i hope it won't connect automatically so it asks us for a ipfs node address that's awesome let's connect there so we have connected to the pvs node running along the flinch node now we have to click twice here and now what we want since what we want to do is to deploy webassembly service we need to upload it to ipv5s known okay anyway we have this uh ipfs node you see here it shows that it failed to upload i wonder why never seen that before but anyway i hope it will work so what i did is i have this iphone's desktop connected to ap snow then it shows me that ipfs node has this wasm file i know that it's a wasn't file for uh service written and rust and control 2 wasn't so i copied cid i pasted it here and pressed deploy and it deployed a new service by this cid uh like file ipfs file hash a deployed service and it's available to be called through this service id awesome so now when i copy this cid once again what this service does it allows me to calculate to download a file from ipfs another file and calculate its size so here for example i paste the same webassembly file cid press get size and it reports the size of this of this file of this wasn't file also it uploaded this uh file size to ipfs node and the uploaded file size like a txt file with this number inside is uploaded to ipfs under this hash so i paste it here it should be a very very small file so yeah it's just six bytes let's try another file we have config tommle here just a random file it's 116 bytes i paste cid here and we have this size so it goes to ipfs through aqua downloads file to one of the frames nodes applies a function in the wasm service to this file calculates its size and uploads result back to ipfs i'm done okay all right let me uh let me get back to screen sharing here take that back all right so okay while we're while we're diddling around there anybody have any questions really all right so [Music] we saw the code for for uh i'm a little bit disjointed so it's gonna take me just a minute to get my train of thought back lined up here uh so we saw the the ross code that turned into the webassembly module we put the webassembly module on ipfs basically uh permanent storage distributed storage permanent web 3 storage so you can use it from anywhere anytime which is in my opinion a little at least in my case a lot more reliable than saving some locally and we've seen that we can deploy the service with aqua in just a few steps so the important part here is not just that you can't do it with aqua but the important part is that you can interact seamlessly with the fluence compute with the fluence node and ipfs there is no separation there there are some backend services alexa implemented that'll allow you to do that and that's really that's really the aside from it being cool that you can blow this blah blah that's really the takeaway message is that uh you can use aqua seamlessly across different protocols distributed uh compute protocols and store protocols and that is really really powerful and then uh uh things like uh removing a service obviously scaffolding is always uh more expensive than uh destroying things it's always like to build a house then tear it down and destroying is always fun this is at the bottom it's just you remove service in that box this is how you remove a service in basically three lines and again it's the the location addressability of the service that allows aqua and the underlying network marine and echovm to take care of a lot of the headaches you would usually get and one of the things that's important to know is that in peer-to-peer networks especially peers come and go it's not an exception it's almost an expectation it's in flux it's a network in flux and being able to to work on this location addressability and then there are ways of implementing failover which are a little bit beyond the workshop you'll see how truly powerful this is especially compared to uh if you have to manually code that stuff uh in addition so okay so this was the actual file size calculator which is very similar to uh what we have before so the actual binding is the process file which we had here so these are the interfaces you use for that uh rust service i showed you earlier one was the size result was the right result and then it's the actual service that provides you the bindings to the file size and the right file size functions and one neat little thing is actually it's a very convenience because i really really dislike copy and paste or leave the retyping what we have is we have a rebel that allows you to interact with the web assembly modules locally and oh look big surprise those are exactly the interfaces we were looking at before so if i had a file path that with the string then i could actually utilize that right here and you would do something like this and then put your file path in and it would process and that's how you can interact locally with the services so if you want to test things out or if you want to test your bindings if you want to reconfigure services this is a really cool way of doing it and of course through marine which was the compiler we saw before we can hang on i need to know where i'm going we can export those uh interfaces i think this process right i'll process files god today nothing's going as fully planned okay so you can export those interfaces and uh if you wanted you could just uh you know pipe him straight into whatever file whatever file you want to and then you end up with a file like this okay so this is sort of a quick start on how to set up your service your module your service deployment and then your aqua coding using the necessary bindings or interfaces from your services and when we start looking in the actual components the application logic now if you integrated with with the browser code is here and one thing i wanted to show you is these are the actual aqua files the way you you saw before we've seen this in in envious code and and if you compile it you uh all right there's some dependencies it doesn't work if you compile it you end up with where are we where we were and build folder writing alexa do you know where the uh where the uh uh aqua output the compiler output files bend they used to be in here where'd they go well maybe they're okay there there okay they get moved to a different directory okay so basically what happens is if you compile it you can compile it in a way that it wraps your output aquacode directly into a reusable typescript wrapper so let's just have a look if we can find one that we used before so get from for example that's what we looked at so this is this is how you get fr do the get from and how the compiler prepares it for you so you can just call that function straight from your client and this stuff in here this is actually air and this is the the machine level code and [Music] believe me it's not fun to write by hand and but it's extremely powerful and what the compiler does it basically wraps that and this is the part this is the part when we said the execution script is part of a particle that is the execution script this is part of the execution script and this is what gets executed on the aqua vm and uh sorry for this ending up fairly disjointed uh so if you have any questions on that uh hit me up and or hit us up in uh in discord and now let me go back to the uh presentation because i want to want to go over the bounties that should be fine and if you have any questions please shoot okay prizes so we get actually let me make that smaller we get uh no that's not what we wanted it will be good god there's like nothing working today nothing i really really apologize okay we get multiple prices so we have a really really simple bounty hundred fifty dollars for the first 10 submissions that basically extends our quick start if you look in our examples it's in fluence.dev in the examples there's a documentation that's quick start section and uh we would like you to extend this and basically add a service just like we showed you uh that counts words of a message that's it and i think uh even in this uh disjointed presentation you should have gotten everything you you needed to do it now you don't necessarily have to use ipfs to do the deployment there are other command lines that are outlined in the quickstart but that's a real easy way to to [Music] stick your toes in the water and play with uh some concepts make a little bit of money and see if you want to go on with uh with the hackathon which we really really hope you want to and the next uh bounty is 2500 best use of fluence compute for your decentralized application i give you a few examples here so for example nft creation with the marketplaces the way they're going it doesn't really matter anymore nfcs get created so uh one way of and then there are examples of people using fluence already to create nfts and there are some pretty interesting ways of creating metadata around nfts that also work with fluence for example you can do mutable metadata for an immutable nft using uh ceramic for example or generally or if you just want to do an ipfs by itself that's fine as well and so using something around nfc creation maybe uh based on gas arbitrage across different uh evms for example that's something that'd be super very super interested price oracles particularly price oracles that go straight to the decks uh reusing an already an aggregator that's kind of lame but if you go straight to the source and uh start pulling from dexes particularly if you start bringing liquidity information with with it that's also super super uh interesting to us and we would love to see that and then another example would be uh for example to arbitrage contract use across different evms whether it's layer one or layer two if you have say a given contract that's deployed on multiple evms uh obviously when do you use which one and uh it's actually not that different than uh how to do uh order rounding order routing to dexes right so you can start uh checking on gas prices on the different evms and then start using the contract for whatever execution you wanted to use on on those different dvms and then we have another price it's a 2500 for best tooling a pattern for other developers to use and um things in there are really about porting existing libraries or x library functions to fluents whether it be a web 3 library for example or just a signature signing verification service where verification is interesting as a network solution if you have a domain knowledge in decentralized advantage to verify credentials we'd be interesting to see uh what you could do with that particularly about linked data and resolving linked data if you use bbs plus it would be really really cool because that is really where everybody's settling around on right now in uh verifiable credentials and we have one more which is basically if you're into front-end development decentralized network explorer of our network and there we have some examples that are listed on the bottom here and then lastly we have a fifteen hundred dollar best user fluence with another event sponsor bounty and basically just use fluents integrated with one of the other event sponsors and uh uh whoever comes up with the best use of it 1500 or years uh going back here just one more on resources so there's a variety of resources we have a uh we have a discord channel we have discord channel in heath global we have a fluent youtube channel we are available in discord but if need be you definitely can book some time with one with one of us and we'll answer all your questions and help you sift through what needs to be sifted through and lastly uh if you're interested in peer-to-peer uh we're hiring have a look at our website and uh that's it that's all i got sorry for the whatever that was no problems thank you so much um bernard for this workshop and thank you to fluence for sponsoring ethonline this year just like what he said i really want you guys to uh continue this conversation in the fluent sponsor discord channel um so yeah you can find uh bernard there and ask him any questions if you guys have any that pop up while you're using fluent student duration of the hackathon but yeah everybody have a really great day and i'll see you at the next workshop bye 