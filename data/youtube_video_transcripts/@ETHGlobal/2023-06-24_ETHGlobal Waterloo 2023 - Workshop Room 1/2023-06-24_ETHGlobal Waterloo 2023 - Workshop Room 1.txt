um so before everything that I would do with the first startup that was very personal and if if somebody has criticism I would be the one crying in the corner or at home because I would take it very personally now it's a bit of a better work-life balance where there's a separation between what we do what they were building as a platform and my personal worth for example uh there was an approval of the crowd back then and like one example of this we invested a lot of time and money into making our office really cool some people here either been in our office uh in Toronto and currently it's like more of a disregard of opinions and you know working from coffee shops or working from we work in places like that um back then there was more of an investment in appearances we paid a huge premium hundreds of thousands of dollars to have our sign visible in downtown Toronto so that people would know that we're there uh I would not do this now so there's no need for those nice perks but back then it was very very important to me and also back then we had investors that were pushing us to build for growth this is companies like Andresen Horowitz and a whole bunch of others that are trying to instigate as massive growth as possible and now it's more of a build with intention so be more focused on solving crucial artists issues that we can that actually make a meaningful impact and back then there was lots of drama so now we're trying to deal with kind of like a little bit less drama so as my finishing slide kind of like where what are the next 10 years because it's nice to look in decades it takes a long time to build something so we see uh for the next 10 years that there's going to be a lot of interest in keeping art royalties and it's something that actually exists in some countries on the regulatory level where whether you're in France or some European countries if the artist is alive and the art is resold there are some royalties that are attached to the physical art when it's resolved so taking a digital and making sure that it's available for 100 of art is kind important I think we'll see what I would call ubiquitous blockchains that everything of importance will be on a blockchain we just wouldn't know or care whether it's one blockchain or the other that also stems from that transactions will go from expensive as they are today on ethereum too cheap and to eventually free so that's already happening without use there's going to be a lot of talks today but eventually the platforms either going to subsidize those or there will be players that will subsidize the transactions for everybody else and that's going to be completely free to transact and we're going to have a much better future in that regard there's also this happening uh when we started with web 2 when we started with photo sharing that was very simple you share a jpeg and that's it right or a video and that's it now there's a bit of an evolution in the artistic medium and people are using whether it's a generative Art Plus photography or whether it's a on-chain art that evolves with every transaction so those things are becoming more important and more interesting for the artist to start using some of the methodologies that only exist in web3 like only the stuff that can actually be on chain and so those are making a very interesting impact and the last two digital displays so we're currently hosting an exhibition in Italy with our current platform and the art exhibits around the world are turning from physical to more digital so it's a physical space but there's this place and the artwork is is having a clear provenance like who owns it or who can buy it and stuff like that so kind of like more likely to see more of those digital screens around the world yeah uh so much so that I think people have those at home eventually or they'll have them in their apple Vision Pro Set uh and lastly kind of like what I mentioned earlier IRL events like this one like getting uh personally getting to meet people is super critical regardless of how far the technology evolves because it's a fist bump or a handshake that can make a big difference Meeting those people sharing experiences is something that we take personally and with the current platform we actually talk to every single photographer that's on platform almost a thousand people we had a phone call or a zoom call or something like that to know them a little bit to verify who they are and just to ask them like Hey we're humans too let's chat even though some were staying Anonymous and they wouldn't turn their cameras which is which is totally fine um so this is the end of my presentation if you guys have questions ask them if uh if not I'll be outside as well to take questions and chat about all things building startups thank you [Applause] thank you thanks foreign maybe I shouldn't keep it in my pocket nicely in there thank you a little bit let me know when we're good to go that's good [Applause] hello okay um hey everyone I'm glad there's actually a few people here right now my name is hardik I'm from learn web3 and today we're going to be talking about you know building for the future in an uncertain market so quick show of hands who here is a student right now at Waterloo or Laurier or anywhere okay I saw one two okay um who here is a software developer by trade one two three four five okay cool and how long have you been in the web 3 space roughly just raise your hand if it's like less than a year um okay okay one one two three years maybe two okay and more than three years Okay cool so you know this is going to be a little different it's also been a long time since I've done one of these IRL so it's nice to be back um this is going to be I'd prefer this to be more of a discussion than a lecture so if you guys want to be talking while I'm doing this I'd love to sort of engage with you but you know we'll go forward with it so as I said my name is hardik I legally have no first name so when I'm signing papers it just goes down as hardly hardik which is weird um I'm a Waterloo Alum I started the UW blockchain Club back in 20s what was it early 2018 I think um software developer by trade and currently co-founder at learn web3 so being at learn web3 you know there's some questions I get asked every day and I kind of wanted to take this opportunity to if some of you have these questions or similar along those lines I kind of just want to talk about that so you know one of the most common questions I get pretty much every single day is I'm just starting out how do I get a job in this space or if you're a student the second one's probably particularly relevant is every company wants years and years of experience and how do I deal with this as a new grad maybe if you're in the co-op program it's a little different but for most University students new grads don't usually have years of experience under them and do you need to grind lead code that's that's very common and what chain what language what protocol what framework to use and also is crypto just debt do we just do AI now is open AI is going to take all of her jobs anyway and why are we doing this at all or you know do you want to learn front end the back end smart contracts and when airdrop we're not going to talk about the last one so from these you know I want to kind of go over these but there are some facts but then there's also opinions and then there's things you can do so fact is the job market is right now there if you're on Waterloo works you know about this if you're if you've been grinding you know about this um some companies need lead code they will always need lead code is just how it is some don't a good amount of companies want past experience but if you're a new grad if you're learning if you're about to graduate soon there are things you can do to sort of get around that and ethereum and sort of evm-esque chains still remain the most popular to build on if this if that's the goal you're working towards crypto is not dead yes I think but crypto is not dead um what you should learn is a bit of a tricky topic and I'd love to dive into that in a little bit and no airdrop questions that's the facts but then again we have some thoughts um being at learn web3 you know we've had students being hired at a lot of great well-known companies in this space some of them are here in this room right now we have people hired you know I'm not going to list out all of these names but um I kind of know a thing or two about what can you do to sort of being a student being in a bear Market being in an absolutely terrible job market and sort of getting away with it and still being able to you know get a job or get funding if you're trying to do a startup or along those lines you got what I mean so let's just talk let's just talk um if anybody at this point wants to ask me questions has a question has a problem they're struggling with or anything let me know more than happy to answer but let's just talk about the questions I started off with first so I think number one we want to talk about is AI going to actually take your jobs and are you wasting your time learning how to code if you don't already do it professionally it is not going to take your jobs and I think one of the reasons is you know actually this is something I hate and this is something I've been talking about a lot more recently publicly is a few years ago when sort of this term web3 came along you know Chris Dixon was like oh web3 is read write own and um all of these guys were talking about sort of you know he was gaining popularity it never equated to crypto it never equated to blockchains either that's a weird issue that we've run into sort of sometime in between over the last few years where everybody is just like web3 means tokens web3 means scams web 3 means Pepe coins um there's nothing real in this space there's not a dunk on crypto um big crypto bro here but oh oh is this being screamed oh sorry about that um okay so yeah web3 was always sort of meant to be like the next Frontier of Technology you know it could have been uh it could have been crypto there's AI you know if you saw WWDC maybe probably Vision Pro is probably going to be very common in the next few years hopefully um that's one thing I want to clear up so if you're if you're in this space there's a lot of beginners who are just like oh did I make a mistake learning how to build on ethereum or learning how to build on XYZ chain um should I have just spent my time doing data science instead or should I just spend my time learning how to use tensorflow instead the answer is you don't have to choose there's no reason for you to pick one or the other if we're really working towards sort of what the next Frontier of the internet is a few years down the line 10 years 5-10 years down the line you're not gonna see apps in the mainstream or just like we do this in a decentralized way or we do this with a chat bot um there's going to be a combinations of all of those things and any sort of Dev who's been you know full-time software developing for 10 20 30 years now if you know anybody like that when they started off Tech looked very different than what it looks like today a lot of the things we use today a lot of the things they even teach you in school today probably didn't used to exist back then that's going to change and this is just something I wanted to rant about I've been writing about this a lot recently um that's one of the things and okay what else lead code if there's a lot of Waterloo people here who probably have strong feelings about lead code one way or the other um I don't know if you've seen this problem come up if lead code is important or not but that's whatever I want to answer the second question with what to do about not having years of experience again if you're the target audience for this talk this might be relevant to you where you know you may have co-ops but internships are not the same thing and you may not have co-ops you may be in a non-coop program how do you get hired in a job market that's terrible in a bear Market where tokens are all down to ship so this what I've seen here what I've seen students get the most value from when they're sort of on this journey to learn explore figure out what they want to do you know what kind of field they want to work in what job they want to get what helps them sort of the most is kind of just building in public not saying you have to be active on Twitter 24 7. there's absolutely no need to do that but you have to be building and you have to be building in a way where you can say that that was your experience if you copy a to-do list tutorial to learn react that's not going to land you a react job if you copy how to build a task tracker using node.js and express that's not going to get you a backend developer job what is going to get you those jobs is building something that you can't copy based on a tutorial is building something that is not so simple it could be a clone of something sure but it shouldn't be a copy based from a tutorial and hackathons like East Global you know and other types of hackathons are probably the best place to do that if you're a hacker here that's amazing I got my start in the web 3 space 8th Waterloo 2017 so this is great sort of being back here after some years but if you're here to hack if you're here to learn that and you're here to sort of you know get ready get a good name out their build projects I think that is the key number one thing you can do apart from grinding lead code and going after Fang um if you're building projects and you're building stuff that's novel that's not a copy paste from a tutorial and if you're building stuff hopefully that can get some users some actual users it's not a necessity but it's always a nice to have if you build a project that has like 50 users right 50 users better than zero do that and I promise you you get a few of those under your belt companies are going to stop complaining about you not having years of experience on your resume because when you have actual things you've built that have users um or just actual cool things you've built that are not copy pasted from tutorials that is a very high value signal I've been on kind of both sides you know I was a student at Waterloo doing the Waterloo Works grind applying to 200 jobs every semester um and being on the other side sort of done hiring for companies I work done hiring for learn web3 and there's a lot of times I hire new grads I've hired a bunch of new grads and the key thing is again have they had novel projects under their belt um yeah I think that's a key point I wanted to get across again this is meant to be a discussion so if any of you have any specific questions I can help answer that might be relevant I'd love to take on those now otherwise I can just continue on this list all right okay so what else what else do we got we got the lead code questionnaire it's okay it's kind of the same similar answer to that um oh the other thing I would say kind of pertaining to number one and number two both is being involved in a community helps a lot I'm not here to show learn that through by the way okay you'll go we'll go through this slide I will there's like one slide at the end where I'll give you the website link I'm not here to show you a course I'm not here to sell you a boot camp or education is anyway free so I'm not here to tell you anything but realistically the most value I've seen um that's like the students I've seen who've gone from sort of not knowing anything about ethereum or not knowing anything about crypto and in less than a year getting like a great remote job traveling the world perhaps if they're in Deborah or just working on cool protocol layer development stuff um which used to be a dream of mine when I was starting out um the biggest thing that separates them is also how active they were in the community there's a lot of people and this is unfortunately somewhat a toxic culture at Waterloo I have to say is people really tend to be in isolation a lot when they're learning when they're trying out new things obviously if you're not from Waterloo maybe don't recognize that problem but there's generally tends to be a little bit of competitiveness toxicity around that culture and I want you to forget that I want you to be collaborative I want you to talk to people around you because when imagine we're in a room right now imagine I'm not giving this talk we're just sitting around we're just chatting having coffee and we're just talking about sort of what's going on in this space right what is cosmos doing is better chain even real um I don't know we're just sitting around talking about that and we'll bring up things that the other person doesn't know about you know I'm gonna go out after this talk I'm gonna meet some of my friends who are going to teach me a thousand D5 things I have no idea about because that's not who I am I don't do deep IDs and all that um you meet somebody else they're going to tell you all the new advancements happening in nfts you meet somebody they're going to tell you why op stack is better than our bedroom stack or why arbitrim is better than op stack or why coinbase is building on optimism or what the hell is worldcoin and why are we also telling our eyes to Sam Altman whatever that reason is when you're around people you get to bounce off ideas you get to talk to people who are focused on things other than you and you will never be able to get that far by yourself web3 is or I should say crypto is such a small ecosystem relative to a lot of other technologies that are out there and even then it's almost impossible for you to stay up to date just by yourself so if you aren't doing this already and if you are kind of in your journey to you know learn more about this build more maybe get a job maybe build your own thing the number one highest value thing you can probably do is being part of the community and the number two would be building projects that you can put on a resume that hopefully have real users um yeah want to say that out um what else do you just move to AI now kind of touched on that not going to take your job use it to your advantage you know train chat GPT it's really simple to do train type in chat GPT feed it a hundred page ethereum yellow paper and ask it all the questions you can so you can learn how ethereum actually works inside out you don't need to stay just on the conceptual level you don't need to be you need to be using it to your advantage a few years from now devs who are using chat GPT to 10x their productivity they're the ones who are going to take your jobs it's not Chad GPT who's going to take her job it's the people who can perform 10 times better in the same amount of time who are going to take your jobs so if you don't have an open AI account if you aren't paying for chat DPT right now or if you aren't paying for an API key right now come on guys okay it's put in 20 bucks put in 20 bucks and it's going to be worth a month two months of whatever usage you can get out of open Ai and that'll be way more value than should I say that way more value than the 20K you're probably paying for a semester over here so um I have my thoughts on University education that's whatever maybe another time um yeah do you like I don't get you know this there's another thing sorry I'm just going on a rant here but there's another thing seeing so many people come up to me they're like hey so I want to learn how this open AI thing works but it wants me to put in a credit card I'm a first year student I don't want to spend money on this stuff I'm like dude you just bought a five dollar coffee right five dollars will get you thousands of messages on Ted GPT 5000 like five dollars will get you so much value from open ai's API um you're gonna think back to this time a few years from now and be like why did I not just do that this is if there was ever a time in history where you could look at it and be like this is going to change the future as we know it um I don't think there's been a clear time at least not in my lifetime there were probably times before I was born but in my lifetime I don't think anything as big as the air Revolution right now has happened and you shouldn't have to make a choice you shouldn't have to choose you shouldn't not be using it you should be using it to improve yourself as much as you can whether you're building in crypto whether you're not building in crypto if you're just here for the free t-shirts and food um if there's anything you want to take away from this take away the fact that don't be worried about spending five bucks and talking to people who's talking to people will get you the most value in your career than ever before another thing to think about on that topic actually somebody said this to me the other day somebody was like you know oh XYZ person has so many connections you know he knows everyone how do you compete with that if you want to build something how do you compete with somebody who already knows everybody they can just give them a phone call and be like hey use my thing or promote my thing on Twitter or whatever and how do you compete with that one thing I want you to think about on that note is if you're in University right now if you're in school right now and I'm assuming if you're at least the people who said they're developers you're either doing ECE or CS or something like that um your classmates you have hundreds of classmates hopefully you're friends with some of them those people five years from now 10 years from now 20 years from now will hold some very good positions at hopefully some very good companies and kids who are in school then will look at you and we'll be like this guy knows all the people from all these big companies how do we compete with them um so talk talk to people build in public build projects talk to people get the value out talk to AI um learn all of this what changed what language the protocol front-end back-end smart contracts do whatever do all if you can I think a lot of you are in the age group where you're probably still exploring you aren't 100 sure what you'd like to be doing a few years from now um if you're in that phase of life just do everything dude it doesn't you have time you have time just explore everything do a little bit of everything that's why I think building projects is amazing and hackathons are amazing because you have to build out the whole thing it can't be just oh I just wrote in Express API but I can't demo it because I don't have a website to show it off um you have to build up the whole thing do that um I think that's all the questions on my list at least and again this is all the Shilling I'm gonna do it's free we don't charge you check it out if you want to come meet me later if you want to this is my Twitter DM me if you want to I reply to every single one of my DMs um that's about it if you have any follow-up questions to that if you want to chat in front of everybody or just by myself later um come up or ask the question now and then we'll hand it off to whoever the next speaker is any questions all right foreign want to do a little uh yeah uh one two three testing one two three is that testing testing I think we're good cool is thank you foreign foreign [Applause] all right it's great to be here um I'm here to tell you guys how to decentralize your front end for this hackathon and potentially Beyond and we're going to talk about how to do it with a tech stack that we're calling the blockchain operating system so just to kick it off like what is the blockchain operating system so two main things one it's this common layer for discovering open web experiences that's compatible with any blockchain which is a part of it that we're really excited about and then maybe even more directly for those of you who are developers in the room probably most of you it's a tech stack for building fully decentralized applications and most importantly for this for this talk it's about decentralizing your front end uh so the main reason we decided to build boss is to solve a few different problems uh so onboarding and distribution are common ones compliance is one that's becoming a lot more important especially if you're building Financial applications uh complexity another one for developers you know there's there's a lot that comes with building a front in these days and we aim to make it easier uh and then we're really excited about bringing cost platform to support to this ecosystem and really just you know letting blockchains collaborate in a more compelling way and so the boss stack is a few different pieces we'll mainly be talking about user interfaces and blockchains today but we also do have some products for onboarding mostly around users being able to use blockchains without actually needing an explicit wallet if they're new to their crypto Journey or using a crypto application they may not have a wallet and they may not want one just yet and we do have some products for that but the less relevant to this talk um and here's kind of a snapshot of a few of the different pieces that fit into the boss stack again we have what's called like these gateways which are going to be basically interface spaces that enable users to interact with the front ends of various decentralized applications like say Ave uniswap liquidy and others and the code for these will be stored both on the near blockchain for the front end and then uh on say the ethereum blockchain for the smart contracts um so one of the biggest things we aim to solve when we set out in building the blockchain operating system is that typically developers are forced to make a choice between distribution and decentralization when it comes to their front end you're way better off like kind of baking your front end into a few existing applications or even hosting your own front end and promoting the hell out of it if you're trying to get distribution if you want just decentralization though those are kind of counter to the things that you want fortunately we think we have a way to kind of thread the needle and actually give you both increased distribution while also giving you even more decentralization you would have had if you're hosting your own website on likevarcel or something like that so to make it very clear and exactly how it works let's imagine that you guys are developers and first you're going to deploy a smart contract to ethereum and now you need somewhere to deploy your uh your front end and let's say you choose boss and you choose linear blockchain so what you're going to be doing today is you'll actually be deploying basically like reacts jsx code like these can components you'll make a component for your dap that you will deploy to the near blockchain and then users will be able to interact like access that interface could conduct some actions that will uh that will then result in a transaction and then they can send that transaction to ethereum which means they can have basically they're interacting with two different blockchains in one experience they don't necessarily know that all they care about is accomplishing their goals um and a component of this we're really excited about is that since you will be able to deploy your code on chain what this means is that dowels that are currently managing their smart contracts can now also manage their front end all on chain so we're hoping we can see it like a world where every single dial will do this like if you have Smart contracts you at least have some basic user interface or even a very full feature user interface that you as a doubt will maintain an upgrade that like reflects the usage of your smart contracts to make this a little bit clearer we'll talk about it from the user angle so let's imagine that we have a user the first step to use boss they're going to navigate to some kind of interface or fun in this could be metamask this could be zapper on on iOS it could be near.org soon it's going to be orbit which we're pretty excited about and it can also be this site called boss ug that's basically like a doc site that we have so by going to any of these they can access all of the same applications so then they're going to select a DAT that they want to use these are four examples we have available today Ave one inch uniswap or liquidy let's say they select Ave so after they select Ave then the uh the Ave front end code is going to be loaded from the near blockchain so it'll be an RPC request to the near blockchain which would then return the jsx and that jsx will be rendered in a specialized virtual machine that will be running on one of those different uh gateways that the user first navigated to and this virtual machine is designed to basically be a strict subset of JavaScript that has some extra security guarantees so that you know if it is near.org like and there's private keys in local storage for some reason those are not able to be snooped easily that's the goal um so then like they've loaded the front end they're doing their thing they're like I want to deposit 100 usdc into Ave great forms a transaction because like they're just using now they're just using a front end and then it hits the ethereum RPC sends the the transaction to ethereum they then get like you know some kind of receipt showing them that the transaction was mined get a message saying that they were deposited it updates the front end now they're happy and they've used a fully decentralized uh or you know cross-platform application what's really cool if you want to get really paranoid with this which we like to do is that Gateway in the first step can be self-hosted and it can be self-hosted very easily you can run this in an electron app and you know soon we'll have that as an access point or I think even more commonly we'll just see people using their typical Mobile wallet and they'll be able to access the application kind of skipping DNS entirely skipping going to this front end entirely just interacting with two blockchains at most one blockchain if it's fully built on near or two block chains if the front end's on your end then the back ends on ethereum or an L2 or Solana or whatever it may be um and the best part for you guys is that it's super easy to get started so there's basically five steps if you guys want to like want to build with this today or even get some things running you can go to near.org you can use the search function search for these five different applications uh you can click Fork you can make changes and then you click save and that save is actually going to be a transaction to the linear blockchain it's super cheap should be a few cents if anyone in here needs some near come talk to us at the near Booth we'll get you guys some some near and you'll be on your way and then the other aspect of this that we're really excited about is that every single component that you build can be composed with other components the same way if you're familiar with react where you can have higher order components and you can compose components you can pass State and props between them you can do that with with boss with a bunch of different components like there can be 10 different components that are deployed I gave an example of a page uh for polygon that shows like a few of their different applications all of which are available on boss and then it shows an interactive swap component there that's also being rendered in the same page and this is actually going to be like seven different components all of which are composed together into a single experience which is really cool um so now on to the fun part which is the demo and we'll actually walk through how you can access boss components and how you guys can get started for this hackathon so this is actually a demo that was created for each soul and I think what's fun is it's going to make it be a very easy way for us to show uh how you can get started so in this demo there's basically four different components that are gonna be shown you see that little widget line that's basically a compo a different component that's being loaded into this higher order component so some of the things you're going to get out of the box here is like the detecting the the network that the user is on that's going to be like the first thing that this component is doing um then you can detect like basically who the sender is going to be from State and we have some examples of how to do that you can load their balance whether they're each balancing you can load their their state deep balance because in this case we're this is like a Lido component example like helping people stake their ethereum and I think it'll be even easier if we actually just go to this and show you what's happening so here here you can actually see this being rendered this is the Lido component and I can go up here and I can click Fork now we're seeing the code so users can actually do this they can view the source code in the browser same way you'd be viewing the source code for a um for like a smart contract on etherscan so they can check out I can't actually see it on my screen [Music] um bear with me somewhere in here we'd be able to see the smart contract but I cannot actually see it um maybe let's just go to the actual lied out contract itself see here here we go so let's Fork this one here you can see the smart contract so like a Savvy user would be able to actually check the smart contract go cross-check it on another uh another website and be like cool I am very confident that this is going to actually uh send my e to the contract I want to which in this case is the light of contract and you can easily change that to say the Lido contract for polygon and then I can just click save and it's actually just going to show me the state diff so this is like showing you like the code is that that's actually going to be saved to the near blockchain click save data I'll probably have to sign a near transaction Maybe oh I don't even have to yeah if it's below a certain size then you don't even like you don't necessarily have to save it uh save it on the on do a transaction in order to save the state diff um and then bam we're good to go and I can preview this I can preview it here so I can actually see what I'm doing and then just like hop back and forth between the browser editor or you can download a vs code extension that will make it a lot easier to compose your apps like if we have from the previous example we had that you can see here there's like these widgets that are being loaded the widget means it's another component so if you use the the vs code extension you can actually click into this and you can then see the component or like pull in the components so you know what it is that you're going to be interacting with um yeah and then if you go to near.org you can actually use the search functionality here and find a few different components so we can look for Ave for instance the Wi-Fi is going to cooperate I think this is the one I cannot see let's see yes whoops okay this is for Avion the polygon zkevn test net where did my browser go here we go while that's loading we can oh there we go so you can see this is like another component that someone in the community built uh we can then go to develop and check out the details which will show us like who deployed it it'll show us like all the source code and then go ahead and Fork it and maybe in this case we'll want to like change the network that like but maybe we don't want it to point to Ave on uh polygon zkvm maybe we wanna sorry guys I can't see it on my screen here but we can change it to point to like aveon polygon or Ave on ethereum or whichever Network it's deployed on and then we can do the same thing and save it oh here it's over here or we can save this version of it locally this will be saved in the browser so you can just kind of like edit while you're while you're testing and then if you want to publish it then you can do the transaction so in this case I'm actually just forking It Off live demos all right let me just pull up the slideshow again cool there we are all right uh so just diving into some more of the technical details and showing you what we're doing here um so a lot of this right now this assumes a react dependency out of the box we're launching a version of the virtual machine that will not make that assumption because I'm sure plenty of you want to use other JavaScript packages um so right now we use props and state if you're familiar with uh with um how react works so like props you can pass between components you can also Pass State but state it can in this case will be more Global which means you can just like store State between components um so here's an example of how you can use ethers so we inject ethers just by default right now to make it easy for developers to to get started so you can see here this is like basically doing a get balance function uh from ethers pretty simple to similar to what you've been doing before and then the result here will do a a state update um and then similar to like updating any sort of State in a component it like uses the the life cycle of react and this component will rebrender with the Steed balance to to whatever the user's balance is so that's an example of just like how Stadium props are going to work um similar kind of thing here I think this one's actually doing yeah the kind of uh smart contract call so you can see like you know it puts the you can assume here that we have like a lot of Contracting in there and then like encodes the data using um using like the the standard that ethers is expecting in this case like balance of and we'll call it and then it will then update the interface based on like the result of that transaction and then a very important part for everyone who's building a front end you're going to want to style this component so uh by default we actually enable um oh no sorry this is an example of that composability we're talking about where you can have this kind of like other component pass pass the props to it um and yeah it shows an example of basically how to do that and then finally we have styling so we by default it'll let you use styled components um so it should be like a nice and familiar way for you to to include your style sheet so you don't actually have to like pull in an external style sheet you can just build into the component like similar like you would do in a lot of typical react components and that is what I have for you get today so we do have uh some bounties here so we have 10K total in bounties I think it's split up between a first place prize of 3K two second place prizes of two grand and then three one two or three of 1K if you scan the QR code there you can check it out and you can also come visit us at the near Booth we're on this side there's also like five coin in the graph right over there uh we're right between them if you have any questions and we'll be here all weekend um and yeah we still have a good amount of time left so I'm happy to answer any questions that anybody has about how this works all right yeah great question um so I guess like our goal here is that you can fully decentralize this right so there's a few different layers if you want to decentralize an app a blockchain application right like there's going to be the front end code and where that's going to be running there's going to be the smart contracts those parts are almost like the easy part the hard part is like well making sure that like if you need radical decentralization like I'm in a place where like they're a serious censorship then you're also going to probably need to run your own RPC and most applications these days have some kind of data layer hopefully it's the graph which fortunately is getting very decentralized but a lot of times it isn't and if it's not like yeah you need some easy way to access that data so like that's been a general big problem on most spot chains like at near we've we've worked with a lot of teams and created a lot of solutions to kind of make like just more easily indexable or accessible data available available to developers but we want we basically want front ends at some point to like let users kind of Define their data layer to find their RPC to find their wallet and like Define each to the different parts of the stack so there I mean yeah that part is tough like right now basically the Gateway is usually just choosing like an RPC provider they're choosing uh the data provider and making sure that like developers can essentially be agnostic to the choices that the Gateway providers might eventually make is is a bit of like an experience problem so that's one of the ones technology sometimes I I bought them at the website and how much tolerate without Oh you mean like if millions of people are accessing like how many yeah so that's actually gets into that first question is like it sort of depends on which part of the stack we'll end up getting hit getting like essentially DDOS like it's uh I mean the near blockchain itself can handle quite a few transactions and these are mostly view calls so they're not actually going to be updating state for users who are accessing it which means that it really comes down to RPC load so like we have we have a few applications not actually related to boss that send a lot of transactions to the network and so like there are some pretty battle tested RPC Solutions so like that probably is going to do okay but depending on which one the Gateway like whoever's running the Gateway chooses that that might fail right that's a common one we see in blockchains that get kind of a lot of load as RPC fails like that could be a problem um the data layer in theory could be another problem like if if the app you're rendering the component you're rendering is making some or some maybe like the developer is like oh we didn't want to use the graph so we just built our own API and it's running on some like really small ec2 instance like that could then fail um or just like the Gateway itself uh if it's like again running on a small a small ec2 instance or something so it depends there are ways to do it like near.org for instance like you you could it can handle a lot of simultaneous users but it's because like you know there was they built it in a way to anticipate that because they get a lot of load already there's like you know quite a few people who visit that page on a monthly basis um but yeah smaller like smaller instances of each of those like could lead to lead to some failures but it is possible to build to build these things in a very resilient way these days maybe not like tens of millions of of concurrent users but definitely like pretty substantial numbers especially for for this industry right now serving what exactly oh I see yeah I mean that yeah this is definitely designed more for like kind of like stat it doesn't be static but like Pages were like the dynamic loading is is data I mean you could use a different like it is just the front end code right it's just JavaScript like you could you could like stream content too maybe you're even streaming it from filecoin or something like yeah that would work fine this this isn't basically you shouldn't be is using near to store videos for instance or something that would need to be streamed even photos uh near is kind of like a sweet spot where we because it's a sharded system like we can handle a higher state load than most chains can but it's not designed for like petabytes of data like file Quinn is right like a great solution for that would be like combining filecoin to actually store the video using their new CDN solution to kind of like stream it and then like piecing it together and creating DUI can be done on using boss that would be like the my recommendation for that stack yeah so follow up on that what is the cost effectiveness of storing disappointments on here yeah so it's uh it's like one year per either 100 kilobytes or megabyte no maybe it's a megabyte um so it tends to be like pretty cheap for front ends like most front ends that I deploy and a lot of times like after you deploy the first version when you do updates it's just uploading the state diff um so it ends up being like usually a few cents for most front ends for something really rich if you store the images into stuff like that it can get a little crazy but yeah I would recommend using other solutions for like that media and then just using this for like the front end code like the idea is like Mission critical stuff right like people you want people anywhere to be able to access it like have those pieces there and then like the nicer like images and stuff like that can you know can come from from elsewhere because it's denominated in a cost of near um so the cost effective is now is a few cents employee business yeah it's a good question so I mean the biggest thing is like yeah obviously if well our approach to scaling is like adding more shards uh we don't know how many shards we can add I think right now they're testing with 100 and that's working pretty well and we don't need that many yet um going Beyond there you know it probably there's some kind of like there are going to be some sort of limits that are hit eventually um but I think we've got like the reason that we chose sharding and took on all of the complexity that comes with that is that we believed it was a much more future-proof solution than a lot a lot of the the choices that are made um so we're confident we can scale for a while and I mean the other thing that happens like the price of near where to go up just like the price of eat goes up that can like manipulate the storage prices in a weird way so what we do there is like similar to ethereum he's like you just update kind of some of the uh the like assumptions that are made so that like the the real costs can can either stay static or go down even like whether and that could go the other way too like whether the price of near goes up or down we can kind of adjust the static costs correct that is a great question the uh so the long-term answer will be absolutely the short-term answer today is unfortunately yeah you're going to have to use the packages that we have sort of pre-installed and that's just because of the security assumptions of the VM but that is that is a common request and it's like one of our top priorities is to enable that so yeah yeah we we don't actually the problem we have now is it's like we have to kind of like add them manually and so we get a lot of requests and we don't want to we don't actually have to make that choice for developers so we are I think pretty close to the V2 of the VM that will allow you to import probably most JavaScript packages or at least it will be like way more like the choice of the developer rather than the choice of us so yes soon you will be able to use Tailwind today you're gonna have to use uh style components unfortunately that is a great question um I don't have a great answer uh I would say yeah style components ethers JS you can assume I would look at a few examples um definitely check out yeah like Ave Lido uniswap like some of those just to kind of see some of the common patterns we'll give you an idea we should have a list though I will get on in making that together all right thanks everyone [Applause] I don't know okay how can I get set up here so um all right so that's your name my name is Marcus Ryan yeah okay I'll write it down here oh okay is it okay if I say um working on the graph I know I know I know the instructions foreign yeah if you want to uh they can uh mirror whip you can see the same or or you can just have it um let's see yeah let's just do the displays and just mirror it because that's good yeah there we go okay so let's try that again it's on that screen there we go okay um is that mirror that says mirror yeah no I don't want to do that because I'll be mirroring to everybody no that's not it called rolling video yeah I don't even see rolling video okay I mean I could I can give this a go like this that's fine yeah it's on uh I know right main display and then you just change it to the mirror there we go perfect time thank you it's getting worse I can see it definitely see that man thank you awesome okay and then it'll take it cool I feel like that's about right yeah okay makeup you know how's my hair you know test test one two test test one two test test we're good we're good oh we are good hi hey hi everyone yes I'm Marcus I'm working on the graph I work for a company called Edge and node and welcome to this presentation an introduction to the graph quick start to sub graph development and querying so let's get into it first and foremost oh we got some internet issues there we go let's try that again interesting well we're going to be presenting here that is totally fine I'm sorry there we go and for some reason that's going okay let's keep going all right so if any of y'all want to hop into our hacker dashboard we've got a few different things on this dashboard that would be of interest to you we've got prize information we've got the telegram group also and also this presentation as well as all the repos so we're gonna be doing a little bit of live coding you're free feel free to scan that let's get going okay so first things first a overview of the workshop we're going to go an introduction to the graph a high level overview of what's going on uh when you are getting your data from the graph we're also going to talk about what subgraphs are all right that's really important we're going to go through that we're also going to go through deploying a subgraph and then also we're going to compare queries between two different subgraphs the subgraph that we deploy as well as a well-developed subgraph okay let's get into it first a introduction to the graph so when you go to the graph.com first thing you're going to see is this access the world's blockchain data let's go ahead and parse that let's go ahead and see what that means I want to go all the way down to the smart contract layer first things first a smart contract really is just a bit of data storage that's all it is and if you're looking at this this is a crypto punks example kind of a mock-up where it's just some data that's all it is now if you have this data what about the data in the past what about how that has interacted with other data points well what you're talking about is this type of History all right we're looking at historical data and you really have to understand in smart contract land everything can interact with everything so we have to understand really all those different types of interactions and seeing how really are we able to get that information to you in your dapps and this is really a problem really because the blockchain is Right optimized all right what I mean by that is it's easy to write to the blockchain relatively speaking we're able to write to the blockchain especially with l2s now in a rapid and affordable way now that's really creating an indexing issue where now we have to organize all of this data and when we're here now we have to read that data we have so much data we are sending our information to the blockchain and then now we need to read that who here today has interacted with uh Instagram or some type of social media app on web2 there we go all right have you posted it on Instagram recently okay so that's a right and that was a single right and then with as many followers as you have you know hundreds thousands of followers that's the read and that's the exact same thing we see on the blockchain where there's a lot of reading going on relative to the actual writing that's occurring so in web 2.5 there's a certain amount of solutions for this where anyone here can spin up an indexer on their own they could do it that's totally fine there's other ways to index as well that's totally fine we call those centralized indexing okay and so if you have a data point that you're looking for and you want to get it and it goes to your front end awesome all right that's a really awesome thing however when that goes away your dap goes away all right and that's really really a problem the web 3.0 solution is to have decentralized reading and decentralized indexing from the blockchain and so what you have here is a single data point going to lots of nodes and all of those nodes are able to populate your front end and if anything should happen to any one of those nodes you're still intact you're still good to go and that in a nutshell is a high level overview of the graph we love this so Let's uh think about what this means because is that too too loud there we go we're good yeah Okay cool so what that means is we have a read layer that is amazingly uh we take the advantages of the blockchain and it's decentralization and we apply that to the read layer because the blockchain is very much your writing to it all the time if you're reading in a centralized way well that's a problem because now you have the Web 2.0 type of issues and then from there if you decide to decentralize also your front end you can actually have truly decentralized apps and that's a really powerful thing so to overview the graph Network which is the decentralized network of indexers the world over we have over 450 permissionless indexers working worldwide there's redundancy between them if anything should happen to one another one will pick it up it's fast cheap and reliable and it's a global open API Okay so let's get into sub graphs who here is deployed a subgraph okay got a few people awesome so let's get into subgraphs what are subgraphs why do we need subgraphs let's talk about it we are swimming in blockchain data all the time all right being able to write all of this information to the blockchain all the L2 capacity it's amazing a subgraph essentially is a way of organizing that data you're providing instructions to indexers around the world to say this is the information that I need and I need it organized and I need to be able to query that information that's essentially what a subgraph is that's a set of rules that you give to the indexers around the world and say hey I need the data prepared in such a way that will be useful and queryable okay that is a subgraph so like I said subgraphs are instructions for indexers let's break down the pipeline in a high level overview of what that might look like you might be looking at on-chain data you might be looking at off-chain data specifically ipfs that's currently supported there's also a push to support more off-chain data but right now it's just ipfs you will Define your subgraph in the subgraph Manifest also known as the subgraph yaml you want to think about that as like the rules and overview of kind of the shape and structure of your subgraph from there you're going to give that information a little bit of logic and that is in the mappings.ts file you're going to say hey we're pulling this information in do we want to put any logic on it do we want to actually start to transform it that's in the mappings.ts and then from there we've got this schema.graphql where you can actually have your data in nice easy buckets also known as entities and you can send graphql queries to those buckets and get your data on your front end it'll look something like this all right instead of going through etherscan instead of parsing through you could send a simple query in graphql that's very easily read and from there get your data through an API endpoint Okay so that's a high level overview of the graph we are seeing around one to two billion queries per day there's over 1 000 subgraphs published on the graph network with the indexers all over the world and there's 450 plus nearly 500 at this time okay so if you'd like to scan this feel free I love QR codes they're easy way to communicate where you have learned about graph about the graph protocol and sub graphs and once I see the phones down we will continue going there's a phone there awesome awesome okay nope phone there awesome got it okay okay finally part three let's go ahead and deploy a sub graph all right so if you would like here is the repo that you can star and reference you don't need to actually clone this this is just for reference I'm kind of just getting these overviews of what I'm talking about today um and there's also going to be another repo that we'll look at in just a little bit so once I see phones down I'll keep on going it's down thumbs down almost down cool all right so first things first you're going to want to go to the graph.com if you want to participate with this you're more than welcome to I'll take my time is anyone going to be live coding with me you're welcome to yes no okay kind of sort of okay yes awesome saw some hands also you're going to want to pull up miniscan https colon forward slash forward slash miniscan.xyz those are really the only two things you'll need and then also of course etherscan that would be helpful too okay those are the three tabs you'll need and what we're going to do in this deployment is we're going to deploy the sub graph and then we're going to trace the punk transfer event because subgraphs are optimized to look at events we're going to look at this Punk transfer event and we're going to see it on chain we're then going to see it in the subgraph Manifest we're also going to see it in the logic and then we're going to actually be able to query that in the schematograph cool that is the pipeline we're going to follow from beginning to end okay let's go back and we'll start so like I said we'll need some tabs open first things first we'll go to the graph.com and studio so you make this a little bigger very nice and we're going to create a sub graph and we'll say live at youth Global Water Loop and we're going to be looking at crypto punks all right we're going to be looking at the crypto punks smart contract so what we're going to do make it a little smaller there we go it'll be on ethereum and we're going to create a sub graph now this is the subgraph dashboard we have yet to deploy our sub graph it is not published onto the network it is just something we are working on when we do get to the point where we want to query it this is our development query a URL where you could actually query that in the front end just getting you guys familiar with this you're free to fill out the description information all of this is all great just providing information I'll tell you why this information is important in a minute let's keep on going forward first things first you're going to want to install the graph CLI all right so open up your terminal copy there and paste internet yes no we'll see all right as that's spinning up right there there we go yay awesome so we've got the graph protocol graph CLI installed from there we want to initialize our subgraph we'll copy this and paste it right into the term a lot of copying and pasting that's all it is so here you're presented with a selection of protocols we had neuron earlier so awesome we index on near that's also there for you we have Cosmos ethereum and rweave now we know our smart contract is on ethereum but any evm compatible chain that we also support is through ethereum we Index right now I believe 40 chains 40 41 chains um on and they're some are evm compatible some are not so just go ahead and dive in since we know this is ethereum we'll click on that subgraph Slug it automatically populates from the CLI and directory automatically populates and here we're given all the chains that are evm compatible we know it's on Main net so there it is and then contract address this is where we can start doing a little research so let's go to etherscan and we'll type in crypto punks there it is and we're going to get the smart contract address is that too small that might be too small that's fine we'll be here just for a second and then we're going to go to miniscan.xyz and here I love miniscan it's incredible because you're able to select a smart contract address and find relevant subgraph information really fast all of this information you may need for your subgraph some you definitely do for depending on the smart contract depending on the Chain there's different interactions that you will have depending on what is supported on a certain chain but a lot of that information is just right here do you want the Avi do you want the code start block all of that is here do you want the name it's all here why would you need this let's go back to the terminal and find out we're going to copy the terminal excuse me the smart contract paste it in it's automatically getting the ABI and this is okay sometimes it fails just due to internet issues just do the chain this literally was working all day today and now it's not no big deal because what I did was I have the ABI here so I'll pop this open very nice there we go control a control C and I'm going to pull up a new window and we're going to open folder that's where we are at and we're going to open that up and we are going to create a new file and we're going to list abi.json this is what you do if your ABI is not able to be gathered and now we have it right there right click and then you have the path so that's what this CLI is asking for here and that's oh so close so close copy path there we go there it is okay now a lot of times the start block is also populated but just in case it doesn't populate depending on the situation at the moment you have it right there copy and paste into terminal okay now the contract name subgraphs can index lots of smart contracts all on the same chain all at once so it's important to name your smart contract by its actual name you don't want to just have the demo name of contract because if you have two three ten smart contracts not helpful so we'll go here hey there it is and copy and from there paste a lot of copying and pasting very convenient from the scanner right there from a miniscam now this is the I think impressive thing the most impressive thing is when you actually see this occurring this is the index contracts events as entities any events being emitted remember that little blocked pathway that I showed you where it had subgraph.yaml and it went all the way to the schema.graphql this is where that connection is occurring all right when you just press true right there you're having this scaffold out and it's connecting all the things in the back end automatically for you to look at all the events in historical data that you can query using graphql so that's all doing that right now while this is occurring um let's see come on up any questions so far while this is spinning up question yes so as I'm sorry a single subgraph so that's not there right now we have a single subgraph for a single chain you could index as many different smart contracts you want on that same chain if you have a different subgraph that'll be for a different chain and you can separate it like that you can pipe all those different apis into your front end and work with it like that but good question the second so wherever you want to start gathering information you can do that if you want your subgraph yeah correct yeah the initial deployment of exactly right where that uh a smart contract was initially deployed it automatically finds it for you and um there it was perfect so now we could have another smart contract we're not going to do that right now so we'll say no and you are welcome to run through these steps here I like to go back to sub graph Studio at this point and here which is more copying and pasting super quick super easy you're going to authenticate first things first very nice and you're going to CD just copy paste copy paste and then graph code gen and graph build graphcogen is type safety making sure all those connections that you've built up let's say you make any modifications to your code it's important to keep those connections fresh and then graph build compiles everything and you can read a lot about that in the documentation totally fine to do that we're just going to go ahead and graph Cogen and graph build what has been scaffolded on the back end we're not doing any changes so that's fine and then we're going to deploy now just so you know when you deploy here you do want to have incremental versioning and also when it is deployed you should see the front end of the dashboard also respond nicely there it is and it responded very nicely so the build is completed it has been deployed we have our development endpoint that is active right now it is currently syncing at 73 so it's Gathering more information takes a little bit of time just so you know when you deploy a subgraph for the first time it takes about five minutes before it's queryable because there's a certain amount of caching going on in the back end at five minutes it is going to be active so just be a little bit patient right now though let's go ahead and head back to the presentation as this is getting ready and let's keep on going in the presentation as that's going so where are we right now okay as that's spinning up let's go ahead and do a reference for subgraph patterns you may see these sometimes you may not see these sometimes but these are relatively common and then we'll see if these exist in the actual boilerplate subgraph that we spun up with our graph CLI and then we're also going to compare that to a very well developed sub graph as well and you'll be able to compare and contrast something that's relatively simple that is a boilerplate one to something a little bit more advanced so if you are indexing a crypto Punk if you're trying to gather that you're going to pipe that into an entity and an entity is in the front end really what you're going to be querying so what buckets do you want to create generally speaking you're going to create a contract entity an account entity nft entity trait entity metadata and event interface these are like different buckets that your subgraph will create and pipe the data into and let's go ahead and go back to the actual code and see if that's the case so head back to visual studio code and there it is nope okay so let's look at these buckets right now everyone let's say hey schema.graphql hey these were automatically created for us we have an entity that is an assigned entity a transfer entity a punct transfer these automatically created and these reflect the events that have been emitted from the actual smart contract just for the sake of this demo and just for the sake of being focused I'm going to focus on the punk let's make it big so everyone can see the punk transfer entity let's just focus on that and we're going to trace that all the way into our actual root level of the smart contract so we have this smart uh we have this entity right here this Punk transfer how did this get here how did this Punk transfer entity appear here well remember if you take a one step back from the different blocks that we were just at that went from the schema to the mappings we got to go to the logic and that's going to be in the SRC folder so let's look and see how this Punk transfer event is actually getting populated there it is okay we have export function handle Punk transfer so when a punk transfer occurs this handle Punk transfer Handler triggers and there's the event right there you can see everything light up right there very nicely thank you vs code and an entity begins to be populated and we see this event right here this event params from this is an event right here that is being emitted and the from from the chain is going to The Entity also named from very nice go to vent params two and then that's also going to the two event params Punk index that's also under the punk index also we have event Block events also carry block information that's carrying the number it's all just being piped right into this entity and it's being saved all right that's all that's happening it's simply coming from the event and being piped into our entity right there the entity is being saved I'm gonna slow down we've got a few minutes any questions so far am I going too fast are we good we're good question yes yep yep it's just a way of looking at the entity and saying hey this is how it's organized I'm going to send a query to those entities yes great question we'll get to that in just a second so here we are we have our Handler that is we're going from the front which is the schema now we're going one level deeper to the handle Punk transfer how was this actually defined well that was in the Manifest let's go back to the root and we'll go to the subgraph.yaml which is the Manifest and this is really how your sub graph is defined it's really important information we have everything we put in the CLI the address the crypto punks Market the start block important information I'm not going to go over mapping it's a little bit right there but let's look specifically for the event handlers right there and then there it is the handle Punk transfer and it's looking at the event from the smart contract indexed uint and in we have a uint right there we have a few different informations right there the address that's really all the way to the front of this diagram that I had a second ago let's go back here and here it is so we just went you could look at this from back to front or front to back and you'll need to do that regularly when you're developing on subgraphs because you'll be interacting back and forth so let's keep on going and let's look to see are there any immutable events we're running low on time we're going to keep on going this is something that you'll see regularly immutable events are important for just keeping logs of straight up blockchain information if it's in blockchain information you should keep it immutable because you're simply just keeping a log that's just something you should look into aggregation entities entities that have a lot of information from various sources on the blockchain you want to have on a single entity like a contract might have information that is being aggregated definitely have that in there and linking entities to have a little bit more power on the front end you could link entities using one to one or even one to many or many many relationships and also reverse lookups you also want get or create helpers because assembly script needs null checks just check on those and there's a few other tips and tricks so document your schema well let's go into that really quickly as well so we could see how important that is when you document your schema well that allows people to really understand what they're querying and let's go ahead and go into a sub graph that is now published on the graph Network that is well designed because remember the graph network is not just indexers the graph network has subgraphs those subgraphs are also part of a Marketplace let's go find a subgraph that is also indexing the crypto funks smart contract in a more built out way so we're going to go to the graph.com and explore and you can see all of the subgraphs that are currently active we just spun up a subgraph and we haven't published it yet but now these are all published and what we want is a crypto punks subgraph that is currently gathering information there we go so we can see a few different crypto Punk subgraphs which one do you want to choose generally speaking the one with the most signal on it generally speaking that is being incentivized by the marketplace itself that is the GRT utility token that is incentivizing this right here so we're going to choose that one and you can see it's gone through a few different few different versions We can go into all of this but what we really want to do is go to the playground and also from here we want to go let me go back we want to go into where is it there it is the actual GitHub repo all right so we have the GitHub repo we're seeing how this is being built and we can also query it let's go ahead and take a look at the GitHub repo and see here the schema.graphql which is really what you're querying you're sending your query settings these are the buckets remember that okay so remember we had the punk transfer entity before we were tracing that well this developer here he had the kindness to actually put in the actual things you're querying so if you're looking at a let's not look at interfaces let's look at an entity here we have an aggregation interface right here where we have an account and there's lots of different properties on this account it's not out there and he's done such a nice job with the mappings and also with Gathering blockchain data and organize it so well that when you type in a query graphql query to the account entity you know exactly what you're going to be querying do you want to know Punk transfers by account and you put in the account number you can get that right there it's very nicely well documented from this which is of course you know we don't have documentation on our actual not ABI Json we don't have it on our schema.graphql because this was just boilerplate but when you're building out have some nice documentation tell developers what you are actually doing and that helps them from there let's go ahead and go to the next part of this presentation where there we go we can compare queries with two different subgraphs we have our boilerplate subgraph that we spun up and we have a more advanced subgraph that we spun up and then from there well what type of questions can we ask to this subgraph what can we ask some questions for this base of sub graph sure we could or could we ask some more advanced questions and I if you guys want we have this presentation right here with all of these questions where you could practice and see okay well if I could look at the schema and trace it all the way back to the blockchain that would be helpful on your subgraph or if you would like to use a more advanced subgraph some of these questions can be answered by the more advanced subgraph let's just go ahead and do the first one just to do that and then you guys on your own are free to go through this on your own tell me about crypto Punk number ones transfer history so what we're going to do is go to sub graph studio so we have this queer setting up right now and we'll go here on the right and this is our little Explorer right here we could send some test queries we're not of course going to the API endpoint and remember that punk transfers event that we're looking through from the very beginning let's go ahead and look at that we have the punk transfers event and what we want to do is we want to go ahead and let's go ahead and look at Punk transfer ID we want the punk transfers there we go punk index and first 10 where the punk index is equal to one okay and we want to see the punk index which is the first Punk zero zero zero zero one right there it's the first ten right there and we want the punk index we want the ID we want two we want from let's see where it came from the time stamp and why not let's get the transaction hash two demo Gods there we go oh dang it let's go ahead we've been having that happen there we go so I pulled this up earlier we have an internet connection issues sometimes and here it is we have this Punk transfers Punk index number one where I have the ID and then two and from and the block time stamp all the way through all the way from the chain and then you're able to organize that at the front end there we go okay that's the end of the presentation everybody [Applause] so the big difference between the graph and just using like an RPC provider so that information is that you graph and get historical information all the historical information from wherever smart contract had been deployed and then all the way through it's yeah that's just bringing it right from the front yeah sure sure so when you have created a subgraph that you really like and you're like man this thing could actually have some legs you are going to publish that to the network we just deployed a subgraph today which is great publishing it actually shows indexers around the world that hey this subgraph is valuable and then you signal that with curation in the form of GRT utility token so that tells indexers out there they could be incentivized if they take action by getting a small reward from that actual signal and that's how a lot of the economics Works within the graph there's lots of different types of this subgraph is well built it helps if developers make their subgraph and make them public so different indexers can say oh that's you know different uh people can actually actually not just indexes but curators and delegators different participants can just partake in the entire ecosystem um so that's being run on actually centralized indexers that the graph has and it's more of a Development Area and then when you're actually finished with developing you already publish you're able to go out that's why it's a free indexing service you're able to actually use that development query endpoint feel free to play in there and get it nice and ready if you're hacking go ahead and use that but when you're ready to publish then it goes down to the network yes so when it's on the when you've deployed it through the subgraph studio and you haven't published it it's free you're free to go ahead and query you're free to use the development API endpoint right there that is for hackathon that's four people right away when you're ready to start participating in the network you publish it to the network and you can actually start earning rewards yourself you're able to start curating you have to start participating in your own way that's it okay perfect [Applause] thank you I got through it all I was tough thank you very much um thank you all right that seems to be working um awesome [Applause] all right guys uh thank you very much very happy to be here my name is Martin I'm from Quan stem we are a smart contract uh security Auditors so you know I'll be talking about best practices for smart contract development and best practices for developing smart contracts in solidity specifically the talk is aimed towards beginners so you know if you are very well worth Solid V programmer uh probably you will be bored in here uh but you know hopefully for the rest of you I will be able to pass some good notes so the agenda for the talk at first I'm going to introduce solidity as the language and the evm just so that we are on the same page of what kind of execution environment we are talking about then I will be talking about some specifics that uh solidity as a language has over other languages and then you know I will be covering the best practices those do's and do not so introduction to solidity and evm uh you're at a ethereum hackathon right so you probably have heard the word uh ethereum virtual machine before ethereum virtual machine is a virtual machine that is powering the ethereum blockchain and that is powering the execution of smart contracts on ethereum blockchain it is a stack based machine and when you develop smart contracts uh pretty much what you're doing is you know typing some high level programming language that gets compiled to byte code and that bytecode then eventually just contains op codes that somehow manipulate the data on the stack so we have you know op codes such as ADD which adds two numbers on stack we have op codes such as call that sends transactions we have Optical such as load or write for writing and uh you know reading from the memory or storage of a smart contract and so on then the evm uses something called gas to measure how much computation was carried out and builds the users who triggered the computations for that right it's for a very good reason because all the miners or validators in the network will be interpreting those transactions and will be running those computations and we don't want anybody to be running you know computations on our machines for free right so that's why gas actually exists and the actors on blockchain are identified by addresses we have two types of actors one is the general people uh who uh transact through something that we call externally owned accounts and then we have Smart contracts the difference between smart contracts and externally owned accounts is that smart contracts do not have private keys or nobody knows what those private keys are so smart contracts cannot sign or initiate transactions everything comes from people's own externally owned account for which we do have private keys right this is how we have created and generated those accounts so this is kind of the setup that we are going to be talking about now the language that we use to develop smart contracts I already mentioned is called solidity so solidity is an object oriented statically typed language it's similar to you know JavaScript Java C plus plus or anything of this similar category but it is specifically catered towards developing smart contracts so it provides us with data types that we will find on blockchain right those addresses those unsigned ins and bytes and it will provide us with blockchain specific functionality so for example functions for sending and receiving ether can be controlled through Primitives of this language right unfortunately compared to other languages that you might be used to it actually has a limited standard Library so it doesn't contain a whole bunch of things that I will be talking about a little bit uh you know later that you might be used to and it also has many blockchain specific gotchas that you know other languages do not really have or are not relevant in other settings so let's take a look at something that is kind of sort of special to solidity first of all solidity similarly to other programming languages contain some access modifiers that allow us to indicate whether certain variables or functions should be accessible from you know other smart contracts right so it has something called keyword private which if you are used to uh developing in other languages just signifies that external classes or external actors cannot access our data right so this is the first gotcha for solidity anything that is marked as private really means that you cannot query it directly on chain but it doesn't mean that that data is private you know at some point it made it on blockchain using a transaction the transaction can be queried from the archive nodes and any participant in the world is essentially able to derive what the particular private variable currently holds as data so even though stuff is sometimes marked as private it's actually not truly private private only means that you cannot query it on chain it's definitely possible to you know learn what is in those variables uh the next special thing that's already has over other languages is that stuff that allows us to interact with blockchain and reference the blockchain context itself right so we have context that relates to blocks at any point we can query these uh environment variables that are initialized with the block number time stamp and hash and then we also have uh some environment variables that relate to the context of a transaction and message itself so who was the initial person who sent the transaction what was the gas price that was you know allowed for this particular transaction and for this given message that arrived directly to a Smart contract who is the sender what is the value that is being sent along with this message what is the call data and so on okay so this is something that we have available in solidity what we do not have available in solidity over other programming languages is floating Point arithmetic and floating Point numbers that doesn't exist at all solidity only has integers okay so that comes uh in question when you are dividing or when you actually want to use those floating points numbers right so all division in solidity will always be integer devotional division so one over two will result in zero and similarly and analogously other divisions will behave and when you need to uh somehow have access to floating Point numbers you essentially have to simulate them right so what we usually do in solidity is that we say okay we will work with really long numbers and past certain point uh all the zeros past this point will be dedicated to representing the decimal positions past the you know floating point right so uh that's something that is very interest important to remember whenever you work with something special like ether you are always working with super long uh decimal numbers okay so solidity doesn't have floating point another thing that solidity doesn't have is random number generators there is no way for you to go and say hey smart contract generate a random number people really like having that functionality right because we want to develop games we want to develop lotteries we want to develop stuff that actually has some Randomness in it but unfortunately it doesn't exist and again it doesn't exist for a very good reason because we know that the transactions that will be executed will be executed by a whole bunch of Miners And validators in the internet right and they have to be deterministic they have to have deterministic results so that everybody arrives to the same state of the blockchain so therefore generating random numbers is not a thing in solidity so what people very often try to do they actually try to exploit those environment variables that I was talking about a little bit you know earlier so what is my blog hash what is my transaction hash what is the current timestamp and use that as a source of Randomness but that is not really random right and it is also predictable so it's actually wrong to be using that for Randomness and if you at some point require using random numbers in your software development what you need to do is actually use a random number generator in the form of oracles which I will be talking about a little bit later as well so we don't have random numbers and we need to remember that I already said that smart contracts are accounts that have some code associated with them but they do not have private keys so you know another thing that you might want to do but will not be able to do is uh schedule some transaction and have it be initiated by a smart contract that doesn't work smart contracts cannot initiate anything it's always people and externally owned accounts that actually can sign and create transactions on this particular slide I have two words that you know I want you to understand for the rest of the talk so one word is called immutable it means that once you put something on blockchain it stays there forever you cannot change that and you cannot delete that if you work with immutable data it will just be there and it will not change even if you work with data that is not immutable and you somehow explicitly allow for your smart contracts to change and you know for these pieces of information to be somehow replaced with other pieces of information the history will still be available as well so you know just the sheer fact that you've put something on blockchain that you've changed it doesn't mean that nobody will ever be able to see what was in that variable in the past the other thing that I want to uh you to understand is atomic execution so what do we have on ethereum is transactions and those transactions are being executed in an All or Nothing fashion and nothing can interrupt the execution so there's nothing like a processor where you would have multiple processes and you know sometimes this guy gets the course sometimes this guy gets the core and that's you know somehow interleaved and and uh preempted that doesn't exist transaction starts running and it finishes all the way to the very end unless it reverts if it reverts nothing ran it rolls back all the state okay so that's the property of the runtime that we are having so transactions are atomic the other thing that we do not have available and we would very often like to have available uh is access to external data so you might want to develop a smart contract that for example provides entrance for delayed flights right and a normal web 2 developer the way how they would think about such a system is okay well I need a system that will query some API that will learn whether my flights were delayed or not right so sometimes developers try to stuff access to API and internet into smart contracts but there is no such thing it just doesn't exist you cannot query the internet from uh smart contracts smart contracts are only capable of querying data that is already recorded in some other smart contracts and so companies and ethereum Community developed something called oracles where oracles are smart contracts designated specifically for this purpose they are made to record some kind of information and then communities and external actors they record this type of information into smart contracts so if you want some specific data you have to find an oracle for it okay and then you can query that oracles API so this is kind of the situation that we are at with solidity and now I will be going through a very long long laundry list of you know what you should be doing and what you should keep in mind when developing your smart contract so the first thing that I want to cover is check effect interaction pattern so you might be able to Google whole bunch of lists with best practices for developing smart contracts uh in solidity and every single list will contain this check effect interactions this rule specifies the order in which you should be making actions inside of your functions so here I have a snippet of code it has two functions one is called bad withdraw one is called good withdrawal both of these functions have some state check right that's the require at the beginning then it applies sum or they apply some changes to the state that the line where I am decreasing the balance of the message sender so in the good withdrawal that happens raft right after the required check and in the bad withdrawal that happens at the end of the function and what is in between in the bad withdrawal is the interaction it's the transfer of a balance that is actually making a call all to uh you know the message center right and that actually transfers the execution power to the message center because when we send ether in solidity uh what gets invoked are some special functions in smart contracts so in the bad withdrawal we are actually not respecting this pattern uh check effect interaction that interaction should come at the very end in the order that I have it in the good withdrawal and the reason why this is really really important is a very profoundly known vulnerability called re-entrancy so what can go wrong if you have effects sorry if you have interactions in the middle of an execution somebody in the middle of that transfer of eth can come and they can make another call to your function to your bad withdrawal and this pattern is designed so that in 99.9 of cases it actually protects you from such you know defects so whenever you're doing stuff whenever you're interacting with other contracts the interaction comes always at the variant okay after you update the state the second uh item that I want to cover here are pull patterns and push patterns so what people want to very often do is somehow give something to other people to other addresses and accounts on ethereum right so imagine that you have some Treasury and the treasury wants to distribute some Rewards or some nfts or something like that so you have two options either you actually do it actively you are the treasury and you are going to dish out the gas and you are going to pay for transfer of the asset to every single person right or you can adopt the philosophy where you say you are entitled to get something from me but you have to come and you have to grab it in such a case you will not have to pay gas for transferring the asset to every single person right the person came initiated transaction they are paying for the gas on their own so we always prefer pull patterns over push patterns the reason why we actually prefer pull patterns over push patterns is not that push patterns would be way too expensive that's usually the secondary reason but the real reason is that the push pattern can actually fail because if you imagine that you are transferring ether to a Smart contract to whole bunch of smart contracts one of these smart contracts can just say no I'm you know rejecting this if I don't want it I'm going to revert your transaction and if you remember my spiel about Atomic transactions that means that nobody is going to receive the ether right because the entire transaction is going to revert and is going to be rolled back so that's the problem with the push patterns they have so many so many interactions that can actually dose your system so we prefer pull patterns over push patterns the next thing that new developers in solidity are very confused about is the difference between assert and require so both these keywords serve the purpose of reverting a transaction if some kind of a condition is not fulfilled but they behave differently with respect to refunding the gas to the transaction initiator so in the case of assert if you are asserting that some condition holds in solidity if the condition doesn't hold your transaction will be reverted but all the gas that was provided to this transaction will also be consumed the invoker of the transaction will not receive anything back on the other hand would require the person who invoked the transaction will receive all the gas that is left back and that kind of drives the difference between the two functions we use assert to make sure that some conditions some kind of state that we are assuming uh holds so you know if you're assuming that your system is in some particular State you check it with assertions and if one of those assertion fails it means that either you have some bug in your smart contract and that smart contract got to a state where it should never never work or somebody's actually attacking you right they found some attack vector and they decided that they will use this attack Vector to bring the smart contract to a state where it shouldn't be and shouldn't operate and in such a case it's actually very okay for you to burn all the remaining gas for this transaction and say fine we are done we are just going to revert in here right on the other hand require is used to check results where you fully expect that the result of an external call to somewhere might have failed you know you called some smart contract the smart contract was like no this is this is I I won't do that and you'll say yeah this is fine this is a perfectly fine outcome maybe I don't know I didn't provide enough tokens I didn't have balance or you know your smart contract just like rejected and that's okay so require in the cases where we are anticipating a possible failure and just wants to say no uh and assert in cases where we are making sure that we are in a good State before we do anything cool the next thing that I want to talk about are modifiers so this is a special feature of solidity as a language you will not find you know custom modifiers somewhere in Java you might find something similar in Swift in the form of extension but essentially modifiers allow us to add code that will be executed before or after or both to a function here I have actually an example of a modifier I have function non-rendered non-rent where I do something and it's annotated with that word lock right and lock is a modifier that at the beginning acquires a log so it checks that the lock is oh sorry sorry a log checks for us that nobody else holds a lock right and it requires a log then I have that underscore and semicolon which says execute my function and then in the end we release the log so those are modifiers what people started doing is uh the modifiers they are originally intended for checking stuff right so this this that would be where you do your uh checks in the checked effect interaction but people actually started stuffing a lot of logic into these modifiers we see it very often in audits what it results in is a spaghetti code if you go back to your you know intro to programming courses and the languages that contain the go-to statement you've probably heard many many times do not ever use go to because like it just you know breaks the flow of the code and it results in spaghetti same thing happens if you start stuffing the modifiers with too much logic the example that I have in there this is the only acceptable example of where you can put some right logic and some side effects into a modifier there is very little of it it's literally three lines of code so that's probably roughly the maximum and the effect is not permanent right this modifier itself it logs and then unlocks so it's predictable so do not put too much logic in your modifiers uh I'm going to skip this slide because I want to get to some more interesting stuff so you know for this slide only remember if you want your smart contracts to be able to receive ether you have two options you either can Implement function called receive or function called callback or both of them and there is a difference when these functions get invocated so look it up into documentation if you do not know the one gotcha that I am going to definitely mention in here is you can never assume that your smart contract has zero ether balance even if you do not Implement these functions so even if you say hey my smart contract can never never accept ether it is absolutely possible to force send ether using instructions called self-destruct so never make an assumption that your contract has a zero balance unless you actually check it directly in the code okay uh here is a slide about pragmas so pragma declares for us what kind of version of solidity we are going to be working with and what kind of version of compiler we are going to be compiling these high level words that are very similar to English into bytecode right so that's that like line that I have there in the example underlined we can declare pragmas in two possible ways we can either declare a pragma that is fixed version that's right here 0.8.15 or we can put that like little carrot character in front of it or the greater sign right which allows floating number of floating pragmas which uh essentially mean that I will be able to compile this code with anything that is 0.8.15 or higher okay so best practice here is always lock pragmas of your smart contracts and the reason why you should be locking the pragmas of your smart contracts is the software development life cycle so imagine that you're developing right and you're working on a big project and you're done and then the rest of your team is not done and you're just waiting for one to two more months for the rest of the team to be done and then maybe audits to happen right eventually somebody is going to come and will want to deploy your code on blockchain but within that time span those two months three months however long this took it's totally possible that the compiler has changed right that you know two new versions actually came out and so then when somebody starts deploying your smart contract it's totally possible that they compile it with a different version of the compiler then the version that you actually have tested it with so the code that ends up on blockchain is different from what you've tested and that might be wrong and yes compilers do have bugs they get fixed all the time but the way how you should keep up with your pro uh with your compiler and have it be up to date is by declaring fixed pragmas and then updating them deliberately every once in a while uh I'm still running out of time here so uh let me maybe mention something about timestamps I had a lot more slides but we will not be able to cover that that's fine so uh using timestamps in smart contracts for any kind of logic and decision making is an anti-pattern when we were in the ethereum proof of work situation we would have multiple miners right they would be trying to solve the proof of work puzzle and at some point they would be successful and they would start propagating these blocks throughout the network through something called gossip protocol well the gossip protocol it's a peer-to-peer communication protocol it has some latency right it takes time for me to produce a Blog and send it all over the world to the other side so this network it admitted tolerance in timestamps to roughly you know 15 seconds so me as a minor I would always be able to push the timestamps a little bit to the Future a little bit to the Past whenever it was convenient for me now this is no longer the case because since ethereum transitioned to proof of stake I'm not able to do that anymore we have a fixed interval of 12 seconds where every single block has to fall into right so timestamps are predetermined but there are many chains in the world that still do not have predetermined timestamps because they do operate on some kind of proof of work system and they are Forks of ethereum so never assume that timestamps are not manipulable and the good rule of thumb is you know think about also tolerance for yourself think about those 15 or even 30 seconds if you're smart on track can operate with 15 or 30 seconds tolerance then your usage of timestamps is okay if it cannot and if you required the time that it got reported is absolutely accurate then you're doing it wrong okay so very careful about timestamps uh all right looking at the clock 10 seconds left I'm gonna stop right here uh if you have any questions please shoot them right now or find me or yeah I'm sitting in the back after here at hackathon we'll be happy to help yes uh do we have some public space to pull slides I do yeah um okay okay uh or grab my contact I will send him yes uh so Muhammad over there in back had uh some talk here at the beginning and we brought some T-shirts so we tossed them in these packages in these on these tables and those are the three t-shirts that are left so you should grab some and wear it all right thank you [Applause] one two three four all right okay oh one two three four one two three four one two three four yep all right we'll get started um [Music] hi everyone uh I'm Stan Lee I'm from uh notice chain specifically nurses Builders ecosystem Builder team foreign so uh uh yeah I like just the first status to introduce like the prices we have for uh E4 loo so we'll be awarding a total of uh 20 000 USD for the use of knowledge chain so we have uh in addition to our like gold silver and bronze price we also have like different tracks so base best AI project or another chain will be and we also have best project on Hashi and lastly best project on safe yep so I'll just be going through what it's called is know this chain why and how and also going through a bit on what snowsis Builders and it at last I'll just introduce Hashi so what is know this chain so now this chain is a level one uh proof of stake based evm compatible chain so it utilizes a dual token system so for X9 for guest fees and gno for staking so the X9 token is a USD pack token so it's a stable coin there is a derived from die on ethereum so that makes it a uh possible for the transactions to be very cheap because with 100 you can perform as many as 100 000 transactions or more and for another chain is also Community powered and developer Focus so anyone in the world can become a validator on a chain so the go what's the mission of uh notice chain so knowledge chain aims to be the most decentralized uh blockchain we already have the tools actually to measure the level of decentralization as shown as the screenshot and and wise now this chain is more suitable for this goal is currently because we have over 129 000 validators and it's still growing every day and the barrier of Entry to become a validator you know this chain is very low so one knows uh General is all you need compared to like 32 if for ethereum and now this chain also tries to be accessible for the types you know through like a straightforward user onboarding experience so the key priorities of knowledge chain is uh like I say decentralization we want to have a resilient uh backbone for and we also want to have an intuitive related experience for anyone who wants to come and validate for another chain and we also provide a seamless and accessible onboarding this is a process for users into the knowledge chain ecosystem and lastly we also have a growing ecosystem of tools and infrastructure to support depth dials and Etc on the system so uh just to introduce like what is notation I was using cultural like why so uh know this chain with over 129 000 validators it is the third most decentralized chain so after Bitcoin and ethereum and our speed uh position is fast with average block time of 5 Seconds and getting started with noises change intuitive and cheap because we have affordable transaction costs and lastly because fee signs exercise stable coin we have a notation stable uh cash transaction because the cost is not susceptible to Market volatility so this is the current state for nurses chain so this is derived from this Matrix so we have uh you know 237 000 active accounts with over 5 million transactions and 129 000 validators with uh 14.9 million dollars in third deposited USD and for validators who are validating for another chain we also have a year of 14 points six percent so and this is another incentive for validators who want to validate foreign yeah so why developers choose notation because it's user friendly and uh another chain is accessible for everyone and anyone can actually interact with your project easily it has also a strong ecosystem of budding or ecosystem of excelling projects tools and resources and we also have a grants program by Northeast Builders so we also allow public good projects to apply for ecosystem grants and through nurses Builders we also provide project support So projects built with know this chain can actually hit us up and they can receive support for marketing liquidity networking and more from the nurses Builders team so this is a summary of our ecosystem at a glance so this was taken in December so yeah from then we still we are still growing so yeah so I'll just go through like how to build uh for nurses chain so so now this chain is a evm compatible chain so anything that you have developed for for example a smart contracts that we developed for like ethereum can be easily for you over to know this chain uh you just have to check out this uh RPC event Point endpoints and alternatively also can also Auto config your miramas wallet you know by going to this uh uh chain list where we have like a one link setup yeah all this information will be available in the docs also yeah so this is just a uh for your consideration and like I mentioned nurses chain is 100 evm compatible means you can actually use all of the DM tools development tools that you use on ethereum or knows this chain without changing anything in fact you can take a smart contract bill for ethereum and deploy another chain without much hassle so here are the useful resources for know this chain so we have the first system notice the io so it's the main website and provides a quick overview of the nurses chain we also have dogs.nosischain.com so it's the entry point for all like documentation for another chain and nurses Wallace will just list the support wallets from this chain now this faucet will allow developers like you to actually get a small amount of X die to deploy your projects and yeah for users who like to validate uh for nurses chain after this hackathon you can actually visit validatednosis.com and we have an interface for you to actually learn on how to validate for nosy chain so yeah I'll just go through like a quick overview of what's not disputers so I'm from Melissa's Builders so we actually provide tools for users and developers to get on board on position so yeah our tools are on the notice the builders slash tools and we also have useful information for developers users validators and we also have community events and yeah all of these are here and uh all of you can check out and for projects who like to collaborate with us or you can actually reach us out and yeah we will try to meet with you and yeah and provide as much support as possible so yeah let's switch gears uh today I'll still be going through Hashi so so Hashi is a new project launched by noses Guild which is a cross chain uh protocol based on additive security so Hashi is the hash Oracle aggregator for cross chain communication based on additive security so multiple inputs and multiple oracles so at this core Hashi is a hash Oracle aggregator and it allows developers to build what uh or in course right hole so redundant array of hash oracles so the main goal here is to distribute trust for bridges on the mechanism level uh where essentially you don't have to trust a particular individual Bridge mechanism and allow users to set up a layer of industry for their systems so why Hashi so Hashi was created by the granosis skill team because there were many security incidents involving uh security incidents related to bridge exploits so in 2022 that's more than 2 billion dollars worth of tokens they are lost due to bridge related exploits so four of the five top experts on the red news leaderboard are all related to bridge and because of this there's no single Bridge implementation that is 100 secure so we shouldn't uh building Securities you should not be building security critical systems that solely depend on them and at Bridge designs have also you know some trade-offs whether it might be due to cost security or auditability and most important thing to take away is that systems built on top of bridges get hacked and get aspirated because they have put all their trust into individual Bridges uh that eventually get exploited so for Hashi essentially what we want to standardize at the lowest level is which is the block header so in addition we want to be modular and agnostic uh to the underlying mechanisms by implementing right whole so what rifle is is a redundant array of hash oracles so let's say you have a critical piece of data you will not want to save only this data on a piece of a hard drive so ideally you want to create multiple backups of this or you can create a raid so in a computer terms you'll be a redundant array of any specific this and so when you have multiple this running in parallel so if in the case that any data is lost you you will actually not lose any data so like any redundant systems rate can also have its own trade-off so in terms of speed versus cost versus redundancy so Hashi system is like sort of rate but for a bridge oracles so in Hashi we decided to optimize for security over costs and speed so Hachi will need to move as fast as the slowest Oracle since multiple Bridge articles will have to report the same hash in order to consider the hash valid because of this robustness and security it's definitely going to improve yeah but at a cost at an expense of cost and speed so here are the main components that the team has built and we are at the same time we're also looking for other people to others to build as well so we are very interested in applications such as token Bridges government Bridges and nft bridges and yeah so I'll just go through the architecture overview of Hashi so on the left-hand side you know starting from canonical example we have a token Bridge contract that wants to ultimately mean tokens at the destination chain so on the search chain it's going to send a message to the storage and that message is going to be reported to a variety of different mechanisms into the destination chain so in this case you can see that uh we have this AMD reporter and remote reporter that's reporting to a very a variety of mechanisms into the destination chain so at the destination chain each of this mechanism is going to essentially validate the message independently and the results from each mechanism is going to be aggregated by Hashi so Hashi will be at the end here and uh so the token British country will actually automatically request from Hashi using a hashtag Associated either with the message ID or block ID and if they all agree with each other it will then allow tokens to be minted on the destination chain the the core contracts for Hashi uh is kind of stateless and very unopenated way of occurring for multiple Oracle adapters and giri giribashi is the kind of government governable extension to Hashi that allows you to have an honorable contract we can Define explicitly which set of adapters must agree for a given hash for the system connected to consider it valid so systems are built on top of this will also want to leverage things like storage proofs reporter contracts for broadcasting and then executing messages based on the hash and then relays for listening to three events on the origin Channel reporting hashes are triggering corresponding destination chain so for hackers who I like to build with Hashi so what to build with Hashi so we like to see people working on its adapters like Clan based one and we'll have love to see kind of optimistic bridge and community-based bridges so diversity is kind of the key here and we also love to see contracts that check for local proofs for some events or storage on the origin chain we also like to see alternate implementations of girigiri Bashi so right now it's a relatively kind of simple aggregation Rule and we'd like to see a different governing rules or different aggregation rules and lastly we'll learn to love to see things beyond our Hashi so like token Bridges nft bridges government Bridges or other novel things that you know we are not thinking about yeah so here are the resources for Hashi we have the singular wrapper repository in GitHub where you find all the information that is related and uh and get you started and we have the nurses Guild team has already implemented adapters for nurses A and B from home and connects and we also have deployed the contracts you know on a girly shadow and yeah just to summarize again these are the prices that we are giving out so yeah that would be it thank you for this uh listening and all the best [Applause] for uh for nurses chain for developers you can use if you go to dogs.nosis dot IO you will see uh there's we have also like a test net called Shadow and if you would like to deploy your contracts on Shadow you can actually visit the faucet uh let me bring up the faucet link yeah noticeforset.com and you can actually retrieve uh you can actually get like One X die in a shadow for you to test out yeah but if you want to test out a minute you can also get the X5 from the faucet as well yeah so yeah and the transaction cost is not very high so actually yeah you can yeah but you you can try on Shadow first yeah so for like uh any if you have any questions during the hackathon like uh you can actually hit us up on the if Global Discord and we'll be there uh to support the hackers yeah and also like for for hackers who like more X die for deploying their uh smart contracts you know just hit us up man we just send it individually yeah uh thank you guys have a nice day thank you you still have one more Workshop uh ah all right testing testing testing testing awesome sweet I do tend to talk louder like when I'm actually presenting so cool awesome anybody foreign I don't need the pet work let's get started we'll get started now and my medium well becoming thank you all right hi everyone I'm Ian I also go by Penryn on Twitter and telegram that's why my pseudonym's up there instead of my real name so I do developer relations at worldcoin technically tools for Humanity the corporation supporting the world coin ecosystem and I am here to give you an overview into our Global proof of personhood system how you can use it in your app to know that your users are unique humans doing something only once without having to know anything about which unique human they are so it's very privacy preserving but also you know great to know that your use just not a bot so I'll go over what world ID is I'll go over why worldcoin created it I'll go over what you should do with World ID and most importantly how you integrate World ID into your hackathon project or even later into an app that you're working on after this hackathon so start World ID answers the question how do you know who or what is a real and unique person right worldcoin started out as a project that wanted to give everyone in the world a little bit of cryptocurrency to introduce them to this digital economy but in order to do that fairly and effectively you basically have to solve the Civil resistance problem right you want to make sure everyone who's claiming worldcoin is a real person and you want to make sure that they only get to claim their fair share so for that we built World ID World ID is built to be private right so we don't have to collect any information about who you are we never ask for names emails I you know government ID anything like that it's designed to be inclusive right so that as much as possible of the global population can sign up for World ID and it's meant to be robust right each person only gets one account you can't have someone with 10 accounts or anything like that and there's a couple different ways that we wanted to a couple different ways we looked at doing this proof of personhood right email or phone is like the weakest possible version of this I have multiple emails I have multiple phone numbers it's great when you just want to make sure like all right did they at least have to put in some effort to try and create multiple accounts here but it's not super useful when there's a big incentive for someone to make multiple accounts we looked at doing kyc of official government IDs but less than half of the global population has a digitally verifiable government ID and for us that meant that it wasn't inclusive enough we looked at web of Trust Systems right I'm not going to name any names but existing web of Trust Systems really don't work that well when you have an initial trusted set of you know 64 or a thousand users because in a web of trust system every step you take past that initial core trusted set is a less trusted profile right and when you're dealing with trying to sign up the entire global population and your initial trusted set is 64. you get really far away from that initial trusted set and it becomes a very gamable system so that leaves us with Biometrics which initially sounds scary but we can do in a privacy preserving way and I'll explain how in a little bit we looked at fingerprint face scans Palm scans but the problem with all of those is that they simply just don't have enough entropy to distinguish unique humans at the scale of humanity right with face ID or Touch ID on your phone Apple can distinguish about one in 30 million people which sounds like a lot but at the scale of 8 billion isn't right and that's because that's for authentication they want to check is the person in front of the device now the same as the person who's in front of the device during sign up and the odds that some random person who steals your phone is the one in the 30 million who would be able to authenticate as you is really really low and it works efficiently for that use case but for us we have a different use case we're trying to distinguish are you unique from everyone else who's ever signed up so we need to be able to do on the scale of one in a billion or higher so 1 in 30 million that face ID or touch ID can do just doesn't cut it for us and the other end of the spectrum with Biometrics is DNA right lots of entropy lots of data but it breaks the Privacy there's a lot you know about a person just by having their DNA right you can tell what race they are what sex they are and those are things we don't want to know about our users and it's also just generally really invasive so that one was thrown out as well but we settled on Iris recognition your iris has a ton of entropy in it it's something that's non-invasive for us to see it's something that to get at high level or a high level of detail it requires your attention and your focus and inherently than your consent and it's very very unique right even identical twins will have very different irises so it's useful because you can't tell a lot about who that person is just by knowing what their Iris looks like additionally Iris recognition has been studied for decades you also all probably heard about the Apple Vision Pro they use Tech quite similar to what we do but again they use it for authentication rather than proving uniqueness so the level of detail that they're getting with the Vision Pro isn't going to be sufficient for say signing up for worldcoin so then when it comes time to how we do these Iris scans we looked at phone sensors right phone cameras are great but they're not good enough to distinguish one in a billion people we looked at off-the-shelf Hardware if any of you are familiar with clear at airport security in the U.S it uses Irish verification but for us those still sometimes didn't have enough detail for us and additionally it wasn't a trusted environment so it became really tricky to like actually trust that that Hardware was doing what it was saying it was doing so it left us with developing custom Hardware and if any of you have ever built Hardware in here before you know that Hardware is hard it kind of sucks but it's what we had to do and frankly I think it's kind of fun so with that I introduce you to the orb the orb is the device we use to identify you as a unique human it does this by taking photos of your iris Computing an iris code on the device and comparing that Iris code to all the other Iris codes that have been scanned and can verify that that Iris code is unique today we're confident our algorithms can handle one in a billion and they're always improving the orb has been in development since before covid so early 2020 it's gone through lots of different revisions as you can see here um we started out with two cameras one for each eye but eventually moved to One camera that can actually move a gimbaled mirror to see both eyes right so the the orb make sure you're real checks your iris code and then it verifies your unique World ID World ID is kind of like this Global digital identity protocol like an internet passport in a sense and it supports multiple proof of personhood credentials starting with or Biometrics and phone number right we see this proof of personhood is a spectrum in a sense right how strongly can we trust that this is truly a unique human so for some use cases right you're going to want or Biometrics that's just we consider it the gold standard for knowing someone's a unique human but in other use cases just knowing that they have a phone number and have verified that in the world app will be good enough and we're always looking to add more proof of personhood mechanisms to this one that we may add at some point in the future would be verifying a government ID but it is up to app developers using World ID to determine where they set the bar for how strong a proof of personhood they want to allow users to take certain actions in their app World ID is privacy first decentralized and open source right we never collect personally identifying information from you that's sort of the whole point of it is that we can't even disclose which person you are because we don't know in the first place it's decentralized and open source so the protocol all the smart contracts are open source our developer portal code is open source our ID kit the front end SDK that's open source as well and there's lots of different use cases for World ID so some that I really like voting one person one vote is something I'm a big fan of compared to one token one vote customer incentives are another one I really like that I think playing well with the fact that we see personhood as a spectrum right so if you have a user whose orb verified maybe you give them a one month free trial and a 25 discount on their first order but if they're phone verified right because you're a lot less certain that they're only that they are a unique human with only one account maybe you give them a week-long free trial and a five percent discount on their first order right airdrops are another great use case you want to make sure you don't have someone claiming the airdrop 100 times social media it's great to know that you're working with a real person instead of a bot lots of different ways that this Tech can be used so we designed world at e to be super super easy to integrate across web mobile and on-chain use cases and there's two ways that you can integrate World ID one is sign in with worldcoin one is anonymous actions so let's start with signing with worldcoin and let's see how it works so I'm actually going to sign into our developer portal here so with the developer portal I hit login and it takes me to this page with a QR code that I scan within the world app so what's happening here is that QR code tells the app which app it is that I'm signing into when I press verify with World ID zero knowledge proof will be generated on my device a testing that I am one of the verified worldcoin identities without revealing which one the list of those identities is stored in the Merkle Tree on chain right so to test that I am one of those identities performing an action without revealing which identity I actually am so I press verify that information gets passed back to the sign-in portal and then I'm logged in simple as that so I can come back to the developer portal in a little bit but that's a quick demo of how we sign in with World ID and there's lots of different ways that you can integrate sign in with worldcoin so I put all zero at the top there we're going to be launching an integration soon where if you're using authoro in your web 2 app you can Implement sign up with worldcoin just as easily as you can Implement sign in with Google sign in with Apple sign in with Facebook whatever it may be right five minute process next auth.js is sort of the go-to right now for using it in any of your web apps we have our openid connect provider it provides an IDC well-known file so if you've worked with oydc before you're almost certainly familiar with that and makes it quite easy or you can even Implement openid connect flows yourself but that's a very masochistic exercise and I don't recommend it so here I'll talk about how we can integrate sign in with worldcoin using nextdoth.js this is all you need you put this configuration for the worldcoin provider into Nexus configuration file right you pass it this well-known file or the URL to the well-known file that instruction on what endpoints to use for authorization for exchanging uh login token right you pass it B client ID and client secret that you get from worldcoin's developer portal when you create an app and then down here we are mapping the information returned from sign in with worldcoin to that user so the user ID is going to be the nullifier hash it is a unique identifier for a combination of user and action within World ID anytime that action a user is taking changes that nullifier chat nullifier hash changes and anytime the user performing A Satisfied action changes nullifier hash changes as well the fact that that nullifier hash will always be the same for any combination of user and action means that we use that as your unique identifier when you're signing into platform a but when that action changes say you're signing into platform b instead that nullifier hash also changes which means that your accounts across multiple platforms using sign in with worldcoin can't be correlated to each other at least with the information passed by World ID if you were to give platform a and platform B both your email and they were to compare their list of accounts they'd be able to correlate you then but that's with extra information that they have to ask you for specifically World ID doesn't disclose any information like that because we don't have it in the first place and now we can talk a little bit about Anonymous actions which are more powerful they can be used for on-chain use cases and likely what most of you will be interested in so Anonymous actions a test that you are a unique human doing something once or within a specified number of um of times you can set that number arbitrarily I'll talk about how you can set that later and for on-chain uses on chain use cases specifically with a specific signal right so say you're claiming an airdrop that signal would be the wallet address you want to claim that airdrop to for on chain use cases even though there is a wallet within the world app it is not designed to be a fully functional cryptocurrency wallet you can't connect it to dapps so you would have users connect their wallet the same way that they always do and then they would additionally verify with World ID as part of the transaction to claim that airdrop or mint that NF team so let's see a quick demo of anonymous actions so if I go over here we actually have a try it out section in our documentation and additionally here on the on the right I am using our simulator so the simulator is how you can test your apps um for staging use cases so if any of you guys are doing on chain apps when you use testnet specifically polygon Mumbai test net you have to use the simulator in order to do these actions so in the simulator you can create temporary identities and then validate them as orb and or phone verified or you can actually sign in with an existing crypto wallet you have to generate a persistent identity that you can verify once reuse for multiple use cases but the reason the simulator is important for testing is that if you're just testing civil resistance and all you have is your real world app you will run out of opportunities to test your civil resistance the first time it works right so as soon as you have performed an action with that ID you won't be able to anymore whereas in the simulator you can spin up lots of identities to test different use cases and things like that so let's say we're using the staging Network let's make this the Waterloo Test action let's only accept orb credentials and let's hit continue with worldcoin oh I thinks that this is a mobile use case so this is what your users would normally see this modal pops up and for testing use cases we can very conveniently click on the QR code to copy the information within it you can also run the simulator on your phone and scan it just as I did in the app earlier and in the simulator we can tap up here to go into the scanner or insert QR manually I paste that in there oh I did hit submit let me try that again real quick so I copy the QR code insert it here I'll verify with my Biometrics the orb verification I click verify with World ID and the proof gets passed back to the front end so that's what the flow for your users looks like when they're verifying with World ID and now we can get into how to actually implement it so when you're using Anonymous actions everything starts with idkit idkit is our front end SDK and it's a single react component right so the idkit widget you tell it what action your users are performing as well as the app ID you get both of those things from the developer portal uh you pass it two callback functions handle verify which is actually optional and on success handle verify hat is called as soon as that proof is returned from the user's device on success gets called when the user closes out of the modal and then you have to pass which credential types you want to accept so you can limit that to just phone verification just or verification or both if you leave that one uh if you don't specify it will assume just orb credentials Additionally you pass it the button that is displayed and then pops up the modal when you click it and this is what gets returned from idkit this is the proof generated on a user's device and passed back to your app's front end so the Merkle root specifies the root of the Merkle tree with the user's identity listed within it the nullifier hash as I said earlier is the unique identifier for that combination of user and action the proof um is much longer than shown here and that is actually the cryptographic proof with sema4 and then the credential type is passed back as well so orb or phone at the moment with more to be supported in the future but what do we do with this we still have to verify that proof right because on the front end anyone can put in any data they want and you can't really trust it so you have to do something on a back end whether that is your web apps backend or if that is on chain so let's start with talking about how you would do this in a web apps back end so you would pass that information to your back end um there's many different ways you can do that in our like Cloud actions template repository that gets handled for you and then in your back end you would run a bit of code like this that would call World coins API right so the base URL would be uh id.worldcoin.org or I'm sorry developer.worldcoin.org slash API V1 verify and then your app ID that this action is for um you pass it that request body additionally with values the actual like request body there will include values that you had to pass to ID kit in the first place like your app ID and action ID um and then we handle verifying that proof for you you don't have to worry about any of the math for the zero knowledge proofs anything like that but then uh when you get a 200 response back you know that user has been verified and then you perform whatever actions you want to perform for that user from there so that can be you know marking their profile is verified in your database lots of other things you can potentially do but you have to verify them on the back end if you just verify it on the front end a user can manipulate that and it's not actually proving anything now if you want to verify it on chain first you have to construct your world ID instance right so underscore World ID here you would pass the address of the worldcoin smart contract we do have an ens name for that uh it's listed in our documentation which I'll link to at the end and then you have to pass your app ID and action ID as well then you have to actually build the external nullifier yourself but that's sort of the first step get everything set up from there you can Define your verify and execute function right which you give the signal that that user wants for the specific action right so again airdrop could be wallet address uh you give it the root of the Merkle tree you give it the nullifier hash and the proof so in this example we've implemented civil resistance right for off-chain use cases we handle the Civil resistance for you you can pick an arbitrary number of times you want to let a user do something in the developer portal but for on-chain use cases you have to implement that yourself so in this instance the first thing it does is check if we've seen that nullifier hash before and if it does we revert we just have a list of the nullifier hashes we've seen and we know if it's in there we've seen it before this user is trying to perform an action twice we don't want to let them do that so then we call the verify proof function on world coins contract we pass it root of the Merkle tree the group ID so the group ID is going to be either zero or one zero is if that user is phone verified one is if that user is or verified we do that because we have separate Merkle trees for orb and phone verification it's explained in our documentation um and in your smart contract if you only want or verified users for example then you can just hard code that as one right but there may be some use cases where you're going to want to pass that information in based on whether that user's orb or phone verified so you ABI encode the signal and hashed field you pass the nullifier hash and the external nullifier and the proof so if that proof doesn't verify this will revert but if this does verify we'll continue on and we add the nullifier hash for this example into the list of nullifier hashes so that we make sure that that user can't perform this action again and once we've done all that that's when we continue on to do whatever it is that we want our smart contract to do minting an nft claiming an airdrop whatever that may be so that is like the really quick overview into how to integrate World ID um it covers everything right it's actually quite simple and for us we have 20K in prizes here at the hackathon so five thousand dollars to the best overall use case 2500 each to the best governance app most creative use case best AI use case and best sign in with worldcoin app right so the governing app can be you know a bunch of different things that could be Dow governance that can be more political voting systems governance is pretty broad there similarly with AI right that can be AI safety that can be ensuring a human's in the loop with your AI system that can be ensuring that that training data is actually generated by a human again lots of different things there but for all of these I want to clarify that you do have to like integrate World ID into your project it's not that we're giving away 2500 to just some cool AI project that doesn't use World ID additionally uh oh I made a slight typo here we have two one thousand dollar honorable mention prizes and then a three thousand dollar prize pool split among all submissions that properly integrate World ID so our SDK and developer portal is still in beta but we're letting all of you skip the wait list for hacking here at East Waterloo or east Global Waterloo Additionally you can continue to build on top of world ID after the hackathon if you do please let me know because I really want to be able to help you out I am developer relations it's kind of my job but this will get you access to the SDK I would recommend visiting the URL on a desktop instead of doing it from your phone but you can also if you missed this here come find me at the booth this information will be available there everyone good can I move on all right so if you guys still want to get access I'll give you a question okay so I'll do questions right after I put this link up as well which links to a bunch of resources including our documentation our developer portal template repositories that we have available for you all uh information on our bounties and where to contact us if you have any questions so now questions all right I'll go with you first um the way the way that I've been doing that it's free so we have considered several options to to actually print the chart what is that you have the uh the real have the identity to to identify the specific values to sell that token and the other they either so but that's my understanding so if you if if let's say the the more like the uh we can identify person as an empathy there there is a more exposure up there are actual uh personal information there it's not like the the Privacy Information that is like is probably not private anymore and especially uh the the one that you talk about that Workforce use personal biology information I just want to know as you guys are the uh Central entry and you use the personal information out of that so I can expand a little bit on how we use the biometric data in the orb um so in in the orb right it does take photos of your irises unless you opt in those photos never get stored anywhere we compute the iris code that digital represent excuse me digital representation of the entropy of your iris in Ram and if you didn't opt into having those photos stored they get deleted if you did opt in they are encrypted temporarily stored on the orb until they get uploaded to our server using a sealed box encryption mechanism to prevent say a rogue operator from trying to get that data off of the orb the orb itself has lots of other physical security measures uh like tamper resistance things like that um but if that is stored it is encrypted full stop and once we have that Iris code right we also know as part of the sign up process the public Key Of Your World ID and to clarify the wallet in the world in the world app and the world ID you're based on two entirely separate secrets right your Biometrics never touch anything related to the wallet but the public Key Of Your World ID we know which Iris code It's associated with but we just add that public key to the Merkle Tree on chain so that when your device generates the proof that Markle tree is publicly available for verifying that proof but that public key never gets revealed not even worldcoin knows which actions any specific identity is taking because that zero knowledge proof is generated on your device the only way to associate actions back to a public key is if you have the private key and you are the only one who has that private key on your device of course yeah so um I understand how the iris is stored and it's on chain but is there any online to associate with the problem so the iris code is not stored on chain just the Merkle tree of world ID public keys but those public Keys themselves aren't really useful for anything because you can't associate them with actions they're not meant to be you know a a true like public identifier of who you are right everything with World ID is context specific you have your nullifier hash in the context of a specific app but you don't know that user's public key for their world ID yes associate the world finds ID once to identify in this particular ID but the wallet you have the signatures associated with that important so if that's possible but you would have to have the user sign in with both right um in that use case would you want your user to be able to sign in later with worldcoin or would you still want to have them connect their wallet okay so in that case I would say actually just using an anonymous action to have that user verify once right it's using the anonymous action rather than sign in with worldcoin makes more sense for the use case you're talking about which I would describe as verifying that wallet right and that's all you're looking to check for yeah so Anonymous actions work great for that as can you speak up please yep and that's because so I couldn't hear you perfectly was the question specifically about why you have to custom do the Civil resistance for on-chain yeah so that's because I for off-chain use cases right it's very simple for us in you know our back end to just track how many times this action has been performed um and let you pick that for your app um it really is just more of a convenience feature for developers who are using things off chain but for on-chain use cases it would add a tremendous amount of bloke to our contracts to track that for you so that the more people use World ID the more expensive it would become for you to use World ID which we don't want to do right so that's why we have you track that yourself it is as you saw an extra two lines of code um so that's why we did that or at least saving you money that you don't have to spend in the first place any other questions yep uh it's most efficient to verify an inclusion proof in a miracle group so the orb can detect that it's actually a human face um and it can detect that it is like a real face and not a photo of a human um yeah like we we have thoroughly modeled a lot of like potential uh fraud attempts uh so yeah like if you put a cat or a dog in front of the orb it's not going to work unfortunately yeah yeah I tried to verify my cat and it didn't work oh I'm sorry [Applause] 