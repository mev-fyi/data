thank you so much for joining uh by youtube or on the zoom call we have zach ferlin from ceramic and three box who's going to give a presentation on managing identity with ceramic and with that i'll let him take it away great thanks hello um so yeah i'm zach from ceramic um you may also know this as a team that built uh three box before um but today we'll be talking about ceramic um yeah we've been to a few of the youth uh global events before we're excited to be building whatever you want to get in here um yeah so today i'll do kind of an intro to what ceramic is um and the main thing we're building on top of that something called idx right now and then the last uh the last two thirds i'll basically do a bit of a workshop uh step through some code it's going to go pretty deep um at the lower level since we're still building a lot of this stuff right now and we want to build with everyone and kind of um we're still doing a lot of lower layers so it should give you a good insight into what's there um and that should take up about 45 minutes and we'll leave the last bit for questions and definitely during the workshop section feel free to ask questions at any point um yeah i'll start with an intro through a few slides tell you what ceramic is um and idx um all right so like i said uh today we'll focus on the part of idx and that's an easy way to manage decentralized identities no servers no silos um the big value ad here is that when decentralized with these decentralized amplifiers you don't need to run um you know any back-ends you don't need a third party to say who you are um you have access to this uh global local network that you can resolve this data resolve these lookups um and someone can always prove um that and everything's publicly verifiable um as well as that you often don't have to run even other data layers because you can basically hook into these other layers so you can hook into ipfs filecoin other uh decentralized db's um all you have to consume is a simple library um and then you get access to most of this a big thing here is now when you have this user-centric model um users control their data control who has access to it and when a day resides to the user you can let them share data with your app so no longer do you have to go ask permission somewhere else to get data um you ask the user if they want to you know share data that they have in one app sure did they have another place they cannot do that so now you can look up data across applications across places across different uh even like centralized protocols um and like i said users now they're the ones in the controller they can access control that they can decide how they want to let you use it what you want what you can read what they what they're willing to sign for um so core part of this is gids uh these are decentralized identifiers uh this is the open standard and i said that as i said it's a way for no one says who you are you can prove it yourself um and people can implement uh different did protocols uh they allow you to then take this identifier with you um and link a bunch of things to it uh so for example we had used these already in three blocks and you could link like a twitter account you could link ethereum accounts eventually you can link across different chains really allows you to weigh the tiles data to it in a publicly verifiable way um and i said on ceramic itself you can actually store data so we'll go through like what it actually looks like um kind of what that underlying structure looks like but it is built on ipfs and and in these data structures you can store data in itself so you can have um json documents any other kind of structured data in that way you can basically link it to these uh decentralized identifiers then there's ways to look them up wait for people to index them and all up to the user and what they want to link or not even more interesting after is you don't have to naturally just link to another object in ipfs for example or link to another document in ceramic you could actually link to any other kind of system um whether there's other like pdp databases it could be something like orbit db textile threads um anything like that and along with this um data now that you're you could just say like here's the data here and you can also add stuff in that document in ceramic that basically says um it meets this schema this is how you like interact with it this is how you um kind of control it or look it up um all this metadata can exist in ceramic you know tied to your identifier so when you bring your data somewhere um another app knows how to knows how to resolve it knows what dependencies they might need to use to get it um they know like what form it's supposed to be in uh and what it's supposed to look like um yeah i was already saying like these these things don't exist um in a silo they don't exist alone when you create them you're actually linking these to basically an index you think of it just like a you know you're this key value mapping that's linked to your did it has links to a bunch of these documents that say i have some of this data that needs to schema here i have some data and this other place it looks like this and this allows ways for people to discover this data look it up and like said consume it let's see and yep the the nice effect of that once you start building these graphs and all these linked data is every user gets to bring this kind of social um user data graph with them wherever they're going um and you can actually like said allow you know like access control on certain parts of the graph so you can write queries against it um all on top of this underlying like graph structure um so that's a lot of like what the value looks like for idx which is the identity index um i'll kind of go into more details there after this is built on top of this um thing i was talking about called ceramic um so ceramic is this uh global general purpose basically document based storage that kind of the interface of the user just looks like it just looks like json data but allows you to securely publish link query um and publishes verifiable information saying when consuming these documents um can verify them um the underlying structure is on ipld so you actually have this immutable data structure underneath the document that looks like this log of basically a log of updates um but since the user is signing every update you have a way to also you know update these documents um change them and still verify them all these things i said are signed by dods um so anyone can resolve those let them up verify them there's some rules for how you can update them um that influence in the system and you can define uh different rules as well for like these state transitions you can think of it as like you basically just get this json data um in a doc you can edit it verify it but when you resolve it um you know the underlying stuff is verified so go here um yeah i kind of covered a little bit of this so i said everything is a verifiable document just looks like this verifiable json object even though the underlying part has this immutable data structure that you can resolve um everything is linked anchored verified these all form a graph um i said an ideality these documents and their updates are anchored in a blockchain right now they're anchored in ethereum but you could anchor them in any chain um so basically it's just saying like this update when you're verifying it you see this update has been um you know include at this point in time uh in some chain um you could use so we we built like i said you started dids before we build three id which is one implementation but you could also use other gids in the system so you might have these other identities that can assign document updates create new documents you could link the ids to each other for example um so there's no global view and ceramic these docks are just these chains of data and people share updates when they when they see them so you don't have to have a global view of the system um people can build local global networks and all these networks can have even different properties so you could have one that's like i said uh for example just it's anchored in ethereum while another one is anchoring in bitcoin um you can have different storage layers so one could use ipfess uh one queue something else like you can use falcon here but a lot of these other layers are configurable you don't need any global view um but within the data you usually have a way to say i can resolve stuff in this network or this network and you'll see kind of what that looks like after so now this starts a little a little deeper and i'll show this uh in the code as well after um like i said the the user interface for a ceramic document is just this key value um object that you can store anything in um but underlying that actually looks like this so it says made up of a chain of records here that make a log um that then you know the documents constructed from so when you create a document there's a certain doctype like i said and the doctype defines the kind of rules that govern these state transitions so like right now um we have a thing called a tile and the basic update mechanism there is that this record must be signed by the owner so in the genesis record you create this json object that has you know some did as an owner it says what tile it is it might start with some initial data um and then that doctype defines how you allow these updates um so anyone making those updates and verify that that the state transitions happened as you'd expect for that record um so for this record we get you know you would want to say that it was signed by the dd that it was anchored after each update that this data um met the certain standard a certain change uh you could actually have different kind of doctypes eventually that had different um basically state transition rules or other update mechanisms so you could say like the owner of it is actually like a nifty unchain and then if you want to verify that someone owns it at some point that that point in time um you would maybe do that look up on chain and that's how you verify like these transitions um but you could build lots of other mechanisms as well and then it's up to each client consuming that to verify that um according to that so the other long underlying log that says has this so every time you make an update you do you first create a genesis record you sign those updates um each update then has an anchor record so the anchor record would point to your last signature record which is your last update and you continue to build this chain so as i do each update you'd end up with this whole list of records um and then each part each anchor record has a structure of a proof on some blockchain so you can always verify these proofs most of these are merkle proofs or the actual just you know hash or cid of this record could be published on chain um allowing someone to verify and look this whole thing up so this is like the actual data model another part of ceramic is that you need a way to always gossip about the most recent update so if i want to get the whole data for this document i want to be able to resolve this entire log um not just the genesis record um like like a a ceramic document is identified by a genesis record but then you need a way to ask for the most recent update so that so for this one i want to be able to get this most recent anchor record um so it uses lit b2p and most of the nip fast and they all these peers will connect and you'll want to share gossip about whatever ceramic documents you care about um so if someone else had this record and i just came online um i'd be like i'm looking for this document with this genesis record cid um some other peer would be like i heard about this record i heard about this one um and i want to you know find the latest um and you for most part you don't have any incentive to behold this then once i get that able to resolve this whole thing uh and get a document um so that's the two parts um now i'll kind of step through what this actually practically looks like in code instead try to make it a little more concrete um so i set up a simple demo that already had some things loaded so our core libraries are loaded here um yeah during this part like feel free to ask any questions i said there'll be some time at the end as well it seems like we're all good oh there we go i just had the youtube video playing in the background of myself okay let me open okay here we go yep so i said i have this demo open here and uh the library is already loaded so the core library when you're interacting with ceramic is gonna be ceramic js um and that's right here this is how you're gonna you know create documents verify them look at them so i have this library um i already have this object on the window right here so i could just be some json i want to make this i want to put this content somewhere so now you i'll uh use ceramic to create a document excel create a tile so it's gonna follow those rules for state transitions and updates and that's how people will verify them objects one zach we got a question in zoom chat here from matthew asking are we creating pair wise did for each connection or just a single the id i get it yeah yeah i'll cover that a little bit after yeah there's one did right now um but we do want ways to like delegate to the other dids and ideally you would like create pairs as you interacting in different places and you would either like lincoln um like do some object capabilities or something um there rather than using the same did across like all instances nice um one quick question is dot js available on react native through shimming or something um it's probably hard it's a lot of people trying the big blocker was it's hard to get ipfs um to run there but i know some people are working on it for the most part ceramic right now ceramic js will just consume like a ivfs http http client or even a ceramic http client um so ceramic js itself should be easy to run that context but you would be running like a ceramic node or an ipvs node somewhere else um so for documents uh so i created this document here with this object um you can see now i got back a dock uh so this is the main interface for a document like i said it has a doc dot content so while the underlying thing has all this you know this ipld graph these updates this is verifying it this is just building the ultimate object the most recent state that it knows so you have that dot you can see that it has an id so ceramic ids look like this right now these might change a bit right now they're just cids but they probably will specify like the network what docs they are and that other kind of stuff that's part of the id after they have as i said the doc id is up the genesis record but as you add updates there's going to be you know most recent latest pointers in that graph um so that's the head uh let's see so that's the cd object i'll turn it to a string wait doc dot as you can see here this is the you know pointing to an ipl the node that's the latest update of that document that's that um now use ceramic to update this document so i just have the second object here i'm going to write to it so i'll do doc let's say wait doc dot i'll do the second object all right so that updated now um so i said in the background i would have you know added a new record signed it um and anchored it as well so we should see now that the content has updated yep so we've got new content here um i just wrote that update you can see of course it still has you know the same genesis record so the id is still the same but now you'll see that the latest update is uh different than it was before so now it's pointing to another node here so i said by if someone else created this document and i want to resolve it i basically would have come on like onto the pub sub network and said hey i'm looking for this ceramic id um someone else would have gossiped about oh hey this is the most recent um you know i feel d note in this graph that allows you to resolve uh that whole log somebody got this and been able to load that on instagram that document um and that's what this library is doing in the background of course it's all local here so it's kind of just pulling that locally from ipvs and resolving that um now that we have these things um i can actually step through what this looks like underneath so i could do so i have ipfs on this window as well right now just load it in the browser so i said this is a cid so we can actually resolve this in icld right now and actually take like a closer look at it to see what it looks like uh so do ipfs.get and i want to take the doc id wait in the dark so i just resolved this id node um we would expect to get an anchor record here um in ceramics so yeah that's exactly what we got this is anchor record this has two pieces um like i said they're always pointing to the previous entry in the log so it's pointing to the node um and then there's there's proof right here we'll step through that after um but we can actually keep walking through this um so see previous it's a link just know cid objects object there's a few cool things here so like you would recognize these codecs in ipfs just defines how you might resolve or read that data um what structure it looks like um we're working on along with some other teams on something called jose which is going to be a new codec and ipfs that allows you to actually have these signed um basically signed and encrypted ipld nodes and links so that's already using this right here so you'll see like how that's signed up there so saying it's pointing to this ipld node um just like we resolved the other one i can resolve it that way again so now i'll do say pretty okay so i'm walking down this log um he said now we get to a signature record um and this is like what it looks like for tag jose is that we have these signatures um this is actually signed by my dad and we'll see that a little clearer after um and then that just represents another link so saying i signed this link with this key um and it points this other node so we can keep walking that we'll take the link now we expect to actually get the actual content or like the most recent uh and here we go so we have the data now you can see this is my most recent update um so when you write new data to it it's not creating it's not copying that entire object it's using something called jsonpatch so all these operations get added you're basically just writing the diff of the json object every time um and then when you're loading this document ceramic ceramic is actually taking all these and applying them um together to get the final output so you just see a single update here um again it keeps walking so you see there's a previous again we'll keep going one more step now we'd expect to get back to another anchor record again for the last update see we do this and here we are another anchor record this time i'll show you what the proof looks like let's open that yes the proof has a few parts i said you just need the context to look it up on so it shows here it shows the chain um this is the chain id for ethereum main that says in this block number uh and this is the root um so if you're gonna verify this you would just say like also we see here that we have this transaction codec i don't have that codec loaded in ipvs right now so i can't um really resolve read that data base you would look for this transaction hash that exists um in this block and it includes this route um a lot of times you could delegate this to other anchor services so ceramic when we first network first launches we may run an anchor service or something else but people can basically group all these transactions together you can publish these anchor records yourself um or you could have a service publish them and then in that case they would create a merkle tree and a miracle proof here which would just include the merkle root uh in a path um since i just published my own update here in chain um or there's a single update at the time for my anchor service the root is actually just another link to my last update um in my graph so i can actually take that we'll see it again so we'll take the root there it is um i think one more let's see yep and so now we finally walked the entire log and we got the genesis record if you see like the initial data we can see here that it has some metadata um and right now it just says the owners and this is my did um so you expect all updates to be assigned by this did if not it's not a valid update um and it follows like you know transition pools or verification rules for a tile um that's the route if i go back a step to roo let's see so here so now we've got the genesis record you can see this is the idea of it and you expect this to be the same as you know the document id in ceramic um oh wait i resolved the wrong one let's see root oh here we go um yep so you see here is the same cid as what makes up the document um document id so now we've walked the entire chain kind of see what you know the underlying structure looks like so i was doing all this i said like i had this did in this window uh so one of the other core libraries here is something called identity wallet um in this library it's kind of how you manage um this library allows you to manage uh your keychain in ceramic um it allows you to manage these diodes as well as add keys at other links and do those kind of things um so i already have that load in the window and i have you know below the same one each time you can see that my identifier is right here so this is the id that i use to update this document prior right there um like i said dids are basically just opaque identifiers anyone it allows you to link the main thing about a link to it at least is you know signing keys that kind of stuff so this this protocol allows you to take just a big identifier and then resolve the same keys that then you can use to verify um knowing someone signed something so of course with someone else's did i could resolve their gid um get their key get their public keys and then allow me to verify their signatures under the ceramic docks um when you're implementing these like i said we implemented our own called 3d here and we have a resolver here for them so i can actually show you anyone can implement these resolvers as long as they meet the spec and they meet what a dod document should look like so i'll actually resolve my did document right here so heaven ceramic let's do it okay yep so i resolved my d um it resolves this did document and you can see here but yeah i have some keys attached to it already there we go um so that document i just created if anyone else wanted to verify it they would resolve my dod um they would be able to resolve these keys here um and verify that actually that i actually signed those record updates so that's there um like i said anyone can implement them um one cool thing so you'll see actually that our look at our identifier here ours actually includes you can see an ipvs cid so if you look that up you'll see so we'll get that again idw dot id oh see i can't resolve the did one we'll do we'll just take it here and there we go so you see that actually we implemented rdid method on top of ipfs so you can resolve the cid and there you go so it has some of the stuff in here um so even more interesting you'll see that this is just not any ipfs object this is actually also a ceramic document so the cool thing here is now you have a way to actually update the data that's length the keys do key rotations all those kind of things on top of these documents you don't have like some static uh update here so you can see like given this ceramic document i can then map that to me um you know what's defined as a a did dock um so that's mapped from here to here um you can see yeah that this already didn't have all the updates that i have so like there's already some updates in here um so yeah you can see that i could actually open this in ceramic instead and that might be more interesting so i could do doc let's create a new dock so my dad is actually implemented as a document in ceramic oh wait ceramic actually yes i'll just load the dock wait let's say um and then we'll do i already have it here so it's just saying yes right mix slash uh the cid so i'll do that there we go so now we got what represents um the underlying document for my d id and now you can see it has all the updates here and this is what you can use to map you know said the document there um that's most of that um like i said those dods now are signing all these updates and then we can you know resolve this verify them and now i can add these kind of links and stuff so there's another interesting thing here so i was talking about um idx before um idx is one of the first kind of standard um documents on top of ceramic um so you can see i have this thing in my did that's just linking to another ceramic document um and these are basically indexes of key values that allow you to attach all this kind of data in some way geode id and i have the idx library already here so most of the time you'd actually be using idx probably unless you're implementing like new doctypes or any lower level stuff but for like any identity stuff in your app you'd be using idx um identity so idx is this identity index um obviously what it does it has let's say key values and basically maps from these things we call definitions and then they map to a reference so a lot of them look like basically a definition is a way to say um kind of describe the data that you're pointing to so whatever the reference is the reference could be another ceramic document um it could be my profile for example um and then the definition would basically say oh here's this profile it means the standard this app might have created it um or might have also the metadata on how to resolve that data if it was in another protocol besides ipfs or besides you know if it was in orbit db or textile or any place like that um i can show you what they look like so as i said like these documents can have schemas attached to them so if i want to make a profile i already loaded uh some schemas in here for idx so i'll just play those um another cool thing is you can see that schemas themselves are also ceramic docs um so you have these schema definitions and you can have them also have updates as well and you can reference versions um as people are creating these um so we can actually take a look what the schema looks like we can again just open it as a document so i'll create another doc i'll just load the doc and i'll do let's do the basic profile okay so now i loaded this schema as a document again and now you can see what these games look like so a lot of these right now is just json schemas they say you know what keys you'd expect to find what values they should have and how they should meet that um then the schemas like i said can be basically referenced when you're creating other ceramic docks so you could expect a ceramic document for example uh to meet a basic profile schema so if you know this document if a document had this schema so i'm loading it would expect it to load it in this way or possibly find these values and know how to you know format them show them display them um that's what it looks like there's a few other ones already standard ones um we expect people to like define lots of other ones we'll have some standards um and ideally people contribute other ones forever context ideally you want to eventually have like come some consensus about what um certain schemes look like for certain contexts that other apps can you know always load these uh different things like i said these don't have to be attached to ceramic documents they could even you could even have a for example a definition that says here's this data in this api um but it still points to a ceramic schema for example um so you say i expect to resolve the data at this end point in this way and this is how you get it so those are schemas and then idx i will now create a definition so you can see exactly what this looks like so do idx definition uh let's see okay so i have this here uh so an idx i'm going to create a new definition um like i said this is a really simple one this is actually just saying this is going to point to another um it's going to point to another ceramic dock in this definition like i could have pointed to any other service or any other api um what i was saying is just it has some name for it so i'd create a definition once i've had a profile um and i would just you know for example i want a namespace here so i have an app that has a separate profile than my global profile but i want to add this to my identity index like this so someone looking for my profile on a particular site would basically look for this definition with this id here then i'm saying i want the data to follow the basic profile so i'm going to create that there we go um so definition create a ceramic dock itself so this definition yeah is now another document in ceramic that can get added to my identity index i'll now now that i have a definition i can write stuff through idx to these um to these different objects so i can do let's say i'll set so i'm gonna say yes i have this here i'm gonna say i'm gonna set um this for for this definition id in my um identity index i'm going to set the content for it so i'm setting it to basic profile [Music] reset and now this itself like says since this data stored in ceramic itself right now this is actually creating another ceramic dock as a reference um if i loaded that you would see this content in that um but we have a user interface in idx to just look this stuff up and you know set and get that stuff so now i should be able to get that data same thing again i'm going to say i want to get it from this definition there we go so it will resolve that content for me um what's more interesting is you can actually say like this so you basically say here is like i you could pass a did so you want you could say i want to get this particular definition for this did um i don't have like someone else's someone else's right here but if someone else here had a profile i knew their did i basically say i want this definition id so it's like saying i want the profile for this app um and this did and then i would ask uh you know idx to resolve it that's what it does here the actual flow looks like um actually last part so we can see all the stuff as we created these should have got added to our actual identity index which if you remember is a ceramic document itself um so we had that up here before that was right here as you can see in my dnd i had this idx document um now we should expect to find those entries in there so i'm going to load that as a document again so let's create let's load another dock um yeah doc one content dot idx so just loading that dot three now look at the content of the doc all right um so for my did this is my identity index um so you can see here this is the entry we added so i basically added this thing that's this definition um points to this reference so this is the definition i created that says there's a basic profile here's for my app has other metadata um in this case points to another ceramic document which is this profile document right here so i said if i want to look at someone else's profile able to resolve their did get their identity index ceramic dock then load um they'll resolve keys and values inside that so you can resolve this here and look that up um like i said i could point to like a textile thread as well now you could load that you could define stuff like um access control or like encryption keys or that kind of stuff inside this definition as well so it's kind of a space for these dids to coordinate over this kind of data whether you're sharing with apps or other people or anything like that [Music] um yeah so that's uh that's most of the demo um those are the main libraries we have right now um like i said the big thing is also you can see here that this has some auth keychain data so um one particular thing we're doing now already is that we have a hosted um basic version of identity wallet so if you're using um if you're using this in a browser anyway you want users an easy way to like permission stuff um science stuff we have something called uh 280 connect here so this operates like identity wallet in iframe um and this allows you to get the same interface that i had here and someone has like a shared persistent identifier across applications um one of the cool things you can add in idx is basically links to other accounts so you have links to ethereum accounts um so one of the things we do already is like if you authenticate with ethereum account that adds that as auth method so it's adding it to my auth keychain here and it makes a publicly verifiable link um as a document inside my ceramic idx um so if someone wanted to say i know a song with this ethereum address they could then resolve my dod then resolve all the other links to it so if i had a profile it basically be like there's a theorem address i can resolve this profile or i can resolve what my twitter profile is um you can link all that kind of stuff to it um so we're really interested to see what kind of stuff people can build as you know basically new definitions schemas um what other kind of data we can add and link here um as well as like make sure we can interact with other protocols and resolve it in all these different places um so that's it for the demo um i said eventually there'll be other things built on top of um ceramic besides idx but this is really a core part we're focusing on um yeah so to recap like i said we the big thing now is we have this base layer and these these basic definitions and ways um to link data resolved data um but right now it's mostly um an ethereum and just in these actual ceramic documents itself but we want um you know help and people building on stuff to like you know make sure we actually can resolve stuff in different blockchains different data stores um have integrations with let's say you should build a one of the definitions in your idx should say like my data is persisted in file coin um and it's stored in this db um and you should build link accounts across different chains and stuff so you can have your ethereum account um linked with any other blockchain account um so you want to work on that um and i said idx is the first use case we're focusing on um and especially want you know input and people building different definitions and references um these integrations um like i said we have this all our stuff is in um javascript you can find are most of our libraries are in this monitor repo here at js ceramic um there's some cli tools and some other tooling interact with it um like i said everything also operates um against like http apis and gateways so you can run it in most contexts yeah for ether online we have uh the three power three bounties um so one best of all project using idx uh two best social common chat implementation used in idx and then lastly best tooling for idx ceramic that makes it all easier for us to use and lastly so you can find some more info at friday x on idx xyz says here that has links to most of our docs and stuff um the link is ceramic ceramic.network and you can find us on discord uh our own discord as well as sponsor ceramic um and we have office hours twice a week we can just come and ask stuff about idx or ceramic and you can find us on twitter that's all from us and yeah if you have any questions about anything that was shown here um i think we can answer those awesome thank you so much zach it's great i don't see any um questions from youtube at the moment but maybe um andrew if you could allow guests to unmute themselves they could jump in and ask questions of zack here yeah and maul's got one let me see if i can do it um yes i was able to unmute okay yeah i think uh joseph having had a question before should i go ahead and or should i be or joseph's question to be answered um what was the question for i think we have time for any questions so okay my question was specifically like i was exploring three id connect idx and ceramic and i was wondering like when should i use each one of those or are they interchangeable and then exact use cases for each of them specifically yeah it kind of depends what layer you're building at so if you're an app that just mostly if you already want to just consume stuff that might be um you know linked to the ids or like consumed from different um data sources and you probably just use like in future most people just use idx and there'd be a whole bunch of schemas and definitions and attached stuff to a profile and you probably just set and get stuff from there and like create whatever schemas and definitions you need um but since it is kind of early there's not a lot of for example schemas and definitions defined so we also expect like a lot of people might be um you can use idx to create those as well um like i said there might be other cases where people are exploring you know what other doc types it looks like so this is the pencil building if you're and if you're building um in web um the best thing to use is 380 connect as a way for like that as that key chain for your gid um you can use identity wallet for testing and stuff place it like a danny wall basically runs inside 380 connects it's just this um posted with permission flow for users uh you know perhaps to access that got it i can use 3id connect uh along with idx as well right probably said some did provider yeah you should really used to do the the main so the yeah the interface is um 3d connect basically gives you a did provider and then that's like an rpc layer in this case like a 3d connect that just makes calls over the iphone window um yeah the interface is the id provider and then you should be able to take the dod provider to any of these libraries um so you can use it in the ceramic library or you can use it in yeah idx awesome thanks joseph did that answer your question or do you want to sorry okay um so yeah my question was uh like how does the performance compare um to traditional document stores like fire like firestore yeah um i mean it's not yeah i would say it's not really comparable i mean the the the model and thinking like how you might get it but um of course it depends on like the local configuration it's like if it is a document that is not you don't know where it's necessarily stored or anything then you have to like you basically would be looking at that document um asking for it through pairs that you connected to through dht and then like resolving that data to like the ipvs dht um and that's not necessarily always performing um and it has some context depending on like what peers you can connect to so there's we just have to incorporate like a i guess in that form like a cold start kind of thing like a cold read or you have to deep dig deep down and find the document um yeah so it's quick to load i mean once you have a lot of documents locally and okay so so a lot of people also going to run info where you're like listening for a lot of the documents that you're interested in like you might run your own ceramic node and you basically say like i'm interested in these like types of documents um and then you constantly listen for updates for those and you would be like probably pinning those also in your ceramic node um and most of the time then you might yeah run that as a service that then your app uses and then you're resolving data pretty quickly um through that and then pinning it locally um and you always have those updates available most of the time gotcha gotcha yeah so it kind of just depends on the distance of where we're caching it at yeah um and for example we're going to be running a ceramic node at first so a lot of people will be just connecting to our ceramic node and we'll be pinning a lot of documents there first so most people will be able to like quickly pretty quickly resolve those docs um and then once you do yeah i guess pin vocally and you might continue to listen for updates at the same time okay um another question too i had real fast is uh the idx uh uses ceramic js in the background right yep okay so if the whole point of asking these questions is because i'm trying i'm on a mobile app um react native and i'm trying to find a way to incorporate some kind of identity service and switch away from my traditional firestore document store um so it i guess my question is is there active development because i couldn't actually hear earlier because my connection was messing up but is there active development or active eyes looking at a react native port or shimming process yes what we have now um so i said like it should work in the context that you run the ceramic node as like a http client so you don't actually have to run like the whole full ipfs notice traffic node inside that client or browser or whatever context you're running it um they all have uh these http apis so like a ceramic instance um can like spin up its own instance locally of ipfs and everything else um or a ceramic instance can basically just be a wrapper around this http api um ceramic i guess in the ceramic js it's really simple to point somewhere else yeah so what you do is you run a ceramic node some ralts the ceramic instance uh in your client would just be pointing to that endpoint um they said like act like http api and then you would pass that ceramic instance to idx that makes sense okay thank you yeah and eventually we all want ipfs to run in mobile everywhere eventually yep zach i've got a question from stefan on youtube who says last time i tried creating docs i never received anchor documents is your default anchor device 7007 operational for everyone um you don't know what configuration you might have had we do have like a dev anchor service that we use um right now um so we should be like have you connected i don't know what point you're referencing now but you could follow up with us um but you can run it locally pretty easily as well for testing great i'll um i'll direct stefan to you guys on the discord great cool um maybe uh if there's any more questions now's a good time otherwise we could wrap it up and let zach follow up with you guys if you have questions on discord awesome thank you so much zach super exciting stuff i know people are really excited about using this especially the ipv ipfs folks sorry yep thanks everyone and yeah we're always on discord so find us there cheers later 