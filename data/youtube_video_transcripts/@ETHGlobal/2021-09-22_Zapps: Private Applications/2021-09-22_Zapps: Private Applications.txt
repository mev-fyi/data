um we're now streaming to the east global um youtube uh my name is andrew um i'd like to welcome everyone to the zaps private applications workshop we have here blagoy demofsky who will be presenting and we can take questions at the end so feel free to um either unmute yourself after the presentation's over or you can put your messages in an ongoing basis in the zoom chat um and then and then we can go from there um all right take it away okay so let me know if you can uh uh looks good yeah yeah okay okay sounds great okay so my name is drago and today i'm going to talk about uh private applications i'm going to give you a high level overview of what our private applications why do we need them how can we build them and at the end we'll go over some ideas which hopefully will uh give you some more inspiration but first uh let me tell you about this scaling and privacy exploration team at which i work at so privacy and scaling exploration team is a team at the ethereum foundation which works on bridging the gap between cutting edge researching zero knowledge proofs and application development on the ethereum network and we work on various different interesting projects which uh which you can take a look at this thing here there are a few open projects and interesting opportunities for grants as well and also you can read the official medium page of the team so uh white privacy and anonymity why do we need the private applications so there are many reasons but the most important things are today in the information age are the data protection of the end users such as user identity protection uh personal account information and other personal uh data protection and also anonymity is quite important from uh from the standpoint of decoupling one's opinion from one's personal identity and this can lead to more like fluid conversations and fleet experiences and there are many other uh reasons uh i think the reddit link here which goes over uh in more philosophical depth on privacy and uh anonymity but the the main point is uh uh that you can actually interact with applications without giving too much of your information out so how can we enable this so on a technological level we can enable this by using zero knowledge cryptography and zero knowledge proofs and some uh constructs uh based on zero knowledge uh proofs that enable this are 704 and rln and today i'm going to talk more about them and how we can use them so sema 4 is a zero knowledge gadget which allows the end users to prove a set membership while preserving their identity and also it allows for the users to send signals so this might be uh very generic but basically the the point is that the users can obtain anonymity by just just proving that they are part of of a certain group without uh telling uh what is their identity and the signal can be their opinions and it's a very application um based so for example if we have an anonymous uh voting application then uh the group might be a group of users that can vote for a certain voting campaign and the signal can be the actual vote of the of the users and also semaphore is a generic privacy layer meaning it's um a building block that you can use to enable uh privacy and anonymity in your decentralized applications or just applications and some of the use cases are anonymous voting whistle blowing mixers anonymous authentications and many others and there are actual proof of concept applications uh developed uh which you can find online and also we'll link some uh some of them at the end of this presentation so how it works uh the architecture consists of smart contracts and which is the on-chain component and also zero-knowledge components which are usually off-chain but this can also be a hybrid meaning that the smart contract part can be uh off-chain as well so that can be just a off-chain registry and the registry is needed to store the state the permission and to perform the proof of verification while the zero knowledge components are used to to generate proofs and that is the the client side of the architecture and for 704 we use a custom zika snark and that is a zero knowledge construct which basically enables uh all of this magic to happen and uh we we won't go into the depths uh of that in this tutorial but there are great resources online if you're interested to learn more uh about the math behind it uh so uh here is the uh as here is a simple flow of how semaphore works so firstly the users register let's say via smart contract so basically they they can now after they register they can now uh send a signals and basically generate valid zero knowledge proofs which they can use to for sending uh signals to the smart contract and the smart contract will verify their proof and if their proof is valid then their signal will be recorded so in terms of let's say again anonymous voting application first the users will register and they register by creating an anonymous identity which is basically just a hash random cache which they sent to the smart contract and the smart contract records that in a merkle tree structure and then after a successful registration the users can vote and basically they express their vote by by the signal and uh they generate proof offline and they submit the proof with uh together with the signal to the smart contract and if everything is valid then their vote is registered so the zk snark proves that the user has previously registered in the merkle tree and uh also that the signal was uh broadcasted by the user which generated the uh the proof so here is a a little demo of how how this looks like so basically sorry so basically the users need to register first with their identity commitment and this is the their hash that i mentioned and the smart contract stores the user registration in a merkle tree structure and for this example we have two users one of the users which is alice registered previously and the smart contract recorded that registration as successful and now contains the identity commitment of alice in the tree and bob tries to register with a valid identity commitment and then then the smart contract uh records uh uh bob's registration and adds bob in the merkle tree as well uh so now the tree contains two leaves which are the commitments of alice and bob and now bob can can vote uh assuming that he provide generated and provided a valid zero knowledge proof along with his uh vote and in this case we assume uh everything is valid and his vote is recorded and now this example bob tries to vote again but this is unaccepted because on the smart contract can can verify and disable double votes because because of the cryptographic properties of the information that the pope sends along with his proof so basically that the smart contract is able to determine if this is a double vote or or not then in this example we see that another user which is previously not registered that tries to vote but this would be also unsuccessful because the smart contract can verify uh that this user is not in the tree but also the user cannot generate a valid proof if he is not if he is not a part of the 7 4 membership tree okay and also the uh the smart contract also prevents a double registration so if bob tries to register twice with his with the same identity commitment then he he won't be able to do so okay so that was a short overview of symbol for and now let's continue with the rate limiting nullifier so this is a construct very similar to semaphore but it also enables spam protection and the spam protection is especially important in anonymous environments because the strength of anonymity can also be weakness so for example let's say in anonymous crystal chat application example it's it's really important to be able to prevent spam and you know in anonymous environment it's hard to do that because we cannot uh find out who the spammers are because their identities are unknown and for that uh we can use rln to help solve this issue and also spam protection is crucial for for many other applications because uh as i said the users can abuse the anonymity property very easily uh so how rln works is that it provides some protection by two steps so the first step is raising the barrier for entry in the group and that is achieved by providing uh a certain form of stake by the end users which is which has a high subjective value and this also allows for hard replicability and preventing civil attacks and the second step is slashing which is enabled on a protocol level by the proof system of the rln so also online can be implemented in a hybrid architecture the same as a semaphore so we can use on-chain or off-chain registry plus off-chain proof uh generation uh and also uh some some forms of uh the state needed for a registration uh can be of a financial form such as tokens or uh or it can be of a of a social form uh because also the user's identity and public information can be of high value for them and we can do a social profile link linking with the ethereum address easily using the interweb service rln also features a custom zika snark which verifies that the user is part of the membership tree but also that the user provides a valid share of their private key so basically with each signal they send the users must provide a part of their private key basically they like a share of their private key and if if they share more uh uh if they send more signals than allowed um uh per certain a threshold then their private key can be reconstructed so for example let's say we have a instant chat app and we have a threshold of of one message per second and if the users send two message messages per second then basically they will send to two shares of their private keys and and everyone in the group can basically reconstruct their private key and they can remove their state from application and also remove them from the application entirely so here is a quick demo on how this works so in this case we have a chat application and we have an on-chain smart contract registry here we have like two users and the user stored a membership tree on on their end at this time so each chat client stores on a membership tree for their for the users and in this scenario we have a new users uh draw a new user uh charlie trying to register and he performs the registration by submitting a register message to the rln smart contract with his identity and here by public key we refer to the identity basically which is a hash generated from their private key and once they are registered the smart contract emits an event that the charlie is registered and other uh network clients listen for this event and register a charlie in their uh membership tree and also with the registration that charlie also provided the stake let's say a [Music] financial stake in this situation so in this step a charlie is registered and all of the users in the network uh have knowledge uh that charlie is part of the membership tree and now uh charlie can send can broadcast messages to the other chat clients so this is a peer-to-peer architecture and he sends messages and with each message he sends the zero knowledge proof the content of the message the people which is uh basically in this case it can be just a timestamp and his x and epsilon shares which are the shares of his private key and that is needed actually for the other users to verify the zero knowledge proofs uh correctly so he sends one message now and that's valid all the clients obtain the message and register it as valid basically they send the message to the upstream chat client and if charlie tries to send the another message in the same people then he will leak another part of his private key which the other chat clients will deem as a spam and they can reconstruct the full private queue of charlie and remove him from the group and obtain his stick so alice does just that basically alice sends a withdrawal signal with charlie's private key and the smart contract basically broadcasts the signal to the other users to remove charlie from the from their uh membership tree as well so now charlie is removed uh from the uh application and his take is slashed by alice uh okay so that was um overview of the rln construct now we can go over some of the ideas on what can be built with these two constructs which we find that are interesting and here they are so we can build anonymous voting for dows we can build uh fair launch platforms maybe launch platforms for nfts and we can use semaphore for this we can also build anonymous publishing platform uh private and anonymous uh instant chat applications uh using caroline and intro we can build like rate limiting website services such as cloudflare but instead of using captchas the clients would need to generate zika proofs and another interesting idea is a private communication channel for its two validators which which allows for spawn protection and this is very much uh needed and uh rln can be used for this these are some of the ideas and we also also at the end of this presentation provided the specifications for the ideas which uh which you can take a look at and if you're interested we can get in touch for working on that and we've also provided a tools that allow for easy integration with semaphore and aralda basically they obstruct the mods and provide high level abstractions uh on how to integrate them easily in your application and also we are working on a browser extension which makes uh life easier uh regarding 704 and uh also uh i've created a tutorial for uh uh how to implement an anonymous voting application using and it's a bare-bone a proof-of-concept application by using client server architectures which demonstrate how can you uh integrate cma4 in your apps and provide anonymity and you can find the link here and we are also working on an rln uh tutorial which should be available in the next few days and we'll share the link for that too so uh some projects that are in production or uh to be in production are using 704 and rln are are these projects here you can check them out uh and here are some resources which we have provided and also you can get in touch with us on telegram or in the if global uh discord chat we would like love to help you out if you're planning to to build some of these applications or have maybe an idea for other applications uh related to this construct so that's it from my side there are any questions we can get to them awesome awesome that was great like like uh like i said um you can ask questions now if you want to unmute i noticed one question chat which is from jason the rln demo 4 slide do i understand why the charlie party loses anonymity once they are deemed to be a spammer yeah basically their uh identity is prepared basically are the identities their stake at this point and basically their private key can be reconstructed which in other terms they lose their identity here if it's just me then i'll i'll ask a follow-on question so um the the key to that seems to be the definition of the epoch right because you said if they send a message within the same epoch that this releases the additional part of the private key is that configurable um at the definition of the smart contract uh yeah so basically it's uh configurable at the at the whole up level and is highly application uh dependent but the idea is that you have some threshold which is based per epoch and in the in the example of a chat app the epoch can be like one second like every second can be a different epoch and if you like pass that spam threshold then by the properties of the the system your share would be revealed and that's achieved by the shamir secret sharing part which uh basically in the background you can use different polynomial uh depending on your use case and spam press hold that's interesting i wonder what would happen if they made the spam threshold too long and people weren't conscious of respecting that somehow um yeah that's a that's a good uh question and that's why it needs to be uh pre-configured well but but yeah it should be generally set in uh constraints where it's uh it's not too low and not too big and again it's highly application dependent and also in terms of like duplicate messages uh the the the spawn the the private key is not revealed thank you thanks a lot it's been great okay a couple questions here in the uh chat just um uh will the slides be available publicly will you be able to share those yeah yeah for sure for sure and then another question from barry in the chat are there any other constructions that can be built such as a member based on proof of assets with disclosing the full details i.e you need to have more than x tokens but no members should reveal the exact amount of tokens they have yeah i see with that right let me read that question again are there any other constructions that can be built such as a as member based on prusa assets without disclosing the full details i.e you need to have more than x tokens but no members should reveal the exact amount of tokens they have yeah yeah definitely uh uh i think uh unirep is some similar uh example which deals with the reputation but definitely such constructs can be built great any other questions feel free to unmute if you're feeling a question coming on if not um this uh workshop was streamed and recorded so it'll be on the east global east online playlist in about two hours um and i want to thank um owner thank blog our presenter for getting a lot of good information i think at a good pace for a zoom call it was like well constructed and well presented so appreciate that um and again he said you know reachable in the discord um so let's keep this conversation going if you have any other further questions or want to explore any of this um so at that i want to thank everybody for joining um good hacking everyone and uh we'll be in touch on discord thanks 