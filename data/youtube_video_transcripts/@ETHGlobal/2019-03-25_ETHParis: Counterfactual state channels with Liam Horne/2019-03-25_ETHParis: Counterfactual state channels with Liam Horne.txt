up next last talk the entire hackathon Liam's gonna talk about counterfactual state channels presumably Oh ice okay I'm gonna try and go through a I do have might in the charge in a bit but I'll try and go through anyway so alright so I'm gonna talk about counterfactual which is an open source initiative basically to make secure layer-2 applications off-tune applications very easy to build if you have tried to build something in this space that has to do with layer two you might have realized it's very complicated there's a lot of research it's confusing our goal is pretty simple is just abstract away all of the complexity to do with layer two applications so you can write a layer 2 app that's as simple as writing a simple contract and etherium that has a some callers to it so Who am I my name is Liam Horan I'm the co-founder of a company called l4 we're effectively a kind of a software consultancy but we do a lot of things in this space to try and help grow etherium and more generally helping growing decentralize applications that are usable as soon as possible so what am I gonna do here I'm gonna give a quick overview of what generalised a channels are because it's kind of this fancy buzzword that people don't always have a good understanding of what counterfactual is give a demo of an app of an environment that we've built that shows the core functionality and I explain how the demo works so quick background on state channels the if you might if you think about the Lightning Network which you probably of familiarity with state channels are effectively the generalization of that enlightening you if I can effectively send money to somebody else over a network by initially locking it into that network and then what you essentially do is use up sign updates back and forth with other people in the network such that those payments can occur off the main chain and simply between the participants of that network in state channels you can do the same general thing except instead of sending money and just doing a send transaction you actually can allocate some money into an application which can be adjudicated by a smart contract code so it's the same general idea if you want to learn about all the details of this which I'm not gonna go on all the full complexities of it there's a paper elf or two ventures last a channels PDF which you can go to if you want to just go through all the full details which is a very useful if you're interested in more academic perspective of it so I think it's a pretty good description I was going to come up of what a generalized a channel is in comparison to a payment channel so you're probably familiar with a payment Chan the ideas he have a blockchain and what you want to do is you want to lock up some amount of money between some participants let's say - for the sake of this example and you want to keep track of how much they've locked up so Alice might have locked up five Bob might have locked up five and as time goes on what you want to do is you want to have Alice and Bob effectively between themselves over any messaging protocol it's not blockchain related at all just you know met facebook Messenger works sign updates balance a balance be it version zero and version one and version two and this is effectively them sending money to each other and then whatever they're done and they no longer want to be in this quick transitory relationship where they can send money to each other you simply go back to the blockchain if the last signed update and the money goes back so that's a payment channel you might have also seen state channels being described as application specific state channels so if you're familiar there's a company called funfair which builds they call it fake channels but basically what they do is they have casino games where you lock up some money you the person at the casino and the casino as well and you play a game roulette or 21 or whatever casino games you might want to play and it kind of looks like this it's the same idea you deposit money into the contract but the contract has this extra application logic so off chain instead of you're signing a Bal B bail which is one type of data structure you sign some arbitrary data structure right if it's a if it's a really it's a roulette game you're signing a little bit of randomness on both sides to guarantee that you know you can produce an output as to where the ball lands on the wheel and then how the ball lying in the wheel leads to an outcome but basically when you want to put get the money back on chain the contract has the logic to resolve that and so you get the money back so that's kind of an application-specific state channel the really cool stuff though is with generalized eight channels and to think about this it's the same basic setup Alice puts money in Bob puts money in and at this point everything is the same but as time goes on what you want to start to do is try to create brand new applications underneath the state channel not be necessarily pertaining to just one application that's been too in the contract but an application which you define while you're off chain itself so the idea is it's intuitive if you think of it in English Alice and Bob share some set of money between themselves and they want to reuse that pool of money between themselves for arbitrary applications so they have one application that they could do it for or they could do it with a second application and they want to do it with the exact same money that they've allocated right it's just it's you can think of this intuitively if you're out with your friends one night and maybe you go and get food together maybe you go and grab an uber together you've kind of pulled your money for that evening because you just want to move the evening along and so you want to be able use multiple applications while you're together you don't want to necessarily commit everyone's money for one app and then commit to another app with an entirely new kind of entrance transaction you want to just pull your money and reuse it for different applications if that makes sense lots of generalized a channel and then if there's ever a case when you want to get the money back on chain you can just put the latest date back on chain and get your money out there's some optimizations too specifically how you do that but this is the general idea by the way as I'm going through this please just feel free to throw questions at if there's anything you want to know more detail on but this is the general idea so what is kind of factual the first thing that's important to note is that we're not a business there's no counterfactual link there's no token there's no nothing to do with that stuff we're literally just a github repo and a handful of passionate people that want to build this technology into a reusable framework that others like yourselves can use at hackathons like this one to build applications much faster the mission as I've stated earlier it's effectively to change this weird dynamic of everything being way too overly over-the-top complicated and you know queer cryptographic primitives and timeouts and challenge periods you have to think about and just make it so you can write your application get it to users and figure out how to make it more usable and more interesting for their for their lives so now we're the cool stuff what specifically it is that we've built so there's three actually three core pieces but it's more like three core layers and four core pieces of technology or specifications that we've done so I have a cool diagram here that I'll walk through and I'm going to go through all the details to make sure everyone's on the same page we've done three three layers first of all similar to how web three AAS and more generally client-side api's allow you to interact with the blockchain say for example the JSON RPC that meta mess exposes we're building an application layer library they let you interact with layer two lets you interact with your funds that you've deposited with your peers the same way that web three.js lets you interact with the funds that you have in the blockchain so we're building an application library for developers to build apps and layer two the second is because it's complicated how those applications interact right because the idea is you've locked money up for a fixed group of people and then you've used multiple applications it's a complicated scenario we needed to devise a protocol that you and your peers speak to each other with that allows you to guarantee that you're doing things like installing a new app in a safe way so we've designed that protocol if you want to see that part it's at spec counterfactual comm and that is who gives you some security guarantees about these types of things that you can do with it third we've designed this client node software so what that just means is we have software running it's it's a typescript library at the moment but we have software running that implements those protocols right the protocols are just the specification of how you speak to your peers soft we've also written that can run in browsers and other environments lets you communicate to those peers using software and finally because state channels are layer 2 protocol and for all layer 2 protocols if you want it to be trust lists you need to have a dispute resolution layer meaning that if you know I signed a message to send to Bob and Bob doesn't reply to me I need to be able to you know get my money out we've also implemented an entire state resolution layer on the ethereum blockchain that lets you get your money out and effectively the protocols define what you need to see sighing back and forth so that you can use that layer does that make sense does anyone have any questions at this point all right cool sorry we're good cool demo so I think I put a youtube video embedded here so so I'm going to show a very quick demo if I can go fullscreen here I'm going to show a very quick demo and then I'm gonna explain the demo afterwards but this is an example of the type of experience you can have using the technology that we've built and you know how it will extend in the future which you can get the idea of as I go through so so it would give it a bit of context here before I jump into the entire thing the idea here is that we have built a website so this is itself kind of a DAP it looks a little bit like what a wall would look like it looks a little bit like a water well wall it would look like where you can go to this website you can create an account what it's going to do is going to ask you to register with the website deposit some of your funds effectively and that graph I showed you earlier you know depositing money into that contract off chain where eventually off of it off of which you're going to branch new applications and then you're going to see that you're gonna be able to run any type of application within this context the idea is put money in on any number of applications and you're gonna see what that looks like so this is this website the first thing you do is you create an account so this is just essentially authenticating with a server second thing you do is after you create your account the server is gonna get a message saying okay this is a now you use it that wants to authenticate with my my service here and I'm going to create a state channel with them okay so this this service in the back was gonna create a state channel with you so it's not necessary you and your buddy it's you and this service and you're gonna see what's important in a second and then it says okay well how much do you want to deposit and I put in how much I want to deposit and when the state channel is created I will deposit and then the service will also deposit an equal amount and I'll get to why that's important so I put it how much I want to deposit and then at the moment this is demos from robson so there's a bunch of Confirmation I need to happen and it takes time but eventually once the state channel has been created which is a contract on the chain it'll prompt to you and say hey the state channel is created it's now your turn to deposit so put in some money in the case of this demo we're gonna put in some eath it could be anything you want it could be a token it could be it could be anything at all then you say to the whole aetherium but say it's it's it's eath right now twice so it sends me a meta master it asks me to send them at a mass transaction I go to their I click it I send in the money and then we wait a bit longer because now what's happening is I've deposited my money into this de channel and then the server is now depositing their money though again this takes a little bit of time because you get to do it synchronously I go and then the service goes so just bear with the block times here which you can kind of see takes a little while but then once you've finished you've deposited they've deposited everything's good you're now in the situation where this DUI shows you a bunch of applications you can open and say you saw there just a second ago that there's tic-tac-toe and there's a dice rolling game these are two entirely different applications two entirely different sets of application code that it offers to you to play and interestingly what it's going to say is take a bet amount so this is how much do you want to bet on this game and what it's gonna do you're gonna click Play it's gonna wait a couple seconds and all of a sudden boom you're in a game and what it's done is because the service is offering it to many different people it's connected you with another person connected to the service or a real-time game of tic-tac-toe 100% collateralized by you and the and the counterparty essentially and trustless so you can just play it it's not instant yet you I could make it instant if you want to do that but effectively you're playing a game with no transactions against another user every update of which is 100% trustless backed by the blockchain and it's all fun you won some eath and you've actually gone ahead and more and got and just accept accept essentially accepted a payment of 0.1 eath we're having one take that tow game which the interesting part is you'd be literally arbitrary arbitrary vm code and you know i should have recorded somewhere with a few more games so you can get the idea but the idea here is this is a service that lets you what put money into layer 2 and then with anyone else that's put their money into layer to play any arbitrary EVM compatible game 100% trust ously which is pretty cool and then I think in this video I do it and then essentially what you can do after that is go ahead and get your money out and bring it back to the main chain the point one of which you just got out of thin air essentially and layer two and use that for some other thing like crypto kiddies or something like that so so yeah the demo yep mm-hmm that's right that's right so I have a slide will show that briefly but it's an important thing to note that there's no fancy go to chain with the state wait a time I period all that stuff if everyone's cooperative if they're not cooperative that's a different discussion and we have the protocol and the resolution layer to deal with that but if everyone is cooperative which they're incentivized to be this is the experience it's just instant and while all you've done is you've deposited you've withdrawn layer two is simply a deposit withdraw API if everything if everyone's cooperative the incentive is just to keep moving things along probably because you're going to want to reuse that same channel with them again in the future so great next slide yeah that's right and in this specific case the service is effectively acting as a hub and you'll see in a second how it was able to do that but basically it wants your business and wants to keep me want you to keep doing that so so let's dive into what we just saw and again please feel free to ask questions because I've found over the past year working in this stuff big you know it always skips people's minds like the subtle detail so please feel free to ask questions yeah I have some cool look I have a code snippet I think it's on the slides you'll see that in a second so I want to dive into what we just saw so I'll make it pretty like li5 you saw this screen basically on this screen there was a handful of things going on the first thing is you saw it was separated there was an app adapt effectively a layer to Apple app well I guess I was a little too app and then you have this other thing in the top this bar that says how much money you have in the environment within which that app is contained right and these are in the implementation of this and you'll be able to see this if you ever look at the source code which is all open source these are very these are two very distinct environments this demo site is acting like a state channel wallet it's actually containing how much money you have available to use for all the other state channel based applications the state channel applications are implemented inside an iframe this is very similar to how meta mask kind of is in the outside container of your Chrome browser and the Chrome browser the web page itself inside the Chrome browser is like a it's adapt communicating to your my mask wallet the same thing this is a layer two app communicating to your state channel wallet it's the exact same idea the only thing is we didn't write a Chrome extension because we want you to be able to go to the web site and just play around with it but that's really the only reason and so it implements this API like that I was alluding to earlier it lets the dap communicate to this other environment using basically the method the methods on the client node software that expose you know intuitive api's for what you can do with this layer to environment you can install an app when it's installed meaning your cat you've proposed it you've signed it your counterparty signed it which is the general stay channel mechanic it gives you an event hey this apps installed and that render to the app has a very obviously implementable lifecycle system to be able to offer you the API needs to build you may have noticed also that at one point made a mask opt up because like I said a second ago you need to deposit money in if you wanted withdraw money out you have to communicate to some wallet to send the transaction to the chain again your money out now this is basically how I've implemented this specific demo but and I think this two slides in between this we've actually done this work already with meta mask to combine those two layers at the top so you can imagine is that instead of meta mask being the separate thing that's like a layer one thing and then are like iframe demo website being a layer 2 thing why don't we just make this one thing and so we've already begun working in a submitter mask it's it's it's basically what you didn't imagine right meta mask itself is already a wallet it already has a mnemonic inside of it it already has private key inside of it why don't we just build it inside meta mask and so you can imagine well not even imagine you can see this is what the demo in internally that we're working in looks like it right now you just open up meta mask they have a webpage UI now and you can do all the exact same stuff I just showed you you don't need to have you only go to our website initially it'll use the exact same mnemonic and so you have kind of layer 2 features within your layer 1 wallet which a lot of cool stuff is possible with that and I just wanted to hammer home one point a second a second ago about this API this is literally what the code looks like so that tic-tac-toe thing you just saw is a react app it's literally we get clone you know great react app when we ran the script and it's very simple when you click X in the corner it calls this take action method what's the X what's the o and effectively gets to this method that we've exposed using our API they'll let you take an action you say hey for this state channel app take that ou app I want to take an action it's a little bit of extra information here it's not as intuitive but this is implemented by the developer not by us we built the step but but not by us as the counterfactual framework you place X you place y-you say whether or not you're claiming your victory or not this API could be simpler you could just say X Y x and y they know coordinates on the grid of the ticket to a board and the API will it's an asynchronous request if everything goes as plans it will return back and say this is the new state of the app and then you render it so it's extremely intuitive so additionally you might be wondering you're doing all this stuff you're signing messages back and forth to your counterparty you have a representation of the app that's in layer two and the state channel itself what's going on there right now this specific demo is just putting all that in local storage this is a frame this is as you as you're building more production of environments they're gonna want to throw this in better environments but for now you can if you want to go to this webpage later it's literally in local storage all the commitments that are signed between your counterparties are stored in local storage the state that represents your channel is stored here and you can inspect it but the main point I want to at home is not that we use Windows local store just that you locally keep track of all of your state presently in this implementation and this is kind of what it looks like I'm not going to look over every single field here because there's a lot of stuff but they're interesting stuff is that this is a completely abstract data structure representing arbitrary applications on aetherium that are layer 2 compatible so in this case this is not tic-tac-toe I should have put tic-tac-toe in the slide this is a payment channel between two people the data structure is literally using a bi and curvy - it's a destruct Alice address Bob address alice balance Bob balance and what you do is you keep track of the state of that you can see down there currently is that address that address Alice has zero Bob has whatever that represents and every time you update it this this data structure updates and you can imagine that our API simply wraps this and exposes simple methods you can call so when you call take action you give it a JSON object it'll encode it properly generates the thing that you need to sign and send it to your counterparty get it back put that in your in your in your database to win to local storage and then give you back a response to the API method with the new JSON which is this is not what the board looks like anyway it's it's all there so you can inspect all of this so this is running in a laptop as you can see and there's another laptop I played against somebody else and obviously there was some messaging protocol that was going on between them but the thing that I haven't explained yet is that there was no on change channel when I initially made that deposit into the into the website I clicked deposit I wasn't sending that to this guy the person I played against I was sending it to what we call in state channels a hub somebody that's offering this service for me to be able to like other people also connected to the hub and the Lightning Network you're familiar with this concept you can pick you can route payments the same thing here you can route the use of capital for applications if there's an intermediary willing to collateralize that application in this case us the people running that website are collateralizing that application and I'll show you kind of generally what that looks like this is me emo is my coworker who actually just two hours ago gave this similar talk to this at the MIT Bitcoin Expo we were gonna play again each other in real time but what the timing was off and so basically I needed to communicate with him there's no state channel but there's a hub that we're running and so we both created an account with the hub we click register and then what we did is we used a technique called meta channels which is the higher-level abstract term for this other thing called virtual channels the state channel research community is working in it's all terminology but generally speaking we created this this non this is not actually a contract on chain between me and NEMA but we have all the exact same api's as if there were a contract on chain between NEMA me NEMA because this hub collateralized the payment again our paper describes us in good detail as the P er UN / une paper which also describes you can great the teal the tail and it's a really phenomenal concept you can use the state channels this is kind of what we did there the cool part from the engineering point of view is that that hub the service that we've used to register an account with it there's like there's like almost no code that's unique to that server except for when I deposit automatically also deposit like the specialize that logic right otherwise it's literally the exact same code it's running the exact same code it's a state channel node we have a state channel node running in our browser name out of state channel no burning his brother browser the only difference was that it's thought it's data in some Heroku post Christie B or something like that however otherwise it's just the exact same code running the exact same protocol that is using the exact same see at the GS API just locally so what you saw is initially I proposed and install counterparty would get a request I think in the one I showed you it auto accepted because I sent out the request and you didn't see that this particular UI and then after accepted it we went to the hub and said hey hub I want to install this application that okay we use the install virtual app protocol which is essentially as remember it's a specific exchange of messages to ensure that this is secure which you can inspect if you want on our website and it then allowed you to collateralize this application so so that's really it that that's kind of the cool thing about it all of this is possible with all of these applications that you can define in any arbitrary way and I didn't show you the code snippet but I can go to that in a second if you want to ask again then yeah this is entirely built today live on robson so yeah cool yeah any questions and well if there are any I'll pull up that code snippet look at I so this is more like it's more of a speculation question I think that probably web-based eight-channel games aren't going to be the big thing that takes over the world I think there are a lot of interesting things that you can do between BOTS so one idea that we have right now in the state community is what if you were to bought to play some sufficiently complicated game like not go because now eat this alphago and maybe that's still interesting have a stay challenged am around it and then people have to compete too right BOTS and have them compete for money so you're not just playing against in the human but your leading you have to write the most optimum bought and they play each other in real-time and win money that would create an incentive for people to build the best BOTS besides just Google paying a lot of money to people that build bots that are cool I'd be kind of interesting one idea we had earlier when I was talking to Pyotr is that opening I they have this really cool thing where they have like these evolutionary agent algorithm to figure out how you can basically have just you just deploy agents into environments and they interact with each other and then some become dominant maybe you could inject some kind of payment system into that and that would use this and you can hook it up with real money like epic currencies I don't know I think I understand this space like no one really knows what the hell is going to happen so let let's build really interesting stuff that just it's just interesting and it's interesting because we're here and we're playing around with them tinkering with it and as long as it's interesting to us we are currently kind of the users so you know what the presently the people in this building are you know better or worse we're kind of the users of this stuff so what do we want to see let's keep building that and get other people interested and to see what that what happens that way but I don't know I have no idea where this industry is going I just think it's kind of interesting I wanted to address your question though so this is the interface for an application so tic-tac-toe was the other file it's kind of in the top there it I could show you all that code but it's kind of its kind of just basically implementing these four functions so most importantly is it's a state machine so given some state of the state machine which in tic-tac-toe is like the board where the pieces are whose turn it is stuff like that and an action which could be something like apply X or other place X or place o or place X and declare victory and place X and declares R or whatever action types you want to use for that state machine that you implement that in function there's a turn taker function which says that for some given state whose turns it is it X's Terezin toes turn and there's also an in-state terminal so if the game is one or two draw that's the state of a state machine then then it's it's terminal it's done and that helps you instantly exit and finally for any given state of the state machine how would the funds get distributed between each of the participants so you can imagine if X wins actually get the money if a wins I would get the money if it's a draw divide the money in half which is fairly intuitive yeah yeah yeah yeah so we have a we have a we have a bounty up if anyone wants to write a client's a TV em Jess interpreter that's built into ethers Richard Moore from Uther's might beat you to it but we really want that because you're right what happens when I click X slick literally when I click X in my browser what happens is it says okay here's the contract for Tic Tac Toe do 1/8 call to the contract with the current state of the board and the place X function this function return back the result because it's a pure function that's there's no gas cost this is just it's just I'm just running code it happens to be the case I'm running it on some other node and then it gets me back to the new state of the board and I render it that sucks a little bit because then I have to call some other node just to run code but the only reason I do that is because there's not a good open source J s based EVM interpreter as of today maybe in like a month there will be there are some ones that are out there but the API interface is not that great but that's literally it but in the case of a dispute then yes this contracts on chain and we would the contract that adjudicates a dispute would call in to this contract so it needs to be EVM compatible um well I mean there's a handful of it's a handful of things there so you can you can always get the money out no matter what if the person you're requesting say hey can we just get the money out in a safe smooth way it says no you can still get it out basically what you do is you put the latest date on chain you wait a timeout and you get the money out because of this thing called the speaker listener fault equivalence problem is that I can't tell if you can't if I blame you on to the chain for not responding the chain doesn't know whether it's me just griefing you or whether you're legitimately not responding we can't like calculate out that you should like Oh me some money because you're not responding unfortunately the best we can do is pre agree that in a scenario like that we would split the fees then in in that scenario you would be negatively incentivized by a little bit for doing that because you would lose money versus just not losing money you can guarantee you're gonna lose money because that's exactly the protocol is written but maybe you want to do that because you don't like me but if you don't like me then I wouldn't want to be in a channel it with you anyway and this is like this is the enforcement like edge case of state challenges it's not perfect there's always room for some external incentive to lead you to want to just brief me but you can grief me at most the amount that you would also have to pay yourself which is a at least at the very least it's a negative incentive you asked about reputation systems as well so we're building this stuff we're not necessarily building like every possible state channel related thing we're just building this core primitive the the API the protocol state resolution layer and the actual software that implements it and all of those things you described can be built on top it can literally be an app for reputation that can be a default app that you add as a plugin for all nodes if you want to do it that way there's there's all kind of stuff that can be built on top but easily doesn't necessarily need to be built into the protocol I mean yeah theoretically if someone had something of value that you pre agreed to that in some circumstances like that you would you would distribute then sure but you still wouldn't be able to prove whether you're lying whether you're creeping me whether I'm briefing you and so at best you could just divide up the reputation loss in half which is which is a bit of a griefing vector anyway you can plea so yeah sure so basically what you can do is you can play with any number of other users for which there is collateral in your channel to play with in parallel where each of the channels themselves are using different private keys and the money that you could lose if you lose the private keys are themselves capped at the amount of alligator's the app so it's the exact same experience a which you might have if you have different accounts that meta mask each of which using different different systems so yeah it's 100% parallelizable yeah so the the protocols that we devise require that you don't double spend effectively right so if I'm with a group of people here and I want to play six different applications I can't sit all of them we're gonna play these six apps because the protocol that's implement that I'm running and that you're running simply there's no way to get into that state it has to be you except in the my state updates it's a new one in the next five one after the other except however when you've done the installation of the applications updating the state between each of those six people can happen in parallel well all right thanks so much guys Oh dinner it's dinner happening outside right now all right well if you walk around just a couple meters you'll get free food 