foreign [Applause] [Music] how's everybody doing good good good um well we'll be hacking today and I have 30 minutes to tell you about hyperlane so uh hyperlane is a developer platform enabling you to build uh what we call interchange applications so at the core of it it's a smart contract API that lets you send messages from one smart contract on one chain to another smart contract on another chain and so you might ask why why the would I care um if you build an application today this weekend right one one decision that you will inevitably face is which chain do I deploy on and that choice is pretty significant in our world in a way that it's not you know in a web 2 world like no one cares if you use like AWS or gcp but if you choose polygon over Avalanche over ethereum that comes with a pretty significant choice and that's usually one developer experience right different tooling different um execution environments those kind of things uh user experience so whatever chain you're on all the users on the other chains by definition cannot use you so you're basically forcing all of your users that are not on that chain to come to you somehow and that's a pretty shitty experience another thing is platform risk right so like whenever you choose a blockchain like you basically like all of the state of your application is completely dependent on the security of that chain and then last but not least uh value and network effects right like if you say build a yield farming app on like one chain but on that chain there's just like no other activity that you can kind of farm on but like everything else happens on another chain your application becomes much less valuable and so like some people recognize this and kind of doing what we call like the copy and paste model where you just deploy the same contract on every chain right so like sushi and unit swap did something like that where they just effectively deploy a new application on every chain like polygon arbitrum optimism but all of those instances of those applications are completely separate right so like when you use you know Swap and ethereum it has nothing to do with uniswap on polygon um and so there's no like uh Network effects that your application gets from having a having State under chain like if anything it actually might actually be like uh vampiric because like if you run liquid incentives on let's say like uniswap on polygon some liquidity from ethereum might actually just move over to polygon and so what we believe is the future is what we call Energy applications um which are again applications that have Smart contracts on every chain and so users whatever they might be can use your application and so you're no longer constrained by this kind of like forcing the user to come to you um hyperlane itself is not a blockchain it's uh it's built on top of all of these blockchains that we support and it effectively eliminates the need to choose a blockchain you can just be on every chain um and so we think obviously there's a lot of ways of doing that like we think the first place to start is probably to allow basically your own smart contracts to talk to each other via hyperlane but you could imagine in a long-term future uh WP alternate ways of interoperability basically and so what we call basically the previous generation of interoperability which was like acid based right like you basically like forced users to think of assets and how to bridge them we think that applications will just be inherently cross-chain and so there will be like an app-based interoperability um and so again all in all we think that's a better experience of of course I think adding this is more complexity and we can talk about that um so hyperlane at the core is really just a messaging API but we also provide what we call the accounts the queries and the tokenbridge API on top which makes uh things a little bit easier and yeah I'm just gonna do the brave thing of trying to do live demos so the first thing the very base API that we have is what we call the messaging API so on the sending side you basically call what we call the outbox contract called dispatch function with three very simple arguments one the destination chain so that's just like an ID for the chain uh two is the recipient so the address of the recipient um it's uh bytes 32 instead of address because we eventually want to support non-evm chains which uh where it identifier does not fit into uh 20 bytes and so that's why it's bytes 32 and then the message which is just arbitrary bytes whatever you want to send over and then on the receiving side your recipient just implements this handle interface which basically like the systems uh hyperlink contract will call and will basically call Handler with again three arguments one is the origin domain so where did the message come from uh two the sender like which address on the origin chain sent this message and then three the bytes of the message um so yeah so that's pretty simple and so if that's that simple let's see if it actually works so let's go uh so on our docs we have um basically quick start tutorials for every API and I like to think they're going to be simple so let's try to go for it so basically first we have to find the outbox contract so we have like in our docs here a list of like outbox contracts so let's say here optimism this is our outbox contract and here is the dispatch function so again like what do we do we have three arguments uh one is the destination domain so in here we have a list of destination domains so let's maybe send it to over to Fuji um we want to send it to a recipient so we have pre-deployed like kind of sample recipients on every chain that you can use or you can obviously send it to your own contract if you want to um so in this case kind of bc3 or whatever is our test recipient actually I can just show you right now on test Nets no Trace oops remove the zeros uh is our test recipient contract and it's like a pretty simple one if I can find it test recipient all right so it has a very simple handle function here that just emits the message and then like puts the sender and the data in storage um but so we can basically paste that in here and then we can send a message body right so whatever bytes we want so this is written hex so we can just say kind of like hello from if SF copy and paste this in here and then do the transaction pretty sure this will work so we just sign it with metamask obviously if you use hard hat or Foundry or whatever you want you just kind of send that transaction and then you get this transaction hash we have a message explorer that you can use uh to kind of follow along on the status of your message let's explore.hypeland.xyz um in here and then whenever uh oh there you go when it was delivered you can kind of check it out the transaction is here and you can kind of see that we received the message um with our message on Fuji on snow Chase um and that's it that that's how you send a message from one smart contract from I guess in this case optimism girly to Fuji and that was that simple um as I said like um well like you saw like the handle interface is pretty simple um so let's move back here so that was the messaging API that's the kind of what we call our low level API and one kind of downside it has is that it requires you to basically have the recipient conform to a particular interface right like the recipient needed to like implement the handle interface um but what if you could do better and so like a common use case for example is like what if you have let's say a Dao in ethereum that wants to actually own let's say assets or wants to like own contracts on another chain um like with the messaging API you would basically have to kind of like create this like proxy contract on the destination chain which basically takes the message and then like performs the action on behalf of the sender um and so we just extracted that out in what we call the um account API which basically like deploys you with create 2 a proxy account for any given sender address on any given origin chain and can then do this for you so the API looks a little different and I got to do in a second but kind of the benefit is basically that if you are like a account on ethereum you automatically have all of these proxy accounts on all these other chains that can basically like again own assets for you and then also do actions for and so the interface is very simple again it's like a dispatch like on our inner chain accounts router you have a destination chain you have the recipient for which you make a want to make a function call and then data which is just the function call that the proxy account is supposed to make API encoded um and so yeah again an example is governance you have a dial you want to do something there and let's do a demo once again um so again we have a quick start right here under the accounts API so you basically just go like in our case you go to The Interchange account router uh which is right here and has kind of these two dispatches you once again specify your destination domain which uh let's just do Fuji again so let me see what the destination is up this uh destination domain right here and then this is like going to look a little bit more awkward in uh etherscan but like I think when you use like again hard hat a Foundry it will be much easier so basically uh it's an array of calls and then a call is really just like two things right like the address that the call is supposed to do on the remote chain and then the call data which is the API encoded function call and so let's say in this case we basically want to call a function on the test recipient which just happens to be Fubar it takes two arguments a number and a string and so if you again like Wrangle the API it just like ends up looking like this so we'll just copy and paste this in here and then let's connect to web3 metamask yes and then right and then confirm right and so basically I am what I'm like zero x f a d on uh optimism girly and so basically I can calculate the proxy address that this address will have on every other Chain by just like calling like predictable view function so in this case the sender oops that's not what it is copy and paste my address in here right like my sender is on optimism girly so the origin I think it's 420 uh on there and so basically the energy account address which again is an address from which the calls will make on every other chain is like c7ba blah blah blah so let's look at our transaction here take the transaction hash let's put it in Explorer again there you go and what you can see here for example Explorer will actually like decode your message and will determine like hey you are the sender that means that uh when the magic is processed this address your proxy contract will make a function call to this destination address with this call data and so if you look at the Block Explorer here you will see that on Fuji um kind of like here C7 basically made a call to our test recipient that we specified and then the test recipient just emits um this event that basically says like hey like I received this call from my proxy account right c7ba and with these messages and so we think that's another like nice API because you don't actually need to deploy anything under a destination chain you're just like from the origin chain can basically like own things like contracts or assets on the remote chain via this proxy account um so that's the accounts API another use case that we found that we wanted to make it easier for developers is let's say you are on a polygon but you want to like make a view call on ethereum right like there are some states let's say you want to like know the price of the like unisoft V2 top of like if I die or something but you're on polygon how do you do that right and so like what you could do is you could deploy a contract on ethereum and polygon send a message over that contract makes a view call to the unisoft swap and then like sends back a message back to polygon with the results of that view call and so again instead of like making you deploy these contracts we've just decided to like make a similar kind of like router contract that just does that for you and so basically in this case what you do is you call our query router with your query right like of basically the destination chain uh which like Target you want to hit and like what's the view call and then we'll basically do the hard work of sending the message over making the view call on the destination chain and then returning you the results in the Callback that you specify and so the API looks a little bit like this so you do query destination domain the call the call that you want to make it yourself and then again like specifying like what function should the router call On the Origin chain for you and again under the sensation chain you have to specify nothing right and so there's like I guess we have here a UNS example if you want to like kind of call resolve an ens name from a different chain but let's just do once again the demo so we haven't had a quick start right here queries API um basically it tells you to just navigate to the test query Center so we'll go right here actually let's take a quick look at the contract uh test query right so basically what you can do with the Korean address and all it does is really kind of pass through uh the destination domain to call and then it just has like a handle query address result function on itself which the router will call whenever it gets back the result and so let's call it right now so again let's connect metamask uh let's query an address and so once again let's just query what what do we want to query um so we can just create this like a cat like uh content that we have and we can just kind of query for the owner of it and so let's say the owner owner call Api encoded is this string uh once again let's figure out which destination domain you want to hit let's just do Fuji again because it's been working so well um and then rewrite it we confirm and then this transaction happened here once it is reflected once again puts it up I think you will see kind of here query dispatch right which basically means like hey we sent a query over there once again we can use um our Explorer to oops we can use our Explorer to see where the message is at oh that was already delivered right so this is the first transaction where we sent the query over on the destination chain here when the message gets processed we make the view call and then actually we send a message back so this is what we call the dispatch event right so we basically return the query with the result which means that this transaction hash actually like the destination processing of the message itself is actually another message and so we can see that here so that's basically have this return message that now sends back the query result back to the origin chain and then once that is done uh on here you can see that the query was resolved um and actually if we look uh right here recruit we can see basically what the task query Center will just persist the result in storage and that's what it is right here so that's our query API and then last but not least one of the things that people ask us a lot about is like so how do I move value right because a lot of these things was basic information but like what happens when you move when you move value let's say if I have like some yield Farm on like polygon but I like actually see there's another Yield Fund that's really cool unless say arbitrum like how do I move this as a developer and so that's a pretty tricky topic like definitely come talk to me afterwards if you're interested in like the nuances of that but basically we have this token Bridge API which allows us to wrap other token Bridges to basically move value around right and so Circle for example announced the native usdc bridge where you're allowed to like burn usdc on one chain and mint it another and so basically we let you do that within the same interface because we believe that there will be many different bridges that you can use and right like circles only going to be available in some chains and but what you do in other chains and so we will just have this kind of single interface that allows you to move value around and it's again pretty simple it's literally dispatch with just tokens so basically just like specify the token address the amount and then the bridge name so for right now it's only circle on both girly and Fuji and then on the destination chain you can handle that message with the token address and the amount all right one last demo uh is for the token Bridge API so this is usdc on girly right and so one thing we need to do is we need to approve uh the token router with some usdc so let's switch over to girly let's approve uh the spender will be our token bridge router so we'll copy that in here approve at stages one because we're stingy um will approve the router here and which might now means that we can dispatch of tokens so let's again send to Fuji I still didn't remember what the domain is for Fuji so let's just uh Fuji is 43 103 recipient address um we just have again like pre-deployed recipients but you can obviously use your own uh so that's right here the message body again we can put whatever we want um I will just say the classic hello worlds which is where is the message all right here the token is the token the UCC address so like that's this thing right here amount I just do one and then a bridge in this case a circle or again whatever other Bridges we will use in the future we've got to connect metamask and then write that confirm all right and then the transaction is once again here once it gets mined on girly girl you work surprisingly well and as everybody knows here girl Eve is very hard to get so be you know careful um okay let's take a lot longer and again look at the Explorer [Music] I think maybe hopefully your girly won't be too content today but still indexing there you go all right so now you can see here kind of how this usgc was burned right like to the 0x0 address um and then like once it gets processed here oops oh this is well happen in one second oh maybe two seconds I guess um but like it will happen in one second I'm pretty sure I mean if this is literally the last thing it just fails this will be like uh I was so good about life demoing this um but maybe yeah before we get to it I guess um at the end um obviously I'm gonna have you to take uh questions um we'll have a booth all the way to the uh beginning uh we'll be here all weekend uh obviously happy to chat or help out of anything um we'll have four bounties um kind of like best use of hyperlane as well as kind of like best nft use best if I use that's Gaming use as well um yeah but I want to emphasize that we're here to help um we think that the Crush in future is very bright even if we're very early and you could be one of the first people to kind of build these crochet applications because we just think everything will be a crushing application in the future um and I would love to end the presentation oh there you go with and so you can see that uh we minted some usdc to our recipient and our logs basically said like hey I got this message hello world and from this token um yeah so I think that's it um yeah any questions 