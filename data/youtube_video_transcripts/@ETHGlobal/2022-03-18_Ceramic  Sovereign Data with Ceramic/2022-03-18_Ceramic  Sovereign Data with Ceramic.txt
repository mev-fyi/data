ceramic i'll let matthew give himself a quick introduction i think we'll be taking questions at the end of the presentation so if you want to put your questions in the chat we will get to them afterwards make sure to use this chance to ask matthew some questions as this stuff's going to be very useful for your build but without further ado matthew i'd love to give you the floor we'd love to hear your presentation excellent thanks luke uh hi i'm matthew i'm with ceramic i actually just joined the ceramic team like two weeks ago as a developer advocate so um we're building the team out to try to better serve the developers in the community um we're excited to be here uh at the east global event to talk to you guys about what we're doing over at ceramic a little bit so we're gonna start this whole presentation with like a little bit of an overview and a vision of ceramic and we'll jump in and i'll show you how to get started because i think that's one of the hardest things when you're stepping into a new project is how do i get this thing up and running um as luke had mentioned you can put your questions in chat uh i we have a limited amount of time i don't know how many of them will be able to get to directly but if i can't for any reason get to your questions make sure you put them in that discord channel um there's one for ceramic specifically and then i'll show you guys our discord channel um at the end of this please join and ask us whatever questions you have um just in case we can't get to them so that's important there so i'm gonna go ahead and share and we'll uh we'll get this thing moving along um hopefully more in good good standing here i apologize if i'm a little bit uh grumbly and rumbly here uh i'm i'm a tad bit sick unfortunately so um cool i'm hoping we see a ceramic slide and that i shared this screen correctly if somebody in the chat can just thumbs up the fact that you see a nice dark slide on the screen that says ceramic on it you would be a here thank you that is wonderful cool so as i said ceramic overview and vision we're going to start with the overview what is this thing right but before we dive too into that sorry ah let's talk about who we are the ceramic team the team that's working on this project has focused significantly on a very deep web 3 experience as a part of that they've for the past few years since 2016 they've been really adamant about shipping developer products directly targeted at managing that identity inside of web 3. the big product is ceramic and it's kind of made up of some smaller products like the ceramic core the glaze suite self id and soon to be cacao which is uh currently getting fleshed out as we speak the team is also responsible for creating some of these core web3 standards that we see today specifically around decentralized identity so if you guys want to go read up on the entire did standard in spec go for it there's the link i i hope you got a strong stomach for tag documentation if so but the point being is that we've been around the block for a while deep into this space and the project itself is not one that's going to go anywhere anytime soon as it has some of the best backing right now in the web 3 industry so um that's a little bit on the history of things so let's dive into what this thing actually is which is what you care about more i hope um so if i had to sum it up in one sentence okay ceramic is very simply a decentralized network for composable data if only it were that easy right if only we could just hang on to this one sentence and never have to like explain it further than that right even though that's kind of straightened to the point um there's so much more going on and it's not always the easiest to get up and running and working with right away which again that's an experience that's currently changing um so why does something like this need to exist and if we think about the web two-way the answer becomes really obvious without even answering how ceramic is solving it uh the web 2 life right like there's a user a service that typically interacts with another application or some other service at some point that application calls an api maybe two three four api calls down down the way a database gets hit right but it's an api most likely that's that's interacting with that database it's not the user or the original service directly which means that the view that we get back we're going to loosely call it a view the view that we get back from uh the data that might be tainted right there's no way that we can trust that that's actually what was in the database we can mutate that when we get it back before we send it back to the app and eventually render it to the user right the other major problem with this is that the data is like really tightly coupled with this application um typically the the app is the only thing that has access to all of the data sure there might be some exposure of a small seb subset of that data that you can hit using you know some publicly exposed api we see this a lot if you go to any like twitter facebook whatever there's an api for you that you can get information about yourself mostly um but it's it's not everything right and this becomes a problem when you want to create an environment that that interoperates well and in a decentralized way and that's exactly what ceramic aims to solve it's not just that decentralized network where we can store data it it's doing that with the goal of saying hey this application at any given moment can look up the data on the network because it's not coupled to its database it's on this peer-to-peer network so i can just go get that and the user of that application can then mutate that data in a way they see fit and publish that back to the network and the second app gets that update in real time really cool things can be done with a system like this really simple things can also be done something as simple as your friends list can travel with you from your decentralized twitter app down to your decentralized facebook app you'd never need to to re-add your friends they would just be a part of you and your identity the whole way and that's a small example some simpler things that make this really intriguing is preferences right like if you like dark mode what if every application you went to automatically toggle dart mode for you we can get that by saving a little bit of data to this network that these patients are aware of and that they can load now you're probably wondering well there's some challenges with this how does the first app know what the second app knows and and how do we make sure that everybody creates data in a way that everybody can read and understand and that's currently where the biggest challenge lies and it's one of the things that we're working on and really leaning on the community for to say like help us figure out like what a standard social profile on ceramic looks like um help us figure out what a standard preferences profile looks like we most likely are going to be putting a cool little demo in that board channel for you guys so you can see some of this interoperability with ceramic in real time so going back to our initial statement of ceramic is a decentralized network right solving data interoperability we can kind of expand on that a little bit by saying if you use ceramic you're able to create and serve dynamic content through applications that content gets created by an identity one of those decentralized identities that the team has been so ingrained with typically they create that by using a data model but they're not bound to that we could kind of put any data we want into the ceramic network right now the data model makes it to where it's more composable we can share it and say hey the data for this app looks like this this is the schema if you use this schema then we have interoperability it's not a mandatory piece so that the data model part's optional but then where does it get stored well it's not on your backend it's not in some database somewhere it's not in a sql database somewhere it's on the ceramic network itself which is a collection of nodes running the core ceramic client in a peer-to-peer manner and sharing the information about the streams and the data models so that's the long way to explain what ceramic is let's talk about like what the vision of our team is going forward right i think that's important too all of this matters because if you're going to build something like this you're you're looking to solve some things so there's a couple qualities that we sat down and decided were were things that ceramic cared about they kind of fall in the four pillars the ceramic network has to be scalable it has to be mutable it needs to be flexible and it absolutely should check the interoperability box and that means there's a local first design to this when you're creating an application you're spinning up a ceramic node rather than a database and you're you're interacting with that and that node's probably running local on your machine depending on what network you put it on like it can communicate with other people's nodes and then we get the shareability about it but the reason for this is so that we can get faster real-time updates if you had to query across a giant network to get information it's going to take a little bit of time by being local first that's a little bit facts faster it also eliminates the need for some large global consensus situation taking place all the time the data has to be mutable right like we want the users or soon even applications to be able to update the data that exists on the network and that's kind of a little bit uh backwards if we want to trust the data right and how we trust it is by making the history of all those changes a read-only state so we can see what's changed we can read that at any moment it's it's a matter of we'll allow you to make those changes but the history itself is the the source of truth for the existence of that data stream um it's flexible right so whatever you need as far as format goes it's it's the types of data or types of streams is what we're calling them streams those types are expanding and growing we're adding more stream types um as we go through so if you go to jump in with ceramic and you're like man tile document isn't what i need uh tile document is just like uh like a mongodb document it's just a json document it's very similar to that uh it's not it's the easiest way for me to explain it uh there's a tile document data stream type you might be like that's not what i need we have a couple other stream types currently and there's more in the works so ceramic is aiming to expand that uh not only the type of data but then like standardizing it in some way to make it a single unified interface so that everybody has access to that data and that data is tied to to a user well kind of it a user can be an application in the sense it's really tied to an identity that decentralized identity um so anything that that identity owns as far as streams go other apps can call on if they know about them so it's pretty cool and that makes it also blockchain agnostic which is like one of the cooler things about this it's all layered on top of ipfs and it has a lot of interchangeability for the underlying blockchain technology taking place so you're not bound to just building on ethereum if you're going to end up using ceramic polygon is also supported and i think it's going to be more support added as time goes on right so this really makes it to where you have flexibility as a developer and ultimately hopefully this drives a completely new era of open source information where we de-silo data and we can have verified credentials running around we can have preferences that follow us we can take conversations with us everywhere we go and it's not one company or one application deciding what data looks like it's an entire consensus of of ecosystems saying hey like this is the type of data that's valuable to us and we can access it from all around the web it's shared by the people that care about it and the most important thing is you control it it's your data you get to use it whenever you want however you want and wherever you want and that's one of the major major things that matter when we're building out something like ceramic what can you just store well there's kind of like six core components of like what we mean when we say sovereign data sovereign data is like really hard to unpack so if you just think of all the all the stuff that could fit in this these like buckets of of ideas these components right id and reputation verify credentials we mentioned things like cross app data which would be like credentials or cookies that you might have maybe user preferences maybe you have some nft content that you want to use um it most likely falls into one of these components and when you combine these just like the whole captain planet thing depending on if you follow cartoons in america as a kid you kind of get what we mean when we say sovereign data this is a complete picture that you're in control of so before we jump into getting started i just want to make everybody aware we do have two bounties for this this hackathon um the first one is to create a decentralized social app that leverages both ceramic and lens the app should also include a data model second one is to create an application that takes the lens profile nft and uses that as a stream controller with ceramic again couple that with a data model so we're going to jump over do the getting started and then i'll shoot you over the discord link and we can go from there so this is a good ol section of vs code here and what i really want to do is show you how to get up and running um the first thing is you're going to need the ceramic cli this is the core component of ceramic it is what is a what allows you to run a ceramic node um once you have that installed you can simply uh run your local node so i'm going to open three terminals to kind of separate these concerns a little bit to make it easier um i'll rename this one ceramic and then this this terminal is just gonna gonna run ceramic so once you have that package installed which is a simple npm install it's in the docs uh you're gonna do ceramic um and you can where is it at i've glazed my way through this enough okay we'll just ignore it the demo gods are going to get me because my i'm not feeling very well at the moment so we'll do ceramic um and then i'm just going to specify a network for this and that network for me is going to be local and if you don't specify that network there we go that's what i wanted it's the daemon um if you don't specify the network you end up on test net by default which is fine but since i'm just doing a quick demo here i'm going to keep it all in or in memory rather because i've published this data model four five six seven times it doesn't make sense to constantly keep putting that on the test net so if you don't pass in that network flag you'll be on test net and your stuff will be shareable which is cool so that's all it takes is you're gonna take the cli you're going to install it and then you're going to say hey like ceramic start the daemon um you can just hit enter there and you're going to get a node that's running right so i currently have ceramic running it's on this machine i could now query it if i want there's not a whole lot going on as we might speak so the second piece of this tech stack that matters is called glaze and glaze is like a layer up abstraction that helps you interact with the ceramic network a little bit easier again it's an npm package so you would simply come in and and do an npm install you can install the glaze cli and you'll have access to glaze so i'm going to go ahead and i'm going to set up this terminal we're going to call this glaze and the first thing i'm going to do once i have glaze installed is i need to create that decentralized id because again all the data that we're going to work with is tied to an id so i have to have an id and that's really simple we'll just take glaze and we're going to say hey take the did and create a new one for me and we hit enter and we get uh two things so we get the actual decentralized id and then we get this seed uh the ds cut off kind of weird we're going to want to copy this seed and we're going to set this as an environment variable in two terminals okay the first one is this terminal we're going to export did key and we're going to set it equal to this this will allow us to use glaze without having to pass this key every time we run a glaze command i'm going to come back over here to my main terminal and i'm going to do the same thing we're going to export the id key instead of equal there and this will allow us to read it into the application that we have as an environment variable to to use it to actually set up the ceramic instance okay all right glaze is up and running so we can interact with the network in an easy way ceramic is up and running we have that node going on over here even though nothing seems to have happened yet that's okay and we've set up our environment to get started we have our our seed for our id saved and ready to go the next thing we're going to do is we're actually going to create a data model okay and that model is really just a collection of a definition that defines what schemas belong to it and it gets associated with a decentralized id so this ends up on the network and this is one of the key pieces to the interoperability letting different applications pull the data model and they know what the data is going to look like we're going to use glaze for that we simply say hey glaze model create so create us a data model and we're going to give it a friendly name we're going to call it lf grow why not we hit enter and we have a model that's as simple as it gets we can take a look at it inspect and oops spelling matters fat fingers don't and you'll see that we don't have anything in it it's a very empty and blank model so we need to add some schemas to it i've staged a couple schemas to make this quicker i'll show you what they look like we're going to start with the this schema which is a person okay it's it's nothing fantastic it follows the the syntax and the guidelines outlined here at jason schema of this specific draft if you want to know um what keys you can use and what restrictions you can place on this schema you're referencing one of the standards in order to to pull that information over we're going to title it hey this scheme is going to be called a person it's going to define a person we we tell it what type it is and then we define some properties our person is going to have a name which is a string it's going to have an age which is an integer it's going to have friends which is an array of well more people right probably not the most flexible schema in the world not necessarily the point at the moment uh i'm showing it to you this way because it's a whole lot easier to read and what i'm gonna do is i'm gonna use glaze now to to put that into the model right i want to load it into this this schema's model or into the lfgrow model as a schema so the way i do that is i say hey glaze we're gonna use the model api we're gonna add to the lf grow model a schema called person and we're gonna paste in that super awesome json that we had because we have our environment variable set with our didec we're not going to have to authenticate for this it's going to read right from there and now we have a model that's updated and if we were to um if we were to inspect that we can see now there's a schema associated with that okay the next piece we're going to add is the actual like definition for the model and this and it's going to look like this it's a name a description and a schema that's all the definition is what are we naming the model in this case we're going to name it lfgrow uh the description hey it's a demo model and what schema does it point to and it points to this schema back here specifically this version and we're taking the version rather than this identifier for the the schema because you can have changes to your schema and this will allow breaking changes to not impact you if you're just grabbing a specific version of the schema so we pass that in right there so we'll go ahead and do that same thing as before hey glaze we're going to use the models we're going to add to the lf drill model a definition we're going to give it an alias a friendly name we can use it's going to be person definition so now if we again one more time inspect that you can see that we have definitions that are loaded and there's a version for that definition it's pointing to a schema which happens to be a version up here um and the schema exists so our model is starting to be built out uh and and packaged all together so we're happy with that we don't want to add actually any data right now we'll do that through our application like life is grand uh let's go ahead and publish that so we're gonna publish that to the ceramic network using glaze again this is all like pre-application build just getting set up and running right so we're going to publish to the ceramic node that we have running over here and we're going to publish that lf drill model we're also going to create an output file so that we can read it into our application boom so everything is published to ceramic again nothing's really happening over here that's okay and we now have this this file that outlines the model for us if we go ahead and take a look at it we clearly just see it has definitions the person definition it's everything that we get when we look at inspect um just in json format okay i know we're moving quick um so bear with me and life is grand uh the next thing we're gonna do is actually interact with it okay so that's great let's go ahead and fire up some some javascript and we'll interact with this thing let me minimize this for now um as you might expect as developers you guys are going to need to import some dependencies you can find the list of dependencies that you're going to need in the ceramic docks it really depends on what did method you're going to use in this case we're using a did key if you were using something like 3id connect to like tie this in the metamask these imports are going to change a little bit the overall flow of this does not though basically what our code is going to do is it's going to read in that seed that we set as our environment variable and it's going to use that to set up and authenticate our did um service that we're then going to pump into a ceramic client so now when we use ceramic we are interacting as that identity that we put in there okay so we'll start once we have our client we're gonna read in that data model so that was in the model.json we're gonna load that in so that we can reference it by its like friendly name we can just say hey like use person that's an alias we know what person is we know what it looks like and then we're going to set up a did data store we can interact with the data in in both of these ways using the did data store it like ties it to the identity so it's a little bit more tightly coupled with the identity so that's what that looks like i'll show you this it'll be simple uh we're gonna create a variable that just follows uh or an object rather that just follows our schema and then we're going to say hey like the data model stuff create a tile and that's because this is a tile document it's actually pop-up that's because this is a tile document this is the data type that we're using it's tile document so create a tile that uh comes from person well person is the alias that we had loaded in that's what we named that that thing put this data into it and then show us the idea of it right it's nothing nothing crazy but we're about to write some data to ceramic that contains what we needed to so i am going to i'm going to run this script i just made a quick npm you know script thing in here because there's a flag that i needed to add for experimental json features for me so ignore all these warnings uh this is the output of that so we created a stream a data stream when we put john doe into the ceramic network and if i were to copy that i can use ceramic now finally to show that and it's going to take a second and we just pulled that record from the ceramic node that's running locally and what's really cool is if this was on testnet or mainnet and it was able to communicate with other nodes we could just take this same stream id i could pass it over to you and you could get this information into your application as well so that kind of pulls us to time unfortunately there's a couple more things it was just showing you how to use the id data store and how to use um ceramic itself right three different layers they're all doing the same thing though they're all writing a stream and they're all getting data back from a stream so i know it was a lot uh oops we didn't want to stop sharing quite yet i know that was a lot and i know that there's not a ton of time to to ask questions here so what i want to do is leave you with this uh i know this kind of sucks to um to type okay cool if we can run a little longer run a little long uh i'll leave this up here right now too um i will paste this in the ceramic sponsor chat for the east global discord this is our discord if you want to come over to ask us more pointed questions but let's jump back to the demo since we have the time i'll put it in that chat okay so we have a note the stream id is queryable from other applications that um are connected to ceramic nodes where the ceramic nodes are able to communicate with one another okay so testnet really good way to get nodes together i'm actually gonna take this and we're gonna use this here in a second um so i'm gonna take this stream id which we're calling all the the tile documents the the actual data itself we're calling them streams so i'm just going to go ahead and comment this out we don't need it anymore that was just one way to do it and what i want to do is we're going to jump to use ceramic instead of the did data store right now and in order to use the ceramic um part of all of this the ceramic library you need the stream id so this is querying this is querying known documents right so you have to have the stream id there are ways to get the stream id but if you have them then instead of using the ceramic cli we can just call the ceramic library and load that stream too so that's that's what we'll do now i'm going to run my show magic script and bam so that queries it too are we getting much difference out of this no one of them is a terminal way to do it and the other one's programmatic that's all i'm trying to show you is that you can call on ceramic the same way two different ways if you need to what's great about this is now you can do like your application can do whatever it wanted to with the content uh yeah i'll share the magic script also it's it's honestly just node with a flag to use experimental features but i'll show it to you um so now like if you loaded that stream into your application right you have access to this because so you could say hey like every user who's 40 or older gets access to whatever chat room right the the 40 and up club or whoever has friends maybe i can start mapping out a contact list of all of your friends because i'm a social app or whatever it might be looks like we got some stuff in chat can a ceramic model be modified from a d app too by using just the stream id yeah you can modify stuff so you would load that stream in and and kind of apply an update or a mutation to it and and write it back that would be the exact idea is on the app one like maybe i add my best friend to my his wallet to my contact list because i like i'm maybe i'm bankrolling his gambling habit with crypto i don't know but and then on d app too like i need to send him something else or i just need to know his address for some reason or he changed it i could i could edit that on on dap2 if i wanted to so it's not just for queries it's also for writing data if you remember um the first thing we did up here with model dot create tile we actually wrote the data so we could mutate it in this same application if we wanted to and we could do that with ceramic or we could do that with the did data store it's totally up to your convention on how your development is going um so the the final piece to this demo is using that data store so these these uh documents that we put on ceramic are they're just they're kind of there they're not like tightly coupled with with my identity they're apart they're they're attached to the identity remember we had the the seed but they're not um super easily queryable right like we needed the uh the stream id to do that whereas if we use this did data store we're actually gonna say hey like load the person definition if you remember that was a friendly name that we gave to the model um so we're going to say hey like take this data that we want to store find this schema this definition this this data model that i i know the name of and write it as it should be and then if we wanted to query for it later uh we can just say hey like store um go get the tile document or the stream rather associated with this alias so this just becomes a little bit more user friendly uh for or developer friendly really for us to to write and read because we don't have to keep track of like nasty stream ids along the way nearly as much so i'll show you this it's not going to be any more mind-blowing than the other stuff and then i'll show you my my script so we just have a second person um we're going to use the the data store that we set up up here so we're saying hey like grab our ceramic instance and like take the model out of this and create a data store that's really tightly coupled to the the identifier right um and that identifier could be something like 3id connect if you were going to build social apps we spun up a key id um so our application can write data it doesn't have to be a user uh so we're going to say hey like grab the person definition stuff this in that person definition and uh yeah then we're going to be good to go and you might be asking what the person definition is uh i'm pretty sure that is uh when we sorry when we ran the glaze command earlier um we said that we named it i'll show you what we typed we named it person definition right so we ran this glaze model ad and like we gave it this friendly name of person definition so that's kind of where we're getting that from not kind of that's exactly where we're getting that from uh to like load that so we don't have to know the schema we don't have to know what's in it we we've already loaded that model it's helpful if we know what's in it but we can use it now so we'll go ahead and do that we'll show magic takes a second we're not frozen cool and now we have jane doe so this was both a write and a read um so we we actually set the store um using a friendly name and then we uh we read the store using again that the alias that we set up so we didn't need a complex like stream id and now like we can do whatever we want with it right like we're just council logging it but my application can make updates to it um there is a to go back to the question of like can dap2 modify this yes uh it it might be um wise to know uh i think it's set here one of these methods i forget off the top of my head um you'd have to look into the docs a little bit one of them will do a complete overwrite so like if we only wanted to like update jane doe's age and we used uh i think it's set that we would completely overwrite it whereas there's a merge option that would just append to it and i can't remember if that's on the store or if that's on the the model manager but one of them does a complete overwrite the other one just appends and like mutates only what's needed so that's again digging the docs but the the answer is yeah yeah we can change that now that we have it and again like if you have this if the model is published right and the in the model is published to a ceramic network that can communicate with other nodes then we can my d app can pull this i don't i don't have to know the magic behind it i just need to know the name of the model um and that kind of goes back to hey like if you're gonna approach the bounties and stuff like include a data model like we're trying to to figure out like what that that means for the rest of the space so i'll show you my my little script here it's it's nothing of crazy um it runs node this is show magic it runs node with the experimental json modules flag and then it just calls my main if i don't do this then when i'm reading in the [Music] json here it tends to break and not work so that's what it is is that anyone knows the id can read and modify the corresponding data model so um it's not necessarily knowing the dig it's it's knowing the stream id uh but the stream id is is you know like kind of attached to a did so i'll try to paint a picture for you that that helps um reconcile this i'm a user i click onto an app it says connect my wallet i connect my metamask wallet the developer is using ceramics so they they use uh in that case maybe they're using three id connect and when i sign that transaction to to log in and not a transaction it's just a signature right it's not gonna like charge me it's not and we're not putting anything on chain um i'm gonna get a did that now becomes like associated with my wallet being like logged into that application so when i fill out my user profile like when i fill out my name my age and my friends and i post that to the ceramic network it's associated with my did right so it also has a stream id so any app could query the stream id um and then when i go to dap2 and i click connect wallet they're also using three id connect or whatever it might be they get my gid rather than generating a new did um because maybe that's what i chose to do i can also create a brand new did if i want but like let's say i want the interoperability so i choose to reuse what i have now i can query for the data models that are tied to that did because it's the same the id so if i said hey like for this did get the the person definition that's how it's going to get it so it's a little i guess harder to understand with the key did because like we kind of just generated it through the terminal rather than like through something like ethereum wallet which is why i will post i'm just trying to get permission from the person that made the tutorial which is why i hopefully will post a small video for you guys in the discord that will show exactly what you're asking um it's a cool little video that the user logs into app one they fill out a basic profile template and then like two or three other applications also speak that model's definition and they load things like its profile picture or um a couple other like descriptions and stuff so you kind of get a better idea by looking at that and a part of that tutorial is them creating a did with three id connect so you can see how a user might use it whereas in this case like the key id might be better suited from the application's point of view of saying like hey look i'm at application i'm gonna write data so i'm gonna use key d id it's one possible use case is there a mechanism to protect the data model from attack someone adds a lot of garbage to the data uh that's a really good question um as somebody who's super new to the team um i don't know if you're cool with it i'll follow up with you in discord about it i can shoot a message over to who is going to know that and i think the biggest mechanism is the fact that we do have like anchor commits that are on chains so like we could you know see if things are are wrong but i i will definitely ask and follow up because that's a really good question user preferences and other user data could be shared across the apps when a user look at this like and then choosing their privacy um no and i can say that really confidently because if the d apps you're using are let's say ceramic native or they're built with this idea of interoperability in mind they're not gonna store anything that you didn't give them permission to store uh so again this is all elective i have to decide to put this data uh you know where i want it to be that doesn't stop the application from you know like logging some of the stuff you're doing and putting it on chains so i would go back to saying hey like be cautious of what you use like know what what applications you're interacting with but outside of that it's it's a voluntary opt-in process like um you know you click the connect wallet button you know what i'm saying so i don't think it's a violation of privacy if we choose right and and the fact that we get the choice remember that's like one of the major things that ceramic cares about is the fact that users get agency over their data again right so we're trying to make sure that that you're only putting what you want to put inside of the ceramic world the problem is we can't stop nefarious developers right so good questions are there any other questions okay if there are um discord's the place i'm hanging out in discord uh yeah definitely let's continue the conversation and discord i'm hanging out in discord um i'm probably not going to hang out hard this weekend in discord but all through the work weeks i'm there again i invite you over to the ceramic discord you'll have access to more than just me if you do that you can ask those hard questions to the engineers that are actually working to solve those problems um so come join the conversation and we'll do everything we can to help you and i appreciate the fact that 17 16 of you however many of you uh decided to give me 45 minutes of your time i think y'all are crazy so have a good weekend well we love having you matthew it's been a great presentation and i i know i can speak for the audience that we had a lot of fun listening and and interacting uh thanks for joining us this afternoon everyone uh i'm sure you guys enjoyed it as much as i did as he said continue the conversation and discord definitely reach out in the ceramic channels i did post the link that he shared earlier in our chat to uh the ceramic discord follow up there uh they're a great resource they're great team to work with we love having them back um and we'll be ending the session here uh but i want to give a quick thank you to matthew one more time um but good luck with building everyone we look forward to seeing 