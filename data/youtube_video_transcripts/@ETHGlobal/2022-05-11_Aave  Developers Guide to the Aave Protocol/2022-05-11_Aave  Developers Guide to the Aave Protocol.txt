great hi everyone thank you for joining us for our last talk of the day um andrew is going to be doing a ave workshop uh about developer's guide to the ave protocol uh if you have any questions let's leave them in the chat on the side there and we'll get to them at the end of the workshop you can go ahead awesome yeah thanks so much so yeah as i said my name is andrew schmitz i am a web 3 developer at ave which basically means i do a lot of front end development but also working with smart contracts and sub graphs and all the things that make web3 protocols unique and i'm going to talk about extensively how to develop with the ave protocol and so the agenda for today first we're going to look at what's new in b3 the features to build on top of this is especially relevant because the hackathon prices for ave are all related to v3 integrations and then i'm going to talk about how exactly to build so if you want to write custom smart contracts if you want to integrate ave into a front end that includes making transactions uh getting live data historical data and then i'm going to do a live demo of the world's simplest flash liquidity uh we're going to deploy and run a transaction and we can do it extremely simple in under five minutes so uh for those that don't know abe 101 uh basically it is a protocol where people can participate as suppliers so they're providing liquidity and they're earning interest in real time on their assets and then people are able to borrow that liquidity and pay an interest rate and the borrowing happens in an over collateralized fashion so in order to borrow you have to have a sufficient amount of collateral and if that collateral amount ever falls below that amount you have what's called a liquidation where someone comes in and pays back their debt and then is able to claim a portion of their collateral plus a small fee and this is able to keep the protocol as a whole over collateralized and keep the system in check and so ave has this concept of markets um so a market is basically just a deployment of the protocol uh mainly to certain networks so here is like the ave landing page where we have a lot of the different networks that the protocol is currently deployed to um and kind of bridges into what's new in v3 um so there's three main kind of sections of innovation we have capital efficiency risk and then decentralization uh so starting with capital efficiency uh the big the big one is portals so portals is a way to facilitate cross-chain transactions um so previously if you are currently if you want to move funds between different uh deployments of the abbe protocol you basically have to withdraw your liquidity from one market uh bridge it and then supply it on the other instance uh but what portals will allow you to do is it will allow bridging solutions to mint unbacked a tokens so as a user you instead of you know withdrawing bridging and redepositing uh you can just do this all within one bridge transaction and this will allow funds to seamlessly flow between these networks uh and the way that bridges are approved is through the governance process so currently i don't know if it has started yet if not it's starting in the next couple weeks is the first round of approving bridges for this um so currently this is not something you can build on top of but it's something to keep in mind for hackathon projects because you know having a multi-chain approach and building dashboards and tools um is definitely something that would be applicable for v3 uh and the next is something that is live is efficiency mode um so this is a way to maximize collateral efficiency by increasing the collateral factor that's available whenever you're deposit or supplying and borrowing assets within a same asset group so as you can see in this diagram you have usdt usdc these are all stable coins and then you also have an eth asset group and within these assets um you're essentially able to create a leveraged position where you're getting more exposure to these assets but it's not as risky for the protocol because they are all very correlated in price and so liquidations become extremely efficient here and so this is basically just a way to provide enhanced risk parameters for assets in the same category next is risk and security so there's a number of different things that governance is able to now enact to keep the protocol a lot safer so the first two are borrow and supply caps these are pretty easy to understand they're basically just a limit that's placed on individual tokens so say i can only supply a certain number of this asset or only borrow a certain amount of this asset and this prevents against things like infinite minting exploits or exploits which require you know draining the entire liquidity so borrowing all of an asset and then using it to perform some certain action this is a prevention against that and the next we have isolation mode so this is particularly useful for new asset listings so when an asset is listed in isolation mode essentially it can only be used as a collateral by itself and it can only be used to borrow stable coins against it and what this does is it basically allows the protocol to take the risk of listing this asset and isolate it to only these certain asset pairs so it has a much minimized risk impact on the protocol as a whole and this is great for newer assets which want to essentially get introduced to the protocol with conservative risk parameters to start out with and essentially prove themselves as a viable candidate for you know being fully listed as a collateral asset and next is decentralization um so there's a number of things that the government is now able to have so we have risk admins and these are basically entities that can be white listed in order to update the parameters of certain assets um updates um things like the interest rate parameters the collateral factors liquidation thresholds um we also have listing admins so these are people that are able to enact strategies for listing assets so say they are only able to list assets in isolation mode or up to this certain borrower supply cap and this is particularly interesting to look into for a hackathon because you could create essentially strategies for um creating automated listing admins based off of you know a certain amount of staked tokens or a certain you know parameters of the assets uh so basically it allows for permissionless asset listing and it happens through this white listing process where the governance is whitelisting it on address and then this address can perform this function and then some other features that are very useful uh introduction of permit so instead of having to approve the tokens in order to supply or repay um you're now able to do a gas list permit functions saving users fees uh repayment with a tokens so if you have supplied and borrowed the same asset you're now able to repay with those a tokens instead of having to perform you know a flash loan and a swap which is currently what the repay with collateral feature does uh then we have a simplified flashlight function and this is actually what we're going to be using at the very end of this presentation i'm going to show just how simple this function can be and it's also 20 more gas effective and we also have a flash borrower role so currently you have to pay a fee when you're taking out this flash borrow position and people with the flash bar or roll will have this fee waived for them and this is again approved by governance and finally listed assets can support multiple incentives so you can be earning a bunch of different rewards for supplying or borrowing one asset so building on top of the protocol i'm sure this is what you're all here to see um so the main point of integration for the protocol is this pool contract um so the pool is basically what handles the logic for the entire protocol and this is also where most of the main functions exist so the core one supply borrow repay withdraw in addition to kind of the periphery functions like liquidations and flash loans and enabling e-mode and enabling collateral basically anything that involves a user interacting with the protocol that core logic exists in the pool contract uh and then so how do you actually interact with these contracts well there's a few different ways probably the easiest way if you're developing smart contracts natively is to import these npm repos so the ave core repo this is where the pool contract is held and like the core logic for a tokens uh and debt tokens and then we have this periphery repo uh which we'll touch on a few of these contracts in the next section but this is also where the rewards contracts are so for claiming rewards for querying reward balances within smart contracts and then finally for calling these functions we also have a javascript sdk so this allows you to import objects so you would import say a pool object and then instead of having to import an abi and do all this work you could just call pool.supply and perform these transactions directly from your front end and so what i got a qr hook yo here for is just the ave npm registry where you can view all of the different packages that we have um listed there's quite a few ones that i don't have listed here that are still quite helpful for this um oh and then finally down here at the bottom this is um if you want to interact with the navi contract obviously you'll need uh the address link or the uh the contract address um and so this link in the docs in general will give you all of the links for the different markets um so that you can make the correct contract queries and then finally for smart contracts i want to highlight the obese sandbox so this is a tool that lets you take any production v3 or v2 market and create a fork of it inside of a hard hat node and one really cool feature of this is that you're able to faucet all of the production assets so say you want to test an extreme position where you're supplying a whole bunch of a different asset this allows you to do this in a production environment uh by using the faucet you can also connect the sandbox to the abe front end to test your features directly so it's just a really useful tool if you're ever trying to extend the ave contract logic or if you want to test some feature the next is for live data so if you want to essentially integrate what is currently live on app.obey.com into your own interface the easiest way to do that is with these two contracts so the ui pool data provider is where all of the reserve and user data can be fetched so these two functions will essentially return an array of every single thing you could want so for get reserves humanized this is going to return an array of all of the different assets with their parameters their current interest rates uh what is the current total liquidity the total amount borrowed uh the interest rate curves you can see the parameters for user reserves this is all current positions so all of your a tokens your debt tokens uh and then for incentives uh it's pretty self-explanatory for get reserves it's all of the the assets which are currently earning incentives uh what's their admission what is the apy uh then the get user reserves is all of the reserves that a user has claimable uh and the contract helpers the sdk that i mentioned earlier also has objects in order to query these contracts directly as well so the sdk is not just for submitting transactions like supplying and borrowing it's also for fetching data and so after you fetch this data probably what you'll want to do is format it so when you fetch data directly from contracts it'll be formatted with decimals it won't you won't have the usd values and we have this other contract package called math utils and this exposes two extremely helpful functions you can take the data directly from those contracts i just mentioned and when you pass it into these two functions you'll get out an extremely nice user readable summary with all of the interest rates formatted correctly all of the usd values formatted correctly and the user summary will also calculate the user's health factor their current collateralization all of these useful fields anything that's shown on the ave frontend comes from these two functions right here and for historical transactions so when you query live contract data you're getting a view of what the contract is like currently at this current state but if you want to get historical data so fetching all the transactions for a user the historical interest rates the historical balances either for a user or say you want to get the total liquidity for a certain asset on a certain block that's what the subgraphs are most helpful for so i'd link to github right here in this github it will show you all of the different deployments so each market has its own subgraph deployed for it and there's also a lot of helpful examples in this repo of queries for fetching the user transactions fetching historical things and you can also use the subgraph data directly with the math utils package uh because the subgraph data is going to be formatted the same way as the contract with the decimals you know the usd values so this math utils can be very helpful for formatting this subgraph data as well and so now i'm going to move on to the demo so i would actually encourage people if you're able to to follow along because this demo is extremely simple you'll be able to deploy and run your own flash loan and i'm confident less than five minutes it's not a joke so i'm going to show you just how easy this can be so when you scan this qr code you're going to get to this repo which i put together um and so in b3 there's two different types of flash loans there's a batch flash loan which lets you do specify multiple assets and the simple flash loan which is the the new one on this just lets you specify a single asset and a single amount greatly simplifies the process of taking out these flash loans and so i'm going to do an example with this simple contract so all you have to do is open this up and it's going to open your contract directly inside of remix remix is an ide for developing deploying interacting with smart contracts and if you're not super familiar with remix i've also linked a tutorial here from chain link it's an awesome guide for getting started with it so what do we do with this contract first we'll just take a look at the logic inside of it so it is about as simple as you can possibly get inside of this execute flashlight function what we're going to be doing is we're going to call this function on the pool contract we're going to be specifying an asset and an amount and the receiver address so where these funds are actually going to get sent is to this so they're going to get sent to this exact contract and they're going to get sent to this function right here called execute operation and so inside of this function is where your logic would go uh if you want to perform any action call any smart contract function for liquidations for arbitrage for moving funds um you can input any logic that you want right here and at the end of the transaction what it's going to do is it's going to calculate the amount that you owe the premium and this is specifically for test nets so it's going to take the ave faucet and faucet the funds to cover this fee so you don't have any overhead uh it's extremely extremely simple and then this approve is what how the pool is going to pull these funds out after the transaction is over um so what i'm going to do here is i'm just going to compile this contract first so when you're compiling a contract it's important to match the version of solidity so we need to use the 8.10 compiler and after we do that and this loads we'll be able to compile our contracts should pile over k doesn't usually take this long so okay our contract has now been compiled and we can go to this other tab uh and this is where we're going to deploy our contract um so most of the time your environment is going to be set to injected web3 this will link to your custom this will link to your metamask wallet or any other injected provider like frame whatever you want to use um so currently i have my metamask wallet connected here um and what i'm going to do is you're going to want to deploy the my simple flash loan contract this is this contract we have open right here and when you deploy this it's going to take two different parameters so it's going to take the addresses provider this is going to be the market which you want to borrow the funds from and then specifically for the test nets we're going to include a faucet and this is where we're going to faucet those funds to cover the fee uh and i've included all of these addresses here inside of this repo so you don't have to go hunting for them um one other step that is not mentioned here but you will need um the base token for the network so for example if i want to do this contract on arbitrary b which is what i'm currently going to do i need arbitrary eth in my wallet and if you just google the faucets for these different networks each network hosts their own faucet where you can get these assets uh and then they'll just send them directly to your wallet yeah so after i input these addresses here the address provider and the faucets now i'm going to deploy this contract so this is going to trigger a transaction inside of my metamask i need to hide my zoom thing here and after i confirm this transaction it's going to deploy this contract to the arbitrary b test network should be extremely quick okay and now after this transaction is confirmed we now have our deployed contract right here and the function that we're going to be using is this one down here at the very bottom this execute flash loan function and so inside of this it takes two parameters the asset that you want to borrow and the amount so how do we get these so inside of this guide i explained that in order to get the asset address and the available amount what you're going to want to do probably the easiest way is to do it directly from the abe front end um so on the reserve overview page um you're going to get this view so in order to get the asset address all you have to do is click this link and it'll open it in a block explorer and this will also give you the token decimals so when you're inputting an amount to a solidity contract you're going to have to input it as an integer and so each each individual asset will have its own number of decimals so if i want to just take a flash borrow of five usdc i'd have to input five within six zeroes after that and that number would represent five so that's what i'm going to do right now i'm going to go to the details page for usdc uh i'm going to open this oh no it opened my zoom window but here so this is the asset uh and if you click this token page this will bring you to a page where you can see the decimals of the token so i now have the address and i have um the decimals and so for the amount so in order to get the amount that you can borrow it's the total amount that is supplied minus the total amount borrowed so this is just the amount that's outstanding in the contract so i can see that there was five million supplied and zero borrowed so there's five million available for me to borrow i'm actually going to borrow a little bit less than that there might be some rounding and so you always want to go a little bit less than what you see so believe this is four million and then adding one two three four five six decimals to account for uh the usdc decimals so what this contract should do is borrow this 4 million usdc from this pool and then just return it in the same transaction it's about as simple as a flash part as you can possibly execute so let's see once this transaction is confirmed come on metamask okay looks like it was confirmed so we're gonna open this panel block explorer oh this is not the right block explorer i want to use a slightly different one so i can see the uh see the amounts um okay so i can put the hash of this transaction and of course it's not good well i guess i will just go talk about it and then we will revisit this link once the transaction hash is uh is available yeah so basically that's the the probably the simplest possible way that you can execute a flash borrow and so as i kind of mentioned earlier this is only for test nets so because it uses the faucet obviously you can't faucet on a main production network but this is a great way for you to test your logic get a contract out there deploy it run it and then once you have your logic refined then you can remove that faucet deploy your contract to mainnet and do whatever you were hoping to do with your flash so now to the fun part so prices so the prizes that kavi is currently offering for the hack money hackathon is for all for ave v3 integrations um so mentioning a bit like what kind of things you could build um so basically anything that involves interacting with the abe v3 pool so supplying funds borrowing funds uh implementing some sort of data dashboard for these uh doing something with the new simple flash loans doing something with e-mode coming up with a novel way for asset listing or integrating permissionless asset listing through the borrow caps and supply caps and isolation mode so the possibilities are really endless and i really encourage you guys to be creative think outside the box there's so many things that can be built with this protocol and i encourage you to uh take risks um so some resources um this is again another guide to this details the process of you know building with these v3 features uh then we also have a very extensive developer docs which walks through basically everything that i've gone through today in more detail and then finally even if you build a really cool project and you don't win the hackathon not the end of the day because there are still grant programs which will sponsor you to continue building these projects and contributing to the protocol so with that it's the end of the presentation i will go back and check on our transaction real quick oh is it still not found it's a bummer well we can see it in the other block explorer i guess but now i guess i can now open it up for questions as well we wait for this um yeah hey i love your comment but uh so yeah is there any questions from the audience keep refreshing i want this transaction to show up so someone below is asking if uh it said it might be is to add nfp as collateral to ave and wonder if you're already working on this question um i think it's something that's being researched it's quite a difficult topic because nfts are non-fungible this kind of eliminates the ability of using this pool model uh and so the pool is kind of what makes ava unique in that it's uh you know has the pool of all these assets where everyone is traded created equally um so it's definitely something that could be researched using a similar ave model to like governance uh and you know listing certain collections as pools uh but i don't think it's something that's like directly applicable to the ave protocol perfect do you have any other questions from anyone um we'll also have the discord open under each global there is an ave sponsor channel where you can go to all your questions it bums me out that our biscuit isn't working there we go from a smart contract is there a way to harvest programmatically uh so actually so he's asking if you want to supply funds uh through away through a smart contract is there a way to harvest programmatically so i'm assuming this means um well there's kind of two different forms of yield in ave so you have the interest that you're earning from borrowers and then you also have incentives um so you are able to do both of these programmatically um so your borrowing interest is actually accrued um automatically so you have what's called a token so whenever you supply a token to the protocol say you supply 10 or 10 usdc you'll receive 10 ausdc and that balance will be continuously increasing with the interest that you're earning uh and then you'll also have rewards that you could potentially be earning uh and for those rewards there's a separate contract called the rewards controller um and this is under the b3 periphery repo that i mentioned and inside of this contract there's a function called claim rewards so you're able to do that manually or also programmatically from another smart contract using vanilla js is there a way to take advantage of the ava utilities so this is actually something that's on the roadmap uh currently the ave utilities is only written for es6 so this is basically um react javascript uh it's something that's on the roadmap to make it compatible with vanilla javascript i would still recommend if you want to just look through the source code there could be bits and pieces that you could take out if you're looking for just doing specific things like calculating the compounded interest or calculating a rewards balance but no we don't currently have exported functions for vanilla javascript oh that is a great point i should be on test that hard to scan thank you so much sandor i am sure it will be here now ah perfect so here is the transaction we executed um so you can see that this is the pool contract and so the pool contract sent our contract 4 million usdc um and then we use the faucet contract on the test net to mint this 2000. this is the fee for doing performing the flash borrow and then at the end of the transaction this 4 million plus the 2000 that was minted is returned back to the pool um so if this were to be implemented on a live production network uh essentially the only thing that would be different is this step right here um so you wouldn't be able to mint the the tokens to enable to perform this but you could essentially get these tokens from any other source so say you wanted to front the transaction yourself so you would fund this 2000 usdc or if you were performing something that freed up collateral you could then use a portion of your collateral to pay back this fee um or if you're earning um simply a bonus for performing something like a liquidation or an arbitrage that's where these funds could come from um so this contract that we demonstrated is meant to just be a nice example of um you know the things that you can possibly build with flash loans and so i hope this is you know a good starting place if you were hoping to use this feature in your project great thank you andrew that was very informative i'm sure everyone enjoyed that um as i mentioned before if you have any questions bring them over to discord um i think that's off tomorrow and i think don't see any more questions so i guess we'll call it today today is uh the last date sorry tomorrow's the last day of workshops so thank you for joining us for the last one today and there's plenty more tomorrow so we hope you guys tune in yeah thanks for watching everyone 