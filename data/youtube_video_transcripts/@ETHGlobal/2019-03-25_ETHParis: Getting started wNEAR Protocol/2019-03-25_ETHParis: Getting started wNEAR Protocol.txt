uh welcome we are near protocol and we are here to talk about centralizing the web again but more specifically um uh this is a workshop to test drive our dev tools so we're gonna have two people on the stage today my name is jane and this is alex hi everyone um since i have the mic i'll just do a quick intro for myself um i've been in software for a long time but i'm actually fairly new to the blockchain so this is fun for me before that uh i did various things including like logitech google uh my other previous previous recent job um was actually working on pokemon go so yay um i know a bit about scale so hopefully we can get blockchain to be able to support an app like pokemon go that's the goal anyhow so what is near protocol near uh we are a shorted layer one protocol and specifically what are we trying to do different from other protocols uh we are focusing on developer friendly tools and end user experience basically um two main points like if you are an engineer trying to develop apps you should be able to get started like really quickly without installing five different things which kind of like don't work with each other very well and um ideally um you'd want to use languages that are already existing and not learn a new thing so um that's our focus from the engineering side and from the end user side we also want to build in a few things into the protocol itself so that it's easier to make user-friendly app like what i like to say is that um for a really popular app my grandma has to be able to use it and i'm sorry i'm not gonna make my grandma install metamask that's just not happening so until we can fix that um that's good like it's gonna be challenging to have a real popular app and that's where we're trying to make a difference all right so where are we now uh we are not main net yet we have a fully functioning devnet which everybody can try and this is going to be the point of this workshop and we are at a point where we can run a multi-node network and pretty soon getting to testnet but not there yet cool and basically that's all the slides i have so now we're gonna go and just demo everything so um what we're gonna do is actually do some live coding so we we're gonna have two things that we need to do first of all somebody uh come up with a simple app that we're gonna code live this is gonna be cool uh okay sure well that's actually it's funny that you say that because now um we have an example of that that's gonna be trivial do it in three minutes okay open your studio click this particular template create so when we go here this is an online id if you start from a template it will actually give you some starting code to play with and you can kind of browse around the contract itself is defined in main.typescript file this is using typescript which is a standard language this is cool if you know javascript you're going to be able to do this i promise um cool so this is already a to-do i'm gonna click run um what's happening right now is um this online id is actually deploying the contract to our hosted um devnet whoa what happened did i pick the wrong template yeah oh i think so oh my god there was like one thing i had to do right and i messed it up well we'll try again yes so as i was saying what this is doing behind the scenes is deploying the smart contract to our hosted uh devnet and the contract is deployed and now we can go and actually add our to-do oh no caps look bam done okay but let's actually have a different example so that we can search the page is it persistent oh refresh the page all right it works but now let's actually have a different example so that we can we can do from scratch do you want to build to do from scratch whichever how about we build that locking thing but that but that's a pretty prepared you know all right well somebody has to come up with uh an idea of what we're going to build yeah we have storage yes yeah so um yes okay alex how about you come up with an idea encoded okay i'm coding you're coding so he's gonna code and i'm gonna just comment on what's happening um and we're gonna have all gonna have lots of fun just before the fun uh if i could ask that the beverages go out of the amphitheater thank you and food too and now the fun begins sorry okay okay so we're gonna start from scratch instead of cloning the existing to-do we will clone a hello world example so hello world doesn't have much as in it just says hello world it's a very important app though yeah okay so the only function we have in the smart contract today is hello world we will have more so we can add a to-do and so the way we're going to develop because let's pretend i have no idea how to build it we're going to open some other template and we're going to be taking inspiration from it so let's use a guest book so that we don't literally copy paste code from the to-do so the way the way you interact with the storage on near is slightly different than it is in ethereum instead of having sort of class members you do it and you have a api to the storage which looks more similar to the way you do it in web 2. like if you're building a node.js application you're probably going to be using some sort of api like firebase yeah this is basically a key value pair of storage right and so i guess what we're going to do okay so we see the api it's set bytes or set u64 that should should be sufficient to start so there should be also a set string i think it's that item uh maybe we will try set string first okay uh so one thing we will need is because to do is a list of things we want to do and we don't have a list we're going to simulate the list so the first thing we're going to do is we're going to say let um and so we need some sort of a key so the key let's say it's next item and then we see and then let's just store it so set item is effectively setting a string we can try such thing i don't think that will compile well we'll find out we nee we do need an example of compiler for a real workshop so the library function to convert u64 to string is near the string actually have no idea why it is not something more standard i don't know again near.stir will convert next item to a string i guess typescript does not have a standard function for to string text as the argument that is passed it should be just two string you know but i guess there is a reason we we have near. something doesn't work well i guess this is honestly okay so that makes sense right we see we get the next item id store the item increase the next item id and we will also need get to do's it would work well i guess if you do plus plus here it will naturally not work because plus plus would happen after it is stored and like if you do this that that should work no no right yeah yeah yeah that's not happening so like right so so it in general we model it more or less after node.js experience with the idea being that uh one of the ideas is that the ecosystem of javascript developers is a little bigger than solidity developers and so it would be nice to try to convert more of them and so the hypothesis is that if you have experience closer to what they used to you might be able to to convert them all right okay so i get to do's returns the array of strings what's wrong with various things it wants you to return something i see okay and so as you can see this ide is already better than uh notepad but even then like remix for example for solidity because it actually does more sophisticated checks right so you can see erase string is underlined because i'm actually not returning array of strings right so this is more sophisticated analytics that than what any solidity ide does today and that's because typescript is a common language which has a lot of tooling already available for it okay so we're going to get the same next item that's not how i create array of strings okay let's google it i think you may need to pass in the size and but i am passing the size right round brackets or something like that okay let's see new array yeah but how does it know the type of the element i don't think you need the type oh it doesn't care um well like i guess yeah at the very least i need to use round brackets right yeah oh no i think this works let's see all right let's try the string okay so now one thing we can try to do is we can write a test for it testing everybody always tests their code right that's that's how it's done right okay let's see so there's some boilerplate code here uh it uses jasmine which is a standard uh testing framework for javascript and the way you communicate with the with the smart contract is you need to say which methods you expose methods the view methods is something that would be i guess it's called view in solidity as well right a method which cannot change the state that's my guess okay so so the method something that does not change the state so in our case that would be get to those and the change method is something that does change the state so set to do then we can write a test so let's have a test which says okay simple to do test or rather if i add elements and so before all let's say is there a contract exposed yes so contract set to do and you just pass arguments unfortunately you cannot just pass position arguments that would be the best right now the interface is that you need to pass a dictionary of arguments but let's add two to two elements to to do so result is and so you can use async await which allows you to effectively write a code which looks like it's serial but but it uses asynchronous calls to the smart contract and so we expect the result to be probability of this working zero you know why uh well that's just the prediction doesn't compile well we can kill the second thing okay now it's above zero above zero okay let's see um so when you click test um oh you still have a compiler i still do have a compiler yeah uh but um well while alex is fixing the compiler i can talk about what would actually happen uh when you click test and things compiled so this online id uh on test will actually deploy like a test-specific instance of a contract and the that instance will have a clean starting state so it will not have any data and then the tests are going to actually run against that instance of the contract so the compilation error was that next item was union 64. and for array size and for the for loop it expected in 32 so now that this is fixed the test doesn't pass it returns an empty array the reason for that uh that's that's going to be easy to fix is that in the test in the before all when i sent set to do i did not put a weight in front of it so it queued it asynchronously called two of those set to do's but they didn't finish and so by the time it requested them the requests were not processed yet okay let's test this did you do this on purpose no but but this is not the first time i do this mistake and it still doesn't work wait you can actually read the error well i see the error it returns it returns an empty thing right so so so now let's do something cool uh specifically and let's see if that works we can we can log as we go so let's do we can use near.log and so even though this is the backend code this is the smart contract code as you run it unless something breaks that is expected to appear in your development console so effectively the way it works is that we stream all the uh all the messages from the contract execution and we can see total elements is zero that is not at all what we expected but but you see the the debugging process is pretty quick now because i can i can lock something from the back inside i can see that uh the next item which was expected to be two is zero right so the problem is is that next item did not increase and so now let's see what actually happens after we store it so we can we can it makes sense to print both local value and global to see if the storage works let's see oops oh wait it's wrong studio how it doesn't compile anymore that's because i'm trying to add an integer to a string and so that that's also a big difference with the building solidity right because if your smart contract fails on solidity if the transaction fails itself especially then the logging just disappears it depends on the toolings but more often than not that's what's going to happen oh i guess something fails on our side as well um so let's see there there are um [Music] a couple of questions um yeah so basically um what is the app structure for um do you mean the overall id or like kind of like a high level of what goes where we see something in browser yeah so um what is happening is um the contract itself is being deployed to a devnet which is hosted basically by us it's right now a single node devnet and the ui that you're seeing pop up in the new window that's essentially github pages so where like we're hosting the ui for this dev environment and that way you don't have to wear you don't have to worry about where do i put my like html pages um and everything is already configured so that when you're running um the oh yeah it's passing now oh you fixed it good it was the wrong function name it was set to do instead of add to do and it was actually in the log i just didn't see it um cool but the structure is so main.ts is a smart contract that's what's executed as you develop it's executed on the devnet devnet is like a ganache type of thing with the devnet specifically in the studio has its own hosted ganache but if you if you run studio locally you will have devnet locally uh and then your tests and your front end in the way we package it are also part of your smart contract package and so test.javascript is a is something that is not going to be executed by the by the miners it's something that you execute locally in the browser but it is part of the full uh of the full package and it communicates to the contract through this boilerplate code like this this is effectively the connector oops sorry oh do you want to show what happens in the network tab when you run the tests because that's very like oh very enlightening okay let's go all of these requests are actually going to to the devnet which is like the ganache which we're hosting okay so it's executing yes it's calling submit transaction submit transaction get transaction result and if you're really into low level hacking you can like look at the request see what's going on there um it's just sending a bunch of bytes because there's some stuff in between uh so you're not gonna like get too much out of it but you can figure out which url we're hosting this stuff on yeah and so now it fails because we did not redeploy the test and so the state is not erased so now it has four elements instead of two that is sort of expected well right you're supposed to click test every time right uh and now the the way you and again the contra the front end is part of the package so you can very quickly build some sort of a front-end so again this boilerplate code here which instantiates the contract you're again saying which methods you want to get exposed and then you effectively so there's only one div okay let's not over engineer it will something like this work so let's see um well we will know in a second and then let's just have a button right after contract message this is by the way now just plain javascript slash html development obviously ideally you would use something more sophisticated like you would use react or view or whichever have you but for the sake of this short demo i'm gonna make it simple the way this connects to uh to the blockchain we have a javascript library which you can import into any html file and essentially then you are basically going to be um writing code in javascript for your front-end there are transactions right now yes right so yeah so it goes to one of the nodes goes through the mempool ends up on the block uh because the idea is that it's a bft consensus meaning that the moment the block is produced you can you have this uncertainty is not going to be unrolled so you don't you're not waiting for multiple multiple blocks for confirmation and like let's say the block production time is three seconds that means like within three seconds it will get back to you like as an app developer you might still want to have something happening during the three seconds to reduce the delay like if you know what's going to happen like if it's a to-do ideally you will just add it right away hoping that it's going to go through so await and well in a sense the the await uh javascript api um is an equivalent of doing that right so contract head to do will only return once the transaction is settled right so there are going to be events they don't exist today but yeah it's going to be similar to ethereum so okay so let's test it almost worked but also have a weight somewhere where i'm not supposed to oh that's because it's not on the sync function let's give it a try again whoop yay and now we have a working to-do application on the blockchain with uh almost yeah there is a ui bug yeah but yeah besides that let's do the simplest possible fix not only we have the application we have a tests for it too yeah yeah we have a fully functional blockchain application with tests uh what else well what was that 20 minutes not bad decent cool let's do a demo of some stuff that like some some um stuff built when here that's not safe for work you know right it's fine sure okay so we have a few toy applications built on near and if if any of you guys want to build something on here please post it there as well we have read it called build with near you can be famous you can be on reddit yeah you know like sometime in the future you will say i was person number three to post and build on near which is the most popular subreddit today uh but yeah so we have we have a few applications here uh one is uh if you guys know r slash place a very popular subreddit where people just collectively draw something on uh on like a canvas we have this smart contract so if actually this is running on mirror you can draw something and that gets persisted and then you can be proactive like this is constantly changing it's being a little slow i would say yeah and so there's a couple other examples you see what is possible and the cool thing about it is that i don't know exactly how to do that but this is a way to get to jump to the source code i guess if you just oops if you go back to build with with near you can actually open this link in studio which will bring you to the development environment with that particular application in there and then you can fork it and you can just start building from that from that state so that would be your own version of it so if you run it it's not going to have the same picture state is not worked though my internet became very slow okay cool i guess people are showing up for the hackathon right so you see the state is completely empty right now it's it's it's a new product version you can draw something and if we like and we refresh it it's gonna stay yeah cool and we we just finished i think the next person's not here so we can do a couple questions anyone has questions we have an incredible tool here for questions if you don't have questions raise your hand just to catch it no questions cool thank you [Applause] if you guys come up with a question later on uh we are upstairs and we also have some coffee at our table so come talk to us and hang out it doesn't work thank you the other one that i showed is the local one all right okay so up next in this room is provable oracle eyes i'm talking about oracle eyes 2.0 thank you no problem all cheers what do we want to do hello everyone um so i will do a quick introduction on oracle eyes um so how many of you know what an oracle is excellent so um i don't have to waste half an hour to explain that um maybe just a few minutes so we have rebranded um like a couple of days ago to uh provable to better represent like our new strategy going forward you will see that in the initial part of the presentation so what we have traditionally been doing is solving the oracle problem um what is that problem basically that blockchain applications uh live like in a world garden they are not capable of reaching out to the internet and it's impossible to get data from um like a solidity smart contract for instance so what you want to do is basically somehow circumvent the limitation so that you can implement data reach smart contrast and have maybe a smart contract that triggers a payment or some actions depending on real world events so on paper the solution has been called the blockchain article basically and and this is something that in theory has existed for for a while even before ethereum came to life but in practice the need for oracles is very recent because of the complex the the complex smart contracts and dubs that are being built today so the article is basically an entity that somehow and it's not important however right at the moment um connects the external world with the blockchain the blockchain is like he's related so in order to um keep the rest of the presentation consistent and to facilitate the understanding i think it's useful to um like define the main entities with um just three simple names one is like the application in the blockchain space we typically call it dap or you know a smart contract it depends but this is basically your piece of code that is basically in need of data this is the data the data source so basically is what you would like to reach out to and normally in a normal application you would just do maybe an http call to their web apis or something to get data from there so that's typically one line of code uh in most languages right just uh called the api maybe it's a public api i don't even need of authentication in like a few seconds you're done you have the data it's probably in json formatted so you can read it very easily and very quickly unfortunately from the blockchain it's not possible so if the application is isolated um you have the oracle that solves the problem um and the article could be it could be anything it doesn't need to be approvable it doesn't need to be your clients um it doesn't need to be chain link or with net i mean it could also be the data source directly pushing the data to the blockchain for example thomson reuters which is a very common financial data source has an integration with the blockchain so there is no need to use a third-party oracle to connect amsterdam's data with your application you just go to thomson reuters and they do both data source and oracle unfortunately this this is not very scalable um because it's unlikely that all the data sources on the internet will adapt to the blockchain and will integrate with ethereum mainnet you know for different reasons so uh the ambition here is basically to enable a seamless connection with all existing data sources with a blockchain with no need for the data sources to adapt and do the heavy lifting and the hard work that for example thomson writers decided to do so provable is basically enabling death we have been doing that since 2015 on ethereum we launched on september uh 2015 on the hero mainnet and the the way we have decided to do it at the beginning was driven by the context of the market we found basically there was nothing on ethereum back then so we had to design a protocol to get the data we had to run the you know the actual oracle so be an operator to keep the service up and also we had to try to understand what people wanted because there was no one building applications in need of data on the blockchain back then so it was a big gamble we decided to take and actually the traction started coming a couple of years later so what does it mean well that um historically a provable um which it was called like oracle's 1.0 if you want uh has been a centralized service because we were the operator running the entire thing so this this seems like uh to make little sense because the application like the blockchain is decentralized this is the value proposition in most cases like let's keep this decentralized we don't want central counterparties still in most cases the data source is centralized like you want to get data from a single web api or from few web apis that maybe the end of the day get their own internal data from the same source so what happens well basically here you don't really want to compromise the security of the system so you don't want to lose the decentralization and you don't want even basically the data to be tampered with during the delivery process so the oracle in between needs to somehow guarantee that the data has not been tampered with and it is safe garbage in garbage out or if the application is perfect decentralized and transparent but then you feed it with garbage the payment maybe is going to be triggered correctly but on wrong inputs so wrong outputs right that's what you want to avoid and we have been doing that via um providing some guarantees we call authenticity proofs so the authenticity proofs are basically some proofs that try to show that the data fetching process that the oracle did from the data source has been done in an isolated way so that basically there was no possibility to manipulate the data and that the data is authentic so [Music] this um these are the integrations we're currently running like we have integrations with all those different blockchains because like 80 percent of our work is off chain is in like securing the data fetching process and generating those authenticity proofs uh then there is a small integration layer on uh each one of those blockchains and as we have announced few days ago on ethereum we have been just running our own integration as on all the others but we will be supporting for the last mile also other protocols such as chain link or with net and few others that basically have the aim to basically decentralize the network of node operators right now we are the only node operator on the main net basically for a general purpose data fetching one day if people will decide to value the centralization of this service they may decide to choose you know chain link or something else and maybe delegate this task to more to more nodes to mod to more node operators um so in the rest of the presentation i will be showing the existing interface of oracle eyes which is the one you find on every blockchain and on the theorem mainnet and this is the one that is being used by approximately one thousand projects on github so if you go on github and look for the oracle's api you will find like i think now it's a bit more than 1 000 repositories making use of that for the the return projects and these are some statistics that we have collected um to basically show what those projects are building like those data reach dapps and i think it's quite interesting to see that a big chunk is gambling right um the blue one is gambling um surprise surprise uh theorem maintenance as the entire ecosystem basically um has you know huge ambition to decentralize finance insurance and so on but data reached ups at the moment as for the number of applications at least um is mostly leveraging uh like crowdfunding which is icos and assets and tokens that use it internally for the nlogix and gambling ensure finance is here insurance is here so they are part of it but the number of our applications is still limited um so i don't want to spend too much time now on explaining how this works because i we will be around me and the rest of my team here so if you um [Music] want to ask some questions more technical questions on how this works under the hood we will be happy to to answer but in general these are the two keywords like blockchain of course that's the interface like where you want to use the service on and this is like how we secure the data fetching process so the authenticity proofs are based on technologies and like intelligence checks ledger nano s tls notary which is a software resolution technique and few others the idea is always the same which is basically let's prove that a secure enclave a secure isolated process probably isolated process has done data fetching so we couldn't tamper with it so basically the guarantee you have right now with the traditional oracle eyes 1.0 service is that if oracle is the oracle answers then the answer is correct because you can check the authenticity proof but the article may not answer so this is the risk you're taking with our traditional approach and that's why projects such as chilling are trying to decentralize that so that basically it's easier to basically expect that it will answer which is important if you want an application that keeps running for a very long time and you are afraid that the oracle may disappear in a couple of years or in something like that right um still if you are a developer and you expect to bid on something like that you have to do basically your own math and decide um what you need because decentralization is like very important but right now we don't see the actual market valuing it much like we see it also with icos we see it with many different like other components in the network we give the tools to the community and we do a lot of work to give the tools for the community and nobody cares they just want to you know buy the nft they want to invest in the dow they want to invest in the ico before the contract is verified before the contract is public they just don't care so we don't know yet how much people will value decentralization if they don't value it at all the entire blockchain movement will probably fail so we hope they will value it at least a little bit but we don't know how much they will value it so the idea is that the existing oracle is interface um fits really well as for gas efficiency for example if you don't care too much about the risk of the oracle potentially not answering in the future so if you're building it up where for example you are the administrator that's probably not a big deal because you are the point of failure anyway and people are trusting you so that's not a big deal but if your application is supposed to be fully autonomous and run forever with no changes or something like that you can you're encouraged to look for some other approaches that give you those kind of guarantees but our aim with the traditional interface which is why we have decided to keep it to keep the traditional one is to be as efficient as possible so since the traditional oracle's 1.0 interface doesn't need to support a decentralized service the idea is that using that one you get the cheapest gas cost you can because the layer is so thin that is it's impossible uh to make it cheaper for example you don't need to use uh token to you know secure the decentralized incentive system you don't need to have different layers in between to solve disputes or anything like that it's like as thin as possible while if you want the centralization of other things we will be operating also in other networks such as chainlink which is here as a sponsor as well and you can just basically use oracle eyes by chain link or oracle eyes and other nodes or just other nodes it's up to you so basically these are the features of the um of the provable service and in general the existing interface we have is also like very simple typically you just use one function where you specify the url you want which is the api call in 99 of the cases you want to to make so you will see an example shortly it's really simple um basically this is the line of code um this is a 3d contract it's quite old um i will show you an updated version in a second but the logic is the same basically you decide how to secure the um like the the data fetching process so what kind of authenticity proof you want here we have selected tls notary you can select others and here you're just saying reach out to the oracle this is my task i want to get the data on ethereum the ethereum price in us dollar from crypto compare the process is asynchronous so basically the first transaction will reach out to the oracle then the oracle needs to basically process the the query and it will send back a transaction so the oracle will reach out to your contract calling your callback function and the callback function guess what contains the result and the authenticity proof and the authenticity proof can be verified if you look in our documentation you will find more details it's out of scope here but you can verify the proof depending on the way you use the service there is a different cost to verify the proof um right now the for example if you ask for a random number uh from a ledger device like a ledger ios we have a custom application it is open source and anyone can verify you can check that the random number we generate comes from there and you can verify on the blockchain the authentic approve at a cost of approximately 100 000 gas something like that um and then you can do whatever you like with the data right you can just continue from where you left the your logic flow in the in the application um so that's the part for the random number generator so if you care about this use case which is basically gambling a few others probably we have released a paper analyzing the differences between this trusted computing based approach for the generation of random number outside of the blockchain and existing ways to do that without using trusted computing like the most trivial approach is the commit review scheme right there are many other ways to generate random numbers we also know you know about the um other upcoming approaches to generate randomness on chain we may be with the beacon you know on uh future ethereum 2.0 versions but they all have some kind of limitations like for example in the case of the beacon you have just one random number every you know six minutes in the case of um like commit revis scheme it doesn't work well um with applications where the bankroll for example in casinos is shared among investors i mean it's quite complex but if you look the for this white paper we released a couple couple of years ago there is a complete analysis comparing like the trust assumptions we make here with the trusted computing technique with all the other existing systems of course you can use it also to delegate one option context the execution of a piece of code it's the same logic i can say instead of asking to the article you basically get data from a web api you ask the oracle to execute a piece of code and give you the result one nice side effect of using like a trusted execution environment is that you don't need the process to be fully deterministic because it will just be executed once you want and and you will be able to prove that that execution has really happened within a trusted execution environment however if then you want to maybe aggregate this data with um something from other node operators or something from other oracles that do the same you need to ensure in your on your side that the execution is deterministic or that you have defined an aggregation method that makes sense for example if you generate a random number uh of course you know the different like oracles will find a different one so then you need to understand how to aggregate it in a way that makes sense and doesn't break the security properties um so yeah this is basically the description of oracle's 1.0 which we keep offering so it works with any web api and these are the technologies you can select at the moment and um yeah this is basically what has been used in the wild by most projects like on the main network processed one million transactions to date um in like four years basically so some useful links if you're a developer a developer um basically this is the support channel on getter here there is the etymo api one for the interim interface this is the documentation docs dot request contains pretty much everything um [Music] and i will show you some examples in a second this is the main slide if you are a developer you should probably take a picture in case you are interested to use it so basically if you want to use localize on a private chain this is possible and is being done by like a lot of people especially during development um you can just download this tool called the ethereum bridge and the ethereum bridge is basically a node tool that injects the oracle eyes contrast and interface on your local chain so that you can test it in memory or on your own local setup basically so you can test the um organize based contracts on any context with without needing to change even a single line of code um it just works in the same way as it would on the main net or on all test nets we are integrated with old testament basically um you can also use it just in memory if you are familiar with remix um like remix.ethereum.org you go to the official one and in the settings section there is there are some plugins and there is the oracle's one you can just click the organize button and it's integrated straight away in the memory execution you can test it there are some other useful pages here to verify the proofs of chain if you prefer this is a tool so you can verify if for example the one million proofs we have sent back on mainnet are valid or not so you can see if we have ever cheated in the last four years basically um and that's pretty much it so i will show you now um like this is a test query page um the test query page does what you would expect it to do basically you define what's the query um for example here you just say fine this is an http get request very simple and this is the api i want to call could be any api there are some helpers such as the json one so that you can filter down the the full response to just the piece you want um but you don't have to do that it's just for gas efficiency um then you just click on this query if you want you can also select authenticity proof for testing is not needed in production definitely then you wait and here on the bottom you will find or you should have duplicated the screen and basically you get the result is exactly the same you would have by doing the http call yourself that's trivial but doing it via this page gives you the exact response you will get by uh provable basically um so if you go to our github repository there are many repositories um [Music] and for ethereum um like ethereum examples is a repository which contains many examples so i guess nobody is using serpent anymore today we had an api for serpent as well but in solidity you just go here there are more complex examples within the folders in the main one you have this simple examples such as i don't know diesel price for example um it's the the exact same format you have seen in the slide right just request query you define the query this is a xml you can use xml filtering and you get it in the callback right um well the documentation uh doctors are closed it again uh if you go to the ethereum section uh there is a quick start and you find also best practices during the academy it's not that important to follow them maybe because you don't have time and typically everything is just put together pretty much randomly from my experience but if you go to production please go back to this section and read it because it's important also for security considerations to prevent common mistakes or issues last but not least the remix drmx integration so that's the plugin basically um it's quite useful to get started um because without having to to set up the ethereum ethereum bridge on your local chain or to send a real transaction on the main net you can just use remix and do an in-memory execution and uh test this setup with your access integration this is just a stupid contract that basically keeps getting the price of ethereum in bitcoin i think um by the cracking api it does it continuously so this is really bad to run on mainnet because this gets very expensive very quickly um but i mean for testing um it's quite interesting um so again to enable it you just have to go to settings and plugins here you find a list of plugins that are integrated with remix oracle is has been the first one being integrated so that's why it's here if you click you find something like that which i admit looks ugly but it works and does the job so now you basically have to somehow move this window which is always challenging hey i did it somehow and then you just compiled the contract this contract where i already compiled it uh well let me do it again because you compile the contract and you you deploy the contract it should um like in the constructor this is reaching out to our clients um so when you click on deploy in theory yeah the plugin will show you the you have reached out to our clients with a query it will show you some details on the query and the fact that there is no result yet because it's being executed off-chain now right so this is a simulated um like execution of the blockchain in memory and also the integration with arthritis is just in memory it's just been run live and here oracle's has returned the result and sent back the transaction so then in the console you can just read what it did and go on as usual with remix and this is uh quite convenient for testing also something that should work is that um when you click on this id uh here which identifies your query it should send you to an external page to check the query status on the archives panel so you can see under the hood what's going on if you have selected the proof what's the proof and how long it took to generate or this kind of stuff um that's that's pretty much it [Music] if you have any questions i think we have still between 1 and 60 seconds left thank you [Applause] any question trustworthiness is a very interesting word um so if i was asking you what's the temperature here i'm sure the majority of you will go on google and ask google and consider it trustworthy the reality is that you don't know even where google got this data from so trustworthiness is not within the scope of the oracle is on the developer to choose what your application can consider trustworthy so my suggestion is to select independent data sources or the same data when possible like the temperature is an easy example and maybe you can find you know five data sources or something um and try to aggregate the data coming from them um still this gets very expensive this is why it's all it all comes down to the cost of decentralization like do you prefer to like give to your users of your application a cheap interaction with the contract with one and two point of videos or do you prefer to make it super safe but make the interaction much more expensive i don't know i think it should be on the developer as a choice and this will be reflected on the adoption of their platform which depends on the use case i guess i mean the role of the oracle is the one of proving that the data is authentic and is coming from the data source then if the data source has compromised the data or is lying that's not a problem of the oracle that's the problem of the data source the developer has chosen which was not trustworthy after all so the oracle is not about this is not about trusting the oracle is about um using the oracle as a data transport layer to get the data from the internet when you write a piece of code in python out of the blockchain or in whatever language you like you call a web api so is the data transport well it's not a problem of the library you used for the request you have to it depends on the data source on the web api you're calling thanks again if anyone has questions i will be around thanks [Applause] okay 