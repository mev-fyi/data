something there's something over we'll do intros before we go into what access stations are yeah just say that you're the CTO and then because I just killed the intro slide because it was just beyond I have I have this one too whatever yes go to your displacement s all right bonjour I sent some winners in here for the hackathon just a few so uh my name is Bryce I'm part of the core team of ethereum attestation service so my role is around really around like product development product design I do some of the front end Dev stuff and then we also have Steve here let's see do his intro I'm just a CTO full stack Dev for ES and so today what we're going to go through is we're going to spend the first like couple minutes just explaining why we built EAS and then the uh we'll go through some examples that have been built and then we'll really spend a lot actually making some schemas together so you get a better idea of how to start using As for the sackathon we'll also give you some inspiration of some ideas that could be hacked with and go from there we want this to be interactive and I know we probably won't cover all the questions that you have so we will have be at our booth to help interact with you throughout the rest of uh this weekend so how many of you know what attestations are to start nice good it's a newer primitive that is catching a lot of like the narrative today and so we're excited to introduce a little bit more about how we see them so attestations are simply just a digital signature of some structured data and that might seem pretty abstract right like okay about what right so we're gonna go go into that what we're noticing in the ecosystem is that there's a lot of identity protocols being built and while EAS isn't distinctly an identity protocol what we're recognizing is that there's a lot of projects that we're trying to solve digital identity because it can unlock so many new and Powerful use cases and so we're thinking well with all this fragmentation as devs we have to learn all these new protocols right just to try to come up with a more comprehensive view of what an identity is so each of these entities are creating their own type of attestations but none of them are really communicating with each other and so we were thinking well what actually is identity what was your first identity and so we went through that kind of first principles approach we're thinking well when you're born you didn't have an identity and then you did so what happened it's when your mom named you right she said this is my child Bryce and then throughout life other entities started testing about different aspects of who you are the doctor could have attested to your date of birth the identity your identity card could have been attested to by the government you go to school and the teacher attests to your grades your employer attests to your job and your skills into and you start also attesting to other entities you attest to the friends that you like the food that you like so you're not only receiving but you're also issuing attestations and so we realized you can actually represent identity as an aggregate of attestations about someone over time or an entity over time and so if you actually want to solve for digital identity identity it's really difficult to start with just a service or a protocol that just focuses on that we first have to start as a base layer where any entity can make attestations about anything those could be identity related or it could be much more so that's what we built we built an open source infrastructure public good for making access stations on chain or off chain so it's completely open source we have an SDK and a bunch of Dev tools to make the process really easy we realize that if you want to solve for like Trust online and use using these digital signatures for things like Identity or like verifications of any type it's extremely important that it wasn't monetized at the infrastructure layer because then one person would have some advantage or try to game the ecosystem or someone eventually would just Fork the protocol and then just take it to zero so we built it as a public good so it's funded through grants and the the whole idea is to make money on top of the protocol not from within so es is completely open source free to use it runs on two simple smart contracts and we'll get into some examples here but just understand it at a high level there's a schema registry contract which allows you to register any structured data about any topic so that structured data Could Be Imagined we're at this hackathon right and you wanted to attest to the hackathon location you might think like okay well what type of data would be important maybe it's the hackathon name maybe it's the hackathon start time so you might use like start time unit 64. so you start to create the structure of the data and then the second contract allows you to make attestations on that we also allow you to set an optional resolver so if an attestation is made on a particular schema type you can make it mint and nft or do any sort of smart contract functionality based off of the attestation being being made with that schema the traction's been pretty great so optimism they're building their attestation station that you might have heard of in the market they actually deprecated their v0 contracts and upgraded to the EAS standard so we're part of like the native core contracts there and then so so with that we're deployed on base any of the op stack chains will have EAS and we're excited to continue to unite the ecosystem towards a unified attestation layer so at decisions that go beyond identity they can be used anywhere trust or verification are needed and I'm going to be showing you some examples on our EAS scan Explorer it's kind of like the EAS scan for for attestations uh sorry The Ether scan uh for attestations so this is if we think about attestations a social network is simply just a network of attestations right so when you post something on Twitter that's just an attestation of you making a statement if someone likes that post that's also just a like of your post right there are testing that they like that piece of content if they follow reply repost update all these interactions are just one entity saying something about some other subject or or event and so we built this sample UI it's called speaketh and you can see that there's some posting is this is the screen size good yeah got a little bit more you can see that there's these posts being made here's one from Tim he attested GM and then there's a reply there's one reply and a like so if we inspect this attestation underneath the hood this is all running on at the stations so if we click on the attestation record it brings us to the EAS scan which is like etherscan and we can see that Tim attested GM at this time and then each attestation record has its own unique identifier and that can be used to reference things so if we scroll down there were two other entities that reference this uid that they liked it and that there was a post so if we click on the like it goes through a different attestation record and it shows this person a testing like true and then referencing that previous attestation uid so you can start to build very composable networks of statements people are making you can do that all off chain two one other use cases around content authenticity so imagine with all this AI generated content that's being produced produced how do we actually know what's being made by the Creator is real so if you've seen these Tick Tock videos with Tom Cruise he's like running around smiling dude doing his Tom Cruise thing but it looks just like him and I'm pretty Technical and I was pretty convinced so imagine our non-technical friends and family in the next year or two it's going to be extremely scary on how people can actually trust the information that they're viewing online and one way to do that is through a digital signature right attesting to the authenticity of content being produced so we actually built a way for you to Hash any piece of content and then attest to it but this is just an idea of if you're exploring some projects for the sackathon thinking about like attesting to the authenticity of of information and building graphs around that is a is a unique idea this is an attestation record of fake Tom Cruise I actually just like changed it in the UI so this isn't his address but it's Tom Cruise dot ether testing to a hash of his content and then people can verify that content against the hash independently this could all be done through a really pretty UI but the idea is that having a digital signature from an authority like a Tom Cruise saying this is my content uh if you see us by the booth we're showcasing this is a open source app that's all a part of our repo that you can access you can Fork it for this hackathon if you'd like it'll show you how the SDK Works in pretty good detail but allows you to attest to people that you meet in real life it's called met irl.org and if you want we'll be down at the booth but you can scan this and it'll take you to Med IRL with my ens on there and you you'll need to make a digital signature with that so you just attest hey I met Brice allen.eth and then I make a two-way attestation confirming that so on that attestation record what you'll see is this is actually an off chain at the station that was made public there's a uid and then a couple time stamps here and so one thing with off chain at to stations is that they don't have a verifiable time stamp because there's no consensus from the network that says this existed and so what we've done is we we took the uid right and we just time stamped that on chain so you can make you can basically time stamp an off-chain out to station on chain giving it proof of existence that it was seen so it gives it more uh more a more trustworthy historical record of it so here's DAC attesting to me that we met IRL true and then I re-attest it to him and I can show you that in a second and then from this type of data you can start to build these pretty cool like social graphs this was actually one built by Kelvin from the optimism team it's called coolgraph.youth catalog I'll actually load it here but this was people are just testing this is kind of a Mimi one right attesting to cool people so they were walking around just attesting to people and then other people at the event were testing attesting to each other as well but you can start to see this like pretty cool interactive graph of these nodes that we're testing cool to these other entities these other ens addresses and then you'll see like this one node over here is receiving a lot of attestations I'm not sure if you can see it through the color but this one is receiving a bunch of attestations coming in but no attestations are going out and so oh it's actually this one this one has more but that's vitalik's address right he's receiving cool person at the stations but not issuing any so you can start to see that there's all these like nodes that kind of hang out outside of the network which if you think about aggregating attestations for like silver resistance you can start to see these nodes that kind of hang out alone right so someone issued like a thousand new addresses and they're just attesting to each other if they're not actually a part of like the trusted Network graph then you can start to weight them however you'd like so this was uh the the actual access station record it was Kelvin attesting to vitalik true on chain with the uid and then the schema that was used was called cool person private data is extremely important especially if you're working on identity related things it's really important to think through like what actually needs to be on chain or not on chain so we built a way to attest to a basically a Merkle root hash on chain and then you can selectively disclose data against that Merkle root that could be more privacy preserving things so this is kind of an alternative to like a CK proof but it's just allowing you to attest to one entity of testing to like let's say it's a document verifier for your driver's license right they could hash all the different fields on your driver's license attest to the Merkel route and then give you that data and then you could give people leaps of that data to selectively validate against the Merkle root after so it kind of looks like this here's the Merkle root hash you get to prove you verify against it I can show you how this works downstairs too so there's a lot of use cases that can be built we have a use case sheet at our booth if you're looking for some inspiration but attestations are not an identity protocol you can do way more than that with it because it unlocks a very composable and interoperable network so you can build Registries can anytime you need to prove compliance in a process notaries proof of anything like proof of attendance or proof of solvency things like that anytime an entity needs to make use the digital signature to build some sort of trust in in an interaction is when attestations are are valuable so here's some ideas that you could hack we're not judging against these but just to give some inspiration hopefully you can think hey if I could do this perhaps I could also do something else so social graphs knowledge graphs Dynamic evidence nfts based on attestation data and silver resistance zero knowledge attestations generating an attestation based off of so generating an attestation and generating a proof off of that attestation would be really cool a testing to rolls kind of get the idea there so I can uh one other thing are these private attestations I'm going to make one really quick so uh first to start if you want to make a schema you can interact with SDK pretty easily but if you want to do a no code way if you go to the EAS scan on the chain of your choice then you can use this no code Builder so you could say like you know event name and maybe this is just a string but you can choose the ABI in the field type that you want and so I'm going to make just this one make a statement it's just going to be a recipient is to no one but I'm just saying nice chatting with you all and one core thing with an attestation is you can also apply an expiration time so if you want them to automatically revoke that's possible and so I'm going to make this off chain which is just a 712 type signature so I just signed it and it's completely encoded in the URI fragment of the URL and oops and you can store them wherever you want locally you can store them in a centralized Place pass them portably but EAS doesn't even know that this exists in but there's a lot of really cool things you can do with private off chain at the stations as well so we have a few minutes left but uh any would love to hear kind of your reactions and feedback questions go for it do you want to answer yeah because I've been talking a while so in the case of a university it like getting an attestation from like a reputable uh entity you would actually want that at decision from the University or from someone that's capable of verifying a University degree so the the value of the attestation is based on who actually attests so like if I attest that like you know Bryce has passed kyc like it might not mean much to most people but if coinbase does then it then it would so yeah so uh you could create a schema structure for like the diploma or types of whatever information is important and then you just the digital signature would be made by a trusted Authority on that that data type so the schema matters less it the the person who's signing the data is what gives the attestation value unless there's a resolver or a hook on on the schema another question uh in the case of off-chain attestations does the chain ID really matter no right so I mean uh technically you can you know as far as as far as bringing off chain out to stations on chain then yeah you can actually read any eip712 signature and just care about whatever chaining ID you want or none yeah so the Met IRL app that we showed you for a testing that people met is a off-chain attestation on mainnet so zero gas but I'm the contracts are on my net but we are also on train and off chain yes the on-chain attestation data is public correct so if you're if you're focusing on things like identity and stuff then you should think either to use private data attestations right or go completely off chain just make sure you're not putting like actual private data on chain so if you you might want to put private data off chain and pass the off chain attestation to some entity where they can share it on like a need to know basis but in general if you're going to put something on chain then you maybe want to put like some sort of like a hash that has some sort of salt with it so no one can break it so you wouldn't want to actually put any private data on chain that's not what we want to do at all we want to prevent people from doing that no private information yes yes yeah so we actually do have a tool on the Explorer is um so you can verify off chain attestations using our SDK or you can drop any attestation file like directly into our UI and it'll verify using the SDK in the UI yeah so if we if we download well so this raw data that you can see here you can just have that and then drop it into the verify off-chain access station then we'll see if it verified or not or just use the SDK any other questions on off chain or on chain in the back uh can you can you say that a little bit louder he said how do we compare to verifiable credentials okay so verifiable credentials typically follow the w3c standard okay and there's uh typically so the w3s w3c standard was built not related to blockchain technology so it has a lot of data right so a lot of off-chain protocols today like disco and others will use verifiable credentials and I think it that has a lot of value towards like web 2 interactions and stuff but w3c standards um can also be you can also create like dispute records and things with access stations in different different ways yeah so uh the difference is that verified credentials were made before blockchain and they have like a ton of data that you wouldn't want to actually put on chain and also there's no such thing as a schema registry for verifiable credentials so when people are using verifiable credentials to attest about things there is they've never really thought of any kind of schema registry where any entity can register a topic and then that topic gets its own unique identifier and so we think that this is is much better for being able to decentralize all these kind of like interactions another advantage to think about is also the composability so if you were to make an attestation or like not exactly as a w3c verifiable credential but if one access station is made and you want to be composable with things outside of identity maybe it's like authenticity of content signatures and things like that then it allows you to do that in a much easier and faster way thumbs up from the front so here's the testing time is up but if you have questions related to this we'd love to show you the kind of how the Merkel tree approach works but there's a lot of cool things that you can build really excited to see um just the progress from the previous hackathons a lot of cool things can be built using AIS as an alternative to nfts and and things like that so if we're thinking about nfts for verification think maybe an attestation could be used instead [Applause] thank you thank you how does that work oh five minutes after I guess we still had five minutes that does make sense it's okay come again thank you oh you cannot it has to be here any microphones there's no holding microphones foreign testing testing testing testing can everyone hear this okay thumbs up they can let you close some shakes before bring up the slides to start okay thank you but I feel that they'll be a monster if it is using my face yeah okay yes you can share now so all right I think we're ready to get started once we have visuals working all right let's go hi everyone welcome to uh our presentation so today we are going to talk about building secure cross-chain uh applications with chain link ccrp so we're very excited to be here today my name is my name is Harry papacricio I manage the developer Advocates at chaining Labs today I'm joined by my colleague Sol or Solange and also with co-founder and CTO Steve Ellis so we're very excited today because we launched a new product on Monday called chaining ccrp it's been in two years in the making and we're very excited to talk to you about it today but first we're going to talk about the bounties because that's why everyone's here for so we have two tracks in terms of our bounties we have a track specific to ccrp so two thousand dollars for the best three projects that use ccrp um in their submission and we're going to talk about ccip in just a couple of minutes however we have one thousand dollars for the four best projects that use another chaining service in their submission right so if you're building a defy app you can use data feeds if you need Randomness you should look at vrf if you want to do API calls you should look at functions and um you know if you need to automate your smart contract calls Etc you should look at automation so we're not going to talk about those services today because we only have 25 minutes however I urge you to go to the chainy docs at docs.chain.link and check them out so let's go so introducing ccrp so before we introduce ccrp yeah that is a bit bright um I want to talk about the cross chain smart contract because when everyone talks about smart contracts it's usually in the context of a specific chain but what a cross chain smart contract is when you have Smart contracts deployed on multiple blockchains two or more and they each they all talk to each other across each of the networks at the protocol level to create a single unified application right that is the cross chain smart contract and that is what a cross-chain protocol such as ccrp enables you to do so what can you do in ccrp so the Cheney cross chain interoperability protocol launched on Monday it's now live on testnets for you to use in your submission right now so polia arbitrum optimism Avalanche polygon and you can use it for any kind of cross chain s or messages so yeah so you can use ccrp to send messages from one smart contract on one blockchain to another smart contract on another blockchain you can use it to send tokens you can send tokens from a wallet on chain a so wallet on chain B wallet and chain a the smart contract on chain b or smart contract on chain a to wallet on chain B and you can do what are called program Mable token transfers which is basically combining a message and a token in one let's move on so what are some cool things that you can do with ccrp you could send tokens like we said If You're Building defy apps you can use collateral on one chain and send it another chain and make it available on a D5 protocol or a D5 smart contract on that chain and what ccip does is it enables what I call true web3 defy composability right so when we build defy apps and we talk about money Legos it's always in the context of one chain so you have composability on ethereum Avalanche optimism but with ccrp you can take all the D5 protocols and have composability across the entire web 3 landscape where D5 decks on polygon you can combine that with a lending and borrowing protocol on arbitrim right so D5 composability across the board you can do cross chain nfts you could mention nft on one chain make it available on that address on multiple other chains you can combine the cool features of account abstraction and you can add a blockchain abstraction layer to that as well have a think about that Gaming's really cool you can have game assets available on multiple planes and when I play games at home on Xbox a lot of the games I can play against people on PC web free games should not be any different like let's say you're building a turn-based game that's not real time there's no reason why me on arbitrim shouldn't be able to play a game against Steve on polygon this is what ccrp enables so now you know what the cross chain smart contract is you know what ccip kind of is and you think well I've never built something that's cross-chained before why should I try now right so I'll give you a couple reasons the first is you know we have bounties and that's why everyone's here we've lost the slide yep that one yep um second reason this is the most important to me in my opinion right so we've all had a great week at FCC and it's now culminated to the eth global hackathon here um but guess what everyone here is in competition with each other and everyone would love to be have their project declared as one of the finalists right so there's going to be a lot of great projects I'm sure yours will be two but um you need an edge you need something to stand out above everyone else and having your application cross-chain application that you've deployed on multiple chains that talks to each other across multiple chains that's a big deal that's going to impress the judges not just us and if they're looking at two projects that they love and they're not sure which one to progress and one of them is a cross chain application and one of them is not guess which one they're going to choose they're going to choose the cross chain one sorry go back one more time and one more point I'll make is when you use chain link in your project it shows you're serious about security and decentralization and Trust minimization because um that's kind of synonymous with the name chaining right D5 protocols have issues they have care about security uh and and that you're now powered by chain link yep and again so ccrp we think it's the easiest cross chain protocol to use as a developer you can go forward again um we've taken a lot of time to design it so that you can easily just use it with just a few lines of solidity the billing is really easy and seamless and in terms of developer experience and friction we've tried to make it as good as possible so that you can use it and this is important because you guys are on a limited time so um we're going to talk about a bit more about that in the demo let's move on so now I'm going to introduce our friend Steve Ellis here and he's going to talk a bit more about ccrp thanks Harry uh yeah so not only in we it's not we think you should should use uh ccip not only because it has the simplest developer experience and the easiest building model for to integrate with quickly but longer term uh it is the most secure and so if something comes of the hackathon project you want to turn it into something else you will easily be able to scale up use this uh on like on a production level application so just to walk you through some of the security that we have baked into this uh so there's essentially uh three different steps that this goes through uh there is you first send your message the on-ramp at this point you kind of stop worrying about it you just send a message actually to the router and the router then routes that it will get picked up by one of our decentralized Oracle networks these are what power all chain link products this is uh the the base level of security for everything that we offer uh after that it gets uh it uh once the chain has finalized that the message gets written on the other side the arm network will then confirm that message we'll talk a little bit more about the arm Network later but the arm Network checks that message uh and then essentially unlocks what the next uh blesses the message so it can be passed over on the next chain so the chain that's then unlocked on the destination chain and the executing Don picks it up and delivers the message for you on the other side uh so pretty much once you there's lots of security baked in behind the scenes you just have to send one message to the router gives you easy pricing quote um and just to describe the arm Network a little bit the arm network is our security it is a complementary second Dawn it is a second client implementation written in Rust different language written by a different team completely separate so you're sure that none of the same bugs will like no bugs are going to show up on one side and then uh and and they'll be caught by the other so this watches monitors the network brings an extra level of security and but hidden behind the scenes from you you won't have to worry about it your applications can scale up to however much dvl you want uh and so I'd recommend both easy use and long-term usage I think this is a great way to start getting involved with ccmp thank you Steve we're pressed for time so I'm going to move on next slide so if you want to use token transfers in ccip we've got two deployed erc20 tokens on all the chains that are kind of generic tokens that you can use one of them is a lock and Min one is a burn and mint so the lock and mint token um you can go to the uh deploy contract and mint as many as you want and it locks up tokens on chain a and then mince them on chain B and then when you go back it kind of does the opposite it burns them and then unlocks if you want to use the other deployed generic ESI token for whatever purpose you want the burner Mint one it'll burn it on chain a uh minta on chain B and then you know backwards going back the other way so messaging already talked about I'm just gonna once again say you can send any kind of message you want it could be instructions it could be logic or whatever for the receiving block uh contract to do anything for essentially and programmable token transfers once again you can send tokens as well as a message to say hey here are some tokens and by the way here's what I want you to do with them now in the other smart contract on the other chain so just last point for myself the fees is gas Cost Plus premium you pay in link on the source chain and you pay once you can pay a link or in Native tokens for that chain or the wrapped version so you pay on that initial transaction ccrp will handle the rest it'll make sure that the um the other smart contract gets the transaction now we're going to see a demo from Seoul hello well uh I love to do a Hands-On Workshop so I love to do you doing with me but I know that I cannot I cannot do this in 15 minutes so uh are you cop and paste a lot of comments for you are you cop and paste a lot of uh links and then you can do this later and our first you'll be around to help you okay I may move on from this and here we are if you'd like to get uh how that I'm doing I I will be here in this collaborative pet so take a picture of this go to this link if you'd like to follow me now or later okay and if you'd like to add your name and Country here could be good as well and I first of all I read copy and paste some requirements for you so 20 metamaski because I'm doing uh how today from Fuji to sepolya okay this was my choice we have other possibilities I choose this and if you don't have a fuzzy here you can add first tomato mask you can get tokens uh on 4G you need to have it you you don't need to have the link token but because you can pay fees on using link or using uh the Fuji but are you paying links so if you'd like to have link tokens as well is this and my goal is to show you two different ways to do this first using our head to head started kit and then using Remix They easiest way okay that has starter kit is this here okay and from there oh I forgot one thing yes let's be sure that this is working yes this is the hard hat starter kit it's good enough and then from here I'm going exactly to the example tree it's not three I do not transfer tokens I'd like to go to example five no well but I it must be open because uh I'm not I I am in a computer that is not in the network of training yes but he's a you'll be shared with this so I'm doing the example six here we are okay let's edit this for you as well okay and what's the idea of example six is only to send some texts some messages and if you'd like to see another a bit complex example doing the the same thing but not a message but uh I did two days ago in HCC and it's record I transferred it uh I minted a token on Fuji and the token appeared on sepolya so in the same way that I can send a message I can send a comment to another chain so this is another uh good idea for you foreign paste the instructions for you because it's this you get clone compile and we have some uh so important parts to show you related to encrypted environment because uh chain link created developed a new way to have your environment variables in an encrypted file and how you can do this first of all you need to set up a password and every time that you are open your uh your repo you need to set up this and I think this will be too small better for you okay so why me here I need to set up my password again and because I did this before I need to use the same password every time that I came here yes I think I mean right and after this you need to set up it this variables okay uh these three variables and like you get your private key I'm going from a village to separia it and you run this command and set up each of it okay and following my my coupon paste uh like if you'd like to get the URL directly from chain chainlist.org it's good it's easy okay this is another trip trick for you and I have in mind then I can show you here because it's encrypted you can do nothing with this and this is the example what we need to do is this part so if you can follow me we are here so are you deploy the basic message sender on Fuji and I already set up pages okay you can see that this is uh it's not my contact yet we need to wait a bit yes this is my contact okay share with you because maybe we'd like to see my content later well here let's put this near okay uh no not this I can see my my keyboard it's so dark okay this is done let's go to the next step that I have here my step is here uh you need to send to fund because I'm using link I need to fund with link my comfort let's fund it uh you don't need to send the one link can be less but to be sure now I'm sending my link we are using less than 0.1 so I'm I'm in the right account and I'm ascending to this address not a wax but the link token and one link in our starter kit you can do this in a comment as well I'd like to use metamasking this point now okay I have the same there and you go to the other chain and deploy the receiver here yes I have the comment done and in some seconds that you have the address of my receiver and I can copy the next comment for you as well because after this we are sending the message okay and I'd like to get my transaction let's prepare this for you is the same and let's see what's happened here uh yes almost done wait a bit more I don't know if it's my internet I have another receiver that I did before maybe I can use it should be fast I use this receiver before okay and then like after after that I have in my uh like after I send and after I receive I have the singer and the receiver I can send the message to send the messages I need to fill the sender this is the center and I need to fill the receiver let's see if my new receiver is here not yet let's use the audio receiver because I cannot wait now this is the receiver and this will be my my message I change my message my message you'll be hello it's a global studies and any paying fees in link let's do this no I need to wait oh okay so I'm awaiting this let's do another Point as well because I told you that I'd like to do another contract using remix so the remix part you'll be this uh we have the this tutorial in on remix okay the cross chain tokens and we have a lucky Henry said before we have a special token that you can use to test and to transfer to all places I have it is as well and this is some parts that we need to have I create a special contract to use this that I did some part faster for you are you at my content here because it is not on the documentation and you can use this content you can copy and paste this conflict because I put out the information that we need the how there's everything is here as well and I have the right interface and this concrete that it is here what I'm doing here I'm using the how to do the transfer I'm using the chain link client the link token interface and another uh interface for the uh the token that I told you before okay and everything is set up here right this is the Hotel this is the link token this is the address of the CCAP test token and the destinations change selector where I go to this is important to you to understand where is this like this is the supported Networks and here you can see that for example if you'd like to go to understand sipolia this is the chain selector to go to sepolia this is the how we go to sepolar to other links Amy on Fuji so this is the I'd like to go from Fuji to sepolia and I have with these tokens that I can use in this time okay and what's happened here oh finally okay oh two minutes I know uh are you not are you sending my message but uh we cannot wait my message to be in the other thing because it you used to have four minutes to to move from one chain to another unfortunately next time this guy you're not talking before me I I start myself and then you talk later yes and this is my receiver now can I add my receiver here this is my new receiver and I assigned this command and then we can check the translator in some place this is the message and when I got to the transaction I can check this in our ccip Explorer yes this transaction will save my life but this is only a part of the transaction this is one part and we need to get the other part that is here and okay this is my Transaction what are you doing [Music] once the Source finalizes then we will the arm network will bless it to pass through and it'll get picked up so yeah right now we're still waiting for chain finality this is a security mechanism just to make sure token transfers don't roll back uh yes and we have three status here it's certified finalized blessed what is blessed uh blessed is on the arm Network the second implementation the second client has said has also verified that this uh this is a separate Dawn Network that essentially or decentralized Oracle Network that checks the one that they don't have access to move any funds they're they're purely a security mechanism okay great and uh the last stage you'll be the finalized when you really can check the other chain and the see whatever you'd like to Silver that can be the message for now remember that I added this for you so in a film in two in two minutes you can check here and see that the message is over there and why we need to wait so long time and why is this timing uh this timing comes from the blockchains finality uh so yeah in this case um it is how many blocks deep uh Avalanche has to be before uh is guaranteed final ity okay yeah so is this I know that you have here the all the contents that we need to check it now but I know that yeah I couldn't finish what uh if I have you one more minute I have one minute yes okay I have your anonymity I'm so happy I can go here and using the content that I shared with you and the other average setup it I will deployed the content just now here we are I have others deployed but let's deploy a new one and okay this is a is my contact you can check my contacts later no this is not my contract my contract is here so this is my content I need to fund my content as well with link so let's go here send uh signs from not from account no no no cancel and send it to Jesus address and send the link again remember that I can pay with a vax as well and once it's funded I can see I can send the message let's use the order that I did before this is my example transfer and let's switch this transaction be confirm it contract interaction confirm it this is the block Explorer so if I go to I will explore it and see this this is the other transaction that I did now and we are waiting for this transaction as well and this I read mint tokens in one chain and this will be minted in one chain Bernadine chain and appearing another chain this is how the process let's see I the first is then oh I'm so happy because now we can see let's go let's come back here to finish our Workshop here I send the message and I can go to the receive address and can see this okay let's edit this for you to be sure that you can see with me and this is my receiver address that I changed what my new receiver address because I changed the messaging receiver address where are you now um here is there is receive address and let's see our message and hello it's globalpatties thank you everyone [Applause] [Music] um it's a uh no problem foreign everything is good yesterday if you have any questions try to learn more about in one session where there's another one I want to uh thank you all right foreign because yep foreign yeah we're going to be I think the most important thing is for yourself foreign I want to make an emphasis today on predictable rates uh because we have in the market with compound another hello hello perfect thank you um with normal lending platforms you have viral rates they change based on how they get utilized in the market how many people are supplying or borrowing that asset in the case of maker the utilization doesn't affect the rates the rate is actually defined by governance so you actually you have kind of a nice smooth experience with rate so you know how much as a borrower how much you're going to be paying we do change that rate so it doesn't it's not a fixed uh fixed rate or fixed term rate as it's commonly known but when it does change first of all you know when it's going to change and you also know what value is going to have at the end so this actually leads to a better experience from both the the depositor and also the borrower site so before App Maker you can only be borrowing uh through the cdps so you had a single collateralized position you will report a die and that was pretty much it now we're morphing into this new model where we actually have a lot more ways of interacting with predictable rates uh through maker so on the borrower side now you have Spar protocol it's a new Landing platform where you're able to have multiple collateral positions so you can deposit eth and any stake teeth derivative I'm going to die at this predictable rate uh you can also be a depositor you can deposit uh die in the DSR this is the die savings rate module essentially we provide yield to die holders based on the protocol revenues um allowing to again as a depositor get this predictable rate on you and what we are going to be showcasing today which is the most exciting thing is conduits so this is more if you're a builder you are able to create a basically a connection or interface between maker and external protocols um to actually provide this have this Ray provided to you so you essentially get to tap in and to make a liquidity um in a in a fully standardized and secure way so now when we get that going on I'm going to be showing uh well Lucas is actually going to be showing how you're able to build this conduits and get a connection so this can be on a any sort of like external protocol it could be any Landing Market it can also be on your TAP as well you can actually have this content connected to it let's say you want to build a use case for wheel assets so you're actually doing you're moving funds of chain this is also um possible with conduits essentially because um in what you define in the interface is the communication between maker or what we like to call the subdial and the arranger the ranger being the pro the external protocol and on chain or of chain this is a new way that we will be able to expand similar to how uni swap is having hooks so you can have full customization within a certain level parameters you can do the same thing when you look at maker and liquidity provision um and I think with that I can hand it over to Lucas can you oh I need to give you actually yeah we're still trying to sort out some technical difficulties here sharing the screen um but what I can talk about without sharing is that I'm currently working on the arranger conduit the ranger conduit the goal of it is to provide like a standard contract that multiple rwa Rangers that are currently working with maker Dao can move to in the future as well as you know future Arrangement structures that are deploying into treasuries or different real world assets can use the same smart contracts that will be standardized throughout maker and that'll provide a lot of benefits first it'll provide an easier user experience for the Rangers because they'll know exactly how to deal with these contracts but it will also provide a lot easier reporting for the entire maker Dow system so for all the risk teams all the different teams that are working on displaying information and dashboards doing analytics whatever it is there will be a common source of information for for these conduits so what I wanted to show you guys today was the General structure of the Ranger conduit how funds are flowing through it as well as how to build initial integration testing with the with the new allocation system um so uh I guess what I will say is I'll talk about the flow of funds since I can talk about that at a bit of a higher level um so how the flow of funds will work at a high level within the new allocation system is that each allocator will be able to pull funds from the maker system and then allocate it to to different conduits so what a conduit's purpose is is to be able to take in deposits and hold custody of funds and track positions across multiple allocators so multiple allocators will be able to Mint die from maker and allocate funds into these conduits the funds will sit in the conduit until an arranger is able to deploy that Capital into real world assets or any sort of yield generating strategy so those arrangers who are permissioned actors can come into these contracts and take the funds out and deploy them into treasuries or whatever it is um and over time as the allocators find a new strategy to allocate diet to generate more preferable yields or the maker course system wants to reduce the total supply of dye or whatever it might be the um the the allocators can request funds from the arrangers through the contracts so instead of this being an on chain or an off chain procedure the the allocators can come in request the funds there will be an on-chain event as well as you know storage that gets persisted on chain that um you know persists the state of this fund request and also orders all these fun requests that all the different allocators have made and so the arranger can come into this single conduit and now see the overall state of the system they can see how much funds they're able to deploy from multiple actors as well as all of the different fund requests that are outstanding that they need to fulfill on behalf of each of these actors so they can come to a single source and just handle all of their real world real world asset Integrations with with maker which is great so once they return the funds um then they will again be sent in custody in the contract except they'll be on uh they'll be tracked in another way um called like withdrawal funds so all the allocators can come in and see that okay now we have some cash available sure let's try that um they'll have some cash available so they can actually withdraw the funds out of the instrument and deploy to another conduit and so this is like you know the first example of a conduit that will be put into production but the idea behind this architecture is to allow for the community to come up with new ideas creative ideas of how to deploy Capital into real world assets D5 protocols lending whatever it is uh any safe way to generate yield and expand the supply of dye and get it further out into the defy ecosystem the maker Community will happily explore just as long as it is definitely maintaining you know conservative positioning and and safety for the core maker system see if this works five minutes okay okay I honestly wonder if it's even worth going into the code a minute does anyone have questions at this point no okay oh sorry yeah so this is currently in development uh so yeah we're currently working on developing this right now soon TM um do you mean like here oh definitely related to conduits I'm very biased obviously but um I think that I I've been involved with the maker ecosystem since 2020 and as a hacker I think this is genuinely the most exciting thing that's happened in a very long time um the maker system is very you know conservative and very thoughtful in their development and they will always be but what's really cool about this is it allows for external developers to propose experimental uh strategies for deploying diet and anyone could come in and have access to this massive um pool of capital that's the the maker core system and if their strategy is proved out and it's scalable and it's safe and it generates good yield they could see their strategy be managing very large amounts of funds so if I was a hacker I would be 100 working on conduits this weekend that's right so um after the talk uh tadeo will provide you guys with resources links to repos you everyone in this room is welcome to Fork my repo that I'm currently working on it's open source and just poke around and see how it works and uh and modify it there's full integration testing with the existing system and everything so that's a great place to start um there is a standardized interface that you'll see me Import in my repo and as long as you adhere to the core interface which I'm inheriting I'm inheriting a core interface um then you're you know on track to be considered for a conduit so exactly that's right so another example of a conduit is a conduit that would deploy die into Spark so yeah in a allocator would be able to just take die from the core system and allocate it into really any lending protocol can be obvious compound spark whatever it is the first one that we're building is for spark anyone else we'll have everything in the the dashboard it's Global but again um I encourage you to ask questions because we'll probably missed a thing or 20. um so yeah thanks a lot and yeah if you guys have any technical questions about conduit implementations just find me and I'm happy to help out or Sam [Applause] foreign foreign old safe oh okay okay we're live yeah thank you all for coming to my talk it's about building the safe course or building with a safe course Decay my name is Manu I'm from Save wallet and I'm working in front of that safe wallet stop working so let's talk about safe I guess most of you know us already the project was formerly known as gnosis safe and it's a multi-sig wallet but it's also more than just a multi-stick wallet we also want to move The Narrative of account abstraction forward so we built a lot of Tools around our account abstraction and save for us was account abstraction from day one because a con-up section mostly means that use Smart contracts as accounts and that's what safe basically is but we also have an ecosystem we have multiple interfaces building on us and yeah I will go into more detail when we talk about the packages and what we talk about mainly in this talk is about the safe core SDK that's a set of it's a typescript library it's a set of kits which help you to integrate with the safe core contracts itself so deploying saves Etc I will hear more later and um yeah so save was recently split into two teams the first team is save core and the second team is save wallet so what are the difference between these teams it's quite self-explanatory safe wallet basically builds and maintains the safe interfaces that means it's the the save web interface and also the save mobile wallets on Android and iOS and the in the services which which these interfaces require and yeah I work on on this team and for the for the front end so if you have questions about that come to the booth the Safeguard team has multiple Fields where it's active um basically three you can or you can split it into three Fields it's first the safe core protocol protocol so that's like the set of smart contracts around safe so the smart contractors are deployed on all networks um which are the the car also of of safe um we will also hear a bit about that um and the Safeco API which are the services are unsafe so it's a service which helps you load safe data so it runs an indexer for instance and um yeah like multiple wallets user to load data about saves or to submit transactions because it's also like a strength of save that you can sign transactions off chain and then submit them once everybody signed or enough people signed a transaction and then it's the safe account abstraction SDK we will talk a lot about this in this talk so let's go forward with the safe core protocol I will only touch it very slightly in this talk because it's a quite new topic it's Alpha so it's only deployed on girly because I shouldn't use it in prod yet basically I present it here because we have like half of the bounties revolve around the building with safe core protocol so I will quickly explain the the architecture which you see in this diagram so the idea is that you can integrate with multiple accounts like one option is of course the safe smart account but it's also possible or we want also and we hope that other wallets or other smart account wallets will also use Save and build on top of the new save core protocol and the DS at the Safeco protocol has multiple registries this could be maintained by a Dao or by groups and the ideas that this Registries contain like trusted or audited Integrations with safe and the Integrations can be plugins hooks or function handlers and signature verifiers it's all things which already existed in safe like plugins is similar to what modules are right now hooks are similar to transaction guards a bit like a plug-in basically you can extend the smart contract or the smart contract wallet by any functionalities by providing new functions which then will be available for the safe with hooks you can dive into the transaction life cycle so you could have pre-signed checks or post execution checks I mean pre-execution and post execution checks and more and the signature verifier and functional Handler are basically what's right now called the compatibility fallback Handler it for instance offers 1271 signatures so you could extend the signature checks by by a new algorithms new like for instance using pass keys or something yeah this is this is the safe core protocol I will yeah if you want to find more information we updated our docs today so if you check the docs yesterday check them again today it's a whole new page and there's also a lot about the new safe core protocol and there's also a demo on this GitHub page I will very very quickly only show it so let's the screen share works it works so basically the idea of the demo is and it only works on girly because it's only deployed there um there's a there's a GitHub page deployed and this GitHub page is a safe app so you can add it as a custom Safe app on girly to any save then you have the save core protocol demo app you open it and you see this page and you can look at the available plugins you know modules are now called plugins on this protocol and it loads some some plugins which are registered on the deployed register and you could enable them and some of them also have a custom UI where you get with this Arrow that's all I want to show if you want to check it out check the repos or if you have more questions about it please come to our booth and we'll just quickly demoing it because half our bounties will be about this so you should have seen it once at least it's quite new let's go back to the presentation okay that's all about Safeco protocol come to our booth if you have more questions please let's talk about the account abstraction SDK like it's a typescript library as I mentioned before and it contains of several kits like several kids around um account abstraction or interacting with your safe um the first is the alt kit it basically gives you um Advanced authentication mechanisms for instance using your social media account to log in um or APC for instance so right now yeah we will see later which products are integrated with it so far then you have the protocol kit it's it's there to integrate and to interact with saves so you can deploy saves you can create transactions you can sign transactions everything around the safe protocol is in this kit yeah here for an example you could craft a batch transaction which deploys the safe and auto sensor transaction in the same transaction then we have the on-ramp kit it's quite dribble like unramping means you convert your crypto yeah you buy crypto with Fiat money and you find your saves basically with it um the relay kit also quite self-explanatory like you can execute a transaction without paying for the gas yourself so you could put for instance pay directly from your safe or you could pay using ESC training tokens even instead of using the native tokens um yeah and currently these implementations exist for these kids like the way it's structured in the sdks there's always kits and then there's packs which kind of are implementations of the interface so where for authentication we have like web3 out right now for um like for protocol it makes no sense because it's the same protocol for unramped we have like stripe which only works in in the states right now but for people in Europe we have monarium launched quite recently um so check it out and for relaying we are integrated with gelato yeah um we're also planning to build markets or there's like yeah there's more ideas and more kids coming soon for instance we are looking into recovery so offering a recovery kit and different ways of recovery inside this kit sort of different packs again uh or like for better multi-chain supporter kit and others are also possible like but these are like the ideas currently revolving around yeah if you want to check out the the kits they're all in the same repo they're all in safe core SDK here's a link to it and a list of the packages here again it's the same list of packages a bit easier to read the only one I didn't cover is the safe course Decay types but it's quite explanatory too it's like like everything is built with typescript so these contain the types which are used throughout these kits um yeah okay I will also quickly demo these kits in the account abstraction SDK like there's uh how to prepare the there's a small react app it's also open source you can also check it out to see also how these kits exactly work uh at least and if you start it it should show this page you can select the chain I will use Mumbai and you can start the demo and it contains three kits the alt kit on ramp kit and relay kit um and here with the outfit as mentioned you can connect with for instance your Google account so let's try it out I hope the Wi-Fi is strong enough uh yeah so here you see this model this is from web3 out so you could also connect with your your as usual but you could also use funds on your Google or Facebook or whatever account um let's do it quickly sign in with Google um if you would use it for the first time if you want to check it out it will not deploy it safe yet it will use the predicted safe address and only if you do the first transaction from that safe it will deploy that save first and then do the first transaction so I already tried it out so the save is already deployed it will take a bit to load the data so here we see the owner wallet which was created and the address of it and the save account which was created and it's already funded because I did this demo already once um down like underneath you can also always see code Snippets which explain how it works most uh yeah here for instance we import the out kit as mentioned we have some options which are like coming from the web 3 out so it's like contains which chains do we want to support or which login methods or what how should this model look like do you want a dark theme or not um and important the client ID that's something from web3 also you need to become a client on a customer at web3 else to use it and then in the end you can create this login adapter in this web3 model pack ing in all these options and then this model pack will um is wrapped in the safe auth kit which is again that kind of the interface for everything and it offers like a sign in sign out and other methods let's go to the next this one I will not show because it's right here we didn't integrate the monarium packet so stripe only works in in the United States and we're in Europe so it won't work but I can shortly click on it and you can see that after some loading this widget opens and you could now onboard if you were in the states um but yeah again the code it mostly contains stuff about stripe like you have a stripe public key and other stripe data you put that into the stripe pack then yeah and then again you initialize the kit so it's a similar pattern you always have the packs which are implementations for the kit and then again this kit offers functions like open and it opens the model and subscriptions to some events which will happen from stripe um next in this one we can also try and show it's it's a relay kit it's using gelato to relay a transaction um and it will pay from the safe itself so here we will send 0.01 Matic to the safe itself but you can see that we don't we won't need to sign anything because the signer is using web 3 out and we already logged in with our Google account so we don't need to won't have a metamask um pop-up and have to sign but instead it will just relay the trade the transaction relay it and show if when it's executed it could take a bit um yeah try it out if you want now it's pending and at some point it will be executed I will go forward because I don't want to wait for this transaction um yeah we are also almost done so this is like all about the um kit and a bit about the protocol if you have questions please come to our booth and probably also have a bit of time for questions after this um let's talk about the bounties because we're all in hackathon um so safe has like ten thousand dollars in bounties and these boundaries are split as I already mentioned between these two projects so if you want to build on Save and you want to participate in the hackathon and and be eligible for a bounty you have to either use the or build on top of the new safe core protocol which means if you plan to build a module then build a plugin if you plan to build a transaction guard then probably look into hooks you know like use the new architecture and the new contracts again they are on our docs and the implementation and the examples too um yeah so for safe core protocol we have like for the first place two thousand five hundred dollars for the second a thousand five hundred dollars on for the third one thousand dollars and the same tiers we also have if you build on top of the safe con abstraction SDK which we presented so this typescript Library um yeah so if you want to be eligible use one of each or both um yeah here are some useful links like I already mentioned the docs you can also find everything if you just go to safe.global but we have other docs we have our Discord um a forum and our Twitter also important you can also reach us on the Discord of uh is global like there's a part or save channel so if you have questions right there or better control booth and we also have a small guide which has some learning materials and some past winners of hackathons and some past Workshop videos and other resources if you want to use that then scan this QR code it's a notion page contain some useful information too for participating in the same effect of them I will this is the presentation so thank you very much for the um for your attention and I think if there's some questions I'm not sure how much time we used but probably there's a bit of time for a few questions [Applause] are there any questions if not then if if you have some in the future please come to our booth or post in the Discord cool like which chains to you uh eligible or yeah I can go back to the Bounty slide um if you want to build and cut off top of the save core protocol that's only deployed on girly for security reasons because it's not it's still very Alpha so we don't want to deploy it on mainnet because it people could assume that it's fully audited and and ready to use in prod that's why it's only in Girly so that will only be girly but if you want to build on top of the con abstraction SDK save is to already deployed on a lot of chains um so you can just use multiple chains then you're not really restricted yes uh can we transfer any token with a construction and with the smart wallet if you can transfer tokens or yes yeah erc20 tokens oh yeah like um the the demo I showed there for instance we relayed a transaction which sent funds so you can relay any transactions for instance using gelato or other relay providers um or you could pay directly from your safe to transfer tokens yeah I mean in general safe supports all kinds of tokens for the safe core protocol um is there is that limited to um specific networks or can we use it also on a test net what sort of what functionality also is is available and isn't available if we deploy it on our own custom networks yeah um for safe core protocol it's currently only deployed on girly so only on girly test net um because it's still in Alpha stage so if you want to build on top it will be on girly it's not deployed on other test networks yet I mean if you really want to use it on Mumbai I guess you could try to deploy it yourself or something and then build on top of it it shouldn't be a blocker but if you want to use the already deployed contracts then they aren't girly and there's also already like the demo I showed here this demo app like there's a repo where you can see a small UI for one of these plugins and you can see a relayer plugin using gelato so you could also use that at the starting point and then build your own plugin on top of that or something so um the second example with UI and contract just a quick follow-up are there um instructions or guides how to deploy safe core on your own network I'm not entirely sure but the the contracts are all open source um like you can find they also linked in our docs so there you can find the solidity code so I guess in theory you could deploy them on a network then yourself okay thank you does the safe core include safe modules does a safe core use safe modules as well I mean if we build a safe model would be eligible for a safe core like yeah um like I would suggest using the building on top of the plugins because they're similar to modules previously but in the new Safeco protocol but in general you I think you can also send a module transaction from the Safeguard protocol kit okay good but you can also come to the Boost if you have um safe plugins are not in the prices right all right sorry I mean bounties safe plugins they are not in the boundaries I mean plugins are part of this new safe core protocol um let me try if I find the slide very quickly uh here so I'm not exactly sure what you mean with plugins but here plugins are very similar to modules so you could extend the save smart contract by new functionalities by building a plugin for instance like the example which is on our repos in our demo app is a relay plugin so it will pay the gelato relayer for a transaction and then relay the transaction using a plugin so it will be part of safe protocol yeah yeah and what about guess uh uh sponsoring gas transactions so you sponsor transactions on any chains or only on gnosis or I mean in our UI right now in the wallet right now yeah yeah guest fees there was it was in presentation like guest piece in erc20 tokens like oh yeah you could do that with the um relay um one second so it's like there's a relay kit and with that you could for instance pay from your safe or gelato like we use gelato for the Relay pack and gelato supports that you for instance pay with usdc um for transactional instead of using the native token so like for the Relay Apex it's currently gelato um and you can pay from your safe or you can pay using one balance it's a gelato product so it's the same like pay Master yeah in fact it's similar it's like a solution which was pre-437 one more one more question I'm sorry uh where can I link to the demo or repo or or the the demo website like it's all on our docs so if you go to safe.global and then click on the docs like there the demo ripples should be linked like especially for safe core protocol there's a demo Ripple linked and also for the safer con abstraction you find the demo if not then come to our booth and I can give you the link if you have trouble finding it please spin pins the links in the Discord if you can yeah okay yeah I think we already pasted some things on the Discord like there's a partner Dash safe Channel like we will reachable there now we are also reachable at our booth the whole days here thank you very much [Applause] [Music] okay distance or you don't have to do anything and I do for me um uh I can start yeah cool um hey everyone so I'm going I'm gonna be talking about Zeta chain uh what is Zeta chain it's essentially um interoperability solution that lets developers build cross-chain depths or as we call them Omni chain dabs so Zeta chain offers a solution for developers to just write a contract once deploy it to Zeta chain and this contract essentially has powers to manage assets on all the connected chains so for example if a user has an asset on bitcoin they can send BTC to a specific address in this BTC becomes available to the contract on Zeta chain and your contract can perform logic and for example swap the token for another token and withdraw it back to a native chain so that's called omnichine contracts it's super easy to start building with uh with Zeta chain if the screen comes back alive I will even show you that but Zeta chain offers also an alternative way of building cross-stream devs and it's through cross chain messaging so cross chain messaging is instead of deploying a single contract Tuesday the chain you deploy contracts to a bunch of different chains and they're using Zeta chains API to send messages with arbitrary data between chains so both Solutions have advantages um the advantage the main advantage of omni chain contracts is that it reduces it drastically reduces the complexity of the system that you're building so you just have one contract to worry about only state is only in one place so that's very that's very convenient from an architecture point of view okay wait a bit for it's going to come back this looks fun looks very web free-like very hacky actually it doesn't change if I change no it does that's like reading docs on hard mode foreign can I continue can I get a green light to go ahead nope it might happen again yes sure so it depends um so the question was should you deploy it to single chain or to all the chains or Zeta chain deploys the contract uh so it depends on which path you're taking for Omni chain contract you would deploy it once to Zeta chain and that's it you don't need to do anything to any other chains it's just all works out of the box if you're using cross chain messaging you have to deploy it to all the chains you want to connect so right now four chains Zeta chain is in the test net phase four chains are connected more chains of course will follow but if you're using cross chain messaging you're deploying a contract on all four chains and you're also setting an interactor so you're basically telling um to each contract you're telling the counterparty contract address so that it knows which contract to talk to so it's a bit more involved from the architecture point of view but it's kind of a very well known solution basically right so if you if you have an existing application that needs to be augmented to uh become cross-chain uh you can use cross chain messaging for like specific areas if you were to build something from scratch I would recommend looking into Omni chain contract first because it's just so much some clearance the the killer feature of Zeta chain if anyone has questions let's just jump to questions I guess first which is weird before yeah go ahead um so again it's like if omnichane you just deploy once crochet messaging you deploy it to all the chains for cross-chain messaging you will be able to send messages between the chains you deploy your messaging contract to because so for example data chain at some point might support like 20 50 blockchains you might be interested in only in three of them or like 10 of them so with cross stream messaging you have to explicitly deploy it to the contracts you're interested in so does that answer the question uh right now in the test net phase only four chains so that would be Bitcoin ethereum polygon BSC of course more chains will follow and Zeta chain is built on Cosmos Tech so possibly it will be IBC compatible if you're familiar with Cosmos then this will connect it to even more chains and we are planning on iterating more evm blockchains and non-evm chains as well one of the advantages so besides Omni chain contracts the advantages of Zeta chain include Bitcoin interoperability so not many solutions especially decentralized Solutions support Bitcoin out of the box so from from Bitcoin you can trigger smart contracts on Zelda chain which is pretty cool and there's very little overhead and there's nothing you need to do on bitcoin you just you just ask users to send tokens to a specific address and that triggers a contract call on Zeta chain and the other Advantage is that it's um there's no wrapped assets so there are rep assets on Zeta chain when the process happens right so when you deploy when you send tokens uh to a TSS address on a chain Z or C20 wrapped version of the original asset gets minted but only gets minted on Zeta chain for the purposes of swapping and working with it so it's like representations of the original asset on Zeta chain Okay cool so let's continue with with the slides um so I talked about cross-chain messaging Omni chain contracts now I want to show how well basically easy it is so if you go to zation.com docs in the developer section you will see two sections Omni chain contracts and custom messaging so here is a complete example of an omni chain contract as you can see it's super simple like the only thing you need is z contract here a couple of imports and you need to implement on Cross chain call function this function gets called whenever tokens are sent to a specific address on any of the connected chains so for example if someone sends tokens to a TSS to a specific address on ethereum they um there are two paths these tokens might be just deposited into your contract on Zeta chain or if a user sends tokens and supplies arguments in the data field of the transaction these arguments get passed to your contract as the message then you can decode the message Implement your logic for example this contract is super simple it just would withdraws the tokens to the same chain doesn't do much but it it shows you an example of how to trigger an omni chain contract and how to withdraw but you can of course swap to a different token and withdraw to a different chain or you can mint mint tokens on Zeta chain it's really up to your contract but the the logic is super simple token transfer on a connected chain triggers this uh this function call and that's it and then you can use your C20 which is an extension of ERC to withdraw the tokens back right now Omni chain contracts support native gas tokens as well as erc20 of course more asset types will be added later year C20 need to be whitelisted by the chain and this is not a centralized solution not a centralized decision uh the the blockchain is going to be very decentralized and people are gonna the community is is going to be voting on important decisions like which your C20 we want to whitelist if it's whitelisted a pool will be created internally on Zeta chain so that tokens can be swapped and so forth so as you can see there's not much to it um your contract just needs to implement one function that's that's it um with cross-stream messaging it's also pretty straightforward so here you have a few things in your temple on first a function that will use Zeta chains connector API to send data so you just provide some helpful information like where do you want to send the message to the destination chain you need to provide things like gas and but most importantly you need to provide the message here is just a text hello world message but you can encode any kind of data you want and it will be processed once the message once the function gets cold this will essentially trigger a process where an event is emitted on on the source chain Zeta chains validators they run nodes of all the connected chains and when they see a transaction happening they will vote on Zeta chain whether they've observed this transaction or not if enough votes are cast the transaction will come go through and will be processed by Zeta chain and on the recipient and you just Implement on Zeta message so if the transaction comes through you just handle it for example if it's a nft project you might want to lock the nft in the send message function right here you before connector send you will lock the nft you will mint an nft on Zada message on the receiving chain and maybe send an acknowledgment back to burn the original nft if you if if you got a new nft minted right that that could be but again the architecture is up to you this is just a kind of low level primitive for you to be able to transfer Val to transfer value and data between all the connected chains you don't need to worry about Zeta chain here at all because data chain works as intermediary here so we have a lot of tutorials uh for for everything you can you can see a very simple cross chain Swap and just what is like 30 lines of code um withdraw tutorial you can also um check out the Bitcoin tutorial as well not many projects support Bitcoin so that's pretty pretty interesting um what I'm going to show the last thing I'm going to show is basically how you would start so you would go to github.com satachain we have a bunch of reposts here but I recommend just cloning the template so github.com Zeta chain slash template when you clone the template you have something like this and it it doesn't have much but it Imports a bunch of helpful utilities so if you run in the x heart hat you will get a bunch of helpful tools so for example if you need to connect create an account you just hard hat accounts and it will create an account for you you can even save it you can um the X hard head balances this is helpful because we're dealing with a bunch of chains so you need to know what kind of tokens you have so on the all the connected chains you can see native Zeta and zero C20 equivalents uh what is super helpful I think is how you get started building so you have a command hard hats Omni chain and what this does is it accepts a name so let's call this contract withdrawal and a bunch of um params like recipients data whatever from so what this will do is it will create a contract um that you just need to fill in the blanks right so it's it's all it's already there for you and you you already have a deploy task so you don't need to worry about that and also a task to interact with it so you just executed one command to create a new contract then you can run hard hat pile now you can just run deploy Network since this is a nominal machine contract you always deploy it to Zeta test net and of course it doesn't do anything right you saw that there is a blank in the in the in the contract but uh um and boom you you got the contract deployed and you can interact with it as well so like all the boilerplate code is here and um there are more tasks uh one more useful thing is if you're building with costume messaging you also have um a task for this so npx hard hat messaging my contract fubar and this will create a costume messaging contract instead and it has Foo and bar here so it already you can already compile it and deploy it to different chains let's do that it's slightly different because with cross stream messaging you deploy it to several chains so let's say early testnet and by testnet pilot first thank you [Music] and what this will do is it will deploy the contract to all the chains you specified but also set interactors for all the contracts so it will tell um the contract on Mumbai the address of the contract on Gurley so it kind of wires everything up together so you don't need to worry about that you just read the docs understand how it works and implement the logic of your contract and something that you want to send through this connector send Zeta chains API so I don't have much time for anything else I will be available as is the rest of the team downstairs at the booth so please do check out Zeta chain if you have questions more than happy to dig into any technical details if you're going to be building on we have a price for the hackathon more on the website but please do make sure that you're using data chains API and actually build something with cross stream messaging or omnichine contracts that's very important and yeah good luck on the hackathon thank you foreign do we have time for questions okay so I will be there if you have any questions thank you yeah yeah um thank you yeah yeah should I start can you is the mic work yep Mike works okay so hello guys my name is Simeon uh I'm leading Integrations with neon evm so today we'll speak about what the heck is new on evm and what are we doing and we're gonna be conducting a really short demo so in a nutshell neon VM is evm inside Solana it's not like layer 2 is not like a side chain but because Solana provides a very scalable architecture we have the opportunity to build uh the ECM the entire evm execution layer inside a Solana smart contract and how this is possible it's possible because um in Solana in one account you can store up to 10 megabytes of executable data and actually the evm that's pretty interesting is around 2 megabytes so we built a DVM inside Solana and we provide an ethereum-like interface for users and developer to to use it and uh basically from developer perspective and user perspective you can use the scalability and low low transaction fees for uh from Solana infrastructure and at the same time you don't really need to change your context and you know from user perspective you know change wallet or if you're a developer I know it's really hard to change your Tech stack or to learn new blockchain mechanics so we abstracted the way all the Solana complexity and so what we are going to do today I'm going to deploy one contract both on sepolia and neon evm to show you what uh what the difference is and what chord changes we need to do and also I'll show you one more thing and we're gonna see so uh the best place to get more info is the the developer documentation and here you can for example uh go to uh let's say neon faucet and get some testnet Neons you can get from chain list for example you can just write neon include test Nets and art neon devnet in your in your metamask I already have it and I already have new off but let's let's just try it out so uh so yeah we can request 100 news and they should be here shortly yeah yeah so let's uh yeah we we have an ethereum like uh blockchain Explorer so everything is evm native and you don't really need to know about how Solana works and how transactions set though on Solano there so let's look at the project I have prepared basically it's a very simple hard hat project if we go and check you can see we have just two two or three dependencies like we have a hardware toolbox hard head and heart header scan uh to verify our contract um and also we have open sapling and Dot ends to store our environment variables in different file that will not be committed in our repository so let's see the first contract that we are going to deploy so we have a simple erc20 token that we have Supply limit uh burnt amount storage variable and just for the sake of the demo I just added zero decimal so we don't have to add all those extra decimals for example if you want to Mint from from the Explorer so we we don't need to count them uh yeah so let's try and deploy first dish this contract in sepolia and verify to see to to verify that it works on uh just a normal evm uh yep okay before running yeah I'm gonna just run it and show to the hardcat configuration so as you can see we have configure two networks one of them is the polia and the other is um Neon devnet uh basically as you can see you you don't need to do any extra configuration uh for for this and we also have uh another configuration this is for uh the verification of the smart contract we have the API key for sepolia and also for neon devnet as of now you can just put any key so you'll be able to uh to verify the contract um trench we are waiting so much for for this contract to get deployed on sepolia it usually takes four seconds okay I just try again foreign it should be operational it always happens like this when you need your contract to be deployed it doesn't yeah it's not uh okay let's try to yeah I mean uh yeah we can we can just try to uh to deploy it to uh Neon devnet yeah so uh uh which one of you has deployed contract on Solana only one okay uh only one person okay so that's that which one of you has deployed on evm chain okay we have more so that's for you yeah so you don't really need I I've never deployed contracts on Solana for the simple reason that I'm just you know too lazy and just to learn any other and to change my tech stack to change uh the code learn new tools learn new blockchain mechanics so I really find it that I really find it very fascinating what neon achieved so basically I don't know why for sepolia it doesn't really work but for for let's let's try one more time I just uh maybe we can check some other maybe the the public RPC let's just get another um I think that's right I'll just get another RPC note maybe this one is down so we already deployed our contract on neon devnet I just want to make sure that uh you know antipolia everything's right but if not we are gonna just proceed to it with neon devnet it's just a simple contract so as you can see we just imported from open sampling and it should be no no changes made actually okay spoiler is not that important so the good thing is that we managed to deploy on Neon and let's just verify this contract oops yeah just a second let's try to deploy it again and it says that it cannot find the built info which is Trench let's do it like this we're gonna hack it sooner or later now we should have the correct build info foreign okay yeah uh I forgot to clean the cache of heart yet it always happens if if there is a problem the problem is in your cash always uh yeah so we verified the contract successfully and let's just go in new scan and see yeah we can see we've deployed the contract we have the contract here um maybe we can try and add it in our metamask um yeah let's import this token here it is okay and let's maybe try to Mint yeah we need to connect and let's meet 100 tokens okay let's see did we no yeah it will we need to provide a little bit more because I found a bug yesterday Neo scan doesn't yeah we need to have this value as gas because otherwise the transaction just requires a bit more gas but uh actually a pretty uh interesting thing is that neon doesn't use um gas measurement from ethereum we use gas gas measurement based on Solana and it's a bit different but we support old RPC calls so most of the libraries they estimate use estimate gas and then put this this as a gas limit so we are fully compatible with this and obviously Neons can don't use estimate gas maybe hard coded some some value so so yeah let's just check yeah we have we coded two times so we have um we have 200 tokens and yeah basically as you can see like it works uh one more interesting thing is that maybe if we open the transaction you can see that there is like a five maybe more nine Solana transactions and if we open even one of them you can see those are all the underlying transactions that executed and they that were wrapped in one ethereum transaction basically why is that is because in order to scale Solana it has a completely different infrastructure from ethereum and if it's stateless uh ethereum is stateful it uses accounts as like in a nutshell Solana is like a big file system so it has two different kinds of accounts it has a data account and executable account so uh and neon EDM basically creates a executable account for smart contracts and smart contract state is saved in data accounts in like different files and read from them so sometimes we need to create one or two transactions when we are using for example as a store we need to create a new data account to in order to execute this opcode and this is one of the reasons we have more than one transactions and there are more more limitations that we can discuss for example um one Solana transaction is actually has limited the 256 kilobytes of memory per transaction and all the evm Primitives like memory code stack is saved in this transaction memory all the metadata that is related to to the transaction and and evm and sometimes we need uh we need to make two or three different iterations in order to complete the the ethereum transaction Okay so the other contract that we are going to deploy is as a bit more interesting so it's called ERC 24 SPL how many of you know what SPL token is no one okay okay one person okay that's good so I'll explain to you so uh SPO token is the ERC let's say the ERC equivalent uh in Solana so in evm networks we have each erc20 as a separate contract right but in Solana we have a token program that is like a centralized smart contract centralized program for all of of the tokens it's like a registry for tokens so in order to create to transfer to Min tokens you need to call this um centralized program that is a native on Solana and perform some token operations so what we are going to do here we have um we have the SPL token contract here as you can see we wrapped it in the SPL token interface this is the interface for for Solana we also have metaplex metaplex is where um the metadata for all the tokens or sites in Solana so we also need this to get the token name the token symbol and so on so we also need this this contract in Solana as you can see we are using the some some precompass and um we wrapped the erc20 interface we wrapped it in uh to call the underlying either metaplex or SPL token and what we are going to do now is we are going to deploy an erc20 on neon evm that under the hood will basically create a Solana SPL token and we can transfer it back and forth so let's just see our script uh it's just a straightforward script we get the contract Factory for erc20 for splintable as you can see in this contract we have two tokens one is erc2 erc20 for SPL and the other is um yeah LC 24 mintable the only difference is that we have exposed mean functions here and the the deployment script is actually pretty straightforward we take the contract Factory deploy it and then we mint token so why we put nine decimals here is before because Solana don't store variables and uh in 256 bits but for 64 and basically we don't want to have a big a big decimal because otherwise we'll sacrifice to have a really low uh really low cap of how much tokens we can have so nine decimals is okay let's just try and deploy it um yeah sure okay now the most the most interesting part and again yeah okay so we deployed let's try to verify it oh yeah we need to provide arguments okay we don't have more time so let's just see the the transaction and I want to show you the interesting thing okay so you can see we have two transactions one is the contract created and the other one is the mean transaction uh so if we go to the contract create transaction you can see we have 25 Solana and this is actually the deployment transaction nothing that uh interesting but for for the other transaction you can see that here we transferred from zero address to our address 100 uh tokens right and if we go and see and check the Solana transaction you can see that on Solana again we have mint so it means that we have created a native Solana SPL token we deployed it and we can natively from neon devnet access soana liquidity and if we scroll down a bit we can see that for example here we have the token program basically that means those those tokens so yeah so that was pretty much it and do you have any questions regarding neon and yes yes so yes so uh Solana um because neon EDM is inside Solana contracts can interact natively with Solana contracts this was actually the demo I wanted to show you how we interact with SPL token program and basically that's a good thing because you can create composable modules for Solana but writing solidity code and don't change your Tech stack and that's that's pretty nice only maybe I can just tell you about one uh one problem that is not compatible but I think more uh most of the Roll-Ups and l2s have it you can you cannot use um lock timestamp and block number as a mapping index this is still not supported but it's not I mean I've never seen it protocols use block number and block timestamp as index and more probably as mapping value but not as key so I guess there's no more questions thank you very much guys [Applause] foreign thank you yes we have time foreign test test yeah here's the trick should I try it works break this up so there should be two browser windows here when you let's do it okay great nice meeting you all I'm fabri from xmdp and this is Nick and we're going to introduce you to the secure messaging Network for web free so you might have seen in the news that xmdp launched with coinbase wallet last week if you haven't tried it yet the only way to get access to the feature is by scanning one of these QR codes here uh but it's pretty cool you get wall-to-wall messaging inside coinbase wallet there's no signatures there's no web3 um you know UI really looks like a messaging app and so if you scan this QR code right now uh we can show you what it looks like on the other end right let me know something so this is xmdp.chat another app on the xmtp network if you scan that QR code in the last slide you can send us message and say hi and uh it'll show up right here any takers Maybe oh look at this so all works in real time and this is interoperable across all 350 apps in the xmtb network um you can also do it from Converse which is a great mobile app built here in Paris um you know we just focus on building an interoperable messaging standard none of these apps are ours other than this one you're looking at right now which is a reference implementation yeah so let's start with the problem right so we can think of Communications today as being broken this is how web2 Works independent platforms that don't communicate with each other they start the information we are not the owners of the information so we think this should be better there is also the thing that in each of these centralized servers you don't own your your identity right they own your identity we only rent it so web free is converging into this unique identity which is called the wallet and what the wallet means is that we own our assets and we also own our Communications and that's on the side of web 2 and Communications but we can also think about more practical challenges that today exist in web free that is that we cannot message there is no open Channel between Wireless Communications so if you're a developer and you're busy end up or a protocol you cannot communicate with your users if you're a Creator you cannot communicate with your audiences who purchase nfts um and again there is no way for users to make communicate with each other so for this xndp has proposed a solution that Nick is going to introduce you to you now sure so xmdp is an open protocol for web 3 messaging we already have 350 apps built on top of this protocol we have sdks for every popular language if you want to build an app this weekend we have the tooling to support you it is gasless very fast to set up totally free to use and so when anyone Builds an app on the xmdp network you can immediately reach any of the wallets that are already on the network which we have about a million wallets today let's look at some of the examples this is converse which is uh iMessage of xmtp it's really fast really clean and gets push notifications right to your phone uh just a great simple messaging interface this is orb which is the biggest mobile app for the lens ecosystem lens is partnered with xmtp if you've used lens you probably have an xmtp identity you might not even know you're using our protocol but we power the DMS all across the lens ecosystem and another 300 plus apps let's see what studio plays um across all different categories we have web3 gaming we have um you know nfts messaging their holders uh yeah decentralized marketplaces really a broad range of applications all running on one protocol all able to talk to each other so why don't we dig in and look at some of the code and see what it's like to build an app on xmtb we have a replit here so anyone with their laptop you can follow this short link and follow along just in the replit you make changes on your own or you can scan that QR code and that'll also send you to the replet give you guys another second uh to take down the link before I hop over all right so this single file really small app just to test the basic functionality of xmtp for the purposes of this demo we are not going to deal with wallet connections uh we're just going to spin up a random wallet so in your app you'd have to use something like wallet connect to get access to a wallet but here we are just going to use the very helpful create random create a random wallet when this app starts up now if you want to create an xmtv client you import the library client create pass in a wallet this be any ether sign or something compatible with that and an environment we're going to use the dev environment since this is a demo and um you know we don't want to send messages that people are going to see in their actual apps and first thing we can do is just check and see if a mess or if a user is on the network so to message someone on xmtp they have to have used some xmdp app at least once we have a handy function client can message that will tell you yes or no is this wallet address on the network so why don't we try running this oh perfect hit run and it'll build this app and do the can message check well maybe it's doing a few more things too let's see can message true so we were just looking at fabri's wallet which thankfully he is also using the network and working here maybe we could do a few more things here and send fabri a message so we're going to uncomment this function and this function and we're going to comment this one out so in xmtp everything runs over conversations which is an abstraction we use to make it easy to manage your chats to start a new conversation with a wallet address this is all the code you need new conversation wallet two which is fabri's address so we can create that conversation and then down here we just use this conversation and we send a GM let's see if this all runs too all right message sent sent to GM that is really all it takes if you wanted to get fancier we do support custom content types and so you can add codecs to your xmtp SDK for things like images or videos or file attachments we have uh some new content types like reactions and replies that you can play with um but the basics of xmtp are just text messages and that's the one thing that is universal across all the apps in our ecosystem now let's see if we can do this in real time I'm going to switch the environment to production so that people can actually send us a message and we are going to listen for messages on the network this is obviously useful when you're building a client-side app where you need to see things coming in in real time and so we have this very helpful stream all messages function and all it does is calls xmdp conversations stream all messages this is going to get the full list of conversations that this brand new wallet has and it's going to get all the messages coming in in real time for each of those conversations and so it's just going to print them to the console here I'm also taking the time to answer your DMs so it's me all right I'm gonna run this and it's gonna print out a QR code for this random wallet let's see if this is actually legible all right let's see if you scan this you should be able to send a message that'll actually get printed out in the terminal here in real time I'm going to try it myself oh maybe the QR code's a little mangled because of the display set up let's try this one more time with it actually yeah I think just let's try and print it again with oh I'm sorry you're gonna have to get a new QR code here oh hey all right we got our first GM so that's all it takes to have a real-time listener for xmtv messages uh set up the terminal this is you know maybe 50 lines of code and a lot of that's pretty lightweight awesome laughs someone's using this for some free advertising space I I appreciate the hustle I respect that oh did someone try and send send us money that second last one I think that's a payment oh that money's gone this is an effect this is a federal wall that just went basically to the burn address foreign I appreciate it all right uh the Wi-Fi in here is pretty poor takes some time yeah there's also one other function here if you just want to stream messages from one conversation that's equally easy this just spits out async iterator so you can just do a weight conversation stream messages and uh that'll give you just the messages for a single conversation which can be helpful if you're building a chat app so before we move on any questions about this code anything that seems a little too mysterious happy to field those in real time all right here including newly created conversation so there's kind of two streaming functions in xmpv to stream the conversations which will just let you know hey someone started a new conversation but not give you the messages and stream messages from the conversation and that API just ties the two of them together to make it really simple to build an app that has um you know all the messages from all the conversations in one yeah so um this is the basic concepts around xmtp so it's basically creating conversation and sending messages and we are now working on group chats read receipts reactions to messages there is also a way to send media attachments like image and video so that's on the SDK level and on the protocol level Nick you want to tell us yeah so xmdp has a roadmap that we've shared publicly in our GitHub discussions around decentralization uh you know there's a bunch of milestones we have to hit to get this point where anyone can run their own nodes and then anyone can get paid to run their own nodes right now xmdp is operating the nodes in the xmdp network we'd really like to get out of that business um and so we are working hard on decentralizing our Network so that we can be a small minority of all the node operators we're also working on the next version of the xmdp encryption protocol uh that's something that a lot of developers have been asking for better ways of revoking keys of having device specific identities so that uh if an app gets compromised if there's a bad actor on the xmtp network that maybe is phishing people that we can really limit the damage from that um and you know that's going to be rolling out in the next few months which should come in the form of Disappearing messages yeah as far as our developer tools we have an SDK for basically every language not only on web but on mobile this was a demo of the JavaScript SDK but we also have for example react native we have Swift and Android so check out our Docs you will find more information about the whole experience of sending your first message and you will find a lot of tutorials we are trying to push into multiple use cases for example you see coinbase using a finance use case about sending money through messaging we also we think that there is room for a lot more so I invite you to check out the docs and see how it's used in marketing how it's used in Commerce the centralized social as we see with lens Automation and support like creating chatbots and if you are going to build on a hackadon I recommend you to check out our playground where is the beta beta versions of group chat replies reactions and read receives and there is also the way to do broadcasting so if you want to send like a message one to many there is a way to do that so that was our our talk I'm fabri I'm Nick thank you all yeah happy to answer any questions you guys have thank you um could you uh describe like property uh the overall architecture of xmtp should let that slide in for me for me it was yeah for the introduction it could be really good to have it yeah absolutely so the xmtp nodes are built on top of waku which means they use lib P2P under the hood to create this mesh you connect to one node through our API and publish it and then it will get gossip to all the other nodes in the network which is how our subscriptions can work in real time even if two users are talking to different nodes we have a pretty big storage layer underneath it so we can store messages on the xmdp network forever um I think that's something in future versions we might not need but today a message can just get persisted onto our Network in perpetuity uh which makes it really easy to sign in across different applications okay and another question um would would that scale like like uh telegram or what what's happened would why are we still using telegram for example and what would be the the next application you see that could replace this kind of a pre uh messaging applications yeah why are we still using telegram at least the people in this room uh you know when there's good web3 native Alternatives I I don't know I basically stopped using Telegram and just got people to message me on xfdp and it works great and it's you know we're not some shady company flying around the world in between Russia and Dubai uh we're right here ahead are pretty transparent about how we handle end-to-end encryption uh which is more than I could say about telegram um yeah I think building a identity layer where people are really thinking about themselves through their web 3 identities first that's going to be the blocker a telegram is great because it uses the phone number as an identity layer and phone number is something that people widely understand and getting you know my mom to use her ens as her primary identity I think that's going to be uh uphill battle that we as an industry have to solve to make this easy cheap and just painless experience and then once that happens XMP is ready to take on the messaging traffic uh yeah we're pretty comfortable with our ability to scale to deal with large volumes of messages awesome what is the name of the app on the App Store uh so there's a few that are in the App Store if you're into the lens Community you can use orb Converse is the iMessage of xmtp and uh coinbase wallet if you've scanned one of those QR codes on the screen you have access to this new feature of wall to wallet messaging inside coinbase wall directly sure does the encryption and decryption work for group Chuck I guess in one-on-one conversation like like we group chats kind of like do it to be like talking video so that like only with this yeah so in the first version of group chat that we've just released this Alpha for the way that all permissions in the group chat work is someone in the group has a key that is secret for the group and they can share it to anyone that they would like and they send an announcement that says hey I shared this with Bob I said share this with Joe and you just passed that key around and so it'll be up to the application layer to add additional checks on top of do you have the key and so you know if you have an app that is only for holders of some particular nft you would in addition to checking can they send a message on xmtp you'd also check do they hold this nft and if not you make their messages disappear at the application layer exactly yeah we've had a number of people do this with one-to-one chat uh but because group chat's so new if you were working on a project like that I think you'd be the first thing any other questions oh sure xmdb has never censored mentioned a message on the network part of our privacy goals are that we should not have enough information to be able to censor a message uh every version of the SDK removes more and more metadata to make it harder and harder for us to censor a message so why why would we censor something when we don't even know who is from who it's to what it's about uh it would just be very difficult for us to censor even if we were compelled by law right now blocking is done at the application layer it's something we're thinking a lot about and uh you know there's some public discussions around consent on the network and how we might do that at a protocol level way but today applications have blocking built in and unfortunately that doesn't sync between different apps on the network but if you use coinbase wallet for example they have a nice block feature you block someone and it won't show up at least inside coinbase wallet for you foreign for adding the image attachments what's the way to do that is there a plug-in or is it copy pasting the code from XMP chat or what's the best way to do like the image attachments that is in there yeah so image attachments the images are stored off Network we have um I think now a guide is that right around images yeah Eastern our dogs so you you can copy paste if you like but we have also this public content types repo so you can just import the content type and that'll give you the boilerplate code for rendering these images or at least uh downloading them and then uh images can be stored wherever you like and so we include encryption key and a hash of the image in the xmdp message that means you could store it in ipfs which you know we recommend but if you want to store it on your own servers or on S3 that would also be totally fine because the images are encrypted and there is a hash so if you know someone monkeyed with the image after it was initially sent and replaced it with something else it would fail to decrypt and so it gives you a lot of flexibility to do images however ever you like for your application yeah we have five more minutes yes no okay yeah no worries thank you okay thank you everyone what guys uh has any anybody dropped a phone anybody left the phone [Music] hey how's it going nice to meet you Oh no you're getting oh are you are you with uh Global or yeah nice awesome okay it's 25 okay for the change over yeah yeah okay yeah it's perfect it's perfect I think mine's that it's 20 minutes so it's yeah okay thanks so much okay thank you all right can you hear me okay all right hey everyone my name is Alex I am an Integrations engineer at Uma um for the past few years I've had the privilege of working with a bunch of Integrations uh prediction markets Insurance protocols and recently with Dows helping them with optimistic governance uh really the focus today I'm going to talk about using osnap to decentralize your dial but I really just want to make sure that everyone understands kind of how Uma works and how you can use it in your projects this weekend so what does uma actually do Uma is an optimistic Oracle the records truths about the world onto blockchains so what does that mean you can pretty much make any statement you can use uh which team one team out of Team a or Team B uh you can say is this a valid snapshot proposal and then essentially you can propose a propose a transaction and attach a bond to that transaction that essentially enters into a challenge window and during that challenge window if anyone disputes it's escalated the token holders to resolve and if nobody's disputes at the end of that challenge period it is deemed as valid and can be used in your smart contracts so like I said if the statements are false while uma's Oracle assumes a statement is true but allows anyone to dispute If it's incorrect during that challenge window uh disputes are really rare we've seen maybe one dispute out of every few hundred markets and that's because disputes are financially incentivized so when you're posting uh or when you're making an assertion you have to post a bond and if you're wrong when someone challenges that uh you lose your bond so it's very costly to make inaccurate or um yeah uh bad data in your assertion and that's because uh uma's resolution process is essentially the token holders vote when there are disputes it's a two-phase process that first phase is the commit process and during that commit phase they can't nobody no token holders can actually see other people's votes and they vote based on their belief and then in the second phase each are 24 hours people reveal their votes and at the end the majority of the votes are essentially used to resolve and essentially resolve that market so now I just kind of want to talk through briefly some of the current Integrations that we have and it might help to kind of click on what kind of assertions we're seeing every day uh this is one that I just pulled from poly Market it's a prediction market and it's basically asking if Oppenheimer grossed over 50 million dollars domestically on its opening weekend and I think that um this is a good example because poly Market could have stopped there and that's all they asked and they probably would have gotten the right answer but when you're making statements to Uma I think it's really important to include a data source and really think it through any edge cases so if you go to this Box Office Mojo and you uh there are estimates and that could cause some confusion when people go to resolve this or make an assertion that this is resolved and um in doing that uh so polymarket predicts um they actually specify use the final not estimates even though it seems obvious it can cause confusion and cause disputes and another example is our we have cozy and Sherlock they're both prediction markets and this is just basically was there a hack bug user error malfeasance like and again it's it's basically just asking if um 50 of these are funds in curve was hacked uh before or after a specific block number on ethereum and again I think these these details that they they're providing a specific block and a specific value of 50 or more so there's not going to be any confusion in terms of like if there's a small bug in the UI or something like that that causes a couple thousand dollars that's not disputable or that's not something that you can actually claim as a hack it has to be 50 of those users user funds so I think that's an important distinction when you're kind of thinking about what you can what you should be asserting to the oracle and here are some other examples of our Integrations across is our crosstream bridge and basically how it works is it would be really capital and efficient to make a proposal every single time someone went from one chain to the next so all of the transactions are bundled and basically a few hour period and that's what's proposed to the chain another example is decentralized and essentially asks do all I mean it's essentially verifying addresses on a list so like I could verify um blacklisted wallets or or wallets involved in a hack um I think one of their first lists asking like what addresses what Uma addresses voted correctly 80 of the time so you can kind of think of how you can use this to use Uma to verify um yeah these address lists and then the last one is poly Market it's just asking TV on a certain date but I think it's kind of cool to see like these three different uh use cases I mean one is a very bot driven crash hand Bridge one is a manual manually proposing addresses to a list and then this pull together one for tvl is just using D5 llamas API so it really shows just like how flexible all this can be when you're when you're using data with Uma and I guess like how how does all these uh apply to to governance um yeah I mean this is the typical the typical governance flow um and there's on chain uh there's you know use forking compounds governance contract but this is what we're kind of seeing uh on a typical um governance flow you first have a forum discussion and that's basically a period where anyone can propose an idea and typically Dow stewards or the community come in and make comments and make sure that the proposal is aligned uh with the actual Dow um like what the Dow actually wants to do and then when everyone kind of gives it the green light it usually goes to a snapshot vote and snapshot is actually really good in a lot of ways even though it is off chain it gives a lot of control such as the Quorum the voting period you have a lot of flexibility with like your voting strategies and like yeah if you're it's like if there's LP tokens doing giving them that voting power on chain would be really difficult um but with snapshot yeah it's no problem you can just add it as an erc20 balance strategy so there are some advantages of using snapshot the problem is uh the multi-sig implementation uh you're essentially just signaling on Snapshot snapshot and the votes aren't really binding so um what we really wanted to create with osnap is a way to enforce the votes of snapshot and yeah that's what we're really pushing is reducing the Reliance on the multi-cigs because Dow coordination efforts just don't mean anything if it's just signaling support and it has no actual execution on chain um I'm sure you've seen a lot of these multi-zig problems uh I think yeah the first one multi-6 owners can act against the will of their community for the most part the Dallin Senate the Dow and the community and the multi-sig is usually aligned however um if you're asking the multi-sig to remove themselves as a signer or pay themselves less that could be delayed or not executed at all um the other issue is just yeah the regulation um Dows are not resilient at all if you're essentially relying on a few individuals that you can go into a Discord and find these find these people they oftentimes have ens names attached to their wallets uh or their KY seeds so yeah I mean it's like how how decentralized and resilient is a Dao if all you have to do is go after the the multi-sig signers as uh as Regulators so they're real they really are a Target and the last thing is just the burden of signing multisig transactions uh is not fun like I don't think I mean I always ask kind of what's the process of multi-stick signers uh when how they review transactions and uh it's kind of they kind of laughed at me because I don't think they don't the review process is there's a lot of trust involved and they typically just trust uh whoever is asking them to sign that transaction and the problem with that is the community depends on these signers to always be accurate I mean it only takes one transaction signed uh wrong with the multi-sig for essentially the Dow to go down so that's really why we created osnap it allows the Dow to be the multi-sig so now anybody can initiate a transaction and that can be proposed so by by the um you know the community it can be proposed by the multi-sig any my autistic holders or it can be posed by anyone that's not even involved in the Dow and that's powerful because you're essentially not only allowing anyone to initiate a transaction you're also allowing anyone to dispute and this works the same way as as polymarket did with the prediction Market or cosita with the insurance and the truth is economically incentivized because uh you're posting a bond when you initiate these transactions and the challenge windows can be two or three days and so if you have to post 10 West and someone comes in and dispute you you're essentially losing that that 10 width so it's very costly and people are very careful when when they're proposing these transactions and I think the the most underrated feature of this is transactions um are transparent when voting so they're actually included in the snapshot proposal and I think that's a huge step forward you can actually look at the transactions when you're voting on Snapshot and um it's just so much more transparent so if something is wrong with the transaction payloads you're noticing it while you're voting and you're not waiting essentially for that multisig signers to then execute those transactions so this is just a quick overview of the flow you have your safe deploy the osnap module you can then set some custom parameters or keep the default and then the rest of the flow is pretty much the same all the way through creating a snapper a snapshot proposal except you have a transaction builder at the last step where you're able to input transaction payloads and if the snapshot proposal passes you can then propose and execute those transactions and if it if someone does dispute it goes to the Token holders to vote on I think an important distinction though is that the resolution value that the token holders are resolving is not actually executed by the safe so they have no control of like the transaction payloads that are being executed um they just so if there's a dispute that actual proposal is deleted and then it needs to be reposed so Uma token holders actually have no control over what's being what's being executed or not and these are the so I kind of looked at like the rules of or sorry the the assertion of prediction markets and insurance and this is kind of what's proposed for um osnap where you're really validating um if the proposal was approved on Snapshot the snapshot space um you're looking at the Quorum and the voting period which are actually uh these are just example values but these are what's what are usually set by the team in snapshot and to make sure to basically confirm that snapshot voting system is not being exploited or otherwise unavailable so it's a very straightforward validation process and you can kind of see what these transactions looks like transactions look like in snapshot and I just I created a proposal before this and it's basically asking um yeah is this transaction proposed during the global demo so this voting period has already been completed so I can just go in here and actually just request this and when I'm requesting it alerts me what is the required bond to post I made it zero because this is on test net but and the challenge period is two minutes and and production this is um two or three days with a bond of typically five to ten thousand dollars so yeah I signed that and you can kind of see it'll alert you when these transactions will be are able to be executed we won't wait the two minutes but after this period is over you'll then be able to go through the same process to actually execute the transactions which will send uh this eth to this address so we have some bounties uh we'd love if anyone for everyone to build as much as they can on Uma using pretty much any use case that makes sense to you our first place is five thousand dollars our second place is two thousand and then we have a cool price pool prize for anyone that uses Uma for three thousand dollars and also we're always hiring so if you are someone that's interested in working with us or know anyone that is interested uh come to our booth or feel free to go to this link or just come find us you're not going to remember this link all right thank you and any questions uh that was the snapshot space so um essentially the safe how you how you would deploy the safe you would sorry you would deploy um the osnap module with that safe and then you could go into the snapshot settings and add the osnap module into that into that space and then the rules of the ostap space you want to include that space that you're governing over so um so yeah so like you would have so when you went into gnosis in the Zodiac module you would specify that outcome Finance space and then you would add it to the space in snapshot it's typically the team so yeah so you'd have like um like most dials that we talk to they have core members of the team that are the designers um and so what this would allow anyone to actually propose the transactions and it can still be um the core members I think uh we've probably seen that several times but what it what it still does is allows it to be a much more transparent process and I think the big win is like those transactions are in that snapshot space they're transparent what's actually being signed and uh yeah if something if they're signing something that is not actually valid it can be disputed where can we find them yeah um you can build anything using the uma's Oracle or you could also use across across or crossing bridge so if you have any type of Crash chain use cases you could absolutely use a cross for that um I think that like it's really open-ended so if you have any type of data off-chain calculations or anything like that that you want to that you want to use in your contracts I think uma's a great use case and um yeah it's very open and in terms of like what you want to build any questions a transaction what are the conditions under which is considered some malicious transactions for example yeah that's a good question so um really it would only be malicious if it didn't follow these rules so if there was a snapshot vote but the Quorum didn't actually uh like of the vote didn't actually meet the minimum of the rules or if the voting period set and that proposal wasn't long enough like that that was specified on the osnap module so um the other would be like yeah if someone proposed transactions that didn't actually pass so if you go into um I think it'll help to see kind of well actually this might be difficult like if you go into the ostap module you'll see the rules specified in that module that like essentially govern over that space so um yeah and you can change these rules in these parameters um but yeah this is what really is holding those snapshot proposals as valid or invalid any other questions all right thanks thanks for coming thanks [Music] yeah we'll check where is that uh foreign okay he's having a smoke can't start till the he's back okay two minutes sure are you stand next to me too foreign foreign let's get started good evening everyone uh I'm Jason Goldberg founder and CEO of airstack and I'm here with Rishi Tucker I'm one of our senior developers today we're going to give you a overview of airstack Rishi is going to show you how to write some more complex queries I'm going to first provide an overview of the apis that we provide and then I'll show you how you can use our AI engine to write your queries give you a glimpse of our new explorer that we launched yesterday so it's a graphical interface on top of our AI top of our apis and then I'll head over to Rishi to go into some of the some of the queries first of all we want to make it as easy as possible for you to integrate any web3 on-chain and related off-chain data into your apps the whole mission of the company is just make it easier and easier for developers to integrate with the things outside of the wraps so you can focus on your app use our apis to get the data about everything else and so everything we do on a roadmap is all about how do we make it easier and easier so that you don't even have to run any back-end infrastructure if you don't want to to be able to bring data in about your users about the wrong chain activities and things that increase relevance so first I'll just show everyone really quick the apis that we have let me go here so air stack offers a number of apis today and just from from a company strategy standpoint we decided to go really deep on ethereum and polygon so rather than doing like 10 chains and doing a little bit on each we just had to go really deep on these two chains we also have po Ops on gnosis but really deep on ethereum and polygon and offering features and API access especially around social and identity that you don't find anywhere else and helping solves very specific use cases and then we'll take all that in the coming months to other chains going on the left hand side we provide apis for tokens erc20 721 1155 every transaction since the Genesis block and new transactions within seconds are coming through our nodes very strong obviously and also in nfts we also offer resized nft images inside of our apis you don't have to go out to ipfs and fetch images it's all right there in our apis which we'll show you in a second we also are the first and only indexer right now of erc6551 token bound accounts uh rishu will show some examples of that and we're thrilled to work with uh this the tokenbound working group very close with the team there and a lot of developers building on 6551 see huge potential in that and we'd love to work with you if you're thinking about building on 6551 here in Paris you can also use airstat to get all token balances token transfers of users and then as I said we're especially strong in identity so we have fully indexed ens ens subdomains and regular EMS domains lens and forecaster when it comes to social co-ops all six and a half million po-offs that have ever been handed to anyone we have inside of airstack and new within seconds and also as of yesterday we also index xmtp um and so xmtp you might be familiar with is a messaging protocol enables you to miss a messages from one zerox address to another at airstack is the only way today you can find out who has xmtp so you could query does this forecast or address or this lens or this ens or does the whole who in this co-ops has xmdp so we enable that as well as a benefit with inside of airstack um and the other thing that we do also with related to xmtp that's really interesting is we act as the universal resolver for xmtp right so with xmdp you can message from a Xerox address to another Xerox address but I don't know Rishi Xerox address but I do know his forecaster name and he might know my lens handle and with airstack the messages get through because we help developers resolve those so all you need to know is the name of the person that they have whether it's their ens or their forecast or the lens and we help devs resolve that we'll show you in a second and then we have a lot on nft sales and marketplaces um in our apis as well so let me go back here and there we go here so okay so one second sorry let me show you all right um so when you go to air stack the first thing you'll see is that once you run aquarium airstack if you want to you can share with the community if you want to really start to jump in and learn about the apis one of the things you can do is just browse queries other people have done so you can see there's a query someone did that has 374 runs and four Forks so I've got all erc20 721 tokens and pull-ups nfts to someone or a bulk check if a Xerox address have xmtp and primary ens I think Reese's can actually show how to write this query today and you can just see also there's by different tags you can see queries that people have done about socials and you can just dive into any one of these and you can see the graphql query that that that that the user did to get this right um and so I'm just giving an overview we'll walk into some of these and work through some of these in detail in a second but the first thing I want to show you is the cheat codes so the cheat codes is we want everyone obviously to learn our graphql schemas and our apis but you don't you can also get started using our AI engine our AI engine is built with gpd4 we've been working on it for seven months now it's fully trained on the air stack apis it's over 99.9 percent accurate so if anything is in our apis it can help you write the query so I'm going to show you for instance I'm going to show you two queries here first I'm going to pick on my friends Shane Mack who's the CEO of xmtp I'm going to say show all nfts tokens socials ens and xmtp for Shane mack.eth and I'm going to ask the AI to generate this for me pretty complex query I mean this is basically saying nfts across ethereum and polygon tokens across the theorem polygon socials is both far caster and lens ens and uh and and not even providing a Xerox address or providing a zns that it's going to resolve and there he goes there's the result um and uh here you can see his forecaster name machine Mack his lens is Shane mac.lens here's other domains that he has here says tokens here you can see we also bring back the images of those tokens all here in a single query in response so you can create all sorts of amazing user experiences with this just from a single API call obviously you could also do this in multiple API calls but the AI helps you learn this and just to show you an example here I mentioned we built an explorer that we launched yesterday and this Explorer is a front end to the apis I'm going to do the exact same query so I'm just going to type in Shane mac.eth and there's the results and the Explorers designed in a way where this is entirely forkable you can grab sdks for the for this from with react uh and uh JavaScript and python we have the code is available for the front end here you can get it from our GitHub and then for any of these queries that you do like the one I just did from the front end Explorer you can also just jump right back into the graphql and get the API so here I'm going to go right back in and get the API for that that query right there that made the front end so very easy to learn it either way you can use the AI or you can use the uh the Explorer front end something else I'll show you from the Explorer real quick is we also not just wallet balances but also token holders uh here's an example this is very current this is eth6 there's we have aggregated counts of the token holders you can see the socials how many have EMS forecaster lens pretty impressive actually the 570 people from the 1136 have signed a transactional polygon and got a lens address just clean um and uh here you can see all the token holders and then same thing again if I go to the graphql here you can get that exact query right there and as I said before you can also see that the images are resized so you can literally just call our apis and get whatever size you need and plug it right into your application so you can build something like an Explorer but you can also do all sorts of other things and just to show you real quickly in our docs we have a number of different use cases we have specific around token balance 6551 has xmtp resolving identities we've all said a lot with contact recommendations so we've done work with with forecaster and with lens and with xmtp to help recommend people that you know based on your on-chain behaviors so people that you've sent tokens to or sent to you uh you have like nfts in common or co-ops that you've been to together we also there's a lens playground we built so happy to share if anyone's interested can show you some of that and lots of other use cases as well that you can dive into in our docs lots of tutorials here as well all right uh over to urishi to get into more that was the the fast overview and the brief is going to details thanks Jason hi everyone so let's get started with some pretty interesting queries right so um for the first one let's try and get all the people that hold the Bob for HCC Paris and let's see what extra information we can get after we get those owners so for that we can use our Co-op API over here we need to pass the event ID I have that here right and we can see the owners and their addresses we can see more things about the event such as which country City yep and let's go right so we got that this is a yeah this is like the pop-up event for ECC uh Paris we got the metadata we have some description associated with it and yeah this is the owner for this particular uh token ID so now uh supposing you met somebody here at uh HCC and you wanted to reach out to them say on xmtp so you can quickly check with xmtp whether they have xmtp enabled or not and let me right so for whomever it is so for example this address xmtp is enabled this act as xmtp is enabled so you can directly reach out to them and we can even get their primary domain as well as their different social handles and voila so for example this user has xmtp enabled here this is ens here's their profiles as well so this is one uh pretty cool query that we have um moving on yeah so for the next one uh let's look in let's look more into erc6551 and um let's try to form a pretty cool query so we have the accounts here so this account represents like the account which is the which the nft is owning and let's say we want to get all the it started getting all the erc655 phone accounts we can get the address the token address token ID some information about the nft as well right yeah right so here we have the um right so this is the address of the of the contract deployed this is the address of the nft and like because this is a wallet so we can get other information about it as well like whether it has any ens or any lens accounts and here we have the nft and there's some metadata related to it for Eid so we can take a specific token address and token ID and we can add it into our filters so token address here and you can ID right so um yeah so here we have for that particular nft we have the address of the deployed contract and we also have the token address of the nft which is owning that account and say we want to get that particular the owner of that nft as well so you basically have the account then the nft and then the owner of that nft so you get the like the true owner of the entire uh sort of uh tree here for that we just need to go into nfts we have token balances and here we get owner and after that we get the addresses yeah so now we get this particular address here so this is the externally owned account which owns for this particular token address and this token ID he owns this nft and this nft is what is owning the account so just putting that together we have a pretty complex query here and using this there can be ways to get like um for a given a counter a given set of nfts we can get all the um yeah all the ERC 6551 accounts related to that and as well as the owners for it so it could be a way to kind of get the total balance of a particular nft because if you have uh this nft and each ERC 6551 can hold multiple nfts and those nfts again can have six five five one so you get like a complete tree so yeah we can get that all through our stack and for the last query we can get we I can show you how to use variables so uh rather than entering everything uh in the UI we can just take a bunch of variables here's these are a bunch of addresses uh that I have and I'm building a query now where we can get a given uh owners for each address we can get their ens name as well as their whether they have xmtp enabled or not so you can go through token balance how we add a variable in the UI is we select the owner and then we just take care and this dollar sign here add the variable yeah and here we can just pass addresses and you get their owner we have their socials domains so let's start by getting there ens names file names and xmtp is enabled right so here you can just uh summarize like we have a array of addresses which are going to pass as a variable and we're getting all this different information about these particular addresses right let me add a few more yeah so I didn't get tabular form might be a bit better here so we can see like for this particular address there's socials so this particular user has two socials one is CR which will be on forecaster the other is lens uh the domains which he has he has three a couple of uh at least 10 EMS names here and like this particular address has xmtp enabled so yeah that's really powerful because in a single query you're able to get the owners and their socials xmtp status as well as their domain information and we can even add token addresses as well here so you can get for a particular nft um all the owners and their particular social handles and other identity fields right well yeah um so we'll take questions in a second uh just if you're interested in 6551 definitely recommend reading through the docs that we have on 6551 and also the 6551 Founders are in our Dev chat and they're on standby if anyone needs any help deploying your 6551 our team can help somewhat and they they're saying by to help um and in particular in the in our Dev in our Dev docs we also have some some queries you can just kind of like replicate on 6551 one of the very interesting ones is you can just say show the last you know 10 where you need to show all six five five ones either deployed on ethereum or polygon and if you just add in at the end and all the assets in them you'll see the whole tree of every asset the images of the nfts at those 6551 accounts own uh obviously we can go into a lot more we also can answer any questions one-on-one or come to our booth and if you're not in our telegram chat yet please join because our whole team is standing by to answer questions and we have six minutes to answer questions now go ahead please plenty yeah so airstack is completely free until September 1st starting September 1st we will have a generous free tier and then I'll be charged based on usage but for now it's entirely free there is a rate limit if you need a rate limit increase we have five additional free plans right now so just let us know what your needs are and we'll give you a rate limited crease you can just request on our team uh yeah so uh ethereum mainnet polygon mainnet and so we do recommend hackathons like we don't index quarterly right now we know a lot of folks would like us to so if you need to Matic to use on polygon just let us know we'll send you some yes please all right so um new transactions uh I think you're asking how fast are things in airstack a new transaction and a theorem of polygons should be an air stack within a couple seconds um we've tested over and over again for performance it's the very very low latency it's not real time but it should be just a couple seconds right now only we run around ipfs nodes right now ipfs we have a couple other off-chain data sources we use for descriptions and metadata uh we're not we're not right now unfortunately not indexing where we've yet yeah but um yeah so yeah so uh basically the yeah so the token URI which is there in the contract like if it's an airb URL or an ipfs URL like we're making the call to the nodes getting the data storing it and you wouldn't have to add any extra like effort from your site to fetch it like it's all on airstack Steve and I learned something new today um so it does have like yeah yeah in a way yeah we have two minutes left anyone all right thank you everyone appreciate it thanks for coming thank you thank you distance you should I help micro ah perfect thank you hello everyone thank you so much for joining us uh for today's Workshop my name is Gyan and I have my colleague Umar together will be exploring the world of provable programming through Cairo it's a bit of a long title but I have I have bolded things that are basically important that is provable programming and Cairo the agenda for today is why Cairo before learning any new programming language especially in the web 3 space I feel like everybody should ask this question to themselves why why should you learn another new programming language and what does it bring to the table we look at what are validity proofs and uh how are they solving the scalability problem and then all about Cairo with Omar thank you so why Cairo I just have one slide for it and I'm going to try and explain this in a scenario that's best understood by Developers when when you write a program in any programming language you execute the program and you try to get a result for that program right most of the times this is how you are trying this is how you have been seeing systems running so far however if you want to make sure that you want to prove that something was done correctly then you want to create a proof out of that program right and most of the programming languages that exist as of today do not allow you to generate that proof however when you write a programming a program in a programming language like Cairo when you execute this program in any supercomputer for example in this context or any computer for that matter in the world it will not just execute that program it will also generate a result and a proof for you now this slide is actually has a little bit more context but because of the shorter Workshop today imagine if this supercomputer exists in a rival country and you have given them a piece of code to execute right you want them to give you the result and you want to make sure that the result is accurate if the Rival country tries to manipulate the result uh whether it was intentional or unintentional you will come to know because along with the result a proof is generated so the idea of web3 or the idea of blockchains is to be able to create trustless cooperations right you want to be able to trust any Source or any machine that runs a piece of code and the best way to do that is for that machine to be able to prove that I have run the exact same algorithm that you have given me this is exactly what proof systems do proof systems help not only generate a result for your algorithm from your algorithm but they also generate a proof that I ran the same algorithm that you gave me and you might have heard of zero knowledge proofs you might have heard of provers and verifiers which is what is used in zero knowledge proofs and this is what exactly the provers do they generate a proof that a certain computation was done authentically so in case the computation was tampered whether intentionally or intentionally the proof generated for that computation will be invalid and this is how in a zero knowledge proof or in a validity proof scenario a regular computer is able to keep a super computer honest the Crux of all of this is that in order to generate a proof you need to learn a provable programming language which is what Cairo is Cairo is a powerful and a highly performant programming language which is not just used in stock net but can also be used as a standalone provable programming language that's why we chose to freeze the talk today as explore the world of provable programming through Cairo how a validity roll ups solving the scalability problem and why should you build on stock net that's the next question right when you think of the L1 scaling problem you have ethereum where say for example when you're producing a block it just says that hey like you remember the uh the problem where we are seeing like okay here is an algorithm we are executing this algorithm the new state of the system is 42 right and a lot of books also say that the answer to all worlds problems is funny too well we can only hope um and what happens in the system is the validators actually validate whether this new state is correct and how do the validators validate they are going to rerun the entire computation that this particular block producer actually ran in the first place and I'm sure all of you already know that ethereum has gotten congested more often than not in the past couple of years especially when there's been huge launches etc etc and that's a huge bottleneck in l1's whereas when you think of proof systems if you remember in a programming language like Cairo you can not just generate a result saying hey the state of the new system is 42 but you can also generate a proof that how the state of the system became 42. and what happens at ethereum level right so you can see there are two distinctions here one is the sequencer and one is the validator now sequencer is what is sitting at the layer 2 at stocknet which is producing this new block and it is also able to create a proof now the validators instead of having to rerun the entire computation we'll just have to verify the proof that is generated by the sequencer and the time taken as you can see is pretty pretty less than what it takes to actually rerun the entire computation not just.net but almost all of the zero knowledge proof mechanisms that you're looking at or validity roll up mechanisms that you're looking at use this exact mechanism to achieve scalability for ethereum and that's why you should learn about stucknet that is validity proofs variety proofs are an implementation of zero noise proofs to say that they are zero knowledge proofs is actually a misnomer it's not correct because starknet is a decentralized layer 2 which is a public network so it's not entirely a zero knowledge proof system but it adapts from the mathematics of zero knowledge proof systems it takes from the arithmetics of that and is built on top of that and because it validates in a way that is based on the prover verifier system that's why we call them validity proofs they use ZK proofs to guarantee computational Integrity that means you can always say that a particular computation was correct or not just by being able to validate or invalidate the proof what this means is doing the right thing even when no one is looking which is the ethos with which web3 was created right uh we placed our trust into code and non-middlemen because we want everybody to be able to do the right thing even when no one is looking um there's a lot of um there's a lot of misunderstanding when it comes to what you can build on things which are built on top of principles of zero knowledge proofs because zero knowledge proofs are generally considered to have more privacy use cases but that's not the truth in this case starknet itself it's all about scaling right so you can just about build anything on stock net a lot of people came to our booth asking if we are leaning towards a particular domain and my answer is surprise us if you're building on stock net build anything cool and we are more than happy to you know see what you're building it uses a particular algorithm called Starks not star snacks are two advantages of stocks I want to quickly run through before passing it over to Umar uh the first one is that stocks are post Quantum secure because they don't rely on elliptic curve cryptography they rely on collision resistant hashes and the second is stocks do not require a trusted setup whereas snarks do so they are decentralized from the get-go Cairo is the programming language that we are using right now to be able to write contracts to deploy on stock net and the next session is all about Cairo [Applause] okay so thank you very much now we know the relevance of Cairo what I started this for and that's now let's look some at some Cairo is who is here considering building something on starnet for this hackathon okay awesome most of you okay so today who of you have already written Cairo who has written Cairo before okay so okay okay what is your name sir Danilo you know who the nilo is he's building this is which is using Cairo for being as you're not gvm so what Yang was saying was very relevant you can be Latino GBM on top of Cairo honest argument so this is very very interesting you can do a lot of different stuffs and to be honest we won't be able to be to to learn how to write Cairo right now in this 20 minutes we have left but there's our boots and feel free to come and we will see more details about it we'll go like with an overview right now but feel free to come to our booths downstairs and we can guide you we can help you and you can build some very cool projects for example uh some guys which I I don't know they they are not here but they came out and asked us if there's something like auto payments they can Implement on on or started with Cairo and auto payment is for example when you subscribe to Netflix and Netflix made you makes you a charge every month without you even you don't authorize it you towards it once and then you have you don't have to keep signing the transaction each month it's automatic and that's thanks to account instruction that is something that we have natively instructed and it's something that we have been working on a lot of time with opening Bravos urgent uh members from Team foundation so we have been working hard on a construction and that is something that I don't know if you can build it without quality another place that it is not Starbucks and you can do all that with Cairo so it's Cairo basically is a smart contract it's a language that is very similar to Ross who knows Rost here Rost perfect portfolio is going to be very very simple but don't worry we don't know roast it is very doable who knows solidity here okay you know solidity and you know how a smart contract works it is very simple so I will go and see a small smart contract here and also point you to a place where you can learn more I love learning in a written way so if you want to install everything you need your setup in order to build on top of current star net if you scan this QR code you will go to the Stark netbook as with the rose book you will have everything you need to start coding the syntax of Cairo the setup the CLI in order to interact with the with the network some tooling you can write your contracts using a started gays which is an SDK that will be similar to whatever you use in in JavaScript to interact with ethereum you can do it with python you can do it with roast so we can different sdks everything you can find in the Theon ecosystem you can find it here and this is the guide for you this is the guide for you to install everything and then start writing Cairo contracts you will be able to go for this hackathon again you can you can ask anything you want downstairs actually one of the creators of Cairo is down there with us so who better than him to to answer your questions and let's look how a smart contracts in Cairo looks if you go to the the Stark Netbook this is the startup book the one you already scanned your code and you will go to chapter number two inside here you will have the fundamentals of Cairo Cairo applied for starnet because it's different right and here it says small smart contract that will allow you to vote it's a boating contract just an example but this example will get you going so let's start okay I will import with user starting is the library that contains everything related to starnet I'm gonna import the contract advice okay not very similar to solidity and then as as in roast we're gonna Define atroid this trade is going to contain all the functions that are going to be external functions what I mean with external functions the external functions are those that interact with this with the memory or the state of smart contracts okay those that can read or write from the state for example this is the trade both right T here makes reference in this case to the state of the smart contracts okay so we are receiving here the state of the smart contract and then we're going to be interacting with T so again T in this case is the state of the smart contract then we have this function called get both status yeah I want a function that is a getter function for for those original solidity is going to be reading from the storage and it's going to get me the status of about how many yes how many know it will make a reference pointing towards the storage okay why because I don't need to write on storage for the for those of you who knows Rost or memory management this is very familiar to you so here we're referencing the storage because we need to read from it we don't need to write on it so it is basically a read function or a getter and it will be returning four different u8s on sign integers eight bits okay this is also another getter function it will be written from them from the storage and it will tell me if a motor can bolt it will receive again the storage of the contract and we'll receive the contact address of the user that I'm asking for can this user vote I will give it the address and it will returns it will return a Boolean true or false and we have the same with Isa both the register yes or no in this case one or zero because it's a Boolean it looks like that and finally we have an external function but it is a write function okay this write function which is both it references the storage but it can it is not only like a reference to reads from the storage but it can write it it can alterate the storage I that's what I'm telling with this notice the difference between this and this okay these are gear functions only reading from the storage this is right into the storage and it will also receive the boat and onsite integer 8 Bits yes or no in this case it would be zero or one okay then we'll be implementing destroy it so we're defining here in the storage the the functions are going to be interacting with the storage either by writing or by reading and then finally we go into the starnet contracts this this via this is going to be a module mod called both that is the name of the smart contract then we will import a couple and we'll import the contract address from started and we're going to import the function call get caller address I don't need to explain those those are very similar for you we have two constants one that represents a JS and a no those are u8 and they are one you ate this looks a lot like roast for those of you that have already seen it but it is very simple if you don't know Rose no problem then we're gonna go to the storage is very simple you can you can read for a moment and you will understand it we have guest boats no boats cambods which is going to be a Boolean it's gonna be mapping this is a mapping like in solidity a contract address to a Boolean register voter is going to map a contract address with the Boolean again and yes and no boats are simply on sign in tiers until now is there a question we have seen how to create the trade for the functions that are going to interact in with the storage we have created we have started our own smart contract and we have defined the storage the next going to be easier so is there any phone any question here yes [Music] yes you won't even notice it behind it it's building everything you need in order to to interact with Cairo know implementation no no on the contrary it's very very cheap so the goal here is that we are having a network that is going to be very cheap to use and also very fast we have we had a recent update to the network last week actually which increased a lot the TPS from the network like I think right now is the fastest your knowledge Network there is it's it's it's to be honest this is going to increase in a lot in the next month so congratulations for being here because to be honest we are in a very good spot right now with starnet and this is going to be even even better okay so I will proceed again there might be more questions but we can meet downstairs no problem then I have the Constructor this is for you is very similar if you know python Ross I don't know JavaScript they have a Consulting like a Constructor or simply what we're doing is initializing the smart contract so the Constructor when we deploy it we are asking for four things first we're asking for the contract State again this we can modify so I can I asking for the state and I'm going to be able to modify it and I'm gonna ask for three contract addresses for both the number one voter number two and voter number three we only have a smart contract for three different addresses to both this can be infinite four or five whatever in this case in this example we only have three then we are doing some stuff in the initialization we are calling functions inside our smart contract using self and calling internal functions like register voters in here I will show it in a minute but to me this is very important here I am altering the state of the smart contracts I am writing to it okay so what I'm doing here is self on this smart contract that is self go to the guest boats which is on the storage here this is the guest volts variable in the storage and then write the number zero but zero in a format of a of an unsigned integer of eight bits sorry I'm making some Zoom here do the same with no boats what I'm doing here is basically saying hey the the voting corner is going to start with zero votes with no zero with yes okay so right to the storage that we don't have any votes we know and no votes with yes that's basically it and we are also registering the voters like motor one motor two and motor 3 can vote that's all we're saying these guys can vote and we're initializing the the boat count with zero and zero then we we create an event this is how events look like in starnet and Cairo I won't go into details right now both and you can go to the boot or you can read this in the book starnet.io I will give you the URL in case you want to review it but this is how an event looks like okay then I want to show you how to implement the functions that we actually defined before in Detroit okay so we create an implementation of that is going to be called both input this name can be changed it can have any name no problem this is an implementation of super which means it's an implementation of something that is in this file which is called both trades and it's going to be receiving the contract state if you go to what is both trades both trade is the trade that we Define at the beginning that contains all the functions that are going to be external functions okay so we are now implementing all these functions here I am defining a gateboard status look like this and receive this and returns this why not telling you how to implement it okay so now we are going to implement it and yes that's all here's a function you can see it here it is get both status we will show we've mentioned it before it is not going to be right into the storage it's simply going to be reading from the storage and it will be returning me for unsigned integers of 8 Bits And then I start writing the function as you can see it's nothing sorry it is nothing out of this world let's calling this function with self the self because simply it is referencing to something that is inside this smart contract then we're defining the yes storage and no percentage it looks like for those in Python it looks like toppo it's actually a topo and then it we call a function and that's it I think you can understand this is very very simple then we Implement another read another get their function which only reads from Storage we do the same here and this is very interesting to me this is the external function that actually writes which is the boat so it Alters the storage it says this number of boats were with yes and this would know and basically it receives a boat then it helps an assertion which is very useful in Cairo for for finding errors in your code so we assert that the boat should either be no or guess otherwise it will return this error both zero or one this is a number that will return if I can if I bought with two or three or four it won't understand it and it will return this error and it will stop then we start calling some functions but again this looks to you very similar to solidity or any other problem language it's it's very simple and basically then I do the same with another set of functions and that's it that's basically it this is the Cairo smart contract right now is to be honest very simple you know python or you know you know rust or or solid this studio is very simple so a sorry we couldn't go through a lot of details but again we will be downstairs tomorrow today and the day after tomorrow will be there answering any question that you can have and please go to the book standard.io let me give it to you the this is the QR code to the book but we have most of the content you need to do this you will have the voting contract plus other examples you are willing to implement a construction you also have a construction examples we have all the tooling you need if you write python JavaScript roast whatever you will find it there if not please let us know all the tools are there the future for us is going to be scalable and and we we really believe we're building stuff for the next 20 years and it started we think is is a great solution to me it is the way to go and yes let us know what you think um and yes thank you very much thank you to Jan and thank you for coming [Applause] a couple minutes do you have the uh let me find that out so we have a telegram Group which is uh of high quality where we have a lot of builders in starnet so you can feel free to ask stuff go go write some Cairo let us know that you're writing Cairo and and we can we can help you in different ways right so go explore it feel it if you like it let us know if you don't like it also let us know and um we can we can support you we are here to help you our goal is to make to to get as many developers as possible we're not interested right now in investors or in that many users Financial users person we are more interested in building right now so if you're a builder let us know and we can help each other oh sorry ah so just very quick please very easy she asked how to deploy and you will find everything you need here in the star Netbook in this QR code he will you you will find in the introduction to starnet your first smart contract first started contract and then you will find everything you need here to deploy you have to create a signer because we're using a construction somebody that signs for a transaction you have to declare it which is a different concept but you will find it here then deploy it and but yes you here you will find anything unique sorry yeah so I'm trying to figure out uh in practice what use case could run on starknet that I couldn't run let's say on on a regular evm chain if I understand correctly this is one of the fastest of the serial knowledge chains but doesn't mean there are some some things I can do in this chain that I cannot do on the others or is it just faster than what yeah imagine you have a bigger computer and so whatever you think requires more computation power computational power I think this is a use case for example right now we are building a lot of a lot of autonomous worlds for gaming online gaming where all the regulation is made on chain all the operations are made on chain also because it's cheap and it is fast you can do AI on chain this is something that I have not seen in done on chain it's something that is weird I don't know if somebody knows about on-chain AI build all the calculations on the chain that is something that's something hard to implement because of the cost of the Velocity so I think that if you can think in something that requires a lot of computation this could be a use case of course I'm not saying that this is good for everything you don't want to kill a fly with a bazooka right so you have to think about it but yes yeah so we actually want to use it for AI but um as far as we understand if we use zero knowledge for AI it increases computational cost by like 100 even a thousand sometimes so um is that something that would happen in darknet as well sorry Daniel is working on that right then can you for example somewhere else get the proof of everything to that output and verify that on your smart contract with the exact same models so I think that's uh their code and don't have to use any CLI any Tab and this and just also you want to do some AI I recommend you you check out Orion from the desert tech company it's they are building they're using starnet and Cairo to build some AI so they're actually in this hackathon right now and you can meet These Guys these are these guys are genius and they are making own chain ML and here we have a lot of different tutorials on how to use their models and this is something that I think is going to be the future in the next year we will talking about this and I think this is a great opportunity to win a hackathon right it sounds very impressive AI on chain okay thank you very much we'll be downstairs thank you [Applause] can uh foreign 