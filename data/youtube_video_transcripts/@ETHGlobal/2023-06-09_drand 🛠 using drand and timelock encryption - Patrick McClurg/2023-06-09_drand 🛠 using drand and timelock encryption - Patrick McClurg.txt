foreign [Music] and welcome to the hack Fest Workshop using Durand and time lock encryption joining us today is Patrick McClurg who will be taking us through the session and with that I'll pass over to Patrick to get the session started thanks very much Troy yes welcome everybody to the d-round hackvest workshop first we'll go over a little bit about the challenges and then we'll dive into we'll be around is how it works uh then we'll finish up on what time lock encryption is and how you can use it and then I'll field some q a at the end for any questions you might have along the way uh so firstly the challenges are twofold first is for the best app built with timer encryption that might not make any sense to people who have not come across timeout encryption yet but we will get to that very soon secondly uh there's a prize for the best use of dran that solves an everyday problem and improves the security profile of a blockchain use case a game or improves the d-round ecosystem and there's a two thousand dollar reduce up for grabs uh for people who make the best apps essentially Okay so what is Durant Durant is a decentralized threshold Network for providing publicly verifiable unbiasable random numbers uh it's based on threshold photography as I said um and supports pairing operations which we'll come to a little bit later essentially when the network is created a verifiable SQL chain process happens and a shared privacy amongst all the participants of the network has created which new single party has access to uh and then they emit Randomness at epochs using the signatures from threshold cryptography it's built on BLS 12 381 has been tested audited by kodelski security and deployed at scale the the biggest user right now is Falcon Network who used the randomness from Durand for leader election and some other approval of space time to do things and currently dran Randomness is available on the fvm and the cosmos ecosystem and kind of on ethereum in fact in one of the previous ethereum hackathons a team-built uh ethereum integration for Durant called orangesis which I've linked in the bottom of the slide here in case and if you want to try it for yourself so a bit of a primer by dram Works uh the notation is not super important that's for the maths nerds who like all the extras but in essence uh do you random it's Randomness epochs each of these epochs mapped to some time in the clock so for our default Network that's every 30 seconds every 30 seconds the nodes in the network gossip are partially signed message um over the the number of that epoch and then when any node cleans a threshold number of those signatures they can aggregate them into one group signature that's valid for everybody in the network because as I said before no single node in the network ever has access to the private key uh that signature is indistinguishable from Randomness as they can pre-imagine uh then we pass that signature through a hash function to remove some mathematical properties from it and that becomes or a random number and this happens at every single Epoch everyone in the network gossips all the partial signatures to one another and create the randomness you might be familiar with some existing types of Randomness and I'll just give a brief breakdown of how diran differs from those um so the one most people are familiar with is uh their view random built into all Unix machines and Linux machines and MAC machines and there's kind of an analog in the windows world it's probably what you use to generate your Bitcoin Bitcoin private keys and do lots of other day-to-day Randomness operations um the biggest difference obviously is the do yeah Dev view random is private Randomness and dran's public Randomness so naturally you wouldn't want to give your Bitcoin private key to anybody else unless you want them to take all your cash uh do you remember all the random numbers are public everybody can read them everybody gets the same random numbers Additionally you run you random on your own device but drand is a decentralized network so there are lots of different participants working together to create this randomness and finally drand is verifiable so if you were to get our number from a random generator you sort of got to trust in the fact that uh it's implemented correctly that you're using the right generator that the number that comes out is actually random uh but because dran is based on a signature scheme um you can verify the fact that that has been generated correctly and because of the property we mentioned before of not being able to pre-image the signatures uh it's both random and verifiable which seems kind to intuitive at first uh dipping into some more of the public Randomness world for people who built an ethereum before they may be familiar with randow Randall as a Dao and a smart contract on ethereum network um where users omit to providing some bit of entropy to Smart contract and at a later Point reveal that entropy and those uh it's a Randomness or aggregated together into a final random number oh do you want to differentiates from this is firstly it's unbiasable so you can imagine someone who has a lot of power in ethereum network like let's say a coinbase I can actually take up many slots in this uh a round out contract and they can choose to reveal or not reveal their little bit of that Randomness uh based on the prior outputs so if you manage to get some number of slots at the end of any round out Epoch you can output you can influence the final result also a cool thing about dram being based on a signature scheme is that it's not just web 3 only there's not a d-round blockchain per se it's not just on on one blockchain in fact you can get dran beacons from any CDN you could even get them from an adversary and because they're verifiable you can know that the dram network has generated that random number um a final project which is very commonly used at the moment in blockchain ecosystems is chain link brf uh chain link BRS allows you to request random numbers and they create some uh roofs and write them somewhere before you use them to show that the randomness has been generated fairly uh firstly like randow like the difference with randow chinig is primarily for on-chin applications but also the trust model is very different you're contacting one party chin link to run that function uh to Output this random number whereas dran we have a network of participants and you must trust that there's never a threshold number of malicious parties in the network and so the model is just a little bit different foreign we currently run two networks in production uh the default Network and the facet Network the core differences between them are that the default Network emits Randomness every 30 seconds whereas the faster Network releases Randomness every three seconds uh they have different URLs for for interacting with them naturally and also they run in slightly different modes so in the default Network running in chained mode each Beacon contains a reference to the randomness from the beacon before it this means that they form a bit of a Merkel dag and uh one drawback of that is that we can't do time lock encryption which I'll come to later using this chained mode faster Network by contrast each Beacon stands alone it's not linked to the previous begin through this chain of signatures and that means that we can predict uh all the future messages although not as signatures um for beacons are going to come out in a facet that's the secret sauce for timer encryption which we'll come back to in a bit uh also my third extra for any math nodes uh in in facet we swap the G1 G2 grips in BLS uh in order to have smaller signatures and bigger public keys because the foundation of the network would create one public key and that every Epoch we create a signature which obviously is a Randomness so it means you can save gas costs if you're using the blockchain so if you were to go into terminal law and request some Randomness from the dran API you would come up with something a bit like this um the top entry here is the round number so that is an epoch that's a monotonically increasing number every time the network emits a piece of Randomness uh is that a new brand it also Maps a specific time on the clock so you can predictably know when a specific grind is going to become available the next key and it is the randomness itself which is a sha256 digest the signature um Third Field the signature is predictably the signature um it's a group signature for the entire network so again it's uh the the key pair that was done I created during the uh distributed key generation process and it's BLS 1231 uh for chin networks is also a previous signature which like I said links to all those previous beacons uh so easiest ways to get to your brand or to use the client libraries we provided one and go and one of typescript those are the official ones of course you can get it through any CDN through any HTTP client you wish but these also bundle in verification the signatures as well just so you don't have to do it yourself also everyone in our community seems to be a rust station so there are a whole bunch of different rust plans for those of you who like writing things in Rust and also actually this one the top one d uh is also a CLI that can do time lock encryption and lots of other cool operations uh so you should check it out because it's awesome uh I've got a slide that says demo time now which is slightly a lie it's more a bit of a Code walkthrough in a demo um let me heal my presentation momentarily I'm just going to go into the integration tests of the drank client for JavaScript I think it's an easiest way to understand exactly what's going on and at least you can find it later in case you don't really remember what happened in that presentation um so we've got an integration test here essentially you create some Plumbing uh we're fetching the public key of the network which you can also do out of band there are so other objects that allow you to not have to make requests for that we provide three main functions firstly you can fetch a beacon by the time you can just pass in a classic JavaScript date and the mapping between wall time and d-round Epoch will be figure out magically for you if you happen to know the epochs that you want to use you can also pass that in and fetch a beacon just by its round number finally we provide a watch function so if you're for instance building a game that needs to consume dran Randomness in a timely fashion at every single Epoch you can get an async generator here that will call some callback uh whenever you proceed to randomness these are also more or less available in the same format in the Google library so I shan't go into the go Library but any questions on that obviously hit me up and okay so that was how to use dram and a little primer and how it works let's now look into timelock encryption uh it kind of does exactly what it says in the tin it's encrypting something nigh that can't be descripted until some future time has passed uh the Crux is that the dran network is a bit like a reference clock it ticks um for every Epoch and emit sad piece of randomness and so we can rely on it to map clock time uh also side note uh my colleagues presented the technology encryption scheme at real world crypto um so if you want to go a longer form explanation of how it works and all the Gory details uh you should definitely go watch uh the talk of an advanced encryption in real world crypto so driving a little bit deeper how does time luck encryption work well it's simple uh fancy Mass I guess is a short term for those of you whose eyes are just glazed over after uh you know going through school and seeing discussing things like this we're not going to dive into this don't worry I've simplified it uh just a little bit further so I said in one of those first slides that BLS 1231 supports pairing operation this is essentially exploding some mathematical properties of the equation as it were in such that you can move different things around without changing it so I'm not encryption Works a little bit like traditional asymmetric encryption in traditional asymmetric encryption you've got some public key that you use to encrypt Upland text and the output of some ciphertext and if you take the side protects and some secret key that has a relationship to the public key uh you can combine them and and decrypt the site protects and come up with the plain text what time lock encryption does is basically turns the round number into a public key and the signature that gets emitted from that round number into a secret key so like I said before an Unchained mode because each Beacon is not linked to the beacon before it we can predict the exact message and exact bytes that will be uh signed over by the network at some point in the future that means we can we know that message now we can use it as a public key to encrypt something and we won't be able to decrypt it until the dran network emits a piece of Randomness in the form of a signature at a later point in time uh we've built some libraries around it but also a cool web demo which you're welcome to try anoic it's called time Vault it is a web application for encrypting vulnerability reports so that when you find all those Adobe flaws even if they take you out with assassin the world can still know what you find uh it's built using t-lock JS obviously it's backed by the dran network um I'm not going to demo at night but you can obviously open in your browser and give it a fiddle for yourself all the codes open source it's all in GitHub and there's also a paper I need print if you want to know how it works uh before we do the Q a I will give the same not quite a demo of tlog.js again we've got some integration tests in there I think those kind of give the clearest picture of how to use this in practice um but then essentially we bundle some minute and test net clients in here there's a function called time lock encrypt you pass a round number that you wish to encrypt to in there there's some tooling as well around um mapping that round number to a wall clock and and back and forth and then there's a Time Mark to Crypt function which takes also a client and takes your ciphertext um it supports um an asymmetric encryption of the hook called again actually good encryption which works and looks a little bit like pgp if you've already fill up a time Vault you see that the output of uh ciphertext here is this cool I gain encrypted file which again looks a bit like a pgp ciphertext so um yeah I employ you to get involved check it out and try all the libraries um luckily I've lost plenty of time for Q a um so if anyone has any questions about derand or timeout encryption I'm always I see oh there are some in the chat here is links that generated random numbers set yes indeed is a shout out of absolute digest so it's got a fixed length hypothetically you could do your own hash key derivation function on top of the signature as well um there is in fact somebody raised a PR somebody from the community or as PR to do that on the dramry Boost so there's some prior art there if you want to go and check out how they've done it or uh or come up with your own derivation function uh Tony is it going to be available on chain that depends which chain you're using it is available in the cosmos ecosystem already through the noise Network that's nois um it also d-round Randomness is included in every block header of this filecoin network um so you can currently access it through the pre-rand out op code if you're building an fvm actor for instance it's not currently available out of the box on ethereum although as I said before um there's a project called orange Jesus uh with a G and not a j that have built all this for Relevant bindings to do on on ethereum if you'd like to do so yourself unfortunately BLS operations are a little bit expensive as currently they're on pre-compiles on the evm flat but there is an EIP up for them so you should go and uh if you want them go and hassle ethereum people to get it merged Max Ken asks do you have a link to the pr for the transformation function function to decrease the length um I can find one for you very quickly yes there's some useful links um you can find it somewhere here the pull request and pull it off for you yeah yes here it is from Mr Gorman um although there also is some prior art in terms of you know if you for instance wanted to pick from one of ten items there's a cool project called derandomizer with an S the Glorious British spelling not the American spelling which provide some tooling around doing that and in the correct way to avoid modular bias and stuff so worth checking that I haven't linked it here but again you can find all manner of projects under the Durand organization on GitHub uh surab asks where can we find some use cases I joined that list I'm not sure what's been discussed um well that's up to you in the hackathon of course and some existing use cases we have seen we've got some people building games on top of the Iran so for instance for uh either randomizing item drops or um defining the variables of certain nfts for certain items and games that's been one example we're also working with a not-for-profit called social income who are providing Universal basic income in Sierra Leone and they're working to use dran to randomly select the people um who should receive that Universal basic income we also developed a sample fvm map called B raffle which is basically a bit of a raffle slash Lottery type app for drawing winners from a smart contract uh some other possible use cases or time knock encryption a very cool one which might be hard work in a hackathon but Med prevention uh minor extractable value if you could for instance uh time lock encrypt the member of a blockchain you could stop miners from either reordering or not mining transactions based on uh gains they think they might get from them other use cases generated drawing anything anything needs to be fair Lottery wise or um in the time lock World things like uh wallet recovery automated uh dead months which is uh auction applications I'm sure there are plenty more that you guys can think up that I haven't thought of and I I hope that's the case I'm excited to see what people build uh how can we get your slides that is a great question I will make them available through uh the hack FS people I'm not sure if there's a centralized channel for that I can also stick them on ipfs after this and post the uh the Sid somewhere for people to retrieve them um yes obviously if you have any further questions you can ping us on Twitter we're also on Blue Skies we're helping with it and there's a link to our slack workspace here as well lots of people talking about different uh use cases and cool things that they're building in there so feel free to get stuck in hey Patrick yeah for the sides if you want to post them in the Discord channel that might be another option as well that's the best idea actually and I will do that immediately after this talk awesome have any final questions from the chat well if that's the case thank you very much everyone thank you for listening I hope to see lots of cool applications built on the around on any questions find me ping me tag me Anderson oh there was uh oh there is last question can you iterate on the future file encryption uh well one cool iteration on time of encryption do people love to have is some kind of proof system on top of it right now there's no way to link if I say I'm including something now to prove that what's in there is actually what's been encrypted uh that's quite a research project and with a lot of work for hackathon but if somebody does it that could well be worth the prize but anyway thank you very much and happy hacking cheers thank you Patrick and thanks for everybody for attending good luck with the rest of the week hacking and we'll see you for the next Workshop in a little while cheers bye cheers bye 