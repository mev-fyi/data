hey everyone thanks for joining just gonna wait a couple seconds for the live stream to go up on youtube before we get started awesome hi happy monday or tuesday depending on where you are uh we have raha here from polygon doing a workshop on building a mini decentralized exchange on polygon questions go into the zoom chat and we'll answer them at the end of the workshop um so stay tuned and with that being said i'll pass the microphone hot awesome thank you um yeah thank you for attending my talk on building a mini decentralized exchange on polygon we're going to be talking about a little bit about why you know building on polygon is awesome as well as dissecting some code that'll help you to build sort of like an mvp or minimal viable product for a decentralized exchange first a little bit about me my name is rahat i'm a developer advocate over at polygon i've previously been a front-end engineer and solidity engineer and sort of like an indie hacker web 3 enthusiast i tweet a lot about like different product ideas i have that i never built so if you ever want ideas for things to build that i never will you can probably follow me on twitter for that and yeah these are just some places that you can find me cool so what is polygon polygon is the leading e platform for ethereum scaling and infrastructure development we provide different solutions for helping you build on top of ethereum that can be things like lte solutions like zk roll ups optimistic earlobes which are kind of in the works as well as hybrid chains side chains and things like that what you might be familiar with and what we're going to be talking about deploying on today is the proof of stake blockchain the polygon blockchain is our most popular solution reason being it's evm compatible what does that mean anything that you build for ethereum any smart contracts solidity code all of the tooling that exists in the ethereum ecosystem maps one to one right over to polygon so if you already know how to build on top of ethereum you already know how to build on.polygon our native token is matic so rather than eth you'll be doing transactions in matic it's much more accessible um one story that i like to share to folks is that like the first time that i tried to deploy a smart contract sometime last year it was like during the height of like a bunch of different nft projects like coming out and then it was very poorly written you know smart contract code with a bunch of stuff that was like unnecessary and unneeded and you know i deploying that would have cost me like a thousand bucks or something like that and um yeah um i have now been deploying a bunch of like toy contracts onto like polygon main net for like a fraction of a dollar uh which is awesome it's also sustainable we've been um doing a lot of work to make sure that um you know the polygonal blockchain is eco-friendly um so you can definitely check out check out more info on that so i've covered a little bit about this but why should you build on our proof of stake blockchain the speed 65 000 transactions per second you can still leverage ethereum like you can take do transactions um and then bridge your assets back to ethereum like if you were doing like an nft project or something like that and saving on costs you know 10 000 times lower cost per transaction than ethereum while still again leveraging the ethereum ecosystem first thing before we go into the code and everything i want to shout out austin griffith and scaffold.eth today's code breakdowns and the code um that i based this workshop on are from his minimum viable decks uh which is an awesome challenge on scaffold.eth on scaffolding i don't know if it's studied but um you can definitely check that out if you want to like dive in play around and like build your own version of this he's got like different um speed runs and things like that where you can go in and play around and again just kind of like shouting out the fact that even though it says scaffold eth everything's written in solidity and that all of that code can be easily deployed onto polygon as well so what does an mvp for a dex look like first off we need a liquidity pool right so this kind of is a ratio of how many tokens are available between two pairs for example if we had matic um as well as our hot coin which doesn't exist but might one day you know you never know um what you would need is like a certain amount of matic in your pool and a certain amount of the hot coin and let's say i wanted to get some hot coin i would have to put in some amount of medic um into that matic pool and once i put that manic into that pool i can then take some amount of a hot coin that is equal to or sort of equal to that when we'll i'll cover why it's sort of equal to in a bit on um when we dive into the code uh but like that'll determine how much for a hot coin i get back and that's part of this like determining the price of like the token swap which is in the code in just a second but we want to be able we want people to actually you know swap matic and tokens so i can put in some matic get some tokens put in some tokens get some medic and the thing that i mentioned before of like you know why you might not get something exactly equal is this concept called slippage what is slippage so a lower supply of a certain um amount of liquidity for your tokens causes it to be more scarce and can raise the price of that token um so let's say i had 10 matic and 10 raha coin inside of a pool right if i wanted to buy sombra hot coin using some matic i would put some matic into the pool and i'd get some some hot coin back right but um the the formula that we're going to be looking at in this code for how to determine the price um is based on something that uniswap uses um called constant product and what we need to do is actually um to determine the price we multiply the amount of um each of our assets and the result of that multiplication is this constant sort of value that we always have to like keep for our ratio so in order to make sure that the two values multiply to that final product um you might not necessarily even if i like want put in one matic i might not get one raha coin back i might get like point nine something um or hot coin back and uh we'll take a look at that in the code in just a second but first up you need to create a token right so this is very like bare bones um erc20 token contract this is all you need to create a token if you really wanted to there's probably other things you wanted you would want to add on top of it this was taken also from the scaffold.edu challenge that i mentioned but it's really just importing opens up lynn's erc20 contract initiating that and just taking a thousand coins and sending it to whoever created this um contract you can of course adjust that amount to whatever you need um you can send it to other people add more functionality etc etc and then this is like the starting code for our decks um this is importing uh what's called the ierc20 so you might be wondering what's the difference between erc20 ie or c20 so the erc20 is like the actual coin itself it uses all of like the um definitions and functionality that the ir ierc20 holds so the ierc20 is like the interface it contains all of the information for you know how to transfer how to um you know view ownership and things like that and erc20 basically um builds on top of that and gives you an actual coin the reason we're using ierc20 in our decks is because we don't necessarily need to mint or create new tokens but we want the functionality of like being able to transfer and send tokens like other people cool so the first thing we need to do is add some liquidity to our contract so we need somatic and we need the token that we're training for and that's going to happen inside of this function which is an init function for initializing our liquidity so going through this line by line first thing i'm doing is essentially creating a total liquidity variable just like keeping track of how much liquidity is in here as well as a mapping that will associate the address of some person probably whoever's calling this initial initializing function and just keeping track of how much you know liquidity they've added so this um function here and it is going to take an um an integer called tokens just be like the number of tokens that we want to put in um this this one function takes care of both adding you know medic as well as adding our tokens how does it do that first off is that public payable that payable keyword is key um for um solidity uh solidity is awesome in the fact that payments um and just like transferring money and all that stuff is baked in natively and this payable function allows this function to be allows this the payable keyword sorry allows this function to be able to say okay i can take some somatic or eth if you're doing this on on the eth main net and add it to this to my contract right um and that's automatically that ability is automatically there just with that payable keyword so next up um i'm i have this require statement um that says total liquidity should equal zero uh because maybe i don't want to add any more you know liquidity if there's already so um some other stuff going on um and basically sorry i lost my train of thought okay so essentially um we're just checking if since this is an initializing function we're just making sure that there's no liquidity already in there and then we'll continue total liquidity is going to be updated to be the current balance and essentially we're going to take the token that the amount of the the amount of tokens and we're gonna be tr uh the token sorry i lost my train of thought again uh we're gonna take the uh token transfer it from the user um and send it over to our contract um so again that this one function takes care of both receiving matic um as well as receiving the token uh which could be balloons for hot coin whatever dogecoin you want to put in here next up is swapping uh which is going to be done using that constant product um formula that i mentioned uh determining the price so this is like the most important pro yeah definitely the most important part of a dex because you need to make sure the pricing of your assets are correct like i mentioned before this is built using the way the the fee structure that uniswap um uses so unisop has um a point three percent um fee uh attached to each of their um transactions so that's why you see these numbers like one thousand and nine nine seven um so 909 is 997 over 1000 is about 0.3 percent um because of how um solidity does not like decimal numbers uh we have to do this in like a weird way where you have 997 out of a thousand to actually get that proper percentage um but essentially um what we're doing is saying that there's gonna be a three percent fee tacked on to this um to to this price um that's going to be put into the reserves of the contract what can you do with this contract i mean those fees can be you know for you know actually using the designer centralized exchange maybe you want to use those fees to add some incentives you know later on for some of your users who are adding liquidity to your contract etc um but the main thing to kind of remember here is that like this the the constant product side of things um introduces the the little um whoops what happened there let's go back there we are okay the constant product formula essentially makes it so that in addition to these fees i'm going to get a little bit less um you know hot coin than i would have gotten so if i put in like a thousand um you know matic normally i would expect 997 um tokens back i might get something closer to 996 because of that slippage because that console product is making sure that ratio is always intact so now that we kind of know how to determine that price make sure that we're taking our fees make sure that like the constant product side of things are taken into account um for our liquidity now we can actually add in the different ways of swapping first thing is matic to token swap i have somatic i want some balloons i want some hot coin whatever back uh how do we do that once again it's a payable function we're going to be you know introducing some bit of matic into this and we have this thing called token reserve which is going to get the token balance um address one thing that might be confusing that i may not have talked on this token variable this token variable was determined if you see here on this ierc20 token and then in the constructor we're taking the iar we're taking the we're initializing the token by taking the token address of our deployed contract of the token which was done here so that allows us to like actually get the balance of the token make transfers of it etc apologies for not explaining that before so matic to token swap again we're just getting the balance of the tokens uh we're looking at um you know what the price is adding in like the message.value um getting the and so we're doing this thing here where we're subtracting uh the balance of the amount that measures that value because um you'll have some amount of matic in reserves and then the payable modifier essentially gives you some more matic which will update that so we want to make sure that this is done on like the initial amount that you had which is why we're doing that subtraction and then lastly we're just essentially transferring uh the tokens once we have the correct price for them and the token thematic swap works very similarly just kind of the opposite way rather than you know sending the tokens um this no longer needs to be payable we're just transferring uh the token amount and then um sending some amount of um matic back to the person based on how the price is determined so going back to slippage because that's super confusing uh concept it took me a while to wrap my wrap my head around it i used this um example a little bit before but like diving into it a little bit once again so if we add 1000 matic and then we base like that ooh not three percent point three percent sorry uh we should get back 997 but we actually get 996 due to slippage so whatever amount of you know funds you might expect you'll get a slightly less amount just to keep that ratio up so like the more um you know of these assets that you try to buy so like if i were if i wanted to buy like ten thousand twenty thousand whatever slippage is going to be higher the more of this token that i want because i'm making a huge dent in the reserves and um in order to make sure that you know the liquidity kind of like stays balanced um that slippage is kind of like what goes in and happens this contract is what's known as like an automatic automated market maker the constant product formula that determines the price will keep the ratio of the liquidity swaps intact and um again this is um the same sort of formula that um you know popular exchanges like unit swap will use uh to make sure that you know liquidity stays intact how can we kind of like take this example and build beyond it um i love this example because like it it takes a very very very complex um bit of uh like project like creating a decentralized exchange seems pretty pretty easy like oh you just like swap some tokens and you know determine some price but all these concepts of like slippage and all that are uh pretty hard to wrap your head around but you know you can take this example and like start building more stuff like you know on top of it you know add more decentralization by allowing more deposits i think in the challenge actually for um for the scaffold.if you can go into that and like create like a deposit function where you like uh rather than just doing like that initial like liquidity initialization you add more um you know more matic more other token uh whatever it might be um next thing is like you know incentivizing deposits with rewards like you'll see in like a lot of decentralized exchanges that uh being someone who you know is a liquidity provider like you're you're giving some liquidity into um this exchange will like yield you some you know amount of rewards you know this is you know you have the basis for doing that um from like even a basic contract like this um and then you know part of part of this contract is like we're like mapping the different you know addresses to like the amount of liquidity that they're providing maybe you can use that to you know build out some functionality where you're providing some rewards for those people who are giving you that liquidity because without liquidity you're not going to be able to run your decks for too long it's also again just like mentioning the slippage stuff again is just like the reason that a lot of people prefer [Music] um you know that a a contract has you know a large amount of liquidity is to like minimize that slippage as much as possible more tokens more amount of liquidity you have in there less slippage better user experience for everyone kind of involved and going beyond this like creating more robust solution with multiple token pairs um this code really kind of focuses on you know one single pair uh you know it could be matic versus um you know hot coin or whatever eth versus um rakoin or whatever and um you can take this and like build much more pairs uh for having like different uh for having like like an actual like almost like a unislap type of exchange where you can add in you know a bunch of different tokens and swap it for um you know whatever base token you would want you know rather than doing like the base token being like matic maybe you have multiple types of erc20 tokens that you want to create pairs for that's another thing you can do to build on top of this as well cool so again thank you for tuning in um uh once again my name is rohat developer advocate over at polygon these are just some places you can reach out to me you know always available i'll be available on the discord as well if you have questions um just tag me to make sure that i um that i see the message and would love to help you all kind of like dive in and see what you build during this hackathon and i will open it up now to questions uh see that we have one is payable modifier yeah so thank you uh i'm gonna find for answering that it is a modifier um yeah that payable modifier gives you super powers to be able to actually you know receive uh matic or eth depending on what network that you're building on top of cool any other questions if not then thank you all for you know joining in uh really appreciate you tuning in awesome thank you raha um super useful i'm sure everyone enjoyed it uh as raha said he can be available on discord in the sponsored polygon channel um just make sure you tag him so he sees the message um and yeah thank you so much raha for taking the time to do this workshop for our hack money hackers and for the rest of you we do have some work more workshops um happening for the rest of today so i hope to see all your faces there as well um i think that you have a question in the chat asking if you can send the slides uh yeah i'll drop that into the discord awesome well thank you so much everyone and have a great rest of your day evening morning wherever you are 