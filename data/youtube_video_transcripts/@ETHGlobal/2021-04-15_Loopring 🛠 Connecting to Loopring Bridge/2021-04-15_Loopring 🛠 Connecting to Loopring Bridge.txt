welcome everyone to the connecting to loop ring bridge workshop joining us today is brett um and yeah i'm gonna hand it over to him to give a quick introduction to himself and kick the session off okay hey everybody i'm breift i work at loopring uh i'm working on the alpha protocol side so i helped create like the zika roll up that we are running now on mainnet and uh yeah so we are a layer two that specifically or two and we have been working on some cool features uh one that i'll be mainly talking about the loopring bridge and like the different design patterns uh which which which are utilized by the bridge uh and also uh one of the other challenges is of course also the uh the block explorer so we will have a sub graph uh which is now still being developed but it's almost ready and it's ready enough so people can actually already use it and start building a ui for a block explorer so yeah let's start with the presentation about the loop ring bridge uh let me share my screen all right it's okay the loop ring as well as looping uh first uh the basic stuff out of the way is lubricant ziggy roll up so we can do uh only a couple of things so we can do transfers we can do order book trading and we can also do emm trading which is already uh quite a lot so most people um those are basic stuff that most people want and so those are already available completely only or two but sometimes people also want to do other stuff of course so there's lots of yeah maybe you just want to present full screen present full screen uh present full screen okay [Music] present better okay uh so yeah there's lots of stuff to do on ethereum and if you are on layer two uh then yeah uh you probably also want to do some of those things uh and the good thing is that most layered one applications actually expose functionality by using a token so if you want to deposit to a vault and then in most cases you actually get another token in return so it's basically it can be done with a trait on layer two um so uh yeah so we can actually use the basic building stuff the basic blocks that we have on layer two to actually do lots of stuff that are still on layer one without actually having to migrate everything over to layer two and of course yeah there are will be multiple layer twos that will be going live now and in the near future and people will want to move from and to loop ring uh to and from those those uh other l2s so otherwise people have to like if they want to move from new print to an l2 they would first have to withdraw and then do another deposit to the other l2 and because the gas costs are high even that could be quite expensive just doing that for each user uh independently so um if if you have a system where people can actually do lots of stuff together so we can actually uh do like one single l1 operation um then yeah the guest savings are high uh which is and then this this design is actually called like uh d5 pooling in some cases uh of a mass migration uh so those are the terms that are often used for uh describing these features okay so the the good thing is is that we are a zika roll up and the zika roll up is actually very well fit for doing these kinds of l1 interactions uh because we use a validity proofs so unlike some other l2s we actually have fast withdrawal times because once a block is on chain and the block is validated with the validity proof then we are sure that everything is valid and we can actually change l1 state immediately so we don't have to wait on any fraud cruiser or something like that uh before we can actually change l1 state uh we can do it immediately and if the validity proof is submitted next to the block then we can do everything at once so we can do l2 block validation and at the same time we can do l1 transactions um so that just makes the design a lot lots of lots easier because otherwise there's like the extra delay and there can actually also be extra reverts so if a reverb is possible with a fraud proof then yeah all the l1 interactions that were done need to be reverted as well which is kind of like very hard to do it's also very capital efficient uh because um yeah we there is no lock up there this doesn't need to be any kind of uh liquidity providers which which can actually do these um we could actually provide funds quickly so with optimistic roll-ups uh and all and even our zika robs we have like these extra liquidity providers which can make it even faster uh but yeah you need to have those liquidity providers uh to to facilitate that but with zika roll-ups those aren't really that important because the the basic um the basic uh flow is actually good enough uh in most cases uh especially if there are a lot of transactions so uh in zika rollover you mostly want to wait until you have enough well quite enough transactions to actually fill a block so it's yeah cost effective to submit the block unchanged on chain to do do everything uh but if there are lots of transactions we can actually submit lots of blocks very quickly and the delay the delay is is very short but uh the one caveat is is that if we do these l1 transactions next to the l2 transactions then yeah if we modify l2 state in some way which depends on how the l1 interaction finishes so if you want to swap let's say one each for one bitcoin and we really want that to happen on layer two uh then like yeah because there is a delay between doing stuff on layer two and layer one there could be a change that like the exchange rate already changed once we actually submit the block on layer one so if the exchange rate like let's say one eighth is now two bitcoin then that's a problem because yeah if we did the trade on layer two for one bitcoin for one eat then yeah the the extra and the difference between the exchange rates needs to come from somewhere and if we would just like we resubmit the block with the updated exchange rate then we would have to revert state and all that stuff so it's just much simpler if you can just depend on the l1 state to be deterministic or if it's not deterministic use some design which yeah makes it more than makes it deterministic and these kind of designs these will uh i will talk about these now so the first naive solutions to to get like these these defy tokens like fault tokens or other tokens uh no matter what like uh on there too is is to use is to have liquidity providers uh so if you want to put some money in urine in a urine vault like you want to put some heath in the urine vault uh you will get y eth back uh and if there is some liquidity provider which uh just creates all those orders on there too so it supervised later to other directly then this works so people can just trade against this liquidity provider and get their white tokens back so it's it's the same thing as just depositing on layer one directly of course the the main downside of that is is that it's quite capital limited because this liquidity provider needs to have enough funds uh to actually facilitate all these trades and it's also quite capital and efficient because yeah this liquidity right needs to have these funds uh on hand and like do the trades like do the l1 interactions as needed as they are uh as users want to trade on l2 so if you have enough money it's it's actually quite a good system especially on zk roll up because you can move funds around quite quickly but it's still not that good because yeah you really don't want to count too much on liquidity providers if you don't need them so the the first way to solve that is like the what we call the single phase converter is to actually do the traits on layer two with uh and in our case we can actually do flash minting uh so the good thing on layer two is that we can basically create tokens out of thin air on layer two um no matter what so we don't even have to use l1 flash loans uh on layer 1 or we don't even have yeah we don't even need to have access to these tokens at all so these tokens can may not even exist on layer 1 or anywhere we can just increase the balance on layer two and as long as we are able to repay that balance then everything works out fine um so that's what we have also implemented on our zika roll up we uh we can flash mint whatever amount of tokens on layer 2 that we want and then yeah just a basic constraint that these have to be paid back so let's say that we want to facilitate facilitate lots of trades between a token and the white token from a urine vault for example then this there is some party which will likely be the block producer which just bundles all of these transactions together so without any capital needed he can just do all these traits by flash minting the necessary amount of white tokens then collect all the tokens that these white tokens need and so these can be like hundreds or thousands of just simple l2 trades then because the the the uh the block producer operator has collected all these funds now these funds can be withdrawn then the actual deposits to the l1 that can be done so in this case yearn uh these these like let's let's say there's a hundred people that want to put one eath in the in the urine vault so there's hundreds of 100 traits between one each and one why eath uh this is the the operator collected one each er in this case withdraws this 100 each does the actual conversion to the in the urine vault so one 100 eat is swapped against let's just say to keep sitting simple 100 why eat and then because 100 why eat was first minted to facilitate all these trades the 100 why it can now be used to repay the initial flashman to make the amount of flash amount flash minted zero so that's of course the the important constraint for the the flash meeting everything that what that was flash minted can be easily repaid uh like this so this this works for any kind of token so if there's just one token conversion to one one other token conversion um this system works but there is a problem if the exchange rate isn't that deterministic so it works well for something that's that has a fixed exchange rate so um something like eth uh a swap from east to wrapped eath of course is a perfect example because that will always work and the exchange rate is fixed uh something like uh ave is taking a i think is also of always like one one ave token or one state of the token so there are some cases where this works perfectly and it's very efficient but if the exchange rate can actually change on l1 all the time then there is a problem because we flash mint some amount of tokens we we withdraw the the the main token that's used for the swap and then this exchange rate is done on l1 but we don't know how much tokens we actually get in return for the tokens that we have withdrawn it can be like exactly the amount that we expected it can be more than we expected which is a lawful fine it can also be less than the amount of tokens that we expect and then we will have a problem with repaying the amount of tokens that we flash minted so yeah so either this fails and we have to revert all kinds of stuff so the block needs to be reverted and we have to recreate the block regenerate the zero knowledge proof and all that all that's kind of stuff um so we don't want to do that so uh if there's too much yeah if the the amount of tokens is is not enough then the converters will also have some extra funds laying around here to help pay repay the flash meeting but of course that's also not uh ideal uh so the the use case for this is is limited if if we don't fully control this this l1 depth so if you fully control the l1 depth there's also no problem because if we do these traits on l2 and we are the only party then actually can change the exchange rate on l1 then it's all it's still fully deterministic so in that case there's also no problem so it can work in quite a lot of cases but in some cases uh like especially with existing land ups on l1 in quite a few cases there there are potential problems so some some extra improvements are needed to make it more uh deterministic um yeah maybe maybe i'll pause a little bit to see if there are any questions if not there is a question in the chat okay okay what sort of ziggy roll up tech are you guys using for example zk sync is using zika snarks and plunks how is your roll-up process different so we use uh well it's quite similar now to ziki sync in that we are support um we use zika snarks zika sync uses splunk we still use uh grot16 for the proving system but yeah otherwise they are quite quite similar the the main benefits of plunks is that they only use need a universal trusted setup and we use squad 16 which still needs a circuit specific trusted setup okay okay let's continue with the double phase connect converter which which solves the deterministic part of the exchange so it may look a little bit more difficult but it's still quite easy processes just doing things twice instead of a single time so instead of doing the swap immediately from from token from the yeah token to white token uh we do the conversion in two steps uh and to do that we we actually can add like some vault specific logic to the converter so the first thing we do is actually swap the token for the the converter token which is still which is just a one-to-one uh exchange ratio so uh if you want to put one eth in urine then you will get one v eth for this converter here um so and just like if it and and this token just represents your share in the conversion process so if you just if there are 100 people that want to put one eath in this in the urine then yeah if you put one e then and there are 100 people then you should have one percent of the share in this vault uh which is still one eighth at a time um so that's that's what happens in the in the first phase so you just do one to one swap for this this vault token and then there's which is of course like a fully deterministic the exchange rate is always one to one and that's also the only thing the converter can do so nobody else can actually actually access this this converter and then we do the the actual l1 interaction so we go from the token that all these people deposited we do one one interactions to do the swap and then we get the white token back and this can be any number so if there's 100 eth then the amount of white tokens we got might be like 95 why if or might be 105 why eat but it doesn't matter it just uh yeah it doesn't matter of course for the exchange rate but it doesn't matter for the system because every user on l2 still has their shared tokens which are exactly the amount of tokens that they put in so if if well if you put in one percent of all the eath then you will have one percent of all the y eth that this converter had converted so so by doing that all the operations on l2 are fully deterministic uh in the first phase and the second phase so because this is like uh this is a one to one ratio so all the trades here uh on the left side will be uh simple so one to one swap and then all the directions in the second block that will be created after this l1 interactions was done will also be deterministic because we will create this block after the actual l1 interaction has been done so in the second part we just exchanged the shared tokens against the actual tokens that people want and then withdraw again use flash minting to aggregate all this all these trades on the r2 and give the people the actual token they want so instead compared to the the first the single phase converter this this conversion needs two phases um and because people always have access to their share token on l2 even if we wouldn't submit the second block they can still withdraw their share token to l1 and actually get their white token back themselves on layer 2 and that could happen if like the operator stops doing things or doesn't actually want to do the second step like the distribution step if somebody like the operator doesn't want to do that anymore for whatever reason then people are still sure that they can get access back to their money okay so let's go to the third uh design and this is the design that's actually will be used for the the workshop and that's the the looping bridge uh so compared to the the the converters the conversions are limited in a way in that they can only do token swaps uh represents in some kind also it's always the case that one token is exchanged for another token which is often the case but sometimes of course it's not the case let's say you want to move from one roll up like you want to move from loop ring to another roll up then you don't swap tokens you actually move the tokens from one place to the other and to do that people can use the bridge design so instead of doing l2 trades on altitudes they actually do a simple l2 transfer to the bridge and by doing this l2 transfer they don't just do the l2 transfer immediately like like any other kind of altitude transfer so they do like a conditional transfer to the bridge account uh and only when it's actually processed by the bridge the the transfer will be valid uh and the bridge will use those l2 transfers to actually do stuff on layer one uh so all these i'll do all the users that want to interact with the bridge first we aggregate all of them so all these transfers are accumulated in one account and then we do single withdrawals for each distinct account so if people want to interact with the urine if people want to interact with uni swap the people want to move to roll up it doesn't matter all the withdrawals are batched together in one withdrawal per token uh which means it's very efficient and then once they are in the bridge then we actually do the necessary l1 operations so um these these connectors are just simple contracts which which do the conversion from like the aggregations to the l1 uh interaction so uh if there's like 100 people that want to interact with the urine connector then this urine connector will just get as input a list of those 100 users with like address uh the token they deposited and the amount this connector can do whatever is needed on the one so probably just run over the list do the l1 interaction one time for all those users and then we deposit back to the layers the users on layer two and that can be done for nvl one dap which has the necessary connector and this connector is very very easy um so yeah it's just very efficient because uh all these urine all these connectors actually work on the same bridge contract and the bridge contract contains all the funds so once the urine connector contact is called which will mostly be done with a delegate call uh so there's delicate calls here to the different connectors so the these can just do whatever logic is needed without having to move funds around a lot so once they are withdrawn the connector can be executed with a delegate call the necessary funds are directly available in this contract and once the swap is done on this contract the necessary funds will already be in the bridge and they can be batch deposited back to the users on layer two which is also just done with with simple transfer so all the actual one token transfers are batched in a batch deposit and then all the different users get their money back on layer 2 with simple transfers which are very cheap so here's like a different like a little bit of a different batch deposit line it's just that these these are like uh interactions that originate from layer two so these like layer two people want to interact with layer one and they can you do something like uh which we call like bridge calls so they want to actually they say like i want to interact with the urine connector okay we will just aggregate them all and do those but there's also of course the case where people from other zika roll-ups or other l2s want to join new print and for that the bridge contract has just uh a simple function call that's called batch deposit uh which takes like the just a list of of all the deposits that will be handled in the same way like this deposit is done so if there's 100 each for 100 users then first the 100 each will be done by a single deposit to the loop to the to the exchange contract to the to the zika roll-up and then all those other transfers will be done on layer 2 very cheaply using the r2 transfers and so the cost savings here are that every normal deposits that the user does is like a full layer 1 transfer so it's quite expensive and by using the batch deposits we we only do the costs once for all these users together and then just cheaper output transfers okay let's see no answers in the chat let's continue okay not that much time anymore uh so yeah the converters are very cheap uh mostly so they only need like one or two l2 trades per user and l1 overhead is always the same because all the aggregation is done on l2 and so not much is left on left to do on layer one and next to just the main l1 interactions that's needed for the bridge account mostly the same also like one or two l2 transfers per user uh also this fixed l1 overhead to do the actual l1 operation but there's also some extra l1 overhead because some extra aggregation is needed on the bridge contract so we have to run over all these different bridge interactions and then yeah pull them around to the necessary contracts which makes it a little bit more expensive but also much more flexible because yeah the bridge can do more stuff than the converters which which are mainly like token swap batching um the fees i think i'll skip that but the fees are like done in a way that's that makes sense i'll just skip this one because there's not enough time uh okay the bridge interface is uh very easy so uh to do a batch deposit to the bridge so people want to move funds from another layer two or even a centralized exchange to loop ring they can just call this batch deposit contract which will do the all these deposits just passed in with the list uh very as as efficient as possible so if there's like one token that's need to be deposited for this list uh one deposits one actual deposit will be done and all the other deposits will be done with the layer two trend uh transfers but there if there are multiple tokens uh in this list then yeah uh multiple deposits will also be built but the least minimum amount as necessary for the the bridge conductors there's also just two uh calls and just this this main main one basically the other one is just for the for like the the fee system uh which i'll drop now but the process calls is just like okay uh all these bridge calls were collected in the bridge and this this function just gets a nice nicely formatted list uh sorted on the group and uh and the group is just like an uh a kind of l1 interaction and then all the all the token transfers that were done on layer two so um this is just what you'd call uh which is what you'd expect so the owner the token amount some extra user data so some some extra custom logic can be done per user in in the connector uh and some some some less important data so i'll first a little bit of time so i'll show [Music] a sample first uh of such a connector [Music] so this is this is like how you would create like a connection to a urine vault a uni swap connector or yeah some kind of token swap connector is you just implement the process calls you get the groups the group is like this is like a a swap example like it mostly follows like a uni swap uh one layer one depth so the the group is just the the emm that um that the user wants to interact with so if it's eat against lrc then this would be the group and all the users that want to do this rc swap are aggregated together in this in this in this group so the first thing we do is run over all the groups we decode which which yeah mempool that we want to interact with um and then run over all the all over the transfers that were done by the users we check what the minimum amount is for the total amount like uh we we check what the slippage is basically so we we have like this total combined which is transferred by users but every user actually has a custom slippage limit so we check here if this slippage limit is is reached if it's set so if the amount that's that the amount that is received by the user is less than expected then we actually won't do the trade for that user uh so we just skip it and we return the user's initial funds uh instead of the swap token so that's done here so we check if it's valid if it's balance is okay then we actually do the swap here with with the the funds from users that that achieved the minimum slippage and then we run over all the transfers uh so if the if the swap was successful we transferred the new token out and with the new amount that was uh exchanged but if it's not valid we just return the amount that the user transfers to the bridge uh so this is what i was also talking about like the deterministic part so this this case can handle both cases uh so this this uh the swap uh the swapping here with the with unisop or whatever can actually fail and user tokens will be returned as if so uh we don't we don't depend on the swap to actually function correctly so it can fail uh and even if it doesn't fail we still have this this fallback method to with the slippage so uh yeah lots of flexibility there and not much time anymore but and then all these resulting transfers are just also returned to the bridge so most of the implementation details are just handled by the bridge and you get a nicely formatted input so the logic can be quite easy there's also like a migration example which is basically the same thing but yeah because it's a migration sample you don't actually return any transfers because um yeah funds are moved out of the exchange and none are returned so that's that's the main difference so let's quickly end this uh workshop so okay the the main channel that's where we have two challenges the first is the block explorer front end for uh the blueprint subgraph so on the discord i shared the link with the subgraph so it's actually failing because there's some some some problem with uh yeah there's a bulk and subgraph but it doesn't matter because it only fails on on on a on a block that's uh quite yeah there's enough blocks that are processed so there's enough state available to to actually start building uh the front end uh and the subgraph will be updated uh once once things are fixed but it's ready to build on uh whenever you need and the second is of course like the use the loopering bridge to interact with another roll up or one hour yeah another one that um so we we don't really want to uh say to like give too many leds so uh like some yes you can be creative uh so if you think well another one that is very well fit for this kind of system then yeah just just let us know what you are planning to do and yeah we we we like creativity here uh so of course the more basic ones would be like doing uh a connector for uni swap or doing a collector for urine vaults or interacting like doing a mass migration for something like hermes uh which has support for that uh yeah lots lots of possibilities there um yeah just don't just don't start doing something that that may not work or or we are not that interested in it uh we have five thousand dollars in the prices uh and this may mostly be like creativity and like how how well the how well the contracts or the web ui is is developed great thanks so much brick um that was a really great session and if anybody has questions don't hesitate to reach out in the sponsor loopering channel yeah and thanks everybody for joining us today and yeah once again thanks beth 