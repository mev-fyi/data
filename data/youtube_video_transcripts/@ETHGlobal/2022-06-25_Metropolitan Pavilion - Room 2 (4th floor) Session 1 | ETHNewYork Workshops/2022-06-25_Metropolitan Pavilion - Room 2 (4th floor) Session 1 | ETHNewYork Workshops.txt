um yeah i think we start the thing is recorded but i'm also around at the booth for questions later so i'm hi my name is simon i'm a solutions engineer at the company etch a node that's a core death working on the graph protocol and the graph protocol is also a sponsor of this hackathon we will look at the prices later but in this workshop i quickly show you how to build and publish a customized and decentralized nft sub graph so um yeah eva baylin the director of the graph foundation once tweeted and said like yeah if you build the app that for the community but you using centralized components just for your vcs or whatever then you're not really building a dap you're just building an app using web3 stuff right um so but the problem is uh really having a decentralized stack is quite quite uh challenging so um but i i walked you through through these steps so the data storage of an nft contract can be roughly be seen as just you know a google spreadsheet where you have like owners and then ids and metadata um and that's kind of the state of the blockchain so you can always just create a blockchain say who owns which let's say the the first punk but um it's very hard to see who owned that punk before um you can do that by by digging through the blockchain but it's not easy so like that's what the nft people call the provenance so like who owned it before um yeah and the blockchain in basically works like this so you send a transaction to the blockchain and then with that transaction you change the state of the blockchain and then eventually and then immediately you can read the current state but you cannot really read what's what is going on so that's what you would like to have is kind of this um time travel feature that we that we know from mac os so that you actually have like the same data but you can actually go back in time and see like how was it before and um yeah this is actually what the grub the graph enables um i i said like that this is the problem with the with the depth in general so like initially the depths were kind of thinking about yeah we can have like a user interface that is just html css and javascript it's deployed to ipfs so it's um it's already a permissionless storage and then it directly interacts with the blockchain so everybody runs their own blockchain node on their computer in a fully decentralized manner um time time was telling like this this is not the case and um like the biggest problem is actually like the blockchain is right optimized and incentivized so by sending transactions to the blockchain you pay gas and that gas the miners take and so they can kind of are incentivized to run that stuff but um if you want to just read data from the blockchain then you then you start to kind of talk to the miners and say or to the to the nodes and say like hey can i can i know this data and there is no incentivization mechanism to do so and that's the problem so epns uses it um so it's quite heavily used and there were like more than one billion queries per day on that host service so um that's that's quite a lot and and we are currently in the process of migrating all these queries to the decentralized network so whoever has a sub graph on the hosted service and uses it currently feel free to come to me i'm helping you to migrate those subgraphs over to the decentralized network i also have t-shirts and pull-ups for those who do so i'm yeah grab me as i said it's a decentralized indexing protocol um yeah animated um there are like more than 160 actually indexes world it's permissionless so like so these indexes they are kind of independent everybody can join um and through that you have like this this redundancy across the globe that your data is always accessible if one indexer goes down another one is there to serve your queries um also because there are across the globe wherever your users are when they query the graph then they will receive a response from index next to them or like form index that can give a quick quick result um the queries are kind of they are fast cheap and reliable um what what changes might be a little bit new is like now you pay for the queries so that's why it's now the queries are incentive so the you pay a small amount for the queries it's not that much um but it kind of shifts this power structure um towards the users who you're only in control of stuff when you somehow pay for it right otherwise you have kind of data miners and the ads and stuff that try to make money out of it um yeah and so that's kind of the vision we're going through this global open decentralized api and i would invite you to join and build on it so this enables us to build truly decentralized apps um yeah so this is uh the rough overview kind of already are there's any questions about the graph in on this level before we dive into the tech no otherwise we are around we have a booth come and uh find us so what is a sub graph so subgroup is kind of this this piece that um is at the core of the graph you can think of it like that as we saw before the the blockchain is kind of actually a mess you have like all these transactions for all these different protocols more or less on top of each other now if you want to make sense out of it and see like what actually happened with let's say sora then you need to go through all these transactions and take the ones from sora out and pull them together to make sense out of it right so that's what happens and that's why it's so slow um but what would be nice is actually if you have like separated databases per protocol which store that data for that protocols in a way that you can easily query it and that's what actually a sub graph is so a subgraph is a definition of like how do i want to have like my data database schema and how do i want to put data that we see from the blockchain into that schema and then it generates you automatically interface to create so in the end the life cycle of a query or the whole thing works a little bit like this on the top we have the dap we know that kind of just the frontend html css it sends transactions to the smart contracts or to the blockchain node which the the the the smart contracts usually they emit events so the graph node in the middle it listens to those events on the blockchain and when these events happen it they go through this mapping which is a web assembly module and the mapping makes sense out of these events and stores it into the database that we see on the bottom right and then on the other hand side like if the depth wants to send a query on the left that it goes to this graphql api that we saw before a very nice expressive query language to get that data out of the graph node so this is roughly the system architecture so because there was this nft nyc and because it's a cool example anyways um let's see how our nft subgraph would look like and we can also kind of build one together quickly so like at the nutshell the erc 721 standard is just uh you know you have to transfer events that you see like which token moved from who to whom you have like this balance off function where you can check the balance of a certain address you can check the owner and um yeah you have this transfer function that you can actually uh trigger transfers so it's it's basically super simple um so we can look at this when you get into sub graph development then here are some tips and tricks so i um yeah you should emit when you write the date when you write the smart contracts you should be a little bit verbals with the events don't try to save gas there because it's you shoot you later in the food in kind of making sense again out of your contract um then with the subgraph development there are these eve calls so that's let's try to not call back let's try to have all the data that you need in the subgraph in the in in the events so that can make the subgraphs indexing much much faster you can create entities for important objects and concepts we'll look that later more in practice you can store aggregation data on those entities like counts and stuff and link those entities together so you can have more meaningful queries and also more explorational queries and then there is kind of the standards nft standards of vtwtf it's a good resource um but yeah you can also uh ask me so then you can start to think about like okay what kind of questions do i wanna ask uh like what questions do i wanna have answers through with my subgroups so like for the nfts kind of how many nfts are there in total how many nfts have this trade x who owns which nft um what's the provenance who owned it before is it available when we have on-chain markets what is the historic price what's the current asking price and so on so forth um so you you start to think about that and then you can come up with a schema so this is a rough schema how i would like a model at nft so you have a contract it's a collection it has accounts about everything and it links to the owners and you have the accounts which are the owners uh you see the holdings which will other will also link to the nfts where you have the token id the metadata uri um then you have like the events you would just store the events also like to transfer the means bid asks and sales if you have them uh block number block cache you want to have per event metadata and trades if available so let's do this so first you install the dependencies i created actually a small github repo that's here i will also tweet that later so that's here on my github that you actually can follow the steps it's also linked to this slide so basically you install this graph cli globally to get started and then you can be gonna look at the hashmasks contract so you can go to this um to either scan you see that contract um so that's that's the hash most so we know the contract address but also what's interesting is kind of this start block right because we do not want to start to index the blockchain from from genesis if we are just interested in a contract that was deployed at a certain amount of time a certain point in time and now this one this is actually the biggest time saver especially for the hackathon projects if you want to quickly start a sub graph from an existing smart contract on ether scan or on ethereum or any other chain that is supported not all of them are supported with this quick start you can also do this with if you can provide the api um it's a little bit more complex but we want to move fast here so what i do is like i just run this so what it does like it says okay graph initialize me a new subgraph i want to deploy to the subgraph studio which helps me to deploy to the decentralized graph network then i kind of say like this is the contract address and this is the important one index event so i want to have like a scaffold which automatically indexes the events and then i want to have like that's the contract name is steve hashmask which network i'm indexing and yeah and then also the directory so let's fire this i did it before now you need just me to trust me that this works because before it took very long to yarn install everything so i was like maybe uh we can skip that so that that will be the outcome um so you have this thing here let's make it a bit bigger is it big enough yeah so by looking at um uh it is basically it's a javascript-ish environment so usually you can start to look at with package.json so we see here um we have some we have some dependencies and some some scripts prettified so that's already good then the next thing that i look at is kind of the subgraph yaml here is defined like how the subgraph um yeah kind of it keeps it all together it says like okay here are the data sources you can have one or many we see again like it's ethereal mainnet it's this is the address this is the api these are the entities we go later to the entities and then we also have the event handler so this um esc 721 they emit these events like approval approval for all name change this is special for the hash marks because you can name them ownership transfer this also because ownable contract and also the transfer event so this is here and then you say like okay and i want to put i want to run this in this mapping.ts but first we look quickly at the schema this is auto generated so like for every event um it automatically creates the entity so despite that this is kind of named schema.graphql what this actually is is kind of a database schema it's not the exact graphql schema that will come out of it but we'll see that later so like everything has kind of id and more or less just whatever it was about everything this event kind of stored and then also we have in source mappings we also have the boilerplate stuff other we have these all these these handlers um actually the most interesting one is the handle transfer so every time a transfer happens on the ethereum blockchain um this handler is triggered and what it does is kind of it creates a new transfer entity it creates this id for it which is just the hat the transaction hash and the log index so you so you have kind of canonical identification of that um event and then you add those things to the entity and then you just save it i mean it's it's super simple um right so you can check if everything works fine if you yarn code gen which generates the boilerplate code here so it creates these helper functions um that help that help you to interact with the entities and and also the the abi and these are just abi helper functions all right so this this works i can check with yarn build if i actually can build it on my local machine yeah okay cool that works right so um here it it it has created um the web assembly files that i can now upload i can go here um to the graph.com studio and yeah i'm already connected so you connect with with the metamask i can go here and say like and indexing ethereum net and uh yeah you're already here and then i can only do this i only need to do this graph auth and then [Music] add graph deploy i need to give a version and then it creates this again this web assembly files uploads it to ipfs and um and and deploys this to the studio studio the graph studio is kind of a centralized service provided by edunote for you for easily um develop sub graphs so you see it's it's kind of deployed already so i can quickly refresh here and it should index so it already starts to scan to scan see we can see here the logs and we can also see here that it didn't sync yet all right it will it will take a while but that's okay because um oh i forgot to add the start block so if the start block it actually it indexes quicker cool i changed this and then i can just redeploy and i'll probably need to give a new version and that should be quicker um going back to the presentation um so this was just like the super quick start of getting started with the graph now we have kind of this just all the events stored in entities but you probably want to do more complex stuff um so i show you some patterns um so you want to store these immutable events that's actually what we did like events are typically immutable events because uh immutable entities because they are just happening once and you do not want to change an event after that you just store it and i also think about a little bit about events as the low level entities on top of that you start to build more interesting stuff like the account the actual accounts actual nfts which you can derive from that events um so you have an account so you see an event so you basically see an event it's a transfer and by seeing the transfer you can see okay from who to who was the transfer so you if so you have already two new um entities namely two new owners and then you can just start to count up and down so these are kind of the little bit the highest but for for the events i would go with immutable so this is the pattern for it um you can get have those get out create owner um helpers because you often want to get the owner or want to get the token or whatever and it's always a little bit the same if you if you see it for the first time you want to create it and if you have it already you just want to load it and maybe add something to it and uh in the in the schema you want to link the entities so here the contract and the transfers are linked and also you have the aggregation entities where you can um that you store counts so for example uni swap has aggregation entities so they store one line for every day and then just just start to do the discounts so that in the end they can display their charts yeah before we go back to the code there are two categories of prices from from the graph the first is like best use of existing subgraphs this is actually this is in my opinion a little bit easier because you can just go um for example to uh to the graph explorer and then you look at an existing subgraph you have very cool subgraphs here so maybe this one is cool the 721 marketplace is one that all that indexes all the [Music] uh the the nft sales actually so you can go go here and start to send your queries you can start to um uh explore how it how it is set up which entities you have which um uh things you can just start to query it and think you can and can use the end point to start the query so this is a little bit easier you don't need to learn subgraph development and you already kind of have the the same price as for the new subgraphs so kind of a trick if you're a good front-end developer this is a cool track to get to get some prize money the other track is the best new sub graph so here we expect you to write a new sub graph and and and we look at complexity innovation and um and that kind of stuff so again we have like three three like a first second third price if uh you want to get some bonus points there there are two stuff that uh that you can do so use the decentralized graph network that's what i showed you here if you go to this explorer the graph.com there is also the hosted service which you can still use but uh if you use the decentralized network you will get bonus points and also by using substream so substreams is a very new technology that we recently announced at the graph day in san francisco and it's actually kind of a new paradigm to write sub graphs uh it's it there will be written in rust um the technology is very young but it's very powerful so like if you're into rust and into the indexing blockchain data or kind of trying to stream blockchain data um yeah think about to make your hand dirty with um substreams and that would be also kind of a big bonus point so like if you're writing in a substring you will be very high up for this best new subgraph um yeah so this is my this is my twitter um you can always uh my dms are open you can write me on twitter or you come to the graph booth or there's also the discord channel that you can go in now we can try to see if yes if that had started to index yeah already that's cool so see we see for example like we have uh we can we can check the approvals and we already have approvals here or we can check for the name changes we can see like which are the the recent name changes that we saw from the hash masks so this is this is just given by just indexing those those events um in my github repo that are linked here i was actually going further of than removing unused entities extend the entities um and and write more stuff to create these logical entities on top of it and you can all kind of start to look into this so today's the schema how it looks like later on and there is kind of a mapping how it would look like if you really go through those steps but you saw like my goal for this presentation is just to say to you look with the graph init command you can very quickly spin up the soft subgraph it already kind of gives you very good insights and from that you can start to um explore explore the stuff and if you have a very cool sub graph on the decentralized network on if your maintenance and you want to publish it to the decent plus network then you can click here on publish you say um where you want to publish and then um i can do it in drinkability or may rinkeby if you want to just test it out or mainnet if you wanted to do it and then um [Music] yeah you can you can do this and really be part of the decentralization movement um yeah that's the finish the end of my talk are there any questions yes now pop publishing um so by publishing you you should signal 10k trt on it um and then just the on chain action is probably around 0.05 eth or something like that it's it's not super crazy um and for the for the grts for the initial signal you can actually reach out to me or to the graph foundation so we help you bootstrap this all the questions cool thank you so much for your attention i bring my thing here again and happy hacking i'll introduce myself and i'll go into the talk in just a moment but when i signed up to do this i thought i was signing up for karaoke this is not karaoke it does have a similar setup but it is definitely not karaoke so uh just put a pin in that because later if anybody does want to do some karaoke uh we'll probably do a little social media maybe have a little get together at a local karaoke bar just follow us on twitter or whatever social medias you all like because i'm sure we have one there so i'd like to introduce you to ape works closer to the mic all right i'd like to introduce you to our company ape works my name is evan i'm an engineer at ape works and today we're going to be learning how to ape so the product is actually ape and you may be asking yourself what's up with all this ape stuff well let's figure it out okay so ape is an ethereum smart contract development framework frameworks of course help you with implementing things around your smart contracts if you want to maintain develop test deploy all those good things right so a good framework starts your basis the other thing that's kind of unique about us in the space is that we're python based and open source so you don't have to pay to use our services which is nice right python means that it is human readable code so if you all have kind of dealt with some other languages where it's a little harder to understand what exactly is happening there's a lot of numbers involved and some strange symbols python might be a good fit for you with that being said we can support anyone from a beginner all the way up to an advanced user so don't let the the ease of use or simplicity of the language itself in terms of look make it feel like you're not going to get a full development experience out of it the other good reason for using python is that there's a lot of tool sets that exist we really want to support data scientists and security cyber security and anybody interested in working on the blockchain with being able to access a lot of resources and a little little alpha leak here we're going to be talking about another thing that we have that's the ape academy but we'll look at that in a moment help you learn some resources the other thing that's unique about our framework is that it is a plug-in based architecture meaning that it's highly extensible so as one of my co-workers says if for some reason it does not exist you wish to use it just make it we are also command line based so you don't have to worry about our front end coding skills and how well you can you know kind of navigate our ui we do provide a good ux experience through the command line this is lightweight for us and also makes it very easy to script things we'll see that a little later too plus we also have really cool graphics and we've heard we've had some pretty good swag over the years so make sure you stop by and see our table so let's let's see what this is like right let's let's install eight so it's as simple as saying pip install eth dash ape or you can use pip pipex we've already basically installed it just like that i can look at ape now and see a few options that i have for running ape as a product and i can see some commands so the accounts allow you to manage basically your accounts right you're keeping your private key hidden and in a safe place but allowing you to utilize your account we'll see that we have support for hardware wallets with that you can compile your contracts picking multiple languages we support viper solidity and cairo you can use init to start a project networks allows you to switch so we support multiple chains mention that we're plugin based and this is a way of installing and managing your plugins using the plugin command run links up with the scripts folder in our file structure and allows you to run scripts in the command line and test gives you access to things like pi test and our testing suite so like i said before we've got a new uh new thing for us that we launched when did we launch that uh june 1st we just launched ape academy this is our learning platform we'll inform you quite a bit about smart contracts we're continuing to build it out you should see new and dynamic content coming out through videos transcripts tutorials downloadables we really focus on vipre since we've found that in that space viper which if you don't know is kind of a python ish language for writing smart contracts so if you like the python framework you'll love the the viper language for writing your contracts we have some additional information about testing up on ape academy that will help you test your smart contracts so let's take just a second and look at ape academy since i've already been talking about it a bunch so while this this talk is only about half an hour long right with some room for questions inevitably if you're using it you're going to want to go back and reference something that either i've said or something that you want to do you want to deep dive some information that's where ape academy comes in we've currently got some featured tutorials including one that was just released today my co-worker chris works really hard on creating a lot of these tutorials and uh we're gonna actually hands-on go through deploying a erc20 contract in just a moment and while we're going to go through that really quick this will be a great place to come back and actually explore information about them so please check out ape academy so one of the features that we also have is something called ape template so if you don't really know where to start on a contract and you want some rough framework for yourself you want something that works out of the box and that you can easily customize this is where a temp template really shines for us so essentially when you download ape uh the plugins we don't decide for you what plugins make sense for the kind of project that you're working on right if you are never touching solidity or you're never touching cairo why should we kind of bulk up your system with additional plugins that you may never use so this allows you to really customize and pick what things that you want to focus on so with that being said to use template we're not forcing users to go ahead and and have that as a download it's it's an add-on for you we do have a recommended plugins list that you can download if you're just getting started you're like hey yeah let's go for it so to install a template we'll watch a little video here in just a second and we're going to focus on the erc20 token there's a standard for it hence the erc20 the files that are generated there's a token.vi vy file which is a vipre file and that is the erc20 standard this is for a fungible token we've heard a lot about nfts but you know what was an nft before an nft it was fungible right hey so these are identical tokens another contract that we support is an erc 721 which is the nft standard once again that's a non-fungible token and therefore unique and it has metadata associated with it that allows for linking assets and other other things you can see on the right hand side here that it is on the right for you all right or is it just for me okay sweet um kind of the file structure that is created when you use the template so let's let's build this real quick so i can type in eight plugins and point that to an install of template should be fairly quick here and now that it's installed i can use it by calling a template and pointing it to the github repository that i wish to connect to this could also be an http address and this uses cookie cutter so anything that is in square brackets is kind of a default value anything that i type in will override that default value and so a lot of the interfaces that are going to be used in this token contract you can decide whether or not you wish to engage with right whether you want to pre-med whether or not you want something mintable or burnable or permitable so i just let the defaults happen there and we can see that it's created the file structure for us so i'm going to take a second to step away from the videos here and actually look at the structure hopefully this is big enough you can kind of see it everybody we good all right so this is that same demo file that we had on the video earlier and we can see the contracts folder this is everywhere when you utilize ape that you're going to store your contracts you can have nested folders within there but kind of starts with contracts it's fully configurable so if you don't like the word contract and you want to have i don't know letters or code snippets or i don't know whatever you want to call it you can customize that it's one of the great things about our tool set is it's highly customizable so just briefly looking at it we can see that where i overwrote the words demo and dmo as the symbol for the token left 18 decimals as a default value and um once again a shout out to chris if you use uh ape academy and look at his um video i had that up here earlier yeah on how to make an erc20 he really goes into depth there's both a transcript and a video here of all the components of setting this up and then telling you kind of the breakdown of the contract itself and even giving some tips about how you might use it or what it might mean to implement a certain interface the other thing you have here is the scripts folder so this allows you to use ape run to run your scripts and that will automate a lot of your processes if you wish to have a more interactive experience we have ape console that we'll see in a moment when we do querying that allow you to do more of a hands-on interactive environment with locals available to you so the scripts folder that we have here has a deploy currently script in it that's very simple this is just going to ask me what account do i want to deploy with and then it is going to do the deploy action for me the other thing that's really nice about using this template is that you get some things pre-built inside of it as far as the tests go we give you some fixtures straight out of the box so that it can support these pre-made tests around some of the questions that we were asked earlier like do we want it to be able to be mintable do we want it to be burnable right so the tests are already kind of built for you out of the box and the last thing i want to cover at least in this screen is the ape config yaml so inside here you can basically configure your your project to interact with the ape framework and create a lot of overrides as well we see that right now all i'm doing is specifying that i have a dependency of a plug-in that is the viper plug-in that will help compile to the abi code by code that i need to deploy we'll see this compile and one thing you'll also note is that we're going to use confirmations so knowing that the block can change just a little bit as we're adding to it right we want to make sure that it's at a stable point before we consider our contract to be fully deployed if we wish to override any of these we can actually do that here in the yaml so with that said let's try it so i'm gonna go um i want to run this script that i've written right or that's been generated for me the deploy script so i can say ape run and i want to do deploy and the thing is i'm not ready to deploy this to mainnet yet just yet i would like to use a test chain right so i'm going to use the network flag network just to um position this to which chain i actually want to use what what provider and what network and what ecosystem so i want to use ethereum and i would like to use rink b if i could type and lastly i would like to use alchemy as my provider so it's bringing up some accounts that i've already set as personal accounts and i've given an alias to so that i at least know which account works for me i'm going to select my account and i get a signing prompt here which at least allows me to look at the gas so beforehand i can be like yeah that's acceptable to me i would like to do that i will sign i'll enter my passphrase please don't steal it i will ask me if i want to leave this unlocked i might have additional things that i wish to do and i don't want to have to unlock it every single time for now i'm going to say no and now what i can see is it has begun the process of making sure that it is confirmed on the block we can already go ahead and look at this ether scan link etherscan is another plugin that we support and the internet's just a little bit slow so we'll wait for this to load yes so we now see that it has successfully uh the transaction itself is successful the next thing we would want to confirm once we wait for the the two confirmations here is that the um contract itself might be hitting that a little hard huh with the retries is that the contract itself has deployed so i can go back to etherscan and check that my token is now available and we see demo token erc20 dmo is the symbol so we have actually if you all want to even go out on the test net on rink b right now you can see that i just deployed an erc20 token what no claps [Applause] thank you all right so we talked a little bit about the plug-in architecture let's dive just a little bit deeper because one of our bounties is writing a plug-in so you might say evan all right what's this plug-in thing about we got ape core which is basically the glue and defines how these components are going to interact with each other you have some core plug-ins that come kind of out of the box as soon as you download a that are ethereum geth pm which is a package manifest sorry had a brain fart there uh package manifest uh plug-in and then east tester which helps to set up and supply some of the locals that you you can utilize in the testing environment so then we have what we call supported plug-ins that are written by ape ape works employees like myself they kind of fall into some different categories we have compilers so these are language based these this is what's going to convert your viper solidity cairo into an api or contract type byte code right we support out currently we support hardware wallets ledger and tracer this makes for a really great way of not exposing your private keys while interacting with the chains we support l2 um ecosystems like phantom and startnet which i do want to give a shout out to one of my co-workers for making the first non-evm plugin jules who happens to be with us today and uh we also have provider plugins like hard hat you saw me use alchemy earlier in fura and foundry is currently in alpha we have a lot of projects that are currently in alpha and we'd love for you all to have a project in alpha beta gamma production whatever right so you're saying evan how do i make a custom plugin well let's walk through that real quick so the first place to start if you want to go for this bounty or you're interested in plugins i would say is to look at some examples of plugins that we've already written so if you want to know something about like ape solidity you want to write a different kind of compiler for languages i would take a compiler api and kind of begin looking down that path providers maybe something like infuria using the provider api tracer using the account api or if you want to make a c cli extension ape tokens wraps the token list and provides that through the cli so here are the like bare minimum requirements right you've got to start with ape underscore give your plugin name generally whatever the plugin is about right and then you kind of pick your own adventure here this is an and or you can do both things you can choose to do one thing but you've got to implement one or more api classes from the ape.api module and or make a sub command and point it to your entry points in your project setup if you're looking for ways to kind of organize your file set and look at the standard that we've already kind of created we actually have an optional project template in github that you can utilize so as for the adventure path of implementing the api classes here's a quick example of using the alchemy like we saw that i used earlier you want to import the api class and then make that the base class so unfortunately i cropped off the line numbers here but where it says alchemy ethereum provider and it has web3 provider and upstream provider those are where you're utilizing the base your base class with the uh apis right so a web3 provider allows access to the web3 chains and an upstream provider allows for forking and you can see kind of here even though i've collapsed everything you've basically implemented the abstract methods for connect disconnect establish or not establish but estimate gas cost and send transaction so the um details of how these things are done you decide as long as the interfaces connect together right it makes sense the next step to that is um registering the api class which this is a separate file and we just see that we have a list of networks that we're providing within the alchemy mainnet robsteen rinkby which you saw me utilize and so on so forth and then we just yield after registering the plug-in ethereum being the ecosystem name whatever the name of the network is which in this case would be alchemy and then the provider itself if you're creating a cli extension um you can look at an example like ape tokens which wraps a token list and we can see some some click commands here and click groupings and the next part of that is just to register your entry points so between lines 67 and 70 there we see entry points and we're just saying ape tokens as a command is actually going to point to the ape tokens library looking at the underscore client or cli file and then cli method and the final thing i'll leave you with is how to query the blockchain requirements here are just that you're connected to an active provider we're going to look at this real quick in ape console which is an interactive python environment that has locals such as uh chain there's much more but we'll point you to um additional things in the ape academy for the rest of it but essentially it returns a data frame that lets you do some really neat things so let's do that just really quick if i can find my there it is okay so ape console this time i'm doing a network of ethereum main net and let's do infuria all right so i currently have an active session here and i want to set up a few things so i'm going to copy paste here so the first thing i'm going to do is set up my stop block which is going to look at the chain and get the very last block and get the number of that block so if i want to know the last block there we are then i'm going to set up my start as being 50 blocks before the last block and then i can do something like looking at the average gas used over those 50 blocks or i could do something like looking at the average time of creation over those last 50 blocks like how long does it take for a block to be generated we're up to 17 seconds this morning it was 14 so that's fun or we can do even more complex things like set up um visuals with matplotlib so if i generate blocks and i go back over the last 20 000 blocks in steps of 1000 because i'm wanting to aggregate some data here and i use matplotlib for the visualization and then a little magic here and let's show it we can actually create some graphs based uh dynamically on the blockchain [Applause] all right and what's my time looking like i got two minutes or so the last last thing i want to do is give a shout out to the bounties that we're running so if you want to do any kind of smart contract project using eight we have a kind of first place at three thousand second place at 200 200 500. if you write a plug-in which we kind of went through three thousand for that one and going over like the blockchain uh data that we just did that's 3000 for coming up with a really good story utilizing those uh analytics any questions so the the question is about the ape console what kind of environment essentially is that and it's essentially an ipython that has additional locals injected into it so you can access the ape-specific functions but you do have the full python environment available to you any other questions all right well i will see everybody at the karaoke later please be sure to uh hit us up on discord uh check out our github read our docs we're kind of cool just saying but i'll talk to you all later okay let me start timing myself all right hello hello my name is kelvin um i work on optimism which if you don't know is a layer 2 on ethereum one of the cool ones and i'm going to spend this is going to be kind of a different talk than normal i'm going to spend one minute showing you how to deploy to optimism and then 29 minutes looking at cool solidity slash ebm tricks this is not all of the evm tricks because there are so many of them but these are the cool ones so here we go all right so back last year optimism was really hard to deploy to it was really annoying you used to have used this thing called the the ovm and you had to compile your contracts with a special ovm compiler and it was a whole mess so we rebuilt the thing and made it easy so you don't have to do that now it's just like deploying to any other network so i'm not going to actually deploy but i will show you how to do it if you want to do it by re through remix if you really want to do this through remix i guess you can use some tool just to get connected to the optimism network in your whatever your wallet is i i built this simple website called chain id.link that you can use to connect to a bunch of different networks so you can try that or chainlist.org blah blah right get connected to optimism change your network go there write a contract deploy that's it you don't have to do anything special it's just like deploying to ethereum or you pick a different network right easy same deal with hard hat right all you do is you set up a hard hat project and you add optimism to your hard hat config and then you write a contract and you deploy with dash dash network optimism how do you add optimism to your hard hat config well here's the details of if you go to community.optimism.io it'll tell you how to do all of that it'll tell you how to uh what endpoints you can use these are it's just like adding any other network to your hard hat config it's really really really easy and if you go to dev docs where are we using your favorite tools there's a whole page on how to do this let me let me zoom in a little bit there he goes here's an example of how you can add it to your hard hat config just just add the url it's just like ethereum great fantastic okay same deal with truffle so that same page community.optimism.io it just tells you how to add it to your truffle config it's really easy you just write a contract then deploy with dash dash network optimism just like you would do if you were deploying to polygon or if you're deploying a test net or whatever you just you just specify a new network and that's because we did a lot of work to make sure that it was fully what we call evm equivalent so it just runs geth under the hood and that's pretty cool same deal with brownie except you don't even have to add optimism to your config for brownie you just do network optimism and it's built into brownie which is very cool thank you brownie that's basically it that was longer than a minute so too bad all right now the fun part of the workshop evm tips and tricks a lot of them you will not want to use in production but it's still fun all right so invalid let's start there number 10 we'll do a top 10. invalid invalid is a really cool op code because it just reverts sort of it does not actually revert it triggers what we call a non-evm error non-revert evm error and what this means is that there's a class of errors that are not reverts that will cause your call to end and you will lose all of the available gas so an example of this is like a stack underflow let's say you try to pop a variable off the stack and there's nothing there you're going to get an error like this invalid is really cool because originally people just started using this opcode they just picked it and they started using it and it wasn't defined as an eip it was kind of defined by social consensus and then in eip141 they set it aside as an official op code called invalid and it is the most efficient way to burn all of the gas that's available in a given call frame so if you ever need to burn gas really quickly without actually doing work you just trigger this opcode and all of your gas will disappear immediately very efficient okay call code call code i want to see someone actually find a use for call code call code is basically really useless it's like the original version of delegate call except they got it wrong delegate call if you aren't familiar is really useful for proxies and what it does is it allows you to run the code of another contract but you still maintain the message sender and the value and all that stuff so it allows you it allows you to do a proxy call code was really useless because it would call the code of another contract but it would also change the message sender to be the new to be the the address of the contract doing the calling and so it never actually worked as a proxy i don't know if anyone actually uses call code but if you do tell me because i don't understand why you would use it so that's just out there the id yes why would you want to burn all the gas in the call that's a really interesting well optimism actually has one use case for this i don't know if it's the only use case but it is one where uh as a trick because message.value is really annoying and if you mark something as payable in solidity and then you want to call another function you want to pass along value that other function has to be marked payable to and so you know one example of why you might want to do this is that what optimism does is when you send a message from ethereum to optimism you have to pay for that message somehow and if you may you could make it payable but now app developers whenever they want to pay for a message have to make this whole chain of functions payable it just looks really weird and your users have to send value with a transaction which they're not used to doing and so the trick was well why don't we just burn a bunch of gas on l1 and we wanted to do this in a way that wouldn't actually put put a pressure on nodes because if you're actually doing work you know you're putting pressure on nodes um so we can just burn the gas really efficiently by just starting a new we do a call and then we just trigger the invalid op code and then all the gas is gone and it's sort of your how you pay for it is by burning gas if that makes sense all right the identity pre-compile um ethereum has a bunch of pre-compiles they're pretty cool the identity pre-compile is probably the weirdest one it's located at zero x zero zero zero blah blah four and all it does is it returns whatever you give it so if you give it some call data it's going to return that call data to you which sounds really useless and mostly is really useless but it is useful in certain cases if you want to gas golf for copying lots of memory at a certain threshold just doing straight up memory copying by taking a you know reading a a word of memory and then rewriting it gets to be expensive so it's easier to just do a call and insert all of this call data and then say i want it to be returned over here instead and it's cheaper so fun if you want a gas golf generally not that useful otherwise although it is also the source of various guest bugs so risky risky pre-compile okay solidity tricks these are kind of mixed evm and solidity tricks i feel like i'm going a bit fast here so i got to slow it down a little bit solidity exposes contract type information if you aren't aware of this you can use this type and then my contract and it gives you meta information so it gives you stuff like the name of the contract the creation code the runtime code and the interface id all these things are pretty useful the name maybe not so much although i could see use cases for it where let's say you want to do like a you know you want let's see what's a good example you could do something like i don't know what you do you know do some version string return some version string and it involves the name of the contract i don't know whatever the creation code though is really useful um if you want to let's say make instances of a contract you can you know basically get access to the creation code you instead of running you know new con oops sorry new contract you can do like a low-level create and there's sort of useful cases for why you might want to do that yes yes so oops sorry so i will actually talk about this a little bit later but in in ethereum when you create a contract you have two sort of types of code there's the creation code and the runtime code and what happens is or what happened was that's ethereum really wanted constructors and so what they decided for to be able to have constructors was you would run when you call the create op code you pass it some evm byte code and that evm byte code actually executes and whatever that evm byte code returns becomes the code of the contract that you have created so every contract has these two pieces the creation code and the runtime code and so the creation code runs when the contract is being created and it's expected to return the runtime code and this is of course really useful for constructors because it means that in the creation code you can do stuff like set a bunch of storage to initialize the contract and then once you're done you can return the code and the contract has done some work in the initialization step and then the interface id is really useful if you've ever used eip165 which is this uh you know supports interface thing where it'll you can query a function and the function will tell you what interfaces a certain contract supports you can just really simply return my you know type my contract dot interface id and that's a very easy way instead of having to do this like whole exor of different stuff it does this for you so very useful saves you a couple lines of code all right another one that not a lot of people know about but it's pretty cool solidity has function types so you can actually pass references of functions into other functions which allows you to do things like map right so this is one of the examples from the solidity docs where you can let's say you want to define a map function and it takes an array as the first parameter an array of unions and it takes a function that takes a uint and returns a uint and what map is going to do here you can see it's going to create a results array and then it's going to loop over the input array and then you can see here it's applying the function to each input value to generate the outputs so this is pretty cool you can do this for a lot of you know a lot of interesting things we just want to save some code or save some lines of code by just passing functions around it can be a little finicky sometimes with with typings and like external and public don't always i don't know if this has been fixed in more recent versions of solidity but when this first came out it was a little finicky but should mostly work and a cool way to do do a little bit of this meta programming okay related to this solidity recently introduced this thing called abi encode call so if you have been writing solidity for a while you probably know yes yes i believe so yeah probably try it should work um yeah probably i mean if it doesn't work we'll find out um solidity okay so so people are probably familiar with the classic uh abi encode and abi encode pact but solidity also has these cool things abi encode with signature and abi encode with selector which is really good for encoding function calls to other contracts and relatively recently the problem with these with encode with selector and encode with signature was that it wasn't type checked so you didn't actually know if you were properly encoding the call to the target contract until you started testing when presumably you write tests that show you whether you're properly encoding this or not and and you get some sort of error when you run your tests but recently solidity introduced abi in code call where you pass you know mycontract.myfunction.selector as the first parameter and you pass the params here and then solidity will actually compile this type check it make sure that you are properly encoding your calls to the other contracts so this is a great way to make sure that you are encoding things correctly and save yourself the headache of having to write a bunch of tests and only finding out later that you mess something up cool and that takes advantage of course of the fact that you can pass in function references and well in this case i guess it's using the selector but whatever same idea all right this one is something that not a lot of people know you cannot deploy contracts that have byte codes starting with 0x ef-00 so or actually just 0xef which implies 0xef 0 0 but really it's just your xef you're not allowed to do this try it try deploying a smart contract to ethereum where the byte code of the smart contract is 0xef you can't do it and that's because of this thing called the ethereum object format which was starting to be introduced which is i'll talk about when it was introduced and the ethereum object format was initially trying to solve this problem of right now code and data in smart contracts are the same thing and this is how you get these weird things like you know technically the constructor is something that you can jump to and execute or technically the the hash at the end of the smart contract that's you know that solidity appends is code that you can jump to and you can run that code and you can use it to do cool uh you know capture the flag things or whatever puzzles but this actually creates problems in the evm because the evm has to look for every single uh every time you do a jump in the evm it has to figure out is this somewhere i'm legally allowed to jump to in your code and in order to do that you have to check is the thing that i'm jumping to a jump desk opcode and there's all these different things but basically we can eliminate a lot of this analysis by explicitly separating code and data but you can use this ethereum object format to do a lot more interesting things but of course we don't have this right now so how do we make sure that we will have it in the future we define some prefix and uh we block people from deploying contracts with that prefix and then in the future we'll allow people to deploy that con contracts with that prefix again with the assumption that the evm reads that prefix prefix and it says okay i know that if it starts with ef00 something this is an ethereum object format compatible smart contract and i know that it's going to have this the following format and i'll talk a little bit about what you can do with that how is this possible so what happened was in the london hard fork eip 3541 it was announced that all contracts starting with 0x ef would be blocked so of course people started deploying contracts that started with 0xef and uh and then what people did was they just looked on chain and they figured out well sure they deployed something that started with 0xef but they didn't deploy anything that started with 0xef00 so we'll just pick that instead and you can't deploy any new ones so good enough it has the potential to be really cool so the the eof ethereum object format contracts would start with 0xef and then a version byte and that version byte tells the ef how it's supposed to parse the contract so one example here is it says let's say this is a version zero contract we'll say that there's a specific area here defined as the length of the to tell to tell you the length of the code then you have the code and then you have the length of the data and then you have the data or something like that and you can also use the same trick to deprecate opcodes so you can say let's say that nobody is allowed to deploy any more version 0 contracts and in version 1 you are not allowed to deploy a contract that includes some op code that we don't want people using anymore because we hate it so we can we can do this really interesting stuff so not technically out yet but will be and will be really cool create two okay so this is uh this is something that you might already know uh create two is really useful if you don't know it you should be using it more often uh create if you do know this great if you don't you should the original create op code as it says here generates addresses based on the creator address and the creator's nons but create two generates addresses based on the creator's address the contract code and the salt which means that they're basically deterministic and it doesn't depend what chain you're on you can deploy the same contract to every single chain which is really important especially in the multi-chain world you don't want a situation where two contracts can exist on different networks at the same address but have different code that can be damaging so use it generally more secure be a little careful whatever fine i'm gonna skip that self-destruct is extremely sus but it has some cool stuff so self-destruct will delete a contract from the state try and it will transfer its balance to the beneficiary very cool uh very cool opcode a lot of people hate it and it's created a lot of bugs for people but whatever so a contract is susp or self-destruct as us because a contract that uses self-destruct can delete itself and then it can be recreated at the same address with completely different code which is kind of a cool way to do upgradeable smart contracts and i think some people have done this before [Music] it's not amazing i mean it's a little terrifying and uh there's definitely been situations where like block explorers don't work or you end up with like a like a parody situation where somebody just hits the kill button or whatever and you can't do anything about it so be very careful with that and then self-destruct is the only way to send eth to another address without triggering its code which can be very useful if let's say a contract has code in it that says when i receive eth revert immediately so if you want to forcibly send east to somebody and they can't do anything about it just use self-destruct and so remember that if you're auditing a contract make sure that you don't make assumptions about a contract not being able to receive eth because you will be able to receive eth no matter what and it's also the only way to permanently delete eth from the supply so yes of course you can send eth to a burn address like the zero address but it's still technically in the supply even though it's not accessible self-destruct is the only way if you self-destruct to yourself it's the only way to delete each from the supply permanently it just gets proof it's gone right all right we're yeah um self-destructors does it in the in the code for self-destruct it basically when you trigger the op code it will just increase the balance of the recipient and it won't actually trigger a call to the recipient so it's the only way to do it i'll often i'll have to run through these because i'm actually getting quite tight here block hash is the ultimate oracle that nobody uses i wish more people did it's really really cool block hash obviously contains information about the entire ethereum blockchain it's a blockchain so the block hash contains information about the current block but it also contains the previous block hash which means you have a chain all the way back to block zero and using merkle patricia tri proofs you can access literally anything in the ethereum try not enough people do this it's really cool optimism has built a library for verifying merkel patricia tri proof so you can do this on chain and you can read the storage of other accounts you can read event logs you can do whatever right everyone says like well contracts can't access event events no they totally can access events you just need to do a miracle try proof it's expensive but you can and it's you know this is there's a lot of reasons why people didn't want people to access this stuff but anyway you can access it it's the ultimate oracle and no one uses it and i bet you could build a really sick hackathon project by just doing some unexpected thing by reading information from the ethereum state like you can literally just go and read the storage of any other contract you normally cannot do that um block hash only goes back 256 blocks but you can always walk backwards by doing proofs so you say well the pre you know i'll prove about the current block and then i'll show you the contents of the previous block hash and i'll just repeat this because the previous block hash contains the block hash before that and you just go on this chain backwards and optimism really wants to build a block hash oracle so we would kind of have a chain of block hashes into eternity um so if you're interested in working on that as a hackathon project would be really cool kind of like a collaborative way for the entire theorem community to store every block hash so that we have access to it not just for the last 256 blocks but for every single block requires a lot of proofs but i'm sure as a community we can do it together and great so create this is number one this is probably the coolest one that people don't really think about when i talked earlier about contract creation i said that create executes a knit code this initialization code creation code and the code whatever that code returns becomes the contract code and the secret thing in here is that create executes the init code so create executes arbitrary evm byte code you can literally just pass whatever you want right i can i don't actually have to create a contract i can pass you know push 1 push 1 add as the instructions to you know there's the as the init code and what it's going to do is it's going to push one to the stack it's going to push one to the sac it's going to add the two and then it's going to have you know two the value two on the stack and then i don't know then it just stops and it doesn't do anything um but what you can do is you can execute arbitrary byte code you can do whatever you want you don't actually have to create a contract you can do you can do math or whatever you can uh you can basically have like user provided scripts that you run and you can you can kind of do whatever you want so you can make a simple scripting language where um let's see what did i yeah okay so here's an example right you could put let's say you want to do like a scripting language that doesn't actually change state you can do something like put all the inputs and call data run create with the user script as knit codes so it just runs these evm op codes then the user script reads the call data so it reads the inputs and then the user script is going to revert so it doesn't actually change anything and you read the result from the return data the other reason to revert here is that like i said this is still a contract crack contract creation and if you return then it actually goes and creates a contract with it with whatever's in the return data but the evm has a quirk where if you revert then then whatever you return instead of being created as a contract just gets put into the return data buffer so you can read it so optimism almost did this i was too scared to put it into production but i built it [Music] where we had this whole system of these contracts that would drip eth to other contracts and originally i wrote this whole system where we would uh i wrote this whole system where we could provide these small evm bytecode scripts and the evm bytecode scripts would have to they would get you know created and they would have to do a bunch of work and they would have to either return or i guess revert with a zero or a one and if it was a one that meant that i could go ahead and do whatever i wanted to do if it was a zero that meant don't do this it didn't work revert whatever right so yeah you could i think there's a lot of fun stuff you can do with this and nobody really does it which means that i think you would look cool if you did it was that 29 minutes just about interesting okay this um i was not expecting to get this far okay nope that was 29 minutes so no oh one bonus trick one bonus trick you can actually in solidity if you drop into assembly in the constructor you can use the return instruction in the constructor to return whatever you want and that returned by code becomes the code of the contract so if you wanted to i don't know return i don't know what you could return you can return whatever you want and that becomes the code of the constructor and so you can do some really deranged things like in the constructor read the code replace the code with other stuff to be able to use opcodes that solidity won't let you use and then return and you do just all this hacky stuff that you should never do in production great okay that's exactly 30 minutes perfect optimism is hiring as always optimism op labs or just come hack i'll be downstairs hacking on some deranged solidity so cool if you have more questions we can talk afterwards all right all right i think we're good how is the uh am i close enough to the mic i think i am all right fantastic thank you guys for all being here what's up guys um today we'll go through what super fluid is and and then we'll walk through building a money streaming application i'm one of the just well-known ethereum test nets so first and foremost what is superfluid so superfluid is a protocol which enables real-time finance so what that means we allow you to build digital native programmable cash flows and this includes things like streaming money with no capital lock-ups in a way that is 100 programmable and unchained so one thing we we think about a lot in in this broader ecosystem right we think we're all building this internet of value right so what we believe is that the internet is to information what blockchain is to value right and and one place that we're trying to add to add value in this area is in real time finance right so in the traditional financial world when you provide a service to somebody i provide the service and a lot of times that service is decoupled from the payment that i receive from for that service right so if i provide a service to you as an employee at your company i get paid maybe once a month when in reality i'm providing value every single day that i work for every single hour that i work so why shouldn't you be paid for every single second that you're working right or if i'm providing a valuable service like on netflix or i'm providing computational services like aws why shouldn't i be getting paid every single second the service is being provided right so that's one thing that we we really help with that we really focus on so the way that this manifests itself is through money streaming so a money stream is a continuous payment that's native to web3 right so any recurring payment you can think of you can turn it into a money stream and send it on a second by second basis so these are like a connection between two existing accounts being an eoa or a smart contract address where instead of deciding hey look i'm gonna send you one thousand usdc per month and send it in a single transaction once a month i can instead take that amount divide it essentially amongst the number of seconds in that time period and the money will flow from my account into your account in real time just like what you're seeing right here this is actually directly from our dashboard we have like a stream details page you can pull up to see the stream flowing in real time and this is an actual live money stream sending real money from one account to another right now so it's very cool stuff so how does this work right well we built a protocol to enable this and it's made up of three high-level parts we'll go through them at a high level right now and then go through how to actually build money streams using solidity and also using our sdk in a couple of minutes so the the protocol is really made up of three high like i said high level parts the first is the superfluid host contract which serves as a kind of like brain for the protocol right so things are plugged into the host contract and that helps to enable everything to kind of work together and the other two are agreements and super tokens so an agreement is a peer-to-peer financial relationship that defines how your token balance can change in real time so the most commonly used agreement within superfluit is called the constant flow agreement which allows me to send you money linearly through time so i agree to send you a certain number of tokens per second and those tokens are just transferred to you per second so that's cool in theory but again how does that work right so many of you are probably used to sending native assets and also transferring your c20 tokens if you're gonna go back here and send money on a per second basis like this right how is this happening right to you if you're only used to your c20 transfers you'd have to hit transfer every single second that wouldn't be feasible so what we built is an extension onto the erc20 standard that enables this real-time balance to be calculated every second so this this new standard is called a super token right and like i said it's it's an extension on the erc20 standard so it is compatible with erc20s all of the the standard transfer and approval mechanisms that you're used to are all on super token contracts there are just extra features on these super tokens that plug them into those agreements that can modify balances in really custom and unique ways right like the the money streaming so like i said these are plugged directly into the superfluid protocol they're usable anywhere in web3 and we have two separate kinds of super tokens you can use so one type is a native super token which just has no underlying address right this is just deployed directly as a super token the other is a wrapper contract right so i mentioned it's usable anywhere in web3 the reason for that is that we allow you to wrap any existing either native asset or erc20 token as a super token so that you can use it in other places as well right so that we wanted to value interoperability because that's so important to our space and wrapper contracts let you do that so again how does this real time balance actually work though right so usually that's not quite enough to to sell you on the fact that this actually is working in the way you think it's working and the idea here is what happens with these agreements is you define like i said a number of tokens you want to send per second right so all i have to do is send a single transaction to say all right i'm going to send fran for example one token per second right what we can do there is calculate the amount of time that's passed before you make another state changing operation and always have this accounting in place they can make sure that you you're only performing a new state changing operation with tokens that are in your balance right so this is all made up of like what we call a static balance so just a token sitting in your wallet and a dynamic balance which is made up of something called a net flow which just which is uh is is taken as the the number of tokens decided being sent to you or sent from your account every single second right so that's the idea if you have any more questions on that feel free to just find me this weekend and we can we can walk through it it's okay we've gone through agreements super tokens real-time balances how about programmability right so you guys are all builders you want to make cool stuff money streaming is cool but you can do additional things with money streams that allow for lots of automation and really interesting applications so you can build something called a super app which is what we'll walk through in a couple of minutes that allows you to uh implement callbacks that can react to events that are are taken um along with that that individual contract right so let's say that you have a contract you deploy that's a super app and you send a stream into that contract that stream can run any arbitrary logic as soon as the stream is is created into that contract right so the contract is able to react to these different actions and the reason why this is able to happen is that it's all plugged in back to that host contract that i went that i mentioned at the beginning right so you register a super app with the host contract which is able to then call these callbacks and react to specific events that are happening with superfluid so again i went through this a little bit super apps these are reactive smart contracts we'll go a little bit a little bit deeper into this in a couple of minutes but what this does is allows any of you here to build applications that are connecting cash flows together and building a really cool network so we expect to see is an explosion of these network cash flows right so this is a live depiction of a bunch of superfluid streams that are on polygon right now this is a this is a live network this is a fast growing network and all of you here have the opportunity to build things that grow this network and uh ideally help connect cash flows in a really interesting way so we see a network effect starting to to emerge here and we're very excited about it so yeah i'm i'm impressed that this this worked with uh within the keynote presentation i was a little i was a little worried it wasn't going to buffer but we got it um okay so that's the high level of how to build on superfluid let's get into a more tactical example so the before we get into a contract we'll walk through together i do want to highlight a couple of developer tools that we've built we really care about developer experience it's hard to build good developer experience around technical products like this but we do put a lot of effort into it and this this is really what a lot of my day-to-day is is built around so one tool we'll go through is the superfluid developer console that lets you see you know any streams that are associated with your accounts it'll let you check super token balances and it's just a really useful tool overall we also have a dashboard that lets you create update or delete streams with without writing any code at all it's just a good thing if you want to open a stream to a friend to try it out you can go to the dashboard and and test that live there we're deploying a new v2 of our dashboard very soon which is even cooler than the dashboard we have here but i just wanted to still still mention it because it is important and the final thing you need to be aware of is that we have built some what i think are pretty good sdks that lets you if you just know javascript or typescript and aren't maybe great with solidity yet you can still interact with superfluid just using our sdks so we'll use that in in just a second but just wanted to highlight those three things so let's build okay what are we going to build we're going to build a tradable cash flow contract so what's the tradable cash flow the tradable cash flow is a super app so it can react to these super fluid events and implement it it does implement callbacks which react to these events and do something and what it's going to do is send 100 of the inflows to the contract to the owner of the contract and the contract is tradable because it's an nft so this actually mirrors some real world financial assets for example if you have subscriptions there are companies out there let you go get revenue-based financing against those subscriptions so this is a kind of web3 native version of that or maybe you can tokenize a subscription revenue and sell it maybe you can model them together and sell it we're not going to get into any of the more advanced futuristic things here today but we are going to talk through the primitive of how this works so i'm going to zoom out here and i'll show you where you can get this exact example code in our repo and then we'll just kind of walk through it together i'll show you how we can write some scripts to interact with the contract itself and we can we can move from there so i might have to zoom in quite a bit here because i chose to i chose to mirror but hang on zoom in here here's our repo it's just super fluid finance protocol model repo and it's in it's in our examples folder you can fork it right here you can fork it just from the main branch if you'd like and this is our examples folder we're going to go into the tradable cash flow section and the contracts are going to be working with are going to be in here we'll step through these these two contracts in just a second but i do also want to highlight that we have some scripts here too the user sdk so you can go into the scripts folder and we're going to create update and delete a flow here in real time together using our sdk as well so you can see all this and follow along if you like in this section of our repo we also have the console up in a separate tab which we'll show in a second but this is really really going to be useful for us when showing you how the streams are being created updated and deleted in real time okay let's get into some code so i i have a a cloned version of that repo right here let me zoom in quite a bit you guys see that okay thumbs up good okay exit out of this clear up some space okay so we have this tradable cash flow contract and and what is this right so one we know it's an nft it's tradable so it's going to inherit from the erc721 standard it's also going to inherit from this redirect all contract which has a lot of this super fluid automation on that on that contract we'll we'll step through that in just a second but in the constructor what it's doing is it's number one minting an nft to the owner that we pass that's going to be the first argument to our constructor it's also going to take a name and symbol standard erc721 stuff and then it's also going to going to take a the address of the superfluid host and it's going to take in the address of a super token right so we're going to we're going to keep this confined to only working with one token but you could make this generalized and work with any super token you like okay and remember the the host contract is that what i compared it to is the the over like the brain of the protocol right so you well a lot of times when you're building on superfluid need to pass in the host address to be able to initialize our libraries and access other things within the protocol as well okay the only other piece of logic that i am implementing inside of the tradable cash flow contract itself is this before token transfer hook this is actually straight from the the open zeppelin api or on erc721 if you guys don't know you can also implement hooks and things you could run automatically when you transfer nfts this is one of those things so before the token's transfer transferred we're going to override the logic here only take the the address that it's being sent to and we're going to call this change receiver function and pass that address in here okay so what this is going to do is anytime i transfer the nft i want the cash flows that are coming out of the nft to go to the new owner right the cash flow should follow the nft right makes sense so let's go into this redirect all contract because this has the meat of the logic so what's happening here is i'm just importing a lot of the superfluid stuff we need for working with the protocol the big one that i'm i'm importing is the cfa library this is going to make it really really easy for us to create update and delete streams in solidity with really just a line of code it abstracts some of the lower level stuff away and ideally makes it much easier for you we also import from this super we also import this this super app base contract which will make this a super app right and the reason why that's important is because we need this to have that those reactive elements to it we need to be able to implement the callbacks that will run on certain events right that's the idea there so at the top of this contract we are going to initialize the library using this syntax here so using the using four stuff that you're probably used to with importing libraries and then what we do inside the constructor is pass in the superfluid host address that token we want to use and then the receiver which is just going to double as the owner of the nft it's going to be the initial owner that the end of t is minted to so we run a couple of checks here to make sure that we're not passing in the zero address for any of these things we assign these variables like we should we get the we initialize the supe the cfa library as this cfav1 lib variable and this final thing we do here is register the super app contract with that superfluid host contract so this lets the superfluid host know hey look there's a new super app being deployed call these call these callbacks on this contract whenever these events happen right and by default there are six different callbacks that will run one is the before agreement created another is the after agreement created and then there's the same thing as mirrored for after agreement is updated and after agreement is terminated right so there's a maximum of six callbacks you can implement we a lot of times we'll usually see just the after agreement created callbacks being being implemented what you do to specify which callbacks you want to run is just you you specify that there are certain there are certain callbacks i don't want to run right so these are all no ops here so we're not going to do any of the before stuff the before agreement created stuff is useful in in the case where maybe i want to reject a stream coming into the contract if it's below a certain amount maybe i want there to be like a minimum amount sent into the contract maybe it's a subscription of some kind it's got to be a minimum i could do that kind of stuff in the before if i wanted to so that's the setup the first thing i'll show is the this current this uh not current this change receiver function and then i'll get into the redirection of cash flows so remember what's important with the the change receiver is that we delete the streams going to the old owner and we create a stream to the new owner that's the idea right we need to make sure that the cash flows are just following the nft to the new owner so we have a nice little getter function to get the current receiver see who it is and if i scroll down we have the change receiver okay so we run a couple of checks at the top and then we check what the outflow rate is to the current owner using this logic here right so we have to do is call this git flow function and we can get information about the flow one of the parameters that's returned is what the flow rate is we can check what that is if it's greater than zero meaning that there's something that exists we'll just delete that flow using this one line of code and create a new flow to the new receiver right so simple enough deleting creating a new now let's get into the the automation stuff right this is the the most important stuff you'll see at the bottom we have a few of these callbacks that are implemented one is the after agreement created another is the after agreement updated and the final one is the after agreement terminated we run this update outflow function in each of them so let's step through let's step through that function because it's going to be very important for this app okay so the update outflow function what it's going to do is it's going to check what the net flow rate is of the app and it's also going to check what the outflow rate is of the app so the first thing we'll see is okay does does the inflow rate now equal zero right if the inflow rate now equals zero it means that the flow that was being sent into this contract was deleted so if that was deleted what that means we need to also delete the stream going to the owner because there's no cash flows left right so we'll run this deletion okay the next thing we'll do is check if the outflow rate is not equal to zero so if there's already a pre-existing outflow and it's not equal to zero now it means that we need to update the flow because it means that the flow coming into the contract was changed so we'll update it and make sure that the flow rate coming in just matches the flow rate coming out that's all finally if none of those two things are true it means that there's no there was no stream that was existing into the contract yet so if there's no stream coming into the contract yet what we need to do is just open a stream to the owner of the nft right simple enough right the creation case the update case and the deletion case and all of that will run automatically whenever a stream is created into the contract and then when that stream again is updated and then when it's deleted so let's deploy this and test it live so what i've done is i'm using the hard hat deploy library which is a convenient way to deploy contracts you can also use the standard hard hat scripts but i have the the hard hat deploy library all set up here so i have this all set for the girly test net just like this and what i can do is just run mpx hardhat deploy and we'll do this on like i said go early it'll compile here i believe in just a second and then it will deploy for us all right so compiled successfully deploying any second now so when this deploys what we'll do is we'll take this here we go we have our address we'll take this and we'll then we'll write some scripts to send money into the contract update that stream and then delete that stream and just check to make sure that the contract is doing what we want it to do right so it's been deployed let me just copy this address and i'll go into our create flow script okay so we're going to use our sdk now to create a flow in javascript to show you i mean we've already shown you how you can create streams using solidity we can do the same thing in javascript and the process looks very very similar okay so here in the create flow script i'm just going to add the address to this variable that i have preset and what we're doing here is just initializing the sdk using this framework.create syntax here we're passing in the chain id we want to use in our case we're going to use the query test net so it's the chain id is five we're also going to just make sure that we have the url we want to use in my case i have an environment variable set up within an alchemy url which is just going to allow me to deploy to to guerli and what we're also going to do is we're just going to set up a signer here which basically just mirrors what an ethers signer is i could also just use ethers.getsigners and it would give me a signer that i can use as well so we have those things set up right we have a signer we have the super fluid framework which allows us to use the sdk now what i need to do is get the address of the token that we want to use and then create the stream so the first thing i need to do is get the address of the token in our case we're using diex this is the address that i passed in when i deployed the contract saying this was the accepted token i wanted to use for this contract so i'll use this to get the token you can just load it by symbol which is pretty cool on testnets we put a little f in front of the the tokens that have been deployed there just to denote that it's fake money and not real money so it's not real um gotta be careful with that and then here what we do is we we create the operation we want to execute and then we execute it right and we sign the message with the signer so here in this case we are going to create a flow using this this year so sf.cfav1.createflow we pass in the receiver which is the address of the tradable cash flow we're sending money into this contract we pass in the address of the token which i can get through calling the address of this and we pass in a flow rate as a string and this is just the number of tokens i want to send per second right this is going to be a pretty small amount because it's all denominated in way but it is some amount so let's let's send the stream into the contract here by running our script okay [Music] and then what i'm going to do actually first is go to the contract address on the superfluid console so like i said the console is very very useful for these kinds of operations the second the stream transaction propagates i'll be able to just search this address more easily because it will automatically pop up in the console so give me a second here here we go and we can see here that there's two streams now in relation to this contract we just created a stream and then remember that the expectation is that 100 of that stream value is sent out of that contract immediately right and that's what's happening right money's being streamed in and money's being streamed out in the same amount right so it's that simple now you have a tradable cash flow contract you can do the same thing and have the scaffolding for a really really interesting project this weekend if you fork this i could go through and update the flow and delete the flow but i think that would be a little bit tedious at this point because it is basically just the same thing the syntax is just slightly different in the sdk but that's the idea right if i were to trade this nft the cash flows are just going to follow the nft holder and yeah that's that's one very very powerful thing you can build on superfluid so if you have any questions on this please feel free to let me know i'll go back into into keno and just kind of finish out our presentation but i'd love to engage with any of you guys on this if you're interested so cool let's go back in and we'll wrap this up okay so we we left off on the tradable cash flow explaining it a little bit another thing i want to talk through is this program called superfluid reactor so what we really value with superfluid is becoming a developer platform that's part of our strategy here we want to integrate with existing web3 product projects that are used widely but also help you take whatever you're building to the next level so if you're if you're aspiring to be an entrepreneur in the space or just build a really valuable project that's maybe open source we want to talk to you right we just rolled out a program called superfluid reactor that you know the entire goal is that right we want to find people like yourself to launch and if you get into the to the program there's an application process but if you get into the program we'll provide the best mentorship we have um we will help you raise money we will connect you to other talent in the space we will help you find your first thousand users we allocate a lot of time to this so we'd love to help you we've had some success stories already in a less formalized way i mean the reactor program is very new but we've had protocols like ricochet exchange which is a dollar cost averaging application come through our system we've helped them quite a bit to get lots of users and get off the ground another is a protocol called huma finance that's allowing people like some of the the people at superfluid and maybe in this room to borrow money against their salary stream or earn passive yield using their salary stream and we've also had a protocol for web3 native subscriptions called stripe also come through our program who just raised a 2.5 million dollar pre-seed round a couple of months ago so lots of lots of success stories and we'd love for you guys to also be your own success stories if you'd like that's it for today if you want to get in touch you can find us this weekend i'll probably pull an all-nighter or two this weekend so if you're gonna sleep here i might also end up crashing here we'll see um you can find me on twitter at sfalmani5 and in discord it's mf superfluid so if you're interested in superfluid please feel free to reach out if you have any web3 questions more broadly let me know and i'm happy to chat through anything and yeah appreciate all of your time today thank you [Applause] testing testing testing okay are we ready to go i'm gonna assume so cool so hello everybody uh we got 30 minutes and we're going to talk a bit about privy and how you can use privy to build awesome apps to delight your users and protect them at the same time during this hackathon which is super cool so before we start i'll introduce myself so who am i so i like to describe web to me as like the past decade of what i've been doing which is a lot of web 2 stuff i worked at cruise self driving and pinterest social networking and a whole bunch of things and then six months ago what happened was my curiosity kind of led me down a web 3 rabbit hole where i decided to build an nft collection to kind of learn by building and i took the red pill and i swallowed really really hard and that just led me down a whole rabbit hole where i got really excited about all this tech learning solidity or the infra that was missing and that was there or the potential and so what that has led to is a career change and now i'm kind of a builder at privy which i'm going to talk to you about today i'm the creator of the blockchain smokers so this right here is blockchainsmoker1921 of my collection and i'm a big privacy tooling advocate and so i'm here today to talk to you about preview and what it can do to help you with your privacy infrastructure needs so how we're going to structure this we're going to talk a little bit about a problem that i like to call the user data problem after that we'll talk about how privy is a solution to this problem probably fixes this and finally we're going we'll get into the fun stuff with a live demo so what do i mean by the user data problem so if you've either developed or even been a user in web 3 you've probably seen and been confused by this screen and this screen like many others is kind of like displaying the underlying issue that sessions are really hard and having a session that kind of propagates between experiences is a very challenging problem uh to the point where even great companies like metamask do a poor job now in addition to this we have another problem in web 3 which is kind of shocking and there's a there's a tweet here from earlier this year which is kind of funny and sad at the same time where megadow like kind of couldn't reach out to some guy because they only had the wallet address on their lists and if they couldn't reach out to him within us an amount of time they were going to have to dump 600 million worth of eth now this is crazy and this is because notifying off chain is kind of unsolved which is wild like web 3 has a lot to do still that's crazy let's talk a bit about a positive example so here we have like the openc profile page and you'll find profile pages like this on a lot of web 3d apps um and what do you see here you see like some information about the user some of it is public like the username and the bio but then other stuff like the email maybe in this case there's none but there could be like other kind of kyc data and you want to handle those like you want to have those so you can create personalized experiences like users come back to your app if it has a delightful experience and you can only really do that if you personalize and you can only really personalize if you have this kind of personal information so the life form which experiences require personalization for that we need two things at the very core you could you need more but at the very core you need user sessions for like in between session state and you need user tables to persist that state and to persist user information between sessions okay so we want to save user data what do we do that's hard and there's a debate about this right now you may have heard this debate the on-chain versus on-chain problem i think vitalik was on a podcast recently literally debating this like two weeks ago and there's a lot of it's just it's not clear where the limit should be but i think it's very clear that there should be a limit and some data should never be unshame and the example i like to give is like your social security number you probably don't want that to be unchained ever right and so if some stuff is on chain and some stuff is off chain then we need to bridge that and so let's say your ledger and you're keeping user data like name postal address all these things off-chain well guess what you can do it wrong it's actually very hard to get right and so ledger had a they got porn basically where like they were doing great on their security for their um hardware wallets but they were doing a lot less great on their postgres db that had pii data in plain text that got hacked and this shows that like when you do decide to kind of take user data off chain doing it right is really risky okay if you are going to do it there's an old ada oh a famous adage that says don't roll your own crypto now there's a reason for this it's really hard um there's many mistakes you can fall into which are typically terrible for you like timing attacks and brute force attacks and weak randomness attacks architecture flaws which is a really big one injection attacks and i could go on now you can build your own crypto but if you are going to do it you have to do it right and doing it right takes an insane amount of time and energy and expertise now you could choose to do this but typically when you're building adapt that's not where you want to spend your time and expertise and that's why you kind of shouldn't so we have a problem here right great products require personalization pii but collecting that is risky and if you do collect it it's hard privacy matters this is a big one i really like this one like one of the reasons why i kind of pivoted my career to web3 is that i think the web 2 got something really really wrong and it's privacy and a lot of these business models are kind of built around an asymmetrical kind of knowledge of the users and in web 3 we have a crazy good opportunity to redefine how we do privacy and how we do interoperability of privacy and that's really cool and finally we need a bridge for offchain data as we discussed cool so we have an issue um and this is where privy comes in and i'm going to talk about it in a second but you can find our homepage at providerio and i'm going to talk now about like kind of what it is and what we do and you can follow along with blobby who's our mascot on the second one cute little ghost cool so what is privy now at its core our mission is very simple we want to allow you to associate user data to wallets privately so bridging on and off chain data now at a very high level like the most core kind of thing we use in our js libraries oh actually i'll get that in a second so first of all like in a few bullets what do we do we have apis they're very simple we have js uh javascript libraries and these help you manage your off-chain data we have end-to-end encryption user storage so how does that work that means that like on the client everything gets encrypted and then gets sent over the wire like as ciphertext and then you get it back as ciphertext and you're going to grip it on the client and i'll go deeper into this but basically what it means is you have end-to-end encryption storage which is the right way to do kind of privacy and we also have sign-in rate ethereum session management which kind of solves those two issues i was talking about of data persistence and session management we also have transparent cryptography we're building in public and our crypto libraries are all open source and privy can never see your data in plain text the way we architected this is like we never see it and finally privy is ready to use right now and honestly it's going to make you kind of develop on steroids cool so at a very high level what does our architecture look like at a high level so at the bottom there you have the browser that's why you the developer is building a dab and that's where your stuff lives and maybe you have some unchained components which are on the right and then you kind of want to link your user which is in this case represented by the encryption keys in the metamask logo like you kind of want to link that and associate some off-chain user data with it and that's where privy comes in and you can see that like from the browser you can interact directly with our permissions engine which we'll get into in our data store to store and retrieve this user data so how do you do that what does it actually look like so and this is where like this is really if you're going to remember one thing from this talk remember this slide this is like the thing that's super powerful that privy does it has two cores privy put and privy get right so in this example i have a user id which is ox872 and i'm not going to read it all and in the first four lines i'm kind of calling i'm saving two fields email and age and i'm saving them to the descriptive data store and then on the second i'm just retrieving them now this looks really basic but actually there's a lot of stuff that goes into this so for this put call what's going on is like on the front end preview is first checking with our permissions engine that whoever is authenticated with the session whether it be the user or the developer like your app or a public kind of uh authentication like if they have access to this field right or read access depending on if they do we kind of encrypt it all on the client and then send the ciphertext up and then for privyget you're doing the same thing you're kind of checking with the permissions engine if the person that's requiring these fields is allowed to see them and if they are then you're retrieving that as ciphertext and decrypting everything on the client so this is ridiculous like you're doing so much in like so few characters with put and get you're kind of doing user data kind of encrypted storage in like the best manner possible it's awesome so that's for storage and the other critical part is sessions which i mentioned earlier so how do sessions look like so what we built and this is because after building a few apps we realized that session management is something that is like a key pain we built like a wrapper that makes it really easy to like kind of manage user sessions so this uses like um in-browser providers like mender miles called coinbase wallet and so in this slide it's kind of showing you like the api of our cv session cb stands for sign in with ethereum which is an eap standard and so you're initializing the session here and then you're just authenticating the user that's going to call up like the metamask notification they're going to sign a message you're going to know it's there and then basically under the hood we're saving things to local storage and we're persisting that like in between your views and then you can also create a client with that session and then you know who's authenticated it's the user that signed that message right so when you decide to retrieve fields later you know that who it is and so if there are fields that only the user can see they can see them and so in this last line i'm doing that i'm getting the email and maybe in this case only the user can view their own email cool so that's storage and sessions done so let's recap real quick with privet you can kind of get back to building products really quickly and you can do it right and doing it right used to be really hard you no longer have to have this trade-off we think that's really exciting you have you can store encrypted user data you can use signing with ethereum sessions and by the way everything i just showed you you don't even need a back end this is why this is a very hackathon friendly project you could just do this in two seconds with only a front-end so we do have a console which you'll need if you don't have a back-end to kind of admin your fields and your permissions and i'll get into this we'll see how it works in the demo cool so we talked about the privacy problem we talked about the previous solution and now i have time to do a live demo with privy flush now i hope the wi-fi is going to be stable because it was a bit flaky earlier now before we get into the demo i want to do a very quick primer on permissions but if you're a developer this is probably sounding very familiar most things are defined by who can read them and who can write them this is true of like unix files all the way to like in privy the field so in privy each field has read and write permissions associated with it and who are the roles like who essentially could can read and write and there are three in privy there's self and that's the authenticated user think the user that kind of signed the message with the uh metamouse wallet there's admin that's you the developer that's kind of passing in the secret and public api keys that you got from us and then there's public and so you can imagine any kind of combination of these exactly like you schmod kind of like files on unix to see who can read and write them cool so i'm going to show you a demo and then we'll dive into the code on how it's working so the demo is this fun little app called privy flush which is kind of like encrypted dropbox where you can send encrypted files to an ethereum address so like everybody has an inbox by default and you could send the file to someone so you maybe use this to like send a love letter that was very secret or maybe you were a bit more serious and wants to send like kyc data like someone's passport photo or driving license cool so i'm going to switch to the browser now so here we go this is privy flush please appreciate my design skills so here what's going to happen um is that we're not logged in so i can't do anything yet but i'm going to sign in with ethereum and to make things more clear for you guys i have two kind of um addresses i'm using here like my primary my secondary on my metamask and i put them here like my private my primary is 1d4a and my secondary is ox885 cool so i'm going to sign in with my primary here we go so i'm signing in with ethereum and this is the sign in with ethereum standard by the way which is an eap that's super simple and it's just like it's normalizing and standardizing what this string looks like so that we get metadata that is a machine possible so we're signing this and now like the app knows that i'm signed in as uh this metamask account which for me is called pushx cool so my inbox is empty and i'm signed in as one ox1da4 so it's this guy right and i'm gonna send a file and for now i'm gonna send the file for myself and so this is the file it's this uh driving license that i photoshopped i'm a developer not a designer so please forgive me and so i'm just going to send it to myself so i'm just going to copy the address from here and i'm going to put it in there i want an address and send and it is flushing okay so hopefully it worked and now i'm going to refresh the page and you got mail look at that and so now i can download and indeed i can see this so i just want to go over what happened here like i uploaded i encrypted the file all on the client then i saved like the encrypted ciphertext somewhere and then i could retrieve it at a later time but when i retrieved it when i hit download like on the client we just downloaded the ciphertext and the privy client was decrypting it so that's super cool we just implemented like dropbox but with encryption out of nowhere and i'll show you how quick it was it's kind of crazy now there's a problem here though i can't send files to other addresses so i'll try i'll show i'll show you that it fails so i'm going to try and send like the same uh oops i don't know what i picked there i'm going to refresh something terrible has happened one second ah i think you may be onto something no that's not it uh let me let me try hard quitting i'm gonna restart the server this is what live demos are and this is what we're here for okay restarting the server see if that refreshes things localhost 3000 here we go i'm still logged in here we go yay okay so i'm going to try and send it and we said i'm going to try and send it to the second address who is not me right i'm logged in as ox1da and sending it to ox885 and so when i do this i'm here when i do this i'm going to get an error the error is not permitted to perform this operation on the field cool so why is that that's actually super simple if we go to the console so we see the the field here by the way it's inbox that's the inbox for the user the permissions itself and so that means that i can read and i can write only me self being the authenticated user so what i need to do is change this and i'm going to change it to uh we need a special access group actually so let's create that we're going to do one where anybody can write to me and only i can read so i'm going to create an access group i'm going to call it public write self read and i'm going to say only i can read and anybody can write so anybody can write me like a love message so i'm saving this and now i'm going to say for my fields for my inbox field i'm going to edit it and i'm going to say the default permissions are public write self-read cool so now anybody can write me so we've saved it now let's go back to our app here and i'm going to try i'm going to refresh and i'm going to basically try this again but try a different file this is this is another nft so i'm going to send this and we're going to send it to the 085 and it's going to flush cool and now i won't see it here right so what i need to do is sign out and then sign in with the other address and we'll go and see if we got it back signing in with ethereum not connected this should work come on okay one second i'm going to see if maybe it's because i'm con sessions are hard this is what i was telling you so maybe if i disconnect this and i switch to this and i kind of refresh now i sign in there we go sessions are hard so i'm logging in as the second address oh there we go it was it had the queued things and we should have the file which we don't so this something went wrong okay i'm not going to live debug we should see it here and i probably made a mistake copy pasting the address i apologize about that cool so the demo is done i want to kind of kind of show what it would look like if we wanted to add a field so let's jump into the code real quick so this is by the way there's a lot of boilerplate code here but it's just like a create next app so if you're familiar with javascript and next this is like pretty straightforward so i'm going to go to like the pages and there's the main page which is index and that's where most of the code that we're doing lives so here we're using a session which is using our signing with uh ethereum sessions that i talked about earlier it's using a react hook to kind of persist it throughout pages but what we care about and i'm going to look for it is privy.session.privy which is where all the privy interactions are happening so we can see there's really two two places where this is in action and it's like on page load we're loading the inbox by doing a session.privy.com file and we're saying for the logged in address get the inbox field and then the second one is on the send which is the hook of when you post a form it's saying put file and you're giving it to the destination address and you're posting it to the field inbox and you're part pasting the file so real quick what would it look like to kind of add a message let's say we wanted to build over the hackathon i don't know encrypted messaging you could do this with privy really easily now i'm going to just create a new field here i'm going to call it message i'm going to do the same public read self-read kind of permissions cool and then in my app i'm going to create a new constant this is like a react hook so i'm going to call it message and a hook to call it set message and this is oops and this is used it's true it's a string and we default it to the empty string cool thank you very much i forgot the closing bracket uh the the computer's like this and it's just breaking my wrists cool so then we're going to get it here const message and we're going to do the same thing dot session.privy.get remember that and we're calling the session the address that's for the oops for the logged in user and the field was called message cool so we're getting it and then if it exists because it could be no let's set it set set message okay message here we go dot text so this is like a privy client thing cool so if we get it we're setting it to the variable message so now we have kind of the message in our handler memory in the thing message we need to go and display it so let's go display but beneath you got mail so this is where you got mail is so if you do i'm going to kind of add a div that just shows the message and i guess we could i guess we could show this only if the message exists which in react you do like this there we go cool so um what i forgot to do is that when i'm sending it um we need to set something to the message so for now let's go let's go write hello world so i'm going to do an away session.privy.put this time it's just put destination address uh the field is message and let's just say whatever you guys want nyc hello world and you could obviously make this more dynamic but i'm keeping it simple for now cool so now we're saving it uh when we upload the form and we're hard-coding it to this message and then we're going to get it so let's go try it out so we'll go back to privy flush so now i'm going to send a file to myself so i'm logged in as ox85 so i'm going to send it i'll make sure to send it to that so i'll send this loverboy and i'll send it to myself oh at x65 here we go it's flashing cool i'm gonna refresh i'm something's not going right and i don't know what it is although it is it was just slow you got mail and why don't we see the message [Music] let's go see in a console we can actually view data and so for the user ox885 there is a message i can't see it by the way this is cool so because like only the user self can see it like me as the admin can't see it um and so here it's not there but there is a field and it's it's there somewhere so i wonder why it's not seeing it i promised this was working earlier message dot text sessionprofit.get okay i'm not going to debug this live i'm just going to do one last thing message and it was called message yeah this should work i can't think about why it's not okay um one last time okay i will i will debug this and send it in in our discord later i'm sorry about that cool i'll go back to the demo because we have only a few minutes left um so i just want to kind of emphasize it's broken at the end here but i promise it works i want to emphasize how easy it is to build like really powerful powerful kind of things with privy and so the demo i gave you is like encrypted files or like sending encrypted messages but you can actually go and see at demo.privy.io we have a few others we have like a pii demo let's say you're like an ft marketplace or someone who has to do kyc requirements you could collect them here uh you could go see that we have a send demo that shows how to collect email addresses to then notify your users and we have a quick start to get going and all this is open source by the way you can go find all our stuff at github previo cool so let's go back to our presentation so for this hackathon you can kind of find us at privy io you can make an account right now at console.private.io our documentation is at dockstop provider io we have a discord and we have prizes so if you build anything with privy kind of we're going to consider you for this price you should go ahead and so our three categories are best data driven ux most interesting data stored and most creative cool so i have a few minutes left i will take your questions how does it work okay so uh i wish i had the architecture diagram i'm going to kind of talk you through it then so the way it works is we use um okay i don't want to get this wrong live we because like the cryptographers have a whole thing here but like we use like a hardware security module which is like a dedicated hardware that's the uh whose job it is to only kind of handle private keys and sign things and for each customer they have like a root key that's in that module and then we use that to like sign the right keys for each field and so when you kind of request a field both to save or to put you first go through up a missing permissions engine we know kind of who you are and we can say this person can or cannot see the field and if you can then we go and fetch the rookie we ask it to like create a public private symmetrical key pair and we sign the field with that and that's how you do it like on the front and back end now we can get into like much more detail here and like we this is public and we want it to be publicly auditable so like come see me after and i can kind of redirect you to the cryptography people of my company because it's not my specialty and i don't want to miss them that's a great question um right now there's i mean so i don't want to talk too much about pricing but like right now you can send pretty much anything because we have free tiers and in the first month it's fine down the line you'll be there'll be pricing per user and so like it'll you'll kind of pay for usage there yep great question so the question is is it only about encryption or does it also have like storage plugins like ipfs so it's a really good question so right now the way we architected it we can kind of swap out the storage component so right now it's kind of owned by us in our cloud storage but down the line we absolutely have plans so that you can kind of swap it out to either on-prem or ipfs airwave or whatever you want like the storage is completely decoupled right like there's the permissions engine that checks the permissions and then there's like the encryption that happens on the client and then you're sending ciphertext so you could really store it anywhere and so that's something we plan to kind of open up later cool thank you you 