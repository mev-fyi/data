foreign [Applause] [Music] so a quick question into the audience so who of you knows what is the graph okay we can do some introductory then who already wrote the sub graph okay and who already wrote the smart contract okay now better and um who plans to write a smart contract cool all right that's uh yeah that's good okay that's good all right so my name is um Simon I am a Solutions engineer at Edge node that's the one of the core devs core Dev teams that work on the graph protocol and um yeah and today I or tonight I show you how how to use the graph and um this time I think I start this presentation with this is what you can get like if you use the graph we have um two tracks the one is a best new sub graph that's the first thing we will look at um the best one will get uh two thousand two hundred dollars runner up 800 and then you can also use existing subgraphs there are tones that will show you where you find them and uh because this is much easier the bound is a little bit lower so I would say the strategy here is if you're a good if you are a good developer and you want to go for the higher Bounty then you would do that but it takes more time whereas when you use an existing subgraph it might be more competition but um yeah let's see um the thing is a lot of hackers usually start um with this one remix um do who who uses remix for the smart contract development yeah and especially the beginners first use remix um before before they start to use more sophisticated tools like Foundry hard hat and that kind of stuff that's why I show you quickly how you do it in remix so when you run remix what you usually do is like you create a new workspace and then you let's say we create an nft nfts are cool maybe a little it's almost a little bit over but um yeah we can still do one and um so it's cool so you can just start with a template and then you can say Okay I want a mintable burnable possible yeah whatever and uh this we don't need upgradability I believe in smart contracts should if possible be Atomic and unchangeable huh um cool and that's it then you just click OK and then it generates you this token um you have this functions so you can pause it you can mint it and it's using the open sapling standard so that's already good so I can say like yeah this is now the Simon token St and when I save it compiles in the background it creates all this stuff but actually at some point you are finished and then you want to deploy it so let's go to um girly Network and you will just say Okay I want to use the injected provider and then we deploy you sign the transaction and it deploys the contract so now you already have your contract deployed almost there right there um it's a Sunday morning and you think like okay I want to build my front end on top of it I don't know who tried to get data from a smart contract with the Json RPC providers but in my opinion it's a bit a mess I can show you it looks like this so you you write codes that that you you Loop over you to these callbacks back and forth and and try to get it and when someone has 10 nfts with that code and that's code that I saw in the wild actually I and every all of these calls to the Json RPC endpoints that take 200 to 300 milliseconds you easily end up with three four five seconds load time of your website right I mean that's not cool um so we have the contract now deployed that's very cool so what you do next is you verify the contract it's very important I never interact with any contract that's not verified I mean you never know right so how can we use this in remix so there is a plugin called the flattener so if you're here and you don't find it you're just doing the flattener you click on activate and then you go here and then you just say like flatten my contract and now immediately the whole flattened source code that means all these Imports are created in one file or in your clipboard then I can just go here and it works actually more or less the same on any chain so you can do this on polygon on mainnet on Mumbai you just say verify and publish then um you have to contact the address here compiler type is solidity single file um the compiler version is usually um 8.0 you can check here which one it is right open source license MIT then we go forward paste just the code that we have in the thing you prove that you're not a robot own boats and then your your smart contract will be verified nice um cool and now you're actually ready oh cheat sheets can I so um she has cheat sheets that help you uh um with these steps to remember um so so please uh raise your hand if you want one and now the next step is uh you actually now want to have a subgraph so you have a smart contract it's verified and we now want to have a sub graph that that I can use we want to have a cool a nice graphical API I want to have something like this I want to have a graphql API to get my data out that's very beautiful all the front-end developers know that's the way to go all right so what do I do I go to the graph.com oh wait or the browser the graph.com when you are on girly or anything you may net you choose here uh soup craft studio if you are any other chain polygon Mumbai sailor whatever optimism you go to hosted service but because we are on girly we take um subcraft studio so I go here um usually you connect first I want to show you all these steps so you connect you take metamask pop-up comes you sign in you sign that's it you're here you create and they say I want to actually make a subcraft so you create and create a subgraph you say which chain you are indexing it was girly so thirdly how do I name it I name it um nft nothing special all right continue that's it now when you are here there are like instructions what you can what you should do it's the same on the cheat sheet so you should install the graph protocol CLI globally and then uh yeah and then you can actually say graph init Dash Studio Simon's nft that sounds interesting so let's do this now here comes the trick I've wrote it also on the cheat sheet but um the trick here to get started quickly is like dash dash index Dash events right this is the magic thing that helps you to get started quickly right now let's let's do it now we have a nice dialogue that we can go through and it says which protocol do we use um the graph supports rvf near ethereum like ethereum think of even compatible and uh and Cosmos but we are here with ethereum it's a if Global hackathon so ethereum and the subgraphs log it's already here we don't need we can just take it then the directory that probably sounds good then I check the network I take gerlin right and now we need the contract address the contract address is here this one you can just copy and paste ah I hope that this will work and check okay just try again all right sometimes you just need to try again twice so it takes some time until the API is available on etherscan but yeah like if it doesn't work there is this thing like if it doesn't work turn it off and on again right okay so it's a Simon's nft give just a name and boom the sub graph is created for you in the background now we actually don't need to do much we don't need to understand what how to write a subgraph how this works what is the schema what is whatever when we want to get started we can just follow the instructions here so you go into the directory you can do this in a new window while it's installing then we uh actually we do we do the authentication so we need to load the API um key that we can deploy so I do this and now the deploy key is set and here now in the background everything is already installed it asks me if I want to do another contract but we are good like just just go with this that's it and now I can just say graph deploy um or actually I need to change here and now I can just graph deploy to the studio I just followed these steps that are that are written there which are also on the cheat sheet I return I need to give a version label let's say it's one and boom it's deployed that's it now I can go here [Music] and and go into this URL and here I have a Graphic URL interface now unfortunately currently we have this problem that if you just follow the steps that I did there is one small missing piece that we can now do together I mean eventually the sub graph will start to index but we can speed it up with this little trick that I show you right now so we could just look at the code and the subgraph basically uh the main thing you're interested in is to manifest like the subgraph yaml so here the trick is everything is already set up for for us but what we need to do in Source like we need to add a start block so that that the graph node on in the studio knows where to start indexing how do we find the star block we look at the transaction where the contract was deployed and we check the block and we just copy paste all right boom save and redeploy now it's version two all right let's see what the studio now thinks about this it's fully indexed so that was better right now we can also go into this again and uh there's also the playground so what is probably interesting if nfts we see transfer events right so the playground is cool because it helps you it has here a graphic URL Explorer so we don't really need to understand everything so you can just click around here and say actually I'm interested in the transfers and maybe I want to have the from the ID the two and the token ID and then it just builds you the graphql query you don't even need to understand graphql in detail but when you have a front-ender in your team they know right and then you can send it and oh we don't have any transfers but I mean it's a fresh contract if you're in remix it's very easy you can just go where is it here this one thanks I'm I'm not using remix usually I need some help so what I can do here is save mint so I can just say okay I mint myself an nft copy the address click token ID and then send it boom and check on ethoscan if it comes through that probably takes a while um cool so so this is this is the easy thing so you can quickly get started with a sub graph you don't need to do you don't need to know much about it you can just follow these steps I repeat you go to to remix you deploy a contract you verify the contract then you go to the graph Studio or hosted service then you log in and create a subgraph and then you go into the terminal and very important here is this um where is it this one graph init dash dash index events and that will scaffold you a subgraph that has for every event on your smart contract an entity and auto generated mappings and you can just get started I I think the transaction should be included so we go now back to the software Studio we send the query again and we see our we see our transfer event here it's very easy now you are already get get started you have like a contract deployed you have a subgraph you have a graphql interface now you just need to code a little bit front and then you're actually done you can go home and enjoy maybe Sunday Saturday night parties here in San Francisco um but yeah there's probably more um and we can go into this so for those that don't know what the graph is I give you quickly the theory behind now that we saw the practice already so when you think about the the the the data on chain we currently have a state in the in the thing thinking of nfts you can think about this Google sheet where you have like a token ID and an owner so the blockchain always knows who owns Which nft but what about the provenance who owned the nft before so we know that the blockchain is this this thing with the transactions on top of each other and so we should know but it's not easy to get to the old data not you need to kind of dig through it so and it would be nice to have this time machine can just go and back in time and then you see how this this owns changed that's actually what the graph helps you with so initially the idea for depths like this decentralized applications was that you have a front-end that's a JavaScript HTML and CSS deployed to ipfs or another decentralized storage and it directly communicates with the blockchain um the problem here is the blockchain is optimized for writing you pay the miners so they introduce your transaction but like when you read from the blockchain how does this actually work I mean in theory you can communicate with a node that you should run at home but a question like who who runs an ethereum node at home oh yeah some some yeah you can communicate with that note but the Json RPC interface that you communicate with it it's not actually made for building a front-end it's made for you for you managing your node and maybe send a transaction and do some inspections and also there is there is no incentivization if you don't run the note by yourself like who gives you that data I mean sure there are like some centralized providers that give you access to Json RPC endpoints but that was not the idea of a decentralized system so you end up with stuff like this when you get the data out so what a modern architecture would look like is you have a front end that writes to the blockchain that that works that's cool and then when you want to read data you go through an indexing protocol like the graph that gives you decentralized access to data now the graph network is already live since one year for ethereum mainnet and you can have fully decentralized subgraph state of the thing that we built before and the thing is you pay per query by paying for queries the incentivization structure for the data delivery is given um yeah so that's the graph you know the apis for this decentralized future oops where are we um on the host service the graph currently serves um one billion queries a day that's quite a lot um and you know big user like uni swap audios unlock protocol and others using it uh teller also actually but there those two already are on the decentralized network and um now since one year we launched the centralized Network you have um 224 indexes worldwide that are independent the index your subgraph and they're participating in the network of incentives they receive query fees they receive indexing rewards and that makes it um redundant right if one index goes down another is around to serve your queries and so that gives you fast cheap and reliable apis in a decentralized way and that brings us together through a Global open API where all the data is available and for you um yeah so we can have truly decentralized apps um we quickly touched the sub graph so so basically all these transactions are a mess you know on touch of each other and just and a sub graph creates um these these focused databases if you want that that you can you can save what you want in your database so if you write the subgraph for your specific contract or a protocol that you write on this on this weekend then you just say like okay I'm interested in this contract and interested in this event and that transaction that's how I want to store my data and then it will be there otherwise it will be very hard to get that data so you have full control over which data you want to store and how you want to store it and then later on you can just query it um so this is roughly how it works so the depth on the right side we saw this we write transactions to the blockchain the blockchains get in they emit the events in in what for nfts these are transfer events um they are emitted and then the graph node is configured to index those events or to ingest then you run a mappings code that you also can enhance if you want to get the price for the best new subgraph you should really enhance your mappings and not just do this what I did but it's a good starting point it will be stored in a database so on the other hand side on the left side you see um there are you send queries which go to this graphical API and will be served by the graph node that's roughly the system architecture here um yeah that's actually then how it looks so you have this this mess of um subgraphs uh data and in the end magically it gets ordered and um you have a very good overview what's going on cool so now if you want you can scan the QR code and tweet that you just learned about the graph or not all right um so if you wanna now peer pressure starts cool um yeah we we did this already that the subgraph stuff um but actually we can now go a little bit into the code so we we barely touched on the subcraft yaml that this holds it together in the subgraph yaml you define which which chain I'm interested in what is the address that I want to index what's the start block what is the ABI you see the API is copied here that was created magically for us and also which event handlers that you are interested in so because we use the ownable possible whatever event handler uh open sapling templates you have all these uh these events here but for for nfts you're mostly interested in transfer so that's the the yaml the yaml also says ver is the schema so the schema when you look at the schema it's it it's it's really just defines a database you say okay there is a one table with approval and approvals have an ID and owners which is represented as a bytes and and approved and token ID and so this is all just Auto generated according to your contract but you're free to change this right so you could say yeah actually I'm also interested in the block number so you write block number and say it's a big end and then you can uh extend your subgraph from here then the the third part is the actual mapping so the mappings they are written in the language called assembly script it looks similar to typescript but it has a small Nuance differences so for example you cannot just import the JavaScript packages here you only only the assembly script stuff but um yeah it's pretty cool and because for example vs code knows about you can also start to explore so we can see it for example what is then in the event what do we have here and that you usually this command click and then you see you go into the event and then see okay it's approval event these are the properties I can also see what is actually here what is in a ethereum event then I see oh there is transaction or there is a block let me see what's in the block and then we see oh okay we have to block hash timestamp and so on and so forth so then I could say I added this block number here but you would do as a next step is you just do yarn code gen when you change the schema you need to run a code chain again which generates this uh this stuff and then I go here to handle transfer and make entity dot block number and see now because I did code chain it already knows that the entity has a block number equals event that's also been explored before on the event we have block so I'll type B and you see like you can explore it here it's not so complex number that's it and I can save and I can redeploy version three cool so that's roughly how our subgraph works and how you can um extend it and and really you know build your magic you can come up with new entities that make more sense not just the events for nfts for example we want to have the holders the actual nfts then maybe the sales or whatever it's up to you um we are already almost at the end what I want to show you quickly is uh this QR code this time it's not there for for a tweet this will bring you actually to a repository that I created for this hackathon um that has all the all the example code the link to that presentation a link to the cheat sheet so if you if you have you rather want to have it digitally and um yeah and and more so so really a good starting point for a hackathon focused also if you if you go there um you see I have you wanna you need to pack thank you I also added some interesting stuff for you next especially the good sub graphs so that so so here's the trick when you when you're on a hackathon you want to get as much bounties as possible for different sponsors right so that's why they're sponsoring and um an easy thing to do actually is you go to do you look for the sub graft of the sponsors that you're interested to build upon and then you use that sub graph and to make a cool integration if you do a cool usage with a special stuff maybe you do some machine learning on top of it or whatever then you come into a good position to get the best usage of existing subgraph so I have here so for once we have the mysterious upgraphs it's a very high quality me sorry joined as a core Dev for the graph ecosystem and they are writing standardized subgraphs over these um you know different verticals so we have for exchanges ERC um governance and they all have the same schema so you can Aggregate and compare and and do fancy stuff so you can you can click on those and and then you are um yeah you can you find you find uh the links and you can also in inspect you see events or and they have some charts so that that's that's that's very good the nsari stuff but also other sponsors for example land protocol I know they have their own API um that they have their centralized API but there is also a subgraph and so if you want to build something on lens you might want to check out that subgraph and see how far you can get because if you have a good application on top of the lens sub graph you might be eligible for both the lens and the graph Bounty and so on and so it goes also unlock protocol which we'll see later here um openc that's a sponsor linear as an example how to how a subgrapher near Works a very interesting uh how they go check what's up graph that's on polygon yeah so you can check this stuff here um yeah I think um I'll leave it here we are at the booth I try to be there as much as possible and so if you have any questions just uh come by and we look at it together and if you have any questions now I think I have another two minutes to answer questions so please shoot them thanks yes good question all right so the the the code the mapping code it takes a while to run it it depends on how efficient you write it so rule of thumb is do not do not do if calls do not call back if possible um but but usually it's a matter of milliseconds like if you do not do very complex stuff so you saw before I just created that transaction the block the block gets mined and then more or less half a second later you have it in the sub graph and if you want to know uh which block that your subgraph is indexed there is this um special thing here uh yeah so we had transfers it's the it's the it's the meta key so with meta block timestamp and number that you can you can query for oh I created the new version all right let's do it again Amanda block timestamp number you see um this is the latest block that you subscribe that the graph notes are this or the sub graph and this is this timestamp so that helps you to build a front-end that knows how fresh the data is one more question otherwise yeah yes when they when they when they when you send a query they respond to that query and they give you a query attestation and they have uh trt staked so if they give you the response and uh it was wrong you can prove them prove them wrong there are also fishermen that observe this and then they get slashed and the fishermen get part of the slashing and uh but we're working on a thing called verifiable queries so that you will have a a proof that it's everything is true but I mean this is a little bit hard mathematical problem um but that's on the roadmap thank you so much for having me and uh yeah happy hacking 