intro about what life peer is life here is building the video streaming layer of web3 we've been building this project for the past five years we've been we've gone through many iterations currently the the network processes about two and a half to three million minutes of video per week um you know those videos are viewed by many million number of users um so so a just a quick overview about video technology right so video is about 82 percent of all the data in the world today all 82 of all the data on the internet needless to say that's the majority of the content that we consume on a daily basis and that's why life here is excited to be working on this technology and to decentralize the infrastructure so so when we talk about video infrastructure and video streaming technology like what like what is it how is it how is it done right there's really three steps there is kind of the ingest and upload step there is the video playback step and then there's the video processing step right we're going to go into each of those steps just quickly so that we can set the right context so here it's a kind of a typical architecture of a video application of today right where um it looks a little complex i'll go through each of the steps so it doesn't look so complex anymore the first step we talk about video ingest and upload right so this is really dependent on if you're building a video on demand application so something like a youtube where you upload a file and have it streamable by anyone on the web or if you're building a live streaming application which is something more like a twitch or facebook live right where people are watching you in the moment as things are happening so for live streaming it's about ingesting a live stream broadcasting it and for video on demand is about uploading a file into a back end and and on the receiving end usually there is a media server that's receiving the content right it speaks the language of the video protocol speak the language for also http if you want to upload it and and there's many different types of ingest tools that you can use right so oftentimes we think of especially for live streams we think about you can i you can either have a desktop-based broadcasting software something like a obs studio which is really popular amongst twitch streamers you can have a mobile app that that's broadcasting the video uh broadcast stream using the camera on the mobile phone or you can have an in-browser broadcasting studio that's only recently starting to get popular and and you know you might have heard of like a restream or things like that so but those are just end user tools right if you're a developer and you're building an application there are a couple a few sdks that can help you to build those types of experiences so for example there are there's a react native component called node media client that allows you to build a mobile broadcasting experience and then we've actually built a tool called webrt webrtmp that allows you to build a in-browser broadcasting experience that can you know capture the webcam on the on on the laptop right um so so that's a little bit about ingest the ingest is all about you know putting the video into into the backhand right and and now the video is in the backhand um how do you play that right so so here is delivery and playback video delivery is often times delivered through a content delivery network or shorthand cdn and this is because oftentimes there's you know tens of thousands or hundreds of thousands of people watching the same content in the case of a live stream you know if you're watching um the world cup or something there's millions of people around the world world watching the same stream right so in that case you really need a really scalable infrastructure to be able to deliver that kind of content and a content delivery network helps you do that or you can if you if you don't have that many viewers sometimes you can deliver directly from a media server and that's also possible but when you're delivering it you're delivering it to a video player on the client right so the video player can be you know either on the mobile phone or it could be in in a browser and and in terms of delivery and playback we think of hls which is the video streaming standard uh defined by apple um there is adaptive bitrate streaming which we're gonna go into later and then there's the video player right so let's first take a look at hls like what is hls like why um why is this thing interesting well hls is the file that you give to the video player in order for it to play right so the hls hls represents the video itself and the the um the format of hls is you know there's a playlist that describes kind of all the different small media segments and then there's the there's the media segments themselves right which is you know the video cut up into small chunks and then the the video player simply loads each of those chunks uh in a sequenced way and then they'll be they're able to play it back um in real time or sometimes if you have two exit you know it'll play faster than real time so that's really hls so when you're thinking about a video stream it's actually tiny little files that are that are making up this big stream um so that leads us to the second topic which is adaptive bitrate streaming and this is the secret sauce for how video is able to play on the internet in the first place right because if you think about this problem we're streaming video under all kinds of different networking connections from around the world on different types of devices different sizes of screens right there's so many different varieties but yet everybody expects to be able to watch the video just the same right so in order to do that um what we do is we transcode the video into many different versions of many different bit rates so that you know if i'm sitting at home watching a video on my smart tv i can watch like a really high resolution version of the video or if i take out my smartphone and start watching the same video it's going to be like a shrunken down and lower resolution video right and and when i'm loading that smaller video i can i can load the smaller bitrate video um and adaptive bitrate streaming is saying that when as you're streaming the video you can actually change the version and the resolution of the video that you're watching without a broken experience so for example if you're ever sitting at home and you um you watch netflix and it starts out really grainy and then it gets crisper over time that is adapted bitrate streaming in at play right so the smaller version comes on at the first at first because your networking is just kicking in and then as the video plays uh the player realizes oh you actually have a much higher uh network throughput and it starts loading the higher resolution version and this is very crucial for video streaming to work correctly online and we when we talk about video players right it's really a piece um you know a piece of software that you can put in your in your web application or you can put in your mobile app in order to play that hls video that i just talked about now there's there are many different many different sdks uh or products that you can use right there's open open source videos players or close or proprietary um video players here i'm just kind of sharing a few of them the most popular open source one is probably um video.js okay so that is kind of an overview of playback now let's talk about video processing right video processing is something that happens behind the bat in the background that most people don't know but it's actually a super super important step right we talk about that transcoding step and that's how we're able to enable that adaptive bitrate streaming way of streaming video right so usually when the video gets uploaded or ingested into the media server it gets sent to a transcoding engine that then transcodes the video and then puts it into a cdn or stores it into object storage the thing about transcoding is that it is super computationally intense right because you can imagine videos are very complex data structures and you have to kind of decode the video understand what it is re-encode the video into different versions store them somewhere and that's really that's really expensive process so transcoding you know work the workflow looks something like this right where you have that transcoding engine you can for example ingest like a 1080p version of video and you can transcode it down into a 720p and 480p and 360p and 240p and they're all appropriate for different device devices and different different networking conditions so that's a little bit overview of video streaming right so all of those pieces together makes video streaming work on the internet so now that's that's pretty complex for anybody here this weekend trying to build a hack you probably don't want to think about all those things and put all those things together that's that's way too much work so at lifepure we built a decentralized solution to make to make all of those complexities go away and to make it really affordable so how do we do that live pier at the core is a set of protocols um it's a protocol that allows people to contribute resources onto a network that then they can also get paid for contributing that resources the set of the and it's encoded as a set of smart contracts in solidity uh it's deployed on arbitrary uh it was first on on ethereum recently we migrated to arbitram um and and it acts in a few ways and one of the most important things that it does is that it acts as a global registry of these orchestrators that represent kind of transcoding capacity around the world so if i am a broadcaster or if i have a video that i need to transcode i can talk to this global registry and say hey tell me a list of people who have capacity that can do this work for me and through this discovery protocol i can not only get a list i can also kind of start testing oh who's who's closer to me right who has a good latency um with me has good connection with me and i can start sending my video to them and they can start transcoding that for me and of course the protocol also handles micropayment and all these things so the value transfer also happens and the orchestrators are incentivized to do that transcoding work right and the other thing that the the network does is that is highly redundant and what that means is you know there's lots of orchestrators around the world and there's lots there's always an over abundant amount of transcoding capacity on the network so that you know if one orchestrator all of a sudden goes offline so for example um you know i'm running i'm running an orchestrator in the data center and the data center loses power and everything goes offline and that's totally fine because the the software is resilient enough that it will just immediately fail over to another orchestrator and it'll continue to work right so even for a video live stream uh it won't disrupt the experience and the other thing that you can do is you can double up you can use you can use multiple orchestrators at the same time so that you know if one goes away it doesn't even matter in fact you can just have the two race right and whoever gets back to you first you use that one under the hood if you look at the live here protocol i'm not going to go into this whole complex graph right i just want to show this graph in that you know there's a smart contract right we have the broadcasters and the orchestrators and there's a verification process here to make sure when the broadcasters are working with the orchestrators um they don't need to inherently trust each other like you can just say i'm sending my video into the network and i can trust that the network will verify the work for me and and and i will always get the right results back and if i don't get the right results back there is heavy economical penalty uh so that it's highly disincentivized for someone to cheat very similar to kind of the blockchain design concept proof-of-stake concept right if a validator cheats then they get heavily slashed therefore they don't you don't want to cheat another important concept here is that there's an on-chain portion and an off-chain portion so and of course when we talk about video streaming there's going to be millions of video streams that are happening on the network right we can't be writing transactions for every single one of those streams so all of the video streaming steps within the lifetime networks happen in an off-chain way and the only thing that happened on the blockchain are the registrations of the nodes which happens only once in the node's whole lifetime and the payments which can be batched together and happen asynchronously okay so you know here i'm just going to go into a little bit of the token economics the way the way it works is that people stake their live peer tokens to the orchestrators and as the live peer tokens get sick to their orchestrators uh the orchestrators can earn live peer rewards and at the same time the people who want to transcode um their video with the with the network also paying in um also paying in in ether to transcode the video so as more demand goes on the network more um the more valuable the network becomes because essentially the life here token represents um the um the amount of revenue that you can capture for all the revenue that's going through the network right and then and then it kicks off this flywheel where the more the more demand on the network there is the more valuable there it becomes then it attracts more supply and then that that kind of wheel starts uh starts going so that's it um that's it's a little bit about the intro of live pier a little intro about uh video streaming now victor is going to show you some exciting demos around um around video on demand streaming and also around live streaming hello let me set this up hello right so uh i wanna show you the capabilities that we have in our in our service in our api and we're gonna start with the live streams so we have this dashboard page here with the streams you have in your account i'm already i have already registered i'm logged in here and you can create a stream from here but you would normally be doing this from your application so you you we have an api that you can use and you got an api key and then you can create all the objects on demand as your application logic requires and we can start here let me increase this so we can start here by by creating a new stream and you give it a name i'm setting it to record as well and here we have a fully created object and it has the configured renditions that you want for your for your playback so it controls how this screen is going to be transcoded and then here are the important bits right now which is the stream key and the playback id the stream key is the secret that you give to the to the user that is doing the streaming and they're it's going to give them right access to this stream to this channel and you also have the playback id which is the one you use for playback in the stream and it's more a little more public in that sense that many people will be watching but only one will be writing and here is the stream that we've just created and say this is an example application that can do video the live streaming from the browser using the sdk that we showed and all you need to do is to copy that stream key here so if you say your application creates the stream and then it's going to send this key to your application somehow and it's gonna it can start streaming to that channel and then if we see here in the dashboard the stream should now become active or maybe not yeah it did so it's too loading starting the the transcoding and everything and while it does that i can also show the playback application so this is just another example that has a video video.js player and all we need to do here is create this url which is the playback url you can also copy it from the dashboard so here is the playback url and this in the same way you are in your in a real application you would actually get this specific playback id from your server from your back end and then you inject in the front end and you can see the stream as it is happening and there's just a little delay of the actual transcoding of the stream but it's live coming from this web page here let me close this and this was using this webrtmp sdk that we showed which is made to for you to stream directly from the browser and it's good to do quick demonstrations or or start getting started with the live peer platform right so the other thing i can show you is the vod api and so we have here this other tab in the dashboard it's not the streams it's actually assets and it's where you can see all the files that you have uploaded to the api and the same way you can create an asset here by giving a url to import etc but i can also show that via the api here as well so the process there is actually done in two requests instead of one and first you request for an upload url that you're then gonna use to actually upload the file and this url here can be called from anywhere so the idea is that you create this this pre-signed url on the back end give it to the front-end application and the user can do the upload directly so you don't need to do any kind of proxies of the actual file then to use that url you just do a put with the file as the as the body and here it's already going and when you import that an asset you get a task that processes the asset until it's it has all the metadata and like the duration of the video bitrate all this kind of stuff and you can also call this other api here to list all the assets in the account you can also read individually but this is easier for now and here's the asset we just uploaded all the specs that we parsed and it also has a playback id and but let me show you in the dashboard so here it just showed up the one we just uploaded and it has a download url here which is actually how you can playback the the file so this is just plain an mp4 right now and we are working on adding hls support for assets as well but as soon as you upload the file to livebear you can already use it from this your this download url and here you can see that this one also showed up and it actually came from the recording of that stream the the first part of the demo and it's also it the recording also becomes an asset later and you can use it the same way and play back the the recorded stream as a as a video file or export it or even create an nft out of it and so let's go into the nft part exactly we have this sdk the video nft sdk that is built that builds on top of this vod api and you can use to easily create video nfts so it handles both the uploading of the file the processing in in the live peer network in case it in case is necessary and the export into apfs and then the actual minting of the nft from the exported file it can be used to build any kind of application you can use it from the front end from the back end from a cli and we actually have a couple of examples using that and i'm gonna show this one which is just an application on the front end and if you are logged in the dashboard you can go to just mint nft and you're gonna see this this ui here and let's use the same video file and this is just the smart contract that we have deployed by default but you can also use a custom erc 721 that you that you have and first up so it's doing the similar the same process that i just showed in on postman to the requested the upload real then actually sent the file then it did some processing and i'm gonna explain soon and then i already exported to apfs and it has this hash here this cid and it's already injected here and now we can actually mint with that cid and this this exporting here currently it's like we if you're using openc there is a file limit of 100 megabytes so if it's if the file is higher than that it's not going to show anything it's not going to show the preview of the file and but when you do it through the sdk it's going to check that and it can transcode the file to a lower quality just so it shows on openc and it's not just a blank nft over there and here we can see that it finished yeah so it's already available here on openc and i did it on testnet but it works on mainnet just fine and yeah back to the processing did we also intend to add support of to other kinds of things like if you upload a video that has a codec not supported on the internet on the web on most browsers we can also offer to to change that so we that's exactly where we plan on adding more and more functionality with the power of the live beer network and we can also go through the smart contract if there's time the so just to go go through quickly here i mentioned that you were you would be using just the default contract here but you can actually create on your own and just change the address here so the the sdk calls that that separate contract and you can do so following this guide here that is in the also in the documentation of the sdk and we have like the base code here for the contract and it's really simple just uh inheriting from an open zeppelin contract and then adding a simple logic on the mint that i can show here like we not gonna show here is better we just import the the contracts from the open zeppelin then have our custom one inheriting from it one that has the storage for for the nfts and then these counters just keeps track of the ids of the minted nfts to always create a new one uh with a different id and then we have this event here which is sent after the mint is done and is what the sdk relies on to show what was the the minted nft the minted id of the nft and then this is the main main function the sdk also relies on a signature like this and then it basically creates the new token id means it with for the for the respective owner and sets the uri to what is sent on the request here and that comes from that thing we saw here this is the token uri that went on that argument and then that's it it emits an event with which we can use in the front end to show any information about the the newly minted nft all the and finally all the other uh methods from erc 721 are already present in this contract just because it inherits from this so it supports any tool that relies on on these interfaces like openc itself so that's how it just shows up there as we mint it and i think that's it for the demo all right thank you victor um i want to spend just uh a few more minutes talking about prices and ideas that you can think about building for the hackathons today live here is um offering up sixteen thousand dollars of total prizes um i'm really excited to be to be here and working with the hackers here um the first prize is for six thousand dollars and we're looking for uh developers to build the killer video centric social media creator or gaming web 3 application this is an area that i think is ripe for disruption for web3 all of the components from infrastructure perspectives are here for us to create a web3 centric social media platform that can be comp that can be very competitive to today's platforms like a youtube or or a tick tock right so we're really looking forward to uh to seeing the creativity of of hackers here building building platforms like this uh the second uh the second price is for four thousand dollars and that's for the best use of the live peer video nft minting sdk that we just that we just showed we look forward to seeing how people can creatively use this asset of video nfts to do all kinds of interesting things right and think about um you know kind of thinking beyond the kind of the speculative use cases i think there's a lot of really interesting interesting areas that this can go to the third prize is for the best video on demand application using live pier so simple think about this as the web 3 youtube right how would youtube look different if it's built in a web 3 native way what kind of features would it have what kind of value proposition would it have for creators to be able to connect directly with their fans to be able to directly monetize the work that they do i think there's a lot of really interesting ideas in here and finally fourth place fourth price for two thousand dollars we have the best applications of life here in the metaverse right the metaverse can be interpreted in different ways i kind of think about the metaverse as this just already deployed and already running decentralized infrastructure in general instead of i think the more narrow definition would be kind of like a rendered 3d world right so thinking about using video streaming both video on demand and live streaming into the metaverse or from the metaverse to show kind of people not participating what's going on in there i think there's a lot of interesting use cases there as well so that's it um we i think have a couple minutes left uh if we have any questions from the audience um we're happy to happy to hear that right now i have a quick question on the um so when you showed the live videos of the stream that you just created during the demo so it was also uploaded as an asset the asset that is displayed there is it only one of the encodings that's there or is that also like in the different formats like different kilobit streams and so forth so so the asset that is created automatically is with the from the source video so it's just the highest quality version but when we also do have a recording that is the same hls that was made during the live stream so it has all the transcoded renditions and you can actually download those as mp4s as well but by default we create only the source any other questions from the audience all right thank you both for the overview on the demo given that you're thinking about video all the time building it from an infrastructure perspective if you had the time uh to to work on a hack what are some ideas that you would love just a spare extra 20 hours to work on using light beer maybe we can do we can search over yeah so something that would be really cool would be a mobile app using the the nft sdk and then you could just make a video and immediately make it into an nfg really really easily on on could be just like a camera phone that because that creates nfts out of every video that you create or something like that and i don't know could be also uh more more different video nfg so that you can create different interactions with video nfts like you can maybe split your nft into each one is one part of the video then you gift it to someone else and then you can merge them together if you have the continuous parts or i don't know some crazy stuff like like that that would be really cool to see um yeah there's so many so many interesting things that people can work on i have a couple of ideas um there's been a hundred applications over 100 applications built just in q1 alone on in live pier some of the things that are really interesting uh for example um the video streaming application for uh dev connect is actually built using live peer and is streamed with live pier uh it's called i think stream eth dot tv um one of the things one of the interesting things is it was a collaboration with between life here and ethereum uh the ethereum foundation one of the interesting things that we did is not only is it now completely open source anyone can take that website and just change make improvements on top of it um for example adding like a chat function or adding the login function so people log in with ethereum so people can see you know your your ens right things like that um but it's also componentized uh modularized so that for example the video player that's being used in its uh is actually a module and this video player has some interesting functionalities one is that you're able to have automatically have a primary and a backup stream so that you know when you're streaming an event you can have two streams going on in case the primary stream fails it automatically switch to the second stream and your user doesn't feel uh doesn't see any um didn't see any breakage in the experience but there's so much more that you can add in this video player right just think about what a web 3 native video player is can look like and what kind of functionality that you can have right if you can start tracking you can you can start allowing the viewers to log in with their metamask and show the nfts that they have in their wallet and the nfts can then that information can be sent to the broadcaster so the streamer themselves so the streamers can know the type of people who are watching their streams right and this kind of like an idea off the top of my head but um there's i guess the point that i'm trying to make is that there's a lot of really interesting toolkits that are already built within the live peer ecosystem that you can just take and make tweaks on top of it to add interesting functionalities and i'm pretty excited about that would it be possible to add extra transcoding steps like some kind of post-processing or like watermarking stuff like that yes absolutely you can do that um you can so everything in life here is open source right including the live peer node itself the live peer node currently handles video transcoding for different codecs it also handles smart smart smart av features so for example if you want to transcode but also do like scene detection to figure out if someone is like streaming adult content on your platform you can do that right so that that kind of gives you an idea of like how open-ended it can be when you talk about just open source and open video processing you can absolutely add water marking you can add com like compositing right to add different um kind of artifacts on top of that so it's not just a watermark it can become animated um yeah all kinds of uh all kinds of cool ideas that can that can come into that one i like it the other way around you know something is it's not like uh you know too dull but maybe too fast so you know like really catering towards people who cannot watch too fast stuff i just took the idea i don't have a question sorry thank you for your contribution any other questions oh one you mentioned that there's a penalty um similar to proof of stake i was just wondering what exactly is the penalty yeah that's a really great question so that's uh really in the in the core design of the life here protocol right and and the idea and the problem that that is trying to solve is that um you know imagine i i'm subversive and i ran a live peer orchestrator on the network and i say hey i provide transcoding services to everybody and you send video to me and i start it's a transcoding video for you but i start ingesting weird videos in the middle of your video or i can just simply return blank videos to you or i just won't do the work at all right um so any of those uh situations are really bad for the quality of the quality of the network and we need to have a way to prevent that so the way to do that is there's a verification mechanism in the protocol that allows the broadcast allow the person who's using the network to say i want to periodically verify that and i make to make sure the work is done correctly but i won't you won't tell me which one uh which segment that i'm gonna verify that you're gonna verify right so um if i am because i am on the network and i'm signing cryptographically for every video segment that i give back to you you have clear proof and evidence that i said i did the work right so if the verification fails you can submit that proof on chain to say hey eric eric cheated and the protocol will automatically slash me by taking uh some of my stake lifespare token away right so because in order to participate i have to have some skin in the game and that says this is where kind of the the staking mechanism come in again very similar to how kind of ethereum staking works a totally different question because not about the technology itself but um how do you envision like uh conquering the world with life beer so how do you compete with with let's say web tour traditional video transcoding services is it a competition based on pricing do you claim that you can do it cheaper than the competition or is it more about that you have more features as web 3 enables what's the plan there oh man uh what's the plan there um there's definitely that cost uh aspect right live pier is 10 times cheaper than amazon web services from an infrastructure cost perspective and that's just because there is so much spare capacity laying around the world that people can donate to not all people can put on this network and to make a little bit of money back right so um so that's really interesting the other thing that's interesting from the long-term perspective which i think is a lesson that we've all learned from the bitcoin network 10 years ago is that if you put a simple set of incentive out there and you say this is encoded in the protocol everybody feel free to do whatever you want with it people are smart and they figure out how to take advantage how to figure out how to game the system by improving their performance to make it a little faster for themselves and when everybody's doing that that grows organically like crazy right so 10 years later the bitcoin network is by far the largest super computing network in the world in terms of the the power of computation right because people started building gpu mining software and for a couple months that was profitable and and immediately it became fpgas and they immediately became asics right a6 kept getting faster and faster and faster so we already see that happening in the lifetime network where asic asic miners are coming into the network they're creating videos video transcoding specific hardware to be able to compete with kind of traditional traditional gpus so that will only get better and better over time and that's where the long-term cost advantage and scalability comes in right but i think that's just one angle the other angle that's that's really interesting is this web 3 movement that's happening right and and the weaponry movement is really about ownership and it's a it's about giving people an opportunity to have a more open and transparent system and that i think is highly disruptive to the existing world of um like video platforms right when you know you use youtube youtube's take rate is about 50 that means for every dollar that a creator makes on youtube youtube takes 50 cents from that right that is crazy for a platform that is made is made up of the videos that people upload they don't make any videos themselves right so uh by by using web3 creators essentially get to say like i actually own the video myself because it's tied to my ethereum ethereum address which is on the blockchain layer the application is simply built on top of the blockchain layer right so for uh so live peer is building the the video streaming layer for web 3 that has all these hooks into other web 3 kind of other web 3 components that together creates this web 3 video application stack that allows people to build these types of web 3 native video applications that i think in the long term are going to be yeah just very disruptive cool thank you two questions first one is do you think that the the network of transcoders will ever be like spread out enough that you won't need cdn networks and is there like a idea in your mind to build out another set of nodes the different function that acts as the cdn or anything like that and then the second question is um if i just uploaded a file to ipfs and included that address in my metadata for an nft would that work or does it have to be transposed to mint and nft um cool first question about cdns um so live here actually already contains software that allows you to deploy your own edge node around the world in order to kind of like run your own delivery right and then for a lot of applications that works extremely well um we have a you know we have a um a user of live peer who runs um runs an application that has like over 80 million minutes a week a month and have like over 75 000 streams per month this like pretty popular video streaming network and they don't use a cdn they just run live peer nodes around the world like a couple of like three or four locations around the world and they're able to handle a lot of traffic that way so that's that's you know the current way to kind of scale your delivery if you don't want to use a centralized cdn we're also working on a decentralized cdn solution that allows each live pure node to essentially serve as a seed of a swarm of nodes that are living in people's browsers right so what that allows you to do is to run a live stream and for your viewers to watch the video and deliver the video to each other so it's not always loading from the network and that's the way to to really scale out and and that's really that's a really good um situation for a really good solution for when a video all of a sudden gets variable right and that's kind of the worst situation for a centralized video platform because you know in centralized planning you already planned out your capacity and when something unexpected like that happens which happens all the time it can be really uh disruptive to the network that's already pre-provisioned right but in this world when the variability happens it's great because people the people who are coming in to watch those streams are just delivering the video to one another right and that kind of protects the network from this like you know almost like ddos attack right um so that's that's that second question is about um nft minting um yeah you you absolutely can just like use a video and you know upload it into ipfs and use that hash and mint the video however um video form video files come in all kinds of different formats they come in all kinds of different uh different resolutions right oftentimes um they're not optimized for video streaming on the internet or especially streaming in the browser right so have you can think of live peers network as almost like a optimization or standardization layer that just processes the video so that it makes sure when you're minting the video you have like the best file format to do it right yeah is it is it multiple formats to put in nft um currently it is one format that's like the optimal format but yeah in the in the in future versions we'll add in kind of flags for people to to have a little more flexibility there yeah all right how are we doing on time we're all right last question um is it technical um possible to make a mint out of one nft video more nfts so like for example editing video you have one video and some people wants to make some art out of it so um and make a second nft out of the small nft do you want to answer that one so you you from from the from the live viewer perspective the the sdk you could mint the same video multiple times you can also like create the smaller segments of the video and create separate nfts out of those and but you could also build something maybe even unchained to do something like that maybe you you have the the nft which points to the video but it has an offset in the video as a metadata and then your nft application knows that it's not owning the full video only part of it and then you could do like you could could create sub nfts or smaller nfts on from the same video without needing to re upload or reprocess that video just by start by having that reference but that would be a custom protocol on on top of the existing ones so you would need like your own application to parse it and and all that but i i don't know if i if i answer the question is it that that you know the small entities are actually from this label oh right yeah so that that's one thing yeah still the question is if there's a way to know if the smaller file that was minted as the nft corresponds to the original one that before processing and that's something that we do want to to add as well which is like when we do the nft we upload not only the final process file in the in the right field for the applications to show the video but we also have a custom property that is like the original video is this and then you have a different ipfs file and with the proper application you could go in and play the the full play or download the full file as well so you can do both and you right now you can customize the the nft metadata as well so you could even build that uh on top of the sdk it's already possible to do so yeah all right well thank you all for the awesome questions and thank thanks for the crowd and thanks to youth global for hosting [Applause] so so [Music] [Music] [Music] so [Music] [Music] [Music] oh [Music] uh [Music] now [Music] um [Music] very briefly what is datum datum is a framework which helps developers build applications fast on different chains and on different on different protocols we support a lot of features out of the box you don't have to build your own nodes you don't have to do the rpc calls you just call one of the ready-to-use features and you are you can integrate it directly into the application you can build basically any app you can build the nfd marketplace you can build a wallet you can build some d5 protocols whatever you want it's just up to you on more than 40 different blockchains what's the benefits or why should you choose to work with some framework or over the native rpcs you don't have to know blockchain you don't have to know how how rpcs work you just need to know how those common features works under common features or like ready to go features from us i mean mean an ft operation create wallet operation signed transaction operation something very let's say easily understandable from the developer perspective what actually like what was the development process of of of building an app inside atom you as the developer will we start with with playing around with the apis you obviously has an idea what you want to build you will just take a look like okay i'm going to build at 750 marketplace would i need to do that i need nft contract i need some some wallets i need some some apis but you find out okay datum gives me let's say 90 of these like ready to go features but i need like 10 percent of some custom rpc call or some custom operations you need to do on a blockchain we don't like lock you inside the tools we we we give you and uh like every good framework should give you freedom and the freedom means if you don't find the things you need in the framework you just go a level below that framework and the level below is of course rpc notes with the rpc note you can do whatever you want and that's basically very very very quickly the slides and now i'm going to focus on like some real live demo real life hacking i'm going to show you how the platform works what you need to do we're going to mint nfds we're going to be in an empties on solana we're going to mean the nfts and polygon we're going to i'm going to show you how datum kms works what it actually is and i'm going to show you how you can interact between data and metamask if you want to build some kind of d5 application so let's quit this let's open post mana my best friend and from the start this whole this whole postman collection and every example i'm going to show today is available is available on our public github i believe you can find github.comio and when you search for the repositories it should be devconnect2022 so there is a visible postman collection there is present postman collection metamask page i'm going to show later today and some readme files so everything is there you can just play around by yourself so today's today's workshop is gonna let's say i'm gonna show you like three three different topics first topic the most simple one is nfds i believe you're all curious like how to work with nfds you don't know solidity you don't know rust you want to mean the nfcs on solana on polygon any anything else out there and for that we have done the abstraction for you which means we have already like end point where you can very easily mean nft on the chain of your choice the like the interface of basically all operations we have is trying to be as abstract as as similar between different chains as possible which means most of the time would you need to chain what you need to change when you are doing cross-chain application and working with polygon or ethereum or i don't know solana is just the chain parameter inside the request you just saw you're going to work with solana you choose eth gonna work with ethereum but let's start from the scratch let's start from the from the first operation in order to to let's say work with an ftes or let's say you want to build an application your user has to have a wallet or address or something where he actually receives the nft or from the for the address from which you want to send some other transaction maybe solar nfds away to someone else we give you the choice very easily to just generate generate a solana wallet and uh the result of the operation is address and the private key i want to say out loud that don't use this endpoint in your production apps because it exposes the private key it travels through the internet which means it's compromised you shouldn't use it of course we give you other tools which you can use locally in your in your app uh like some client based sdk or datum kms or datum cli where you can generate those wallets or do any operations with the private key securely in your perimeter so let's we've created a wallet i think that's that's uh let's use it like this for the demo purposes i don't care what we have actually done we have called an api call to to our eu region and you need to pass an an api key you can obtain in our dashboard when you sign up which i forgot to show you how to actually do it so if you head to the datum.io you hit get started you can create an api key here you sign up you create an account and you can create free api keys from for which you can you can build you can run you can you can play around in the list of the api keys of course you can show it copy paste use it in your app so let's get back to the let's get back to the to the postman so i have created an address i should obviously send some some solana tokens there from the from the faucet so i can perform some transactions let's use cell falsett when you when you create a testnet api key in our platform for solana we are using devnet because it's a chain which should be used for for developers so let's send one let's send one soul to my address and let's check if it's there or not looks like it is so i have some balance to work with right now the next step for you you create an address for a user or for your application and right now you want to mint nft for minting an ft again we have another operation which is mint nft surprise surprise and there are some couple of important fields you need to you need to enter in order to meet nft for so long this is a little bit different than for evm chains i'm going to show you later how to meet the nfts on on a polygon which is same for any evm chain but for solana you just need to specify the metadata the metadata are stored on chain with in comparison with evm chains where you are storing just the url to the to the ipfs or some other third-party metadata storage and we are going to use the the address on which we're going to mean the nft so the recipient is going to be our address and the mentor could be our address as well let's use the private key of our of our created address and let's meet nft i'm going to mean nft some random stuff with some default metadata name symbol and the url of the of the image and yeah i forgot to enter the the verified creator which is myself and the result of the operation are three fields the first and the most important field is the transaction id with this transaction id you can easily check on the explorer if the transaction actually passed or not or you can read the transaction from through our api we can see that the transaction looks like part it's successful and the result of the operation is new token which is minted and when we check the token address nft address here in the response which is the same here you will actually see the new limited nfds for solana we are following the metaplex standard which is like de facto the only way how to work with nfts on solana so we are like fully compatible with any like nfd marketplaces or whatever which supports nfd's on the solution so great we have created nfds and we have sent it to us as the owner another step the logical one is i want to send an f3 from my address to somewhere else which again requires transfer operation in the transfer operation you again need to define from who you want to send nft was the private key of that address who's going to be the recipient and the contract address represents the actual physical address of that specific nfd for the polygon example we're going to see small difference because obviously we are missing some kind of identifier of the token there is no token id for evm chain there are token ids because it works slightly different for solana each nft is a unique basically program on the chain which doesn't have additional identifier so let's use our sender our sender parameters like i'm gonna send the nft from myself to someone else and i need to use the correct token which i want to transfer and the result operation is again the transaction id which we can verify on blockchain that nft has actually changed the ownership from myself it was sent to someone else very easily straightforward in three operations you can create addresses you can mint and fds you can transfer them of course there's much more to that in our api documentation you can find everything you need if you want to like reads operation read metadata or do some other things with solana and now let's do the comparison how the same nfd is minted or how this all is handled on a polygon which is like l2 for ethereum this this approach is valid for all evm chains ethereum cello binance marching polygon harmony and anything else we have added in our platform so again as for the solana first step for polygon is generate the wallet for evm chains we support like hd wallets out of the box so we give you the mnemonic an external public key which points to like millions of addresses under this one specific mnemonic so we need to do like two additional steps here in order to get one specific address and one specific private key if you wanna create an address from the from the wallet we have created you need to say i want to create address number zero from this wallet extend the public key bam you have address if you want to create address number i don't know 1000 you just enter address 1000 you have i think up to two more than two billion addresses available in one in one mnemonic but i think we are fine with one so let's use address number address number zero which is this one we should send already some test net assets so let's go to matic faucet and let's send here some of course of course i'm gonna use my i'm gonna use my personal testnet faucet for this this could happen only on live demo right the default is empty so let's send here i don't know zero point this is not enough let's pick different account this one let's enter i don't know 0.5 matrix great thank you matic faucet for helping let's go back so in order to obtain a private key from the from the mnemonic we have created again there is operation generate private key from the mnemonic again i'm gonna say out loud don't use it on production use some safer ways i'm gonna show you which ones so from this mnemonic we are generating private key for address zero zero zero address private key it needs to match one of the biggest problem when developers are playing playing around i have used incorrect index i have used different x pub and mnemonic and it's not working blah blah blah blah blah just focus so we have a private key here the safest way how to actually validate if this private key points to the address you think it points to is just import it inside metamask and you will see that the address is correct and we have a balance safest way just double check i'm gonna keep this window open it's wonderful so we have a balance we can actually proceed to finally minting some nfts on evm chains when you want to work with an ft first of all you need to deploy nfd smart contract under nfd abstraction here we are talking about erc721s we also have erc-155s available for you so semi-fungible tokens the let's say steps for working with them are basically the same as for seven to ones just a small nuances so let's create new nfd let's deploy it on matic chain with some random symbol and we are gonna pay the transaction cost from our private key from our address the result is transaction id you have we have created like very let's say useful some kind of utilities for like smooth like flow of the application which means you want to deploy an ft obviously you want to find out what the contract address of the deployed of the deployed contract so we have created a very let's say small utility from this transaction id tell me what's the contract address and what other construct that there is here so we don't have to verify it on a polygon scan or somewhere else and for example if you are building some kind of let's say nfd heavy application when you are like real time deploying new nfds you need to do programmatically these kind of operations you must have you must have a tool for that so we have deployed a contract and right now we finally can mean our nfd the difference again between solana and and evm chains is that 11 um 721 and 1155 standards bold requires the metadata to be stored off chain somewhere else and stores only the pointer to that metadata you want to you want to attach to the nft so in order to actually meet an ft you need to have some kind of url which you want to use most of the nfts out there are using some decentralized storage systems like ipfs file coin ar view etc etc we have integrated we have integrated ipfs where you can very easily again in one api call basically store any any thing you want on ipfs and you receive the ipfsc id so i'm gonna i'm gonna store some crazy build smart contract compilation information to the nft i actually don't care usually what what you are storing in the metadata is really up to any application if you are building some let's say if you're a content creator and are creating music or art or videos you're storing there some videos if you are working on a project which where you're going to mind those nfd as a utility nft which could represent tickets to represent memberships it could represent i don't know what some fractional ownership of some piece of land why not he will obviously store the metadata something else than an image but let's just store this uh this file on ipfs and the result is a ipfs identifier so in the mint operation we can actually mean nft with some metadata we are gonna use the deployed smart contract we have we have deployed as a contract address we are going to work on matic chain this is the recipient of the nft we are going to mint this is the private key which will mean the nfd so we need to use our private key we are going to send nft to us and we are going to mint nfd number one the token id in the seven to one world should be some integer or integer really extremely huge integer 256 bits it can have if someone is interested so you can create a really a lot a lot of tokens under one contract so let's mint obviously the result is the transaction id of the operation and we can check this transaction id on the on the faucet on the on the polygon scan the result of the operation is nft which was minted from zero address to me as a as a recipient with some metadata attached same as for solana we want to transfer this nft somewhere else so we're going to use the same v3 nft slash transaction operation as we were using for transferring the the solana nft if you're going to work with ethereum again we're going to use the same operation that's what we call cold ones deploy on every chain so let's transfer our our nft on the matic chain right we're gonna transfer nft token number one to a new recipe and from we're gonna transfer it from our address and here you go again transaction id in the meantime polygons can finally loaded our transaction and we can see that we have minted nft from zero address to ourselves token number one you can see that if we take a look on how actual like parameters of the operation look like you can see that we have minted token number one to this recipient and this is the metadata connected to it so everything we have entered in the operation is visible on the chain and let's check the transfer transaction transfer transaction is again very straightforward we can see that we are transferring nfd number one from ourselves to someone else and basically i don't think i have anything more to say regarding the transfer if you want to now support not not matic but you want to work on on a binance smart chain or you want to work on ethereum or you want to work on cell or you want to work on harmony this all is available basically only by changing the configuration of the request we give you not only the the ride operations but if you want to build some reason of application and should like have full set of features you want to use you need also you also need to read you need to read which nfts are hauled by which addresses what you own what was the nft transactions how the nfd travels between the the different accounts on the chain we have these operations available for you as well we got you covered so for example if i wanna see the the balance of one specific address which nfts it owns we can just check this one and you can see like this was my address and the address owns these token ids on this specific nft contract with some metadata attached so you can see i've already play around with my metadata file i think i should have used something smaller but i think you get a point where we are you can see all the balances of a specific address the time when those nfd's appears in this endpoint varies how fast we index the data internally on the faster chains it's pretty fast we can we can scan polygon quite near to real time for slower chance like ethereum it can take like two to three minutes since the transaction appears in a blog and since we do our internal stuff there are of course more operations than just get an ft's by address everything can be found in the api dock which i think i should show how you can get there inside the resources there is a api doc link where you can see a list of all the operations we support and we are we were talking today about nfd section so you can see here all the operations you can do on top of the nfd here are some write operations here are some read operations get nft transactions by address etc etc everything you need to do in order to build something something real this is basically basically pretty much it in terms of the nft workshop and right now i want to focus on on the kms and i want to focus on the on the metamask because yes we have played around with apis we have like pretty like decent understanding how the flow should look like what operations should we do but this is actually not how you're gonna build your production application you're not gonna send private keys over the internet to us to sign something you can do it some projects do that but please don't please don't don't don't don't this is just for you for playing around as i said at the beginning we have other options how how you can like build the the the production application one of the option is to use our client libraries datum js it's a javascript sdk which you can download you can include it in your app on your back end or on your front end and do all these like sensitive operations locally i mean generate wallets or sunny transactions the sdk looks pretty simple when i open some some let's say unit test which actually shows you how the how the sdk looks like you are building on top of the sdk you want to work with a transaction section and you're going to mean the nfts the body of those of those calls are near are almost the same as for the api calls it's just the different wrappers on top of some on top of some some objects in the in the javascript but basically we are reusing one to one datum js format inside rest apis but you can use your private key here because obviously you will include this in your back end so if you are building some custodial applications some custodial wallet or custodial marketplace and you are already managing the private keys of your users you can like use the private keys on your site if you are not using if you are not building uh for not building custodial solution but you are building something something let's say more defy and you want your users to sign their own operations with metamask or with something else you actually want to know how to how to do it how to sign some transaction how to sign mint and ft operation with metamask you know like i wanna use the same like cool features the same abstraction method same in the nft transfer nfd operations but i want to let the users to sign that i have created very very ugly example html page where we actually gonna connect this page with a meta mask we choose some some account in the metamask and we're actually gonna mint the specific nft using metamask with the signing and then we can take a look inside the code how this all was done i need to choose a correct account for this i think it was this one yep i think it was this one so i'm gonna first of all i need to like enable metamask connect some account from the metamask and then i'm gonna internally mint nft with some specific token id with some random metadata i actually don't care what i'm gonna mean i just wanna show you how to maintain so i don't think this will work because i think i have wrong i have wrong account yeah exactly so let's dig dive into the code before that this is what needs to be changed i need to use my api key of course because i'm going to communicate with the platform i'm going to perform some post requests to the api and i think there was another one here and what i'm gonna do i'm gonna basically use the same request as i was using for minting i'm just gonna replace the from private key with some placeholder value which we internally understand and we just like give you the recipe to be used inside metamask so i'm gonna use this contract address i have deployed i'm gonna mint it here to this guy with some metadata and i need to connect the correct correct account inside metamask which was the last one efd so let's connect to metamask let's try to maintain ftes and metamask window pops up it was correctly connected you can see that i can sign some transaction let's sign it and the result is shown here again transaction id and we can check it on the polygon scan if it's actually working or not this looks like a magic internally it's very it's very simple internally what we are actually doing we are leveraging the the standard metamask interface how the metamask connects the to the blockchain application where we just work with the ethereum object in the in the javascript world and then for minting nft as i said we are using the same api call as we're using in the demo but instead of a private key we are using a signature id signature id for us means that we don't sign the transaction the private key in our api but we just prepare a transaction object which should be signed later on it could be signed inside metamask or it could be signed inside our key management system register kms which i'm going to talk like in next one a minute you can enter any signature id here we just mean the we just send the mean operation we receive some some response we perform reading that responds so we're actually fetching the transaction object which we want to assign inside metamask and just do some magic and send the transaction config for signing to the metamask i'm not saying it's simple i'm saying it's like 30 lines of code but this operation you are doing right now could be anything it could have meaning nft it could be sending ethereum it could be transferring erc 1155 it could be some approval on top of the smart contract it could be whatever anything you want to prepare on the client could be signed with this approach with metamask so if you want to build quite quickly some defy app you want to use metamask you can leverage all our pre-built pieces of functionality all the features using this way and just let the metamask do the do the signing and then like last part of the workshop is going to be the completely opposite type of application and we're going to talk about the custodial application want to build and the way how to actu how to work securely with the private keys if you are building a custodial solution i've seen crazy things i've seen projects where storing private keys non-hashed in the postgres database on their application server i saw projects who are sending private keys over internet edit they don't care eventually all of them like stopped working because they got hacked or like there was some other problems connected to that but none of like if you want to build something really serious something which should survive at least first hacker attack from from some random guy you need to really understand and pay attention to working with the private keys if you don't do it properly you can be like really in a bad place or in a bad situation what's like unfortunate is that like it's not unfortunate but more and more new developers are joining web3 space more and more web 2 people are trying to build something on top of the blockchain but they actually don't have any previous experience they don't know was the correct patterns they don't know that private key must be stored securely they don't know like how to do it and what's the correct flow and because of these there's there's so many problems and so many like failed projects or hacked projects out there in dayton we understand that and that's why we're trying to guide you using trying to guide you to use proper design patterns while building your app and actually you can't do it badly if you follow like these main ideas and the kms is basically that example so i'm really gonna start showing that because we are bad on time if you wanna like datum kms is a is a key management system which means it's a small tool which runs again on your infrastructure which holds the private keys the mnemonics everything on your side and it automatically communicates with our api on the cloud like fetching some transactions which should be signed from the api signs it locally and broke out broadcasting the blockchain with this setup you basically your private keys never leaves your perimeter the private keys leaves leaves in your server secured as you secure them because the transactions are being fetched private keys are not being sent away if you want to work with the kms you need to pull the kms docker and you need and first step which you want to do is basically set up a wallet file which will like securely hold all your private keys for that there is like a bunch of cli commands you can work with the most easiest one is generate managed wallet or store managed private key with like external private key i have example of these calls in the readme so right now i'm gonna store my pre-generated private key for the existing polygon account i just need to point out the the correct volume on my drive and say hey datum kms i want to store managed private key for a matic on the test net chain the door could just start it will ask me for the private key which i want to store which i believe is this one it will ask me for the password which is used for encryption of doublet file for the first time just enter some password you want second time we'll have to repeat it my favorite password is one two three four five and the result of the operation is that datum kms grabs the private key stores it in the wallet file and generates signature id which actually represents that private key inside this kms instance right now my kms can start fetching transactions which are connected or sent with this signature id so let's say i want to mint new nft i want to mean the nfd number 10 but instead of a private key i'm gonna use signature id and tells and this inform this like body tells the api internally that hey this guy to store the transaction for the kms signatures later on so the result of the operation is not the transaction id on the chain because not no signatures were were done no transaction was broadcasted to the chain the result is some identifier of the tr of the operation which should be signed later on you can get the details of that operation using kms get details stuff and you can see here some let's say information where the most important pieces are the chain we are working on matic the serialized transaction field is actually the transaction which will be signed inside the kms and the hashes field represent the private keys which should be used from kms to sign the payload so right now the transaction is still in let's say the spending state and once the transaction is signed there's gonna be new field takes id present with a specific transaction id what we need to do from the kms perspective we need to run it in the docker mode if we wanna like start kms fetching if we wanna kms to start fetching the transactions from our api we need to run it as a docker daemon using this command you are actually saying hey kms i want to start you in a demon mode this is my api key so under this api key you should you should communicate with the api i wanna see only transactions which are connected to polygon on the test net network so right now i have one transaction pending inside my inside my api key space so kms daemon will start you need to enter of course the the password to decrypt your wallet store and kms starts fetching the transactions from the from the platform i think we have a lot of transactions there under these signature ids which i don't like for any reason but i think this one is the one oh not this one let's see if this one got processed it got luckily so let's take a look what happened here under my api key i have a lot of other pending transaction which should be signed one of those pending transaction was mine and the transaction got picked up by the kms it was signed broadcasted and the transaction id was attached that kms to the kms transaction object we can right now check on the on the polygon scan like if the transaction actually passed or not and yes it looks like we have really mint token number 10 as we want it and when you take a look how we actually did it we haven't sent the private key anywhere the private key remains secret and safe inside our kms i know it was a lot but right now it's time for any questions you might have for i think we have a microphone somewhere i don't need the microphone okay go ahead so thank you very much for your implementation it was it's very it's very clear you use metamask but can i safely assume i produce any other kind of one at times just to replace maximus yeah for the stream the question is if i can replace the metamask with any other wallet like let connect whatever else yeah if the like if the principles how those like wallets are working are similar to metamask so you are passing the transaction configuration which should be signed then yes you can use whatever it's really up to you awesome there's any more questions we can ah another one great oh what do you mean by that can you have this maybe nft but if i take for example have an video in this case would this would this also work well if you mean like an ft minted video it's like actually the existing nft already on the chain and you want to remind it again yes you can because like technically speaking this is just mint nft and i don't care what i'm minting like you can mean whatever token on on with whatever metadata so it's really up to you what you want to mention if you are going to create new nft this is the operation what's actually inside that nft is really up to you guys if you will have any more questions we are here like yeah go ahead um the question was again for the for the stream uh that we have a lot of vm chains integrated and if we plan to add some bridging functionality what we have available in each of our integration of every blockchain is that you can easily let's say call smart contract you can perform right operation on any smart contract available on that specific chain so if there is a bridge already which is a smart contract base which usually they are you can actually right now working with the bridge just by invoking the bridge method for example we're gonna send an empty there and call something on a bridge yes from the abstraction perspective right now we like don't plan to add some custom bridges or like do abstraction for existing bridges uh if you want to like bridge yourself those nfts and build it by yourself you have couple of options you can create you can like integrate some existing breach or you can like deploy your nfd contract different chains and basically create your own bridge that you will like burn on one or bin on another one and basically will bridge like this with some metadata connections between those or which is even better solution you can basically send your nft to some specific address which you own and you say that this is my breach you will mean another one and like do it by yourself yes you can yeah it would be great okay guys i think we're on time so thank you all and as i said we are here to tomorrow on sunday as well to answer any questions thank you my favorite [Music] [Music] [Music] now [Music] all right huh [Music] oh audio might be all the way back there [Music] so [Music] [Music] hi there how's it going [Music] good um oh yeah i'm moving some things around before showing yeah okay perfect okay [Music] okay gotcha [Music] i know someone who's gonna need a microphone right away actually we're co-presenting yeah oh nothing just go with it [Music] okay i support that sounds wonderful thank you all right appreciate it um no i told him that european [Music] [Music] oh yeah it does i'm just moving things around so thank you [Music] [Applause] [Music] [Music] [Applause] [Music] i'll see foreign [Music] um [Music] they told me to wait i said to wait a moment good to go all right hi everybody uh and thanks for tuning in especially if you're on the live stream watching this from down in the hakka area or across the pond as they were saying earlier so i'm christine from scale labs i'm really excited to be at amsterdam i'm doing this workshop the primary goal of the workshop is to one explain more in depth what scale is all about and also give you an update about v2 from a surprise guest and then also do some live coding for those that kind of want to follow along using some tools that you should already be familiar with and if you're not don't worry we'll slow it down and make sure that everyone can catch up so um before launching into that just want to remind everyone about the prizes we do have a lot of prizes to win today um so if you are going for the grand prize it's pretty much using having the best use case of scale integrate it within your application that means potentially using some of our additional features file storage interchange messaging etc etc we'll definitely get into what that is all about later we also have two other categories if you're developing a metaverse p2e or nft game all teams that win this will share up to five thousand dollars and then for partner integrations if you see any partners walking around um that you want to try to integrate onto skill you can definitely do that and you'll share up to two thousand dollars for teams that are hacking on that and then last but not least any team that hacks and deploys an application onto the skill network will split four thousand dollars among yourselves so really excited to see what is built on today and if you all have your phones ready definitely go ahead and scan that qr code it will take you directly to the information you need to get started all right so what is scale so scale is a layer that sits on top of ethereum that pretty much allows you to speed up your smart contracts and then also removes the gas costs now what's great about this is it fits really well with an ethereum ecosystem so all the tools that you love that exists in ethereum automatically works on the scout on the skill network as well you don't have to program a new language you don't have to change your tech stack you can simply just migrate everything over to scale using an infuria like endpoint as you see here and i'll get into how you can actually do that using some tools here remix we might go through truffle if we have time but definitely explaining web3 and ether.js as well all right so how does this all work we have nodes around the world and what ends up happening is when you decide you want a skill chain we group together a subset of those nodes we take 16. and what this means is your scale chain has its own environment it allows you to process transactions but it also has file storage meaning that you can store files directly to the blockchain so let's say you want to host your website or stream videos you can upload that to the file system and have it automatically displayed to you because we have an nginx layer that sits on top of that additionally we have interchange messaging which is a bridge that connects you between ethereum and scale so that means that all of your assets you've already developed on ethereum you can migrate them over to scale or if you haven't yet started you can start minting on scale directly and migrate them later thus by saving even more gas one of the things that we do is we run rotate the nodes ever so frequently so this adds a layer of protection because i know what everyone's thinking out there 16 knows that may not be a lot but when you think about the random rotation over time you can potentially have seventy percent ninety percent hundred percent of the network which might have worked for your skeleton at any point in time and we do this to make sure that nodes can't collude um if you wanna learn more about that definitely come see us at the booth our vp of product chadwick would love to go in detail about that as well as our bd team i'm going to call out some few ryan connor fabio who else is here alex as well can definitely give you a rundown on all that's involved there all right but this is a fun thing um we're a multi-chain network and it's one of the first of its kind so i know you've probably been seeing the news and you've been seeing other networks trying to migrate to the same thing it's really cool to see that you know other applications are now seeing the value about this and now trying to integrate that within their applications as well so definitely check to see how we're doing it here because one of the things that's really exciting about this week is we are launching something called the skelvers which is basically a v2 of the scale network and what that v2 allows you to do is add organization around the skill chains so we listen to our community and our community submitted proposals which was amazing that said that they wanted to band together to create hubs so we have exchange hubs which is all your liquidity we have some amazing exchanges some amazing partners are going to be launching there over the next few weeks as well as marketplace hubs as well we have marketplaces that said hey we want to join the scale network and provide an ecosystem to where any nft project or any project that has an nft can list their nft on the scale network and have it transact in a free environment how cool is that and then lastly because you know a lot some of the community they don't necessarily want to manage their own skill chain they want to use what's existing kind of like how they leverage ethereum and so that's where community chains come into play instead of having to manage your own skill chain if you just want to deploy your application we have an environment for you to be able to do that in a hub-like environment as well but then lastly you know there are a lot of applications out there that have said we want our own chain we want to make sure that our transactions per second isn't deprecated because of another game or another application running and our speed stays the same and the only way that that is viable is through a multitain architecture which is the thing that we started with our vision from the beginning and so really excited to see this come to life with scale v2 but there's so much more to that and i think chadwick should probably come up and explain a little bit more you ready to come up [Laughter] now i don't have a slide for him so you're going to have to listen carefully to all the additional features coming into scale v2 hey everyone chadwick here vp of product uh so just to piggyback on christine's intro the key thing with the hubs and with v2 we've taken the interchain messaging agent which is the native bridge deployed on skill chains and for several months that's been operating very well between ethereum and scale transacting and transferring tokens and arbitrary messages between ethereum and scale and now that we've we've expanded that to uh basically help promote and drive the skill verse this sort of hub and dapp chain communication model by allowing any two skill chains to transact uh tokens or messages basically sending tokens and messages between any two skill chains with the same uh bridge layer that we have using bls signatures but the key thing here is okay it's a bridge but it's a bridge that can transfer tokens between 82 skill chains and a gas cost-free gas environment so you don't pay any gas fees transferring tokens between any two skill chains and the resolution time between any two scale chains is very fast it's 18 seconds so we've taken that bridge from ethereum to scale and applied this between any two skill chains on top of this we didn't stop there v2 includes this but also includes what we call an rng endpoint it's very difficult for solidity developers to find a really good uh source of entropy to drive like the randomness of maybe nft properties lottery design or other deeper functions that you'd want to do in smart contracts there are other options out there like vrf's and other options as well but we decided on scale because of the uniqueness of our architecture and how we use bls threshold signatures amongst the nodes that comprise your skill chain we're able to leverage this in a very easy way to allow developers to basically call a precompiled contract on each skill chain that delivers a random number gener a random number for every block that's created it's a really easy way it doesn't doesn't create any external calls that you have to do it's basically a very simple assembly code that you can copy and paste in a contract and integrate very easily we also have an oracle api we have the base layer available now we're finishing a few aspects of that but it'll allow basically any developer to create an rpc call or an rpc uh call to any uh external off chain data and then allow the skill chain the nodes in the skill chain to request that data from uh from off chain and bring that inside come to an agreement about what that off chain data is and then present it for available uh verification and solidity um and then did i forget anything i think that was it that's it yeah that's it for v2 yeah so scale chain transfer oracles r-e-n-g oh my wizard of oz so it's pretty exciting though i i think we're really excited for the skull verse because it's really just showing the power of a multi-chain network and i really want to stress that multi-chain network started from the beginning vision number one and we're really excited to see it you know evolve into what it is today um with that oracle piece though i think we're really excited because um we do partner with other oracles but i think you know giving developers the option to have an oracle that's native to the chain i think is also unique because when you think about what the skull network is trying to do it's not just creating another blockchain it's creating a blockchain with a platform of features so file storage the oracle rng the list just goes on machine learning which was something that we sunset but we had before like it's really exciting to see scale labs labs scale l2 develop amazing things over and over and over again all right so now i think it's really cool to take a step back and see what cool things can you build on scale and with fast finality no gas fees and high throughput it feels like the possibilities are endless and we didn't build a blockchain that's just for nfts within any bill of blockchain it was just for games we built a blockchain for every application out there and that takes time to build and so where we are today means that now the applications can take what the features that are there and build these really cool applications so with fast finality we were able to deploy oracles but other oracles could also create on this modular system as well media paywall authentications the no gas fees mean that nft projects can launch their application without having to raise a lot of capital first they can simply launch their application prove product market that and then move forward from there and that's a game changer when you think about how things currently operate in ethereal ecosystem being able to just launch your application or your dow without having to figure out how to pay the high gas fees and then high throughput one of the things that we did at one of the eth conferences a couple years ago was we took unity we took one of their templates we put it on scale and saw how it worked and it worked extremely well extremely fast and one of the feedbacks that we always get from game developers is that when they use the scale network they can develop for their application and not for the blockchain and that's a different way of thinking about approaching development so really cool to see all these different applications that you can develop now what are some applications that have developed on us well ruby exchange is a really great partner of ours is going to be launching one of the first exchanges within scale network and what's cool is that liquidity hub that i talked about the organization they're going to be at the forefront of that making sure that you can bring equity in and out very seamlessly they're really good with marketing as you can see that's one of their videos very flashy very amazing but what i'll do though is actually show you their application and let me come here so this is the ruby application and it's just on on the test network for now because they're going to be launching in the next few weeks but what's really cool is that they're allowing developers to easily bridge over current um you know standardized tokens usdc usdt the list goes on and if you want to add your custom token they are a great partner to make sure that you can do that within the scale network they've also integrated with our faucet to distribute s fuel i know i haven't talked about that but i promise i'll bring you up to speed on that in just a bit but this faucet makes sure that anyone that doesn't have permission to process transactions on the scale chain can do so and i think that was a really cool way of how they integrated that within their application what are some other applications that have developed iv cache this is a really great nfc project you don't have to have a wallet or understand blockchain to be able to get it in ft and they prove that by allowing anyone to create a qr code present it on a screen add a game or anywhere scan that qr code and simply have an nft show up in your wallet just create it for you and so that's a different model than saying hey how about you download the application here understand blockchain make sure you save your private key and then oh make sure you then change to the correct endpoint they remove all the friction for their end users and so when you think about creating an application with design in mind using applications such as layer 2 that the scale allows you to do that and achieve that because again we have a no gas environment the last one i'll talk about is going to be name services what's cool about them is that they built an application that allows you to reserve your name so it could be christine.e it could be my daughter's or her that either would be chadwick.ed but essentially when you reserve that it then actually resolves to the wallet address and they have a really great api as well so they have two sides of the product one side is for you know users to actually get their names reserve them and be able to attach it to their wallets the other side is for depth developers to integrate that within their applications so they have a fully fledged built out api that allows you to do that but not just you know integrate their name service but ens and unstoppable domains as l as well they're covering the entire suite of domain name servicing which i think is a really awesome way of using scale as well so when you're buying your names on their application within the scale system it all happens in the background the user doesn't have to know that you're on their own scale they're just simply there they're buying their name with a credit card and that is it so again another great use case for usability all right we're finally at the live demo portion i hope i didn't kill you by slides looks like i didn't everyone's still up everyone's still looking this way that is great um do i have developers in the room or are we here to watch i know i have developers out there that's watching on a live stream but i can't talk to you so developer okay one two three ish three okay three three in the room that's good so in that case what i'll do is i'll kind of go through a little bit of the coding aspect of scale because i think it's really cool to see how seamless and how easy it is get up and running all right so i'm going to switch back here to my lovely browser we're going to exit out of this goodbye ruby we still love you all right so the documentation portal and i'll back up just a bit because there's a lot of information on here uh you can thank again chadwick our vp of product for organizing all of this and making sure that everything's ready for the scale v2 launch but if i navigate here to develop there's a plethora of information on how to use again those existing tools that i promised you guys or just deploying to the scale network if you already know what to do you just want to go it alone but let's use something that most developers are familiar with remix a lot of developers have used this you've come across this in some capacity for just simply deploying a smart contract well what you'll see here is that all of these tools have step-by-step instructions on how to use that with the scale network and one of the things that reigns true with most of these is that the deployment or the usage of these is just as simple as changing an endpoint so if i go to this metamask example here there you go just changing an end point portis same thing simply just changing an endpoint and i think because of the way the ethereum space has evolved all tools that are building within that space makes it so that way you can integrate with other layers outside of ethereum and it's shown here now for remix it's more or less the same you can take this example smart contract copy it into remix and just run it by deploying on the scale network so let me show you what that looks like if i click on this link actually let's back up i'm going to open it into a new browser tab all right perfect we have a simple smart contract called hello scale super simple but um one of the things that you'll know is that you could always connect it to metamask by switching it to injected web3 and here we're on metamask i'll switch it back to ethereum network but because we're at the hackathon if you go to oops let's not open that if you go to eat amsterdam.scale.network this will give you all the information that you need for getting a skeleton end point and accessing a faucet while you're at this end point uh that's why you're at this conference to be able to get it going so if i click here there are two skill chains available and i'm going to select the first one now i can go the manual way of copying this opening meta mask and adding it to you know my list of networks or i can do it the automatic way which is click on this button here and it'll automatically add it for me now i'll go ahead and switch networks and what i want to do is jump back just for a second to the documentation because if you want to understand exactly how we created that button all of the code for doing that is simply here you can copy paste and just have it work so i'm going to go back here to remix and now that i'm on the skele chain as you can see i don't have any ske which has been rebranded to s fuel actually and s fuel essentially is a token that exists on a blockchain just to prevent ddos attacks it has no monetary value which means you can use it as an authentication mechanism so if i come back here and i'm going to go back um and back up a little bit and what i'll do is let's see i'm going to copy this endpoint paste it here and then i'll come here and get my wallet okay super simple paste that here and then simply click on get s fuel what this basically shows you is just a faucet mechanism for setting up distributing that s fuel you can just as easily distribute as fuel the moment you recognize this user when they log into metamask but now that i have s fuel i can go back to remix and simply deploy the smart contract onto the skill chain all right just want to make sure everything's connected as long as this green light is going we're good to go and let's go ahead and click deploy one of the things you'll notice is just how inexpensive it may seem to deploy the smart contract and that's by design because again it's a gas free environment but we still want to make sure that no one can ddos you and so over time if someone is trying to ddos you this number will simply increase by a predetermined number until they've run out of vest fuel and you can decide just not to top them up which means they're blocked from running transactions on your blockchain now if i confirm this that'll do what you expect will happen in any blockchain it deploys a smart contract to scale and from there i'm able to transact with it just like i would if this were running on ethereum and so just as i promised very simple to transfer over from ethereum to scale now one of the other things that we can do is let's check out one of those really cool features that chadwick mentioned i like the idea of checking out the rng endpoint one because i think the documentation is really well done where you can simply copy paste run now i'll copy this and i'll come over here and i'll paste this here let's go ahead and save that good looks like it's already compiled and i'll delete that one and we will simply redeploy all right give that a moment and this is that random number generator that chadwick had mentioned what's cool is that in scale v2 this is going to come standard on every blockchain and so one of the things that we kept getting asked about is that you know with scale being a costless environment do you guys have a random number generator and if so can we use it do you have code snippets well we took it a step further we don't just provide you the code snippet we provide it um you know standardize with every blockchain so you can just simply access it and so every time i click on get random every time there's a new block a new random number is presented to you um so a really cool way of using one of the new tools that's coming out and scale v2 all right so before continuing on um i will pause if anyone has any questions straightforward so far everyone's following i see nods i see nods okay no one sleep yet this is great i know it's midnight all right all right so again i think the main thing i want to drive home here is just you know the simplicity of using the scale network but also the complexity of the features that we have available and one of those complexities i think is drawn out in interchange messaging so if you're here building a token and you want to make sure that it can um transverse between different chains or different blockchains between ethereum and scale or reverse from scale to ethereum this is the the documentation that you want to land on now there's a lot here we have support for all of the major token standards erc 20 erc 721 erc 1155 and then any custom smart contract now that is very unique because a lot of the bridges out there only support erc 20. but with the support for all of these what that means is that you can really transfer any assets to scale even as far back as crypto kitties or create any new standard and simply have it work within the skull network with being able to transfer that back and forth now we have some really cool um diagrams here um that help you just sort of like understand what the flow looks like so you're not going on on this alone where i'm a visual person i hope so you are too and so having a clear way of understanding how to move a token between the different chains is extremely helpful and that menting first methodology that i mentioned um is down here where we give you a simple flow of understanding how to first mint um an nft or any asset on the scale network and then move it to ethereum after the fact that's by saving you even more gas so i encourage any blockchain project that's looking to hack at this hackathon to try it out this would be a really cool way of integrating it within your nft project your p2e game or your metaverse application all right let's go back here all right one last thing um since we have everyone's attention we do have a hundred million dollars in usd for ecosystem grant program and that's going to be specifically for gaming so if you're here building a game definitely come talk to us that way we can see where you are in your development and to see if we can get you into this grant program but looks like we had a question before i concluded use the skill change skill chain bridge how would you use it the skeleton the skeleton bridge i'm actually gonna go back here because i think uh let me show this one all right uh great question by the way and the question was for those that are um viewing this how would you use the scale chain to scale chain bridge uh the best way to think about that is let's first explain um you know the layout here we have these exchange hubs which are providing liquidity meaning all liquidity is coming into that one chain and other chains that are creating complementary like exchange hubs as well we have nft marketplaces which means that all nfts are going to be viewable within one endpoint one chain which is great for developers because things are able to be shown in collections which is very important if you are building nfc project and those community chains where we have a lot of applications that want to share space because they don't necessarily need 70 gigabytes for storage or 200 transactions per second for their medium chain they just want a small subset of that um but if you're going to be launching um on your own chain on one of these hubs how do you communicate between chains and when does it make sense to do so well as you can imagine if you are launching your pte game or your metaverse game or your music application you are um in your own ecosystem your own container which means that you might need to bring liquidity over now you can go this on your own and use energy messaging bridge bring it from ethereum or you can take advantage of the free transactions per second and scale and simply go over to ruby exchange that exists in an exchange hub and when you do that you would use the skeleton scale chain bridge to be able to make that connection between your chain and that exchange hub it's going to be extremely fast everything processes in 18 seconds or less but what that means is that you're able to bring over the pairs that you need for your game for your nft for anything that you're building whether it's a stable coin whether it's ethereum whether it's scale it could be any token that you want to use or any custom token that you want to use so the normal flow is going to be bringing the liquidity that already exists in the skull ecosystem over to your chain but there are some edge cases there and one of those edge cases is if you're creating your own custom token on your own chain and you want that listed on the exchange you have the same flexibility to use that same skeleton skeleton transfer to push your token to the exchange that way is listed for anyone else in the ecosystem to pull down later so a really cool way of um you know spider webbing this together in a really organized way and um yeah the skeleton skull chain um upgrade that's happening this week actually uh you'll be able to start on playing around with that relatively soon can i store my files in another chain and use one for both data okay so the next question is for file storage can i store my file storage my files my files and another chain and use another blockchain for the data of the application is that correct um the answer to that is yes i think one of the things that you know the community realized immediately when skeletal said that we were going to launch this multi-chain architecture is oh i can have five chains for my application and then use them for different modules within my application and that was a really cool way of thinking about it um and so yes if you wanted to use one chain for launching your token or running your game or running your application you can do that but let's say that you wanted to store all the files that were going to be accessed for being used within the game or used on your website or used for machine learning or used for any application you'd be able to have another chain that runs side by side to that and so what's really great is that it means that you can scale horizontally you're able to start with one chain and as you need more space you can either upgrade from you know a medium chain to a large chain because we offer different types or you can say hey you know what i simply just want a new chain all together so that way i can double my storage all at once and maintain the same transactions per second because i might not need more 200 is enough especially when you think that 200 for one application versus 200 for 500 applications as you might see in some other networks that's a different conversation when you are on a dedicated chain and you have all of your services just for you you can think about you know using those services not worrying about the fluctuations that anyone else might cause so yeah you're welcome any other questions the ima bridge are all the chains sharing one ima bridge over to the mainnet or are there do they have their own yeah so with the ima bridge um because each skill chain um is its own environment they all have their own like smart contracts there right and so they connect to the smart contracts between ethereum and scale but yes like the buckets that you would transact with on the skeleton side are all going to be your own on the ethereum side it is going to be a shared environment but that is um really well um separated if you will based off of the chain that you're interacting with and so as you can imagine that design was put into place to make it easier for skeleton skeleton transfer and also ethereum to skill transfer but yes essentially on the skill chain you have your own bucket you're on smart contracts and what's great is that you don't have to think about deploying these everything comes pre-deployed pre-compiled and so as you can imagine what that means is an easier way to understand how to connect this on each and every skill chain if the contract address is going to always be the same and all the skill chains you don't have to think about keeping a mapping of that which i i think is a great way of approaching creating the entertaining messaging protocol so good job engineering team who's not here but here in spirit and we're really excited so any other questions all right well with that i'm going to conclude the session but if you have any questions definitely come see us at the booth we'll be around tonight and tomorrow tomorrow there's a special event i can't tell you what the special event is but come see ryan he will definitely explain that to you it's going to be great but definitely come hang out with us and learn more about how to deploy your application into scale and before i go i will just show this last screen here for those again watching this virtually definitely go ahead and scan that qr code or simply just put this url in your browser again we have 16 000 and prizes to be won so definitely hack with us because at the very least if you simply deploy you have the possibility of winning that 4k prize that would be descriptive among all teams so at least give it a try alright thank you [Applause] [Music] foreign [Music] [Music] [Music] so [Music] so [Music] [Music] [Music] [Music] do [Music] [Music] [Music] [Music] so [Music] [Music] [Music] [Music] [Music] so [Music] [Music] [Music] [Music] [Music] [Music] [Music] so [Music] [Music] so [Music] [Music] [Music] [Music] [Music] this hi everyone [Music] [Music] fine [Music] [Music] [Music] okay [Music] [Music] [Music] [Music] [Music] do [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] uh [Music] [Music] [Music] [Music] me [Music] so [Music] so [Music] [Music] so [Music] [Music] [Music] cool oh okay we good all right we're good we're good all right um this is uh deployed optimism 0.5 seconds of your money back um the first like five minutes of this talk are going to be me talking about how to deploy in the second 40 minutes of this talk are going to be talking about optimism in general trying to answer like architectural questions about uh what's going on under the hood so this should be pretty quick because it's very very easy so if you were working on optimism maybe about a year ago you would have known that optimism used to be really annoying to to deploy to because we had this custom compiler it was a total nightmare and it made people really annoyed so we got rid of it and i'll talk a little bit about how we got rid of it but for now the reality is it's really really easy to deploy so anything that runs on ethereum should run on optimism one to one the gas is all the same the contracts are the same runs the same byte code you can use solidity viper whatever you want works really really well and we spent a lot of time trying to make that happen um so deploying with remix it's very very simple first you got to add your network the optimism network to your to your wallet so i made this website called chain id.link and you just do you go to this link chain id dot link question mark network equals optimism and hit connect oh and of course i probably have signed oh no no there we go oh it's because i'm already connected so whatever i'll sign up to something there we go okay right boom connect to my uh to optimism uh and i'm connected to i guess i this should be it should be optimism whatever cool all right so you know you do this with whatever wallet you have connect connect optimism and then you know go to go to remix and uh write your contract and i have a simple contract here that doesn't do anything it doesn't matter this is simple but can be as complex as you want you know save it connect metamask to whoops to your injected web3 provider and that's it just deploy and um this is what is this this is on mainnet so there you go deploying on mainnet that's it that's easy it's the same thing it's really simple just like deploying onto ethereum except it's faster and cheaper um okay go back to this doing it so with remix pretty straightforward hard hat also very straightforward same general concept just add optimism to your network config and deploy um i do have a very brief example of this straightforward look at me this is my network config that's that's all i dated i just added an optimism network and then i can deploy my contracts so i have my adder same thing as before i have my deploy function same thing as before and deploy if it'll ever deploy there we go that was easy okay that's it it's the same thing like that's i this is why this talk is really boring it's just it's just showing you how to deploy a contract um same thing with truffle literally just the same thing you just add optims of your network config i can maybe i can share the slides later if you want the link to this but very straightforward same thing with brownie except you don't even need to add it to the network config because it's in there already um and that's it that's literally all it is this is not a very interesting talk so i will talk about uh the more interesting side of things which is how optimism can actually be this easy to use which is as a result of this concept of evm equivalence which is sort of a stronger form of evm compatibility where this trick is you know the evm is a very delicate beast and every time you change the evm a little bit you you know you can say that you're compatible because you're compatible with all the rpc endpoints but if you change the behavior of the evm all of a sudden you get into sort of a weird uh weird state where you get developers who are relying on some very small feature of the evm and you've told them that you're evm compatible but then this one feature of the evm doesn't actually work so are you really evm compatible i would say no but because so many people have said on evm compatible that we've come up with this new idea of evm equivalents where you're essentially just running an evm that is like a production evm that's being used to run the ethereum mainnet so it's the same exact virtual machine um and you can actually like take this evm and really run like a main net node with it um in this case we're using guess evm to do this so we literally our client runs geth okay so um yeah so let's let's sort of describe at a high level why is this okay let's describe at a high level um how this whole system even functions because it's quite interesting you have your layer one oops there you go you have your layer one and your layer one is pretty you know what that looks like it's a blockchain right and then what we have is these two components we have this thing called an op the op node the op node and it pulls transaction data from layer one sort of just like pulls in layer one blocks and from these layer one blocks it deterministically generates a list of layer two blocks and then it takes these layer two blocks and it executes them like right at this point you just have like a block chain on layer two and it's fully derived from layer one so just like a pure function on layer one blocks that generates layer two blocks and then you need to execute those blocks so executing the blocks just happens in geth we take geth and uh geth has this very beautiful api called the engine api which is sort of a new thing for the merge um but what it allows us to do is to treat geth like a like a thing that can be driven there's the you know in after after the merge you'll know no longer have this um the the execution and the consensus parts of ethereum are being split into two pieces so you have the part that executes blocks and you have the part that figures out what those blocks should be and we sort of realized oh well we can actually apply the same exact idea to layer two why not you get the blocks from layer one that's the consensus and you do the execution and this can this execution client so in this case the block execution literally just happens in geth which gives you this like perfect evm equivalence because you're not doing any sort of like weird translation into a different virtual machine you're just running geth so everything just works how you would expect it to okay first of all before we do that does anyone have questions i don't want to like i guess it's a workshop it's kind of like a lecture um all right well if people have questions just stop me we could do the whole microphone thing um let me move this up okay okay so um this is there we go okay so what um part of the safety of like of an optimistic roll-up is sort of the ability to prove oh let's let's go a little a little back essentially um people aren't familiar with the idea of an optimistic rollup you're publishing transaction data you take transaction data from users you sort of bundle it together and you publish it to layer one and then you what you're also doing is you're executing these blocks and you're generating the results right you're when you execute a block you get a resulting state route that says this is what the state of the system is you get a bunch of sort of information about the state of the system and we we execute a bunch of blocks and then after a certain number of blocks we take that sort of the state route of that block and some other information about it and we publish it to layer one and the idea is that if we publish this data to layer one then contracts on layer one can actually start to make decisions about what's going on with on layer two and you can use like merkle proofs to basically prove something about the state of layer two given one of these sort of checkpoints and it allows you to do so deposits into a rollup are very very easy it's just a transaction on layer one and this allows you to do withdrawals from a rollup because you can you can do a proof that says i can prove that you let's say you burned this amount of money on layer two i can prove that to you because i have a merkle proof but i can only do that if i have something to do a merkle proof against and that's what these checkpoints are so we do these regular checkpoints that get published to layer one and this gives something that contracts on layer one can execute a proof against so that they can make decisions about what happened on layer two and this gives you deposits and withdrawals so but the question is how do you actually guarantee that this thing that is being published to layer one this this state route or this output that's being published to layer one is actually correct because it could just be anything i mean the whole point of the optimistic roll-up is that it's not you are not performing the the execution of transactions on layer one so ethereum has no clue if the execution result is correct you're kind of just telling it this is what the result was but it doesn't have any proof of this so what we want to do is we we have a program that we're running and we want to prove that that program is ran correctly right we want to take this now i'm getting these sort of mathematical stuff but it doesn't really matter that much we have a program and we want to prove that the program ran correctly that's you know allows us to say based on the transaction inputs that we've published to layer one to output the state route that we publish to layer one is absolutely correct and it can't be wrong so how do you do this proof well whatever you have a program um what does our program look like our program it takes l1 blocks it generates l2 blocks then it executes those l2 blocks and then it takes that that finds that final state root from the last l2 block it's a very simple program and then you know more generally what is a program because it's important we have a machine architecture it can be whatever we want it can be like x86 or it can be something even simpler it could be the evm and then we define operations within that architecture so essentially we have op codes right so the evm has a bunch of op codes x86 has hop codes blah blah blah it's a series of operations right and this is universal like this is sort of what a program fundamentally is and what we're really trying to prove is something about a series of execution steps inside of this machine architecture right it could be the evm we're trying to prove this opcode happened then this op code happened then this alpha could happen and i actually executed those op codes correctly so we have this series of of steps the evm is fully deterministic right so given a starting state and the evm everyone gets the same result this is why this entire blockchain thing even works and um and we want to prove that we ran let's say the evm correctly so we sort of want to prove this the the the correctness of this trace of you just think about it the list of execution steps that's what i mean when i say a trace just the list of things that happened except on ethereum we don't want to re-execute every single step because if we wanted to re-execute every single step we'd be wasting a huge amount of gas and it'd be really really expensive because the whole point of the optimistic role is to sort of not have to do all this this work and you really don't want this proof process to re to be executing an entire ethereum transaction because it's really hard and really expensive um so yeah so the question is you know how do you do something like this with the evm because it's a very complicated program the answer is well either you go and you build an evm interpreter in the evm which is a huge amount of effort and it's not worth it or you can just do something much much cleverer where you can take the you take our your program and you compile it into a much simpler machine so our program here is geth which is sort of like a wrap slit slight wrapper around the evm and then we have these little other parts that i talked about trade you know figuring out the l2 blocks and figuring out the final state route you kind of think that of that whole thing as your program and what you're going to do is you're going to compile it so you're going to compile it into a simpler architecture right um i mean you know you you can compile guest right this is a thing that people do so you you take your program you compile it into a simple machine architecture and if we want to get an execution trace out of this we run our program you know it's a compiled binary we run that with some input and um and we run an emulator and at every step we sort of record what the state of the machine was so we take you know what is the state of the of this virtual machine at step zero okay the memory is this the program counter is this the stack looks like this you take that you take a snapshot of it and you do that process for every single execution step so you can't general you can't really execute this whole thing on ethereum a single transaction generates a massive execution trace so you could i guess do this proof by just uh just executing every single step on ethereum and seeing what the result was it should give you a result it's a machine a virtual machine you can run it on ethereum just like you can run pretty much anything else on ethereum so you can run every single execution step on ethereum but it would take forever it would be really really really expensive so you don't want to do this you instead introduce this idea of bisection games and this is sort of what truebit truebit really pioneered years ago and getting into some more annoying matthew terms but you don't need to know about it the idea of the bisection game is that if you think about your program as a series of execution steps then and you say that the starting step step zero is based on a known state we all agree on step zero but we disagree and we agree on step zero because we must have if sort of if you think about it from the optimistic roll-up standpoint let's say that each one of the things corresponds to a block if i'm challenging block n and i and i it's because i disagree with the result that was published for that block but doing that is sort of an implicit statement that i agree with the result of block n minus 1 because if i didn't agree with the result of block n minus 1 i would have challenged n minus 1 instead so you can follow this logic backwards and backwards and backwards and the idea is that you you are you should be incentivized to always challenge the first thing that you disagree with because if you you should just challenge the earliest thing because if you wipe whatever the point is you're going to challenge the earliest thing and so we agree on the starting state because the starting state is the output state of the previous block which we agree on so we agree on the starting state but we obviously disagree on the sort of the ending state of running this virtual machine and we have to figure out which one of us is right and if you sort of think about it if we agree on the starting state but we disagree on the ending state then at some point in the middle there must be some step where we agree on the previous step but we disagree on the next one that's just sort of you know i could prove it but it's it's sort of intuitive at some point you you got to a point where you disagree so you want to find out how can you find this first execution step where you disagree because if you can just get down to executing a single execution step that's very very cheap and you can do that on ethereum no problem so you want to figure out how you and your sort of your adversary can you know the person who published this result or this this output this claim about the state of lair 2 how you two can sort of play a game and figure out where this first disagreement is and the process we do is we generate our execution traces and we generate a snapshot of this of this machine state at every single execution step and then we turn that trace sort of we hash that that snapshot and then we generate a merkle tree out of it so if you think about the machine starts here and then the machine goes into into its next state and remember this is all deterministic right the machine just operates on a state and it produces some output state so you go from step one to step two to step three at each point you're taking a snapshot and you're hashing it and then you generate this big merkle tree out of this this array of machine states and so then you want to try to find you and your your sort of like i said your adversary are trying to find the first step that you conflict on and so what you do is you look at you you start making your way down the merkle tree and you look at each root and you say do i just do i agree with this root this intermediate node of the merkle tree or not at this point let's say we've gone down the merkle tree we say okay we disagree on both sides remember this is in order of the execution so this means we disagree on the second half of execution and we disagree on the first half of execution somewhere in the first half so we always want to find the earliest steps so we're going to start thinking about the the first half of the execution and let's say okay we agree we sort of go down here and we agree on the first two steps right we agree on this route but we disagree on this route and so if we ground this route that means we agree on these two execution steps we agree here we agree here because we both have the same thing in our little merkle trees that we're comparing but we disagree here so now the question is do we disagree here because this is different or do we disagree here because this is different because they're both part of this this intermediate node and then maybe you know as an example you say okay we disagree because this is different but we actually agree on the contents of this so by doing this game we just go back and forth and we compare our trees and we try to find the first node in the merkle tree where where the hash is different and that first note in the merkle tree where the hash is different represents or the first leaf node in the merkle tree represents the first execution step where you agreed on the previous step but you disagreed on the next one so we're going to try to do is we're going to try to execute this step because you're saying that the result of this step was x and i'm saying the result of this step was y and we're going to figure out which one of this is right and we're going to do that by executing this machine step on on ethereum um so how do we do this it's pretty interesting we literally just built uh a machine interpreter and solidity so there's uh we picked we deliberately picked a very simple uh simple virtual machine called or just simple machine architecture called mips um and it's about 400 lines of actual solidity code so you can actually see like a like a vm interpreter on chain for for very little code which is really cool so just to reiterate the full full challenge process in a nutshell someone publishes a proposed version of the l2 state this takes the form of a hash then somebody else comes in and challenges that state and then the proposer and the challenger play this game where they go back and forth and try to find the first step where they disagree and so you find that step so one of them now executes that machine step on chain literally just like a virtual machine instruction on chain and this is you know it's just a program like a machine architecture is just a program itself that takes instructions and generates some output so you execute it then ethereum knows who's correct because they've ethereum's the one doing the execution so it knows who wins and if the challenger wins then the state proposal is invalidated so this means that somebody else has to come in and say actually this was the correct result of executing that uh block on layer two or whatever it is and then um oh well whatever so optimistic rollups are a solved problem i think this is actually very true they're complicated but not really in a lot of ways they're very sort of you know that architecture that we were describing is actually very very straightforward and the actual the changes that we made to geth are like less than 400 lines of code total um and i could have gone on for way way longer but i won't so let's we can go to questions if people have any questions about optimism how it works any of these little there's sort of a lot of jargon in here but whatever i mean yes we have a little an extra mic okay yeah thank you for the talk server um my beginner question i would say would be like what's the benefit for me to deploy to optimism versus ethereum mainnet yeah sure yeah so um the primary benefit is just that you're gonna get essentially the same exact experience as on mainnet except it's going to be way way way cheaper and and we could do this by kind of separating the execution like mainnet you have thousands and thousands of nodes that are executing all these things optimism it's just the people who care about optimism there's just like a lot less people on the network so it's just cheaper in general um but yeah so it's cheaper we've added some interesting stuff to make it also faster which is sort of these interesting things you can do when you when you are a layer 2 you can introduce this idea of a sort of sequencer which is a block producer and the block producer can give you really really really fast pretty reliable confirmations and so you get sort of a much snappier experience you get to see what your transaction did within like a second or two instead of waiting 15 seconds um and you know when constructed correctly these things basically give you the same security guarantees as ethereum with basically one added security assumption which is that there's a single honest participant watching the chain and willing to perform the challenge process if necessary um so you get basically all the benefits of ethereum with a with a single honest party assumption you're not trusting like a majority of some set of validators just like one person on the network is incentivized properly to do this and um yeah and it's cheaper and faster so and you also pay with ease and gas or yeah you also pay nice with gas so you can yeah thank you of course other questions sure let's uh we'll pass the um i i think we read up somewhere online that one of the sort of subtle differences between deploying on ethereum mainnet and deploy on optimism is that the it says something about being careful about using uh block times for timings in your contracts you maybe just allude to where that comes from why the block time is not consistent in optimism sure yeah so um this basically comes from this like this block producer that we call the sequencer and it's just that you can't make um the the assumptions around the sort of the the what's the word um like the fidelity of the time stamp are a little weaker than on ethereum it's because the the sequencer has a little bit of room um you have to give them a little bit of room in when they can create their blocks and so this technically the sequencer within certain bounds can manipulate the stamp it always has to be going up and it always has to be basically within a certain amount a certain window of the current like actual ethereum time but there's leeway for them to to go like a minute into the future or something like that right so so you can't you can trust it for for many things if you're just trying to keep time over the course of let's say days or even hours sort of longer periods of time where that like minute or two minute fidelity doesn't really matter that much but if you expect time to work within very very tight periods of time you sort of have to trust that the sequencer isn't going to try to use that to explicitly mess with your contracts it's just something you need to be careful with if that makes sense okay um how does optimism compare to zika volups in terms of like security assumptions and also like speed like now and also in the future i guess um that's a good question the i mean at the moment optimistic roll-ups are like functional i'll say um [Music] they're way more reliable i mean maybe except for like starknet which is still still in in alpha um i guess one of the main selling points at the moment is that they're they're very functional uh you have you know you have different assumptions about this the safety this like really it all boils down to whether you want to whether you want to make a like the one honest party assumption or whether you want no assumption at all and the one real downside long term of the optimistic role is just that you have this basically you need to give people enough time to be able to actually challenge these state proposals and so you need a window of time that we call the challenge period where somebody can come in and challenge something um this both of these things i mean the realistic thing is that optimistic roll-ups are still a thousand times easier to build and so there's there's sort of like the other side of the security argument which is like how secure is it if there's like two people in the world that can really audit it at what point is it you know the more complexity you introduce into your system the more you're opening yourself up to bugs it's just sort of like security ends up being the spectrum and we actually think in a lot of ways optimistic rollups end up being more secure at least now in the long term like i don't know very long term for me five plus years you might see zk roll ups i i i actually think that the the way to build these systems correctly in the future is to do a um to do an optimistic roll-up and then when these state results are published these checkpoints are published immediately start generating a zk proof between the last two checkpoints that have been published and so you so in the worst case you get this optimistic roll up if no one's publishing these these validity proofs it's an optimistic role but when people are publishing the validity proofs you can actually you know the validity proofs you you don't even need to think about waiting the seven day period as soon as that validity proof is up you're able to withdraw so now it just becomes a problem of optimizing your prover so you can get very very fast proving times and um and you can just publish these validity proofs very quickly and so you cut down on your on your withdrawal time to be just the length of the the proving time so i i think realistically that the future is probably going to be like a hybrid optimistic zk thing and luckily optimism isn't designed in a way so you can slap this on the current system and it doesn't you don't have to change anything so i just think it's like overly complicated as my answer for zk yeah cool other questions comments concerns opinions i think we got like i don't know 15 more minutes or people are tired we can just just go to bed all right i think we're just going to call it we can just do uh questions afterwards if people have them cool [Applause] [Music] [Music] [Music] you 