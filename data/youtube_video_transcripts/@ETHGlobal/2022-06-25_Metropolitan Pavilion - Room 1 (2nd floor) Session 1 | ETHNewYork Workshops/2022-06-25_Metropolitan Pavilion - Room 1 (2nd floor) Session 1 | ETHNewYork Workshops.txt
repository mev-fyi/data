centralization and storage so for centralization and storage we're looking mostly at application data this might be about the user this might be about a collection of users and with this centralized storage we can oftentimes think about this as like application front ends too um we don't want to necessarily host our whole website on aws or versel or whatever else and this is a little bit what skynet is known for is our decentralized storage but we can also look at centralization and compute resources which is where this talk's going to go eventually and we can think about things like apis that work over that application data and for our kind of model here we can think about this as our application back ends of course this is the off chain back end typically our compute a lot of times the smart contracts is going to be on chain but there's also other apis that get utilized all the time that we can focus on decentralizing and skynet is our magic bullet for solving these things so i want to talk to you a little bit about what skynet does and what we're building towards and so i'm going to talk to you hopefully only about 10 minutes about skynet and then show you what it looks like to use skynet but first as a primer for what it looks like to you know how skynet's built i want to have a little diagram here skynet is built on the scia blockchain it is an application specific blockchain focusing on decentralized storage and it has hosts on its network and it also has renters and on skynet we have individual users in their web browser and on skynet what we can do is have a user take a piece of data this can be an image it can be a video it can be their user profile data and they want to send it to a skynet portal like skynetfree.net that data will then get broken into lots of little chunks and stored across a lot of hosts on the saya network once that's done once that data is persisted that user will get back a sky link if you're familiar with ipfs this is similar to a cid it is immutable it's like a fingerprint for that file it is a way that the user can later verify that the data that they're getting matches the data that they're requesting and with the skylink they can pass that to a friend it doesn't have to be isolated to that user so now we have user b they have the skylink they say hey fileportal.org totally different skydept portal not run by skynet labs i want this file what happens is fileportal.org has a connection with a bunch of hosts it will you know select some that are the fastest it'll grab enough pieces to reconstitute the original data and pass it back to the requester okay so this is kind of what immutable data on skynet looks like we have a mutable data layer too um but talking about decentralization and decentralized apis there's something interesting here right on the right hand side when we're still in the blockchain world all this end to end is verified through typical blockchain stuff but when we start using browsers it gets a little bit weird if you notice i was being a little cagey with my language the skylink is an identifier that means that the data is verifiable but that doesn't necessarily mean the client is verifying it which brings about a question right are we just putting our faith in the portal at that point it might be open source or whatever else but do we have a centralization point happening there let's kind of look at an example we've got a user they've got this file and they use chrome because they love chrome and using chrome they request this skylink from badportal.org badportal.org not surprisingly it turns out bad data but because chrome is dumb it doesn't know anything about web 3 and the protocols and the protections we've built it's going to just pass back this bad file to the user and the user goes on their way um but we could do a thought experiment right like what if chrome browser did understand web3 primitives and the protections that those can grant a user and and you know incorporated them in the browser and what that might look like is that our request goes out to badportal.org we get back a bunk response and the browser's like hold on i know that this is not the right data because i can verify this with the skylink so let me go reach out to another portal hopefully they won't lie to me or censor the data or whatever else the file comes back it gets verified now not just verifiable and the user without thinking about portals or anything else gets the data that they need in a fully decentralized fashion okay so skynet's not building a browser don't worry i know that's uh always the quite a task for some engineers um but we've built something called the kernel and so what the kernel is is it's either run as a browser extension or in an iframe and it is able to load code hosted on skynet and it will pull that code verify the code and then run that code as a decentralized client-side api and lots of websites can share that code so what does this look like in practice well we have a website our kernel and our portal and let's say we have greatscap.hns it's one of the naming services we support is handshake and so the application in its code we'll say hey colonel use the module for doing uploads to do method upload okay and it'll send that request to the kernel the kernel knows how to handle this and so it's going to load that you know blob of data run it as a web worker pass on that request to the web worker and say hey i need you to do upload and this was requested from you know greatscap.hns and then this blob of code we'll know how to handle that it'll talk to the portal it does all the verified's fun and eventually gets back to the browser in a protected safe way fully verified end to end fully open source and fully permissionless okay what if we wanted to get a little bit fancier well the kernel also has an identity layer where you have uh you know a seed and public private keys for doing updates and citing messages things like that and so we might say to the colonel hey i will need you to use this module located at this skylink to do the action registry update but the module needs the user's key but we don't trust the module with user's key the kernel is the only one that gets to have the user's key and we definitely can't trust the client side application because anyone can deploy that very trivially onto skynet so what happens is the module says all right i need a key colonel can i have one the kernel will create a derivative key a brand new key just for that module and then we can do our signing and our interacting with the portal and so i hope this gives you a little bit of a sense of what it looks like for our vision of creating a decentralized api where we can still do authentication we can still do access control from you know modules calling other modules they know the identity of the caller or what the host website is and let's see a little bit of what this looks like in code because you're hackers you're here to code so what you basically have to do this is the module code for a very trivial module but you'll clone a repo and you have a file where you start writing out your code and aside from this boilerplate basically we have to add handlers so the requests have a method and this method is called sayhello and then we define a function that handles the requested method so this function is called handle sayhello we'll log some data and then we respond to the query with arbitrary data and here it's an object with messages of the key and why hello as the value from the client side in a react app or wherever else this code is real clean and simple and so you import this call module you want to have the skylink of the module which we here should have as a constant and we say await call module so call out to the to do module we want to do say hello and pass along some arbitrary data or action or whatever else we'll await the response grab the message and be able to use it and so you know getting started building these apis is actually not that complex we have a pretty tight built pipeline where you're able to quickly deploy these things to skynet just using your cli and iterate against it but apis are made to be consumed right for the most part we want more people consuming the apis than producing the apis and so how can we do that i've already talked about saya skynet skynet kernel i know it's a lot going on so let's look at what these layers of abstraction are on saya we have this fast and secure data storage and a decentralized blockchain that is still private though so we need to make this accessible to the web which is what skynet does and then to make these rich applications for web 2 developer experience on web3 we need to enable identity and shared code execution which is what these skynet modules can do these kernel modules excuse me can do and then lastly what we're seeing is that people building these kernel modules then just write normal json libraries that wrap the annoying call module or whatever else right so we're going to see a few of these in the demo but the idea here is that we can do another layer of abstraction so it just feels like interacting with javascript code for the end user the end developer the user doesn't really have to know too much that even a decentralized backend is supporting it and we can empower really powerful decentralized experiences where users can share their data across different apps in a safe and private way okay so let's build a social dap on skynet so modules tend to isolate and separate out specific types of behavior and so we for building a social application are going to need something for identity we're going to need a social graph we're going to need a feed of posts from those users and we're probably going to want everyone's user profiles so we can have pretty things like avatars and bios usernames so there is a set of developers in our community that have published skynet dax library and that is a one of those wrapper libraries so you don't have to deal with call module or anything else these expose methods for interacting with these abstractions on skynet and if you want to follow along or follow along later or want to take a picture this is the github repo of the code that i'll be working with in the demo and let's build okay so let's take a look at that repo sorry about the plosives um are folks able to see great i think that seems pretty good okay so i'm in this hackathon ideas workshop and this is the code i'm working against here and i want to show you that as a react app i've already built out all the ui elements so this is just mock dummy data this is not coming from skynet at the moment but this is what i want to build so i want to start off here i want to build an idea hackathon idea decentralized web app where we can have people join a social graph of hackathon participants and mentors they can create new ideas and then see a feed of existing ideas from other folks in the hackathon so that new idea page will be over here and i can put in some details and if you take a look at the repo later you'll notice kind of everywhere these wires everywhere that i have these kind of mock statements but all of the logic for dealing with the kernel and these decentralized apis is going to be in this hooks folder so basically all of this is ui stuff but we're going to really focus on authentication and then using these social modules so let's take a look at this right now i am basically to do authentication i have to use the functions in the lib kernel library which is produced by skynet labs and first off we need to load the kernel so this is our bootloader and once we do that we'll set state in our ui to say the lo the bootloader is loaded so let's kind of just start stepping through this um actually what does it look like when we don't have a bootloader loaded let's start from the very beginning here all right so the boot loader's not loaded boot letter loads pretty fast so we'll get rid of these skeleton elements and our bootloader is loaded once our bootloader is loaded um our user is not logged in so we have to provide a button here to log into the kernel again i'm just kind of showing the ui and login flow here but then once they authorize with the kernel produce their seed then the kernel will load and we'll start kind of preparing to load in other data and once the kernel is loaded off of skynet the code that does all this protection then we'll be fully ready to use this data and again this is just mock dummy data for now but what does it look like if we drop that off and actually call the necessary functions for interacting with skynet kernel so we await an init that's our bootloader and then we basically await a promise from login complete so whenever the user is finally logged in then we can start doing some stuff in our application so these are just kind of fairly boilerplate honestly if you want to build a react app following my example here so let's go ahead and save i'll do a hard refresh over here and now in actuality i will be calling out to skynet to load that bootloader load in a kernel and get going with it okay okay so now if i've done my authentication correct now the user is authenticated and i can start interacting with these this library that exposes all this social behavior so as i mentioned before we have identity which gets us the user's id in this public decentralized social network it's a ed25519 pub key and um we can use that to then look up their profile look up their social deck and look up their feed deck so they're this is their friends list and this is their list of posts and you know i'm not going to use any post here we're going to have some selective elements where we modify which posts we actually want to show or display and so instead of returning the um photographers are distracting instead of returning this kind of mock data for our profile let's start using the use dax hook to actually expose real behavior that will then export to our ui okay so right now i'm returning early with mock data let's comment that out and now if i reload my app what should happen is i should load my bootloader we'll temporarily see the kernel loading and once that's loaded now that decentralized api is going out grabbing my profile data that i was you know on my own assigned on skynet all the data's persisted to skynet the user profile image is persistent to skynet and it's loading that identity into our application and what this looks like from the code side is that we have the identity dac we say hey grab the user id and let me know when you get it back and then let's pass that to our profile abstraction and we want to get the profile for that user id then once we have the result let's update the state of our application and keep going so there's a lot of react-y stuff going on here if you're unfamiliar with react the actual kind of kernel stuff is not too deep or dense here okay so also we waited until we were authorized authenticated on the user side and we waited for our kernel to load well great how about these avatars right here if we go and look at our element for that on our hackers component we kind of have a function where we say we want to get the user avatar for some some predefined folks that we know these are our participants and mentors um so we have a list somewhere i've defined a list it's going to be in the bottom of use dex i defined a list of the user ids that i want to define as like participants and mentors and so now i want to grab their avatars instead of grabbing um this mock data and under get user avatar i can stop returning my mock data and instead say let's create an instance of our profile dac remember this library that wraps a module interaction and called get profile with the user id and then um that's a sky link which is you know we need to then define the portal that we're accessing them from and that's what this method does but at the end of the day when we save that what will happen is we can refresh our page and as these things load again our application reaches out to the kernel saying hey i need this profile for this user id but i want you to use this module and the code in this module and then it will reach out to the next place which will reach out to the skynet and so now we see these being pulled in in real time off of decentralized storage this is fully decentralized end to end which is pretty impressive especially if you have experience building on some other decentralized storage projects all right how am i doing on time decent um so this is kind of cool like i'm a brand new user i don't follow any of these people but i have a list of you know basically i can bootstrap my social you know social graph that will follow me from application to application on skynet by basically writing my own method that says here's a list of people go follow all of them and tag them as being associated with a specific event and so that's what this follow user list method does i say let's use the social dac for all of the users in our user id list that was hard coded into the program let's go ahead and follow that user id and if i pass in some details i can then add some metadata too so that later on i can know why i followed them or whatever else and you know there's nothing built into any of the protocol pieces that require me to use this tagging or use whatever else like this is all community developed and open source and everything else so i think that's an interesting aspect here that we can design how we want social graphs to work um and even extend how they work and use that extension in our application but still have that data be interoperable with other folks building in the same paradigm okay so if i save that now as those load i already know these user ids but i can click follow all and i'll just in the back end that module will start following these users i want to mention maybe right here before i forget this is kind of the cutting edge of what skynet is working on we've focused a long time on decentralized storage and we've started seeing all the potentials for decentralized apis being fully hosted on decentralized storage so there are spots where we are still doing optimizations uh things that are called sequentially that you know with a couple hours work will be called in parallel um and so you'll notice things that like following these folks is going to take a little while but we're excited to have developers start building on things now so they can have a voice in the direction that things move and what we focus our our efforts on so all right i'm gonna just try to like fly through a few more before doing my uh closing appeal to everyone let's look at our ideas feed and instead of returning our mock data let's return actual data so here what i have is a set of users and for each one of these things i'm going to eventually grab their user profile but we've kind of looked at the profile deck so i'm just going to skip over it but what we have is a oh i broke something fun okay what we have is a reducer here um basically what that means is a piece of state that we can kind of keep updating with the previous piece of state's state and so what we're going to do here is call this updater um every time we see a new user and grab their current social feed and we're not going to grab their whole so we are going to grab their whole social feed actually but we can just really quickly filter it so what we're going to do actually specifically is call sorry it is down here on our feed deck we're going to call load posts for user we're going to pass it our user id and we'll get back a big list of posts and we can quickly call a filter on it to say we only want posts that have a content field that we've extended that is called event we could say activity hackathon whatever else but here we can just say if it has an event field let's use it and then we'll pass that onto dispatch ideas list which is a complicated way of updating the state but you can see that grabbing the data off of skynet is actually pretty easy for the end user now but the module developer has abstracted this decentralized social network behavior and it would be cool if things loaded all right so the last behavior that we haven't seen maybe we can watch a few of these ideas load and pop over into creating a new idea but while it's grabbing some of those we've created a create post method here that we can call from our user side as well and we can just pass it a title for our project id some text identify the event price track whatever else and now we're making a post on that user's social feed that has this extended metadata that can any application can utilize for whatever they want but this is really cool because you in the ecosystem have other folks that are building aggregator type infrastructure and so now your application specific data that is tagged with certain stuff can still be included by maybe scrapers or aggregators or other user interfaces and that's the beauty of this fully decentralized structure is that this application data is totally interoperable everywhere else and again you'll see that we're using the feed dac to create a post pass it this information that we've formatted in the correct way and then it will be added to the feed so let's take a look for a brief second to kind of see we're loading in some of the feed items from members of our list up here above but let's go ahead and add a new idea we want to have a super big prize winner and we'll be at east new york trying to do the public goods track and we'll be building with you know solidity flutter and hard hat i don't know if those make sense together and we're looking for a team now when i press that button i can call again this create post and what happens is that data is persisted to skynet and then i'm immediately pulling that data off of skynet into the social feed using fully decentralized storage using decentralized code stored on decentralized storage and using a decentralized stored on skynet piece of code to do all that verification all that message routing and everything else so from end to end it's always forkable it's always verifiable and yeah and for the user they don't have to have crypto or a wallet or anything else to interact with it so i hope you see some of the potential and are a little bit excited about some of the direction that we're going again if you want to look at this later on you can see where i just comment out mock data on the hackathon ideas workshop and we also have beta documentation because this is still new and is at kernel beta kernel-beta.skynetlabs.io and i'm going to annoy someone by going about 30 seconds over here we're doing a call for builders so we've just released this beta we really want feedback from folks building decentralized applications especially those that have maybe experience in web 2 or elsewhere we're putting up 8 000 in prizes for anyone that it creates or consumes kernel modules in your application so you know there's gold and two silver prizes um but you don't have to create a kernel module or a decentralized api to be eligible you could just bring in some of these social components identity user profile whatever and still be applicable for the price um i just said all that to learn more check out kernel.beta.skynetlabs.io if you want a free account for 100 gigabytes of upload for decentralized storage check out skynetfree.net come say hello to me i'm going to be downstairs showing up my booth for a long time and i super appreciate everyone's time and attention and check out our discord i don't think i have time for questions is that correct okay um not necessarily no um if you want to have kind of like that sort of privacy on skynet what you want to do is use encryption to do that layer of interaction i mean i guess in theory you could spin up like a private saya and a fully private skyneck that's all open source and you can do that but by the default architecture the idea is that these portals share this kind of big data lake more or less um no matter what portal you're running or accessing it through yeah so the relay economic relationship for getting data on this siya is between the user and the portal so skynet labs is using a freemium model where we let users have 100 gigabytes of storage for free and like pretty generous access speeds but if you want to ramp those up for five bucks a month or whatever else because we're focused on like making this really accessible for web 2 users that aren't on the crypto space yet um but it's a fully open source stack and we're really excited for folks to open up portals where you can pay in crypto or anything else and then the portal itself is paying insia coin on the side network because that's what that protocol does so all right thank you so much for your time and attention come see me if you're interested in the prize and i'd love to help you out today we're going to be doing a 40 minute workshop on building full stack dapps and really my goal here is for people who maybe you know there's a lot of protocols in this space there's a lot of cool projects coming out but for me when i first got started in web 3 i kind of found it hard to find what a web3 tech stack looks like right now like what actually works what works well together and then piecing together how do i actually make all of these different pieces of the stack talk to each other so that's what i'm hoping to accomplish today so that you can leave ready for the hackathon and i'm going to leave you with some resources that you can fork and clone and it'll help you get started a little bit easier hopefully so part of this is going to be a little presentation kind of just going over some of the basics that i want to communicate and then we're actually going to walk through a project i wanted to live code it but there's just not enough time with what i want to do so we're actually going to walk through an existing project and then at the end like i said there'll be some resources for you to just get started with so really quickly about me i do developer relations at edunode which is a core developer of the graph protocol i've been there for a few months and then i come from a more traditional software background i was engineering at paypal on the checkout experience for about a year and a half and then i worked at a startup for some time in between paypal and where i am now i also took a more traditional path to kind of my career i studied computer science in college and i've been an educator for six or seven years before doing developer relations i taught kids how to code back where i live so i've always loved to teach this is what i love doing and now with my job in denver all i get to teach adults so that's just about me so let's talk about the web3 stack so this definition is actually taken from a blog that edunode wrote a few months ago but it's really clear really concise and one that i wanted to use here so when people ask like what is the web3 stack i think the best answer that i found is the set of protocols that enable you building fully decentralized applications so it means from beginning to end there's a set of protocols that allows you to build dabs in a way that there's not any layer where it's like oh this is you know aws or this is you know you're putting this in like you know some standard database so it's the set of protocols that allows you to build end to end fully decentralized so before we get into kind of what my stack looks like and maybe what i would recommend for now or at least what i'm building with i wanted to talk about some of the characteristics and some of the important pieces of the web3 stack so as we move on this will make a little bit more sense i know we are all like really familiar with all of these i won't talk through them specifically one by one but one that i do want to focus on is um native digital payments that's like the one thing that i feel like was really key when i first got into web 3 is when you think about web 2 like someone put it this way and it made a lot of sense to me in web 2 we put things like music and movies on the internet and this whole concept of like putting things that were in the real world on the internet like in web 2. and now we're doing the same thing with web3 by putting money on the internet and making money native to the internet rather than like some external thing and obviously like native payments is a huge part of web3 and why we're all here there's incentive mechanisms behind a lot of these protocols so i just kind of wanted to highlight that and then the other one that i wanted to highlight was self-sovereign identities so you know like just today actually this morning um the supreme court overturned roe v wade and now it's up to states to decide if abortion is legal or illegal in their states and someone brought up a good point that there is a period tracking app called flow it's an app where women and you know people with periods can go on there and track their cycles as a way of kind of like no hormone birth control and the way that it is now in theory if you are using this app your data is owned by flow and flow has been caught selling your data so in theory right if you are using this app and the government like your state government wants to prosecute you for having an illegal abortion they could take the data from this app and say look you usually get your period i don't know the 20th of each month and for the last three months you didn't get a period and now you have a period so obviously this is a very like nation specific example that i'm giving but it's a very real world relevant example today where other people owning our data and having access to our personal data that can then be used against us in the world that we're in now isn't really a world that i think i want to live in specifically as a woman like going through all this so that's another thing that's really important here okay and now getting to kind of the building blocks that we're going to talk about here as we build out our stacks so kind of the primitives or the building blocks is obviously a blockchain and l1 blockchain development environment so as i'm listing these out and you're hacking this weekend start thinking about what you're using for each one and obviously you don't need every single one of these it just depends on what you're building all of these are specific to a project but as i'm going through these and you have your idea think about which ones you're going to need and then think about which ones you might want to use so as we go through this talk you can say okay i wanted to use this one but she talked about this and then you can go back and look at the wreath like do research between them figure out the trade-offs and then pick the best tool so as i'm going through these that's what you should be doing so an l1 a blockchain development environment and i'll go over examples of what these are right after this file storage off chain data protocols api for indexing and querying identity a client oracles and then i just grouped all these other as other protocols and this is actually also from the edge and node blog post that i'll link at the end if you guys want to read more thoroughly so i have this little visual here this is what you should take a picture of if you are going to hack so this kind of lists out all of the different options in each part of the stack that i just described so as you're thinking through your project and you're like for example i need something for you know i need an l2 or a side chain what's going to be the best one for my specific project you can look through this list and like a lot of these people are here actually sponsoring so you can go learn about them but as you guys are all taking pictures you'll see there's a lot of options for all the different parts of the stack and the thing that's important to remember is that there's no one tool that's the end-all be-all for and it's not the answer to every single thing you should always like take a look at all of the options and decide what's the best one for this specific use case in this specific project so what i want you to do is don't walk away from this talk being like oh like what she said is like what i should be using in all my projects this is what i'm using for some specific projects and you should take this stack and adapt it to your specific project needs okay and then some that weren't included in that picture that i do want to include specifically for this hackathon because they're both sponsors is live peer and lens so live peer decentralized video infrastructure it allows you basically to build in live streaming to any dap really easily so if you're familiar with next.js you can literally just enable live streaming and then like minting video nfts just from an api route and then lens decentralized non-custodial social graph for building composable social applications um there's qr codes there there's like guides to start each if anyone wants to take a picture these aren't going to be on another slide so i'll give you guys a second case anyone wants to okay cool okay great um so here's what i'm using for this project that we're gonna walk through together um it's called web3 rsvp and we'll go through it together but basically the project is a way for you know you guys know eventbrite it's an events platform where people can create events and then users can go on there and rsvp to different events the only thing that's different is that you as a user you have to deposit some ether and then you'll get that back when you show up kind of like what you have to do here i think right like hackers had to deposit some and you get it back when you actually show up and it's basically just to combat the problem of like all the lists filling up really fast and then people don't actually show up and these places are half empty so that's what we're going to go through so for my l1 i'm using ethereum for my side chain i'm using polygon for the rpc provider i'm using infuria in this specific project but i've recently started using anchor and i really like anchor a lot for my dev environment i'm using hard hat but i've also started using truffle recently really really recently it's newer and like it has some advantages over hard hat for specific projects so i'm going to start trying to use truffle more for off chain storage i'm using ipfs and web3 storage for indexing i'm using the graph for identity i'm using rainbow kit and coinbase wallet and we're going to talk through what this means in a second but rainbow kit is a way for you to easily offer your users a basically that like connect wallet button at the top and then for the actual wallet i'm using coinbase wallet which is also newer so i was kind of testing that out and have been experimenting with that and then finally for my client i'm using ethers.js so now i'm going to walk through this with you guys and what this looks like okay okay so i'm gonna walk through the setup let me double check my time how much time i have okay cool so i'm gonna walk through is the text big enough okay i'm gonna walk through the setup for so really what i want is like if you're here and you're like i have a really good idea but i'm not sure like the nitty-gritty like how do you set up an rpc how do you make your smart contract talk to your friend and like how do you do all the little pieces that make everything come together that's what i'm gonna like walk through here so real quick i'm gonna just show you an overview of the contract contracts it's so small okay there sorry so like i said um in this contract we are setting up a struct because in this contract multiple people should be able to create multiple events right so this is the way that we're storing the events in the struct is where we're storing all the things that are related about the event so for this specific example we're saving an event id the address of the person who created the event the time stamp of the event the max capacity of the event the deposit that needs to be sent in order to rsvp to this event and this event data cid so this event data cid is related to off chain storage so you know to save things on the blockchain it's a cost gas right so for this project i wanted to minimize the number of items that i'm actually saving to the blockchain because for example the event description i don't need to save that on the blockchain i can save that off chain save money it doesn't have any effect on like the security or the functionality of the app so that cid is just for you guys to know that's related to off change storage and we'll talk about that in a second but it's basically the ipfs hash the reference to our data that's going to come from the front end so then we create this mapping where'd you go okay so this mapping so this mapping maps the id and id to a struct so here what we're doing is we're creating this collection it's basically like a dictionary where for every id you can find all the information about the event that we just listed the timestamp the deposit the max capacity and then here we have our functions that do the different things the first one the most important one is creating an event we pass in all of these information including the cid so that's something to know so remember we're going to have to compute and get the cid before actually calling the smart contract function which we're going to do in the front end so just hold off on that but then when we do have that we're going to pass it into this function this right here creates a unique id by hashing together a few of the different arguments because what you want to do is like in a hash table obviously you want to minimize what are called collisions where basically you want to have a unique key to every definition so if you have two that have the same key you're going to be referencing perhaps the wrong one so one thing to combat that is to get a really really unique id by hashing together some of the parameters that get passed in so that's what i do there and then um here is where you actually create that entry in the dictionary by calling this and then one thing that you'll notice in my contract is i have a bunch of custom events so here i'm writing custom events and the reason why i'm doing that is because in order for my indexing and query layer which in this case i'm using the graph in order for it to understand what's going on in my smart contract the data that i want to expose needs to be exposed via events so the data that you want to index and query needs can only be accessed via events so that's why you'll see you might be like why are you creating an event and then also and i mean like creating the actual event with the function why are you calling the function create event but then also emitting an event called event called new event created that are basically exposing the same data right but it's because my subgraph it doesn't have access to my functions it only has access to my events so that's another thing to know if you want an indexing and query layer and what that does is it allows you on your front end and in this app that i'm going to show you it allows you to build a dashboard of past events events that i've rsvp to events that i've created it's a way for you to ask questions about your data from this contract so for example how many events have irs we peed to how many events have i created and you know with that data you could build a dashboard for each user to let them know what events they have coming up what events have already passed so in order to do that with the graph you need to do it via event so that's what these events do and you'll notice at the end of each function i'm actually emitting those events then i have a function called create new svp new rsvp where i pick the event based on the id so someone the user passes in the id i go locate that one and i say all right for now on we're calling this my event um then we you know they have to pass in the minimum deposit the time stamp has to be such that the event hasn't already passed they get added to this array of rsvpers and now we have this array of rsvp peers right but now in order for them to get their ether back they need to actually we need to have a mechanism for them to be confirmed or for them to be checked in so that's what this next function does so again we pass in an event id so we know which event we're talking about we have to make sure that the person calling this function is the owner of the event which is why in our struct when we defined this we added that in so all of these little pieces that are there they're there for like a very specific reason right and then we loop through the rsvps we loop through the rsvp so this is confirm all attendees and it just confirms every single one one by one so we made this function because for example if you guys are all here and let's just say 50 of you guys rsvp'd and i counted and there's exactly 50 i don't want to have to manually like confirm everyone one by one so i might just want a button your users might just want a button to do confirm all so that's what this one does and then down here we have confirmed specific attendees where you pass in the event id and then the address of the specific attendee so let me just show you guys what this looks like on the front end for you to have a kind of like a better idea of how this looks okay okay so this is what it looks like um here is where the events that get created um end up and if i connect my wallet and we'll talk about how to do this too i just kind of want to show you so you know what i'm talking about when i say certain things if i go here to my rsvps i haven't rsvp to anything actually with this wallet so let me do that real quick um but this is where it'll show up and you do this using the graph using your indexing inquiry so if i go to rsvp actually i don't know if i even have matic but i'll just try this real quick okay i don't have enough matic okay but let's just say i rsvp'd then it would show up in my dashboard and then i would be able to create an event this is the app that we're talking about so now let me switch back to the code okay and then finally withdraw and claim deposits i'm not going to walk through this this is basically for the event owner for people who didn't show up for me to take your money because you didn't show up so i get to keep your deposit that's what this function does so now this is our back end right this is our smart contract but now we need a way to do everything else in our client application so i'm going to open that code up right now too okay okay okay okay um important things to know so create event is the um file in our next js project that's that page where someone creates an event god damn it here let me show you i forgot to show you that oh man i stopped the server okay well it's like a form where you just put in the event name the event description all that stuff that we talked about but some things that aren't in our smart contract structure so remember we didn't have like event name we didn't store that in the smart contract we didn't have event description we didn't store that in a smart contract but still it's stuff that we want to show in our app but the only difference is that we're not actually storing it on the blockchain we're showing it off chain with web3 storage and that's what i'm going to walk through real quick so let's go down here real quick so here is this form so here event date and time this is where the person fills in the date fills in the time fills in the max capacity all the stuff that i talked about and we save this all in state you know react state and then what we do is we pass the stuff that is not on chain so to web3 storage with this call right here so it's just the next next.js route it's called create event so let me just pull that up so you can see what that looks like so an api create event so it's just a function that initially checks the request if it's a post then it passes it down here i won't go through this like line by line but basically all it's doing is it's taking the body of the request and it's pushing it to web3 storage and it returns you a cid remember that's the cid that's like an ipfs hash reference and it does like this one is a little longer and a little bit more complicated i would say because we're passing in an image too so it's not just text but if this was just text it would be much simpler but here i'm passing in like an image and that's how you get that really cute image so let me just show you here so in create event okay here so in create event this is where we make that api call so we say hey we've saved everything in state here's the body here's everything that we want to store off chain the event name event description link and the image so now that we've stored the stuff off chain once that response comes back as successful like yes this has been posted to web3 storage it's up on ipfs now we actually need to make the call to execute the function on the smart contract and pass in the cid because remember in our smart contract it wants it wants that cid in order to do that let me show you real quick create event it needs a cid so that's why that we did this in this order because in order to call this contract it would be missing an argument if we try to do it the other way so first we make the api call to web3 storage then it returns to cid and then down here once it's successful boom so once it was successful then we call create event and we pass in the cid and everything else has already been passed in and um yeah there we have that and then when we're talking about identity i said i'm using rainbow kit and coinbase wallet so it's really easy to set up and i'm actually not going to walk through it because what i have is something better i created a uh like a starter repo where you can just clone it and it has rainbow kit wag me tailwind next and a wallet connect function already set up so the only thing you have to do and i'll walk through it is basically import your abi oh yes so for people who don't know how to do that inside of i did it inside of a utils folder so you just create a folder at the root of your project call it whatever i call it utils and then you make the name you know whatever name of your contract.json and you just paste in the api from your smart contract but that's important so now if we let me show you guys this real quick uh front end starter okay so with this front-end starter that you can clone and use for your project there's this function here called connect contract can you guys see that yeah connect contract and the only thing you have to update is you have to pass in your contract address and then once that's in you'll be able to so you know for every page that you're on in xjs if you want to call a function on your smart contract you need a way to make that communication between your front end your smart contract this utility function does that so instead of like manually writing this in every file we abstract this out to a util and then you can just import that so here if i go to index i've already done it for you so it's already imported and the only thing you have to do when you're actually ready to call your function and i also added it down here is you just do you know const you know this is called your contract or whatever and then you call that function that we've created and then that way you can start calling your function so this is called rsvp contract with you know it'll be your contract here and that way you can use it on every page in your next js project and you don't have to write the logic to like actually connect to your contract that way okay i know that was a lot of talking does anyone have any questions up until this point okay um so yeah this the what you're seeing now is a template so let me actually maybe i'll just like run it so you can see but it's just it basically just has everything installed so it's still like a blank canvas this is what it looks like so it has rainbow kit wag me next js tail when css so i'm on the wrong network but this is a button that'll allow you i don't know maybe this is the right network um but it'll allow you to have yeah the connect to wallet button right away so you don't have to write any of this logic yourself and yeah basically you can just start developing the logic to connect to your contract is there the logic to connect to your wallet is there the logic for that's built into next.js that's really great like routing and all that good stuff is already there and then you basically just have to import your own api which you know is just copying and pasting that into the utils file and then you can start developing so let me go back here now so is there anything i didn't talk about i didn't so let me get into the graph a little bit more how many of you guys already know how the graph works or you're familiar with it so so so actually not that many people um okay cool so the graph like i said i'm going to talk about it six minutes so the graph is an indexing and query layer and it basically allows you to efficiently read data from the blockchain so you know right now you can go to you can go to etherscan and you can i don't know what's a popular project uh crypto punks sure you can go to any contract right and you can read information about that contract you can read data from the blockchain but it's very one at a time like let me give you an example immatash i don't know so like yeah you can read data from the blockchain as it is now but you kind of got to read it like one piece at a time but if you want to make more sophisticated queries or to ask complex questions about your data like you want to understand a relationship so for our thing maybe i would ask how many users rsvp to this event and showed up or how many people created an event you know have created more than 10 events in the last year those types of queries you can't really make manually as it stands right now just directly from the blockchain so the graph allows you to do that so it reads all of this data that you're interested in um it indexes all this data for you so that it's efficient query times when you do ask questions and then it allows you to make queries with graphql so if you're already familiar with graphql it's the same exact query api you can ask questions the same exact way and yeah as a developer basically what it allows you to do is hydrate your ui with data from the blockchain and when you're developing smart contracts a lot of your data is coming from the blockchain that you're in that your front end user is going to want to know like for example what is the deposit amount for this event that's on the blockchain and we need a way to actually read that and the way that we're reading that in this specific um case is through a subgraph so i can show you guys that real quick too just so you guys get an idea so if you write in javascript or in typescript it's going to feel really familiar because the mappings are written in assembly script and it's basically just like writing javascript and telling and writing the logic for like i'm interested in this data this is how you get it and this is how you construct an object to then send it to your ui so let me go here subgraph okay so you should be able to understand this because you just saw the whole smart contract so let me show you in source mappings okay is this really small no it's not okay so when a new event gets created on the blockchain right we need a way to display this on the front end so the way we do this is we create an object maybe i should show you that first we create an object in our schema so those who have maybe experienced with databases or with graphql you know what a schema is but for those who aren't familiar with the schema it's basically you just defining the objects in your model if that makes sense so for us the objects in our model are an event and an account an rsvp and a confirmation these are entities that are unique to our project and if you make a project with a graph obviously these will be unique to whatever you're building so for example here this means that i want to be able to query for an event and i want to be able to query for all of these different properties in an event right so this is what we're defining this is like the dictionary we're saying i want to be able to do this but now in the mappings you actually tell the program how to get this data how do you actually form this and construct this object to then return it to your front end so this is what's going on here so we say okay when an event is created this is what should execute in order to build that object for me i can't really see from here um yeah so like the event id you can get it from the parameters the event owner you can get it again from the blockchain who's the person sending this message and all of these things you can get from the transactions that were made on the blockchain that you just wrote in your smart contract but here you're just saying this is the logic for how to find it you're just giving them a map this is how you get it that's all you're doing um and then for example the stuff that is off chain so stuff that's on ipfs you know it's not on the blockchain there's still a way to get it because there's an ipfs api that'll allow you to do the same thing for ipfs and the only difference is that because this is metadata we're passing in the event cid so that the program knows where to actually go and fetch this stuff from and what we're doing there is we we're literally just like going through this object so you know json is a big object and then it has different properties where it's like name description i think those are the two things that we stored off chain oh and oh yeah image and link so then all we're doing is we're saying hey if this ipfs hash is true if it's valid if it doesn't come back as a falsie value then go ahead and like you know because it's an object i'll it's a like one level object there's no nested objects you just i'm just going to ask questions and i'm going to say hey look for a value called name look for a value called description look for a value called link and photo and when you find it save it here and then if these come back to be truthy values again so if these don't come back as false like if they're not null or you know for some reason we spelled it wrong then this is how we actually construct the object we're saying my event the big entity dot the specific property equals that that's the construction that's how you actually make that object um and this just repeats for all the rest of the stuff that we're doing but that's the big picture okay almost done last thing i want to talk about present okay cool so we kind of talked about like um what the stack that i use is again you should take this and apply it to your own uh project based on what you're building but i did want to highlight the bounty so if we talk about building something with the stack that i just uh referred to there's what 20 40 65 68 68 000 in boundaries just with the specific stack that i talked about here and actually forgot to mention radical but radical is a decentralized github so they have this product where you can host your code and there's literally a prize for fifteen hundred dollars just to a project that hosts their their code there you can still host it on github if you want you know obviously to you know keep it forever and for collaborators to use but you can literally just host your code on github and be eligible for this bounding it's like the easiest bounty ever and then here is that quick start uh front end repo where you can just clone it and that way you'll have wallet rainbow kit wallet connect wag me ethers tailwind next.js you can clone it you know sorry you should fork it first then clone it and then do your thing on there i'll pause because people are taking pictures real quick yes exactly so the graph um maybe i should have shown that but the graph in addition to the schema that you define in the mappings you also define events to listen to and basically in order to guarantee that you always have the freshest data and you don't have stale data like you know today we make a query and there's ten events on the platform but i create three in the next hour we need a mechanism to refresh basically and re-index so the way that you do that is you define some events so for example for my contract right the event was new event created so then we say okay when new event created gets admitted i want you to re-execute the the mapping which re looks you know rechecks and loops through all the metadata and does it over and over and over again until we have the freshest data so yes um so that's that front-end repo i see one more person taking a picture so i'll let them do it got it okay cool and then the other really really cool thing that i want to talk about here is 30 days of web 3 is something that's being hosted by women build web 3 where a dow that's pushing forward female engineering talent in web 3 but this is open to everyone it's going to be it's education that's going to be open source when it's ready it's launching in two weeks and it's a 30 day curriculum to basically hold everyone's hand through developing a full stack dap and kind of help them build that reference and that mental model for what it means to build a dap so that hopefully by the end of this you'll be able to say okay i have my own idea and i've done this once i just kind of got a remix you know the contract because now i learned how to do everything else i just got to remix and tweak small parts but i know how to build a full stacked app and actually i want to pull this up real quick so you can see it kicks off into oops it kicks off in two weeks and you can register at 30 days of web3 dot um it's open to everyone it's free and the the cool thing is that you're going to build the project that we talked about in this mini workshop here of like building a web3rsvp app and the even cooler part is that there's going to be live workshops by all of these different amazing developers and developer advocates that are like experts in their specific part of the stack and they're going to come do live workshops like this but more specific to whatever part we're talking about that day or that week and this was also built with like really amazing support from these orgs and these protocols um so yeah there's some faqs at the bottom tldr yes you can join if you're a man or anyone can join it's going to be open source the time commitment is 30 minutes a day this is all online and asynchronous so in theory you can do this in a weekend if you want you can do this in a week we just are dubbing in 30 days of web 3 because that's the pace that we're going to go on and the pace people can follow if they want to follow along but you'll be able to do this at any time by yourself okay cool and then finally thank you that was it if you guys could see my feet right now look at my feet i've literally been tippy-toeing the whole time and my cows are so sore right now okay does anyone have any questions you good one question back there um they're not actually can me in this thing they took it down but uh yeah right there i'll post them there and then it's the same as my github handle so yeah i'll post them there cool all right thanks everyone scaffold eath if you guys aren't familiar with scaffolding it's just amazing awesome open source program or a collection of tools it's kind of like a tool kit that you can use to rapidly deploy ethereum-based uh daps real quickly so it's available on github so really you know you can kind of get started real quickly by just forking the code um we're going to go through a demo today and kind of walk through it and show you how you can tinker but all the instructions are here so you can get started real quickly once you get through kind of tinkering around with with scaffolding you can kind of go on there and put in examples from like solidity by example and kind of mess around with it uh and after you've been kind of playing around with the bit with it a bit you can go to uh speedrun ethereum so the speedrun theorem is then on this like uh kind of these quests that you go on where you learn how to do different things like build an nft uh be it build a decentralized staking app token vendor dice game there's all these cool things you can do and eventually you can become part of the build guild which is this kind of like collection of of coders that want to build on the ethereum ecosystem so check that out uh everything you need is right here so you guys if you guys take a picture of this this will give you the website for github this will give you speed around ethereum and you guys can get started um but yeah so we don't have the app up right now but i i use what's called tmux which is this just a terminal multiplexer allows me to have multiple screens up i've already gone ahead and checked out the code for you guys so we're just going to kind of get started and get going here everything's here when you first download the repository you're going to do a yarn install which is going to basically go through and it's going to install any dependencies that are required to get you up and running so do the yarn install it takes about a minute or so to run and you'll be good to go then what we can do is we can do what's called a yarn chain okay yarn chain is going to spin up an instance of hard hat scaffolding uses hard hat it's going to spin up that you're going to be ready to go that's all you need then in a new window you're going to come over here and you're going to do a yarn start which is basically yarn start is going to spin up react so the front end that you utilize with scaffolding is react um that might take a little bit to load so while that's kind of doing that what i'm also going to do and that's going to be the second window that you're always going to keep up the next one i'm going to show kind of what the the data structure of the code looks like okay so you'll see when you first get in here inside the directory there's uh let me close this out for it now there's this packages directory so inside there we have hard hat and we also have react and then we also have subgraphs so if you want to do a a sub graph using graph the graph a graphql sub graph you can do that as well but the most of the stuff that you're going to really be messing around with is going to be here in the in the hard hat directory right so inside the contracts there's this kind of like bare bones contract that gets deployed and it's kind of like a hello world contract uh we can kind of check it out and see if it's spun up which here it is so we're up and running this is going to be out of the box it's going to have a lot of cool stuff that you don't really have to think about to get started building on ethereum one of the cool things is it has what's called a burner wallets right so you load up your uh your scaffolding app everything's in burner wallets and you can just grab some funds from the faucet so it'll pull funds from hard hat pull them into your burner wallet which is like an in-browser wallet you don't need to mess with meta mask you don't have to worry about nonces or anything any of that stuff you can connect i don't even have made a mask installed on this profile but if you wanted to you could you could connect to like wallet connect app or if you had made a mask it would show up here as well so you can see i've got some funds down the wallet this app home which is basically everything you see here is like where you would build your your app to like prototype so you know you kind of like build the ui into this section but what's uh really useful is this this debugs contract uh directory and this is where it's going to keep track of like kind of all the functions that you have available to write in scaffolding and how you can interact with them and test with them it also gives you the address uh contract address and it tells you how much value is in there as well um i might need to reset let's see oh i haven't run out yarn deploy yet so the last step is once you get hard hat up you get react up then you do a yarn deploy now what yarn deploy is going to do is it's going to grab the the contract that's in the contracts directory and it's going to deploy that on onto the blockchain so that way and it's what else is going to do is it's going to kind of like grab the abi automatically insert the abi into the front end and it's also going to deploy an instance of the contract so that you can mess with it and it also reports like how much gas you use it's really really useful and it also publishes a subgraph as well so let's take a look at kind of some things you could do so like an example would be like let's say we've deployed that contract now now that we've deployed it we have this kind of like hello world where there's a contract there's what's called a purpose which is just a you know a variable that's being set and then we have a function that allows us to update that right so we could say eth nyc or something like that right and then hit send and then we just interacted from our burner wallet directly into um into scaffolding and we were able to see that we updated that variable right so it's real basic concept right so let's let's do something a little bit more interesting so let's uh let's define a address right variable and we might do something like public make it a public variable and we'll call it owner and we'll set up an owner variable we could grab this uh sorry you can copy the address of the contract or you can copy the address of the meta mask or sorry the burner wallet so we're gonna grab that and punch that in here and then save that and then come back and redeploy so you're kind of doing this thing where you're messing with the contract deploying your changes and then once you know that they're successfully deployed everything gets updated and then you can look back at the ui and see okay cool now we have a new variable that's called owner and we have that in it matches this so let's say we want to do something like maybe we want we have this existing function that gets set up here it's called set purpose and you can see here we have like a require that i've already done earlier i was doing gandalf but we'll just say that you're not the owner if you don't have this particular message so one of the first things you learn with with solidity is the require statement right it's this concept of um you you basically are checking a function to see that something is is set in this case we have one called message.center where we're checking to see that who was the message sender for this contract call does it match the variable owner and if not it's going to say not the owner so we can set that do a deploy oh did i do something wrong thank you let's try it again yarn deploy cool so you get but you get the idea we're going through we're kind of doing some changes here making some updates to the uh to the code and so now what i can do is i can kind of mess around here and we'll go let's open up a new incognito window let's go to that local host and so now we have a new instance of the contract up or i should say have the dap up right so at this point we can grab some funds into this burner wallet we can go to the debug contracts again and we can try to update it to something like foo right hit send and we're going to get an error not the owner right pretty straightforward um so you get in this kind of like loop where you're just kind of testing uh the the updates that you make to the contract and then you're just kind of validating that hey these are the changes that i made and they're working but that's not very uh that's not the really the proper way to do something like access control for a function you could also do something like inheritance so you can actually import so another existing set of contracts so in this case we're going to we can import open zeppelin contracts specifically the ownable.sol and then what we can do is we can make this an ownable contract so inherited from ownable and then we can do something like well we get rid of this variable here because we don't need that and we can instead on the end of this function we can say only owner we can deploy that and then make that change so inheritance is that concept of inheriting rate everything that's in another contract and making it available in this contract let's see if that deployed looks like it did but what you'll notice is now we have that owner variable but it doesn't match what's in our burner wallet so this is kind of one of the first things i had a problem with with scaffolding is i didn't understand like well who was deploying it well hard hat is deploying the contract right so what we actually need to do is update the deploy script to transfer the ownership so you'll notice that in the dap here now we have this transfer ownership function which is a function that's built into ownable so what we want to do is then take that variable or i should say that function and call it in the deploy so there's uh when you when you set up scaffolding there's a there's a couple different areas there's this old folder called scripts don't go in there because that's the old deploy js script go into this one here that's uh under deploy and you'll see that what we're doing here is we're deploying the contract here and we're creating an instance of the contract and then there's an example of how you would deploy your contract here so i've actually gone in here and already kind of set it up but what we're going to do is since we already have the the contract deployed in this particular instance here we're going to call that that instance of the contract called transfer ownership but then we need to put the proper address that we want to transfer to so we'll come back to our dap we'll come over here we'll grab the burner wallet address that we have and oh sorry so let's update that save it and let's redeploy cool and we might need to refresh it let's see if it worked looks like it worked okay cool so now we were able to deploy the contract using hard hat and then we were able to transfer the contract using transfer ownership so now we're the we're the owner again but it's still this isn't a very i guess interesting contract it allows us to set the purpose but you know we don't want to really just let just the owner of the contract set the purpose so what we could do instead is we could make this function actually have like um uh require a value right to make transact with this with this contract so to do that we can go back to our our smart contract and instead we can do a require statement require that the message.value so this message.value and messagesender are these global variables that are available right and so what we can do is say message.value is equal to i don't know a variable that we're going to call price and then we're going to say add more money or something like that that and then what we can do is come up here create a price variable so we'll do unt uh public price equals i don't know point zero zero zero sorry zero zero one ether something like that and then we'll save that so now when we deploy that what it's going to do is it's going to it's going to recognize oh i probably did something wrong again what did i do oh thank you payable yeah so it does need to be a payable contract newbie mistake all right let's deploy that again boom okay cool so it's deployed i always forget to make it payable by the way uh and we can also get rid of only owner actually too because we don't want only owner right so let's go back because that would be useless so redeploy again okay so now we have uh the contract deployed we've been able to transfer the ownership but you'll see now the set purpose has this value it needs a value right so i can set it to whatever i want so i'll say new york city or something like that um you'll see that now we have this price variable and you'll notice that it i put ether but it's actually showing us in way what we need to actually send in the transaction so if you didn't have that there's this cool feature of scaffolding where you can just kind of hit this little green button so you can type in what it would be in eth hit the green button and it would translate it to you for in way uh but since we have it right here you could just copy and paste it and put it in there so now we hit send and boom it works so now you'll notice that the contract actually has a little bit of value so we've deployed the contract and it also has some money in there but there's a problem we don't have any way to withdraw the funds so we created this kind of like black hole where we're dumping funds in there so the next thing you would do is you probably would set up a way to either withdraw the funds or some kind of like you know if you're really fancy you do like a multi-signature but we're not going to do that right now so instead we can create another function that allows us to withdraw that so um i've already actually already wrote it here so we can just kind of grab it out of here so what we're doing here is we have we're creating a new function [Music] and it's called withdraw and it's a public function but this time we're making it access controlled so only the owner can call it and we're setting a variable or a boolean called named success and then we're doing a transfer to the message.sender we're doing a call actually with a value of the address of this contract's balance right so basically we're just like a rug pull we're gonna grab all the funds out of there so we can save that deploy so you can see this kind of cool like we're building an app right really easily just by making our changes deploying those and then kind of testing those really really cool so now we can come in here set the purpose to foo [Music] send we've done it and then now we have this cool withdraw function so let's go back to our kind of like incognito one here and let's see if we can withdraw boom so ownable caller is not the owner so we've successfully set up this kind of bank where the contract is storing value we've set up access control so that we can withdraw the funds um we might want to do something else kind of cool like uh maybe just with with a simple line we could actually adjust the price so you can see here we could take that price variable that we're setting multiply it by 101 and divide it by 100 so basically just increasing the price by one percent save that boom deploy again and then now what we'll notice is if it deployed successfully which it did uh if we change the the this thing to like nyc and then hit send we get value added to the contract and what happens to this price variable well it added one percent so every time that someone's going to come in here and set the uh the function 0.001 if we just try to send 10 000 it's going to say add more money because we didn't actually put in the new amount that it's uh costing to do that so we can add that send boom so now let us do it so now the the price function's in there um we have the the contracts getting value we're able to withdraw the contract we're able to do a lot of cool things we're kind of like building on our dap um so what what can we do next so um i guess what i want to show is maybe the idea of like building like a a token right so um the first thing usually you would do is if you're going to keep track of like a of like a token inside of a contract you're going to basically create like a mapping right so you're going to create like a mapping that keeps track of addresses and then a unsigned integer that has a kind of like a balance for that contract so first first we'll create a mapping map those addresses to the uint and then we'll create a total supply and there's a couple ways you can do this but total supply is this concept of like how many tokens are we going to issue in our in our contract what i like to do is actually deploy the the supply inside of the constructor and i pass it through in the deploy arguments so what i always like to do is come in here accept an unsigned integer um in this case we could do 256 and we can do the total total something like that and then what we can do is uh total supply is equal to uh the total that's passed in the in the in the deploy of the contract and then what we can do is we can also decide um who's going to get all the balance for the for the initial balance right so we can call balances and then we can uh call the address oh sorry it's actually this and we're going to grab that address that we have in the burner we're going to put that there and we're going to set that to the total supply so this is kind of like the the owner or the deployer of the contract and then if we want to actually like deploy this it's going to fail right now because it it needs that this it needs this variable passed over in the deploy script so how do you do that well there's this option here called args where you can pass like an argument so in this case we could say like all right let's do i don't know 21 000 or something like that save it and then let's try to deploy it so this this deploy script is going to pass that value over and then it should update the balances for the burner account with the proper balance so let's see if that worked uh we can grab our address actually i think it's already on my clipboard paste it in here boom so this address has 21 000 tokens so what would be the next thing you'd want to do with with that you'd want to have some way to transact the tokens send them around so we're going to actually build in that functionality uh so we can come down here we can do like a transfer function i've actually already written it as well so let's just kind of block it out and i can kind of walk you guys through it so this transfer function all we're going to do is take in an address of where we want to send our new token that we've created and then we're going to take in an amount that we want to transfer that person so in this case it's a public contract and we're just going to return like a boolean to see whether it was successful or not the first thing you have to do is check with a require statement to say hey is this a person even have enough to send right do they have enough balance in their actual account to actually send those tokens over then you it's two simple lines it's one to upload the message.sender to extract their balance and then it's another one just to update of who you're sending that balance to so if we deploy this save it and deploy and now we'll have a new new function in here to be able to transfer those around so let's see if it works deployed successfully and now we got this transfer function so now i i know that this contract here or this burner wallet here has 21 000 maybe i want to send some to my my little other little uh blocky dude here so let's come in here let's do a transfer let's just send them i don't know 777 and then send boom so now we can check our balance again and boom you can see that we've been able to extract so basically we've created an erc20 token so you see how easy it is to tinker around scaffolding it's really really cool really really fun um yeah so after you get kind of going and you're you're uh you're messing around with scaffolding again the next thing i would probably say is you know check out the code mess around with it learn about solidity if you guys don't know solid if you don't know slowly well you're just kind of getting started go to solidity by example and just kind of like start tinking around and grab stuff from solidity by example put it into scaffolding see how it works right and start building around and toying around with that once you're done with that then go to speedrun ethereum and come on here sign up for you know you basically you can connect your wallet here you can start doing these quests um and then eventually you'll be uh invited to join the build guild right and go from there and uh yeah that's pretty much it that's that's kind of my demo i do want to see if you guys have any questions any anything you guys want to uh kind of know about scaffolding no yep yes there is a type square version actually that is a really good point um so if you do go on scaffolding github there's a bunch of different versions that you can get here so if you want to search for like nft uh or if you do typescript right here there's a next.js typescript version um yeah so you can they've actually moved it so it's yeah it's right here so yeah we do have a typescript version yep yep so yeah so um if you do get any any issues with uh scaffolding another thing you can do you can always uh reset the contract as well so that will kind of like set the contract back to a kind of a reset state there's also another cool command that i sometimes i use like if you don't want to constantly be bounced around you can do yarn watch uh where you can actually like have it just kind of constantly updating for and checking for changes um i'm not sure why it's not working right now it might not like some kind of change i made to like the deploy contract or something like that so i'm not sure why it's not working but um yeah so really easy to get going um just to give you an example uh of like if you went to like branch like nft uh you could do like i don't know let's see let's see so there's like an nft auction option right where you can just check out this uh this repository and then it's got this kind of like erc721 build um and it will help you build like an erc 721 marketplace i think i think i think it's erc 721 um and it gives you kind of like a starting point for your uh for your contract and you can kind of mint these little like uh artwork that is in here uh and create nfts yeah trc721 so yeah so there's a lot of cool stuff you can do highly recommend you guys check it out again if you guys want any of the links they're going to be available here i'm going to hang out a little bit later here too so if you guys have any questions about scaffolding or anything just let me know cool thanks guys good evening uh welcome to room one um you're in the right room thank you thank you [Music] you're in the right room if you're expecting to hear a talk about how to deploy on scale and some wicked cool features that will explain that's available on skill chains at this hackathon so let's get to it welcome to new york uh if you're native here it's awesome you're a visitor i love this city i really love the eve global events one of my last favorite hackathons was east amsterdam and a couple years ago eath new york in brooklyn so i'm so excited that we have such great weather and such a great venue so thank you youth global organizers for setting this up um really pumped about this weekend i love hackathons they're dear to my heart so i'm really excited to kick off this weekend for a lot of fun and building some cool stuff by way of introductions my name is chadwick strange i'm head of product at scale i've been with scale since 2018 this is my third venture in the web3 space before this i was working in a completely different industry pharma and biotech and i got a reality check that i was in the wrong industry and found my passion in web 3. and it was at a hackathon in berkeley california where i basically subjected myself to much like yourselves trying to learn new things trying to build cool stuff was up late at night until like 2 a.m i'll never forget one of the sponsors that was there like 2 a.m to 4 a.m helping our team trying to deploy a contract we worked really hard we had no sleep the next day we submitted the project did not work it partially worked but people got it people got the vision people got the effort and our team won second place and that started my foray into this space that i'm super passionate about um my last name is strange and uh i want to give a shout out to rob our social media manager who created this uh meme from doctor strange uh so the marvel studios doctor strange uh multi-chain of madness and i'll go into multi-chain in a bit all right to set this up for the agenda for this session i'm going to first talk about skill network i'm going to give a high level overview kind of going deep in certain areas i'm sure some of you might have heard skill network um maybe you don't know anything about skill network so we'll start with a high level explaining what it is and then i'll go into detail about how to deploy on scale then i'll walk through some really cool features that are not only great for adapt developers but they're great to help out build out incredible dapps i'll walk through that i've got some video demos just to truncate the time so i'll scroll through that and i have a really awesome live demo at the end so praying to the wi-fi gods that i'll still have access and bandwidth to do this live but we'll see live demos are always tough um and then i know you all are here to build and there's not a lot of time to build you're thinking about ideas so i'm going to actually walk through a cheat sheet about how best to position your team for success in building on scale and showing off scale on your project so i'll walk through how to really win um what are the tips that i can give you to work really fast and to integrate in your dap and how can you position yourself best to win skill bounties all right let's get into it so what is the scale network the scale network is the first multi-chain ethereum native scaling network there's a lot to unpack here let's start with ethereum native the entirety of scale network is architected and built on top of the ethereum main net and what does that mean the entire network nodes represented by these lovely dots on the left side of the screen run by validators these are skill network validators when they register with a network they're registering with skill manager on ethereum those are transactions that exist on the ethereum main net when you request a skill chain or do any network operations those are also transactions on ethereum mainnet and that's really important because the scale network uses the pooled security of ethereum validators to help support the network so as validators are joining as validators are providing or getting stake in delegation that's all secured by the ethereum validation layer and then extended through the unique security features of scale network and so we have over a skill network has over 160 nodes currently connected to the production main net and as adapt developer when you request a skill chain and again that's a transaction that exists on ethereum scale manager handles that transaction and says all right how do we provide a scalable blockchain for this app developer it will go into the the skill network will go into the nodes it will select 16 nodes at random and it will send an event to those nodes and tell those nodes hey build a or provision a scale chain and these nodes will spin up a dockerized container these containers are networked together and that basically encompasses the adapt specific blockchain that you use to deploy your dapps and have all your users or community transact with um one of these nodes let's take a look at this i'll do this very briefly but a node again run by a skill network validator is a bare metal that runs skill node software at the core of this software is a python script that is listening and transacting with the ethereum mainnet it's listing for inbound messages about whether a skill chain has been requested the other part again that's the core the inner diamond the outer part of this hexagon kind of it's an abstraction representing the other available compute resources on this node and that's available to basically containerize or provide scale chains of various sizes in various numbers so a single node can support up to 16 individual skill chains it's a very powerful system and then as a shout out to some of our validators uh we're working with a lot of validators that also validate for a lot of other networks especially ethereum so these validators have been really great in helping support build out the skill network and help onboard skilled network partners so you can think of scale network as a network of dap specific blockchains represented by these circles surrounding these nodes so any node can support multiple dap specific chains and these change are very special because they have very fast finality and that's due to the consensus and cryptography technology that skill network has combined they run very fast about up to 2000 transactions per second you can really throw very interesting contracts at this so it runs full state smart contracts it comes with a native file storage layer comes with a native random number generator endpoint that allows you to help develop contracts and have a really solid source of entropy and it comes with a native expandable bridge which is a really incredible bridge that allows tokens and messages to be exchanged or transacted with any skill chain and with any ethereum network chain and they're adapt specific because as adap if you're building a game or if you're building a marketplace you have the full resource capacity of this chain you're not sharing resource capacity with other chains we all know what happens on a single chain like ethereum if there's a huge game or airdrop gas fees go through the roof the chain slows down your dap slows down along with everyone else on scale this does not happen it's a containerized individualized dap specific resource that's dedicated to your dap your contracts and your community and this can be shared at least to you or maybe your project or even open to like a dao community to allow a dial members to be able to transact deploy contracts and build really interesting stuff on these chains with a multi-chain architecture with the mini dab-specific chains that can be deployed on skill network we can kind of think or the network has evolved to create these new abstraction layers and they can be called scale hubs and dap specific chains at the bottom you can think of these dap specific chains as individual projects either running a game running a metaverse a music streaming app whatever it is and each of these apps might need services for example for a game you might need a liquidity layer or some liquidity on-ramp if you're a metaverse you might need the resources of a marketplace well a marketplace can exist on its own separate chain and on your adapt specific chain you can connect to these hubs as service layers so if you're building a play to earn game you don't need to build a marketplace on your chain you can use a marketplace on another chain and be able to connect chains together using the native token bridge which allows very fast exchange of messages or tokens between any of these hubs so again as a play to earn game you can get liquidity from one of these hubs you can send your nfts to an nft marketplace and then sell them on the market so in this way these hubs provide services to multiple chains in the network this is an extremely powerful abstraction that is really interesting because the scale network partners have really galvanized around this and decided to build communities of liquidity hubs and nft marketplaces where it's sharing amongst multiple marketplaces and liquidity on-ramps all right so that was the introduction for scale network skill hubs the technology the nodes the dap specific chains what can you do on scale one of the key features is every single dap specific chain provides gas free transactions with a free gas token called s fuel that's right when you deploy a contract when your users transact they don't need to worry about gas fees they don't need to worry about exchanging eth to get something done with s fuel again this is when you create a skill chain you're provisioned a huge amount of s fuel as a skill chain owner that you can allocate or provide out to your users so long as your users have s feel they can conduct transactions so this is also a unique way where you can control or basically provide a system where you can onboard your users and sort of modify or customize their onboarding behavior so as users come on for example maybe they create an account on your on the dap they can be provisioned s fuel as and then they conduct then they conduct conduct transactions after they conduct a transaction spend their s fuel they can be topped up through contracts or through faucets or through other mechanisms and the reason why there is a gas token is to prevent ddos attacks so no single user could just slam the chain with transactions and this way every single skill chain owner can customize the onboarding process and user behavior through their user journey skill chains come with a massive block gas limit 160 million this allows some really interesting design patterns that you can do with solidity contracts typically on other chains you would have to gas optimize your contract make sure it's not too expensive on scale since there is no value of gas you can really pack a lot into the logic of smart contracts and do some amazing things like combining machine learning models with smart contracts that would be completely cost prohibitive on any chain where gas is an actual economic value file storage every single chain comes with a native file storage layer so you could use other file storage systems but how nice it is if you're deploying an nft game or a marketplace and those visual assets or image assets or video assets exist on the same chain as those nfts and that that those files are redundantly stored across the multiple nodes that support your chain and i'll show a demo of this so again if you upload nft assets those images those jsons can be stored natively on the same chain that those contracts are deployed onto you can even use it to host statically generated websites and serve that over the web uh every single skill chain comes with a random number generator endpoint leveraging a key architectural technology of bls threshold signatures to drive the entropy for random number generation and i'll give a quick example of how this works and this is great because now you can use this to gamify things you can use this to maybe randomly select a thai vote for some dow proposal or you can use this to drive some unique aspects of maybe on-chain svgs and creating some unique uh minting properties of nfts and as well we have an ima bridge i'm not sure if enough time to go into this but let's see how we go so let me get to the first demo this is just a quick pre-recorded video of how to deploy a website on a skill chain oops one second oops let's try that again so i'm going to create a very simple project here um let me skip ahead a bit i'm going to pour it in environment variables which includes my skill chain owner address my private key as long as as well as the skill chain endpoint and i'm going to pull in the file storage.js package which allows me to interact and do upload delete create directories uh with the file storage layer on the skill chain itself and then i'm going to create a folder that will host a really basic html website very simple html boilerplate i'll skip ahead i'll create some css and then i'll do is i'll create a file storage uh script for uploading so this is pulling in the file storage.js library it's going to hit the directory that i put those html and css files it's going to iterate over those files and file storage.js we'll take those files uh cut them up into chunks it will actually push that as transactions directly to the skill chain itself in the skill chain we'll see those transactions realize that they're for file storage construction and then it'll recreate that file on a native file storage partition on each of the 16 nodes so that's what's happening right now at least in the video i'll skip ahead and i'll go to my browser the other key thing is great you have a file that's stored on these nodes we also have there's also an nginx server on each of these nodes so now you can serve those assets over the web so in brave there we go i've just served a static website by uploading files directly onto the skill chain itself so not only can you create assets that drive your nfts and have nfts reference assets on the skill chain you can create a whole website that's decentralized across your skill let chain go back okay next we'll look at the rng endpoint i'll kind of hurry this up i actually won't go into the demo because this is pretty simple um i'll go into how you get the information for the hackathon but this is our documentation portal under develop we have a bunch of tools here and right here using the rng endpoint i'm not going to go into details but you can look this up later but this function here this get random function basically calls a very special pre-compile contract that's deployed specifically on skill chains only and this grabs the glued threshold signatures that are used to sign every block onto the chain and it generates a hash of that and that's returned as a bytes 32 hash that you can then use to generate your render number generator so it's very easy to implement you copy this paste it in you can as soon as you hit the skill chain you'll be able to uh create these random number generators or random numbers and we go back um i am a bridge i won't have time to show the entire video but again for docs right here on the main page ethereum to scale bridge this contains all the information to get started with transferring tokens between chains at this hackathon you'll be able to transfer tokens between rinkaby and scale as well as the two skill chains that are available for the hackathon so you can do scale to scale transfers of erc20 721 1155 and you can expand this to any arbitrary contract the other key thing about this bridge is it's very fast on production networks the finality between one chain to another chain is 18 seconds that's absolute finality there's no challenge period it is it is final when that transaction happens it's very very fast and let's get to the on-chain svg demo i did this quite last minute this week so we'll see how we can get through this let's see i'll show you briefly the contract i created the reason i wanted to play with this is i love what people are doing with on-chain svg i think it's super cool and i think we just hit the tip of the iceberg of what can be done with on-chain svg so i've created a strange token and i've created this simple mint function so it's minting incrementally this is an erc721 i want to kind of show not a 1155 but actually minting multiple of these on a skill chain itself i'm creating an svg for the token uri i'm using the get random function so i'm using the randomness for every block to help modify the svg in place and here we go here's my svg so i have this massive svg with three circles and the components of this circle are being randomized using the random number generator so an effort of time this is already deployed on a chain that's live right now so without further ado i am going to go ahead and mint this live i'm not going to do a thousand i've actually trimmed it back i'm just worried about the wi-fi well here we go so the the tokens already uh deployed onto the chain of the erc721 contract and now it's going to go through and just mint 100 of these and it's going to hit the skill chain and i have a block explorer here and it might not refresh as fast with the wi-fi [Music] you can see a bunch of transactions are hidden into the chain are being minted we have contract call if we go back here the mint is still happening boom just let this finish it's finished minting a hundred on-chain svgs using the random number generator let's take a look at one of these let's see here so as you can see i'm using remix so i can easily use remix or any other web3 tooling for a skill chain and i'll pull up i think token 105 was the most recently created maybe 401 yeah let me check injected web 3 let me refresh stuff i'm trying to read this from this monitor here it's not the easiest let's see and then one second and oh there we go i'll do let's see here there we go i'm not sure why this is not pulling up i don't see that file on the screen anyhow if you come by later i'll show you this live but it will display in browser the on chain svg of three circles every single mint is slightly different uh and that's all done live on a scale chain itself i'm surprised i got that far in the demo with it without it breaking so without further ado let's continue on the journey there are many partners building on scale what things are currently building on scale lots of games brock ballers uh a lot of people love their stuff it's like an on-chain uh rpg uh live on scale we have a lot of other games that are going live or building currently on scale along with some amms uh decentralized exchanges um as well as some interesting apps like a name service where you can buy a name service across multiple blockchains that's using making use of file storage to actually store a mapping database of those names cross chain as well as a decentralized e-commerce and nft marketplaces so all across the board many applications to use and deploy on scale the cheats sheet requirements to earn skilled bounties at this hackathon is simple deploy on a skill chain my recommendation just to help everyone else out is to document scale use in your github dev post and in your presentation we love to just see how you're using scale and explain that in the presentation itself and in order just a suggestion in order of the ease of how easy it is to earn these bounties first thing deploying on scale super easy any project can do this just get an rpc endpoint i'll show you where they are it's the easiest thing to do the next thing of greater difficulty probably only take five minutes integrate an rng endpoint you copy that function put it into your contracts when you're deploying that on scale you'll be able to make use of that rng function in whatever you're building for various features the next tier of difficulty is file storage it's very easy there's a npm library that allows you to do these upload operations maybe you can host your entire presentation on the skill chain itself host all your nft assets who knows go crazy uh and then the next thing is the ima bridge we have a lot of sandboxes code samples uh js libraries uh it's a little bit more nuanced but we've had lots of people have a lot of fun building on the bridge and making some really cool stuff at hackathons so i encourage you to go all the way down this list but if you're prioritizing time this is what i'd say to go through we have twenty thousand dollars and prizes to give out five thousand to a grand prize 8 000 to a metaverse gaming nft 2000 to a partner integration such as live peer at the graph and a pool prize of five thousand dollars shared amongst everyone who at least deploys onto a skill chain themselves uh so thank you you can scan this qr code this will get you all the information that you need for getting a skill chain itself and i'll show you what this page looks like this is the faucet hackathon page so you'll get all our docs here if you click this hackathon link right here this will give you a page that looks like this these are the two two skill chain endpoints that are available at this hackathon if you click this it it'll drop down you have your https websocket endpoints a file storage endpoint so you can hit this put this in the browser see and serve those files over the uh over the internet you have your chain id you can click this to add this network to your metamask there's a block explorer these two chains have ima natively deployed they're connected to rinkeby they're also these two chains are connected together so you can transact tokens between these two chains and then back to that prior page there's a little bit of nuance about these chains at a hackathon on production there's a configuration that not only certain deployers can deploy contracts to the skill chain here anyone can deploy just to make it easier for the hackathon but every single user who deploys needs s fuel so this is a quick faucet how this works out of the one out of the two endpoints just copy paste the endpoint in here paste in your public key address hit the s field and you'll account will be um allocated s fuel as well file storage you need to reserve space to upload certain files otherwise people would dos the file storage layer so we have very similar s fuel a faucet to reserve space and there's some quick faqs and tips just below here if you have any questions find us at the booth we're here all night all hours we're often here very very late hours to help hackers so stop by engage with our team our booth is downstairs thank you very much for listening thank you a very simple way of explaining what wildconnect is it's just a secure remote signing protocol what this means is that your wallets can interact with apps without your private keys leaving your wallet basically we have uh a lot of our wallet a lot of wallets support wallet connect and basically any wallet you can use is uh enabled with wildconnect um we also have a lot of dapps a lot of dabs usually have well connect integrated with us and so then for this hackathon usually just if you want to use any wallet and interact with another app usually while connect is enabled um we have here's a full list and hopefully that by the end of this hackathon your that will also be included in this list um we've had lots of downloads uh throughout the years so we're getting we're reaching more places as we keep growing so how do you integrate it there's a very simple ui that you see probably in a lot of the apps which is this web 3 model and it basically provides it gives you the ability to use any web 3 provider and this web 3 model is is a way for dapps to connect to either meta mask or wallet connect those are the two most popular ones so i'm going to focus just on those two and there's other other providers but i'm not going to mention them for now uh this is how this is the package you're interested this is the wallet connect slash web3 dash provider this gives you uh the easiest way to start using wall connect and also use metamask at the same time so uh this this uh application this library is this ui that you see when you click connect so then how do you configure it the web 3 model is very easy to configure what's the most important aspect about the web 3 model is that you can pick multiple different evm chains so like for example versus the network parameter you can put the ethereum main net that's the default you can put optimism you can put polygon mumbai uh what you have to remember is that you have to pick an evm compatible chain um also something important that you need to do is that you have to have your inferior id the reason for this is because the connection with the wallets the wallets don't provide uh the blockchain information your dab still has to carry uh query that information within vera for example like nonsense or token balances that is obtained through inferior not through wall connect so the once you have it set up you can do web3 uh await this promise web3model.connect and in this mo at this point the user is presented with this uh interface so only until the user presses one of the options either metamask wall connectors or coinbase that promise will resolve and then you can easily integrate it with a web3 object in this case it can be ethers or web3js and the provider would be the wallets that the wall connect has given to the through the connection once the user connects with it um similar very similar to metamask once you press connect it it gives it to the user uh to this object um this provider object follows this eip1193 standard and there's two things you should pay attention during this hackathon with regards with this standard is that it has two functions which is uh two events accounts change and chain changed so what usually happens is that on your wallet the user can like okay i'm on ethereum main net i should probably want to switch to the testnet so i want to switch to rinkeby so you want to pay attention to when the the wallet changes from one network to the other because that could change the contracts that you interact with or the where your app is deployed uh another thing that you have to listen to is the events for account change because the user you can have multiple accounts on your wallets and you want to you might switch them to to test your data and just just keep in mind that this is how you listen to them and depending on your use case uh finally so you're gonna be iterating a lot in your dab probably in this hackathon and is you might want to disconnect uh to try to reconnect with another wallet just like okay you're sharing with your with your uh teammate in the hackathon it's like okay here scan this you know why is it not working for me so you have to remember that when you disconnect we also that this connects the session that the cache on the browser still is still contains information of the address that was previously used now this is useful for uh user experience because then it's like you don't have to reconnect every single time you don't have to scan the qr code every single time but it can be quite troublesome for you during this hackathon where you like forgot to clear your cache so it's recommended at least that after you disconnect you also clear the cache just to make sure that you don't have any leftover addresses that you don't want to use um so here the docs this has there's a lot of other providers that are not just only inferior uh or i mean um uh just other web3 providers that the web3 model supports we recommend that you use four to six providers because sometimes having more options is too overwhelming for the user so the top four most popular is usually a pretty good starting point and we also have the wall connect docks for when you depending on the different types of transactions you want to do uh with your dap and finally here's a an example repository that has ethers js etherjs is just a um a web3 library this is a react app and it already has the web3 model installed so this is a good starting point for your dap if you just want to use wall connect with ether.js um so yeah it's a very very quick demo i i'll just go back because this is probably this the events accounts changed and chain changed is quite important and the disconnect you don't want to make sure that you leave cache there that affects your adapter and your hackathon i'll just leave it the docs and that's it you know any questions go ahead alchemy yes you can use it yeah definitely you can use it uh so other evm chains like i know for example that some cosmos chains have uh forked well connect to support cosmos transactions i'll need to get you the i don't remember exactly the name but i'll have to get back to you in that version two of all connect which is we're hopefully wrapping up soon uh would be multi-chain so sadly it's not ready for it for this hackathon but hopefully future hackathons we will have multi-chain support all right if you have any questions we're going to be here at the booth uh do you know any usually most of the problems uh occur with network changes like when uh when you change your network from either mumbai or to optimism on your wallet that's usually causes a lot of confusion or like just the the event does not get updated properly so you should pay attention to that during the hackathon uh my personal experience rainbow wallet works really well it's really well supported uh with wallo connect um yeah that's what i have for now any more questions all right thank you very much you 