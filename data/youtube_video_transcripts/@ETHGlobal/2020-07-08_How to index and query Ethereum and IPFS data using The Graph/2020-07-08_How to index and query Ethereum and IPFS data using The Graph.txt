[Music] [Music] 1:30 alive along awesome yes we are live so let's get this going welcome everybody to the graph workshop we're gonna get an introduction to how to use the graph what it is how to make sub graphs and a bunch of the tools that you can hopefully leverage during a cough s from Yanis Bowman he's a member of the graphs team so we're very excited to have him with us today for the next hour so going into these resources we also have another team member Martine Martin as you wish he's going to be monitoring the chat and you guys will be able to surface questions to him the way we're structuring it is there will be we'll be able to surface questions during the session we want to wait until the end and we'll try to make it a little bit more interactive for people as always please make sure it's a stake if you haven't already for hack efest the cutoff for that I believe is tomorrow midnight Eastern so Thursday midnight please make sure to do it before then and then after that we'll be removing people who haven't staked from the event because they're no longer eligible but I'm sure everybody here has already done that and they've gotten it out of the way no problems alright so right before we jump into this workshop we're gonna do a quick little something I'm gonna invent a game really quick let's see if we get as many people to turn on their videos if you can no worries if you can't and the game we are gonna play needs a few more people I'll give it 10 more seconds turn on your video thank you Michael and Moll alright game is on the count of 3 or whatever the equivalent is when you when you hear this through zoom you're gonna put up either a 1 or a 2 this is not really competitive but you get assigned to a team as soon as you put up a 1 or 2 and yeah we'll see who wins ok 1 2 3 don't change it Android you count the ones who two's take it by a wide margin sorry we should keep it running tally of all the wins because I think I'm winning most of these games it's alright to say well ok feel free to keep your videos on or turn them off and then like always put your questions in the chat and now I give it to you Yanis tell us about the graph Thanks hi everybody I'm glad to see so many people joining so we'll be walking through how to build a sub graph how to get started with that obviously we're not going to build like a complex one today but we're gonna play with one a little bit see what kind of features you have available to you next data off of etherium and ipfs and also our weave if you want and so the graph first of all if you don't know it yet or don't know us yet let's take a quick look at the website I'll bring that up there we go so the graph is essentially an indexing inquiry protocol for the decentralized web right now focus on aetherium and ifs with other block chains you know being planned for the future and what it allows you to do is to build really really fast application snaps on top of etherion without having to go to you know if you're in nodes a lot for small pieces of data and like having really long load times instead you can define a custom schema for your data up front and you can then use events and other information from the blockchain to trigger you know data extraction transformation and then you can query that data later on with graph drea that's basically the gist of it and so we participating this hackathon your phone and we are giving away I believe double check I don't get this wrong we're sponsoring two prizes of 1,000 die each to the best news of grass on the graph and yeah what I want to share with you to start with is a few of the resources and where to find them and how to get started and then we'll dive into building and actually the actual sub graph so we have on the graph that calm slash hackathons we have like over the over hacker over the hackathons that we're participating in and so for a CAF a so obviously linking to the official page and you'll find more information there I guess that's not new for most of you of any of you and the main entry point for you will probably be the the explora so that is the that is where you create a sub graph on what we call the hosted service and that's a hosted cluster we can have your sub graph in next and where you get endpoints that you can query or use in your in your applications you can also run everything or almost everything not the Explorer but like the stuff behind it so the graph node that does the next thing and also provides the Korean point you can run that on your own machine as well and I imagine for this hackathon I believe for this hackathon and it's a requirements that they are submitted on the through the Explorer and so the Explorer gives you first of all you know when you when you come here you can like browse around see what projects have already you know build a sub graph and now using it up potentially so the decentraland marketplace for instance is is a live def that uses is the central and data for querying and so you can send graph get aquarius to that and you can see what kind of data there is and you can explore that a little bit so you're kind of kind of like filters you have for instance to like narrow down the data that you need in your application as pagination etcetera built into I will get into that later and also crass basically look like this you have like a progress bar when it's processing data because you know there's a lot of blocks on the blockchain so depending on how much data you need that'll take some time and so this gives you an indication of how things are progressing you can see some more data like how many items you've actually or how many entities you've actually put into this door how many like records that you can query and then you also get like an end point that you can use in your app and you can basically just copy and paste that there's a bunch of really good graphical libraries out there in different languages you know Java Script usually people use Apollo as a few others there as well and you can also use just generally any kind of HTTP library and just you know send JSON queries graphical queries to this endpoint and get the data back and so there's a bunch of surprise up here there's more down here so when you create yours ill it'll show up here and you can also search through what's already there and then there's also a dashboard so once you sign in for that you need a github account right now because we're basically piggybacking on the github like account model you know with organizations and users figured most developers already have you could have account in the future I will no longer be the case you know get up is after all centralized but for now this is this very convenient so that there's a dashboard where you can see your own subgraphs and can see both the subclass that you have created as well as the surprised that you've bookmarked for instance and so if I go here for instance I can also see my organization's so when you have an organization you sign up with that you you will hopefully you'll see it if not there's some instructions here on how to get your organization into the Explorer you get an access token can use to deploy surprise under your account from the command line we'll get to that yeah you'll notice the the purple button on the upper right corner and that's how you that's what you add a new sub graph which we'll also do in a moment and then use your own your own surprise and they look basically like any other sub graph right um so just what we saw with decentraland and you can also see the logs and those can be a lot you know if you have a lot of data a lot of events that you're scanning you might get a little bit lost here so that's why we have like a fuzzy search but up there we can pretty easily search let's say for like processing where it's processed events now this one I think has its pretty old so as surprise get older the logs load slower so in this case we might not find anything doesn't surprise me right now but yeah yours will oh pretty fast and the different log levels obviously you can also do your own and your own logging to sub-grants not just the stuff that we generate you know automatically based on what what's happening with the sub graph cool so that's the Explorer when you get started there's some documentation on but basically some introductory information about what the graph actually is and like how or what the gist of it is how it roughly works but then there's also Quick Start guides for both local development where you run your own node locally as well as the hosted service which is you know the main interface being the Explorer but there's also some interaction from the command line with it and that walks you through how you what you need to install a new machine and how you create a sub graph from scratch how you then deploy its I think that's may-maybe yes must be mentioned somewhere and then this also this is a bit outdated by now I think but there is an example application that we rewrote for like refresh for last eat Denver when you can like how the graph key endpoint is wired up and like how queries are sent and and so on but for most of these sub graphs that you can find in the Explorer already there's apps out there way that you could also potentially look at so most of these out of course open source so you can have a look around as well and what we're happy to to provide guidance always on how to do things and then there's pretty detailed instructions on how you define a subgraph you know what kind of elements that that includes I'll get into the details there in a moment there's instructions on how you deploy it to let's say the the Explorer to create an account so basically what I just showed you in the Explorer you know your dashboard and so on that's all kind of explained here a bit of graphical documentation as well I think some of that is a bit hidden under the query API I think that takes you to this one that's where a lot of the filters that are automatically generated for your schema show up I'll also get into more like hands-on details there and and like when you build your subgraph you'll probably spend most of the time in the actual data extraction transformation and like you know reading stuff from the database changing it writing it back to the database and then you're working in a language called assembly script which is more or less a subset of type scripts that compares to webassembly so that's your all your surprised run in like isolated sandboxes in web assembly and for convenience reasons you know most for enough front-end developers like using javascript typescript we picked assembly script as a language for that so it's not like such a big disconnect between the front-end developers and and you know the subgraph authors or developers might even be the same people and so here you find a lot of information about the theorem API when you can do with the theory on the store API we load data and write it back usually you won't interact with that directly there's a API there's my PSA like if there's API to read files from my PFS if they are anchored on chain JSON API because often data on IP of s is JSON crypto API I think that's a bit of an exaggeration I think that's one function right now so yes and then we provide some built-in types you know for bigdecimal support for begin support to support these really large numbers and etherium that javascript and also typescript and assembly script don't provide natively you can you know convert between the different different types is where and primarily look at look at some of these when we or you walk through the actual subgraph but but yeah that's the docs predefined up there in the navigation at the graph that colon slash Docs and what you don't find there please you can join our discord and we'll be happy to answer any questions there we have a support channel that's pre active and yeah we can we can then point your to specifics or like explain things is not things that are not explained on the dot in the docs yes so easiest way to get there is the graph the comb slash discord but I think we also link link to it from the web side if it's not sure if it's in the footer some write down there known on the docks okay but go to the graph column scroll down and as I think is called a link down there this one so yeah you'll be sure you'll find that cool so any questions after this point I don't actually see the chat right now my team and what is we'll get to what a subgraph button you have suggested I should cover what a subgraph is you mean the documentation section or just as a general overview right um let's do then let's see if there's a description up here I think it's easiest to explain the easiest by like hey looking at the the way you can interact with it and use it and be the actual subgraph contents and I'll explain what they are like what the building blocks are so let's get to that now um let's create a new sub graph we'll call it hack FS workshop and we give some some guidance here for good names no tests usually not a great name and the workshop should do that so you can pick the organization or the personal account that you want to create this I know you can create an image you can also edit that later um demo subgraph for thon I can put a detailed description in there that will be shown get up your air if you want people to point people to the source code it also hide it if you don't want it to be seen in the in the Explorer but I'll phonologists created publicly there we go and then here you also find some instructions on what to do next if you don't follow the getting started guide in a Docs you'll see some commands you need to install the grass you lie which you can use to build the subgraph and deploy it there's some instructions on and creating a new sub brand from scratch on the command line because this is basically an empty container right now and then also how to deploy it but we'll do that so first thing usually is that you need your access token and you need to authenticate with the service so what you do there is you do graph or HTTP API the raft of common slash deploy and then you paste your access token in and it'll store it in your secrets like system key storage and automatically fetch it from there well when you run deployments and I think that's covered probably here on the deploy yeah so you don't have to remember that now I've already done that so we really could be see so we've created the subgraph in the Explorer right that's there we can also confirm I think that it exists and is shown in the browser so there it is and that takes us to the same site as a page and the next step then is to actually create the actual contents for that sub R after the the code that besides what other like the the hooks that decide what can you advance you when I listen on and process the the schema that you want to want your data to be represented through and that you can eat then use the query data and then there's two ways to do that so one so there are these clock graph in it that you get by installing a protocol Graci I am and then graph in it has a from example flag and a from contract flag so the from example one I'm not gonna run these now because my network has like weird SSL issues and have to like NPM or no dependencies don't download so I've done that just before to do I have to do it again but the from example one you basically give it a name when you don't doesn't matter you you can then choose it later on it like walks you through like an interactive form where you can begin where you can type in all the bits and pieces that are needed to create the sub graph but this creates a sub graph that's like very simple it's a gravity basic routes of gravity's like I think was like an experiment to bring gravitas to aetherium where you anchor images on chain and you that are sort an activist maybe it's just your else that you put on chain and you add your nail and then basically you have a Gravatar that's associated with your if your address and where when you paste that you could in theory then look up the image um that's a very simple example that has like a couple couple of events that you listen on and that's it the other way to do it is to you use from contracts and the way from contract works is you can go to say ether scan and you'll find a contract that interests you or that they or have already deployed perhaps and where you have uploaded the AP ABI to ether sky know where it is already uploaded to ether scan for instance like this this Marc contract here is I think very fine and this the theory maybe I has been uploaded you can see the column the code here you can see the ABI so what you can do is you can basically copy that and you can say graph in it from contract paste in the contract address you don't need to pass this in sorry and then you walk through a similar form where you can then create a subgraph from an existing contract and i'll fill in some pieces already for you that might or might not be familiar to you from the contracts and you can then fill in the gaps to to your next data so let's look at that where i'm like yeah let's go yeah so that's workshop let's do this is the smaller one so more looks at dow and you know has proposals members votes that kind of stuff i think so if we go to that directory open it in an editor i will see a few files here and if your directories so the first thing is it's kind of like any javascript package and that it has a package JSON with a couple dependencies so we have like a it's called TS should be fully called be called ass or something because it's the assembly script library with our like big decimal types and so on or the api's and we provide on top of the Senate assembly script known as grass July which we then used to run cogeneration Bill's deploy the subgraph and so on and so that's basically like any any other JavaScript project where you can add dependencies but you can like use JavaScript or typescript dependencies in your subgraph code that doesn't work because that code is assembly script or so sometimes yeah sometimes confusing but there may also be some assemblies of libraries out there you can use after that can the main entry point is the surprise manifest and that puts all different building blocks that make up your surprise so graph together and it's it consists of a few like main main pieces so one is the schema that defines the shape of your data you know what types do you have what feels they have relationships they have and that then gets translated into that graphical API that we that we can play with in the Explorer for instance or that you can use in your DAP and then the other thing is the so called data sources and you can think of currently of a data source as a contract and so there's a kind of you pass in you know say if your own contract you can give it a name that's completely up to you you give it the network that is on so like main rinkeby Rossum Kovan girlie X died as a few more that we support so basically all the test nets and I think yeah pike oh I swear so a bunch of options now and that work on the hosted service but if you have a provider and you run a local node that you can you know hit with an ethereal JSON RPC API compatible blockchain then can use that as well and then the contract lives at an address that's the source is the address and avyayam the ABI is basically just a name there's further down there there's a list of av eyes that you can add you can add multiple AV eyes for any contract that you want to interact with and we use those to generate some code for you I'll show you that in a sec and yeah the address is where the contract lives at on the etherium right so that's what we looked up on ether scan you know where as that contract exists copy that over and that means I'm in Xing this particular contract and then the datasource comes with a mapping and the mapping defines and the triggers primarily the triggers that you want to perform some main Xing work in reaction to and the list of a vis and the actual code that does the data extraction transformation so on and so in this case because we did graph in it from contract it basically fills in all the events that exists on that contract already and there's handlers for all these events so whenever a proposal is submitted on Molag on this in this contract this function is called in your mapping and you can then do whatever you want with that for this and yeah you can add a bunch of ABI so in this case we've automatically pulled the Moloch API from either scan it looks like this and that's basically all the methods that that what all the functions and that contract has all the public state variables and all the events baby eyes and so on yeah and so so we have that how do we use it like what do we so what's this mapping file and what are these handlers and how we use them what what do I do with them and also yeah let's actually let's start with the schema like what does the schema look like what shaped my day to have how can it be relational etc so the schema is a graphical schema written in the so called graph to a schema definition language as together and what you can do that you can define types like example entity or we can actually check here what do we have we have proposals we have votes that's great a tie proposal we tagged it with this this called directive entity directive to declare that it's an entity that we can then query later we give it an ID that's mandatory and we can then give it some fields like these were prefilled in just to have something there um what does the proposal have it's a good question we'll find out so it's for now just quiet just give it an ID you add another one for boats let's say also give it an ID and we'll see what we can do with this that's the schema and you can have different fields that can have let's say you can have like a big infield or you can have like us let's say small towns if just in that's just in 32 this one is a betray size you can have the decimals here for really large fractional numbers you can have bytes for any like byte data no like addresses for instance so that could be bytes and the exclamation mark means the field is required so it can't be the defaulting hrothgar is null so it can't be now if you leave that off it can also be left out and you don't have to set it and then we have what else we have we have lists so it can also be like addresses new you have all rights in nominal bytes in a nominal array that kind of stuff and you can also I'm assuming votes have like a proposal that they are for so you can also let's say do proposal and you can say that points your proposal and we'll see how that works so you can have relationships between them and you can also have all the votes for a proposal as a list of votes that is derived from the field proposal in there gonna just say this not sure done this in a while and this will automatically allow you to curry all the votes that have been created against the proposal without actually having to manage them it just have to put a proposal ID into the votes so we'll look at that in a moment that's the schema and the other thing is the mapping so the mapping has all the handlers that you define in your manifest you have to export them as functions and they receive the thing that you trigger on so event handlers trigger on events so we get like an event event parameter that has typed based on the ABI and you can then get data off of that event so for instance you can get the transaction of that event and you can get the seminar from that transaction and you can add an address so you convert that to a hex string and you can you can then use it as an ID for an entity for instance and you can try to load that entity and if it doesn't exist yet you can create it with the same ID and you can set fields on the entity you know like with any odd JavaScript object more or less and ultimately when you're done with with writing your entities you can or like changing your entities or creating them you can save them to the store and at that point the new changes where as soon as the block it's been processed that data can be queried so as soon as you save changes and they are like all the events from in your subgraph from that same block happen process they are all like transacted into the database in one single step and you can then just consume that data and what else can you do you can just comment it out and it's basically listing all the things you can do here the more contracts and has a bunch of functions that you can call to get extra data that's not on the event into into your sub graph so for instance you can access the members here not sure what the parameters are but what you can do is the event comes from a contract that contract has an address and you can then bind that to you can basically bind the contracts like that we created for you from the ABI to their address and then you have an instance of the contract that you can interact with can make transactions against that because that would be mutating things on chain and you know who would be the sign off of those transactions it doesn't work but what you can do is you can find it and you can then in theory not just in theory you can then call functions on it like you know get the current period like voting period I assume for instance stuff that's not only bent because the event doesn't you know has a limited number of fields probably um so yeah we stopped out basically all the event handlers for this contract automatically if you if you created from an API and then you can just fill in the gaps so that's something I'd like to do now um you'll notice that our few arrows here so I can't find certain files that's because some files are code generated from the ABI and the way you generate that code is running the encoder and that will take the manifest all the api's and create code files for apps and so you can see here it's loaded the Contra gave you eyes it's creatives so at this one it's created a mock contract class and it's also created some types for the schema that you can then use in assembly script and so now maybe I have to reopen this there we go so example entity have removed it's now proposal that's the type I just created in the schema yeah let's just wipe all of this for the moment you can create something you so what do we want to do in addition so first of all we have like the proposal class now so we can say whenever there is a new proposal submitted we create a proposal new proposal and what should we use as the ID every entity needs an ID it's probably something on here proposal index could work ID evening to be strings so we convert that to a string which gives us like the decimal string of that that number and then we can save that proposal right easy that's a pretty boring proposal but my work okay let's let's do it let's try it so if you want to test like whether that builds locally you can just run yundal npm run build which will run graph build seems to be okay and the next step after building would be to deploy it and by default when you create your sub graph you already give it the name that it has in the Explorer so I've not done that so I need to go into package.json and change Yanis Molag to be honest what is it a hack a best workshop so it's just a command graph deploy providing some of your ads like the IPS note that all the fire escapes get uploaded to the hosted service as the endpoint and to deploy the subgraph tool and then the name of your sub graph that's like a URL in like a URL representation not like a display title or something and so if I do that now he'll that works so this builds the the mapping or the mappings if you have multiple data sources into webassembly which you can see here and also what else is do yeah that's all the compilation it does but then it also collects all the other files involved like the ABI the schema manifest it puts them all on this ipfs note that you've provided and giving you like a final I give this hash for the truck like the root of everything which is the manifest file and then deploys it deploys the sub graph and the sub graph or the Explorer is get it gets tolls or those service gets told this IP best hash and then it knows okay I'll go try the best and I can retrieve the entire sub graph data from that or not data but the you know all the files involved I need to run this sub graph and so if we refresh this page now we should see you surprised sinking I hope it speeds up a little bit um but I can show you trigger now to make that faster and so it's starting to scan the entire history of the blockchain with filters based on your data sources so we have one contract we have all these events that were scanning for and it'll go through the entire history of the chain filtering all the events they are based on on these parameters and I think right now there's very little like if you go to debug you'll see some more details it's found in this range it found zero relevant blocks so it doesn't know any and it's against the next range and so on um that usually doesn't take particularly long although this looks somewhat slow what we could do is find out when Moloch was actually created so this was the transaction that is the block number of that transaction and so in our manifests we can set a stop block which is that number so we basically skip everything up to that point and just start indexing from when the subgraph the contract was was actually deployed that is helpful let's send that up and I'll also in this case it'll read me immediately replace this version because that hasn't finished indexing yet if you ever already have a version that's indexed it'll like show a little if you refresh it'll show a little pop up here to switch between the current version that's already sent and the one that they just deployed so you can switch between them shows you different endpoints that you can play with okay so we're looking better we're at 70 percent roughly and it's found some triggers it's processed some events with votes my proposal and you can see some you know extra information they're like what block was that on and you can then also search by that so I could let's say submit proposal is the event I'm interested in so I can see you know what happened happened there if it found any events it's a trap it should have entities by now I'm not sure I think this is a little bit cached so the entity number they were showing there may not be updated yet but we saw some proposals being submitted so we should have some proposal IDs some proposal entities Corral so we have some data it's not particularly interesting but we have proposals and you can see the two types that we created on the right hand side the schema now the proposal with the poet's that are not set we can see if we can get some votes here no it's all MP lists so that's all right it's a start right and let's see what what else we can do here and please interrupt me if you have have any questions on my team you interrupt me if you've collected any questions so the proposal right now doesn't have a lot of data on it but there's more data on the event so if the parents there there's an applicant as a member address there's shares requested a token tribute so we can basically put all these on the proposal let's say we've wanted to store like the shares well if it's a key yeah it's - she has requested and on this proposal we can try that okay that few obviously it doesn't exist and I think if I were to for what to run this it'll deploy this it will it'll work but it probably I have failed to build I think so also do yon build - - watch which will ideally keep watching a subgraph show you any errors in the way so yeah she has requested it doesn't exist tough luck we'll add it so Chas requested thought that was I think that's a big end see it says begin there if you hover it get some information so let's call it big end and then we have to rerun cogent because we change the schema so whenever you change the schema or you manifest you have to or the evii eyes you have to rerun Cochin but after that we should be good to go and this seems to have compiled so can deploy that as well and we'll we'll let that actually we can look at it right away blowing okay cool all right I think it's already the new version you can always double check does this IP best hash subgraph deployment ID match ends with NR 6 this ends with NR 6 okay same version cool so proposals share requested she requested an ID cool we have some some more data and we can then for instance filter using a bunch of things right now we have just two fields on this so we can like do somebody no filter by certain ID properties or let's say everything with a shared she has requested are greater than 100 and this is a big begin so it's people represented as a string like in the Java the big number JavaScript library that's used all over the etherium ecosystem okay there's no proposals with that yes but it maybe there's some less than 100 cool as one okay so you can then also say if you want everything that has more than that you can say order them by the shares requested order Direction say deaths endings we find the ones the proposal with the most shares requested and you can also say just ask the first five and now that did not work something does not make sense okay right or equal okay then we go so that one actually any oh yeah I know first okay so we can say like the first five order by she has requesters or a direction descending and let's just find that off then that's yeah cool so 102 101 under 100 so I you can trust me nuts that's that's everything that's no no missing pieces here um okay so how about votes and relationships which is pretty important so remember there's a vote submitted a bet that has proposal in exponents pros like deep was the next cool so that's create every time I vote a submitter let's create a vote we can import that from the generates code for the schema event pounds let's vote ID I assume so let's use that to that maybe not sure what type is it you in votes that's any not even sure what that means not quite sure I trust that any looks weird we shouldn't have that I'll use use it another thing we could do here we could do that so if we assume there's only one vote for transaction we could then go into event transaction I'm using the wrong okay let's let's stick to that in theory can also go through the transaction and any transaction data on in like the transaction hash for instance use that let's use let's use a proposal in now it's excuse the member address it's not ideal it's not great and maybe multiple votes for the same member but let's use something to 2x or twig string because address rather to string let's save the boat is where and though it has a few more fields so proposal for instance and we are using the proposal index as the ad for proposals and to link them together we use the IDS again so in this case which is set the proposal not to like an object of the proposals but to the idea of that proposal so in this case that will be proposal in the next two string is the same thing that we use when we create the proposals as the proposal IDs so we can link them up together like that and so now we explicitly establish this relationship from the vote of the proposal and these relationships or this relationship will be inferred or derived at quarry time so based on the value of the fields proposal in the vote so it'll basically find all the votes that match the current proposals ID let's deploy that as wave and then we'll quickly look into contract interactions and then we'll I think we'll wrap it up on the list of graph creation maybe a little quickly look at the dots on what time see what other things you can do there cool let's refresh this one and let's see so what about the votes and that we have do we have votes we have one vote cool what proposal is that for this one great what voice does that proposal I have okay there's more votes now but and let's assume it was this one it has votes now we can query those even though all we did was put the proposal ID into the vote they are automatically linked together and that works works both ways so you can also have it the other way around we just we have a unit or the other side um so yeah we can now for instance find all the proposals where the vote I am canceled on the boats that's right but we can for instance for all the proposals we can get the ID and we can get the other shares requested and we can get the votes and of those we can again we can then filter them by whatever so we can also just say give me just the first one vote for everything about all the proposals and then we get bunch of proposals but just one bow each so that's how relationships work roughly you can also have them explicitly don't need to have this derive from you can manage them on both sides if you want but often this is quite convenient this is just pean now all right that is that contract interactions so this is something you often you will often need is there's not all the data is on the event that you want let's say the proposal was made in a certain I think what was the contract its first create the contract instance so so the contract is Morlock which we import from generated a code for the baby eyes and we can then bind that to the this I hope this compiles this is a morning a different version local yes but broken in theory there's an address here or in practice there is I hope that it compiles anyway and what you can then do is you can on the contract you can for instance get the currents periods I don't know what exactly the period is but you can then also store that on the entity for instance so if we added a period big end on the proposal type and we bind the contract we can make calls that contract at that block that this event comes from so not at the current block but at the block that the event came from and so that gives you powerful abilities to extract more data out of the contracts which normally you would do in your like what traditionally you would do in your your death you'd go to the contract you get someone like data out piece-by-piece but here you can do it over time you can like pre aggregate data there and if you want and then have it really quick when you when you create from the client okay we've done these are insights built out but that's I think as far as I'll take it here in the docs under defined a sub graph you'll find a bunch more feature so we've covered contract interactions we've covered event handlers and the graph get schema you know how you define entities there's also interfaces so you can have multiple types that have share some fields and you can you find them as interface and you can also create interfaces and you can have relationships on the interfaces too there's the full text search feature as well where you can you know more in like you know a more more powerful like full-text search manner you can like search across the entities you're not limited to these like filters that are pre generators there's data source templates so if you have a factory or a registry contract where that creates other contracts and you want to keep track of those as well but you don't know them obviously at the time you're building your subgraph because you know they don't exist initially you can also create data sources dynamically at runtime from within your mappings for those contracts and you create them basically like the data sources but under a field called templates and you leave our die think the contract address and that's that's it you basically just pass the contract address into the to the instantiation of that data source template and start Broncs we've looked at you can do that in all the data sources to speed things up there's call hand us so some things I'm not available some some contracts don't implement events for everything so the ESC 20 contract for instance or standard I think doesn't mandate for instance mint events and so one way to work around that is that you can you find coin handers that trigger on transaction functions being called from either the user directly or from another contract it's definitely more expensive and slows things down but try it if there's no other way there's block handlers too even slower because Bailey pulls down every block that's relevant either all the blocks so not a good idea probably or just the blocks that involve a call to your contract so that allows us to filter them a little bit yeah so that's not everything right there's plenty of things you can do in the in the API they provide for instant like the logging capability is pretty cool I can use placeholders and kind of printf style logs some stuff that you can then see new flora you can then search to see to debug your contract directly surprise and so on questions I'm basically done with like the washroom and I'm happy to take any questions about features or like things that maybe went too fast or anything at all can surface a question thank you thank you yeah and there was a question about creating sub graphs for getting data from my PFS buckets yeah I can show that although for your inaction because there's no IPs hashes and goods I don't know so the way the IP of s API works is you can import I give s from graph to yes so our API library and what you can do then is you can do cats is usually what people do there's more capable version called map where you can like map over the lines in the file if there's a very big file on JSON in JSON but usually carries enough and if you have an archive s hash and click on chain and you may be you know positivity Bend so you can process it off chain or something you can then pass it into to this IP less careful cat call and you get a result back and I think the result is bytes so it's either could be null if the IP address kept call fails because unfortunately the distribution of files in ipfs is it's not graves and so if you want so it's often the case that you try to get a file and as an IPS node but you can't reach it in the network and so eventually you timeout and and so if you really want to make sure that your IP first files can be found you you can pin them on our ipfs node which is the one you that you're also using for deploying so on it it should be as if you're either graphic on like your vest that's a fool I'd be best know and you can just pin files if you want if you get the data back so if it's not now you know this let's say the error handling here if there is a file there is data you get it as bytes and quite often what what happens is you have a JSON file there so what you really want to do is get the JSON data so then you can import the JSON API from our graph yes library and you can do from bytes and you can then just pass the result in and you get back a JSON object it's not as convenient as like a JavaScript object where you can just you know arbitrarily like dive into the object you have to often check what what the type of the specific jason value is that you're looking at it could be object being array it could be you know a string so you'll be you'll be wise to not just convert to like an object blindly because you can't always trust what this is what this data really is one chain it could be garbage too so there's a try from bytes try is kind of if there's no exception handling here in assembly script yet so for both for JSON parsing as well as for instance the contract calls there's try variants which can fail and the result in that case both of the contract calls as well as the JSON loading passing is a result object and that that then has a arawa or value on it and you can then check what happened and yeah you also get a logs for for the fate of try calls okay that's roughly how happiness works yeah yeah anybody if you have questions feel free to unmute and just ask directly and we'll try to get to them we do have to wrap up in a few minutes so if you can surface them sooner rather than a minute yeah go ahead I guess maybe you you covered everything I'll show one more thing how do I actually use the data outside the Explorer people doesn't always you know spot this URL or don't know how to use it and so sometimes people think that I can just send this string to that endpoint it'll it'll work that's not quite how graphic ale works and so graph killer is Jason so it requires a JSON object that has a query field that has a string value and the string value is this query so let me try not to real quick so I can do I can do this but that's cheating of this so this is HTT p-- i is like a nice quiet tool now which gives you an HTP command and you can basically just create JSON object by saying like passing the key value pairs and so so I can send this a query and it says okay that's not a query it's not really query and but you already get the JSON response back then are you expecting and this is a graph cuts down that is to have all the arrows and like arrows key you can then say say votes and the ID and now we get something back and in curl that looks like looks something like you know you pass a query filled in with a string value and that string value is is boats ID what else no you do curl that URL and so it works with any HTTP library was with more powerful graphic clients like polo and we're happy to share like our experiences on this chord like send you links to clients documentation for those tools oh yeah just fire away with questions even now if you want so how is it if I if I do this indexing a subgraph if I put something into the index with the next call on an event could I already query what I have been indexing in the call before or is that not guaranteed that's possible and so first of all everything from a block gets transacted into the database together so so at the next block you can certainly query it already and like low entities that you've created before you can also do it you can do it in the same time because the the stuff that is not transacted into the database base is of course kept in memory and when you do like a lookup into the store it looks at the memory stuff sees if anything has changed there eventually falls through to the database if it makes sense and thereby like merges the two states like the in flight state in the database state okay randomized and this also handles reor behind the scenes so sometimes we get that question how do I handle Riyadh's with this good thing is you don't have to because the way it works is basically you like I said we transact all the data from a block into the database as like one batch we also keep track of when data was changed and so when we realized that the chain has diverged and we have some blocks some data from blocks and no longer on the chain we just like roll them back one by one like all the changes we made and then move forward again in the right direction and so it to yourself graph it just looks like this events being emitted and you process them and that's it it can happen a bunch bunch of times you know I think girl he has particularly many we also you'll see that in the logs sometimes and there was a reorg and like went back to a certain stage and stuff but there's not much worry about that alright I'll do one last check of YouTube to see if there are any questions there and it looks like there aren't so Marcin unless there's anything by Joshua are there any subscriptions is there even a place for that in this there ah we've we've hidden them because the current implementation is not particularly optimized and unstable so like a bunch of projects particularly mint base this is very vocal about the benefit of switching to polling queries that's made there that bunch you know a lot more robust and if you replace HTTPS with WSS you'll get a subscription endpoint and that basically has like that follows the live query approach so you can send a query or multiple queries to that WebSocket subscription endpoint following the graph key over WebSocket protocol which clients like Apollo implement already for you so with a bunch of helper libraries I think and you basically get a new result whenever there's there's an update and but you don't get like streaming update where like every new piece of data is sent over instead you get a new view of the data that has changed so it's there's two different approaches now channel that we picked that one I like to have both but what one day all right takedown might be it five four three two one all right questions are closed just kidding you guys can hit up mark scene or Yanis in the slack they'll both be there with the rest of the graph team definitely ask some questions figure out more how you can use this as part of your haircut that's hack it's definitely a useful tool so be sure to chat with them and I think we can wrap there thank you again both for coming and walking through some of the code and hoping to answer questions for the hackers it's great yeah good good luck have fun hopefully see a lot of you in this quad all of you ideally yeah and just whenever you have questions just just ping us with their and the support Channel and this code is the best channel for those questions cool all right we'll see everybody remember to stake there's a couple more events including one more in half an hour with wonbin a talking about file coin system will see you in slack and elsewhere bye everybody bye everyone thank you right 