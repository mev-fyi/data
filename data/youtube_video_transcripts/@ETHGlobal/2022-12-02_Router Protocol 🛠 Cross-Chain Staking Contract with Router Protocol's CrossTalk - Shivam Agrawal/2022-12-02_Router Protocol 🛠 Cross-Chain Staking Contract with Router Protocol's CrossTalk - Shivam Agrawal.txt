foreign let me tell you what router protocol is before we start any further discussions so router protocol is an extensible multi-directional grazing protocol that connects current and emerging layer 1 and layer to blockchains to allow contract level data flow across them at router we have multiple products the first one is the Pathfinder API if you can use to swap your tokens directly on the router bits U UI into your own UI the third one is the router cost of Library about which we'll be talking today at router we have around 10 block change already implemented and we are focusing on implementing other blockchains objects in the future so uh let's talk about the cost of library so crosstalk library is the library that can create cross chain contracts with the ability to sequence token transfers as well as arbitrary messaging you can create a contract you can integrate this crosstalk Library into your contract and you can make it cross chain you can swap tokens through your contract itself you can pass arbitrary messages to other chains with your contract itself and you can do both in a sequence also through your contract itself to integrate the cost of library so if we talk about the requirements of Crossing systems you will find uh mainly there are three requirements the first one is the cross chain token transfers if you want to transfer your usdc from polygon to PSC so this is one thing that cross chain systems require the second is crossing instructions so if you want to instruct your contract on the other chain to do something so that is one of the requirements also and if you want to do both of these in a sequence so if you want to swap your tokens and then do something that is the third requirement we have discovered so with the crosstalk library we provide the robust solution for all of these so you can transfer your tokens you can transfer arbitrary messages as well as do both of these in a sequence using the crosstalk library okay so most of the crossing Solutions available today provide either token transfers or generic messaging or both but in silos so while we were creating a where we wanted to swap our tokens corruption and then stake the tokens on the other chain so we discovered a problem that we do not have a good solution for sequencing the transfers as well as the instructions right so we created the crosstalk library for this where you can swap the tokens as well as pass some instructions with a sequence that it should happen first and this should happens so how does it work and how you can integrate it into your uh contracts so there are very simple steps first is you need to inhibit the crop top Library into your smart contract then the second is that you need to you know deploy these contracts from all the chains you want to uh have your contracts on and you while transacting you need to provide the data for erc20 transfers or generic messaging of both uh whatever you want to do then you need to provide some free tokens to your contracts so that it can pay a bridge for the crossing services so you do not pay directly to the bridge but your contract itself is so you need to provide some free tokens to your contract to pay the page okay so what use cases you can enable using crosstalk so there are multiple use cases but we have listed only four or five of those here but you can have infinite number of cases the first one is the indexes that can allow Crossing swaps and sticking together in one transaction per user so you can transact on a chain a that you want to swap these tokens to the other thing and then stake it so you can do that then you can create cross-chain tokens where you can burn the tokens from the solution and many them on the destination chain then there are lending protocols that can allow for promotion payments and settlement of borrowed capitals then you can have cross chain nft minting where the fee for minting can be taken on one chain and then ft can actually be minted on the other thing then there are some uh other things like cross scene production markets and so on okay so let's now move on to the demo for the router Pro Stock so you just need to go to github.com and search for the router protocol and you can find in the router crosstalk sample that will okay then you just need to go to this branch and you can check the code here but we'll show you a demo so we'll Fork this Branch not actually phone will clone this Branch okay so I've actually cloned it already so uh I'll move to my editor you can see this is the sequences taking branch and uh it has all the contracts and stuff here so here what we are creating is we are creating a contract where we can swap the tokens from one chain to another and then stake it on the other chain so here you can see we have two contracts The Vault contract so what volt does is what actually implements the router cross drop contract okay you can see here it integrates our out of crosstalk contract with in every set here and we initialize it here also and it is used to create a cross chain request what state does is we can call the state function here in this staking contract and it will take the tokens from The Vault contract and stake it for the user so what if we want to swap a token and then stake it on the other chain so we'll just uh call this state question function we will be providing the chain ID the gas limit and the gas price the erc20 data and the swap data that we want to pass I'll uh walk you through what each of these things mean so here we just uh pass the selector to the function and we just pass on the params and then uh it sends the tokens also and then States it also on production okay so let me walk you through uh the Vault contract as well as the state contract first okay so to integrate the router crosstalk Library you just need to First inherit it and then you need to initialize it so you need to initialize it with the sequencer Handler the rc20 Handler and the reserve Handler contracts all of these can be found at develop Dev dot router protocol.com so these can be found at Dev dot account.com where you will find documentation to the sequence this crosstalk also as well as all the addresses that you need to pass here okay and then what is this token so this is the token for which we are providing staking so maybe it's usdc maybe it's polygon Matic anything right so now there are some functions that you need to have in your contract to integrate the crosstalk library so you can see these are the three functions which needs to be integrated to have Crossing capabilities the first is the settlinger function second is the set fees to open function third is the proof is so what these things are the set Linker function so Linker it is the address of the admin who can link the contracts on different chains so you need to deploy this contract on multiple chains and then you must have some way to know what is my counterpart on other change right so we need to use these contracts on different fields so Linker is the address of that admin who has the capability these contracts on different teams then there is a set free token so as I told you uh the contract pays the fees for the bridging Services provided by Autumn Bridge so there are multiple free tokens that we accept and those the list of those can be found at the same website the devta router protocol.com and you can pass any one of those fee tokens here as your desired feed open then third one is approved fees what is this for so you also so since your contract pays the fees to the bridge you need to approve the bridge from your contract that it can deduct the tokens from this contract right so this is what a proof is this okay then here we have the approve to approved tokens function just because we want to approve the staking contract once the tokens have reached here we want to approve this taking contract that it can cut the tokens from our wallet from our vault not our wallet but this world contract so once I call the state cross chain my tokens from my wallet will be sent to the Vault contract on the other chain right and then if we have approved the staking contract then the seeking contract will be able to deduct those tokens from The Vault contract so that is why we have the approved tokens function then there is a set speaking contract this is a regular function this is this has nothing to do with router prosper then there is a stake function which uh you can come to the contract and stick actually this is not a Crossing function this is the same change State function actually then there is a same chain on stake also now we have a take cross here so what we pass here is the destination chain ID and uh this is not the actual chain ID of that chain but the router defines scene ID like for polygon we have the chain ID one for BSC we have two for Avalanche we have three so uh the list of these three IDs also can be found at Dev dot router protocol.com so yeah now this is the chain ID of the destination chain so if you are going from polygon to BSC and for BSC we have the chain id2 at router protocol so you will need to pass to here then there is a cross chain gas limit so what is crossing gas limit and what is crossing gas price so you have to pass the gas limit as well as the gas price you are willing to pay for the execution of your function on the destination so if you have created a contract and you think that okay this should take this much amount of gas limit and this much amount of gas tries to execute on the destination then you have to provide that amount of gas limit and gas price and this is how will determine the fees that we need to take from you uh for the crossings but mind here if you pass a lower cost in gas limit of gas price then required on the destination team uh your transaction May stuck on the immigrate stuck on the bridge and you will need to replay it we also have a replay mechanism but I'll talk about it later so yeah you have to pass a good amount of gas emitting gas price so that you will be able to um seamlessly use the bridging services then there is an ERC return there is a swab data uh the these two are uh so actually these two are for the cross chain erc20 transfers right and these two you will be able to get through our EPL which I'll be showing you later okay so you just need to pass the token addresses of the token on chain a to the Token on chain B you need to pass the chain IDs that I want to swap this token from chain added this to generate this and you need to have some data then you will be able to get this two things the years delete and swap data now what we are doing here is we're just creating the selector to the function we want to call on the destination chain so we will have this function on this contract itself on the destination chain and this function will be called when the request is received on the destination sheet so we'll encode the data we want to provide so uh not actually input this is we are decoding the swap data to get the amount we want to swap then we are passing this data into an Avi encode so what we are doing is we require an address as well as a unit here and this address is the address of recipient so staking will be done in the address of this message center right and then this is the amount of tokens that needs to be state right so we are encoding the data that needs to be passed to this function receive Crossing on the destination then we have a generic data what is general data so we just encode the selector and this data that we have created to pass through the other chain and this creates the generic data now we have a parent's struct where we accept the chain ID ERC data swap data generate data Crossing gas limit gas price fee token address and these two parameters so first one is the sequencing function so if if this is true this means that you want to swap the RC 20 first and then you will call the generic function what is the generic function this receive cross chain function the second is if you pass Falls then this function will be called first and then erc20 transfer will be executed so you want to transfer your tokens first before you start staking that is why we have it true so that erc20 transfer takes place first and then we will call this function on the other chain then this is uh okay so this is only generated actually so what this means is if if this function you are calling does not have to transfer any ERC data right so if you want this function to just uh call some function on the other chain and do not transfer any data any erc20 tokens right even use true fault if you want to do only generic message passing you will pass through and for swap data in RC data you can pass any dummy data so that will not affect okay then you just call this about the same function with this params and it's done right so you have created a cross chain request for staking that will transfer your tokens cross chain first and then it will stay good for you now as I told you we have a received State combustion for which uh the selector we have here so this is the function that will be called on the destination chain and what it will do is it will just call this taking contracts take function with the user as well as the amount we passed here the user is message center and the amount is this so this this function is called on the source chain uh and this is called on the destination chain and you can see it has a itself modifier what has a self modifier two for security purposes we want that no address can call this function directly only a bridge can call this function right and not also arguments but this contract itself will be only able to call it and how we will achieve that how will this contract itself call it so when a cross scene request is received on the destination chain this function is called that is a router sync Handler with the selector and the data you passed in the generic function so here's the generic data you pass some selector and you pass some data what this data is it has the user address as well as the amount of tokens need to be saved so this selector and data is received on the destinations in into this router sync Handler function and what this does is it it's it checks if this is the selector to this function and we decode the data accordingly so we know if it is a stake cross chain function then we must be receiving the user and an amount so we decode it accordingly and we just call that function from here right so only this contract itself calls this function no other address or any contract can call this function so this is how a cross scene request that is received is handled on the destination sheet now we have a replay transaction function so maybe if you pass you know a lesser amount of gas limit or gas price then required on the destination chain for a transaction to be executed then your transaction may get stuck on the bridge and you will need to replay your transaction and for this you have to call this replay transaction function and what happens here is you pass the nons for that transaction you pass the crossing gas limit you pass the cross chain gas price and this is the updated gas limit and gas price you are willing to pay for uh replaying your transaction then it will call the router replay function which will clear a transition on the bridge now we have a recovery token function but this is actually this has nothing to do with cost of integration this is just because this is a testing contract and if I pass some free tokens and uh something goes wrong I want to recover my free tokens so that I can use it with my updated so that is why I have this function but it has nothing to do with the crossing contract okay now uh so we learned that we need to initialize the sequence of the address of the sequencer the erc20 handle and the reserve handle we need to create these three functions uh that are necessary for cross chain swaps and uh generate message passing that are the Linker address set free token and approved fees then we need to have three main functions which are across in sending function which will use to create a cross scene request then we will have a router sync Handler function which will handle the crossing request received then we'll have the replay transaction function which will be used to replace the transaction so only using these simple steps you can integrate uh the router crosstrop into your contract now we have the staking contract and actually this does not do anything uh it just have the Vault address in the total address that need to be state it just maintains a balance of the state balance is a mapping of the state balances according to the address and it just transfers the tokens to itself and updates the mapping so that's the only thing it does okay so let's now talk about uh the deployment and the config of these things right so we have created a very simple system of deployment so we have a one click deployment process here in this contract module so we have a deployments folder where we have the sequencer deployments.json what happens here is you just need to pass the uh things you want to provide to your contract so we need to have the sequencer erc20 Reserve Handler addresses in the contract to initialize the Vault you can see here we also need to have the two connectors right so we have the sequencer erc20 and Reserve Handler as well as the token interest layer so this token address is actually the usdc on polygon all right this is the USD and free token is also usdc and polygon and the token we want to state is also usdc and polymer okay now uh the Linker is my address actually so this is the address of admin that has the capability to map the contracts on different sheets similarly for evaps also we have the addresses and these addresses the sequencer erc20 and Reserve Handler addresses you can find on the official documentation the dev.to protocol.com okay then this is the usdc on our launch so we are using the feed token as usdc and the token 2 is taked also as usdc on the other thing so then we have the Linker address so this is the link this is the same address you can see this is my address actually okay so once you have done this you will just need to go to the tasks and we have all the tasks here so one is the deploy Vault what this does is it takes the data from uh your deployments file the one we just created and it just initializes the Vault contract here and it stores the address of the Vault into that file directly then it sets the link upon this contract it sets the feed open on this contract and it approves the free token on this contract so please pretty much does all the conflict for us then we have a deploy State function which will just deploy the sticky contract then we have uh set free tokens at Linker so all these are called inside some master master tasks like deploy World calls this uh set Linker set feed open and approved and so on then we have a deploy all tasks which will actually do all the things for us it will deploy the Vault it will deploy the state contract it will set State contract on the vault and it will approve the tokens so what is approving the tokens so once we receive the tokens on the Vault contract we want the staking contract to be able to deduct those tokens from The Vault contract so this just approves The Vault contract from the staking contract to deduct the tokens and stake it okay uh so once all these things are done these four things we need to map those contracts and for that we have a map contract practice okay so here is the map contracts task what you need to pass here we need to pass the chain ID and then chain ID what is the chain ID so chain ID is the destination chain ID defined by wrong text so example uh you have the product of contracts on polygon we have seen our lines so from polygon you need to map your contracts to BSC and Avalanche so for bsp we use the chain ID too so for BSC and we use the chain ID for our launcher router protocol and all these things again you can find on the official documentation so chain id2 and chain ID3 so for this chain ID is the destination chain ID defined by router so when you are mapping from polygon to BSC then you will need to pass the chain ideas to and then the nc9 is the actual chain ID of the destination chain so for BSC that will be ncnid is equal to 56. for directs engine ID is four three one one four okay so when you are mapping from polygon to BC you need to pass through for chain ID and 15th for ncnid and for polygon to a vax you need to pass 3 for chain ID and 43114 for engine ID once you have done those things uh then I think you are ready to go and test your contract on the Explorer or real UI so let's deploy these contracts and test it out once okay now so let's deploy these contracts one polygon and Avalanche so let's start with polygon first is uh polygon so we'll write the task and PX harder deploy Dash as unit for polygon all right we have a deploy task that will deploy the stake that will deploy the Vault contract as well as set all the config on board and State plus approve the state contract to deduct tokens from the world contract also all the dresses it will take from the sequencer deployments.json in the deployments folder so you can see it has already deployed The Vault and said the link of address the feed open address as well as approve the fees also this address is stored in the sequencer deployments file that I'll show you later okay so all the config and everything is done on polygon side let's do it on our launch okay so the deployment has started foreign foreign now we would also like to verify these contracts so that we can access them on the Explorers so you can see all the deployments have been completed and the addresses have been stored in the deployments file now for verifying it also we have created some tasks so if we call this verify all task it will verify the vault as well as the state so let's do that so we'll first verify on the qualiform network so the verification has started on polygon okay so the polygon and the polygon verification is done let's do the same for our lunch now thank you okay so the contracts are verified on both Avalanche and polygon let's open it up first we'll open uh the contraction polymer so we have opened the world now we'll open the stick also similarly will open the wallet and step on our line choice power analysis notice this is the voltage percentage okay we have the Vault we have the stick now we would like to transact from a relaxed to polygon so I will send some free tokens first to the Avalanche Network so that it can pay our Bridge so we have kept uh polygon as the free token let me send some free tokens to my contract the wall contract let's say we'll send one usdc okay so I've sent some free tokens to my world contract so that it can pay the bridge now we want to transfer some usdc from Avalanche to polygon chain and then state it on the polygon side okay so we also need to approve this Vault contract from our main main wallet so that it can deduct those usdc that we want to transfer to the other chain so we'll open the usdc it will open up its contract and will approve our vault contract for it so okay I will copy The Vault contract address and we'll approve it this is the approve function below uh have the Splinter then we'll only give approval for some point one usdc 4.1 we have to write five zero because USD C is six decimals actually okay so now that we have given the approval also we can go and try uh any cross chain functions here so you can see we have one usdc here in the contract itself to pay the fees we have also approved it from here from our main wallet so let's try to call will connect the wallet and we'll go to the State gaussian function okay now we need the chain ID so for chain ID the for polygon change the chain ID is one where you can find it you can go to router protocol.com here we have a list of uh chain IDs so let me have a look [Music] husband will pass one as the chain ID here crossed in gas limit and gas price so I know that my function is not that which I'll pass a medium kind of gas limit maybe I'll pass for the safer side and plus a hundred thousand you can pass through the world if you want I think this is not a complex function so it should work with lower amounts also but I would just want to be on the safe side okay now to get this ERC and swap data that is for erc20 transfers will use an API and I have written a script to get this data so you can go to the scripts folder and get sequence and data so here you have this basic URL and then you need to pass some parameters so in from token address we are passing the usdc or Nava launch because we want to transfer usdc on our Avalanche chain to us decision polygon chain and we want to transfer an amount of 0.01 usdc four zeros means 0.01 with six decimals now Source chain ID is Avalanche destination ID is polygon 137 free token address is usdc or Naval launch as we discussed earlier the recipient address so here what the recipient address should be so we want to send our tokens from polygon from Avalanche to polygon but we want to send it to the Vault contract on polygon so that the state contract can take it from the world contract right so here will pass the state uh World contracts address on polygon so this is the Vault contract address on polygon so we'll pass this address as the recipient address because the stake will deduct these tokens from The Vault contract so we need to specify vault as the recipient address now is this the native what is this so if the destination token is a native token of destination change if we wanted to convert this USBC to Matic token on polygon then this should have been true otherwise this should be false okay now we construct the query URL here and we query it here using axios so let's when this script runs this is a sample script you can use it in your project to uh do it dynamically so it's in the scripts folder and your name is get sequence so when it runs it will give me the ERC data and swap data I just need to pass those parameters to the function and we can do the transaction then so we have the rc20 data here so I will go and paste it on the Vault contract okay we have the swapped it also so this is the data that will pass to the bridge for the rc20 transfers okay so we are getting some issues here so let me check uh so I figured out what the issue was the issue was that uh so do you remember earlier I told you about the Linker address that the Linker address has the capacity capability to map the contracts on different chains right but we did not map it so let's go and map it so from polygon we want to map our contracts to the Avalanche and from Avalanche we want to map our contracts from the polygons so let's run the task map contracts what we need to pass one is the chain ID which is uh for Avalanche to polygon will use the chain idea of polygon so router spec chain ID is one and the N chain ID is 137 for polygon and this is on the network so from our launch we are mapping polygon okay mapping is done now from polygon we'll map our launch so of polygon here and we'll have 1093 because our launches c93 here you can see uh so this is a launches in ID3 and this ID is about four three one one four okay now we'll do the crossing swap and you can see it's okay now we have done our transaction here now it takes some time uh to uh go to the destination change but here we can check we do not have any state balance right now so we can go and check the state balance in the contract and we can pass our address here so you can see when we query we find cu okay now let's wait for some time and we can check what happens so it has not come yet but let's wait so now you can see here then the balance has been updated to ten thousand what this means is that the usdc you paid on the world contract in avax has now reached the polygon Network and is stayed here so I think that completes our tutorial uh thank you guys for being with me and I wish you all the best thank you 