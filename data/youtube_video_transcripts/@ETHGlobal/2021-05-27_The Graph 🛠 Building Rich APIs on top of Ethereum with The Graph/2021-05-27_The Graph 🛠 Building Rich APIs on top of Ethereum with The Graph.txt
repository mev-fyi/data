all right let's get started thank you everyone for joining today um we are hosting this workshop with another debate from the graph the workshop will be building a rich apis on top of ethereum with the graph um if you want to connect with the team afterward i invite you to join our discord in the specific sponsor channel and in the meantime if you have any questions please post them in the zoom chat and another will get to them as as he goes on i will let you take it away another thank you for the intro um really excited to be here you know kind of honored to be speaking in an event like this so thanks for having me and um we have 28 minutes maybe 30 minutes so i'm going to try to you know fly through what i'm going to be doing it's going to be a combination of a presentation as well as a kind of live coding demo and we're going to deploy an api on the graph it's going to be querying nft data from azure smart contract so we'll go ahead and jump right in so i'm going to share my screen and we'll go ahead and get get this started so i have a few slots not a whole lot i just want to introduce myself my name is nader davit i'm a senior developer uh relations engineer or developer relations engineer at edge node and i've been here for a few months and i'm kind of fairly new to this whole like web 3 ecosystem but i've fallen in love with it and i'm like really really excited about all the stuff going on and um i just uh really love learning about a lot of this stuff and building building things um really excited about some of the ideas for the future of the web and things like that so um one of the projects that i became really interested in was the graph and one thing led to another and i landed an opportunity to start working with edge and node which was a company that started the graph um you know a few years ago and they've since launched edge and node and one of the things that we do is we help support the graph protocol and that's kind of what i'm here to talk about today so the graph is a global api for d5 and web3 but in reality it's kind of like a global api for any public data any data that is deployed to any decentralized network or any distantialized system now some of the main use cases that people are working with today on the graph are d5 and they are a lot of the traditional type of gaps that you see but in the future we definitely are excited to see a lot of more interesting things that people are already starting to build games you know e-commerce all types of stuff and the graph is kind of the best way i can kind of describe the graph is it is a way to deploy decentralized apis that make querying data from blockchains or any other decentralized networks very very easy and you know it's kind of an abstraction that allows you to kind of get up and running with something that in the past would have taken you a lot longer to build and it's also something that would be really tough to build in a decentralized manner whereas the graph allows you to build and deploy these apis in a decentralized way by taking advantage of the decentralized graph network and the network is something that we are currently you know rolling out as of the end of last year and we have a lot of exciting updates actually coming in the next couple of weeks so right now there are two kind of main ways to deploy uh graphql apis using the graph one is using a hosted uh service which is kind of what was deployed when the idea was fleshed out which to kind of like get a lot of different companies and developers on board and so you can still deploy that way but what we are all now moving to is the decentralized network both of those things are available to to work with now we're rolling out some really exciting stuff though in the future for the user interface and things for the decentralized network but what i'm going to be deploying today is to the hosted service because it's kind of the most mature ui that we have as of this this workshop so in the past uh if you were building out a an api or building a dap on top of something like ethereum the problem that you might have run into is that you can make single requests to the blockchain but let's say that you need some historical data or you need some aggregated data or you needed a performance query that is going to gather a bunch of data and maybe aggregate it or do some map reduce or some other type of data access pattern now in the past you can't just make those queries directly to the blockchain so what a lot of companies were doing they were building out their own indexing servers so they would uh take you know a smart contract they would build a server and they would deploy it to something like aws and then they would have to build out their own logic that would then go index all the data stored and serve it up and api now the problem with that is that it's first of all breaks the whole idea of what decentralization is but also it's very resource intensive now you can kind of understand how you know you might want to have taken that route if there was no other options but what the graph is here to provide is that that new indexing layer that allows you to deploy these different apis in a decentralized manner and you know deploy a web app a mobile app it doesn't really matter even to query these apis from the backend but you deploy your api and you're now having access to all of this very rich data and giving a bunch of really really great different data access patterns and we've seen a lot of success a lot of growth you know and as of the time i made these slides which is probably a little bit outdated numbers at the time but we have over 10 000 lifetime sub graphs deployed by over 18 000 developers and um we're seeing over 20 billion queries per month and um i don't know what the exact number is now but that was kind of a few months ago and a lot of companies are using the graph now you've definitely probably interacted with some of these different um you know apps in the past yourself so things like unit swap foundation synthetics all of these are using the graph and production and there are also different subgraphs that you can interact with that that other people deployed on top of other uh smart contracts so the compound is one of those um you can go into the graph explorer which i'm going to show you in a moment and kind of see all these different open apis and uh play around with them build out different front ends on top of them whatever you'd like it's pretty nice and um once you've deployed your api you can interact with it in the user interface that we provide or you can just hit the api endpoint from your app but it's really nice that you can kind of jump in here and play around with different queries see what data is there and if you've ever worked with graphql you kind of know a lot of the benefits that graphql provides but if you haven't graphql is just a really in my opinion improved abstraction over on top of rest and it doesn't really give you the rest api as a developer you're now working with this new api but it's very very good for building modern applications because it allows you to have a lot more efficient queries and a lot more performance and a lot better developer experience especially for client side developers which in this case is going to be everyone because we're not building out the server side stuff all that stuff is handled for you by the graph notes now the graph network is the decentralized network and this was launched in december of 2020 and we're continuing to improve and iterate on that and like i mentioned earlier we have a lot of really cool stuff coming in the next couple of weeks so keep an eye on that but what we're going to be working with today is the hosted service but you can really deploy either way as of today and the way that the network is powered is with grt which are graph tokens and you can use these tokens in different ways depending on how you are interacting with the protocol as a you know curator or an indexer or even a subgraph developer so let's say you have an idea for a subgraph an api that you think other people would be interested in using you can build out the subgraph you can deploy it and then you can actually earn grt if other people use it so a lot of interesting ways to kind of be a participant in the graph network and as you're going to see we can build out one of these graphs in just a few minutes so that's what we're going to do so we have 20 minutes i would like to initialize a new subgraph and deploy it and query it from the network and see if we can do this now the graph that we're going to be deploying is to query it's going to be indexing and exposing an api on top of nft data that is using the zora smart contract now these are the steps for creating and deploying a subgraph you initialize the subgraph you define the data sources which would be the smart contract addresses that you want to index you define the entities that you want to index from those smart contracts so for example let's say that you have an e-commerce a product could be an entity so you kind of define that entity and then you form that entity and save it into the indexer and you're going to kind of understand a little bit more about how that works you also define your data model which very is very closely tied to the entity so the entity is actually defined in graphql you configure your assembly script mappings which actually define the business logic from the data that is coming back from the smart contract for what you want to save and then once you're ready to make the initial deployment or an update you just deploy and uh within a few uh seconds maybe a few moments you're able to start querying and playing around with the uh with the api so with that being said um we're going to be working off of a workshop that i've actually made open source so i'm going to be using this as my like boilerplate to kind of walk through but you can also take this and build something yourself and i kind of encourage you to do that if you're interested in you know learning more about this so the the url for this workshop is that isn't my github so github.com david3 slash building a subgraph workshop if you go to my github you'll see that at the very top the repository the third repository would be that one i believe that we might be sharing that as well in the discord in just a moment anyway but what we're going to be doing is we're going to be kind of like walking through this and in a very fast manner because we only have a few minutes i'll probably copy and paste code and stuff like that but if you're interested in this and you kind of want to try this out yourself this is all here for you and in addition to this readme which is kind of like the directions for doing this there's also an existing code base that you can work with so this zora nft subgraph code base is the contract and all of the subgraph code that we're about to write you can kind of copy and paste that and deploy it yourself if you would like to as well all right so let's go ahead and get started so before we kind of like write any code locally what we're going to now first go ahead and do is kind of um define the graph that we want to or the subgraph that we want to deploy in the graph uh ui so i'm here at the graph.com i'm going to go to my dashboard and i'm going to click on add subgraph and i'm going to call this eath global nfts all right and i'll call this like mft sub graph and um that's all we have to do uh we're go ahead and excuse me we're ready to go ahead and create this so i'm going to click create sub graph and we're given now a uh an endpoint essentially that we can deploy to we're given an access token and all we're going to need to now do is initialize the subgraph locally and then we're going to deploy to debit 3 each global nfts so with that being said we're done with the graph dashboard getting started we're going to go to the codebase or the the readme and this kind of walks through everything you need to know i'm going to be running through it fairly quickly so you need to install the graph cli which i already have installed and then you can use graph in it to initialize a new subgraph and this is going to kind of generate a bunch of boilerplate for you now the the command that we're going to run is graph init and we're going to say from contract and we're going to pass in the contracts and then we have a really really helpful command called index events and index events is actually going to look for any event submitted from the smart contract and it's going to go ahead and create some boilerplate for us using the um apis so this is going to actually generate a lot of nice code for us that we can then modify so we don't have to write a ton of code after this so i'm going to go ahead and just copy that go to my command line and here we are in an empty directory i'm just going to paste this here so we're saying graph init from contract we're passing in the network mainnet of course you can also pass in a test network like roxton or whatever you'd like to work with and then we're passing in the contract name and then index events and this is going to go ahead and scaffold everything we need now for the subgraph name we already created that so i can go back to here copy debit three slash global global nfts and we're ready to roll i can now just accept all the rest of the defaults because i've already kind of passed in all this stuff and we're ready to go so that's going to go ahead and that's going to go ahead and create the code locally and we can go ahead and continue on i'm going to skip over some of this again because of the tom constraints and we're going to now go to our schema.graphql now in this schema we're going to be defining the entities that we want to save so with an erc 721 you have um an um entity that's essentially going to hold things like the id the token id the content uri metadata uri and so on and so forth and we also want to um so we're basically going to have a way to index and query all the different nfts as a token and we're also going to have a way to index and query all the users and then have relationships between the two so we don't only want to query the tokens we don't only want to create the users we might want to say i want to get all the tokens and all the user metadata or vice versa and the way that we do that is we use these different directives so here we have a derived from directive where we're passing in the fields that we want to associate so in this case we have owner and owner and then we have creator and creator we also are using this at entity directive and this is uh something again specific to the graph that is going to allow us to index this data and build out some code generation for us locally so if we go back to our terminal we should see that everything has been created for us so we see a new directory called each global nfts all right and what we're going to do is we're going to go ahead and open this up in our text editor and we're going to start writing some code so i copied it i copied that uh that graphql schema and we're going to use that in just a moment um and in in the scaffolding in the boilerplate that the cli created for us we have a few different main areas that you probably need to keep into consideration one is the schema.graphql so i'm gonna go ahead and open that this is where we define all of our instances we also have the main configuration for the entire subgraph at subgraph.yaml and this subgraph.yaml is really where we're kind of describing everything about this subgraph and i will walk through some of these properties in just a moment and then the last thing that we're going to look at in just a moment is the mappings and i'll talk about what those mean in just a second now before we start writing any subgraph configuration let's go ahead and define the entities that we want so in this case we want to index and query tokens and users and i kind of walked through how some of this stuff worked as far as these directives and stuff and these fields that we're working with and i'm going to go ahead and save that and open up subgraph.yaml now the subgraph.yaml has a bunch of configuration for the things that we're going to be working with but the main thing to keep in mind is this data sources field and you can have multiple data sources but in our case we're just going to have a single data source and what the graph does once you deploy this subgraph it's going to kind of go into this data sources field it's going to look for all the addresses and it's going to then start indexing and looking at all the different transactions for this address and for every time that we find this this uh address or transaction on this address we're gonna then invoke these event handlers um and we're gonna look for the events that have been emitted essentially so this address is the zora smart contract address so if i go to like etherscan you know we'll see that we have this address and this is kind of the data that we're going to be indexing now um what we can what we can do is uh we can now also define the start block because let's say we don't want to kind of like go through every single block from the very beginning of ethereum we might want to start at when this contract was deployed which makes a lot of sense we can do that and let's see here i can go to last and i can say okay the start block is going to be this right here so i'm gonna go ahead and copy that and i'll even uh go back to my code base here where we kind of see where we have the start block here so i can do that just to kind of show you that it is documented here so we have the start block and uh so we're working with this contract um the start block and we can continue on now the entities that we want to save are going to be defined here and here we have a token and a user so let's just go ahead and update that to say token and user all right so the last thing that we want to do is we want to define the event handlers that we want to basically interact with and save data from so by default when we passed in index events it went ahead and looked at the abis and it saw like any events like approval or approve for all and it went ahead and created these event handler boilerplates for us the only two events that we're kind of interested in are token ura updated and transfer transfer is going to be kind of what's called when a token is minted or transferred and then the token uri update is going to uh someone changes the metadata from an nfc this will also be uh be updated and those are the two events that we really need to kind of get most of the data that we're interested in so we've uh we've we've saved those we've made those updates and you see here i have all this here as well um the next thing that we might want to do is we've already kind of created our our schema we have our configuration here what we now need to do is interact and create our business logic you could say or the code the the code that we need to write to actually take the data that's passed into these events here so here we see like when a new transfer is made we have the address that it's uh from probably the address that it's two and um the an integer value that we're gonna be working with and um so in these mappings we're gonna be kind of handling those events but before we do that we need it would be very nice actually if we had some boilerplate code that we could basically use for type safety and we can do that actually really easily by running a graph whoops and graph code gen is actually going to go ahead and look into our schema and it's going to go ahead and create some really nice helper code for us that we can work with and if i go now to source slash i'm sorry i generated slash token schema and token i'll see that we have some nice code that we can work with and here if we look at our schema you'll notice that this resembles our schema here we have a token and a user here we have a token and a user all right so um with that being said let's go ahead and write our assembly script mappings an assembly script is is to me like just very close to typescript so if you've ever written javascript then this is really easy to pick up so i'm gonna go ahead and copy and paste this here again we only have about like eight minutes so i'm not gonna walk through everything but um let's go ahead and walk through like one of these functions when this handle uh transfer function gets invoked we've defined it here whenever this uh transfer event happens we're gonna be passed in an index address address and uh integer we can we can kind of go here and see that we are taking this event and then we're basically going to check and see like we basically have that event information here and then all of the different values of that are available on the event.params so we have the token id we have the content uri and all these other different pieces of data that we can that we can work with with that being said the logic here the first thing we do is we first go ahead and try to load that token and if it exists we skip this and we kind of go ahead here and we kind of add additional fields if it doesn't exist we go ahead and create the different fields on that on that token and then we save it and i think this is kind of the main the main functionality that you want to make sure that you have if you want to save something you just call dot save on the entity that you're working with and this is what indexes and saves it into your api and with that being said we're kind of uh done we can now go back to our uh you know code and we can run a build and if i run graph build this should go ahead and create a build for us that we can then deploy and if everything is successful you'll see that you have built completed and we're ready to deploy and before we deploy what we basically need to do is we need to give some authorization from our local machine and stuff so i can say graph off and then i need to pass in the access token and here we have that access token right here this was given to us when we like created our sub graph all right so we've we've authenticated and now we can go ahead and run yarn deploy and this should go ahead and deploy our subgraph and we should now be able to kind of test it out and just to kind of get an idea around the things that we're going to be querying from this is what we're going to be querying this uh these nfcs so i like nfts for these types of demos because it's a nice visual data that we can kind of like see and look at and stuff it's a lot better than maybe just some some financial data or something all right so if everything is deployed successfully you should see some green check mark and some feedback here and if i go back here and refresh we should see that [Music] everything is ready and we see that 12 million blocks have been synced and uh we're ready to start running some queries and we see that we have 5494 entities that have been indexed that means we have 5494 nfts that we can query so let's go ahead and run a query we're here in the graphical editor that we're given given to us by the graph explorer and here we see that we have some content uris um and this is going to be kind of like the nft data we can also pass in arguments so we could say that we want to order a direction like descending we can say order by like id or something like that or say token id and we're given um you know this in a different direction so like instead of getting the newest stuff at first i'm sorry you said being the oldest stuff first we're now getting kind of like the newer stuff so let's go ahead and copy this content uri and see what's there we have an nft um check out one more hopefully this is safer work there we go i think that's the same one that's yeah that's the same one that's there so maybe if i refresh yeah cool so um our data is coming back in the same way that it is being displayed on zora that's pretty cool it only took us a few minutes to deploy our subgraph if um and that's really it i mean the one one thing that you might do would be to kind of uh continue iterating so if you want to make an update um you want to try change a few things you can do that all you need to do is make the updates in your code and just run yarn deploy again and maybe i'm sorry you might want to do cogen as well if you've changed anything in your in your graphql schema but anytime you want to read deploy just run yarn deploy and your deployment is updated and uh with that being said we're kind of getting close on time so i'll go ahead and drop off or go ahead and end this presentation with a couple of resources and then i'll be in the discord for the next you know 15 minutes answering questions so the workshop is linked here github.com three slash building a subgraph workshop um if you're interested in learning more about the graph check out us check us out on twitter on the websites our docs and we also have a discord that i recommend checking out if you're building out things and you want to ask any questions or you want to contribute back to the community um one other thing i would say that i didn't really call out here is we have a very really great grants program so if you're interested in making money and contributing to the ecosystem or being a part of it and you know getting paid for it um and you have some ideas then check out the um graph website um let's see your grants button if i can find the blog post here this is kind of giving you an idea around how the the funding mechanisms work and how what some of the things that we've contributed to in the past so it gives you a good idea around some other ideas that you might have so uh yeah that's it for me i just wanted to say thank you so much for checking out my presentation and uh that's it thank you another that was really great and um so much information um yeah i see a question that's actually really good like 12 million blocks um yeah the reason that uh it was so fast is that we um we gave it a start block first of all so it's not really uh so it did index that many uh blocks but it only indexed the blocks that actually have transactions from that smart contract so let's say i think we saw four thousand seven hundred entities so it actually ran four thousand seven hundred different um you know it saved four thousand times to the to the database not uh twelve million awesome yeah i think that was the the main question and as you were saying we're running out of time um so anyone please go to the discord channel another is going to be there for the next minutes and uh we'll be happy to take your questions and again during the event uh the the team are usually there to support you so as you start running into blockers feel free to jump in the sponsored channels that's why they're there for um thank you so much for the session nether thank you everyone for showing up i'll wish you all a really good day 