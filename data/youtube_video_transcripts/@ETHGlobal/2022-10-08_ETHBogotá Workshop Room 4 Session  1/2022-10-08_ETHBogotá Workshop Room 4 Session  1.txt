uh hello can you hear me well just a second uh hello my name is I'm from the open GSN team we've done a lot of guys less and lately we're working on account abstraction with the EF ezr from the f and I'm here to describe account obstruction with a specific stress on how to build the wallet on this framework I will go with a brief overview of what the account abstraction is what we abstract yeah security the architecture of a our implementation of a eip4367 some cool features we think can be built and should be built above it and then it will go into the SDK we have in how to use it how to use this API to create a wallet uh we do need a knowledge both in solidity and Ethos API in JavaScript I hope everybody here has it okay first of all before we do account abstraction as I said it's for doing for security what is the basic account security account security is for that does three things authentication reply protection and dos protection those gas payments we're paying the other mechanism used by the system for those protection they're not just fines and when we say account abstraction what we basically abstract is all of these so we have the wallet a wallet is a contract and the contract can abstract the authentication it can do whatever it like replace the signature whether you can use ecdsa it can use a BLS for aggregation or other things you can do Quantum resistance we as a counter instruction don't care what a signature scheme is used it except of using different scheme it can use to change the signer you're not bound to this sign address the signer is separate from the account itself so you can use multiple signer and a access roles whatever and you can do a recovery a lot of features you can do with the for Authentication for replace protection you still need to use somehow nonce you can use normal sequential nonsense like our sample but if you like you want to use parallel that is transaction that can be sent on chain regardless of the order you can do it also and for payment yes you can do the normal payment the account pays for itself but we also provide an API to let an external contract to perform the payment opening cool features like onboarding where some external contract application pays for the deployment or using token paymaster to pay the token for transactions briefly the components we have for account abstraction first is the user operation this is our transaction the replacement for a transaction structure is user operation we'll see it lately later then there's a wallet the account which is built of course from a contract there's a centered a second contract we call the deployer this is the contract that deploys new contract again through the system and the wallet software the ux we see the the browser extension or other software that shows the ux the transaction to the end user and let it sign the transaction it has to know the contract signature of course to sign using the right signature the next component or a system are the payments are the contracts that can pay for transaction if they want that is they verify transaction and decide whether this transaction is valid for their own payment system bundlers are the nodes that support account obstruction and put this a user operations a on a chain and the entry point this is the one contract we deliver that executes on chain the transaction perform all the validation orchestrates all the system if we look briefly about how we add it to the system we have an application that uses the wallet software and sent the RPC but you can see here that account abstraction doesn't come to replace say in one shot a normal transaction some nodes of the system continue to work with transactions some nodes no uh normal transaction but also user operation user operations come from a separate mempool so when a wallet sends a user operation into some nodes and bundler it will get into the network yes we would like all the nodes in the system to support user operations and account obstruction but the system will work fine even if only part of the nodes supported uh if you look at the flow on chain once a node sends a user operation the single method in entry point called handle Ops to send a transaction the transaction goes through four steps first step if needed optional is to create this wallet if it has an init code it will deploy this wallet contract if needed once it is deployed the validate user method is called this is the main method with the seat later that a wallet a has that validate the signature announced and everything and pays if they're needed if there is a paymaster the paymaster is consulted whether it wants to pay for this transaction otherwise the transaction will be rejected and finally a the transaction will be executed on chain and as I said it's called handle Ops it can be a bundle that's why we call it a bundler with multiple Ops in a single request but I'm not stress of this because this is something that a wallet doesn't care about something that the system does for its own optimizations a if we look at the transaction the way we see it is an application how how we add account abstraction how applications start to interact with it so an application is probably stay unmodified it uses a wallet it will continue to use a wallet the wallet will be modified of course instead of creating a transaction it will create a user operation and display to the user with the added Fields ask user to sign it and eventually send it to the node through a different type of SQL the send user operation the node bundler will accept it we it verifies it unlike normal node that knows the signature scheme and everything to check it it will it makes the view call to this validate user up not directly but it makes a vehicle to the entry point to validate this user operation and it added to the mempool later on a bundler what used to be called in the past minor will collect all these user production from the mempool and we'll create a handle Ops transaction and put it on chain okay let's see what we have in a user operation a user operation first it has all the fields that you see for you know from a normal transaction the call data itself got limit values signature uh and bonds except that the definition of nonsense signature are completely open to the wallet implementation then there are some extra fields that we add we put the sender since we can't assume this signature is ecdsa which you can recover the address of the center from the signature we have to specify the sender addresses specifically if the wallet is not yet deployed we have the unit code which is the code that is used to create this wallet and we have several extra gas fields that we have to add we have a verification step so we have a limit on the Gaza similarification step can take and there's some gas value that has to account for all the things that you can't check on chain like call data cost to the ETC and finally there is the paymaster information if there is a paymaster it will be specified on the paymaster uh what the wallet has a to Define the API we provide specify the function validate user operation in the iwallet interface this is the only function we mandate by its name by the wallet it received the entire user operation and the request ID which is basically a hash of this user version this is what gets signed and it needs to a validate the signature in aggregator not relevant for this talk for a separate talk about signature aggregation highly relevant for l2s not relevant at the moment and the missing wallet funds this is the Top-Up value the wallet has to pay if no one else pays and there is no balance that it already has it has to pay this to the entry point for this transaction to succeed if this a valid user reverts the transaction will fail it will not pay anything uh if it succeeds then later on a the entry point will call the call data there are two wallet there are two wallet specific functions we don't mandate their name but the wallet has to provide them one of them is nonce to return the current non's value when we create a transaction we need to know the current nodes and the other is the method that will be executed from the entry point so in our sample wallet we call it exec from entry point which I think is a good name it has to have implementations for these two methods um okay now I'm going to the client side I want to create a transaction I need to have a wallet but today we don't have a wallet that support account obstruction so we created a method where we can use an existing [Music] injected wallet like metamask and still use a counter structure with it provider the current provider you have we have an API to wrap it with the account abstraction specific provider when you send a transaction through this provider it will go through the logic of a create a user operation for it and to send it on chain so if you add this code to your client application it will go through a account obstruction one thing that is missing here is that you see we have the wallet address uh this wallet address exists even before the wallet itself is deployed on chain the wallet is able to pay for itself for its own creation so we need to fund it to send some if into this address or if you use the paymaster the paymaster can handle this payment but this address the signer address of our provider this is the address of the wallet itself and then I create a SSA contract in called some method and the method will get called and the First Time The Vault is called this method will also create the contract the difference from a normal wallet yes it will take a little more gas because you need to deploy this contract just before making the call this is the high level API underneath this API we provide the we'd call a base wallet API this is the API that lets you create user operation you pass the parameter to it it will create a the user operation but creating use operation is a highly dependent on the contract so this base wallet API which is in abstract class provides a four abstract methods how to create an init code for this specific wallet a method to sign the get nones this is the method that reads from a vehicle from the on-chain value of the current nodes and a method to create the execution function to make this call and in our sample contract we have a contract we call a simple wallet so we created a simple wallet API because this base base wallet API and implement it for our contract is double for methods so you create a simple wallet API and then you can call it a to create a transaction Center or unsigned transaction and then send it on chain the owner we see here also on the base class is a signer this is the the owner of the wallet which is the the class a bit get called to sign the this user operation uh okay if you have any question I can go back yes see there I haven't okay when you create a simple wallet API a specific wallet API it is for a specific instance you can pass it here the address I didn't specify if it is pre-configured you can pass it also the address of the wallet contract itself the apis I call it here is it is not yet created so I create this object I specify the sign the owner the signer and I have get a wallet address I have a method here to get the address of my wallet which will probably the one I will use on the next call yes the sample here shows only the first creation for an already created wallet yes you will specify the answers of the world obviously also you can have it is possible to add account abstraction support for an existing wallet like with an example how to take ignosis safe and to add it interface to be called through account abstraction so obviously if you didn't create it this way you have the address of the wallet it is not created through the system but once it is created you can use it as reality yes both here and the high level API you can specify the address of the wallet yes Center it is called Center it is called sender because sender is the contract that we'll call the call data call data is the encoded call so if I and I will call it on the sender so I like to call it a wallet okay it's the same the wallet is naming is problematic yes what do you mean change the parameters yes yes we don't you can have what whatever you like I think the best way to do it is make a transaction that you as the owner of this smart contract makes to make some changes you can have an API that will be used only through entry point but if you want to call it directly for example you don't want to use for one transaction you want that the owner can also call directly this contract then you will want you will want that to change owner change entry point all this function will be callable the same way so this is the way we suggest to do it U.S owner allowed to make execute from this a smart contract and also make changes on itself yeah yeah so I think the the normal flow for reconfiguring whatever whatever type of reconfiguration you want to do whether it's to set a new entry point or even let's say it's a multi-sig and you want to add a signer then the the correct way to do it will be through a user operation where in the call data you can specify you can interact it's actually a self caller the wallet is calling itself so it will still go through the same validation flow validate your validate user of implementation gets called and then after the wallet says yeah I accept this sign or I accept this operation and then it will be executed on the wallet so we don't we we don't mandate which there's no interface for what other what are what other functions the wallet needs to implement you can have an exit function you can also have configuration functions but you should make sure that they can only be called by the wallet itself or by entry point depending on the model you use not by anything else any more questions for what mm-hmm yes it's uh you you would have to uh you would have to deploy if you wanted to have the same address then you would have to deploy you would you would have to send the first transaction on each of the chains which would deploy the wallet uh if you use the provider then this is a transparent to the user it just gets deployed but the caveat is that but all that both of the chains need to have the deployer in the same address in order for the created wallet to also have the same the same address it's a yeah it's done since uh it's all counter factual you can start so you can assume that you own the address you can assume that you own the address you can even send assets to it without having the contracts and then the contract gets created the first time you transact with it it's so it's created lazily or optimistically when when you need to start using it it's actually it's an it's actually the way the way you're supposed to do it because the wallet is supposed to pay unless there is a pay Master involved so uh putting their paymaster use case aside the wallet needs to pay for its own creation so uh so you need to have uh so you need to have some if inside the wallet uh inside the wallet address before the wallet will even exists you send it to the address before after getting the wallet address and then when it gets deployed the first thing it's going to do is during the during its validation it will pay for its own creation and if it doesn't then the creation gets reverted yes and if you want to use it a cross chain a as a wallet Creator you have to make sure that the deploy your contract is the same on all the chains and this way it will create the country factual address for this sign it will be the same on all Networks yes we don't mandate how to use it but yet it has to be deterministic as you have said the wallet can't pay for its own creation unless you as a wallet Creator can counter factually know the address and put funds into it so if you look at the high level API you see I I use normal ether the code I created the app provider the signer in our provider it's not a real signer it's the component that sends it as a user operation but it has a method get address in normally account it is the account address which is really designed in our case it will return the counterfactual address that you can use to send funds to but again it depends on the deployer that will work yes we provide a sample deployer that is counterfactual that is creates the address exactly based on the basically it means that the deployer has to create the address based on the current signer the first signer you are using you have designer or the component that will sign this a create an all in the next request of this wallet a and based on the deployer itself and they say address you uh we create the address of the wallet if you later change the address it doesn't matter because then you will already have the address and you will keep the same address you don't care the counterfacturers only needed for the initial creation no no no sorry go on creative yes yes um so this is not a this is not a hard Fork it's an ELC meaning that we need the we need some bundle to support it and ideally it would be great if all nodes support it if all block Builders support it but we can start without it so we are starting a network of uh we're starting a network of of bundlers and we hope it will it will expand over time because it's going to be profitable for Block Builders so when a block Builder when a block Builder includes such a bundle in the transaction and the blog Builder gets paid for it so Blog videos are incentivized to participate in this mempool and include these operations it won't happen in one day but it's okay it can it can happen over time I'm sure I couldn't hear you right now right now there's an implementation of a nethermind that is a full-fledged node it runs currently on the girly Network we have our own bundler uh it's somewhat limited from a wallet's perspective it's fully functional it receives a user operation RPC and it puts them on chain from the bundles perspective it can be a dosable it can be a attacked large part of the ESC are made to how to make this a network of bundlers resilient our specific bundler it's simple but it's not as resilient as it should we are working on it with nethermine and others yeah ideally we have to say yeah ideally it should be ideally it should be part of nodes whatever when any node that is used for Block building has the information in order to in order to also uh build these bundles and as though mentioned there's a so never mind never mind implemented it in their own client and there is also and they also implemented it into Mev into Mev gath so there's actually a get Fork that also uh that also supports this and we hope that we hope to see a lot more of those and another way you can currently you can currently run a bundle safely is by having it is by connecting it to flashbots or to Mev boost so that uh so you know that you cannot be you cannot be attacked in certain ways because you can use the protection granted by a flashbots to submit the bundle I think we provide the sensory position resistance that the normal ethereum nodes gets it's a mempool and nodes take entries from the mempool that are profitable and put them on chain anyone you have actually another layer that if you have a specific application you can easily run your own bundler you know you will not attack itself uh because in order to be protected a bundler has to make view call to make sure it it will succeed and they make the transaction so a general purpose bundler cannot trust a components not a front run itself but if it is your bundler you can always trust it so you can you have a way to make always your transactions but for a general use I believe it is as sensitive resistance as nodes as a ethereum network yeah but there's actually there are enough but you actually have a fallback but you actually as a last line of defense let's say all the bundles decide to sense or you then and you're not running a bundler and everything you can always just put a bundle yourself since the bundle itself is just an ethereum transaction so if you have an eoa with gas you can use it to submit uh you can you can use it to act as a one-time bundler and put your you put your bundle on chain so it is a it is always a censorship resistant as ethereum itself running it has some guys want to is it cheap he said it has some overhead yes the overhead of the system is 20 or 30k or 20K on top of the normally 21k it's not a big deal you will lose because it's not a bundle you will send a bundle of one so you can't split it with others or if you do have you can it's less than a single units of operation and over it yes this is the simplest way to do it it is possible to manage multiple addresses but it's going to be very difficult to manage yes in order to be questioned you want to have the same address okay first it's not a problem with account obstruction itself it's a it's a use case that you want to support it we do see ways that you can use the same address on multiple chains well it requires that you put the same deployer on all chains and then you have it uh this deployer can be deployed using Creator using some counterfactual deployers that are out there or using your account like the deployer of glossy safe is deployed by their own private key on all chains so they can will always be able to support a new chains so you can use that method once you use it you have a mechanism to have the same address on all chains but technically if you are if you are on chains where you can't have the same address I can see a use case for example for having a registrar like you know having suppose you have a Singleton contract where on the channel you where you initially create a wallet you could have a mapping you could have a mapping that says you can send it from a certain wallet and um okay yeah so you could build Solutions around it yes we added support for Signature aggregation mostly for BLS and we have a reference implementation of BLS using it the idea is that you send a bond a bundle of a multiple user operation but with empty sector in all of them as long as they use the same aggregator you have a single aggregated signature and there is a get another contract that you have to use which is called a signature aggregator you interact with if you want to go deeply you can we can talk about it later right now it is not deployed anywhere there's a sample that works with it but a we didn't go make any further progress with it yet yeah but it is only valid for l2s because there is a requirement that the cost of aggregating a single signature is a less and on ethereum the cost of pairing aggregating a single signature of BLS is more expensive than a easy recover so there's no point of using it on any chain that with the gas with the L1 gas limits on l2s where there is a huge gap between call data cost which is very expensive and the CPU data CPU gas cost which is very low there it makes sense very much to be used yeah I think I think we are a bit over time so we can continue to take questions sorry if you want to uh if you want to keep discussing it okay [Applause] thank you for coming out today my name is vaness and I'm a developer Advocate with wallet connect thank you [Applause] for today's Workshop it's going to be pretty quick and easy we're going to go ahead and show off our new web 3 modal version two and we'll get connected and we'll be using some react hooks so let's go ahead and get started so for those who don't know wallet connect is a Communications protocol and we connect apps to wallets we have end-to-end encryption frictionless ux easy integration and multi-chain support we support any wallet any app any chain so to get started we're going to go ahead if get a project ID and we can do that by creating an account with developer Cloud so if you don't already have an account you should be able to scan this QR code and this will be kind of like um you know you can go ahead and start coding too so we want to make sure that everyone's running locally at the end of this with a full-on integration with the modal so I'll give you all a couple of moments to get that if you don't already have it and you can also create an account using your ethereum address so you don't actually need to create it using an email and password okay so most people use react so we're going to go ahead and make this example using react so to get started we're going to go ahead and create the react app you can do that by using your terminal and importing or typing in npx create react app name your app whatever you'd like we were calling it wallet connect demo and then the Imports that you'll want to use will be web 3 Act and web 3 modal ethereum since we will be making the example on the ethereum chain and then we'll also import ethers the QR code over here is our GitHub to our model 3 version 2. so if you want to take a picture of that you can actually also follow along with the docs along with this presentation so to get started we're going to first import web3 modal so we have an example here in your index.js we're going to first start with importing web3 modal from web3 modal react and then we're going to configure project that project ID will be that same ID you just created from the developer cloud we have different theme options we have different accent color options as well and this is the ethereum object where you can go ahead and name your app and to actually use this web3 model you'll actually import it and use it right below your consuming app so it won't actually wrap like in the past with our old modal so that is something important to note for the next step you can go into your app.js file and you can add in that line import connect button from web3 modal react and if you just return the connect button modal you should be able to see a view very similar to this you should see your connect button and when you click on it you'll see this new modal pop up and that's our new model that we will be using so we want to be able to actually be able to pull in some information from the user when they when they authorize using that connect button so we're going to do that by using the use account hook and a couple of things that we can pull out from that is is connected which is just a Boolean which will return true or false and then the address and so for the following example we're just going to create a ternary option so if the user is connected then we'll be able to see their address if they're not connected we'll be able to render that connect button and so this is kind of an example of what that should look like so we get logged in and then you can see your account address pretty simple but we kind of want to go a little bit further you know we've got ens names these days we've got avatars that we want to show off so we also have some um hooks for that and one of those hooks is called use ens name and so very similar to what we did with use account we're going to do the same thing with use ens name and so we're going to destructure it destructure the object take pull out data and then pass in the address which is the user's address and we just kind of updated the return statement here so we should be able to see their name their ens name as well as their address so that's kind of what it should look like but if you're doing this live you might notice that there's a moment where it takes a while to load the ens name and you probably don't want to have that because that's not really the best user experience so we're going to add and make a couple of adjustments here we're going to create a new file under a new folder called the data.js and we're basically going to kind of move everything that we had in our index or in our app put it into Data and then we're going to also now add this new property called is loading and we're taking that from use ens name hook and so what that will do is if it's loading then we're not going to render anything we're going to just render loading so then the user doesn't actually see their address first and then they have to wait at you know that moment until the loading is complete and then this is the updated app.js so instead of having most of our return statement now we're just passing in that data component and so this is kind of what it should look like upon connecting so you have that loading State and then once it's actually complete and lastly we can't really have the full user experience unless we can also give them the option to sign out so this is where we use the use disconnect hook so we'll go ahead and import that in the data component and very similar to the other hooks as well we'll just create a new const and call that disconnect and then we'll add our button so right underneath address we add the new button we give it the on click Handler which is going to be disconnect and this is what that should look like you get your button once the user clicks it'll take them back to the is not connected state which will render that connect wallet button and lastly if you have any more questions you can take a look at our GitHub which will also have other react examples if you want to go ahead and play around with those so that kind of concludes our Workshop I know we went kind of quickly but I really wanted everyone to have a chance to really play around with the code and have this modal working so are there any questions or are there any places where anyone's stuck structures you said structured I'm not too sure we do have our engineering team here so I'm going to kind of look at them for support here and see is that something that we are able to do at the moment right up here new blockchain um well a couple of things so we're gonna we're going to need wallets that also play with those blockchains so we need to have the wallet support first and then we can have the DAP um integration as well are there any other questions great I approach about word coin that is compatible with control is World coin compatible with wallet connect with the version one protocol or the version 2 protocol the two that's something that we can look into I haven't heard that we are or not compatible with worldcoin but if you want to follow up with us at our booth after this I'm sure we can answer that question for you yeah thank you all right well thank you very much for joining us today um and have a great um hacker weekend [Applause] foreign my testing hello yeah uh hola Bogota Estates so that's all the Spanish I know so yeah my name is chai I'm the head of engineering at web3 auth um so today's session will be about uh how we simplify blockchain and web3 access for everyone and how do you enable these smooth seamless experiences for your users uh using web3 auth okay so uh for people who don't know about web3 what we do is like we simplify web3 for everyone uh and it's where password soft meets uh MPC enabled non-custered L key management for OLX and apps so that's like a mouthful but the idea there is like uh we allow you to do key management but we allow you to do in a non-custodial way and we enable familiar web to login experiences for web3 users so it's like uh you can use your social logins like Google login Facebook login and so on and get access to a blockchain wallet and we do it in a fully non-custodial way okay so uh let me just go through about what a typical web3 user experience is like and what are the typical problems with associated with that so uh for so if you look at a typical web to login flow how does it look like okay user enters an app they log in Via SSO and then they simply use the app okay so this is what happens with the you know millions of applications out there in the wire and this is the typical flow which everyone is familiar with like you know more mainstream audiences like my dad and everyone okay so but if you look at web3 login flow it's a bit different right so it's dramatically a bit more complex so whereas user needs to enter an app and install needs to install like a mobile app Wallet or an extension I need to set up the seed phrase and we need to educate the users about securing those seed phrases uh need to connect the confirmation with wallet and app okay and we need to talk about the extensions and all uh and also after that the user will start using the app so this leads to multiple problems obviously uh the first of which is bad ux okay so let's say if you're developing a small game right you want the users to focus actually on your game rather than uh you know installing and setting up a Chrome extension so uh what we uh and uh the couple of other problems are like you know there are some uh unfamiliar flow so these are all like unfamiliar flows for mainstream users okay and uh there's no easy recoverability okay so if the user basically forgets the seed phrase or you know doesn't secure it for whatever reason so uh a lot of keys are lost okay so nearly 3.6 million Bitcoins are lost from misplaced private keys and a seed phrases are like the single point of failure in this case okay and for many applications which are built on web3 uh there is a very high drop-off rate okay so nearly 70 000 daily dapps users are lost from the web 3 ecosystem due to the long onboarding time so typical setup uh takes around like 10 minutes right so this is time better and in the day of in the day and age of like Tick Tock where people's attention span is like very low uh getting them to spend 10 minutes just to use your blockchain game is like super hard okay so ah so how do some of the Enterprises solve this key management problem okay so they use this concept called as multi-party computation so these are some of the Enterprise companies like fireblocks bitco Anchorage and uh paxos uh who use MPC Solutions or some custodial Solutions in order to uh manage the keys okay but what we do at web is we are trying to democratize this Enterprise grade security for everyone okay so we bring these personal multi-factor keys for uh any application and any wallet okay so let's say if you want to build a wallet and you can use our authentication Service to uh build this you know the multi-factor authentication for your users so uh let me just talk about the way web3all smoothens the user's journey into web3 okay so what we offer is the familiar white label login flow so users can uh use the social logins which are very familiar within the web 2 apps uh it helps reduce the onboarding time it improves the conversion rate up to 74 and we also provide like the passwordless and other social logins as well so we have a very good ux team which has done a lot of research on this space and we have actually seen several applications move from uh traditional Chrome extension flows to using a web 3 auth and they have seen dramatic improvements in terms of user retention uh this is especially true in terms of uh the native apps and uh the other mobile applications as well like you know the mobile web browsers where the extension flows are much more complex to use next uh we can connect to any blockchain with any wallet so we provide interoperability across the chains platforms Frameworks wallets and logins so we are blockchain agnostic we are platform agnostic as well so whatever platform you're building on whatever chain you want to Target uh you can use our SDK to basically get keys for that platform next uh what we offer is the non-custodial MPC enabled Enterprise grade security so it allows applications to legally operate without if I see AML because the key management is non-custodial so you are not subject to the same uh kyc AML regulations which other companies are subject to and it future proves the company's liability to Safe Keep user funds because of the non-custodial nature the user is actually responsible for his own funds and we have some really amazing ux flows which make sure that the user never loses their account and usually has actually uh very good access the secure access to all his different types of shares okay so uh you can experience this yourself as you can see now on the screen I yeah the video is playing so I just log in into Google and then boom you're actually in okay that's literally uh all you have to do so the rest of the magic is done in the browser uh I'll just go through on how this magic is done later on but uh the as you can see there is no difference between a traditional web to login flow and the web3 login flow using web3 auth okay so users feel very comfortable they feel at home and then that's it okay and they're able to connect to their wallet uh using this okay so some of the top Integrations look like you know a lot of caster skyviewer and chess.com so all of these companies have integrated us um we'll share this PPT later on you can actually go to the sites of all of these companies and then you know experience the login flow for yourself um these are uh web throughout this is actually trusted by uh the best and over 3000 applications so we are currently integrated into all of these applications as you can see uh several there are several wallets and exchanges there are several Games Social applications Enterprises marketplaces nfts finance and everything okay so uh we have three companies in every space basically uh integrators and they try to offer the seamless experience to their users okay so at this point I would like to uh just pause the presentation and then go through our documentation yeah so uh so we have a really good documentation in terms of uh how to integrate our SDK so our team has actually spent months curating this and we have received like rave reviews regarding uh the ease of use for our documentation so if you guys go through and integrate our application using our documentation we would love the feedback which you guys can offer okay so we have a booth in the upstairs and uh our team will always be there so please feel free to reach out to us we also have uh Discord and telegram channels as well feel free to reach out to us and then you can comment about anything okay so if you feel some concept is harder to understand we'll be glad to improve our documentation regarding that yes so uh coming back let me just go through what uh a quick start on how it looks like so you can basically start by integrating a basic web3 model into your application and then you can customize it according to your needs uh we also have a really good integration Builder like this so you can choose your language framework and then you can choose the blockchain you're targeting uh you can also talk about whether you want to use custom authentication or you want to White Label our model okay I'll just show a demo of how this looks like as well but custom authentication basically is one of the key features which web3 also offers so let's say your application already has a login mechanism okay so you have a email password login or whatever in your application you can bring that and you can bring those users over to web3 so which basically means that we create non-custodial wallets for your existing users as well so that is something which is possible with custom authentication and the typical web3 react quick start guide which because many people use react so yeah that's the default here and the blockchain is ethereum uh so you can just use npx create react app and then npm start um so webpack 5 basically said like you know uh We're Not Gonna support the you know node modules so we need to add this uh fix the webpack issues uh then you can install web3 or ethers uh and then you install a couple of dependencies of web3 auth uh after that you import our dependencies and then at this point uh we would like that you know you guys register for a new client ID on our developer dashboard so our developer dashboard looks like this uh it's it internally uses the web 3s login mechanism as you can see so we believe in our products that much yeah uh so the typical login flow looks like this I just clicked on login with Google and then oh I have Biometrics enabled so I just clicked Biometrics so that's also something we offer by the way uh and it goes through the typical login flows where the shares are reconstructed from uh the social login nodes and also I have one backup share on my device so all of that is being reconstructed at this point and then any minute now it will be done I mean the network is a bit slow here so it's taking a bit of time but normally it's much faster yeah uh and I just select an account I think I'll just get into my admin portal so whenever you're ready oh there you go okay so I'll just turn off my admin portal so uh this is how the typical dashboard looks like um and you go to the Plug and Play section and you can just create a new project okay so this can be any project you can select the environment which you want uh prefer typically prefer the sign main net for uh building over here because the cyan mainnet is present in the US and then it's closer to this geographical region and yeah you can also select the chains you're uh building on top of and you can also select whether you want this web ski to be shown in the Taurus wallet so Taurus is the previous name of the company uh we have a couple of wallet Services as well so if you are building an app using web3 auth uh the key can be shown in the Taurus wallet so that it can be used within different marketplaces basically like openc or something like that okay now once you create a project you can actually whitelist the URLs here like you know it's a typical oauth flow right uh you create a project get a client ID you whitelist your URLs basically and uh so on and so forth so um we also show you the typical usage of how it looks like on the dashboard itself and then you can also read the docs and go to the integration guide so let me just go back to the integration Builder so once you get your client ID you can create the web instance like this so here I'm targeting the ethereum mainnet so that's the chain ID and the RPC Target and you can initialize the model so at this point it actually shows you the model uh you can log in the you can lock the user in using a web3. connect and after the user is done the dot connect resolves and gives you back a provider uh you can also get the user info using web3.getuserinfo uh you can interact with any evm compatible blockchain because I selected ethereum at the top so the way it works is like you know the web3 dot connect returns your provider so you can use that to initiate web3 or ethers and you can do all the methods which you are familiar with using web3 right so you can just get your account up your dot get accounts and so on and so forth okay sign transactions and transactions and everything okay yeah you can also log the user out when he's done so using uh avoid webfield.logout and that will basically require the user to log in again when they come back to the app okay so um how does a typical integration uh look like okay so I'll just go through that first so this is a demo app which we built uh for some you know it basically demonstrates all the different types of mechanisms which are possible um yeah there you go so I'll just select mainnet for now and I click on submit and then yeah that's fine so I'll just click on connect so it shows me the model so at this point uh when when you see the model it basically means that webster.connect was called and I just click on login with Google I go to the same flow which I showed you on the developer dashboard I select an account my shares from the Taurus Network the auth network are being brought into the front end it's combined with the device share which I have on the device and then that forms my private key and you get an appscope key for your application from that private key and um any second now that will be done yeah there you go okay so your application this is the demo application so this gets back the apps called private key and you can do everything with it okay so I can get the user info those that's my user info uh I can get sign some transactions okay so this is a typical transaction signature how it looks like I can sign messages uh so we support all the eip1193 uh uh yeah EIP one seven EAP 72191193 as well uh so you can also get accounts get chain ID get balance do you have balance on this no okay yeah and we support all the other ethereum provider um stuff as well okay this is how the typical integration looks like now uh you can also uh refer to our examples examples GitHub repo so we have examples for all kinds of uh different combinations which you're looking for so we have some important links here as you can see and if you have want a react evm example or next view angular common JS so depending on the SDK you choose we have an example for it okay and if you really want an example for a different platform please reach out to our team we'll definitely be adding that example here as well so we can Target different blockchains different types of authentications and the mobile sdks as well even the gaming SDK so we have gaming sdks for Unity and unreal as well so we have documentations guides and everything for that so once you have the integration Builder we also have the SDK API reference so as you can see uh so we have the API reference for both uh for all the platforms as you can see there and uh yeah uh you can integrate our SDK using the integration Builder the asdk API reference and we also have some guides so if you have some custom authentication like Firebase or zero or any other type of authentication provider authentication mechanism we have some really nice guides for that so yeah you can easily use all of that to provide the seamless experience for your users in the apps okay so now uh coming back to the presentation so we have uh something new which we're going to announce today okay so this is our Early Access Alpha MPC SDK so uh in the previous flows as you can see uh we reconstruct the private key on the front end okay so with the alpha MPC SDK uh we never reconstruct the private key okay so it's all done via threshold signatures okay so this is basically like uh fire blocks but for uh you know consumers okay so uh you can just scan this QR code to access our Alpha MPC SDK and uh I'll just talk more about it this is a very new SDK which we are launching just today uh this is a typical demo of how it looks like Okay so as you saw that you know this is a typical same web3. login I'll just uh still log in with my Google account um it just takes a sec yeah so the difference here is that the private Keys Never reconstructed anymore I'll show you how that works and also the way we sign transactions is quite different because the transaction is sent to all of the different MPC nodes and all of the nodes basically partial sign and as I said I also have a share on my device so I partial sign with that share on the device as well and once all the partial signatures are combined it forms your actual sign transaction which you can then submit to blockchain okay so uh the MPC has two phases like pre-computation and signing so the pre-compute phase already happens when you uh just simply load the page as you can see uh and it's very fast by the way as you can see even with this internet so I can just sign a typical message like hello Bogota and as you can see that signing was done okay it's less than a sec for MPC signing and this I would say is like the best in the industry okay and yeah you can also verify that the signature is valid by going to the scan and then verifying this okay so this website is live you guys can play around with it and then if you face any issues you can feel free to reach out to us yeah so there's some small comparison I would like to do uh comparing uh the web 3 MPC versus uh the typical competitors so I'll just use a cluster in South America for whatever reason and see gg20 is the current standard which the rest of the Enterprise are using and you'll basically see the the speed uh speed comparison between the two scenarios okay maybe I can open the developer console yeah so this is all the things which are happening okay so the green is the dkls which is it was done the pre-compute was done in 10 seconds the signing time is like one second whereas uh the gg20 is still not done okay so I can basically change North America run one more maybe then the gg20 will be done let's see okay so this basically shows that our solution is like miles faster than the competition okay and uh yeah this is all the console logs which are happening okay this is all the things which are happening in the background yeah as you can see the competitors uh solution takes around 27 seconds uh for the pre-compute and the signing takes 2.7 seconds so we are like much much faster okay yeah and this is our uh the documentation for our Alpha SDK so if you guys want to use the MPC which I was showcasing here and uh here the threshold signatures we have a new SDK for that so the only difference between the new SDK and the old SDK is the way you initialize it okay so the older ones basically use at the rate web 3 or slash web3 auth and this uses at the rate web 3 or MPC slash web3oth and the way you use it is exactly the same as the a typical web period integration except the open login adapter the way you write it so you just use iframe URL as MPC beta.openlogin.com this is our Alpha site where we have the TSS signing and you use the TSS settings like this and then you can just copy paste all of this logic and it will just work okay so as you can see the typical login logout flows the quick starts all of them are exactly the same and you can use it with any blockchain and the flow is also exactly the same okay so there's no difference or extra complexity which you need to do uh in order to integrate the MPC uh flows okay so we also uh have a very nice code for the demo so I was showing you uh this demo right so so this is a different demo uh which basically shows you how to integrate the MPC SDK and uh yeah this is a simple uh repo which showcases that integration and I can just show you the run through the code very quickly so it's a typical react app as we talked about I just install at the rate web 3. MPC slash base and the web slash NPC slash web these are the new sdks for the MPC as I was talking about uh and uh the rest of it is like the typical react app we just need to do the config overrides the same with any web3 application nowadays and when you go to app.tsx which is where everything is uh you can initialize web3 auth or you can initialize open organ adapter pass this TSS settings to enable the MPC for you and you I need the model you need the model basically initialize the model in the back end configures the different adapters which we have and so on and so forth and then when the user wants to log in the user basically can click a button and then we call webclub.connect so once the user is connected we get back a provider and then that's it you can use that provider to do uh all the transactions okay um so I'll just do uh npm install here or no it's yarn actually so yeah just do yarn and uh yeah I don't think the internet speed is that great but no worries so uh you can do the typical things which I was talking about like before like you know getting the user info logging the user out getting the chain ID getting the accounts balance signing and sending transactions and everything okay so uh the flow remains exactly the same it's just you need to use a different package okay that is all and our team will be always here so you can reach out to us if you face any issues while integrating the new MPC or the uh old uh web3 or typical SDK okay let me just get back to the PPT now so uh thinking about what to build okay so you might guys might be having different ideas already and you guys might be uh already forming a team regarding you know if you have an idea you want to build that right but if we also have some suggestions for some of the ideas which you can build uh on top of webcode so uh we offer uh around 20 000 total in the Bounty tracks uh the best overall app gets 7 000 the security track has two uh items the best in track gets four thousand and the Roundup gets thousand and uh we have other tracks like identity and data and then use case and ux as well so we think ux is a very serious problem to solve in case of blockchain and then we prioritize that by actually giving a very good Bounty for the use case and ux as well so here are some of the ideas regarding what to build so uh the top idea basically is like the building the security policies on the MPC engine so I was just talking about the MPC engine right so where we have the threshold signatures and all so in that case uh adapt can basically choose to have a policy engine in the sense that let's say all the users of its dap should not spend more than 0.1 each a day okay or even user can configure this user skin configure like I do not want to spend more than 0.1 each a day or any kind of limits okay so uh you know you can also have some sort of scam detection or you know transaction uniqueness or something like that so uh all kinds of security policies can be built on top of the MPC engine so we have some really good code for this in the demo which I was showing you earlier so we would love to see more security policies built on the top of this MPC engine and uh yeah the best price usually goes to the best security policy to be honest yeah and we also have uh combining the MPC with smart contract or multi-c capabilities so if you're building on top of other multi Sega or some smart contract wallets um you can use the MPC solution to integrate this as the default key for those smart contract wallets or the multi-6 uh cases so how do you introduce the time-based security on MPC or uh what are the some of the IAM systems that people would appreciate like you know you can integrate nodes to save plus MPC or something of that sort next uh there are some ideas around encryption and decryption as well so could we build a messaging layer between the wallets and apps based on the user public private key Pairs and what are some of the ux friendly permission systems for users when uh talking about their uh data so these are some of the ideas which you are thinking about in terms of the encryption decryption side and some of the ideas regarding uh the webtoon web3 identities are like you know how do how can we help apps identify what users would be into ahead of time so like web has this concept of uh derived addresses okay where you can know what the address of user will be before they actually log into your application okay so in that case as well uh you can use web to actually identify the identity and we can also manage the backend systems for web 2 and web3 for Server resources and can we share the recapture or kyc for multiple users using this next because we link web 2 and web 3 identities right so it makes real sense to uh have some of that next uh for payment so how can we make crypto payments more friendly uh what stack or markets would appreciate crypto payment adoption and uh the most important on the silky smooth ux so you like that we just can't trust this like you know uh if you are building some application with a very slick ux that basically qualifies for a really good price and uh what are some of the gases abstractions you can do on top of the uh E2 okay so these are some of the ideas which we have and uh yeah that brings that brings us to the end of the ideas so this is our MPC SDK so you can scan this QR code and then you can uh keep in touch with us on the Twitter at redwap3 or discord.dg web3 this is our Telegram and you can also mail us anytime so uh please feel free to reach out to us and uh we'll be available on all these platforms uh throughout the hackathon uh our team will also have a couple of mentors at our booth uh so please feel free to reach out on either the telegram or by coming over to our booth so we'll be happy to help you in any sort of uh way we can also brainstorm a couple of ideas which you would want to ah discuss as well okay so uh yeah that's the end of presentation okay does [Applause] uh does anyone have any questions hello so the question was that uh if you sign using web3 auth into different applications using the same social login would you get the same wallet address or different one so the answer for that is you can configure it okay so let's say if you own both the dapps if you use the same client ID you get the same address if you use a different client ID you get a different address so the way it works is even though the Social account creates only one private key if you use it in an app you get a app scope key derived from that root private key okay so the key switch apps receive are basically appscope keys yeah their scope to your app yeah no other questions you can always export the private key yeah so users can export the root privately by visiting app.openlogin.com or uh the DAP apps go private key is also available for the lab and the apps can create the UI to export it or users can also download all their apps scoped keys on app.openlager.com as well okay so we have configured the entire ux around this to be very seamless both for the users and the dapps as well so the dapps can basically automate all of this programmatically in order to you know help users understand and Export their accounts as well yeah foreign not really so as I said the private key consists of multiple parts okay and the private key consists of multiple parts so the social login basically uh share is split into multiple sub shares in the across the Earth Network and you also have a second share on your device you can also have one more share on your backup phrase and so on you require two out of this n shares to actually create your private key which basically means that uh it's non-custodial kind of or self-custered as I would say for the end user because let's say even if the Earth Network gets hacked for whatever reason right uh the attacker cannot get access to the user's private key unless they have their device or you know the backup uh whatever yeah so in that way it's self-custodial login or non-custodial login the way you see it yeah that's that's kind of our USP in terms of comparing to our competitors yeah yes so uh while the user sets up the MFA we also offer uh different types of set setups okay so like user can start with two out of two two out of three two out of four and so on uh you can add multiple devices you can add a password you can add a security questions backup phrase you can also do n number of things so we have generated our own user flows after multiple uh yes of you know ux research so to make sure that users never actually lose their account even if they lose a device or even if they lose forget their password or uh lost their backup phrase as well okay and we also have this solution called as web 3.self host which basically means that you can build all of the ux flows which you are which you are showcasing so in that scenario our team can work with you in order to provide the best ux flow for your application as well okay that's available as a separate feature yeah yes pricing um yeah uh the pricing you can go to web3.io pricing to be honest we are cheaper than Cognito or OCTA yeah right the pricing is basically uh based on Mau monthly active users so depending on how your application gets uh the monthly uh how many monthly active users your application has the price scales okay uh it's free up to the first thousand monthly active users and we have different uh tiers based on the number of Mau you have uh the typical would be like I'm not sharing screen but uh for a thousand logins it's like 70 something I guess yeah uh so it it's like point six cents per user 0.6 cents per user for a million logins uh per month okay Mau per month yeah it's like rock bottom so you can actually check the slider oh my God my mouse is not working okay so yeah so that's the slider we have and if you cross more than one million you can uh upgrade to Enterprise and then you can have a custom rate for your application yeah yes yes so uh one good example I would showcase is basically like uh cash dot IO um yeah there you go so cache.io is a typical example of a multi-chain application so they are present on both tezos chain and ethereum mainnet so how it works is you can simply log in with your Google account I keep using Google for no reason you can use other social logins as well okay you can also use the passwordless by the way yeah uh and so on and so on so forth basically the app gets an app store private key and then they derive the trezos key from the same private key okay so that way the keys are compatible with both sccp and ud25519 chains so you can typically literally use it with any blockchain okay so all blockchains basically use sscp or ed2509 keys right yeah so as you can see I have a account on Tera I have an account on ethereum as well okay using the same login mechanism uh yeah my time is up almost so if any hand has any extra questions uh we'll be right outside okay last question maybe yeah um not really so it depends on the dab to actually configure it because the dab gets the appscope private key right okay so they can sign transactions on your behalf okay so the lab can show the models uh depending on their use case but let's say if you're building some kind of application which do not does not want the private key we offer another integration called as Taurus wallet so Taurus wallet is also our product and in this case uh the DAP never gets the private key it lives in an iframe it's basically a web-based wallet and it's the one which is integrated into openc and other marketplaces yeah okay so that's it guys we're out of time so uh our team will be right outside you can reach out to us and we also have a both on third floor please uh feel free to drop by and then if you have any questions please ask us thank you very much yeah I'm very excited to be here and present it for you today I work at a company called blocks which is the core developer of a very cool project called SSV Network SSV stands for secret shared validators and it's a decentralized infrastructure for ethereum staking now um with a quick before we start with a quick raise of hands how many of you here has been engaging in ethereum staking either through solo staking or any other stake in service very nice hopefully there will be even more after Defcon so I think in order to better understand what we do it's important to take a step back and talk a little bit about the current state of ethereum and how it works so the transition of ethereum to proof of stake started almost two years ago on December 2020 and since then we have about 440 000 validators active on the beacon chain which amounts to 14 million ether at stake or 18 billion dollars this represents about 12 percent of ethereum circulating Supply and those value dealers are earning approximately between four and four and a half APR um even more if you factor in math which is now available now I personally think this is pretty amazing even more compared to the fact that most of our ether was just collecting dust in our wallet right so um every new technology has challenges and ethereum is interior staking is no exception to that the main challenge that the most familiar one is slashing slashing is what happens if you part of the validation process do something that goes against the protocol it's a big penalty into your principal stake um which is pretty bad because it can result in negative Roi definitely something you want to avoid at all costs moving on under centralization if you are not new to crypto Twitter you probably heard a lot of concerns regarding centralization or a subset of that problem which is client diversity basically it's the idea there's there's no single point of failure in the form of one entity whether it's a client or a service that has enough market share that he can shut down or censor ethereum your keys have to be online 24 7. um this really goes against everything we know about Keys management right we need to keep our keys offline preferably in Cold Storage and so so it's hard it's also something we take for granted right because we all have our device in our in our pocket we we bring it up we have Internet but as in life the internet shuts off the kids plug it Off the Wall we go on vacations and sometimes we come to load up a song and it's buffering right there's latency issues now we personally can wait out those 20 seconds for it to load but if you were to run a validator and we were to miss a duty because of that we would miss out on the associated reward with that Duty which is pretty bad and last but not least ethereum staking has a very significant cost of development and maintenance in almost all staking providers out there has to build their own infrastructure which makes it very very not reusable now the bottom line of what I'm trying to say is that ethereum staking is very very hard and a lot of it has to do with the design itself of the staking so let's see how it looks like this is the most basic infrastructure scheme of almost all staking providers out there ranging from the coin bases and the Krakens of the world all the way down to startups and solo stickers managing a single validator this is the most basic way people set up their infrastructure and as I said the reason is is it's pretty much derived from the ethereum spec itself now in this middle part here we have a thing called a validator client this is a software containing of different and a bunch of validator keys each validator box we see here represents a 32 each validator on ethereum and this piece of software is responsible of coordinating those validators into the duties they have to perform periodically every six minutes or so now for the Keen eyes here you can see that this infrastructure has a very big flow in it this big thing in the middle is literally a single point of failure and this causes a lot of challenges and a lot of risks validator clients can only run a unique set of keys if you try to run a multiple valuable clients with non-unique set of keys then you're risking beings last Almost for sure so robustness through stuff like redundancy or backup is something that is really hard to to develop into the infrastructure of ethereum you also have to keep your past signatures of all of the things you signed with your value into something called the slashing database and if you lose access to that database because you fail to restore it or back it up correctly then you're also risking being slashed as well the keys has to be online 24 7 which is hard we just discussed this and because the infrastructure is not reusable it's going to cost you a lot of money a lot of resources and a lot of knowledge and expertise in order to actually do this and this is pretty much goes against everything we learned in the past decades regarding software development especially in crypto right one of the amazing things we have in our ecosystem is that we managed to build these components that everyone can use right usually it's the blockchain itself but it can also be an application if we take D5 building blocks for example that are stacking up and building on top of each other this really reduced the the cost of development for everyone and accelerated growth and innovation and because the current infrastructure of ethereum is not reusable it really hinders Innovation because if the cost of innovation is high then it's very high to innovate so with that in mind let's Circle back to SSV SSV it's a protocol it's a decentralized infrastructure for ethereum staking and it tries to solve a lot of the issues that we just covered so how does it do that well first it doesn't use a single validator node or any specific staking service or provider to run its validators it uses multiple of them there's no no single operators hold the full key so there's no single point of failure we use threshold signatures and BFD consensus protocol to coordinate duties between non-trusting parties in a way that builds fault tolerance within the protocol and the best part is that it's a reusable infrastructure anyone can use it in a permissionless way and this really enables you to focus on the application focus on your business and not on the infrastructure beneath but still a way that left you enjoyed a solid first class decentralized info Charter and it looks something like this and you can see in the in the middle part there's no single point of feather anymore there's a bunch of them and they work together to to run your validator and if one of those nodes or clients in our case it falls shuts down gets hacked or compromised nothing happens to your validator because the rest of them will continue to work and this is really the heart of it instead of having a single point of view a failure that runs everything you now have a bunch of them and this really removes centralization not only by the fact that you have a redundancy of more than one but also because it's highly customizable and you can cherry pick your validator operators according to their set clients their jurisdiction their client provider Etc according to your needs now we're all devs here so I'll let's see how it looks pretty much internally so as I said each validator has to perform periodically every six minutes or so a duty whether it's an attestation or a block proposal it doesn't matter and then those four or seven or whatever the amount of operators you chose for your validate those once a duty comes in then they together select a leader in a very deterministic way that leader proposes what they need to do for example sign in at the station and then if they reach consensus regarding what to sign and this is where really the false tolerance kicks in this is where the power of SSV kicks in then they each produce locally a partial signature they then reconstruct it to a full signature and execute it to the beacon chain as a full and valid uh Duty and this all means that no operator has the full key okay they only have a share of it so they need each other to work together but they are pretty independent right they don't need to know the other operators they don't need to trust the other operators only to to communicate over a consensus protocol so with that in mind the benefits of SSV are pretty significant right first of all you don't have to keep your key online anymore put it in Cold Storage follow the best practices of Key Management because they don't need the key um the threshold signatures that we used they Grant security and if a share is compromised it cannot be compromised in a way that will compromise the full validator there's no single point of failing anymore it's decentralized it's fault tolerant and it's ready to use infrastructure right it's it's reusable now you can use the same operators the same network the same setups over and over again and the cost of integrating SSV is practically nothing it's literally a smart contract call which is pretty amazing now the best part about everything I just said is that it's not some moonshot idea this is no science fiction this actually works it's running on testnet people are using it people are experimenting with it it works and you can try it out today so I want to talk a little bit about where we come from and where are we now well it all started when we received a grant for material Foundation to build an SSV node SSV was later termed as DVT distributed validator technology since then for the last year and a half we've been running test Nets during which we got engagement from over 3 000 operators a hundred of them and more are verified operators and by that I mean to real and reputable staking services some of them the biggest in the industry that are running a test this node experimenting with this with the intention to adopt it when it goes live we also managed to accumulate over twenty thousand validators so we can really test it that it works out in scale and right now we're at the final stages of getting it ready to launch hopefully early next year early 2023. now I want to kind of showcase to you how it looks like through a very simplistic flow or use case of a solo sticker that has a validator that he wants to run on the SSV network instead of running his own infrastructure or instead of choosing a centralized taking service so we built a very cool and easy web app which you can try which you basically come with your validator when you can import it to run on the SSV Network all you have to do is bring your validator key bring your key store file enter your password if you have one so we can extract the key and then you'll be asked to choose the operators for your validator you'll see a big list of operators a Marketplace of operators some of them you know and recognize some of them you don't but you can evaluate every one of them through some metrics like how many they are managing currently what is their performance metrics according to specific time frames what rate they are charging for their services because this is a free market and once you picked your group all you have to do is review and sign this transaction with your web3 wallet and once it's broadcasted to the network your operators will pick it up and start managing your validator for you and and that's pretty much it you're welcome to the distributed net infrastructure of the SSV Network and I really encourage every one of you to go to ssv.network check out this web app it's very simple very easy to use and it really showcases how to onboard a distributed validator and how to manage it so I discussed one use case but there's a lot of different use case which you can use to build on it right because it's infrastructure and install infrastructure was meant to be used somehow so these are the more most typical use cases that we come up with obviously there are more because now when we open up infrastructure as a reusable way a lot of innovation can happen so the most obvious one are staking pools it's taking pools that will use SSV as their backend and starting this presentation I said there's currently 14 million eater at stake this number is projected to go to 40 million in the upcoming year years and that new eater that will come in will not only go to Lido we'll not only go to Rocket pool but in our eyes there will be a long tail of new staking pools that will compete for this market share because at this amounts it's becoming a huge Market and for those taking pools for those news-taking pools now that they have the infrastructure available as a service the next rocket pool will not take three or four years to build it will take three months and we know this because we currently have teams doing exactly that in those time frames moving on there's a lot of the adult treasuries on ethereum a lot of D5 protocols even bridges that has a lot of ether they're also accustomed to to holding inter they're accustomed to the price price fluctuations of Intel and we see that that eater will eventually find its way to to staking because it's becoming the de facto reference interest rate for for ethereum and also staking services and institutional staking will want to use SSV as their back end to have higher performance more security to decentralize their operation and mitigate the risk they have now because they're running it in a central way and I want to use this opportunity to really call out all devs to check out our new uh and big grants program and where we give out grants to build exactly those use cases and help the teams bootstrap their operations so if you follow along one of these categories come and reach out make an application and also use this opportunity to extend this offer to the teams who choose to build on us today on this weekend if you choose to continue working on your project and make it from this weekend to a production grade venture feel free to to reach out and apply for even a bigger Grant we would love to support you and partner with you in the future go to brandssv.network check it out and so with that I would like to pass the torch to lior our CTO who will present to you how to onboard a distributed validator through our smart contracts thanks Ariel foreign so I hope you're getting excited after hearing um what I really describe um so I want to do a quick guide because I don't have a lot of time on how to run a distributed validator and how easy it is for developers we offering ground uh offering grants for this hackathon to run ssv's taking pool or us taking service based on SSV so to run a distributed validator I there's a simple pre-requirement is to have a validator if you don't have you can use ethereum Launchpad to generate one and deposit you'll need to go early and you'll need a test net SSV you can get both of them for us you'll need a little bit go early to just to make the transaction to our contract um you can get SSV as well from our faucet okay um the process is you select a few operators right now we support four in the future will support more um you can use um sorry then you need to distribute your validator key to shares and then register the Viator to the network and that's basically it to have your validator run on the SSV Network um okay so the operator selection you can use our Explorer where you can you can browse all the all the operators and um their performance as Ariel mentioned and and choose which one do you want to use for your validator okay once you chose them you need to just pick um just to copy their ID and publicly as mentioned here on the image and we will need it for generating the key shares okay so key distribution we created a SSV key distributor SDK and wrapped it with a CLI so you can either integrate it in some code that you're running or just use the CLI for your convenience um the output of this thing is the key shares it has a public key and encrypted shares corresponding to The Operators you chose you will need that for registering that to the network all right and then the main function register validator on our contract it accepts its its expects the public key the validator public which you have and the operator is these that you chose from the Explorer the share public keys and encrypted Keys that's the output from the CLI or SDK whatever you choose to use and the amount of the SSV that you want to fund your validator right um to pay the operators that you chose by the way the CLI also outputs the this whole payload for the transaction so you can use that for your convenience instead of building it by yourself I mean it's not just [Music] providing the public keys and encrypted keys for the validator um we really encourage you to go to our documentation you have this whole guide and with a lot more resources um to uh see how you run a validator but as well we have integration guides for this hackathon how to build a staking bonus Suite has a lot of information or us taking service and um you should go there before you start uh we really encourage you to go there it has a lot of information will make things much more easier to kick start so just go to docs.cv.network and um yeah that's uh that's basically it so if anybody have questions feel free to ask um you this one works can you just shout it out you basically mean I'm repeating you want to run your own operators and then choose your your validators to run on that operator right correct that I would use the closets or or anything on the same infrastructure use the same yeah so each operator you can see the clients that he uses right so if you want to to have different clients you can choose operators that operate with different clients and then you have some diversification it's up to you totally open anyone else I'll just add I think it's even encouraged uh to do that right for client diversity you can choose one operator runs on AWS and we show that those operators when they register verified operators uh provide their data one can run on AWS and run prism client and one can run on Azure or whatever Google cloud and and run something else and not just that you can run even one operator locally if you want to like uh to have more diversity right like let's say if Google Cloud right now for like uh shutdowns or have some outage we're probably going to see a lot of validators not working right or what Etc AWS or so so that creates not just for you for your security but also for the ethereum network to be more secure Viator that's going to run on SSV Network are much more uh resistant and make the network itself to be secure um yeah so Lido you want to answer that again all right Leto have a few operators right but they have they managed to eat they have the ethereum and then they're distributed between uh their operators so um each operator have and run it by itself x amount of validators it means it holds the private keys somewhere right in a one custodial Central way we just see the difference is that the validators running on operators but each operator hold a share of of the the Privacy right so if let's say one of the Lido operators will be hacked for some reason this way or another the attacker will have the private keys right I'm here if one of the operators hacked you have just a fraction of the keys and you can't do anything with that yes um sorry if you have what yes so um SSP is a Dao that's first of all um and operators anybody can be an operator but um we have a verification process that runs through the dial and operators that are um showing that you know they have a good back infrastructure a good reputation can get to be um verified but hey even if one operator from those four operators as we mentioned would be hacked or would be like uh um something wrong with it then that would probably vote for it to be unverified that's a and for you that's not going to do anything because if you're running a validator on that again one one operator can do anything for your validator actually the the threshold is three f plus one that's why we said four but in general like it depends on how many single points of first you want to assume how many failures you want to support so if you want to support one failure that's four operators right today when you run a vital client as a sales taker for example that's zero so three multiplied by zero one right I mean if you want to have two failures and it's seven and Etc um so yeah and then as a validator you can always change the operators right if you're not happy with some operator because you think it's malicious or because his performances are great then you can anytime change the operators um any further questions if something comes up you can reach out to us outside or return booth and thank you all for coming foreign foreign foreign all right hi everyone um so today I'm going to be giving you a lovely talk about why you should definitely move your project to optimism so just because everyone looks a little bit dead and sad right now I know it's raining outside but we can be alive so I just want to figure out how many of you are hacking this weekend that's a good number of you how many of you work full-time in crypto even more of you okay and then how many of you have struggled to get support on chains that you've deployed on wow all right lots of top-notch support all right so um there are so many opportunities on optimism to get what you need to like make sure that your project does the absolute best So today we're going to be going over just some of the amazing things we can do for you on optimism and uh help you get you know actually deployed there is a QR code at the end with all the information so I got you um right so um first things first is the vibes optimism's Vibes are unmatched anyone who's been in our Discord or like at any of our events you know the Vibes are just immaculate we have retro pgf so we retroactively fund public goods which is just think about that for a second so we've funded the solidity team the Viper team web3.js ethers.js uh we've given away a million dollars so far in retro PDF and we have another round coming out a little bit later this year maybe next year depending you know timelines are a bit sticky on these things um so yeah we fund public goods and uh you should definitely be supporting that so if you deploy your app on optimism the a portion of the fees that your users pay when using the app actually goes towards funding public goods so your dap doesn't even need to be a public good to help the ecosystem generally uh grow um we also strongly believe in collaboration I know a lot of chains will make you fight to the death with other projects on the chain for like resources and like oh you know you want to get an nft Quest like ah fight with the other chains um we're not like that at all we will we will help you we will support you you will don't have to fight anyone to get help um and yeah uh collaboration beats competition every single time um we also are on our path to decentralizing you know we've actually we've actually started this so we've launched our token house governance and our two token house a two-house governance system which is actually one of the largest experiments in government's uh you know in a hot minute um yeah so the token house is fantastic and a completely open process that anyone can go join uh and it is obviously a token-based governance system but we'll get more into that a little bit later so as a crypto project it can be really hard to get your project in front of users right so we have some amazing opportunities for your dap to get discovered so we run uh Twitter spaces quite regularly we have the Op radio which is a Twitter space that happens weekly we have demo days which happen bi-weekly uh where you can come and demo your dap to users it also helps if you want to go through the governance process to demo it so that the delegates have like a space to ask you questions um and like the delegates love to ask you questions so just uh be warned they will ask you questions and that happens once every two weeks and it's in our Discord and it's open for any project that has deployed to participate in whereas the Twitter spaces you know we do do a little bit more digging before we'll uh join you on Twitter we also have some incredible Discovery things so we have quests which are the most adorable little nfts you've ever seen in your life if you haven't checked out our Quest program definitely go look at it they are very cute and you can actually as a project apply to join our Quest program um we haven't started accepting new projects yet but we will start so definitely go and apply for that so you can get on that wait list um and they're really really cute like I cannot emphasize how cute they are I wish I put a photo up um we also have a token list obviously for our Gateway and our bridging that you can go get your token listed on as well as our website listing for all of the apps in our ecosystem which is a really nice way to get discovered so how many of you have a full-time QA tester or do QA testing at all yeah yeah I see you um so we have the most fantastic ambassador program group who are just like have such an insane energy so if you wanted to get your project to have like a real QA testing process you can come and offer some small incentives to our ambassadors and they will do a full bug hunt like clicking every button of your dab so and they've done this before for other projects and it's been amazing so they give you like a full list of uh bugs that they found as well as the steps to reproduce those bugs so it's like proper QA as well as just general features that they think you're missing because obviously they interact with lots of dabs so they'll be like oh well you're a wallet why don't you have this feature which can be really really helpful if especially if you're in the earlier stages of being a project to just have someone go through your dab and click on everything and it's not just someone there's like 500 of them so it's a proper QA test and a little bit of a stress test if you haven't actually launched to a lot of people yet we also have Grassroots Community content so if you want some memes made up out your project you want a little bit of hype you want some articles maybe some tutorials on how to do it you can definitely come to our community and have that done for example with the quests which I was talking about earlier a whole bunch of our community members just started making tutorials about how to use these apps because you kind of needed to know how to use them to do the quiz so you can get like genuine Grassroots content made about your project which you know you can't underestimate the power of a little bit of a Twitter barrage of your project and then of course we support you we will support you with developer questions if you're struggling to deploy or you have like some unrelated question about like what to do with my solidity bug we have a very active community of developers as well as general users who will just help you um which is really really nice we also have user support so if your users are struggling to use your app our community loves to just dig into that and help out we also of course have project support so you know this is everything from like um figuring out how to deploy infrastructure connections like getting connected to other projects that you would work well with like synergetically I can't believe I just used that word but yeah so we have we have project support and like you will be supported you know um we also have incredible infrastructure we are the most forked L2 with I think Three Forks right now might be four um and tons of orders from like the top auditing companies in the crypto space so you know it's like we've done our  it's secure we also to have Bedrock coming out soon which is the next version of the optimistic infrastructure which is amazing I'm not going to talk too much about that because we actually have a bunch of talks happening at Devcon about it so if you're not there they will be online so you can watch them live we also have been championing the EAP 4844 process which is going to push L2 fees down to like the theoretical lower limits which is super exciting because obviously you know fees are expensive you don't need them to be uh as expensive as they are we also have the prettiest docs you've ever seen I'm definitely biased because they're my baby but they're on the prettiest docs like go click around you'll see what I mean um and they're great for developers they're also great for users they also have like if you want to deploy if you want to get a proposal through our governance process all the information you'll need is there how to write a proposal where to post your proposal how to get feedback all that kind of stuff is in the docs um it's really really good we also have a lot of content for like absolute beginners you know if you've never written a smart contract before we also have tutorials for you if you've written lots of smart contracts and need like very sophisticated you know like how to integrate with the bridge smart contracts directly like there's also tutorials for you so we really cover everyone and just because I really do love them these are our docs look how beautiful they are guys look at that look at that they cover everything this quick start how it works dark security we're very honest and open with our security settings like how like our security models uh governance contributing it's amazing it's all there go check it out um then finally of course well it's not finally but of course you know everyone wants a little Opie in their bag so uh you can get op through two methods one is through our governance grants which I've been speaking about which is completely open and transparent process uh so you can um go and apply it's completely like open and again you can go on our docs for the process of how to apply templates all that kind of stuff uh it's good for small to medium-sized grants you can get a larger Grant but normally you're really going to have to like justify it um very good if you've got like Milestone based grants and you or you want to iterate on your ground again in the docs is the whole process that you can go check out we also have a partnership Grant where you can get op but that's a private process so you can apply but it's not going to be like publicly listed you're not going to be able to look at previous uh proposals for inspiration or anything like that um yeah and this is how you submit again the docs guys I really do love them so this is how you submit a proposal like all the steps are there the templates the links everything you need to actually um do the thing so actually last but not least is getting connected so as I said earlier you know we really really really believe that collaboration beats competition every single time and as such like if you want to get connected to a centralized exchange or an infrastructure provider or a wallet or an on-ramp or an audit firm we like very much if we have a connection with them and they want to talk to you we will definitely try and facilitate that relationship because we think it's really important you know like um crypto and blockchain is built on collaboration and that's where the real Innovation happens you know when you're actually able to like innovate with people without like weird competition Vibes going on so we really really try and encourage that and like we've done a lot to make it easy for you uh and then of course what is a talk without a little bit of alpha so we have actually a very exclusive uh partnership server that will be coming out in the coming months teasing Supply uh that you definitely want to get on the waitlist to get into where we will make connecting between projects even easier and much more like automatic and facilitated so you should definitely go check that out because that is going to be amazing um I have also left a lot of time for questions because uh I know I covered a lot very quickly this is the QR code you're going to want to scan to get all this information um so definitely hit that up but yeah so what's up guys who's building who wants help love you thank you [Applause] no one wants to apply for free money wow impressive you all must be doing really well in the spare Market yeah yeah you totally can apply for a grant so you don't need to have like you can apply for a grant a governance Grant before your Project's even finished so you know you can apply for a grant you can use the ground for developer costs obviously because like you guys need to eat um and also for things like um you know like user grants and like if you want to do like an airdrop to your users or like a retroactive reward to your users for having used your application you can totally totally do that you just obviously need to lay it out in your Grant application about like what you're going to use it for make it very clear so that the delegates understand what you're doing but you can totally do that 100 also shout out thanks for building such Cool Tools that is a great question so the question was how who how do we determine who gets the retroactive public goods funding right so the way this works right now is anyone in the community can nominate a project right so you could nominate a for-profit project that's not necessarily a public good or they would nominate themselves that's normally what happens um and then you know everyone else is nominating public goods then what we do is we select a subgroup of the community so it's a smaller group normally less than like 50 people last round I think we use like 30 people and then what they do is they sit and they go through all of those applications uh we use a quadratic formula for voting so they will quadratically vote on those projects and then list it out you know obviously from the highest to the lowest and then we distribute the funds proportionally to how many points you got in the voting from the sub community so in the next round we'll probably do something quite similar where it's actually like the community that is voting on uh the projects and we do that because obviously you know we're not necessarily impartial to what is and isn't a public good so we want to leave it in the hands of the community uh and make sure it's like very values aligned people yeah just community members they don't have to be token holders at all yeah yeah we do yeah yeah no shout out vitalik you wrote a great article about our first retro PDF round we also wrote an article but obviously it wasn't as popular as his so you'll find his first thanks yeah oh thank you yeah no optimism really is like it's a very wholesome Community like especially for first-time Founders or first-time projects like there's a lot of support especially for the earlier stage stuff um and the community is like very supportive you know if they find a bug they'll tell you about it they're not gonna like scream at you um which is really nice and then also because it's an L2 like the fees are quite cheap compared to like deploying on ethereum so it's much cheaper than for your users to like claim the nft use it that kind of stuff yeah we also have a decent amount of Dow tooling so if you did want to launch like a dow with your nfts um it's quite easy to do that yeah I got you girl anyone else I don't bite I promise in case I won't bite you um yeah make sure you've uh scanned the QR code if you want to get all this information later otherwise go check out our docs literally all of the information I've talked about is on our docs um yeah Deploy on optimism it's good vibes and your projects then funding public goods which like what a better Flex you know yeah you know you don't have to jump you did the jumping earlier you're done with the jumping now you got socks though so you won really you know like yeah okay hold on let me just go back a few slides okay so if you see at the top there we have a security page on our docs we are actually very open and honest about our security um setup so right now we have a multi-sig that had can like Fast upgrade the entire network so it's like completely centralized really um but yeah we're definitely we have um so once the so the kind of the timeline of like things that are coming is first we're rolling out Bedrock which is like the like next major upgrade to the optimism Network um which is going to like reduce fees a little bit um and really just like make the infrastructure much more robust and hardened and much more like you know we're not going to need to upgrade it for a while because it's going to be very like stable um so once that's out uh it's in Alpha right now once that's out and like on Main it and like actually running and we've got like good data that it's like very stable then the next step is going to be rolling out Canon which is our fraud proof uh mechanism sorry fault proof mechanism um and the fault we're obviously going to start that on like a very whitelist you know no slashing mechanism as we're like testing and figuring it out uh once we show that you know the full the fraud proof fold Proof full proof itself is secure and it's not like accidentally saying things are wrong or right when they're not um then we will roll it out publicly so then anyone can like call uh you know uh say like uh I think there's fraud let me like prove it uh but that will first roll that out with no slashing so like they can call it without uh any repercussions for the sequencer then once that's stable and we know that's working right then we'll introduce slashing and then we'll start decentralizing the sequences so maybe doing like we haven't 100 chosen how we're going to decentralize the sequence unnecessarily but I think the way we're thinking about this right now is that we're going to do like some kind of sequence of auction where the rights to be the sequencer can be auctioned off and then obviously you know in order to do that we have to have 100 functional fault proofs with slashing enabled so in order for it to be like decentralized um yeah you kind of do need the sequencer to be decentralized because for example like if the entire optimism team died tomorrow the sequencer would go offline and that would not be great um I mean it would run for a while but um yeah so definitely that's a part of being like fully decentralized we definitely need the sequence of to be decentralized but there's this concept that we've been toying with which is like minimum viable decentralization so the minimum viable decentralization for optimism would just be fault proofs because once you can prove fault and have a slashing then like you don't really need like the sequence of being decentralized is like the final step rather than like a necessary step yeah great question though sorry I'm Veronica yes yes I'm Veronica obvious if you see me on Twitter we good yeah let's build it let's go all right well I wish luck to all the hackers uh obviously optimism lots of cool prizes if you're hacking on optimism uh so definitely check that out um yeah thanks all for coming love to see you [Applause] okay hi everyone great is it okay if I put it in the holder no okay no worries hi everyone uh welcome to my workshop it's called the future of identity is self-sovereign build a Dap with polygon ID first of all I want to say a big shout out to the polygon ID team a bunch of the ID team is here can you guys stand up we've got people back there woo they've built a really really cool product and I'm excited that you're all going to get to start developing daps this weekend I think these are going to be some of the first steps on polygon ID ever so you're you're really early which is exciting but first of all GM GM I'm Steph I'm a developer relations engineer at polygon along with my lovely co-worker Rahat in the front row another round of applause for a hot because why not Vibes are good today um I'm also oceans 404 on Twitter uh but right here in this slide I gave you one two three four five pieces of my identity so my name my job title my company and also my Twitter and my profile picture so you know five things about me from this but how do we know that those things are true we don't really right you can kind of trust me but when I think about identity I think about things that I recognize immediately uh like SpongeBob and I know this is SpongeBob and maybe these police come up to him and ask him who are you and he says I'm SpongeBob and maybe they look at him like are you really how do we know that we've never seen the show but if you have done kernel or read a lot of things on bitcoin there's this proverb that says don't trust verify so you can see in this image SpongeBob is wearing a name tag and you can see that it's written maybe in handwriting so we think that he has self-identified as SpongeBob but we still don't know for sure if that's his real name or if that's really who he is or if he's just saying that's true so if SpongeBob had a driver's license that would be better proof that he is actually who he says he is this driver's license is issued by the city of Bikini Bottom uh it has his address it has his sex his hair color his eye color his date of birth uh but if the police came up to SpongeBob in bikini bottom and said what's your name why should he have to show his full driver's license if they only need to know one part of it why do we need to show all of this other data if we only need to prove one piece at a time so kind of ruminate on that as we get into the rest of the presentation this isn't just a problem for SpongeBob right we all have digital authentication that we have to do to have access to all kinds of different apps including big tech apps social media apps like Facebook you have to sign up and give your first name your last name a lot of personal data so like your mobile telephone number your email uh you set your birthday your sex just a lot of information and no one really knows why they need that they say it's to improve the algorithm and things like that but what are you really getting back for all of that that you're giving so getting into identity Solutions there's three different types of identity Solutions today the first one is centralized identity uh like I said if you're logging into Facebook you use your email or phone number and a password a centralized identity system is a single purpose identity so you would need to create a new account every time you use a new app so you're kind of siled right because that identity isn't portable as you go from app to app you can't use this Facebook login to log into let's say tick tock at least I don't think you can I really doubt those systems talk or that there's Synergy there because of competitiveness but every app is storing this information for you separately which could lead to a lot more security risk right like if one of these gets hacked they have your data if another one is hacked they have your data but it's also a huge headache for managing all of your passwords and accounts across apps I know I have a password manager and even that is a pain because there's always like one password that isn't in there and then I don't know what my password is because it's a centralized identity system The Next Step Up is Federated identity who has a Federated identity um login for work stuff I know I do and everyone at polygon probably uses I think it's OCTA or okta I'm not sure but it's a way to sign into a bunch of different apps that are all within the same Federation so at least then you can use one single account and reuse your login across all of those different apps that makes this type of identity a little bit more portable but unfortunately like it doesn't work for every single app out there and another drawback is if you log in with let's say Google one big tech company has access to all of your data across all the different apps you're logging into so it knows what you're looking at it knows what you're accessing and I remember I used to use Facebook login a lot and one time I decided to delete my Facebook and then I realized I was locked out of Spotify which I didn't even realize was connected so I immediately got my Facebook back but I was just like oh no so enter a decentralized self-sovereign identity this is a multi-purpose and portable type of identity where you can prove pieces of your identity to use on any app this is really powerful because you as a user retain the control over your personal data and also your digital identity and you also eliminate the middleman that's holding on to your identity in all of these different systems so you don't have to give up your data to prove access rights to the things you need to log into so these Concepts come from this really Incredible Book that the polygon ID team recommended to me it's called self-sovereign identity and the two main takeaways I had from this book were that SSI or self-sovereign identity empowers us to receive digitally signed credentials store them in private wallets and securely prove our online identities and we as individuals or even organizations like maybe Dao's or workplaces have that sole ownership over our digital digital identities and we can decide how our personal data is shared and stored or if we don't want it stored or shared at all so going back to my SpongeBob references um a big idea in SSI is this trust triangle so we have an issuer a holder and a verifier so in the SpongeBob situation the issuer is Mrs Puff who has a boating school and gives out a driver's license the holder is SpongeBob who is getting that license and the verifier is a police officer and so this kind of explains the issuance of a verified credential and also its usage so the verified credential in this case is the driver's license and Mrs Puff issues it to SpongeBob and in this new self-sovereign identity system instead of the police officer having to see the verified credentials they can just accept a proof and they can do that because they trust the issuer and they trust that the issuer has given the holder a proof that is authentic so the issuer has to be trustworthy in doing the right things to make sure that whatever the verified credentials that they're giving out to a holder are actually legit so we already see that happening with governments and also in cases with like covid passports or vaccine passports so someone is issuing you a verified credential maybe it's a nurse giving you a shot and they're saying I gave Rahat this second covid vaccine and so if there was a way to have a proof instead of having to show that actual covid vaccine card that would be all awesome and we're getting into that enter polygon ID so polygon ID is a scalable blockchain ID with ZK based privacy we have a really nice architecture diagram on the right and then the left has different tenants and things about it so it offers Universal identity you get to prove your access rights rather than giving up your data or identity and it also enables Advanced on-chain verification through ZK snarks so these are four of the guiding principles and I think these come from that self-sovereign Identity book and just other extremely smart people on the team but polygon identity polygon ID is decentralized it's private by default it uses ZK for uh trust and reputation and it's also open and permissionless so going back to the SpongeBob thing we're going to switch that to what this looks like in polygon ID so instead of Mrs Puff or like someone from the government creating claims you use an issuer to create a claim and that issuer can give the claim as a verified credential to a holder me within my polygon ID Wallet app and then I can generate a cryptographic proof that is verified on chain with a smart contract to check against my signature to make sure that that is actually my proof so if we go back to kind of some of the problems that we've seen in social media apps and other different things on the left I logged into Instagram a few weeks ago and it said add your birthday it said to continue using Instagram you have to add your birthday and I was wondering why is that so I looked at the why and it's because you need to be 13 years old so they need to know my birthday to make sure that I'm 13 years old but I'm going to show you how we can use polygon ID to prove that I'm over the age of 13 and I can use Instagram without actually having to like swipe around and put in my real birthday so this all starts with issuer so I'm gonna oops click into issuer so this is uh the UI that is used to create these claims that you can give out to holders I'm going to sign up sign up it's actually more of a sign in and I have the polygon ID Wallet app on my phone I'll show you more about that in just a second but I'm just going to log in with this QR code and I see something that just says connect my wallet so I'm connecting my wallet authenticating and now I'm logged in and I can create a claim so I'm going to create a claim um and there's some different default schemas that are drop downs I'm going to do a kych credential because remember I want to prove that I'm older than 13 so I can use the app I'm not going to tell you all my real birthday but I'll say 1990 8 24 so August 24th 1990 that make that would make me way older than 13. and I'll submit that so this has created um a claim that I can give myself so since you can't really see it on my phone I'm going to open up a notion page uh that shows this or actually I'll start with the slides so I'm I'm interacting with this issuer within my polygon ID Wallet app so these are just some screenshots from the app again you can prove your access rights without revealing your identity um and what I just did in that issuer UI was I created the claim so now I have to give this claim to myself so that um I know that that was my fake birthday it's not my real birthday but you get it so to do that I'll show you a video of how that looks okay so we just created a claim which is this screenshot next up we have to generate the claim so when you accept the claim by scanning that thing the the QR code it goes through this flow where it adds the claim to your polygon ID wallet so once that claim is added you can see it in your data so you can see now I have this kyc age credential within my polygon wallet so when I screen recorded this earlier I said my birthday was January 1st 1990 but now this exists in my wallet and I can check anything against this so the demo app that we worked on was a ZK erc20 airdrop so what we want to do is airdrop tokens to anyone who's over the age of I can't remember what the age was but let's just say it's 13. I think it was a specific birthday but in order to do that we need to check against that claim that we just created that said that my birthday was the first in 1990. so what you would do is you would scan that proof request or you would scan that QR code it would generate a proof against the information you already had stored so it's generating the proof a cryptographic proof would appear and then you would click generate proof it uses biometric ID or a password and it pops open your metamask and allows you to claim that erc20 token claim based on the fact that you were over the right age so it's generating the proof and then if this is successful we'll see that the airdrop gets added to my wallet so you can see that in the screenshot it confirmed that contract interaction and now I have five ERC zkp which is just the token drop that we created inside of that wallet so that's kind of a high level overview of how this works but I'm also going to show you some of the code for the verifier and all of this is in different links that you'll be able to check out so you can look at how the smart contract works and also how the front end works okay so this is the tutorial example Implement a ZK uh erc20 airdrop in 20 minutes so it really does only take 20 minutes if you follow these instructions and just deploy your own smart contact and update like three different variables uh but what you would do is download that polygon ID wallet setup either from the Apple store or the Google Play Store and then you would get it right into the code so if you were just cloning this repo all you would have to do is install the dependencies and then compile the code that already exists there and then run the deploy script this would result in one smart contract and what you would have to do after that were all of the magic with the proofs and everything happens is that you have to run something called scripts set request and this is where we're actually submitting all of the things that make the proof work so let me get into that So within this set request we have a validator address this is the already deployed smart contract that is doing the validation and this is something you can reuse for any of your polygon ID examples all of the specific stuff happens below so there's an age query and the part where we're actually checking against the age is on line 14 with the value so we're checking that your date of birth is happened before January or January 1st 2001 and so I already proved that with my claim that I was issued so this should work for me um the other thing is that we also have a ERC verifier address so this is the address of the erc20 token uh that you can deploy using those instructions above and so the ZK proof request checks against that validator and also the age query to make sure that you're actually over the age that you said you were so back in the readme we have two different contracts uh within contracts so this is the erc20 verifier that I was just talking about and this extends an erc20 contract as well as a zkp verifier contract that exists in this repo and there's a couple interesting things going on there's a before proof submit and after proof submit hook as well as a before token transfer hook so this is where all of the custom logic is happening to make the actual airdrop happen so before you submit that ZK proof it's checking that the challenge input of the proof is equal to the sender so you need to make sure that the user who's saying I'm over the age of 13 is actually the person who is submitting the transaction and then after the proof submit there's one more required statement and this is just making sure that you don't claim the airdrop multiple times so that's just a little extra logic and then this is where the airdrop is executed so this is kind of just like classic airdropping a token stuff um but before these tokens are actually transferred there's one more check and it's just making sure that you as the person who provided the proof are allowed to receive the tokens and so once you have all of these smart contracts deployed all of these meaning just to you the last thing that you need to do is design a proof request so there's a query based requests language or not language but structure so you can read about that more on the polygon ID documentation and in the GitHub but I'll show you the one that I created so mine is in QR proof so this is just a big Json blob and I'm going to pass this to the QR code it's going to live in the QR code so when someone scans the link it understands that this is the contract and this is what we're querying so on line 21 and 22 you can see what we're querying we're querying the birthday and on line 22 we have LT Which is less than and then 2001 0101 so we're checking that the birthday that the proof is submitting is less than January or January 1st I can't say January January 1st 2001 and mine definitely is so this should be successful and like I said this needs to live in a QR code so on our front end we have to have some type of QR code that you can scan that has this data so that it kicks off the whole smart contract process I created a little code sandbox for you all so that when you deploy these on your own all you have to do in the code sandbox once your contracts are deployed is update this deployed contract address and then you should be able to test with this front end to look at the QR code and see if you can actually claim the ZK airdrop but that Big Blob of Json that we saw before lives in the QR code request so it's just this big it's the same exact thing it has the deployed contact address and that little check down here birthday less than January 20 or 2001. and that just lives in a little QR code component so it's just passing the value of that to here so when we scan this code from the polygon ID app since I already have a claim it should kick off an airdrop to me so I see something come up that says proof request in my app so I've scanned and I'm just going to sip or submit continue for the proof request it's generating the proof on my phone and then once it's done generating the proof I'll click one more button and then it'll kick off the transfer of that airdrop to my account and you can see where that happened before if you look at this poly scan link I think I'm the only person who's claimed on this contract yeah but five of that ZK erc20 token were airdropped to me about six hours ago so I should get another airdrop pretty soon um but yeah that's how you would do this with an airdrop that was the code okay did I lose everybody I know that's a lot you can you can look at the code um on my GitHub I'll give you the links towards the end but I just wanted to talk about some of the prizes that polygon is doing for the hackathon so we have twenty thousand dollars in prizes and four thousand of that is for the best use of polygon ID so you could create an app like the one I just showed you or something totally different to help people prove parts of their identity without actually giving up their data we have three other prizes we have four thousand for the best public goods and refi projects hopefully they're going to be like local projects that help the latim ecosystem we also have four thousand dollars for the best social adaps on lens protocol and four thousand for the best user experience and user onboarding to whatever Dap You built and last but not least we have a four thousand dollar prize pool for everyone who deploys any type of contract on polygon we ask that you have two transactions to that smart contract so that we can see you've actually used it and then these are just some of the benefits of develop developing on polygon I'm sure a lot of you know speed cost scalability flexibility all great it's a great developer experience and we're also asking that if you do submit for our pool prize by deploying something on polygon that you tweet your smart contract at us and tell us what you're building and why you're excited about it we love hearing developer stories it really fuels our entire team to keep going just because we want to see what you're building and we want to amplify that work and maybe give you a grant or put you through our accelerator eventually okay so these are all of the different resources that I covered um in this talk uh you can take a picture of this or I'll have a screenshot at the very end or a QR code at the very end so that you can get all of these um when you're developing during the hackathon but we'll also be at the booth and we have lots of different members of the polygon ID core team here that can also help you develop their awesome super friendly and some of the most talented Engineers I've gotten to work with so I highly recommend stopping by but thank you so much for listening to all of the things that I just said um all of the slides and the GitHub repo and everything is on this QR code so feel free to scan it and you'll have all of the links to get started building really excited to see what you build this weekend and wag me we're all gonna make it thank you [Applause] foreign thank you um I am Miguel and this is flywheel and we are here to talk to you about wallcoin and wallaby and basically how to make any app fully civil assistant within a few minutes and without keeping everyone's privacy so before that I want to talk a little bit about why we're doing this and the reason why we believe that this is a really big deal is because I feel like everyone here can agree crypto is really really awesome but at the same time it has a bunch of problems which is mostly with the its value being hoarded a little bit we all know about being early and the thing is especially for the things like latam that are now joining more and more in crypto and where it's clear that it can solve really big problems most of the value for things like ethereum or Bitcoin has already been captured by the people that were there at first and that is not great and that can uh hinder a little bit on the Innovation that we can all achieve with this and so at work when we had this question like what if Bitcoin had started instead of by however it got started by just giving one Bitcoin to every human in the world and then seeing how the network reflects effects played out how how in a currency that was fully globally available was still being modern and online and cryptocurrency played out and so we wanted to find this out obviously we we cannot buy a Bitcoin for every human we I wish but instead we said okay let's make um an erc20 token and let's do the same experiment with it let's make a token that every person gets for free and then we'll see how that affects the supply let's see how that enables new people to interact with all of these ecosystems that we're building and the big question there obviously was if we're going to be giving this token that is worth something and we're going to be giving up for free a lot of people are going to be trying to get it for free multiple times and it's like still from everyone really and so this question we went back and forth uh we learned about this thing called civil attacks which is um pretty modern concept nowadays because all of these nft means and airdrops are suffering from it it basically means that some of your users are not really unique users they get like someone running a bunch of accounts and this is really what we want to avoid we want to make our protocol and every other protocol there while we're at it civil assistance and so we went back and forth into different solutions that we could use for this maybe we could ask for an email or a phone which is better than nothing but kind of similar to what Bitcoin is doing but it's still not enough kyc can work but there's some areas of the world that don't have either documents or not don't have a database to check them against and also from a privacy standpoint it's really bad because we we would have to get everyone's ideas and we really don't want that there's always other approaches like web of trust where you are saying I trust these people around me and then that progates that has the issue of you need an initial set of people to trust and then over time if you know a lot of people it's easier and easier to fake another human uh we looked into Biometrics like using your fingerprint and using your DNA which both work uh except for the fingerprint doesn't really have enough information for 8 billion humans um there are going to be some people that have similar enough fingerprints so that we cannot tell them apart and then it has the opposite problem it is really really unique but um it's super expensive and super slow to measure and also very invasive and so we wanted a solution that was both private uh inclusive meaning that we could onboard every human in the world or 8 billion humans into the system and that again was scalable and didn't leave anyone behind and so we ended up sitting with irises which are like the perfect middle point between fingerprints and DNA they're still unique they're pretty hard to obtains and even then you can most of it and detect it and at the same time they're quick they're really quick to scan measure and use and so this is great using the system we have a system where we were taking no images we we did we do take an image of the iris but then we delete it and just extract information from there no name no contact info okay with so no phone number really it's there's no link between these really and anything in the real world but for us it felt like it wasn't enough we wanted something more we wanted something that would allow us to really not just be private but be fully Anonymous and so we started looking into zero Edge proofs and how aside from saying this is a human that owns a public key that has been certified by an orb as human we could also say this is like one of those humans and we have no idea there's no way to even link them to the hash of their scan and We've Ended up with this system which allowed us to prove cryptographically on chain I am a real person and I have never done something other started something was mostly claimed worldcoin but as more developers came to us and said we want to reuse this technology that you guys have made on our own apps we started thinking maybe we can expand this so that this can be added to everyone to governance nfts airdrops even web to actions like during the Discord Channel which would help a lot with Spam and so we created this thing called quality which is a protocol that lets you fully anonymously verify that someone is a real human being and that has never done an action before like claiming Walco in and so it's a privacy first decentralized entity solution it's not it's not even identity in the sense that it is fully Anonymous pair up so if I use my URL ID on two different apps these two different apps will get completely different ideas of who I am which doesn't makes it so that you cannot even track people along us it enables anonymously Anonymous proof of personhood which can pretty much search for every use case that similar systems would uh use and it's also an open protocol that runs on the blockchain on publicly verified smart contracts and where you get to keep your own keys and so for example if you were just making an airtop to integrate this you just need to add a widget which will talk a little bit more about and that's it you're set it's it's really that easy so now flywheel is going to talk a little bit about how it works I'll switch computers over there all right so here's roughly how the world ID protocol works so you go to an orb physically one of one of these guys and uh the orb will verify you're a unique person uh and you get your world ID so in in in the background what actually is happening is your world coin app is going to generate a unique random identity commitment that's going to live in your phone and it's going to show the public part to the orb the orb is going to do the verification that you're a unique person and then add that identity to the public list on chain of verified identities the the cool thing about like this zero knowledge proofs is that there's literally no link between your identity and your wallet or your identity and anytime that you use it every time that you use it the world going app will generate a zero knowledge proof that you're someone in that set of verified persons but without revealing Who You Are and the protocol is very complex to support for this uh Anonymous proof of personhood but we've abstracted all of this complexity so you can integrate quite easily so um that the way we work is uh you you and install the widget in your app the app the widget will connect to the worldcoin app receive that zero knowledge proof and then you can verify it on our smart contract or on our API after you verify it you you um you know for a fact that that person has been verified by an orb and it's an actual person uh and then I'm gonna show you how to integrate it using the API which is that the fastest route to integrate um however if you want to do something Unchained we definitely recommend doing uh on the smart contracts I will also show that in a little bit so let's say I have this example of I wanna I wanna issue a pull-up but I want to make sure that the pump can only be claimed once by a single person so I have this very simple form where um you know I can click claim Pro app and I and I receive the pop-up in my wallet um this of course is very easy to farm and spam and and steal all the pop-ups so if we can simply add uh World ID to prevent that uh and let me get my app here so to to do this we simply need to uh we simply need to uh the world going widget so you you can easily install it by just running yarn at worldcoin ID this will install the the widget on your project you can now just simply load the widget if you're using nexjs this is an important part you need to do this Dynamic import as I'm doing because the widget relies on um window being set so if you don't do this you'll get an error and then just remember to do the dynamic import no thank you Copilot all right there we go so I have the widget imported we can mount we can then Mount the widget you're you're gonna need to provide a couple of things to the widget so one is the action ID the action ID basically uh defines the scope of the uniqueness for for your own application so you can just go to developer.worldcoin.org and you can create any number of action IDs there it'll ask you if you want to create something on production or staging and it'll ask you if you want to run it on chain or just with the API um and then you'll also need something called a signal so the signal is an additional security measure that you can add and it depends on what your application is what makes sense to do so for instance if you're doing an airdrop and you don't set a signal what I can do is man in the middle attack that claiming process where you know I get the serial knowledge proof from the user and then I change my to my wallet address to receive the airdrop that would have belong to the other person if you add the signal the signal becomes part of the proof so if I tamper with it then the proof will become invalid so depending on your use case it might make sense to use different types of signals but then something like this in this case uh you know the signal can be the wallet address or it can be something else and then we're also going to need the action ID so let's just do all right then we're gonna need to receive the proof here just comes and look for now all right let's see let's see if this works oh I need to run the server all right so now we have the widget mounted super easy to do uh just make sure to set the the right params once the verification process happens then I'll receive uh the proof in this in this method and then here here comes the the probably the most important part what you need to do is verify that proof the fact that you got the proof from the widget is uh no safety measure at all it's obviously on the front end very easy to spoof very easy to change so what you want to do is grab that proof and verify it either on chain or with our API but don't just don't just assume that because you got the success um this is the success method that this is going to work uh and then to to verify the proof is quite easy so um you if you're doing the API You're Gonna Wanna Do this from your back end uh if you again like if you do it from the front end it's quite easy to spoof so um make sure make sure to call it from the back end and you're you're simply going to want to do something like this where I call the API you don't have to remember the the end point of course you can it's very well um uh documented so don't worry about it uh and then the the API either the API or the smart contract is going to take five params to verify the proof so first it's it's going to be the action ID uh the SEC the second thing so let me let's just send the action ID of course if you don't send the exact same params this is not gonna work so be sure to send the the exact same params uh second of all the signal both the both of those params are set by you and sent to the to the widget so make sure to use the same ones let's see what signal that we use here as flywheel.eth uh and then the other three params are what comes from the response on the widget so if you see this like verification response object it it actually has these three parameters Merkle root nullifier hash and proof and those are the additional uh three params that you need to send out I'm just gonna do it like this and then if if the response is successful uh 200 code you know the proof is valid if the same person tries to verify again uh they'll they'll then you'll get an error or of course if the proof is invalid and just to add a little bit more to that so the three params that we're sending is uh they they have different purposes the Merkel route is used uh just to prove that you're part of the uh Merkel tree where the identities are stored uh the proof is just as your knowledge proof um the interesting one to take a look at is the nullifier hash the nullify hash is basically the user ID it's going to be unique for you for every person and every application so this is what ensures uniqueness if if the same person tries to verify for the same action ID again you'll receive the same nullifier hash and you know that's the same person well what's cool is this will always be different for every application so if I use my role ID with this poapp app then my nullifier hash will be different than if I use it to verify my lens profile and now Miguel is going to show you how to integrate on the smart contract side there we go and there it goes in the right direction the first time okay so um first of all um all of the stuff that we're saying here right now it's probably way more better explained in the documentation so any questions or any doubts or even like the endpoint ID or all of that is going to be there but yeah let's look at some code um start AC let's say that we are like we've seen we've seen how to verify it on the API and the API behind the scenes what it's doing is calling on chain anyways every it's always very violent saying the AP is just a convenience measure for people that are not super familiar with web3 or people that are making applications like the pop-up one we're really adding an unseen component doesn't really make sense but for most of the implementations of this you'd probably want to use a Smart contract and so let me make the font size a little higher hopefully that's big enough this is an example contract that what it's going to do is he has going to airdrop some tokens and the longest Care by all of the measure the all of the text here most of this is most it's just comments this is one of our example star kits and so they really the part that you need to look into is this claim function which receives um four parameters first is the address that is going to receive the proof we do it this way and stuff he has default into msg.sender in order to make it so that anyone can submit the transaction and so you can pay for gas for your users which is really nice and then the other three arguments are the ones that you got from the widget like Paolo uh demoed and so in here we're going to want to do three things to verify it and then you can do whatever you want to finish your logic first of all we're going to check if the nullifier has that we are getting here is already on our list of people that have claimed this so you'll see up here I have a mapping of Apple of the UN which is only for us to a Boolean and this is going to be false by default so we'll just get right through it like Paolo mentioned this is a unique ID for this action on this person meaning that if they do it again you'll see later down here we're just going to mark it as true and this is likely the dumbest solution for making so that they cannot reuse you can also do some interesting things with this but the most common use cases yes taking if it is included and after verifying making it included and so afterwards what we're going to do is call the wallet contract and you're saying verify proof and we're passing the route that we received group ID which is always one then um the signal of the proof and for the API the signal doesn't really matter usually it's on the smart contract side what it really really does matter and an example of what this would matter is let's say that I submit this proof I'm not using the signal someone can just front run my transaction in the mempool change the receiver and get all the tokens by themselves and then I cannot verify again because I already went through by adding any number of parameters here on the signal what I can ensure is if this parameter doesn't match the one that the user specify when they generate the proof then the verification is going to fail and then with someone where to like tamper with our transaction it's not going to get verified and so yeah you can add any number of parameters in here it's kind of like a way to of checking that the parameters that the contract received are the ones that the user intended and you usually just want to add any parameters that your function is going to received in here in this case we only have one which is the address and then every other thing that we received the action ID is important uh we are getting that in the construction here and you're just going to get the action ID like the string that Polo showed is like WID underscore the bunch of letters and numbers what we're doing here is encoding and hashing it this is required by the smart contract solution and if you're using one of our story kits it will be handled automatically for you and then finally this call if the proof doesn't uh get verified for any reason be it the user is not registered as a human or the signal has been changed or they haven't done this again then this is going to fail if that doesn't happen then we're just going to mark it as true so that the next time that the same user calls this function this is going to revert right here and then we will proceed to do whatever we actually want to do in this case send them some tokens um a more advanced version of this would be we have this integration with lens protocol where users can mark their accounts as humans and the implementation of that follows the kind of the same pattern with one difference as you can see the first thing that we're doing is we're getting the profile ID which instead of the address is the parameter we care about here which profile we're verifying and then the three parameters we're going to verify the proof passing the profile ID because that's the as the signal because that's the parameter that we care about and then since this is really a unique identifier it has only for my app what I can say is if this user has already verified a profile we can use that to unverify the profile before verifying a new one to make sure that if I up and verify the wrong profile of or any point want to change the profile that I have verified I still have that option without allowing me to verify multiple ones so this is an example use case or how you can use the nullifier hash some sort of anonymous action ID so in this case if the instead of setting the nullifier has to true what I'm doing is I'm sending it to the profile ID and if that is different from zero that is the default what I'm going to do before is just unverify the other profile AV which in this case is just emit in an event because lens takes care of accounting for this in this part and finally let's look at how um we would hook all of this up on the front end so I have the front end for this here it's a little bit of a it has a bunch of models and stuff but the one that you care about is the verify model which is where we have the profile that we want to verify already and the only thing that we're going to do is run the wallet that we get our signal is going to be the profile ID and we're doing some sanitizing here to encode it as a unit which you sometimes have to do when you're not working with strings and then the actual ID and everything is going to be just fine once we uh once this is successful we are just going to call set proof and then send it to another component um in this case we're going to use what the what me react library to write it to a contract so we're calling the verify function on the contrast that I just saw showed we're only doing this though if we have a profile and we have a proof so until we actually go through with the verification this is not going to trigger and then once it does we are sending all of the same arguments that we saw here before and then calling the method that should call the contract if it doesn't revert it will go through everyone is happy and we are verified um so yeah just to recap a little bit the system is quite complex but we've made it super super easy to use you can just drop in a few lines of JavaScript integrate a wallet connect style JavaScript widget that acts in a similar way of a captcha and just allows the user to scan a QR code get us error noise proof that you can verify even either through an API or most commonly on scene and get to know that that user has never done whatever action your app cares about once um on the upside I didn't have time to hook it up with my to show my phone screen here I thought enough shifting with the computers was enough uh this is what it pops up on the wallcoin app where it will just show the name of the app and say the app wants to verify that you haven't done this specific thing before and it will tell you what that specific thing is and then when you click verify the it's weren't sends approved to the website again the code is really really simple verifying the proof with the API text probably a minute doing it on the smart contract takes a little bit more but we've been working really hard to provide lots of examples OnStar kits and pretty much anything that you would need to have fully commented code that you can just take the example that I should start with the airdrop change the thing that is in the end and in most of the cases you're going to be fine and yeah the really really cool thing is we have civil assistance now and it is super super flexible there's it's not just protecting airdrops there's a lot of things that you can do especially with governance and boating um quadratic funding things like wallcoin uh there's been a lot of talk about solvent nfts which are solvent your wallet which is an ideal because then you lose your wealth and your fact something like the thing that I showed for the lens profiles could be used to bound nfts to our wall ID profile instead um making it so that if you lose your wallet or you find any point you want to transfer them you can still transfer them as long as you can generate proofs with your warranty and there's a lot of other really really cool use cases all of the links that we have mentioned are in the documentation including the explanation of how this works links to uh probably not this stock because will not be out there but other similar talks that we've done in the past documentation guides uh test net simulator so that you don't have to go to the orb to try your app you can just use a faucet that will give you unlimited entities with that with on test net Expose and much much more so yeah you can just go to id.walkin.org and we'll also be doing the entire hackathon both of on the walkway Discord which you can access at discord.edulecoin and at the external Discord on the sponsors um dash world container yeah we wanted to give a little shout out at these three projects SEMA for havaland wallet connect which are kind of like the perks that are allowing us to do all the things that we're doing here most if not all of these products actually all of these products are open source um I'm sure everyone is familiar with welcome foundation and SEMA free is also an open source product by some really really cool people and those are the things that really enable all of the stuff that we're doing there here and yeah we we got started with this around East Amsterdam so um foreign of this year and we've been working into making more apps like the lens integration we're working with a git coin passport to get integrated as well and many others and we are hoping to release this multi-chain right now it's mostly on polygon but we'll be moldating hopefully by early 2023 and yeah I'm I personally think it's a really really exciting solution I've made a bunch of things that sound super hard but really just take a freelance of code like a contract that will receive any tokens and split it um through every human on earth or at least every human that has registered and things like before you could just not think of how to do and yeah I I'm really really looking forward to see what everyone else makes yeah if you have any questions our boothis upstairs uh on the left first one that you see and we'll be here weekend you have this card I have purple hair pretty easy to spot yeah thank you for listening hope you have fun [Applause] [Music] 