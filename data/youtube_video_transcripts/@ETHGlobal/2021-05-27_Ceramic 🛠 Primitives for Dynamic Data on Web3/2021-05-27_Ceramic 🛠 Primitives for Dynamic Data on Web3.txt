um thank you everyone for joining um today we have ceramic with us um joining us today specifically joel thor stenson uh who will be presenting a workshop on primitives for dynamic data on web3 um thank you so much i will let you take this over in a second uh everybody if you have um questions please feel free to put them in the chat and joel will get to them as he goes on with his presentation we'll head to you now all right thanks catherine uh let me share my screen and then get started all right so um kind of just going to start with a few slides to give you guys an idea of uh what ceramic is so uh i think the screen should be showing now that'll let me know if not uh so yeah ceramic uh ceramic is a protocol we've been working on for a while it came out of some insights we had while working on a previous project called three box and and really what's ramkias is like provides really kind of lower level primitive for having having mutable data on web3 without having to put like all the things on the blockchain um yeah it's basically mutable data on web3 and how does that work so in ceramic an object is also a stream and basically a stream is a bunch of events that are linked together and then there's a processing on top of the events and then you get like a state and that's like the current state of the and you can yes they kind of mentioned you can view this as like a minimal building block for data that mutates over time and these streams have a stream id and they act as persistent identifiers and that means basically that you can always use the same stream id to fetch the content of of the current state of the stream and you will always get the latest state and so ceramic is a global environment for for mutable data so i can run another micro machine and then load some stream from someone else's machine and one of the main differences between this and blockchain is that i can trustlessly verify just one stream i don't need to like verify an entire blockchain worth of data so this makes it kind of very decentralized and and scalable and so underneath the hood this is using ipfs for like content pieces of content and an ethereum to like anchor and get like a an audit trail of updates uh and yeah so it commits the the events in the streams are originated locally it's signed by the user and the streams themselves can are made of an append only log and a few different kind of stream types are supported so stream type basically defines the update logic and conflict resolution strategy so like if there is a conflict in in this depend on the stream of events like how do we resolve the conflict and it's a data structure and so that might be like one depend on the vlog it might be in the future you wanted to support like forking and merging back again um yeah that's that's kind of a general overview of like the primitive so i'll jump in a little bit into kind of how it works um and then soon we'll kind of jump in and get started with with playing around with the cli so commit streams we've talked about to the right you can see how how it kind of the data structure kind of looks like so you have genesis commit which contains the first update you make or the creation event and then it can be anchored into a blockchain and then basically right now ceramic has the concept of anchor service which takes a bunch of different streams bashes them into big merkle tree and puts the the root of the mercury on chain so we can minimize the amount of transactions we need to make on chain and then basically like we have these signature commits so that they include like a patch to the state and so you can imagine the state it's like a json object uh that mutates uh over time and the signature commits contains the contains it patches to um to the object uh and yeah and then the the stream kind of progresses like this as the user makes updates and the nice thing is i can process each stream independently so um and i kind of mentioned this earlier you can sync an individual stream um right you already talked about stream processor stream types uh and then shake pointings uh yeah i mentioned this as well uh periodically it's anchored into the blockchain and one of the reasons for this is it gives us kind of a proof of publication that this this commits like the signature commit for example existed at a certain point in time and there's no way someone could you know fake that all right so i'm going to talk a little bit about using ceramic so if you can use ceramic protocol directly and that allows us to get kind of to create read and write strings and it allows you to have full control over the data flow so if you want to really control how your application works and how it interacts with these kind of lower level data objects you should you'd be using ceramic directly it we also have a kind of protocol on top of ceramic which is called idx which you can think of as kind of like a decentralized user table where you can store data and the data is stored with the user so the user kind of gets full control uh over the data that every change that's made is actually signed by the user and the nice thing about idx is you can kind of semantically define the data sets that is associated with the user so they have to like include a json schema which exactly describes the kind of data that's expected there and generally idx is the best place to store user generated content um and we also provide something called 380 connect which is uh an interface uh to so so in ceramic we use something called the ids which is decentralized identifiers i'm not going to go deep into that now but it's basically a way to interact with a user identity and request signatures and requests things to be decrypted and stuff like that so 380 connect allows any any blockchain wallet really to authenticate and uh start reading and writing data on ceramic uh and 38 also allows you to like tie an ethereum address to your dad so you can look up data based on like an ethereum address but you could also like tie that to like other blockchain addresses uh like filecoin or or cosmos or polkadot or whatever so it kind of really enables the data that the users have to be interoperable across the web3 ecosystem um yeah so that was kind of short presentation if you want to jump into like looking at the documentation we have that at developers.ceramic.network and if you want to learn more about idx um you can just go to idx.xyc um and so before i kind of uh jump into the workshop itself and looking at how to use ceramic directly i would love to like answer if there's any questions on on what you just heard hi jealous case i have a question hey i have a question about the anchor comment uh actually about the genesis records so um in ipfs uh if i would publish an item like let's say i use schema.org and i say company and i say three box labs and i'd be the first to do that um you know in ipfs it doesn't really matter because that cont is just going to um determine the hash enhance the address in ceramic if i would do this same content twice i'm guessing the genesis block would look different because i'm using a different did i'm using a different time stem but what if i wanted to sort of search all the documents that have schema.org company um three box labs in it in the content uh is there some sort of indexing that we could use for that yeah that's a really good question so uh right now that you could build an indexing service that listens to the the gossip that happens in the ceramic network and see like oh this is a stream i don't know about and then load that check if um if uh it conforms to like specifics or it has like a specific schema um but obviously like that that might be pretty expensive and it's also like subjective to like the node that listens to like the gossip and the network we are working with the graph to natively index ceramic and basically it will look at the anchor commits and the anchor anchor services can include like a bloom filter that says like oh there was a stream with this specific schema that was included in this anchor batch and so then an indexing service like the graph could look at that information and find the relevant streams and make an index based on that um i have a question so the data um is that stored on um i'm guessing it's the nodes running on the ceramic network so um so like on ipfs you have to pin files uh is there some sort of a pinning mechanism or like some um for for long term um ensuring that that the data is always sort of accessible what's the uh solution for that yeah so uh right now you uh if you run a ceramic node you can pin strings and what that means basically is that the ceramic node will uh the the commits themselves they'll pin that the ceramic node uses on an ipfs node underneath so we'll pin the commits on the underlying ipfs node but the ceramic node will also keep track of any new update that comes in for that stream and keep track of what the latest state is for that stream uh so we have for kind of the persistence of the um of the commits themselves like the fps objects we have a back-end to like make deals with falcoin to back those up and then for and they could also be like that's modular so that could also be like plugged into an external ipfs node that's run by a third-party service or it could potentially be plugged into something like weaves so we really want that commit persistence to be very flexible in terms of like which decentralized storage uh solution you want to use because our weave has like different properties than you know platform and then in terms of keeping track of the latest state and the latest updates to stream right now you actually need to run a ceramic node and have at least one ceramic node that keeps track of that in the future we will be working on adding an incentive system that you can basically pay to keep track of your seams for you so then that would look like some some set of validators uh that basically work on tracking the pin streams and that have been paid for yeah i hope that answered your question yes it does thank you cool so let me jump into the example that i wanted to show oh i stopped sharing i'll give you another all right so uh what i'm going to be doing is basically just using the ceramic cli to get you like an idea of like how you can start using these primitives and like how to think about them so the first thing we want to do is create a ceramic daemon and what this does is basically it will start ceramic on the test net and it will in the background spin up an ipfs node and connect to an ethereum node i think by default it connects to infer if i'm not mistaken uh but if you and if you don't pass a configuration you might run into rate limiting so you can pass like ipfs api and you can pass like ethereum um companies so like yeah there's a bunch of conflicts you can pass to the ceramic daemon uh like ethereum rpc or other things uh yeah right now we're just gonna kind of run the vanilla uh so yeah this just starts ceramic see and it listens on ipfs and has some config and it connects to this random network and then starts a ceramic api and all right so then next what we want to do clear up here a little bit is so we can use the ceramic cdli to create the tile and i prepared here so uh here we are going to create a stream in ceramic which is called tile so tile is basically as the json object or json document on ceramic so we can create this and as you kind of expect it just like gives you back the content which you just used and then you'll get a stream id which is the kind of permanent identifier so if we do ceramic show and this remedy we will again see the content and we can also update this stream so let's do that so i'm just going to copy this and add some more stuff here so description all right uh and we make an update so now you can see the new state so obviously this is just the pure kind of content of the document we can also look into the kind of underlying state of the ceramic screen so we can do ceramic state and then okay that's not right [Music] copy the stream id again and now we can look at the states so here there's a bunch of stuff but here we can see the document type which is the tile and but in kind of a binary representation um and yeah so here we see the whole kind of states so there's a bunch of stuff in here content is the contents of the genesis right now there's a metadata but and in here we see which dad is being used so by default the ceramic cli provides the key did which is basically is the public private key pair and unique allows basically when you create a style in ceramic it will automatically add some randomness to that so you can create the same content multiple times and get different stream ids there's [Music] which in most use cases you want in some cases you might want to create the same and there's options for that but i'm not going to go into it right now then we can see that it has been signed there's like a signature status and now we can also see that we have an anchor status that's pending and that basically means that our node or like our ceramic local ceramic node that we started has made a request to an external anchor service that will eventually anchor this this commits and here we see log so here we have type 0 that's the genesis commits here we have type one that's a sign commit or signature commit um and so yeah the log is basically all the updates that we've seen um and yeah so then we see here also when the anchor is scheduled for um and yeah so one thing to note here is next contains kind of the state that we updated to um and once the anchor is kind of executed then this kind of mixed state will be finalized and will become part of like the main content up here uh but if you do just do like ceramic uh show right now it will kind of that's annoying uh it will just kind of grab the latest kind of pending uh content here um right so let's see this is actually scheduled for uh uh that's too late uh oh yeah i think this this get this anchor service runs like once every um every 15 minutes so we might not be able to observe an anchor uh cool so i see there's some question in the chat so is the signature done by an external mode or the one running locally so it's it's done by the local node and so right now so the cli here we have the daemon and then we have like the see the command that executes and in the background this is just running an http client and yeah so the keys live locally with the client so if i'm actually now gonna show you uh actually let me show another thing on the cli so i can also do uh list the commits here so i'm gonna type ceramic commits and we copy the stream id and now we can see that there are two different commits here one is the genes commit one is the commit id of the first the kind of first sign update so we can actually now do ceramic show and the genesis commits and then we will see what the state was before see there's another question in the chat will it cost any eth to anchor the stream so in practically i mean it depends so like it generally there is a um you you usually configure your node to to work with an external anchor service and this anchor service basically takes a bunch of updates from a bunch of different streams and makes one transaction launching so it's the anchor service that makes a kind of launching transaction and base eat so on the testnet you can use that kind of for free because it's on robston uh on the mainnet you might need to like engage with some service provider that does the anchoring for you and then maybe you pay each to them maybe you pay um you know by some contract so some kind of fiat but it's really kind of up to the application developers to set up that um agreement we're like yeah so the next question i see which makes sense is there any decentralization on the anchor service itself so right now there isn't uh but anyone could run an anchor service so there's no like centralization on any one particular anchor service but i mentioned earlier when i was giving going to the slides that we are working on like an incentivized system for keeping track of the state and that will actually decentralize the anchor service as well and so that's plan [Music] but yeah there's no like lock-in into like a particular anchor service so if one anchor service would be censoring you for example uh you could just engage with another provider um all right so now i'm just actually see uh i'm gonna change directory here um so now i'm actually gonna show you the the http client that you can use in javascript so the first thing we're going to do is require and just import the ceramic network slash http client which is an npm package that you can find on npm so we're just going to load that then we're going to do let ceramic equals new ceramic and we're just going to point this to our local node that we had here um all right so what we want to do now is basically just like load the documents with load dock equals or left doc equals ceramic dot flow stream and we're just going to pass the stream id we created over here oh i did not do this in the right way because we need this returns a promise i need to wait [Applause] uh now we see kind of the same content that we saw before and we can also do like style metadata controllers and we'll see like oh this is the owner of the of the data stream and so now we could like make um basically we can just show that we can observe kind of uh updates here so we can do tile dots and so actually let's go back to here and let's make another update and just add some word here all right so you can see we have made an update so i think if we just do kind of content here again we'll see the old content this is because we haven't uh by default we don't subscribe to updates i think we can do tile.sync and await this uh and we should be able to look at the content and yeah we can see the updated content uh i think if i remember the api correctly you can do subscribe here [Music] and i think uh so this returns uh a kind of observable um but i wonder if we just do that we might get the content for free uh let's try okay now we can see okay yeah so that i misunderstood here so basically you need to consume this observable to to get like a stream of updates that comes to to the tile so like now i guess if we sync again we'll get the content here um all right so i think we have five minutes left so i would love to answer like questions if any questions came up um or if there's something specific uh people are wondering about all right if not i can i can actually um try to show like the last thing but catherine any anything else you wanted to like uh okay so oh there's a good question in the shot actually uh do you have support for jason ld or seaboard ld uh so there's some native support one thing um that you can do however is just like put json ld content inside of a tile document in ceramic and that basically is you include the contexts and that that's basically it like you you then have uh jason ld and inside of ceramic documents and another thing that ceramic supports which i think is to take a little time to demonstrate here but you can actually create a json schema so json schema is basically some json data that defines like a schema for other json data so you can create one of these tiles that is a schema and then when you create a tile you can do like you can after only you can specify the content but you can also specify schema and the schema can be a stream id as well so if you created a schema first and then create a new stream you can reference the schema stream in your new stream and then ceramic will automatically enforce that the json content in the the schema conform or in the in the stream conforms to that schema so that will kind of give you more guarantees around what the data you can expect from [Music] from the when you load a stream this is also something that's used in idx to kind of more semantically describe data you can expect when you're requesting data from users all right any any other last questions i guess before we close anything else coming up well i will invite everyone who has any remaining question um to simply go to the discord and connect with the ceramic team on discord this is really the best place to get in touch with them and ask your questions as you hack along during the the next few days so thank you so much joel for uh your presentation and for uh all the answers to the questions i think that was super informative for everyone cool yeah thanks everyone for joining great have a great day 