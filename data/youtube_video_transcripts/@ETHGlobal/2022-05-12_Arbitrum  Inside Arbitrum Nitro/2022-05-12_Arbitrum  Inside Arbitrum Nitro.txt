hello everyone just waiting for the live stream to get set up onto youtube hi everyone we have ed here from arbitrom who's going to be doing a workshop on inside arbitrage nitro uh workshops are sorry um chat or questions as always go into the zoom chat um if you have any questions definitely ask them and i will um answer them all at the end and with that being said i'll pass the mic off to ed hey thanks um welcome everybody thanks for your time today um i want to talk about arbitrarum nitro which is the latest and greatest version of the arbitrary technology that i hope some of you know and love nitro is a top to bottom rewrite of our software stack to make it faster simpler and and cheaper to operate than our current arbitrary stack so nitro is now on test net and we're we're driving toward migrating the arbitrary main net onto the nitro software stack so i'm going to talk about how this works we'll go inside and and really talk about uh try to give some idea of of how it works on the inside so i want to start with um basically four concepts that i'm going to go over as we talk about how it works first it's an optimistic roll-up second that it functions by doing sequencing followed by deterministic execution that we put geth at the core of the software and that we separate execution from proving i'm going to go into a lot more detail about what each of these mean but this is just kind of a road map okay so first optimistic roll up what does that mean um well first it's a roll-up and roll-ups have gotten a lot of attention lately probably one of the big things that drove attention to roll-ups is this post by vitalik about a year and a half ago now basically talking about a roll-up-centric road map for ethereum the idea is that roll-ups provide a level of scalability and low cost that the ethereum chain itself has trouble providing and so vitalik talks here about a roadmap for ethereum where ethereum focuses on enabling roll-ups roll-ups provide the execution and storage layer for uh for applications and ethereum focuses on being the best uh under underlying layer for roll-ups so that roll-up centric road map what that means is that the kind of technology that arbitrary nitro is is the kind that is in the road map for for ethereum to support and to become the main sort of execution layer for ethereum so what rollup means essentially is that the data of your transactions is stored onto the l1 ethereum chain it's an optimistic roll-up because of the way that we settle transactions back to the ethereum chain it's an optimistic protocol which means it's a protocol that is always guaranteed to be correct but is especially fast and efficient when people behave according to their incentives and i'll talk more about what that means yes so sorry to interrupt but um you're not actually screen sharing your slides right now let me screen share oh thank you no worries all righty okay there you go now you can see it okay an ethereum centric roadmap okay the second thing about nitro is that it operates by doing sequencing followed by deterministic execution and this is where we really start to get into the nuts and bolts of how things work i want to tell the story of how arbitram nitro takes transactions and actually executes them and finalizes them so it starts with this component called the sequencer the sequencer is currently a centralized component that's run by our team the arbitrary team but we're but we're moving toward a decentralized sequencer uh approach the sequencer's only job is to take transactions that are submitted by users and to put them into an order into a sequence in what order they arrive the sequencer follows a first come first served uh approach to sequencing and the only thing that the sequencer is trusted to do is to say in what which transactions arrived in in what order there is a mechanism if the sequencer tries to censor you that you can bypass it and still get your transactions into the sequence but i'm going to skip that for simplicity in the explanation so the sequencers job take these transactions that you submit and put them into sequence okay now once the transactions have been sequenced now the sequence transactions can be run through the state transition function the state transition function is basically a piece of code a piece of logic that says what each transaction does and it's a fully deterministic function meaning that if you give it the same inputs it will always produce the same output so the state transition function will take the next transaction in the sequence and it will take the state of the chain and it will do that deterministic computation on it and the result of that will be to update the state if your transaction does things like move assets around it will um the state transition function will update the state to record the asset transfers and other things that have happened and then the state state transition function will sometimes emit a layer two arbitraring block okay so this is how execution happens logically transactions are put into sequence and the sequence of transactions are run through the state transition function one at a time now one thing to note about this is because the state transition function is fully deterministic that once you know the sequence of transactions that that sequence of transactions fully determines how the state will evolve and it fully determines what the l2 blocks will be and what that means is if you know what the sequence of transactions uh is then you operating all by yourself can execute the state transition function yourself in your own node and know what the result of computation on the chain is going to be right so everything follows the the the sequence of blocks follows in a deterministic way from what this transaction sequence was okay but how do you find out what the transaction sequence was well the sequencer first publishes a feed of um of the sequence transactions anyone can subscribe to and receive that feed and the sequencer produces that feed in real time so you submit a transaction to the sequencer under normal conditions in less than one second your transaction will be sequenced and will appear in the feed so that feed is the sequencer's promise as to what the sequence is that it's producing this is so if you believe the sequencer's promise then you know in less than a second what the result of your transaction will be because you can subscribe to that feed take the transactions on the feed and run them through the state transition function and now you know everything about what the chain is doing the sequencer will then every few minutes will take a batch of the sequence transactions and it will batch them together to make a big block of data it will compress that data for efficiency and then it will write that compressed data onto the l1 ethereum chain and this records what the transaction sequence is and as soon as that transaction that ethereum transaction that records the compressed batch as soon as that has finality then the sequence of transactions is final and then everyone can look at that they can execute the state transition transition function for themselves and know exactly what the chain will do so this is the um when the batch and compressed transactions are written to the l1 chain then then all these transactions have finality because the l2 blocks are an inevitable consequence of that of the that batch and the batches previously recorded okay now so let's talk about finality and how finality works in this space there's basically three uh forms of finality if you will in a system like this the first is what i'll call soft finality which comes in about one second to get soft finality you subscribe to that sequencer feed you compute the state transition function on all of the transactions that are come out in the feed and then you know the result and the guarantee is that that is the correct result of what the chain will do provided that the sequencer speed is correct if the sequencer is being honest the sequencer is making that promise it has the power to keep that promise so unless that you have finality within uh one second or less the second version is is hard finality which comes after about 10 minutes so to get that hard finality you watch the l1 ethereum chain you look for those compressed batches you decompress each batch to know the transactions you compute the state transition function on there and then you wait for that compressed batch to have finality on the ethereum chain and the guarantee there is this is as final as your l1 finality assumption all right and then finally there is certification and this is the process by which the ethereum chain learns uh what the result of computation is now i said before that anyone who sees the transaction sequence can figure out what the chain does and know the result with certainty and finality and that's true so you might ask why doesn't the ethereum chain know in one second or 10 minutes what the result is and the answer is the ethereum chain doesn't have the computation power that you or your laptop or phone or really anyone has ethereum has a really slow and limited computation capability which is why we're doing this layer two thing in the first place so ethereum cannot compute along with the chain even though your laptop can and so we need to use another method to convince ethereum what the result is and that takes days typically seven days so you in order to see this you just wait for the l2 blocks produced by the arbitrary chain to be certified on the l1 this is really only used by l1 contracts and that is they're the only entities whose world is constricted so they only see what ethereum knows all right so that is how sequencing and deterministic execution works the second piece of this is geth at the core the idea here is that in order to have the arbitrary chain um be compatible with ethereum um as closely as possible we actually take the core of geth or go ethereum which is the most popular and sort of authoritative ethereum node and we take the core of gas which does evm emulation and tracks the state maintains the ethereum state database and all of that stuff and we actually build that into arbitrary nitro so we use the very same code that geth uses to do evm emulation so that's the gethcore on top of that gethcore we put a layer which is not to scale here it's actually much thinner um that we call arbo s so arbo s basically takes on top of that geth core and it gives you the few additional things that you need in order to be an l2 chain this is things like uh making sure that the sequencer gets reimbursed for its um for its ethereum gas costs it handles deposits and withdrawals that is movements of eth or tokens between ethereum and the arbitrary chain and in various bookkeeping type functions and then on top of that we take node functionality this is things that take your node and they turn it into a server that can respond to uh to rpc requests from your wallet and uh and can do all of the things that an ethereum node can do in terms of serving the user so we sometimes uh refer to this as a kind of geth sandwich and the reason for this is that we have the geth core at the bottom that comes from from this very standard geth ethereum node we have this rbos layer in the middle which is custom and then on the top we have the node functionality which again mostly comes from the geth code so that's the geths sandwich right geth is the bread and this thin arbos layer is the uh is the the payload in the sandwich okay we then now the state transition function i talked about before the part that takes a transaction and the state and then updates the state and maybe produces a block remember that that deterministic function that's what i've outlined here on this slide in orange it includes all of the gethcore because it is taking care of emulating the ethereum uh making sure to emulate ethereum execution and keep track of the state of the arbitrary chain just as if it were an ethereum chain and then also some pieces of rbos the parts of rbos that are needed to keep track of things like deposits and withdrawals and accounting and so on those are in the state transition function right and so uh this is uh this setup is um highly compatible with ethereum because we use the gethcore for evm emulation and because we use gethcode at the top on this as the top bread in the sandwich um to be compatible with the uh network with the rpc api that ethereum that that ethereum nodes provide all right let me move on to the last piece now which is separating execution from proving okay so remember this piece right this is what i just showed you um this is the blue part is the full node software the orange part is that state transition function which is the part that needs to run correctly and reliably and provably in order to guarantee a correct outcome so we take that blue piece the entire node and you can compile it to native code just using a standard compiler this software is pretty much all written in go and so we use the standard go compiler and you can compile that to run on your machine or you can and then you can run that as a node so if you're running an arbitrary nitro node you just are running a program that runs on your machine which is compiled from all of this blue stuff and it will do all the things that you would expect a node to do then take separately the orange piece just that state transition function and we compile that using the same go compiler but instead of compiling two native code that you run directly on your machine we instead compile it to wasm or webassembly format which is a machine independent and efficiently executable format for expressing code which is developed by a consortium of of companies and developers and so we use that for proving so if there is a dispute between different parties in our protocol about what the state transition function this orange outline code should do that dispute is resolved or refereed in the context of this wasm code so the wasm code is the definition of what the correct execution of the code of the state transition function will be and the beauty of this sort of dual compilation mode is that in ordinary execution when you're just running a node and the chain is running along it's running as native code which is the fastest way to run a guest type functionality so you get a lot of speed by doing that but then if there's a dispute and you need to do proving proving doesn't need to be quite as fast and efficient but it needs to be extremely portable and reliable and secure which is what wasm is is excellent at so we use that for proving and this is one of the core tricks that allows nitro to be really fast and also to be fully provable okay let me talk about how the proving mechanism works because this is part of the secret sauce and in fact this is the part of arvatram that we devised first back in 2014. this is um and there's a question um in the chat which is if soft finality is one second hard finality is ten minutes what time frame can i do a dispute with it um and the answer is uh you get seven days to do a dispute so you have finality very quickly finality means that the result of the transaction is inevitable people can still dispute it because someone could try to make a false claim about what the outcome will be but if you're an honest party you can force if if your transaction has finality that means that you acting alone can force the correct outcome of your transaction through our protocol no matter what everyone else does if every other person in the world is evil but you know what the correct outcome of your transaction is you can force that result and that's why we say you have finality because if you uh because anyone can enforce the correct outcome okay so how does this work how do we actually prove or resolve disputes let me dig into that so um and this is how we actually settle the result of transactions back to the ethereum chain so it starts with alice who's just some uh some arbitrary person in the protocol and alice makes a claim and she puts down a stake to back that claim and her claim is this she claims that in the in the current state of the chain that is the start state that everyone agrees on that after the chain executes n blocks creates n blocks that the end state will be some particular thing now these states are really just cryptographic hashes of the state so they're small but because execution is deterministic there is a correct answer about what the end state is so on this diagram i've drawn the start state in black because everyone agrees that that's correct that's known correct and i've drawn the end state in orange to reflect the fact that alice claims that it's true but it might or might not be true so alice makes this claim then a challenge window opens up a period of time in which everyone can look and see if they agree with what alice said and if they do agree then they don't need to do anything you could just sit back and wait and if the challenge period passes after seven days and no one has disagreed with alice's claim then alice's claim will be accepted and the protocol will move forward and that is the common case alice has staked on her claim so her incentive is to make a claim that's correct and other people would have to stake to dispute it and if her claim is correct that would be foolish of them but let's say that bob actually disagrees bob responds and he says no um i i the start state is the same but i think the end state is different and now i've drawn the end state in red to show that we know that alice and bob disagree about what the end state is alice has what makes one claim bob's making makes a different claim and what the protocol is going to do is identify one of them as being a liar so how does that work well the first thing bob does is in addition to saying what he thinks the end state should be the protocol forces him to make a claim about what the state is halfway through after n over two blocks right so now bob logically has made two claims that each are n over two blocks and now now it's alice's move in the protocol so alice has to do one of two things she can either say i disagree she can either disagree with bob's mid-state in which case we're in the top one of alice's choices here if she disagrees with bob's mid-state now you have a situation where she agrees on the stock where the two of them agree on the start state they disagree on the mid-state so this looks just like the situation up at the top of the slide except we've cut the number of blocks in half alternatively maybe alice agrees with bob's mid state and in that case we have the situation at the bottom where alice and bob agree on what the mid state is but they disagree on the end state and again this looks like the the diagram alice's initial claim up at the top except half as large so alice is going to pick one or the other of those to do depending on whether she agrees or disagrees with bob's mid-state and let's say that alice agrees with bob's mid-state and chooses this one okay so now alice has done that that's her response and now we force her to again break her claim in half by by claiming what is the state halfway between um halfway through that and series of n over two blocks all right well now that looks like bob's situation in the middle except again half as large and so now it's bob's turn he's gonna have to identify one of the two sides of alice's claim and break that in half and so on and so you can see that in each round of this protocol we cut the number of blocks under dispute in half so after a logarithmic number of rounds we get down to a dispute about a single block right and this is a very efficient protocol because alice and bob are doing all the work there is a contract on the l1 ethereum chain which is the referee in this protocol but it's just like making sure um did bob post a claim about the midpoint and did alice say whether she's disagreeing with the left or right half of bob's claim and did bob post then did alice then post a claim about what she thinks the middle state is and so on the referee at this point just makes sure that each player actually makes a move that looks legal-ish and by doing that the parties do all the work and you get down to a disagreement about one block all right so now here's the full challenge protocol so we started with step one up at the beginning alice made a claim about the result of n blocks of computation and bob disagrees we bisect the dispute down to a disagreement about one block now what happens inside that block they just they're disagreeing about that block well alice now claims how many steps of computation how many individual instructions of wasm got executed by the state transition function to produce that block alice makes that claim and now you can again do bisection but now you're doing it over steps of computation and the states are states of the um are states of the wasm execution so you again bisect down to one step of computation so like one ad instruction or one memory read instruction or something like that in wasm and once you've done that alice then submits a proof of just that one step of computation and at that point we'll know who is lying or telling the truth now this protocol guarantees that a party who's telling the truth can always win the game and force the liar to lose and so the result of this is that we're going to identify a liar that liar will lose their stake half the state goes to the other party and then we're able to prune off the claim that that liar made and so if you're cur if you make a collect correct claim you will eventually be able to prune off all the counter claims that might disagree with it and then your claim will be accepted so that's how the protocol works uh one a nuance here is that we don't actually bisect into two pieces we instead for efficiency break into about 400 pieces with alice or bob putting about 399 uh intermediate points and the other party choosing one very small sub-segment that just reduces the number of rounds but that's basically the challenge protocol and you can show that that by using this protocol that a party who is correct and telling the truth can always force the correct outcome to be accepted okay so that's arbitrary nitro in in a nutshell you can try it out uh it's running on a public uh public test net we call it a devnet um that runs on top of of the gourley um ethereum testnet there's a url here on how to get to it and how to use it we're really excited about nitro it's on testnet it's going to be a huge step forward in scalability order of magnitude improvement and throughput and uh and gas cost reduction um we're we're not making promises but um if i were a betting man i'd say maybe a factor of two reduction in gas cost um over what is currently on on arbitrary we are also working on follow-on technologies including something called arbitrary any trust which is able to drive down the cost further but i don't have time to talk about that today so that is it um one more thing um the mandatory please come and work for us uh jobs at offchainlabs.com or reach out to me i am ed felton um on twitter or telegram with this name here so that's it let me go back to the um to the devnet url and then um any additional questions by chat okay yeah we do have a few questions in the chat i see there um i don't know if you see it on your end um i okay i've answered let's see a couple i think you answered both actually yes i believe i answered both i have a question ed if you don't mind sure so um i have a question around fraud um i was speaking to a lending team and they said that their users are transacting with you know with lending and borrowing on arbitrum and fraud occurs what happens to their users who are lending and borrowing you know when fraud is confirmed if fraud is confirmed well nothing happens um the um essentially nothing happens so the way the way we think about so if you're a normal user of the system you won't even know that someone tried fraud um what i mean by that is that honest arbitrary nodes just look at the transaction sequence and they compute the state transition function for themselves and so they know what the correct outcome of the chain is so the fact that a bunch of people are over somewhere else quarreling about what the outcome is in that sense doesn't matter so from the user experience standpoint the fact that someone attempts to to commit fraud is not something that you'll ever see what you see as a user if you're connected to an honest arbitrary node just like if you're connected to an honest ethereum node you see a chain that just marches forward um and it executes correctly and because of that very strong guarantee you because of that very strong guarantee that any one honest party in in the dispute protocol can force a correct outcome as an ordinary user you don't have to worry about it and the user experience is that you don't even see it you see you see correct execution and you see finality in either the one second time frame or the 10 minute time frame depending on on what kind of node you're connected to that's awesome thank you thanks great do you have any more questions i think we're slowly running out of time here yeah i think that's it um well thank you very much ed that was very informative i'm sure everyone that was part of this uh really enjoyed it thanks everyone and feel free to reach out my my twitter and telegram contact uh address are on the bottom of this slide now perfect there's also a discord channel as well under the global sponsor discord for arbitrary so you could find uh the team there thank you very much and uh thank you all for joining us today we'll uh talk soon thanks everybody bye thanks 