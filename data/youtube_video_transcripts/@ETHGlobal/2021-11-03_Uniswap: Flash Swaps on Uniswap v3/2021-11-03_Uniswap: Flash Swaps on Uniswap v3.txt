a kind of technical example of integrating with flash swaps on univ3 so that's what we'll kind of go over i have some diagrams and some code snippets and things like that and then at the end we can leave some time for questions um or you know feel free to kind of jump in with things if if you have questions as we go um cool so let's get started um i think to begin with we'll sort of start with kind of like a conceptual understanding of flash swaps and you know what what they are and and kind of what they mean in the context of um [Music] uh of uniswap v3 and i'm trying to get it to actually just like click so i don't have to like scroll here one second there we go okay um yeah so we'll kind of just begin with like this kind of conceptual understanding of flash swaps um essentially a flash swap is kind of the name that we call a form of swapping that allows you to withdraw tokens with no upfront cross and then execute logic just given that you actually end up paying those uh funds back at the end of the transaction um and we'll kind of go into like a simpler example at first before we get into a more kind of convoluted example at the end so just to make this a little more clear i don't know why it's not there we go we'll start with this example essentially uh if you guys have heard of kind of like arbitrage is like a really great example for flash swaps um but in this example we have two pools let's say so we have one pool that's um 1300 die east pool so like the kind of like cheaper pool and then we have another pool that's like the 1500 die eath pool um you know without even talking about flash examples what we can see already is that there's an arbitrage opportunity right so we can buy each from the cheaper pool and then sell eth on the kind of more expensive pool and gain uh plus 200 and this is sort of not kind of excluding talking about fees and all that kind of stuff but you kind of get the idea now bringing in flash swaps what you could do is actually execute this transaction without any upfront capital so essentially we can just take advantage of this price difference with one transaction with a flash swap it's capital free because you actually don't really need to put capital up front you can withdraw eth from that first pool execute a swap and then pay back um all within the same transaction um and so yeah that's kind of the advantage of of doing flash swaps um and i think in this next example we'll um we'll kind of i'm gonna go through a couple of diagrams with you guys to to sort of set up a mental model for all the different pools and things that we're gonna look at code for um but by the end you'll be able to hopefully understand how to call the actual flash function that uniswap v3 core provides cool any questions here before we get started with the more complex example great all right so in this example we're going to be talking with three different pools um each of the pools are uniswap v3 pools of ethan dye with different v-tiers so um just as a reminder with uniswap b3 each pool is defined by a token zero a token one and then a feet here so in each of these three pools we kind of get all all the different feet we cover all the different feet here's um and this is a it's a this is a fairly um not practical example like you normally probably wouldn't see this actually in production but i think it really covers a it really covers a cool example of flashing um so yeah in these three pools we have three different prices so we have a fifteen hundred um each die a thousand each die and a two thousand each die and we're going to be executing arb opportunities across two of the pools so you can see here um in the first pool we can withdraw 18th and 1500 die and we'll kind of not really uh talk about the fees right now and just kind of assume um it's kind of baked in to withdrawing and the price and all of that um [Music] uh but you'll see later in the code how we um ensure that this is going to be like a profitable a profitable swap so the first step is to withdraw one each and 1500 die we'll end up swapping 1500 die and we'll swap the other one each across these other two pools and so in the end you're going to get 1.5 each in the first pool and you're going gonna get two thousand die out of the second pool so it's 1500 die for 1.5 eth in pool 1 this is the one at the top and then it's 1 8 for 2 000 dye in pool 2 at the bottom so you actually end up with um [Music] some profit here you'll pay back the original pool pool zero over here on the left um one each leaving yourself with 0.5 east profit and then you'll pay back the original pool 1500 die leaving yourself with a 500 profit does this kind of make sense or any questions here essentially this is the entire scheme of what we'll be coding so if we don't understand this yet then it might be harder to look at the code later so if there's any questions feel free to shout it out okay cool i see um all but ask you to just do like a once-over of this again for everyone totally yeah let's start kind of back maybe with just like setting up the um the pools um one second i don't know why it's not clicking there we go okay yeah let's just do a quick once over um and yeah feel free to jump into questions as we go all right so we're setting up today's example with three different pools each are eath die pools and they have different fee tiers right because we can have there are three different fee tiers available on uniswap v3 in each of the three pools they also have different prices meaning there are opportunities across pool 1 and pool 2. um and so this is the kind of upper pool here i'm calling pool 1 and then the lower pool here the 2000 each die is pulled too and so this kind of diagram shows you uh kind of the steps that will take to actually take advantage of the the price differences here in pool zero over here this 1500 east dipole we can withdraw 18 and 1500 die and we'll kind of see how we actually do this in at the contract level but essentially we're gonna take out both both tokens this is the withdrawal phase so we take out one eighth and fifteen hundred die we can then swap um fifteen hundred die in the first pool at the one thousand each die rate and we can also take the one each that we already withdrew from pool zero and swap it in the second pool uh the 2008 die and if we do the math that what we end up getting is 1.5 each for the 1500 die in pool one and then we end up getting 2 000 dye for one each in pool two and you can see that there's um a gain here right we have to pay back the pool one east and we're left over with a profit of 0.5 each from pool 1 and then in the bottom we only have to pay pool 0 1500 die so we're left over with a profit of 500 die and so uh essentially the profit total is the 0.5 each plus the 500 die that we just armed across pool 1 and pool 2. um cool any questions here it was sort of just uh another quick like once over of of how we're using these three different pools um and taking advantage of their price differences yeah there is a question from dave if you want to unmute yourself and ask sarah live you're more than welcome to otherwise i will read it out it was just a general question about the flash mechanism the initial withdrawal you say it's capital free so is it all baked into the whole flash loan and repayments or yes why is the withdrawal allowed yeah so the withdrawal is allowed because um of we'll sort of kind of see how this works at the contract level but it's essentially allowed because of a callback mechanism so when you actually flash um you are sending tokens to say like a contract and that transaction will revert if you do not pay back the pool by the end of the transaction so you could withdraw execute some logic but at the end of the transaction because we're going back into after basically the callback happens we go back into kind of the uniswap core logic and just check hey do these pools is their balance still the same um if so we can execute the transaction if not we just revert and the transaction fails and so that it's like as if that withdraw never happened um yeah great question um yes uh it actually doesn't necessarily have to be profitable you could write a contract that's not profitable um but there's no real point in doing that unless you're just kind of playing around and practicing um but in in the contract that we'll look at in a second we actually have a profitability check um like a very simple one but we'll see how that works cool so yeah i uh let's kind of dive into setting up the actual contract um we'll talk about so i already mentioned a little bit about um the this sort of like callback structure but essentially how swaps and flash swaps on univ3 work is through a callback um a callback implementation so um you know the design you know here is that callbacks are able to give sort of your own contract autonomy of executing sort of this arbitrary logic that we talked about but like i said before inside this callback the pools that you're borrowing from need to be refunded otherwise um the transaction will be reverted when the callback closes well so i sort of have like a a little diagram and this is how i like to think about it inside of my head like these different contracts interacting with each other so on the left here we have our contract this is the contract that we'll be writing and setting up and kind of going through all the steps that you need to do to actually um execute this kind of flash swap logic and we'll be interacting with the uniswap core libraries so or the core contracts and so that's what this kind of write diagram over here is representing is this the the core contract specifically unisoftv3pool.soul um so if you also have that contract open you could kind of follow along as well um but just a quick overview our contract is going to essentially do two main things one is it's gonna call the flash function that's defined in the core contract um flash is going to send amount 0 and amount 1 of token 0 and token 1 to our contract and this is that kind of withdraw phase and then after that the uniswap v3 flash callback that we're implementing in our contract is going to one do all the arbitrary logic that we talked about and then to pay the pool back and when this flash callback closes we end up back in the flash function in the core contract which does the check hey have all the pools in in that we've touched in unisop v3 been paid back if so we'll like finish and close the transaction if not we'll revert and so that's kind of how these two contracts interact with each other um any questions here i saw there might be something in the chat so yeah there's a question from gideon who says um does the flash modify the liquidity of the pool in between the loan and the repayment um no because the transaction only goes through at the end so like during the um when when we're inside our contract executing all of our logic the liquidity in the pool hasn't actually changed all of this happens um atomically right so all of the logic here is going to be one transaction that changes that state in one go um so it'll bar it'll it borrows and then executes and then repays um like all in one if that makes sense so in particular like this sorry i talk now in particular this state of the count of unisop contract is not modified right if i call like the pool dot liquidity uh the number is the same like it's not affected by that right yeah um you'll have to pay gas fees but you won't have to pay the like lp fees essentially if it reverts right because you wouldn't have interacted with the pools if like if it reverts well can we step in for questions uh sorry what was that can we step in for questions or should we wait till the end oh you can step in if you want um and i'll also leave time at the end too okay um just a very quick question and maybe this might be better asked at the end but if a transaction that includes a flash swap is any in a block that is uncle does a transaction then i mean is does it still execute as one transaction in the uncle block or does it exist as a single transaction in the uncle block or can it be split up into into i think i i'm not a hundred percent sure but i think it's just one transaction um okay thank you but yeah i'm gonna have to double check on that one thank you great question though um [Music] cool so yeah i think if if this kind of makes sense we can kind of go into some of the code snippets of just how um you know what is the actual logic that we're calling and and what are the functions we're calling um with the unislopv3pool.soul contract um oh actually this is a good slide to maybe just put put put all of this logic kind of back in that mental model of the diagram we saw earlier um so uh this withdrawal phase happens inside of flash when we call the flash function that exists in the um the core contract and then the callback um in the callback is when we're actually executing the two swaps that we talked about earlier um so this is just a great slide for if we need to kind of refresh on the mental model like what's actually happening here um and like what stages are happening and what contracts um so we can we can come back to this at the end too after we've kind of looked at the code all right so in the contract that we're setting up we essentially create a pool and then call flash on the pool with the parameters the first parameter is the recipient so we put the address of this contract as the recipient so that we receive the withdrawn tokens like our contract wants to custody these tokens now we also send the amounts of the token zero and token one um because that flash needs to know okay how much are we withdrawing of each of the tokens and then we're going to send this avi encoded data this essentially is just data that we want our callback to have and so you can see on the right hand side here we have this splash callback data struct that has the amounts we need the amounts inside of the callback to know how much to repay the pools we also have a payer so this is the message.sender so who is going to be taking profits at the end and then the the three parameters at the bottom are the the various pools that we're going to be working with so in our example we had three different pools so the pool key is basically the um unique pool so that's going to be the die eath and the original fee of like the width of the pool that we're withdrawing from and then pool fee 2 and pool fee 3 specify the other two fee tiered pools that we'll be working with um basically in taking advantage of the arb opportunity and all of this data we don't really touch inside of flash it's just being passed to flash so that we can ingest it into the callback um which is called inside of flash so that's kind of the first step is let's initiate flash the second step is actually implementing the v3 flash callback so in implementing the v3 flash callback we'll define a function uniswap v3 flash callback that takes in a fee 0 a v1 and data and this data is just going to be this flash callback data here that we defined earlier the fee 0 and v1 are computed by the flash function and that just tells us what fees we owe what fees we owe essentially on token 0 and token 1 when we repay the original pool so kind of getting into the logic here the first step is um kind of just some setup so let's decode this data parameter um which is the flash callback data and again just a quick reminder that's kind of the amounts that we've withdrawn the um the original kind of payer or the person who's going to be collecting the profits and then the three kind of defining features of the pools that we're working with and then we'll also verify the callbacks we want to make sure that this callback is coming from the original pool so we have the factory address and the the pool key of the original pool that we're withdrawing from uh we'll approve the swap router to um uh to to actually um ingest tokens here and token one um essentially we need this because we're going to be swapping token 0 and token 1. right and that's kind of goes back to this diagram here the swap router handles all this kind of like swap logic so we're going to approve them to spend token 0 amount amount zero and token one amount one and that's the 1500 die and the one each from this from this diagram um cool so here is actually kind of a somewhat of a profitability check which is um amount one min and amount zero men are like the minimum amounts we want to receive from the the swapping um because it's the amount one plus the fee that we owe and the amount zero plus the fee that we owe if we receive less than this um we'll be losing money right so we'll we'll do kind of like some profitability checks here with that cool so now we're ready to like actually execute our our um our first swap so we we call exact input single this is just one of the swap functions that we have available in the core the core contract there's a couple of different ways um you could swap this is an exact input swap so essentially we're just um [Music] we will be sending the contract an exact input so first for some input just give us the exact out the the maximum amount out for this swap and so not to get too in the weeds with the parameters but essentially we have a we just have to specify which direction the swap is in so we want to go from token one to token zero right we're swapping that if we look back in this example we're swapping the um die for east dye being our token zero and east being our token one so we specify that in the first two parameters and then our fee and then so for here we um we're doing the the pool with fee tier two um the recipient is this address right so we want the we want to hold the tokens that come uh from the swap the deadline is sort of just arbitrary in this example we set it to like far in the future in production you probably wouldn't do that but just for this example and then our amount in is the amount one and then our amount out minimum we set to amount zero min which is what we just calculated back here um essentially that just says like if we don't get at least the amount zero min then um revert the swap and actually just will revert the entire transaction and then this last parameter here the square root price limit x96 essentially just specifies at what price do we want to swap up until only really advanced use cases would use this and and we set it to zero here which means we'll we're willing to swap up to kind of like any price up until any price um and then same for this amount out one instead of token one to token zero we're going to be going token zero to token one and so that's what this bottom this bottom kind of swap is doing here we're going instead of going die to each we're going east to die and kind of it's the same parameters and such just the only thing that changes is just we're using a different pool so that's why we set the feet here to be the pool feed 3 instead of the pool fee 2. and so after these execute we now have a parameter amount out 0 and amount out 1 which should strictly be greater than the kind of original amount 0 and amount 1 that we that we have withdrawn [Music] so um if if this is sort of doing the um pay back to the contract right so if our amount amount zero min and our amount one min which are the amounts that we owe to the original pool and i'll just go back here to convince you of that amount 1 min and amount 0 min are the amount 1 plus the fee and the amount 0 plus the fee so this is what we owe back to the original pool if what we owe back to the original pool is greater than zero then let's pay the pool the amount minimum of token zero and the amount minimum of token one and then we can can pay the profits back to message.sender so if the amount out zero is greater than amount zero min meaning there are profits let's calculate that profit and then pay um that profit back to the message.sender which we have in that kind of like flash callback data right um we encoded that as the payer and then same for token one cool so that's actually the um the last step um i know we went a little bit fast there so i'll leave some time for questions um yeah and feel free to just kind of unmute and talk out loud if you want yeah i see um there are a couple questions that came in the chat i'm not sure if varen feels comfortable on muting and asking the question live i don't mind um thanks for giving me the opportunity so i guess two questions i had were is there a way to calculate gas fees i mean sorry not casually is the loan swap fees ahead of time um [Music] well yes that's i think the fees are going to be equivalent to it depends on what pool you're working with so um right we we specify like the fee tiers here so it's just um this i'm pretty sure just this times the amount that you're borrowing um will be the fees but you can actually you can just look in the con the core contract and see how there's like a formula that they use to calculate the fees depending on how much you're withdrawing and what pool what pool speeds here um you're working with so yeah i mean if is your question like doing it off chain like before i even um like try to execute a swap we're doing it like in like during the the actual swap well i mean you've already got a profit check um in the in the code walkthrough you did um so i guess i guess my i just want to clarify the the few that i'm referring to isn't the fee for um executing a swap on a pool it's the fee for borrowing or running a flash alone yes was that clear my question okay okay cool yeah yeah and and that's all calculated inside of flash so that's why um it's a parent it's an input into uh where is it it's an input into our callback so this just tells us how much we owe from what we've borrowed you okay i don't know if that does that kind of it does it it does answer the question out of curiosity the calculation for free zero and p1 is that available somewhere to just review it totally it's inside this contract so remember how i talked about we're writing a contract this is our contract on the left and we're um integrating it with the core contract so you can just go to github or whatever and look at this specific contract the unisop unisofv3pool.com and all of this math is happening inside of flash which we're calling from our contract gotcha okay thank you and i guess thanks dave i'll go look at that and the second question was the the parameter you mentioned that was designed for more advanced cases the i think it was a square price limit x96 is that akin to a slippage limit that you set when you trade okay yeah you can use that if you're like totally so so how you would set it is like you could do some like inline calculations or like setting a certain slippage that you'd want um to adhere to and then um it would involve some other math and calculations to actually put it into this like square root price format um but then you could set that and it would be yeah it would be sort of like a slippage check or just like a price check in general where you could add slippage into that calculation such that you won't swap past a certain price and is the reason for including this check because if this transaction executes somewhere in the middle of the block and the state of the pool has changed from what you read in the previous block to the middle of the current block is that why you had this check inside um that could be a reason um it could also be like if you're working with i don't know there's lots of reasons like for example in like because because in union swap v3 we have this notion of like ticks and like liquidity per tick um essentially you could run into a case where um there's like lots of liquidity in between a certain range here and then like none for a while like this probably wouldn't happen but like it could um and so you're actually you how the algorithm works is like um we'll keep swapping you up the curve um until your swap is is like finished right and so if there's a range where there's no liquidity then we'll actually like hop you to that next price and so it's sort of like a safety check of like okay maybe it's actually not a great time to make that trade um because you're going to be swapping across all these ticks or all these like ranges and so just that's like a boundary um but you yeah you don't that should be like a very rare case um because liquidity is usually distributed pretty normally across the um the current or the spot price so yeah thank you so much i appreciate it sure well there any other questions yes hi um can we see the slide before the last one i think you were paying fees uh yes let's see uh here right can you just uh explain that again please totally yeah this is um this logic is doing the repay to the original pool so if we look back to um yeah like here after in the inside the callback after we execute the swap we have to pay back this original point three percent 1500 east dive pool with the um original amounts that we've withdrawn plus the fees that have been calculated for us for like for like doing this flash um and so [Music] all we're saying is um [Music] from our address from our contract repay um amount the the amount um [Music] we pay the amount to the the contract basically okay thanks very sure hi i'm gonna my name is mark i've got a question related to the differences between v2 flash swaps which i just spent the morning figuring out and and v3 um so some of the differences i can see is that this is v1 and v2 whereas at least the code i was working on that my own contract just uh calculated what the fee was supposed to be and basically in the end i'm sort of repaying one token and not two so i'm just trying to understand some of the differences here really that's a really good question so um in uniswap v3 you can't so yeah essentially there's two ways to do flash swaps on v3 one is to call flash which we're doing here the flash function is um a specific type of flash that allows you to borrow two tokens for one um but it allows you to borrow both in v2 we don't have that um to simulate something more similar to v2 you could actually just call swap um it it you could essentially like emulate a flash swap um similar to v2 by calling swap because we have a similar logic of doing a callback um with just the regular like swap function that we define in the same contract um and so instead of specifying like two tokens that you could borrow you'd just be executing a swap right like a regular swap one token for another um but because we have this like callback architecture you can actually all swaps are technically a form of flashing because it withdraws the token first executes some arbitrary logic and then pays that pool um so yeah so if you're trying to emulate more of like a v2 style flash swap you would just look at the function called swap in this same contract where flash is defined okay so i would probably my swap i mean that's what i'm doing right now and v2 is calling swap so that part might remain the same yeah but but the callback would be different uh right you would write you would have to go look at the how how we um implement the you would have to write a contract that implements the i forgot what it's called it's something different but it's like you know swap v3 swap callback or something like that right yeah yeah i guess i'll reference to that so that that part would so the second part the callback sounds like would be different but perhaps the just calling swap that might actually be the same it's similar i'm sure i i can't remember off the top of my head what the exact differences are but like for example you have to specify like the fee and set up the pool as a v3 right now right yeah i guess it would be some difference just because of that because there's no notion of it different pools at different fees and me too okay i'll have to look into that uh okay i think that helps um yeah just trying to figure out a scenario where i'd be paying back you know one of the two um but yeah great really good question um and it is a bit confusing because um we do have there is sort of like two types of kind of flash flash swaps you can do with v3 um because of this and my other small question is i apologize i missed the first part here maybe it was discussed but i noticed you're using a pay function yeah i think that's just something we've defined in one of our yeah if you look at i think the transfer helper contract i think okay that's where that's from um right okay i'm not i don't remember if that's specifically it but okay i'll look for it it's defined in one of our like libraries or something okay thank you well um albert i don't know if there's a specific tutorial that i could point to um but we have this contract that i just walked through today up on our github in the periphery and the periphery um repo so i feel like if you want to read the full contract it's all compilable um that would be a good place to start cool uh has anyone else got any questions for sarah um sorry one more question um actually i haven't answered that question before uh one question more about the purpose of doing these flash loans i'm assuming if it's i don't want to say free money right if it's free money everyone is doing it and surely it's been armed out of the market by now yeah so is there an incentive to do it uh other than i'm assuming one of the reasons is to keep the uh the pools in check um you know or keep the prices in line with the rest of the market uh but it's is does it is the incentive big enough for people to take that sort of risk um yeah i mean the incentive is really just like the profit across pools and like um you could do this like across different protocols as well right so um it doesn't just have to only be like uniswap pools so i think that there's a big enough incentive i mean people are running arbitrage bots all the time i think the big thing is like they have to be really fast so um and because there are so many of these bots and such it's probably unlikely that um like or maybe there maybe there's some open source like our bots and stuff um but probably unlikely that like you would beat a lot of the like big players that have been doing this for a while but um the incentive is still there and it is really good because it keeps the prices um like essentially you're being the price to the true the true price right so um and sorry just just you mentioned um you need to be fast enough um but wouldn't you say in in the blockchain world where a block might take time to be mined and all the transactions to be processed it's not as fast as say high frequency trading in the yeah or in the traditional yeah um yes fast enough is that i guess fast enough as in quick enough to recognize which pools can be armed and then fat like fast enough to get your transaction in first right because you're competing against other bots that have probably seen similar arb opportunities cool okay that makes sense and i guess that's where um that's why some uh our traders pay extra gas fees to get their transaction through right right and so that's another thing you have to think about too is like um [Music] when you're calculating your profits like you still want to make sure that the profit is greater than all of these fees that you're paying combined right so that's like another thing that you could add on um in your in your kind of implement implementation of flash swaps cool thanks cool great um there's just one more question from lucas which is this work is on testnet or which um this is not this contract specifically is not deployed but it's open sourced so you could you could deploy it on a testnet or play around with it if you want to cool thanks so much sarah um yeah thank you for that really great session and thank you everyone for joining and for all the um questions um if you want to connect with the uniswap team you can find them in discord and i'm sure sarah will be more than happy to link me to the slides and i'll be sure to share that with you as well um cool thanks so much sarah cool thanks guys see ya 