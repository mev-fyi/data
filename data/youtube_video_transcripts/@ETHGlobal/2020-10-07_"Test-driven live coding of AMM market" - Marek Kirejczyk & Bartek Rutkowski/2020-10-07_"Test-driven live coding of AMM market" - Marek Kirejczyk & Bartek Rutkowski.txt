and uh this is going to be something interesting because we are going to try live coding on our summit and uh doing that will be merrick and bartek who will be showing us how you can do better crest driven coding uh for amms using waffle and fiddler so i'll have them kick it off from here and i'll let them share their talk in their demo so please welcome eric and bartek heyer hey thanks for having us we're just about to share our screen off we go okay good so hello everyone um it's absolutely great to be with you here today and what we're gonna do today is we're gonna do a live coding of distributed exchange and automated market maker model and we're gonna do it all in just 15 minutes so how we're gonna do it let me perhaps hide that first so how we're gonna do it we're gonna use test driven development so we're gonna write tasks before we uh write our implementation and we're gonna use incompare programming so we're gonna keep switching keyboard as we write the test and that smart control code the tooling that we're gonna use is typical modern smart contract developer technological stack so we're talking waffle that was developed here at itworks for testing smart contracts we're talking biddler for running the test and building the whole thing we're talking about ether.js that was um created by richard moore for connecting to the test nodes test node we talking about type chain created by chris catcher uh that donna gives us strong types in our typestrips tests for the smart contracts within the solidity and finality finally we're going to start with solidity template that was created by raul etc so what is automa automated market maker tax you may ask well the model is really pretty simple think about the single contract that represents a market a per of erc20 token we're going to call it plume and qb for the purpose of this presentation and you have really only two operations one you can modify liquidity in our case just add liquidity and the way to do that is simply call a function that's gonna send some of both of the years token and those erc tokens gonna be added to both pools for each year for both pools for both tokens and of course they need to be sent in the right proportion and there's there is a second function used for trading and again it's very straightforward what it does is it allows you to send a little bit of your c20 token and add it to one pull while the subtracted amount from the second pull goes back to the center pocket so off we go okay so here we are with our 15 minutes we're gonna talk fast right fast so pay attention and stay tuned with shaflak with shazlak so marek right now is implementing our very first contract which is gonna be a market it's gonna be only the empty hollow or of the contract and we're gonna go straight to the test we're gonna write the first test just after initiating the file so when it comes to texture and development one of the hardest things is always writing the first test as actually as you're gonna see i think it's gonna take us roughly half of the time to write the very first test so and many times when you when you're doing that it comes the question what is the simplest test what is a simple reasonable test that you might write so in our case and in general when it comes to working with smart contracts the very first task is usually the one that deploys the smart contracts and check if they were deployed and utilized correctly now if we would like to write it all at once that would be quite a lot of work and that would be quite a big step so we're gonna start with just one very simple thing which is deploying the contract without even initialization in the very first iteration now what bardik is doing is he's writing this very first test and he already comes uh he already comes uh he already comes timechain into play so what we're gonna do is what particle really did is he compiled the smart contract so the smart contract is compiled and the types and typescript for the smart contracts already generated in addition to those types the factories for every single smart contract are generated in that case in our case we have a market factory that can deploy the market now the market factory has its type and the market has its type so when we're gonna uh when we're gonna have uh when we're gonna call functions on market we're gonna see we're gonna see both suggestions and errors if we try to do something that should not be happening okay so we have our first test already passing which is only deploying the contract and now we need to start implementing the actual functionality of the market so we're gonna pass two tokens to the market which are gonna be exchanged on our market and we're already gonna create of course we need to import uh an erc20 interface from well known and low okay and probably we're already gonna also implement getters for uh for the stored pointers so here we go a little bit long a little bit tricky but that's right and we're gonna create two variables which are gonna store pointers to these two assets that we're gonna try i'm gonna make them public i guess a little bit copy paste feels a little bit like cheating feels like cheating but i think you will forgive us yeah and let's make it public good all right now let's try run test i think we need to reorganize the screen a little bit yep running size and we expect them to file because we're obviously not passing the we're not passing the tokens to in the contract let's see if that's true well we didn't even need to write the test you can see when we compile the compile the times it already show us okay deploy obviously doesn't have the arguments that they supposed so now it's the time to implement token that's right let's implement tokens yeah so we're going to implement this one really really simply and really in a very straightforward manner we're gonna strike all the necessary programs of course we're gonna ask our uh contract it's gonna be a token we're gonna import it's gonna be a new erc20 token uh of course and we're gonna import an erc20 contract this time implementation uh not the interface from open zeppelin again good old open settling always there when you need it yeah our load jump and we yeah we're gonna call them erc20 constructor and your c20 passing the names yeah that's right and for the for the sake of the demo we're gonna mint all the tokens to the user to the deployer of the smart contract it's gonna be sender and let's pass him two thousand tokens like for example all right let's see so rich today is there anything yeah slash tokens you're missing slash tokens oh yeah [Music] that's very good friends okay so let's build it and it's gonna be a proper time to deploy it yeah so uh yeah so almost there we are now uh now that we have a token we need to deploy we're gonna deploy two instances of the same token one that's gonna represent kiwi one that's gonna represent blue and you probably already know how to do that you need to use token factory again um type chain comes very handy so yeah off we go almost there token factory being created and once we have that we can create two tokens now note in line 16 we have a we are using um biddler designers method that allows us to get on instance of the wallet that we're going to use to that we're going to use to pay for deployment and yeah remember about good all the ways always there for you waiting and yeah we need to pass parameters and let's see the passes so i think we're i think we're going to have our very first very first test passing and a second now let's see okay so deploy but we're not testing much yet we kind of deployed a contract well the test didn't fail so it seems successful so we're coming to the very first question to the very basic question what should the first test look like and very simple answer is it just should check if the contract would initialize properly so in our case all it needs to do is to see both um both variables what both contract variables was were set up so test is almost done and when we run the test we expect the test to fail that's fine we expect it to fail but when it does we're gonna we can actually jump to actual implementation so that example might seem trivial but actually this is a really important principle of the tdd method that you should and you definitely should uh write your test for the implementation and that actually implicates many many good characteristics in your development practices so yeah and i think that the implementation is already done so we can jump to the test and see in it and you can see builder is doing great work for you because when you run tasks it knows if you change the contracts or not so it's building contracts only when you need to boom the very first test is passing so off we go to implementing the contract so let's write the first function i think you remember from the presentation we have a supply function and the supply function that's right it's gonna add liquidity to the contract and as you can see the flow is gonna look like this for the whole demo and it should look like this uh in the whole process so you first implement the signature of the function compile it generate all the typings and then jump to the test and then continue with the implementation yeah so now the question is what our supply function gonna do well it's gonna add liquidity to our market so it's gonna basically just transfer two tokens to some amount of the two tokens the kevin plumes to the smart contract how we're gonna test it very simply we're just gonna call the supply function send a couple send a couple of tokens here and there and then we're gonna check if actually the balance of the smart contract has changed uh and is proper now when transferring your c20 tokens always remember about calling the upper function otherwise well it's gonna fail and boom off we go almost there we're adding the first marcher which checks if the balance is there a quick quick trick a a little detail is we have a expect to equal it's fine on the left side on the x back side it's a big number and on the right side it's a number of a string because waffle already does all the conversions on the fly for you so i think the test is written we run the test and see if it's gonna fade and if it does it's good it means we can start with the implementation and it is failing and it is failing for the new reason so so we're starting with emulation and it's gonna be really really straightforward it's gonna be just calling the transfer from function two times so one first time on the x token we're gonna transfer tokens from the message center from the token zoner to the address of the market and we're gonna pass the x amount and also we're gonna do exactly the same for the y token for the white token and gonna just pass y amount okay here we are let's see if that is going to succeed so i think we're cutting now for almost 10 minutes and if the test gonna succeed we actually have a working initialized contract with the very first function i know there is still plenty of things missing but let's now jump straight to the second function and it's gonna be a trade function which is gonna exchange our assets so we start with the signature we're gonna pass one argument you need to type it um yeah that's right and we for the sake of the simplicity are just gonna pass one argument which is gonna be the amount of tokens we intend to sell and we will allow only trading one way yeah and real solution you would need to have function that traced both ways but again just 15 minutes quick demo so we're going to simplify a couple of things i think uh we almost there so we're writing the test for the second for the very second uh function out of two so you see that bardec has to build a contract because the environment didn't see the types so that's little annoying thing here but it's worth investing this extra couple seconds into the compilation because it really helps writing the test layer well the trade function is very similar to supply function the only difference is it doesn't just receive the tokens or two types it receives the tokens of one type and send the tokens of the second time back so we can you can see the test doesn't differ that much and as you see that you're gonna see in a moment the implementation is not that very different as well well you know what we're doing just define all day long we're just passing tokens around right so that's exactly what we're going to do this time okay we suspect you know so yeah so we oh let me just right test okay so we expect that the exchange is gonna gain 100 tokens one time 1000 kiwis so exactly the amount that we passed to the exchange and we expect the balance to drop below the 2000 of the second token so the task is failing for a good reason so we're implementing yeah so the implementation goes as follows first we transfer the tokens that we intended to sell again to the to the market contract and then we transfer from the exchange so the exchange is gonna call the transfer function on the token and yeah what amount is gonna be so we're gonna go with something pretty straightforward and really simple just because the time isn't our best friend today and it's gonna be a ratio of the token white oak and supply uh gathered uh white oak and liquidity gathered on the address of this uh contract this market and it's gonna be divided yeah it's gonna be a ratio so we shall divide it yeah and i know what you're gonna say that not using safe math is not how you do things that's fine this is not production demo this is demo that shows you how you can code in the hackathon but also if you have more time it's a very good way to actually build a production code both ways you very quickly get into something that is working and that is something that is very stressful so boom guys we did it it's already working it's uh it's the erc20 market i think we still have a little extra time so let's let's let's do something extra there is plenty of details missing so let's start with good old practice that you know every every single important method that you call on the blockchain every single function supposed to emit an informative event so that you can gather the data outside of the blockchain analyze them so we're gonna start again with a failing test we're gonna uh assume that supply is gonna emit an event we wanna see it failing before we actually implement it i have a hint i have a hunch that's gonna fail and it failed and it failed for the right reason that's right so right now we're adding the event to the contract it's gonna be against pretty simple it's gonna be just a supply event with two units passed that was gonna that's gonna signalize and in the supply function that's right we're gonna emit that supply with x amount and y amount okay so that should the cool thing about pro programming is if you make a stupid mistake instantly the second person can see it we're running the test now and uh let's see if it's gonna be successful ah i think it's gonna be the same is it yeah yeah i think any second now three two one and boom it's working and we still have time so let's implement something extra so we don't really have a lot of we don't have any validation so let's that's the validation in reality validation code in smart contract open times as much as half of the code or even more so let's do that let's um let's implement at least one require we're gonna we're gonna do a very simple require for today we're gonna focus on reverting on uh trade function if it gets your token obviously if someone is sending zero tokens to the trade function that sound sounds like an error so we have a we have a code uh let us see let us see if the test fails and if it fails for the right reason it should let's see it fails and it's very for the right reasons so now we say we require x amount to be bigger than zero and if not then this is the message we would like to uh yeah it's a double quote automatically fixed let's see if the test will pass right now i think it's gonna pass what do you think about it yeah i think that we are doing really good actually we could have just just now started all dabbing all these like bells and whistles some fancy formulas for prices etc but for the heck of reasons i guess we're good i think we're good there i know what you think guys there's plenty of other things using site mod all the validation and all the stuff if we only have another 15 minutes i'm pretty sure we could look at this majority of that yeah and actually if we did this in only 15 minutes imagine what you can do in half a day or one day of hackathon i think it's a month actually or something yeah so this way the other quick recap what happened we use waffle waffle has all these great marchers the two of them you've seen so expect to end it with rx would allow us easily to easily check if particular events were emitted by smart contract expect to revert with which allows you to see if the function reverts it and revert it for the right reason and there's plenty of others i'm gonna just show you one more which is expect to be called on contract with which allows you to check if your original function that you called also did other calls to other smart contracts and if they were done with proper arguments and waffle also have a plenty of other features i would like to raise your attention just one more which is mocking mocking allows you to deploy dynamic mock a smart contract that is a mock smart contract on the chain and dynamically from the smart contract i'm sorry i dynamically from test allows you to define the behavior of the define the behavior so that you can easily test in isolation we also use piddler for compiling and for testing additionally we use biddler evm which is the fastest test evm that is available on the market video have plenty of great features uh they have automatic verification on address scan with single command you can upload your code and get into verified and get it verified on etherscan very useful for hackathon it has console log for solidity which allows you to quickly develop things and i want to see if there is a big announcement coming next week so if you do anything uh related to defy or anything related to touching smart contracts that are already deployed on the blockchain well stay tuned it's coming it's really gonna be uh yeah the presentation is gonna be available online uh so we put all the links here and i think we still have a couple of minutes for questions hey american uh we go i will uh i'm just going to kick start this so thank you so much for this amazing live session i'm glad that we were able to get something done live without murphy's laws coming in place uh we have a couple questions coming in so anybody who's listening on the chat feel free to ask the questions right on on the chat itself but our first question is to your knowledge is there a good step-by-step visual debugger that can be used while running tests and uh if so what would you recommend people do and uh the question also points out that uh the one for azure uh needs ganache to their knowledge here's the thing there might be but we are so used to doing teflon development that we never really use debugger we never actually even use console log i think maybe occasionally because we write so many tasks that you know when they fail we almost instantly know what the reason what was the reason so on one hand we would like to advertise like it's a really cool way of creating smart contracts on the other hand we encourage you to explore because i think some people are doing some interesting things we just never kind of look into them awesome so uh we're uh waiting for a couple of more questions coming in i just have to relay them with our live stream sync and lag um what other tools do you recommend that people try out if they are interested in just learning or being a better solidity developer well i think the stack that we presented is very good for actual coding whether it's on hackathon production if you just want to get into the thing i think there is uh uh remix right next yeah and there is also what's the second one i think there is a um now any on ethereum domain there is some kind of uh what was it i don't remember anymore yeah uh we can try to find it quickly but there is a so so there are great tools online that we encourage you to explore and maybe we will just leave it somewhere on the chat yeah but there are again like online tools but when it comes to the tools that you can actually use in your local developer environment i guess what we've shown is this state of the art for today like in our opinion i guess and we encouraged to explore biddler and we're encouraged to explore waffle and all the other tools because there's plenty of features that help on every in everyday work yeah great um the last question we have is uh what do you think is currently missing from the ethereum developer suite right now and what will be your wish list of really great dev tools that would make everything easy for everybody well i think nothing comes to mind i think what we i think there's a lot of polishing on features that we already have um so for example tests are running pretty fast now but i think they could be even faster i remember originally uh you know tests were much much slower i think uh also uh yeah we were just discussing internally the watch mode would be interesting yeah we also thought about um some some deployment tool that will help you organize your deployment scripts maybe in some declarative manner instead of the imperative one like similar to the tools that you see in the devops world we think deployment get much more complex that it was a year or two years ago also so deployment is potentially a space yeah awesome we got one more question on our live chat which is to your knowledge what is the best way to integrate um your contract with existing vp protocol without directly testing on production uh the answer is you need to wait for a big announcement from from vidler that is coming next week so definitely follow those guys yeah and definitely this is going to be the answer but we will we don't want to we don't right now we don't want to spoil it for no yeah from uh from norman guys so now mclaren is the company behind middle earners doing great job developing the this whole bittler solution and also the whole ecosystem around it no that's wonderful we uh we can't wait for the bible team to also announce this on our discord they've been a great help to read global over the last few months so um with that i want to thank both of you for taking us through this live demo and giving us time to uh to showcase how you can actually really do good 