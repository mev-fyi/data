command to start jsn so jsn is a combination of is it is a network of of relays and a smart account that coordinates this release so it shows uh if uh like which relays are currently active and which are not and this way clients can find the relay they need interactively and in a decentralized manner okay so after uh after we add this uh now we need to actually add support for gsm to our smart contract so now this is surprisingly easy so first you add a base really recipient and you inherit from it and now you need to only implement one method it can be a constructor but we don't do it as a constructor in this demo so yeah so you add a set trusted forwarder and let me talk a little bit about forwarder here uh this takes a little bit of history but uh your contract will have to trust our system to provide it with information about who the real sender of the transaction is and in order to make it the impact on this uh integration on your security smaller we separate the code that does a signature verification to be an individual contract so uh by integrating with json you don't put any trust on any of the json contracts you only trust a single contract that is very small and it will be strictly audited by everybody uh that is called forwarder and this is the contract that protects your contract now you do the last and the most critical thing for your contact everywhere is where you use message.sender you replace it with a method msg dot underscore msg sender from base relay recipient so uh i hope it's clear so far what we did here uh so this method will uh behind the uh extract the actual sender and users don't really create a transaction they sign message for relay servers to broadcast and release servers create an actual transaction now uh of course uh this magic happens hey i think we're gonna have to take a moment here and see if we can get get him back on just stand by sorry about that everyone hey we lost you there a little bit alexander are you able to um reshare your screen zoom just crashed for me let me do you see my screen again yes perfect yeah when when when did you lose me we lost you about two minutes ago two minutes ago wow okay i've been talking with myself for some time here uh where was i two minutes ago it's hard to say exactly right so i've been through capture the flag i've been through replacing message center with underscore message sender okay and i have been to deploying with truffle migration i didn't all right i've been talking a long time uh okay so i will start again on the capture the flag thing uh so we need to inherit from base really recipient and it has to implement a method that is called set trusted forwarder because as i have been talking probably to myself uh in order to minimize uh security impact of your integration with gsn we created a very small uh contract that uh checks this user signature and tells your contract who the real sender of the transaction was because we separate sending the transaction on chain and sign in a message so users end up signing messages for uh relays and really is create transactions so this is why you need to replace underscore uh like message.sender which is a solidity construct this underscore message sender which is a method defined in base video recipient so this is what you do and now you need to deploy and configure it so uh forwarder will be deployed by our command line but you still need to set trusted forwarder on your contract so these are the steps that you need to integrate you need to replace all places where you do message dot sender with our underscore message sender and you need to send the trusted forwarder address which will probably be the same address across all networks and it will be audited by anybody who wants to audit it and it will be a piece of shared infrastructure we have an erc 2770 describing it but it's uh it's very simple so uh and next thing uh your client code needs to know how to interact with uh uh with a relay network so uh you need to replace your web3 provider that you are probably using in your dab is uh is the one that we provide as part of our library so i will bring the imports here so you need relay provider and you may need this method this is auxiliary method resolve configuration and you will want to learn the paymaster address from deployment that our command line does and after that you have a similar structure where you create a website provider at some place you replace it with a dropped json provider it drops an external provider and it turns to our relays uh am i still online can you still hear me yes okay great uh yeah i will check that every once in a while uh okay and i think at this point we should be good to go let's uh let's see how it goes and so what has to be done is we should start ganache we now do the new commands this is yarn gs and start okay so this command should bring up a relay server okay and let me just to make sure oh now i shouldn't do it right now uh okay let's uh let's start right now yeah start okay let's hope for some luck here no luck here here the demo effect as i was expecting let's try again see if i did everything correct i make mistakes foreign i think it's better okay it is better now let's let's head to localhost 500 000 and now we go let's make a mask a little bit all right so now i switch to account it does not have any ether and let's see that we can capture the flag now using the gsm so we see a pop-up looks different because we are not creating a transaction we are not paying fees we are not sending ether uh we are just signing on this message and each field here describes something very relevant to our system but i won't go over them right now we like everything and we sign and we see that in a few seconds the flag was captured so we just interacted with unchained card contract from an account that doesn't hold any ether so we believe this is a very powerful point where users who only have keys can start interacting with blockchain immediately okay so at this point we transition to step two of our workshop where gas does not come for free uh unless you're working on ganache on a local test net or any actual test net so on test nets we will be deploying contracts that are called paymasters that are responsible for paying for users transactions and uh these contracts will be across all test nets but this is not a solution probably for your dab because you cannot pay for everybody uh because like your funds will be drained by somebody who like who wants to maybe ddos you or is able to steal those funds so you need to have some like a firewall right so you can decide who gets and who doesn't get transactions for free uh and you can implement arbitrary logic there but the uh the example we are shown here is the simplest we could come up with whitelist so you just create a list of contracts who can interact and then they can interact and the rest of them cannot so in order to add support for that uh you can write your own custom paymaster we are providing a library of paid masters ourselves so in order to add them you you can run again yarn add open json pay masters and again it's going to take time so i will pretend that i did hear it here and i head back to my uh people and i just paste it here uh now uh next thing is again specific to our current state we are using a truffle so normally you would probably not need to do it but uh travel does not compile contracts that are not directly imported by your project so this is just a technical step that we need to import anywhere in our project the whitelist paymaster from our repo this is a paymaster will be deploying and using now this paymaster has a bit more configuration to it so i will paste this code here uh so this is a new part if you are wondering so we deploy a paymaster now and we also need to set relay hub address on it and we add a sender with whitelisted so let me paste my address here for a change so okay so account 2 will be whitelisted let's do it this way uh okay so this account will be white listed any other account will not be able to get free transaction uh all right so also uh our ui now are you with me am i online yep you're all good okay great uh needs to know uh the address of this paymaster as well so we will be using it uh so we just change which paymaster we are using and we tell our configuration that we are now using a different pay master this should be all you need in order to add support for a custom uh paymaster let me stop everything and start from a clean state okay so we restart ganache we start jsn and start serving our webpage [Music] and a few moments later yeah they're good to go me again we go it around so it doesn't get something cached or whatever it works all right i am having problems with with something i don't even know oh right i made a horrible mistake here shouldn't have removed this line sorry for wasting your time interactive copy pasting is a difficult topic starting from scratch again let's try again this should work okay uh and let's see i will first try to use account that i did not whitelist and i will click the button and hold on a second a drawer could you remind me what was this issue uh i didn't look at the code did you resolve did you ever set a forward yeah yeah i lost some changes said trusted forwarder right right okay also if you're following uh you can uh try all of it uh in the repo that uh we're showing right now there are two pull requests so these pull requests show you the actual changes that need to be done in case you missed something or skipped something over whether it was offline let's see now okay now it seems to work and i do have the pop-up from jsn that asked me to sign for a transaction but once i sign it i get the error message directly from my paymaster that says sender not whitelisted because i did not whitely this sender i did whitelist a different account of mine so i should be able to switch to the second account and this is the one that i did at the whitelist manually and just for certainly refresh and in this case i really should be able to interact with blockchain and capture the flag so with a few hiccups we showed the process of uh integrating gsn with a paymaster that allows everything and then a paymaster that allows you to be in control of who gets free transactions and who doesn't uh so uh plea please give it a try uh you can ask us any questions at any time and it's let's see i guess any questions am i online yes i see one question from someone named like client if you were to estimate how much of gsn is on chain code versus relayer work what would you say um all right so uh what in terms of like what is the measure like how much of json is on chain okay so unchained code is a big part of it uh but we try to keep it simple and small so the on-chain code is responsible for relay registration handling stakes and penalization which also gets you some code and relayer is uh like relayers can grow like uh relay hub is our core contract and i don't expect it to grow and relays can get additional functions that like will make it bigger and maybe more useful more resilient and the on-chain component i think should remain there like the kernel of the system and think it's maybe a few hundred lines of solidity code for relay hub core uh i'm curious to know what it would mean for json metro transactions became available at level one okay uh the transactions are available at level one of ethereum mainnet uh how viable are they they are somewhat viable for some use cases uh in other use cases they do have an extra cost because you go through a number of contracts that enable the system so uh like of course you acquire user you wouldn't acquire any other ray because uh like you probably would you lose a person if you send them to an exchange saying buy some ether and come back to my app but if you need people like users to make hundreds of transactions uh it depends on your cost of uh yeah alex miller than that what but the question is whether a gsm should it be in the layer if you understand correctly should it be available at the layer l1a feature and maybe it should maybe it shouldn't but it should surely take time gsn is here to add a feature that will take a long time for network like ethereum to add it also add a new business model for a market for paymasters and for relayers it's not something that is so easy to add to layer one network right like on a protocol level here can can am i being hard yes yeah um oh i i will say that uh we're actually hoping to see protocol level changes that support meta transactions um it will reduce reduce overhead and um you know make things a a bit easier on multiple fronts potentially um but yeah we're currently just doing uh the best that we have with the current rules of contenders um and we're we are looking forward to seeing changes that will make things a little bit more efficient it's just that we didn't start out by trying to change the layer one protocol because that has been very hard historically and it's sometimes easier to get traction on that once you can sort of um prove that you have the right way to get things to uh to work and all the pieces come together and yeah that's kind of it in a nutshell it's a little bit speculative because it depends on exactly what type of uh protocol changes eventually make it into layer one um but this is something that we're you know hoping uh will happen sooner rather than than later um yeah oh we'll see there's a couple more questions from like client in the chat i think it's probably easier if i just go for voice thanks for unmuting me uh yeah i mean you know i think that you guys have done the right thing i think that a lot of teams face similar problem people want a solution today and they don't want to wait for a network upgrade that solution to be available and so they work with what they have but gsn is you know probably the most robust relayer system that we have so far and so i think it's like really important to know from you guys what it would mean to have meta transactions implemented at the layer one would it what it what do you need available in these sorts of transactions for it to be beneficial because it's it's useless if we implement to layer one without being able to ask the people who are going to be using it and make sure it's the right thing and maybe that's not something that you have the answer for on this call it might be something maybe we should chat again at another point after you have time to review the e but i would be curious if you have any like off the cuff thoughts yeah so my up off the cuff thought is that uh devil is really in the details um and uh in general we are very supportive and we would like to see this happen as soon as possible um we do see tsn as a prototype for an extension of the ethereum stack um you know but getting consensus towards that is a big part of why we are working on on gsm maybe it's easier once you have uh you know or more use cases that need it and it's kind of easier to get to that to bootstrap that um using the using something like a slightly less efficient uh implementation that does not require a protocol level changes and then okay this is useful now but let's make it more efficient so let's see what is the best way to add it to layer one um and the right place to have discussion is probably um just uh you know um you know and let's like set up a group and and discuss it and maybe put together a proposal and get like you know as much feedback as possible from different stakeholders this this is what we try doing for the previous cip we tried getting as many people involved and this is sort of the recipient meta transaction recipient standard and it wasn't easy like it was a lot harder than we expected just to get everybody to agree on that what that should look like but hopefully we learned a little bit about the process and you can do it more efficiently next time around okay i see another question by derek yes can it be attacked yes it can be attacked we did a lot of work to try to minimize the impact of such attacks gsn in a way is a system where there are relayers there are pay masters and there are recipient contracts and and we try to build a system where neither trust anyone else you trust code so you have a minimal forwarder code to trust you have the to a lesser extent really hub itself to trust but otherwise most components don't trust each other uh there is eap 1613 which is a bit out of date but the entire but it covers most of the possible attacks and how we mitigate them yeah but specifically to add to that because he's asking about also denial of service um it really depends on what you mean by a denial of service attacks uh different different uh scenarios have different uh defenses uh the ones that are hardest to mitigate are gas various grass gas greasing vectors that we put a lot of uh work into um and and it's it's impossible to to get the exposure to zero but it is possible to do a lot better than a naive implementation um so the goal is is to have a meta transaction system where the asymmetries are tilted in the favor of the defense and not the uh the attackers and time will tell if we have the right balance but um we think we we can make the system uh uh as robust as it needs to be for use in the wild yeah uh there is a question about uh ways to batch many metal transactions on layer run so uh we did start to work on uh on the concept where you can batch multiple transactions uh it did not involve a bls or snore signatures but i think this is one of the things that can be added on top of json as a part of a of a dedicated forwarder uh that can uh later be used by uh dabs that want to uh support batching better transactions which seems to be a popular approach this time i will i will add to that that we we were initially looking into including batching as the core feature of the forwarder and we ended up realizing that it made a little bit uh more sense um to keep the forwarder as a minimum viable implementation uh with the understanding that it would be possible to uh to inherit from the forwarder and implement batching um elsewhere um and then this is not necessarily going to be the only trusted forwarder but oh we did we did uh we ended up you know trying to keep the order really as simple so simple that you can just you know read over it and understand how it works and not have to think about um things like uh the implementations of of batching but uh you know we we we do agree that that will be very useful for some use cases and it's also something that we designed the gsm to support yes so another question from michael does a gas master layer handle fee bumping for stock transactions is it's their nodes yes a relayer server handles bumping the fee for transaction it sends both management transactions that are not requested by client and the relay transactions with a visa uh know that if client signed on a gas price this is a gas price client like the paymaster will pay their layer so at uh at this point if free layer needs to pay more for gas to get its nons unstuck relayer can be at loss on this transaction so relayers have a way to indicate the minimum gas price they are willing to accept so this should not happen often it may probably happen only in a huge and long gas price spikes if this happens i i will i will i will add to that um that because the the different components are designed not to trust each other then paint masters don't necessarily have to trust the relay servers even though that could make things a little bit more efficient but it would also uh change or weaken some of the security assumptions that we're making so this is why we're not just letting relay servers bump up the transaction fee that paymasters are liable for because ultimately the pay masters they're the one paying for the transactions or they're the ones committing to paying for the transactions and the relay hub contract in the middle enforces that but relay servers they don't want to have to trust the the paymasters um so um the paymaster says in advance okay this is this is what i'm willing uh this is what i'm you know i'm willing to uh to pay the relay server relay server is is uh is assumed um to accept that in in advance this is something that they they can you know perform the transaction with and if not not service the the transaction and if they decide to accept um to accept this this transaction uh then um you know they they've done that because uh the it's a good deal for them like alex said it would only maybe break if if something has changed very dramatically since they evaluated the profitability of the transaction and when they actually execute it in which case they can unstick themselves but another mitigation that he's implemented in is multi-worker support for relays which means unlike in gsn1 where every relay just had a one worker address and that meant that if any transaction got stuck on there the relay server was stuck indefinitely with multi-worker support you have multiple addresses tied to a single sake and then that that is also useful for preventing relay servers from getting uh stuck because of uh you know gas spike changes it was one of the things that was really important for us to um to figure out when the network became a lot more congested has happened recently and this would also really help for where we expect most of gsm usage uh to end up which is on on layer twos uh where uh the the scaling requirements and the transaction throughput you know it does actually require multi-relay multi-worker support relays so hopefully hopefully we've gotten the right balance so uh alex do you want to show on um are we planning on showing anything else or asking uh asking people if they have questions regarding integrations that they're considering or yeah i would love to hear from people if they are considering or tried or failed uh to integrate with json and like their concerns and address their issues uh if you have like some uh something you want to show it's uh also great so did anybody try to integrate with json or similar service already uh alex everybody is on mute so it'll be hard for them to respond they might be able to send a message on the chat but they're also not allowed to actually start working on their um other projects until friday nobody nobody's going to admit starting before friday that's a violation of the rules they can't yeah right they're doing it they have to keep it a secret can't catch them so um if we don't have anything else though we could just do a sort of a brief oh uh we can just do a like a brief overview of how the gsn architecture works so people when they get started they can um they have a like a you know a ballpark idea of what the gsm looks like um and in which case if that makes sense there's nothing else i can share my screen and just go over the the architecture diagram yeah it makes sense okay let's do it okay so great so can you see my screen alex yes yes i can see a screen all right so this is this is uh the architecture uh for the new gsm uh uh two system uh was uh deployed very recently uh the mainnet and uh for the assessments including rinkaby and robston and uh essentially uh we're showing what a transaction looks like when it goes to gsn at different levels so you know at the highest level you have a client that doesn't necessarily have any to pay for gas but it's a gaseous client and it's interacting with a recipient contract um so to make to make this uh magic work the client um especially needs to create this meta transaction a meta transaction is a transaction that someone else pays for and the client it needs to find a relay server this is a third party that it will provide uh the transaction to and then the relay server agrees to uh to pay for the graph by certainly wrapping up the client's transaction in a meta transaction this is a transaction inside a transaction that's kind of the trick the meta transactions are based on and what the gsn does is it helps it helps uh facilitate this process so um by by default the preferred there is sort of going to be a preferred workflow for that they they set up their own relay servers and their relay servers provide service for their for their dev contract without any charges uh we don't stop there because then that would be a little bit centralized and if uh your relay server goes down then your front end goes down so we we've implemented a wonderful and also one type scheme where essentially every dapps relay servers also registers into a registry of relay servers where it agrees to service the users of other dapps in exchange for a transaction fee that is configurable and then what that means is that now taking down the front end of any depth is as hard as taking down all the adapts that are using the system so we've kind of aggregated the availability guarantees that the system provides but without complicating how much you need to understand up front because you don't need to understand how your client would look up uh a relay server from the decentralized registry as long as your relay server is still working um and you also would need to understand like you know what your what the transaction fee is going to end up because you won't pay your own relay servers a transaction fee or rather your paymaster so we we find a relay server whether it's you know our relay server or a fallback from the registry and we passed the transaction and as part of the transaction we say okay here's the payments or contract that is willing to pay for the transaction and what the relay server does is it then executes the transaction off chain to see that um when the transaction is fully executed it was reimbursed for the transaction and it did get you know either rebalanced uh so every relay server has essentially an external account or just normal accounts from which it's it's um it's paying the immediate gas fees for transactions that it it relays uh and it needs to get that back so the pain master contract provides refunds reimburses the relay server for those fees so to make sure that happens and we don't want relay servers to have to know about and trust a paymaster contract um then they're part of the functionality of relay server is just executing the transaction object which is seemed very similar to uh how you would execute a view function you know it's not actually a view function and then once the relay server says yes it is going to get reimbursed this is a good deal for it then it actually assigns a transaction it immediately returns it back to the client the client can also take this now it's a valid ethereum transaction it can broadcast uh this transaction itself um so the relay server is also going to do that and then uh you know once this transaction is mined it will call into the relay hub essentially this transaction calls into the relay hub contract everything that was before uh executed off chain is executed on chain and the final destination before the recipient contract is the trusted forwarder contract um which essentially just uh you know it's a it's the minimal minimal uh minimal contract that uh that includes the logic for verifying the signature of the client so that's the only thing you're really trusting when you're depending on the trusted forwarder is that it checks the the signature it parses the transaction and checks the signature from the client uh correctly um and then if if the signature works out um then you can you can get the you can get the message sender um from from uh like the message sender function and not the message.sender uh member so and and that's the only thing as a recipient that uh that you need to be concerned about you know the really hub does provide guarantees for other participants of the system you know the relay servers they they trust the relay hub instead of having to trust the pain masters they masters trust the relay hub instead of adjusting the the relay servers um and this is this is uh sort of optimized to create the most centralized system so some apps they won't be able it doesn't make sense for them to run any infrastructure example is you know a betting betting market and that is considered illegal in certain jurisdictions so they just developed the app and they completely rely on other people to run the infrastructure like relay servers so they in that case um their pay masters even if they just subsidize users cannot assume that the relay servers are are good relay servers could be part of an attack and the same for relay servers anyone can it's a permissionless system it's designed to be permissionless from the bottom up but still be as simple as possible and minimize security risks as as much as possible so you know we essentially took a long look at all the things that slowed down adoption for gsn1 and a lot of that was the complexity of the system that it was monolithic that recipient contracts had to include a lot of logic and they had to subsidize the transactions or that was part of the assumption and because we've broken that apart who pays to the transaction is separate from who receives the transaction we can have things like tokenpaymasters and tokenpaymaster they don't subsidize the transaction they if you have any rc20 token that can be exchanged on on unswab for ease a paymaster could make you know it's it's it's payment it's reimbursing its um acceptance of the transaction conditional and you paying it agreeing to to pay the um um the paymaster and tokens so with an arrangement like that essentially now any dap can plug into a token paymaster and a tokenpaymaster lets all the gas fees be paid in whatever token the user has so now if you have die for example you can just do everything in die and this also opens up other interesting possibilities so for example one of the things we're really excited about is you have privacy use cases where if you want to withdraw from a privacy unit from a mixer like tornado cache you would usually need each do that because otherwise how would you interact uh with with a contract and in this case you can sort of commit to paying for the transaction further withdrawal from part of the withdrawal amount um so or yeah hopefully this this opens up a range of possibilities and we do expect most of the usage to end up on layer twos because that's where we expect most of dapps um to eventually uh live for uh for you know gas gas few reasons um but but uh this this will be uh something that you can use on layer one for any purpose all right let me just close the unshare my screen or ask if there are any questions maybe before i unshow my screen i can just um let me see if there are any questions are there are there any questions regarding the the architecture or the system or something was not clear can explain it better maybe oh okay well i think in that case maybe we're we're done thank you so much you guys this is a great workshop really excited to see what you guys have done and hackers what you all will build using gsn thank you heather thank you thank you very much thanks guys bye 