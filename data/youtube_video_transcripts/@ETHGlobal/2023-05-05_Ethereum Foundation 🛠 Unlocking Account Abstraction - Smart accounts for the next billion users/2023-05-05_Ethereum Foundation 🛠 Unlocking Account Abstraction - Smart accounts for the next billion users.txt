foreign [Music] I work with the ethereum foundation on the account obstruction so uh I'll start by saying what is account abstraction what we abstract and why so before talking about account abstraction let's think what is an account if your account first of all of course is an address uh where we put tokens and if these uh whatever this is our account obviously we have an Authentication which is is a private care ecdsa private key this account can execute stuff like send transactions send if send tokens whatever and it pays for gas it pays for guys using its own ethereum balance and all of these is defined by the ethereum protocol which means every node on the system knows it know how to do it and do it exactly the same like any other node so what we abstract what we try to abstract okay basically almost everything the account itself will become a contract so we have the contract address um the Authentication in order to abstract it to extract it out of the system is a method call it's a method called on the account we call it we will hear it several times in this talk it's called validate user up and execution can be abstract to whatever you like okay we provide sample execute method or execute batch method you can add more if you like and the Gas payment we also suck that we have a paymaster contract which again once it validates the request it accepts to pay for this transaction and the cute thing about all of this is that this is all done without any change to the core protocol it is live on test Nets on mainnets today so what can we do with it okay this is a very short summary of what we can do authentication with a normal account you have exactly one way to authenticate that is sign a transaction by a single signer and if you want multiple we have problems or you have a MPC or something fixed but with account abstraction you can do a wide range of authentication methods you can choose different signatures and I gave you as an example two edge cases one of them is a simple gaming system where you want the browser to sign each transaction as long as it to this limited contract account so you want a very easy signing for gaming account can support that On The Other Extreme you have a corporate account in which different roles have different access some are multi-signed some allowed only to transfer if some have limits some allowed only to vote I don't know whatever so you can have account of any of these and by the way when I'm saying use cases these are use cases that can use account abstraction we don't support any of these you as developers are here to try and find use cases that you can do all of this stuff payments again it's not the account can pay for itself this is the default but there can be a paymaster and the use cases for pay Master again are endless I gave you two highlights as an example one of them is onboarding paymaster let's say someone have a dab has adapt and he wants to sponsor the Sam requests all requests I don't know of its users it's possible you can have a paymaster that will accept under some condition it can decide what the conditions are and accept this request and these requests are approved by the paymaster uh another example very common very thoughtful example is a token paymaster a paymaster that a will pay the transaction the transaction is a native token in Eve but the paymaster will make sure the user has enough balance will convert these users tokens into the native token and pay for the transaction so from the user's point of view he's paying with tokens but again it's not a system it's a specific pay master that decide if and how to do it other use cases you can do with the we think of are in a recovery mechanism the first and foremost actually most people don't talk about it at all is change your key think about that with normal a private key once you have an address it is impossible to be changed even if you think it might have been leaked you you're screwed you either replace it completely or go and hope that no one will ever use it with account abstraction account can support change key you know every normal web 2 application have changed password and is if you are even suspect that you're privately that your account address uh was a credentials were compromised replace it with something new other more complex recovery mechanism like social recovery can also be created like you trust friends to replace your account or do a Deadman recovery or other examples uh we have a full talk about half an hour a full hour of examples of use cases like I described here and more so you can look there this is a by the way it's a QR code of the presentation you have everything um now I'll try to Jive and explain the components we have with account abstraction the first component of course is an account an account is a contract that performs the logic of validation and execution we'll see it in work the second component we call it an entry point users don't see the entry points at all developers know about his existence this is the this is where the magic happens this is the on-chain contract that performs all the validation and it is trusted by the contracts a the next component again it's a contract is the paymaster as I said a paymaster is a contract that accepts to pay the gas fees of some transactions uh on the second row we have user operation actually I'm saying in this talk transaction interchangeably with user operation we call our account abstracted transaction we we name them a user operation so a user operation is equivalent of transaction you filled all the data in it some more data than normal transaction you sign it using your account signature whatever signature system it uses and you submit it the next component we have we call a bundler as we said we didn't change the ethereum network we didn't change the protocol they are still nodes to run the system but in order to put user operations on the network we had to add another off-chain component we call a bundler you can think of a bundler as a node we actually believe that in a production Network it will be run adjacent to a node it's a functionality of a node to put user operations one chain lastly the last component like in any ethereum decentralized network there is a mempool again it's a main pool of user operation not a mempool of a transaction and it is important to understand the system but usually and not interacted directly by users or Developers now let's look at the flow how a user operation is executed the big component here this is a my wallet is an off chain it's a thing of metamask or a soul wallet or any other wallet that they implements account obstruction and the wallet creates a user operation it has many fields as I said like normal transaction and several fuel new fields we'll see later but like paymaster and the signature depending on my account a the user operation is sent into the mempool like normal transaction but this is a user operation mempool the the bundlers are looking probing this a mempool and they pick up the user operations that want to put into the next bundle the next block they want to sorry bundlers as I said are off chain think of node either node it's a node with a special functionality of being for supporting user operation supporting account obstruction anything you ask Alex for you to use ethereum do you need to be a node okay the same answer whenever because a as I said user operation is a transaction a bundler is equivalent it's a little different but it's equivalent to a node so you don't have to be there has to be nodes in the system or there has to be bundlers in the system to support it now so the bundler picked up user operations and just like a node if you think about it a node takes a set of transactions validates that the balance is correct the signature is correct and the nonce is correct and then create a transaction the bundle does just the same it validates the transaction but the way it does the validation is a bit more complex this is the simulation phase it calls a method in our entry point which calls the validation function the validation of the account and the validation of the paymaster if both these methods say okay this is a value transaction that means the signature is okay it means the nonce is okay it means it has it will pay for the transaction someone will pay for it the entry point will validate it it's a call on the entry point it knows that this is a user version is valid so the next phase after validating actually each of these user operation it will go into the execution phase where it creates a transaction we call it it's a method called handle Ops it gets an array of user operations and it created an transaction with it and put it on chain what this transaction will do it first repeat the validation of each user operation because we don't trust nobody to do anything of chain we call the validation of the validation repeat exact same validation we did the bundle I did previously off chain and if they all succeed we continue to the execution phase we call the execute method of the account whatever it written there and then you can see that for a paymaster we also call what we call the post op a post operation so that a paymaster has a method called before and after the transaction the method before first validate and then it can do other stuff like you know reduce the user's tokens to make sure that it will be used and at the past op it will refund whatever the access that was not in use the account execution of course executes a transaction so this flow is done for each user operation yes the message sender is the bundler of the a entire transaction but a for each user operation the execute is an execute method of the account so if the account execute token dot transfer because I want to transfer Tokens The Token says me the account contract is a sender the transaction.origin will be the bundler the msg.sender will be the account yes the account is wrapped there are two gotchas okay I'll get them in a moment okay this is one of them yes it's deprecated then with the count of star sharing becomes even more useless there is no good reason all the good reason to use the X origin are actually wrong if you think you're protecting yourself for by somehow using TX origin you're wrong because it doesn't protect you so the way so if you want to block account obstruction or a Contracting account then use it go ahead but if you want to protect yourself against replay against Watts again you are not hey yes use message dot sender okay the transaction itself is paid by the bundler because it is the one who put the transaction on chain but the logic of validate user Opus we will see in a moment that the account is supposed to pay for itself so the account pays the bundler yes the bundler pays the node and as I said a bundler and a node the distinguish is blurred and they're usually the same entity so yes it pays for itself for the execution and gets an extra by the account itself that pays for the transaction no if you think about the incentive model of ethereum how why do transactions get included why do a transaction cannot be censored because there are nodes out there that eventually will take out of the mempool transaction the same is true for bundlers these are bundlers are not ours that we Define the spec we create a reference there are already five implementations of bundlers we are working on the code that they will work with the mempool yes it is still work in progress but the usable as they are today hey so again to recap a eoa against user operation as I said account itself with the counter press it's a contract instead of ecdsa it is secured by its own code to do the validation uh a wallet with normal account can do a single operation which is approved approve everything because you sign whatever it is with account abstraction you have custom UI you have custom logic in the account itself to do whatever you like mempool mechanism generally it is the same it is different object accounts and the block Builder is equivalent to bundler and a its verification is a little bit more complex because it does a view call but otherwise it does just the same now I go linked a little into the contract itself the only method in account has to implement is validate user app yes of course you need to do some execution but it is not we as the as we write the erc4327 we Define the interface the concrete interface between actually the entry point and the accounts how they call the accounts so we Define that an account has to have this validate user of method this method receive the user operation itself it receive the hash of the user operation that can calculate it but it we already need it so we pass it to the account itself and someone asked about payment missing funds the account has to pay its sender which is will always be the entry point it will receive the amount it needs to pay how much is already missing we maintain the balance deposit within the entry point if you have enough or if there is a paymaster you will get zero for these missing funds otherwise you have to pay at least this amount to cover your user operation this is that so this is the code of the base account it's a the base contract you don't have to use it but I think we think it's very easy to use it it templates some of several everything you need to do so we of course require the call is from entry point you will get griefed and some will steal your money if you don't do it uh we call the stop methods we'll see in a moment to validate the signature it will validate the nodes if needed and pay prefund is pay this amount if it is not zero back to my honor so validate signature is a the method I need pack validation data is a helper method needed for use cases like gaming if anyone want uh I will not go deeply into that but you can have you can Define that a validation is valid for a specific range of time like if you have a game and you want that your transaction will be valid only for half an hour from now there is a way for a wallet to convey that information back to the entry point it is not allowed to use directly the timestamp of codes but it it can return it using this method um so this is as I said this is the base account we have and we also have a simple account which is a concrete implementation that uses it and tries to emulate an eoa as much as possible it uses simple signature it uses the same signature using a ethereum signed message so that you can even use metamask sign message to sign it so this is the actual code of validate signature it takes the user operation hash it adds the single sign message prefix this is a open Zeppelin a helper it does say easy recover if it is the wrong sender it fails otherwise succeeds a little note about this method it can revert revert is also a way to say okay I failed we did add a different mechanism to the port a signature failure because we do want to be able to do the equivalent of each call you want to be able to take a transaction and call like you call the node you call each call you to make sure that transaction succeeds you want to be able to do the same with the to estimate or simulate the user operation before the user signs it and there is no way for us to tell the the account itself that it doesn't need to sign that we give it a transaction with wrong signature the Khan doesn't know it is called the it's very important in our system he doesn't know it is called off chain or on chain it behaves exactly the same so what we say is that if the signature is wrong it simply return an error it is the it is the entry point to decide which knows this is a simulation okay I return it even though it's a signature failure or is it a real execution I will revert this transaction because it's a wrong signature these are the basic execution methods these are actually very simple again the required from entry point so that only the entry point can call it it can be Enterprise owner because we make our wallet also callable directly by its owner without accounts obstruction and there is an execute batch we created which get an array of destinations array of a function and someone might say okay why don't you pass value here I said you are complete right you are free to take this simple account add a different execution method and use it the this is not part of the framework this is a sample sample account you can add as many functions as you like to the account and okay this is a the implementation of a base paymaster just like in account we have a template method of a validate a paymaster and a post-op okay these These are the contracts now the contrast can't walk alone each contract has to have a wallet that works with with the normal EOS you have exactly one account type so every wallet with work with that just one account type which is eoi with account abstraction we have different account in each account needs a wallet and by wallet I mean the desktop probably Chrome extension or whatever in the account is what is the contract so each account needs a contract so sorry each account contract needs a wallet to work with okay so to help a hackers we created the the project boilerplate a Chrome extension we call trampoline which can help you a create a new account hey it is inspired by tally how and metamask but it is written from scratch and uh So within this framework you can replace the account contract and you can replace the ux that works with it this is a ux that works with the standard a simple account so the basic component with an account API that gives a high level JavaScript apis we need in order to work with the account and it will we also provide three a ux react components onboarding is a weeks that will pop up when you create the account like if you want to collect some information from the user or nothing if you if you are silent you don't need to collect anything transaction is the ux that will pop up whenever you send a transaction and of course sign when you create a signature now a simple account is to implement several things in order to support a contract the first is the the init code because the very important part of an account is to be able to deploy itself so uh it is this a account API that knows it's a account implementation and know how to create the Constructor so it creates the contracts The Constructor signature now in order to create a transaction it meets first to get the nuns the next nuns it will be used again this is not some standardized it is the account to implement this method underneath and we need to encode the actual transaction once it creates a user operation with this method we need to sign it um again there's an onboarding which is an asynchronous ux that have a method to call if it needs to collect data in order to send a transaction and then the transaction itself can modify the transaction just before it receive okay it is called just after send transaction is called by the application the application calls and transaction this provider receives this transaction uh now this looks like a transaction but we convert it and create out of it a user operation that will look like a city come from the account and it submitted a into the blockchain so let's see how it looks here okay first of all in order to install it I'll need to disable my metamask enable developer extensions and where am I okay I'm here in the trampoline project I should do yarn start I already started it so I can do it and inside this trampoline project I will load this unpacked uh the I love the build folder it's a Chrome extension the Chrome extension is built as a framework it's innocent extensions so this is the framework that I want to create an account hey this is the first customizable page as I said this is the onboarding page you can put whatever you like here you can see this is the onboarding I can open it in a add if I want to collect more information the output of this is a context and this context is passed to the account to create this sample doesn't need any no it creates a private key it creates a private q a address and pass it back to the account nope out of this account I can see its address and it is not deployed a I don't have a sample here with a paymaster so what I will do is I will send little if so it can be deployed you can see how much it's a it's a it's a Max limit how much it needs to be deployed why it doesn't switch oh it's here I will send some if to it okay I hope Gallery will get it fast now okay good for the demo okay now I have some if in my account I can deploy it here but instead of deploying I want to send the first transaction I'm open uh I open etherscan this is a a pre-deployed standard greater sample and I'll be using this application I want to call this a set greeting I will connect sscan to my account it says metamask sorry for that and this is a extension pop-up connection request we will accept it and then we can send and I can put some message in again this is a this is again this is a stab sign-in account we can remove it completely or put if we want to collect more information now I see again the transaction data that I want to approve I could escape the framework can be set so you will not show this transaction oh it say I didn't pay just a second okay it means it is a little more expensive than what I passed it great for sample sorry already a lot of time okay they tell me we are out of time I want to show you some transaction let's so uh we didn't build it alone we have a lot of Partners who work with us a stock app Alchemy and others build the bundlers zero Dev candidates all wallet already built in effospot build some sdks and tools you can use a trampoline you can those sdks if you want more resources you have them here if you didn't copy the QR code before this is the bigger one so you can use we will be here outside if you want to ask okay question and thank you foreign 