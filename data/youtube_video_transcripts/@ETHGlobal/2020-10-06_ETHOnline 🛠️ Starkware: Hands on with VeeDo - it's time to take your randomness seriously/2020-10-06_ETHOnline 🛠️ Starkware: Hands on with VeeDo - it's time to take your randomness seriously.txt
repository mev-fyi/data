thanks so much for taking the time to join us today it's officially the first week of eath online which is exciting we have tom brand from starkware who's going to give us an intro on vidu so i'll let you take it away tom thanks um so i will share my screen and hopefully we'll see it and yeah you see it i guess yeah it's great okay great hi so uh hello everybody and um thank you very much for joining me today um my name is tom i work at starkware uh i'm doing product and research there [Music] and today we're going to discuss i'm going to present a video which is a randomness beacon based on vdfs and starks i'll explain a little bit how it works and then we'll see how how you can use it and hopefully some of you will decide to to build on top of it in the following game months so a few words about star wars so we're an israeli-based startup our mission is to bring both scalability and privacy to blockchains using a zero knowledge proofs technology where almost 40 team members did two rounds of funding and our first product is starcx which is a scalability engines for uh a layer 2 scalability engine and it's now live on mainnet since june together with our partners the diversify um scaling a self-custody exchange so this is about starkware and before we'll start diving into how vid works the main purpose of video is to generate secure and unbiased randomness so what do we use randomness for in in blockchain ecospace and i guess general speaking so there are a few applications that come to mind when we think about using randomness in ethereum or in blockchains the first one uh is just a a loader application assume users wants to buy some tickets and then we need to choose a winner we want to make sure that the randomness that we're using to pick this uh winner is is a secure randomness um nice example for this uh kind of application is pull together which are also also participants in it online um and we are working closely closely with them on on video and [Music] so this is lottery another application is uh proof of stake protocols or for example ethereum 2.0 so those protocols generally speaking require randomness in order to choose a set of validators and also to choose who is eligible to to propose a block and if this randomness is not secure or if an attacker can buy us this randomness then the protocol is is many kinds of attack can be done on the protocols and indeed east 2.0 is is using a vdf for randomness in its protocol another application which i'll describe shortly is gaming and for example card meeting so one of our partners is immutable and and one of the things that they allow users to do is to mint cards for for gaming applications i imagine magic the gathering so when i buy a pack of cards i want to make sure that the randomness which is used to pick what cards i get in this uh in this pack is is secure and unbiasable and that i truly get my chance in winning the uh a golden dragon or a diamond dragon or or whatever i want uh so this is for gaming um and those are all applications that are running on ethereum they use randomness and they have a need for for a better and more secure randomness um first walking is is a kind of idea that i hope that some of you will will will come up with the like at the end of this month and it's not something that i am aware of that is implemented at running but the idea here is to use randomness in order to to for example to help automated market makers to to prevent front running i think it's very exciting and we are at work um on on designing uh such a spec but i mean i'll be very happy to if any one of you choose to work on it okay so this is the motivation for why we need randomness in ethereum now let's dive into what is video and how it works okay great so it seems a bit intimidating but we'll we'll pick a part by part and you'll understand everything so this is a high-level description of the system uh here you have some off-chain service it can run in the cloud or in any server and here you are ethereum blockchain and and the general flow which we'll explain in a minute is a user wants to get some randomness it makes a request to to a contract uh on ethereum the option service pick the request generate the randomness and somehow prove to the user that the randomness is secure and correct and the user can use it okay now in the next few minutes i will explain the system and after that we'll take the footsteps of alice and see how we can use this uh system okay great um i don't know how i will see answers but if anyone has a questions i mean if anyone has any question feel free to ask at any time so the first thing we need to to to understand here is what is exactly a vdf um again i will explain everything here very briefly because it's not needed in order to use the system um feel free to to either ask questions or come later to the discord server and and we'll be happy to to to explain in more details so vdf stands for verifiable delay function and it was uh firstly introduced in a in a formal way in the paper last year by a bono a sorry by a don bono [Music] and basically what it means is we're saying that f is a vdf if it has the following properties first of all computing f is slow and second verifying f is fast um and maybe to some of you uh immediately one kind of this function come to mind and uh it is proof of work right it takes a lot of time to to find a solution to a proof of work but it's very easy to to to verify it and the question is can can't we just use it so the answer is no because we have another property which defines a vdf and this is the time delay that it takes to compute this function is sequential why is it important for us this time in sequential because if we know that this computation is sequential and we can lower bound uh the step of computation then we can get lower bound on the time of delay that this uh kind of computation gives us right so a vdf is is is a basically a way to to verify that a delay has passed and now we'll talk about how how we achieve it with those two building blocks so first we'll explain the delay function um i won't get uh deeply into it um but basically what as we said what we need from the delay function is that it will be sequential uh that it it won't be able to to to do the computation in a parallel way and what we choose as a delay function for our construction is a well-known construction which is basically obtaining the the cube root of x adding a constant and repeating this uh computation for t times um where and we work with field elements where p is 126 bit prime um and to the best of our knowledge or to the best of the the computer science uh community knowledge um there is a well-known uh lower bound to to this computation and it's not uh sequential and so we can get a well-defined lower bound if we if we decide what is t [Music] for those of you who want to get deeper on what is exactly the implementation you can check the reference implementation here it is in our public repo which is um you can find it uh at the discord and also if online i will post it um there are many details here but the one thing which is um interesting to see is that at the end the delay function is defined by those in nine lines and you can see that giving some input we run the same computation which is a cube square and then some scramble with the multiplication and constants for any iteration times and then we return x this is the delay function great um so now i understand the delay function uh feel free to to ask any questions about it afterwards um so now we have the delay function uh now we need to understand how we verify it so for this we have the start proverbs as i've said stark uh uh stark proofs and and uh proof systems in general is the technology that we developed at starkware um i will explain it in in in a nutshell and uh we will understand how it applies to our construction so proof system in general is is a protocol which uh um you have two players the approver and the verifier the approver wants to to prove to the verifier that some statement is correct and is able to generate a proof to it and the nice properties of this proof is that first of all the verifier does not need to to trust approver simply by verifying the proof he can know if the statement is correct or not um the proof itself is succinct so if the the approver proves um some amount of computation the amount of work that the verifier needs to do is exponentially smaller so for example uh in our case what we want to to verify is the delay function actually was computed correctly so if we wanted to to run the delay function two to the power of 20 iterations uh the verifier needs to do something with the order of 20 uh computation steps in order to verify it um so this is proof system descriptions in general and specifically we are using uh uh stark which is a uh there are many implementations for what i just described uh we're using uh the start protocol and here you can see some of its benefits i won't go uh into it but the main thing which are relevant to to our case is that the the verification time itself is is very very fast and also the proving time the time it takes to generate a proof is much faster than any other zero knowledge proof systems that we are aware of [Music] there are other things here just something uh interesting for example is that uh um there's no trusted setup some proof systems require trusted setup which which is um uh hurts the trustlessness of the of the proof systems but in starts you don't need it okay so we explained uh what is the delay function and what is the proof how is it related to the construction of vdf itself so the delay functions gives us the the slow side of computation and the stark proof allows us to verify it in a fast way because as we've said the verification is exponentially faster than the computation okay so now we have our construction of a vdf using a delay function in starks now we need to understand how we take this primitive and use it to generate randomness in a in a secure way [Music] right so this is what we're going to explain right now um so for this let's go back to our gaming example and let's say i won won a match and i and i got a surprise loot box and now i want to open this loot box but again i want to make sure that the randomness which is used to decide what is included in this loot box uh is indeed secure and unbiasable so i will have the highest i have a fair chance to to receive my share the way to do it is that at the moment that we we purchase the the loot box the randomness is not no and and then we initiate the ver the vdf um the first step is to compute the delay function let's say for example that for the amount of iterations that i wanted to to to run the vdf it takes about two minutes uh what once we generated the output of the delay function we now need to generate the proof so it will be uh users on ethereum will be able to verify that this is indeed the the randomness uh this let's say takes about uh uh half a minute and then once i have the randomness and the proof i can use it to open the the loot box knowing that the randomness i used is was unbiased or anything secure okay great uh so we understand what is vdf we understand how we use it to get secure randomness and now the missing piece is how how we interact um how we use this construction with actual users so for this we introduced the notion of a vending machine and i will try to explain what is the motivation and how it works um so i mean in our view it is inevitable to to to outsource heavy computations of chain for example if we would like to take the delay function that is used in our pdf and compute it and do a naive verification on chain it will cost on the orders of billions of gas just for a simple two minute delay [Music] so we must outsource the computation and have some kind of way to prove that the computation is is is correct in the same way that that i just explained now the question is how can i do it in a trustless way that both the option service which which uh generates the proof know that he will get compensated for it and the user knows that either he will get the the results for the request that he asked for or he won't pay so so we proposed the vending machine model which is a user request a result from computation and lock some funds in advance then some official service seedlings request and post the result and the proof and if the proof is valid meaning the result is indeed the the the correct result of the computation the options service can receive the payment which was locked and if no valid proof was was submitted the user can after some time lock uh reclaim the pl the payment okay great so now we understand every part of the system the next step is to to to show how we use uh uh the system itself but i think it's a good good place to to ask if anyone has questions i'm not sure how i will be able to see them maybe it means that there's no questions um okay heather is there any way i can see questions we do have a chat here in this zoom call and there are no questions right now derek says no please continue oh great thanks derek um okay great so now we take the the role of alice and we wanted to just receive randomness let's say that um me and derek made a bet and the bet was um i say that let's take the the the next block hash and generate a a randomness based on the block hash as a seed i'm saying that it will be even the result and derek said that it will be odd right let's let's see how we [Music] do this bet great so basically all you need to start is github and specifically our public video github so let's go there um i hope you can see but this is the public a video github you here you have your all the contracts which we'll go into in a second you have here the reference code of the the delay function that i've just shown you can look at it uh and there's a documentation um it covers what we just described um if you feel that something is missing here feel free to ask in the discord and we also will just edit um but let's first look at the the contract so um as you remember i go back here we have two contracts one is the vending machine and the other one is the verifier the verifier is basically an implementation of the start protocol on ethereum uh we won't go into it but what you need to know is that it holds the the delay function statement and it can either reject or accept proofs now let's look a little bit about on the vending contract um it's not a complicated contract and it has uh um three external functions which you will be able to use okay you can see it here the first one is the add payment function which basically allows the user to uh to make a request right this is the the first step if user wants to to get randomness the request is on a specific seed for example in in the uh what we and derek wants to to to understand is is the c is the block hatch and n ether is the number of iterations that we want to the delay function to run more interventions mere more security but more delay uh tag is is just to allow more flexibility to build the wrapper contracts around it we won't get into it but it is not get into the competition at all and the payment amount is uh how much you're willing to pay um so this is the the end function it it uh stores it and emit an event which we the off chain service uh catch and uh decide if we want to uh use it or not in the case that a request was not served the the user can reclaim the payment if enough time has passed since the payment was made specifically now it is a one day you can see it here okay let's go back here um so this is the reclaimed payment and in case indeed the randomness was not registered and the uh enough time has passed the user gets back his money and the last function is is register and collect so in in the happy case that a request was collected and a randomness was was generated the often servers can call this function register and collect and basically register a randomness as i've said before the randomness will only be registered if a valid proof uh was uh was the first to apply to the verifier now where do we check it um we check it exactly here we go to the to the verifier and and check if he is in a proof to this public input what is this public input this public input means uh i've started with this vdf input i ran for any iterations and i got this vdf output okay if this is indeed valid uh i register the randomness and the user can then uh uh look at the registered randomness it's it's a public mapping and and use the randomness for whatever is needed okay um was it too fast i don't see any questions in the chat uh so we can go uh one thing to note is that this is a vending machine erc20 so it is it knows how to receive uh payments in erc20 and when we deploy the contract uh sorry where is it um yeah i'm sorry so when we deploy the contract yes we define a specific token address and and the the vending machine accepts payments only from this address great so now let's uh go and um and process our bet uh so we go here at the at the bottom uh we look and we see exactly where the vending contract is deployed um note that uh since it is only deployed on roxton we will probably deploy it uh next week or the next week after it maybe next week on mainnet currently we only accept this amount of iterations this is pretty small and it is mainly for testing purposes okay let's go to the vending contract you can see it here now the first thing i want to understand is uh what tokens does it accept so i go to the read contract i see which token address is registered let's open it now what i want to do is basically i want uh to call um the function it's payment with uh the block hash that we'll uh get from from their blockchain in a second uh now for that i need to have enough payment amount so let's go just to show you how are we doing it on rocks and so this is a test net die uh it's pretty easy but you uh first of all um mint to yourself so for that i will connect my wallet and let's look at my wallet which is called hacking at random i mean let's say this will be very small but will be enough and now let's do approve to the same amount and we want to approve the contract to be able to uh to take it so we approve this this is the vending machine contract we approve it okay great now we have enough funds and we can uh do a ad payment right so the payment amount is one million the targets i've said is is not used if uh it allows you to to wrap it with other contracts and they can manage who is calling but for this example we won't use it uh and eaters as we've said is unacceptable right now is a this amount and the same let's go to the ethereum and let's take uh the latest block hash derek is this good for you that's hope it is uh take the hash he says yeah okay thank you now if you notice we need to convert it to you in so let's just do it for a second and sorry um great so this is the uint of our block hash let's see uh when we run it um and write again connect or what okay great what happened right now is that we sent a request to the vending contract um maybe let's go back here and and understand exactly uh what how much time it will take so so the first time it will take is the time the request will get mined on chain then we have the time for the option service to pick it it's quite immediately and then we have the delay function which is an extra time then we have the generation of the proof and then again we have the the when the transactions will be accepted back on chain so we did the first step here now this is happening in the background behind me um and then we'll get back a randomness and we will uh see who won um i think it's uh while we are waiting it's a good time to to i mean there's no questions but it's a good time to to ask questions if there's nothing i have there are a few things that we can still discuss okay um so let's see what happens here uh so we got the request you can see the event here it's at payment uh in in a few minutes we'll see the the event which says the log near randomness uh and we will see here the randomness this is not it um just to make sure okay thanks derek you're the best number one fan yeah yeah [Music] okay it should take probably two and a half minutes something like that okay two minutes have passed the provers are generating proofs um maybe one thing i i can discuss uh is why is it not good enough to to use the block hash as randomness and what uh and and how um using a vdf on top of the block hash adds a security to it so the easiest way to understand it is by looking at the roulette example right so um let's say that i'm a miner and i did this same bet i had now with the derrick i'm saying that the next block hash will be even and he's saying the next block hash will be odd now if is a miner put some money into this bed i can uh immediately when i mine the block know if i won or not and i have the chance to to to effect on it and and either discard a block which is uh not suitable to to the results that i want or to just try to to find another one what happens here maybe i will go to the example here so what happens here is that during all this time that nobody knows this uh this randomness because we have a lower bound on the time it takes to to compute this delay function um the cost to then revert it and either uh do something else or or find another block is then the number of blocks that fits in this delay function so basically if we have a delay function of uh two minutes it means that we added two minutes of reorg time that is needed to the security of our protocol now if we know that i know we are able to to reorg one block in few uh thousands of dollars uh reorganizing more minutes is exponentially harder so it's it's much more harder okay let's go back to our contract great so a new transaction is entered now let's look at it we have the log near randomness and it's odd right let's make sure everybody believes we have uh wait just to make sure uh explain what happened so we have a lot in your randomness uh we see that this is indeed the uh it will only get emitted if a valid proof was submitted and we see that the the seed and the number of iterations corresponds to the request that we made and then we have here the randomness [Music] just to make sure we are yeah it's uh it's fine so it's even i don't remember what i said but one of us won so this is uh how you use vending machine and i think it's let's say you won thank you thank you um great so so let's go back here um i i didn't do it through the terminal or stuff like that because i mean basically i mainly wanted to to to explain the the the interface with the vending machine now what what can be built on on it right i go back to the examples so the the most trivial thing is to build um um for example a loader application uh but we already have examples for it so it might be not that interesting uh i think that very interesting stuff to do is to use randomness in in applications that we have not thought about before uh so for example using randomness uh to ensure some fair swapping and uh preventing front running might be a very [Music] interesting direction i think that also building wrappers around this contract so for example a very simple idea is to uh build a wrapper that uh just take the block hash and transfer it as ssc to the vending contract uh the bank contract is general except everything this is the purpose of it but we can build interface around it which makes it simpler to use um yeah this is basically it um yes tom there's a question from youtube from matt solomon asking how does vidu compare to chain link's vrf okay good question um so first of all hi matt and thank you for coming um the technology i guess this is not the question right because vrf is a ver verifiable random function um which basically allows the user to to to very very simplifying it to compute something using his uh private key in in [Music] using generating a random function using his random random key and then providing proofs to to everyone to to verify that this is indeed the computation using its public key um but there's no delay here meaning that the the user that generates this vrf knows immediately what is the solution so for example if some operator of an application that [Music] uses randomness somehow collude with with the vrf provider that he makes a request to then they can know in advance what will be the the the solution since there is no delay here um but but it has other benefits right it has less latency um it's just like in my opinion the security is is uh is lesser does this answer the question we'll wait see what matt says on the youtube chat uh we do have a question here from fox raymond in the zoom chat once again how do you prevent front running with randomness okay this is indeed very interesting i will describe it very briefly and uh please let's discuss it later uh because this is an idea it's not a complete design um but i think there is something to do there um so for example let's take uh an alley stop me if uh [Music] if you if you don't want to share it yet but let's assume we take the interface of uh uni swap um right so you you can call it uh and i will describe something right now which is in the naive implementation is not possible on ethereum but i'll just describe the idea so the problem in uniscope is that the miner can can include or interfere with the sequence of the transactions or include a transaction of its own and he can know uh exactly what will be the price that it will get and he can front-run traders [Music] so an idea can be let's say that all the traders that calls uh uni swap in a block gets the same price maybe the worst price that uh one of them got and then we use randomness which is not known in advance to the miner or to any other user to distribute the the extra profits between all the traders so as i've said it's very briefly it's not possible in the navy implementation but this is the the idea great um i don't see any more questions from youtube but we could open the floor and if anyone in the zoom call wants to just jump in and ask tom questions we could do that that sounds good sounds good great thanks again everybody for coming and uh have a good night um morning i don't know wherever you are thanks awesome thank you tom oh question from derek how do we find you um i guess you can uh this is my handle yeah on discord yes i think also in discord yeah so this is on discord great okay awesome thank you so much tom bye thanks everybody thanks 