that's right cool uh yeah i see that tweet came through let me just repost it out awesome welcome everyone um so i think we're and trent just to confirm we're scheduled here for like an hour right yeah i think we had scheduled an hour and a half um but if the injury we're good i can i'll kick it off and get going all right cool uh so today is the last day of week three which seems pretty crazy it feels like we were just starting um it was only a few weeks ago but it feels like it's been both a really long time and going faster than i expected for sure so uh the end of week three this is uh we have one more event after this which is the file point office hours but this session is focused on learning about ceramic and how you can specifically use it in your hackfest project so hopefully this is useful to the hackers that have shown up and today we have michael with us he is an uh builder at three box which works on user ids and user data profiles all sorts of things like that he's going to walk us through what ceramic is and some of its features also have michael yep take it away uh cool so we have an hour um i want to keep this pretty informal um because it's more just about helping you grok what ceramic is and answering any questions that might pop up ceramic is pretty new um so for some context yeah we've been working or i've been working on three bucks for the last two plus years um and along the way we've always had the goal of um sort of creating a more general decentralized protocol for some of the things we were doing and in the process um created this new protocol called ceramic it's a protocol and decentralized network and it's not currently um in product like it's not live on mainnet yet so it's still in an early alpha which we're calling the slip devnet um but in a couple weeks we'll be on the beta devnet which we're calling clay and so just for some context as to where things are in the development process so you might have some questions about how do i do something or where is this library and sometimes the answers might be it's being developed um but there are some hackers from hack fest already working on some cool things um some of the folks on the call now um and so you know i'm can also point to them to share the ways that they're using ceramic because i think there's some really interesting use cases popping up but um so for the first bit of time i'll just give a high level overview of what ceramic is how it works some of the use cases and things people are building with it and then it will just be open questions so i'll go ahead and share my screen and you can see my ceramic github right um let me move the participants and it's kind of hard to see chat while this is going on so how do i keep that open okay great um so just to quickly orient you uh the github is github.com ceramic network and ceramic is a permissionless protocol for creating what we're calling smart documents um they're basically documents that are stored on ipfs but where they're linked append only logs where each update can be anchored on a blockchain so basically what you really have is the ability to create these mutable documents where you have guarantees about the order in which the updates occurred and this has a lot of really interesting use cases ranging from decentralized identity to permissionless content publishing to publishing schemas and other metadata about resources that may live scattered across the web um publishing verifiable claims any sort of information where you want it to be permissionless censorship resistant exist in a cross-platform way um and but be updatable and so you know unlike some of the other platforms where um you know they handle sort of decentralized file storage you know either the raw file storage like file coin um or are we or platforms like that um ceramic sort of sits at a layer above those and it provides the the document structures rules straight state transition functions that enable you to make better use and interpret that content in certain ways um one unique property about ceramic is that it completely uses dids so decentralized identifiers um which means that a did is obviously the w3c standard for interoperable cross-platform identities but every bit of information published and authored and updated on ceramic is signed and controlled by a did and dids can in turn be controlled by any number of wallet keys that may live on any network so really what you create is the system where content exists sort of on its own right cross-platform and users can interact with the content that they own from any of the platforms or any of the wallets so you can use the filecoin key an ethereum key a bitcoin key a cosmos key whatever you know times a thousand to control the same content so the content you're publishing isn't locked into any particular key or platform um which provides a lot of interesting use cases and properties for building more user-centric applications and platforms where data is interoperable um and so to to quickly scroll through i mean i've just covered some of this but um in the github repo if you go to ceramic network ceramic you'll just see a quick overview and this kind of points you to a lot of the resources that you might need to get started right here you'll see a ceramic introduction which is a really detailed description um of what the protocol does both the needs for a system like this um and and how it works but i'll kind of jump into um how it works quickly where are we here cool so now what you're looking at is the ceramic network specs repo and this kind of defines the rules of what the core protocol does and so you know as i mentioned really it enables you to create these tamper resistant but updatable documents owned by dids not owned by any particular private key and the way that it works um is basically each document consists of a series of what we're calling records and a record is just an ipld object so um and to quickly back up like why would you use ceramic versus using um file coin directly or using ipfs directly or any other publishing platform directly and that's because by sort of using ceramic as a way to publish content to those platforms you get all the benefits of what smart documents can do which are you know version control state management blockchain anchoring and even the ability to do things like add logic to it so you can say only mutate the state of a document to a new version if this thing happens if this script executes and returns a property so you can really start to program content in a way that you can't do um if you were just using the file system directly itself and so um a document as i said is a series of records and each of these records is a state transition so each document is effectively a mini doc chain where you can you know query a node and say what's the latest state of this document and the node will fetch all the updates and construct the state transition logic and only return to you what the valid current state of the document is and so each document begins with a genesis record and that's like i said an ipld object it contains some header properties and i'll scroll down to that um it contains some header properties which are basically a set of owners it could be one did or an array of dids it has a schema which is optional but it basically defines the content in the documents you can say i want to create a document and i want it to conform to this schema and that schema is also published as a ceramic document and you can also add tags to a document which enables others to make sense of that information you can imagine publishing your app's name as a tag or the type of document that it is which might use a generic schema for just like a string map but you might say i'm using the string map for this use and so tags are really interesting when index services such as the graph or others begin to index content on ceramic you can just search by tags um and unique is a string that basically says this document this new document is unique because the doc id so the the persistent permalink for a document is how you identify it within the network and that permalink that ceramic id is generated which is effectively just the cid of the genesis content so if you create a genesis record um that has the same header content and the same body content you'll get the same cid um and so you can add an optional string which adds randomness to that which obviously will generate a new unique cipd and so that's the header metadata for the genesis record and then in the genesis record you specify which something i'll dive into which are doctype the doctype it is and then any data and that data is sort of defined by the doctype which i can jump into so the genesis record is really just the cid object that creates a new unique document and it's owned by a set of dids and then when you want to update the document you the owners so if it's one owner just that owner if it's a set of owners then all the owners but they sign this update record which is effectively just a json patch to the genesis record and then that update record so called a signature record has to get anchored in a blockchain to be valid because you're saying the genesis record is there we're adding a signature record which mutates the state of a document and in order for that to be finalized you submit it for anchoring on a blockchain which gets appended as an anchor record and that creates a version so now once you have an anchor record there's an explicit version of a document so let's say that's version now two and then you make another update as a signature record and that's gets submitted to a blockchain for anchoring then you have version three and so you can refer to documents just by their doc id which is the cid of the genesis record which will always return from the protocol the current state of the document or you can specify explicit version so i want to query ceramic colon slash bafy whatever you know query parameter the version and then the protocol will only return to that explicit version of the document um and again there's a lot of nuance into what content can be stored in documents and how these state transition mutations are enforced by the protocol which i can jump into next but i see a question came in so i'll pause there for a second how does ceramic differ from three box spaces is one more ideal for certain use cases than others whereas space is using ceramic good question so we're in the process of reorganizing information in some of these repos to make that more transparent but spaces uh and three box broadly are not dependent on ceramic at all so they're kind of two separate concepts ceramic is this protocol for information dynamic information management on the decentralized web and three box will use some of the things and standards built on ceramic to do the identity management piece internal to it but three bucks will really be used to let people create orbit db instances that are managed um and have a simple interface to do that but ceramic is kind of separate so um ceramic has its own set of use cases and own set of you know um design that is in no way dependent on three box um hopefully that makes sense there's a there's a bit that i'll jump into when i go more into use cases about how you can see where some of the space is created with three box might plug into ceramic but the concepts are kind of entirely different makes sense jonathan cool and so that's generally the structure of documents and obviously as i mentioned these doc ids are really how you query a document so this is just an example of a doc id that if you query a node it will return the valid verified state and or you can query a version and it will only return the version um the cool thing is about ceramic is it's really modular so the ceramic node really enforces these document transition rules and gives documents these permalinks but the persistence you know it's all content is stored in ipld and pinned locally in the node but then that node can choose a persistence option so that node can persist the contents to filecoin if that node is configured that way but alternatively that node could configure a persistence option to like s3 or a sql sql server and it just depends on your trust guarantees for the documents that your node is managing and similarly it doesn't need to anchor on any particular blockchain so you can configure your node to anchor to ethereum um you can configure it to anchor to file coin you can configure it to anchor on cosmos or anywhere and so really it's plugging ceramic in a way is a meta system on top of these various decentralized protocols that makes creating and managing information better um okay jonathan not exactly sure still all right hopefully uh in maybe like 10 minutes this might become a bit more clear i'll jump into like where three box might plug in um so now i'll jump to how how ceramic works so we went through general the structure of the protocol what it does um if you want to start building there's js ceramic so js ceramic is a typescript implementation typescript client for the ceramic protocol and it has two interfaces there's sort of ceramic core which is a local node that you're directly interacting with it's a standard javascript interface or you can interact with ceramic over an http um api and and both work so you know ceramic can run in browser in an app directly and do the full networking or you can in some ways run like a light client right where you just have js ceramic configured with the the http api and it's communicating with a remote ceramic node that might run on a server um and so obviously things like that enable ceramic to work on different sorts of devices more resource constrained environments like mobile apps and things like that or running right in your browser um and this is um you can see there's a couple packages that comprise this i won't go into too many details if you really want to learn you can dig in um but when you're setting up a ceramic node there's a bunch of configurations that you might want to set as i talked about before so you can pass in a persistence option to file you can pass in a blockchain anchoring service which may anchor your updates on a given blockchain but you also need to import what are called doctypes so um i gave a hint towards it before in the protocol but each document that's created on ceramic conforms to a doctype and a doctype is really the rule set the both the content rule set and the mutation rule set that's applied to the document you create you can think of them as like they're the smart logic for the document and so um doctypes are really these engines and we've created a few um and so when you're spitting up a node you have to pass in the dot types that you want your node to support and i'll go here one of the the most generic doctypes is called a tile and it basically describes a json document that's like a json object store um and it's really flexible in that there's no specific rules for how content what content can be stored as long as it's json and the owners have to be one or more dids and those dids have to sign the updates for the document to be mutated um and that's really like a pretty simple primitive we actually include the tile doctype in the js ceramic mono repo and in your instance out of the box so you don't actually have to manually import it it's kind of there by default but the manual importing is there for people that may for example want to write custom doctypes and they want to use it in their nodes there's no predefined restricted set of rules but rather it's flexible for you to write documents and doctypes that do things to documents that are aligned with your use case one more doctype is called free id and this is actually a w3c compliant did method built entirely on ceramic documents as a doctype and so this is different than the tile in that there's different considerations for what content can be stored in it um and so you basically need to um you know there's specific things that make a did what a did is you know a did is basically a document that has a management key and that management key needs to sign all updates the did document including you know public signing keys and encryption keys and other content that a did might need to include in the did document and quickly for those unfamiliar dids are sort of the core piece to interoperability that we've been you know working with the w3c community and the decentralized identity foundation with for quite a long time since early 2016 the standards finally getting you know the attention and traction that it deserves but they're really you know globally unique identifiers that can be respected by any interface and you can control with any number of keys and so they actually serve as the foundation for a more user-centric interoperable web and the three id did method is implemented as a doctype in ceramic natively so again if you install js ceramic you'll get the three id doctype out of the box you can create the ids so you can start interacting with other documents but ceramic is did agnostic so let's say you have a did method that's anchored on microsoft's ion or ether did on ethereum or anywhere else those dids are still supported in ceramic so ceramic is diagnostic but because it is a did-based platform we do have a did that you can use uh to just get up and going if you don't have one um and now this brings me so what uh where is it here cool cips so as we talked about those the core protocol and then there are things that are optional are sort of configurations and those include doctypes but those may also include standards that are built with doctype so standards for schemas or standards for um identity indexes or various things and so we have the cip process where the community can propose standards for things so you'll in in this list you'll find the tile doctype you'll find the three id doctype and so doctypes you can use are all in here as well as things like schemas so we've specified some things like a simple string map so a string map is how you would define a schema on ceramic which is actually using the tile doctype so if you create a new document that you want to be schema you create the genesis record you say it's a tile and then you can just publish your schema to this document which then once it's the document on ceramic you can reference it with a doc id when creating other documents uh so you can say i wanna create for example um a basic uh it's right there a basic profile uh like how would that work so i just saw it here we go so a basic profile let's say you want to create a profile for a did and publish it on ceramic you would basically just create a new document that is a tile you would specify in the schema property the schema of this basic profile which will be deployed as a document once the network is more live and on beta test that so you just pull in the doc id of this schema you'd specify tile and then you could go ahead and in the content just publish data according to this schema and then and lastly you'll need to add the basic profile tag to the document tag and then anyone can query your did and see it's an owner of this basic profile document and have a basic profile uh obviously a really simple use case but one that can kind of get to some of the properties and let's say you wanted to update a profile with a new name the did would publish a signed record which updates the basic profile document to a new name and then that would get anchored on the chain and then the next time i query this document id i would get the new profile um sort of automatically and how this all ties together so when we were creating ceramic what we really had in mind was we obviously drew on requirements from three bucks so with three bucks it was how can we create a decentralized identity protocol that allows a user-centric web where a did is controlled by many keys and that did maps to and controls many resources which may be profiles but it may be account links so links to twitter github domain names etc also data stores which may live on three boxes infrastructure but which may live on the textile hub for example and textile threads or it may map to just a bit of raw data published on file coin or on our weave and so how do how do you basically like look up a did and find all of its related resources which is sort of the heart of the user-centric web and this brings us to one of the main standards we're working on so again we have ceramic core then we have ceramic doctypes and we have standards and schemas built on top that are use case implementations and so the identity index protocol we're going to be sharing more about this really publicly to start engaging people on it next week but it's a way to build an identity centric index of resources built around it did and i'll skip through the beginning because this is sort of conceptualizes how documents can be linked to provide really powerful use cases and so you have a did which might be a ceramic 3 id you can create a root index document which is just mapping properties to other doc ids so it serves as a routing table for categorical directories so you look up a did you get its root index document then you say i want to query its profiles so you follow this doc id and you query the network for the profiles index which contains an index of various profile documents so basic what you see here would map to the doc id of that basic profile document i just showed you it can map to an authentication key chain which actually is where you would add a bunch of different wallet keys from filecoin wallets to ethereum wallets and everything else to actually control the did so now you can authenticate and manage did with any key um similarly you can link a whole bunch of accounts like domain names crypto accounts publicly so you could look up these accounts and resolve a did and then resolve the rest of its resources you know portable social graphs are mapped from the connections index and there was a question about how um three bucks maps the ceramic and so three bucks has its own identity system internally which we're fully migrating to this identity index protocol and sort of allowing three boxes little library to consume these identity indexes built on ceramic and three box spaces are just basically you know personal data stores that are app specific so you can create any number of spaces per user um and here those would be mapped in a collections index so basically if you want to associate some external data source whether it's app data or any sort of data to a did you add it as a collection and these can be orbit stores textile threads even other ceramic documents but in order to add it what you would do is you create a definition and a definition basically specifies the data model of your app so it can say my app uses one orbit store one textile thread and those conform to these two schemas let's say for a very simple example so my app uses two data stores that use these schemas and that is published by the appsdid and then it points to what here it says manager but it's actually called reference so then each collection that's the definition the definition maps to a reference and that reference is a document that contains user specifics about that definition so you know every uni every textile thread or every orbit store has unique id um and each user gets a unique instance right so in this reference you would say you would have a pointer to the textile db located in the definition so i know it's a textile db and it has this schema and then the reference would say and it has this address and it lives at this location so now i can look up a did find the root index find the collections index and then find the data stores that i need which may live maybe the textile db for this app lives on the textile hub and maybe the orbitdb for this app lives on the three bucks cloud and so you can route to those and because they're mapped and controlled by dids the user can always encrypt and decrypt and authenticate those data stores so it really gives it solves the the sort of on the distributed web in order to make identities and resources truly portable across platforms you have a discoverability problem how do you associate these resources to a user in a standardized but flexible way that enables anyone to query a did find its resources and route to them in the appropriate way and so this is sort of the core of the user-centric web and how we imagine a lot of use cases for ceramic will be built like even if you're just publishing documents such as blog posts or data about something you'll want to in order to make it discoverable and consumable by other apps you'll want to associate it as a collection to a did um and so yeah hopefully that clarifies the three box question a bit like if you have three box spaces once they migrate they'll just be collections within this iip um and a bit about where we're going so as i mentioned we have um the slip test net that's live you can play with it people at hack fs are already building things on it um we just refactored our js api so that's already released um we basically pulled doctypes out of the core protocol and made them optional so anyone can write their own doctypes and use them we added schema support as of like yesterday so now when you're making updates to documents that have schemas the protocol is actually validating that update and making sure that it conforms to the schema otherwise it's an invalid entry um we are making the the interactions between wallets and the network really easy so you can use ceramic with any crypto wallet you want um and we got approved by um filecoin and ethereum foundation to create this library called dag jose which standardized it's a multi-codec for ipld or codec for ipld which standardizes the way sign information is signed and encrypted as ipld objects so data that's for example encrypted data that's put there by ceramic dids will be consumable and decryptable by anyone else on the ipfs ecosystem it doesn't lock anyone into an encryption standard and we've already added that to the protocol so we're really just testing and finalizing um a bit of this but within the next few weeks we hope the beta clay test net will be out and that's sort of like we'll use all the data formats and standards that you would need to sort of build real apps and try it um and then after that we have a bunch of you know nice things that we want to add to make the protocol more powerful and more performant um that will do before we actually go live and we're hoping to go live you know by the you know end of fall early winter um and that will sort of be the full thing and it'll be ready to go to production but if you want to follow along this is just the roadmap can be found as just an issue um in the ceramic ceramic network ceramic repo um so i'll stop there um for a second and there's obviously a bunch more i could talk about i could go through a ton of use cases that people have maybe that'll be helpful before a bunch of questions but so for hack fs there's already people building a new doctype for verifiable claims um and some of them are on the call but basically i'll let them share more about their use case but in summary it's a doctype that enforces the verifiable claims format and schema to create w3c compliant claims so things that are you know maybe like an education degree um or a proof that you own this social media um profile or username or a claim about anything really um and it's like a signed bit of data where you can trust the author what's that institution and it's really kind of one of the big pieces for decentralized identities someone's building a verifiable claim doctype um someone else is building the geo web which is sort of a an on-chain registry of of properties in the physical world and they're mapping those to ceramic documents um so only the owner of that physical piece of property can create this dynamic document on ceramic and update the content and do whatever um and again like it's the way that documents are structured how they're updated um is you know to be determined how if they're going to write their own doctype or not so those are two hack fest projects we now are working on things others are using ceramic this identity index protocol i discussed to um provide like to upgrade the identity systems um or lack of on the filecoin ecosystem and textile and others so basically they want to host um textile dbs or textile threads for users but they want to associate them to their iip and let the did access control those data stores that they're managing in such as in such a ways to make the data portable and interoperable so they would be publishing schemas of the data stores to ceramic they're mapping those data stores to the dids using the collections index and they're doing all sorts of cool things to build on this stack of dids like ceramic network dids file coin textile to really make web 3 a reality because you know it's kind of hard to build a true a truly portable web 3 app that's controlled by users when each of these technologies have their own implementation for keys and identities and routing is sort of implicit and hosted on a service but if you can decentralize schemas and routing and identities all to this public network that works across chain you can tie all these technologies together to build really powerful applications so um i'll stop sharing and i'll pull back up the people in the group um and say questions thoughts uh sort of the the floor's ears so i see one coming in from thomas does the node automatically anchor the state changes to whatever blockchain it's configured for um so it it doesn't well it doesn't automatically there's a method where you you the node gets a record and then it applies the record so the apply function is separate um so the node can collect signature updates from any participants before it actually applies the record and when it applies it either you know we have this concept of anchoring services so for throughput and low cost the nodes can submit the the record to an anchor service which basically takes a whole bunch of anchors from a whole bunch of nodes and puts them in a merkle tree and then only publishes that merkle tree to the chain along with the metadata for things like bloom filters so you can like parse the tree and know if a document you care about was updated and then once that anchor goes in it gets reapplied as an as an anchor record after that that proof is returned but in the meantime you don't have to wait for the anchor service to actually anchor your update to assume it's valid the anchor service emits a message in the pub sub room which says uh anchor pending and so you can kind of like work optimistically that that anchor is pending and use it as ordering in the meantime so you're not held by the frequency with which the anchor service is updating you can actually get a message back that allows you to proceed does that make sense um cool any other questions if not we can allow um you know i think uh stefan and and while you guys are working on verifiable claims feel free to share sort of how you're using ceramic why you thought it was interesting if anybody wants unmute feel free just go ahead and do that so yes uh thanks a lot for for this extreme explanation it's always great to hear what you guys are up to and we're actually just struggling to get it work um uh what what we so we are actually doing two things we are trying to build these uh verifiable claims document type or on top of the mono wrapper this is what animal is doing i think he's still here hello one more and what i'm trying to achieve is actually get everything running in the browser scope and i mean in the plain browser and i'm not exactly sure if this anchoring service is meant to be run in the browser at least i i have quite a hard time running it here but from a from from a concept point of view i think you just could use metamask or some injected signer to to sign these uh anchoring transactions right yeah okay yeah of course so an anchor service isn't actually meant to be run in the browser it's like an external service that you submit to um because that would be yeah quite a lot yeah of course but i think you you could actually also just anchor every document change you do on your local thing on your own or on on the ethereum blockchain yeah um the the main thing we were struggling with was also like binding the three box identity um of the identity wallet uh to that ceramic uh client and then we had some little discussion on the discord of ceramic and we i think we're pretty sure that you cannot just use the three box identity to identify uh with this one against the current ceramic implementation right yeah so i mean some basically like we haven't done the three box migration yet so it's it's not meant you're sort of very early in in the sauce on that and so basically like you can create new dids on ceramic using the the instance and you can interact with the protocol that way but it's a bit hard until we actually do the migration to use three box identities within ceramic um yeah i mean the main thing we had to figure out is how to uh create verify the claims representations because putting a verifiable claim in a ceramic document is a no-brainer you just put some document in there it just works but of course you would we wanted to to conform to uh more or less the standard and i'm all if you don't mind i can just share my screen and show just very quickly on how it looks like in our case if i find the right window here it is i guess do you see a window or do you see lots of blue i think you see a window okay um ah the project has been called eridanos because this is the area in in greece where lots of ceramic comes from is at least this is what we found on wikipedia so what what we're doing we're authenticating our our ethereum address against three books and now we got a three box identity and what what we're doing because this is not compatible yet we're creating a seed that we're storing inside the private space on three books and then we're using that seeds to identify uh or to create um a three box sorry a ceramic identity that as a document actually looks like that and if you just want to see how this looks in the browser i just created the tile document and uh let's scale that up this is the idea of that document you could look that up on ipfs and you can update the document and you see that the ad is changing and you get all the changes here and now here comes a problem if this runs in browser there is no anchoring service so every time i reload that one it doesn't know about the updates because it never anchored anything and yeah this is something i would like to get around but coming back to the very very verbal claims uh so this is just just a demo we just created a very vulnerable claim document when i clicked the button and this is the contents and animal was using the um did jot vc project the library to create a jot a sign shot out of the claim and as you know or might not know there is of course this very nice oh this was wrong right where's the red one i hope i didn't break anything here because actually this shot should contain a claim but it doesn't i'm sorry i think i broke it um on the way but what we're actually doing we're just creating a verified credential that says this um dod has taken part in the hacker first hackathon and we're creating a jot proof um it's actually self issued very far verified creative in that sense and this is what what we're storing as a ceramic document unwell if you've got any additions to that one i'd be happy to hear yeah i think yeah explain most of the idea but yeah i mean claims can be anything you know that it can be educational degree it can be a driver license it can be a kyc documents and the idea is you know how do you link them to your decentralized identifiers and you know and store them somewhere else so that you can share them with any verifiers on any organization and that's what yeah that's where the id comes like create a doctype we store the screens and we're also trying to add the schema support so that you can store them in a more structured way and then you can also present them in you know you know as a ceramic document itself and you know also verify them ceramic documents already have that signing thing you can digitally prove that yeah you own that verifiable claim yes that's the idea and yeah statement already shared awesome yeah thank you i appreciate that um a question from thomas can a document be unowned um sure i mean you basically the current owner can can change it's specified in the doctype what what updates can happen but the tile doctype for example you can update the owners i believe to nothing and then in that case it's not owned by anyone and it can't be updated in that sense um and so that that definitely works and the reason why we need blockchain anchoring is really for this ownership right and especially with decentralized identities if you're adding keys and then you're removing keys or changing keys you want strict ordering about updates and you you need a linear logical clock or linear explicit clock about when things happen because you know if i remove the key i don't want that key to try to make a malicious update to any of my documents at any time and so um you know same thing is true with certain documents that you might have and so in that case yeah like blockchain anchoring is really good for proving verifiability of the owners at any point in time who's authorized to make updates so if i wanted to sort of promise that i will never change the document i could remove the owner or something i imagine yeah um yeah and there's really interesting things that we're exploring too so uh for example a document could be owned by like the geo web project for example um they they really want it to be where um a landowner only the current landowner can update the document and so if you just specify the present landowner's d as the owner um you know that present owner can make two signed records right one saying like i'm removing myself but before they do that or i'm changing the owner to the new owner but before they do that they say i'm the owner right and they withhold that first signature and then they only submit the second which changes ownership then at a later point in time they could publish the previous update and say oh no actually like this one is precedent because it came before i'm still the owner take it back and so how you get around that like for decentralized identities that's not really a problem because it's all my documents and i'm not transferring mine but what you can do is you can make an nft the owner of a document so you're actually like delegating the double spend problem to a blockchain and so you say only the did of the so an address owns an nft the d id of that address is the only one authorized to make updates to a document and so then if i transfer that nft to you thomas now only your did can make updates and mine can't either so you can do that's really good for supply chain really good for like nft owner guest books you know like everyone that owns an nft is the only one that can write to this log um you can do really cool things and that can all be enforced by ceramic um so there's like really a lot of flexibility in how these documents can be made smart just depending on what your use case is that's excellent thanks you can also do things like you know dow votes where a new record type can be created where you know the the dow votes on chain for something if it passes it creates a record on chain which is already anchored in a way so you don't even need an anchor record you can just add that to the document um and so that would be like a new record type so depending on the use case you can really add all these things in as modules between the combination of records doctypes um ownership things schemas um it's really configurable um so we still have 10 minutes any any other questions or any ways that i can be helpful cool if not trent don't be shy if you have questions yeah we still got a few minutes uh hugo asked question uh in the chat what kind of network uh is this going to be how's it going to work um sure hugo can you share a bit more context about the question yeah so maybe um i didn't completely understood this part of it but like who is it going to be running like ceramic nodes and um how is this all networking part going to be working at least on a high level how's that gonna work yeah so i mean like the um like the ipfs journey we're not adding a token uh immediately because we want to ensure that everything is working properly before we introduce something that's going to lock the network into a certain model um it eventually likely will have a token um but in the beginning i mean every you know everyone that's running the ceramic core instance in their browser is running a node um right in the browser also there will be partners that are running more nodes that you can connect to from an http api and then actually serve to pin content when that local node is offline for example um and so like ipfs worked until the introduction of filecoin is really how ceramic will work until the introduction of some sort of a more incentivized node operation scheme but it basically any app that's running things on ceramic will probably run a node users themselves will have a node if the app is using the the full library in the browser um you know three box will run some nodes we have a bunch of partners already lined up to run nodes so even without a token we're seeing sort of the network have enough support to manage the initial use cases and not every node needs to pin every document which is the nice thing about ceramic where you know you don't have a concept of a full node where you have the full set of all documents on it nodes can just pin the documents they care about and then they use lib p2p pub sub to request the current state from nodes that have it and so nodes are actually a lot lighter there's not the same amount of overhead needed to like run a full node because the concept of full nodes doesn't really exist in ceramic since each document has its own state chain you don't need the full state tree of all documents to verify the state of any one document you can just verify the state of each document independently so it makes the network a lot lighter meaning like you don't need a server farm to like run a full node you can just run it in the browser that's awesome thank you yeah but the main idea of these nodes is anchoring and pops up notifications uh if they get requested the current head of a document id right really the functions of a nodes are version control right like the document management logic anchoring is not really the job of a node nodes can add an anchor service where they just externally submit to or the user itself can publish that to the chain however they want um like the node is really just running the logic engines for the documents it's managing so like the node in the protocol will say like does this update conform to the schema defined are the parameters true that require the state transition to happen um you know querying a node it will return the current state of a document so it's really like document management but not like the core job of a node is not really persistence or anchoring it's applying the rules to each document on the network which is like really it's like a rules engine that's basically something that that you can do in a browser right so yeah yeah you can do that in the browser because you're just like running that copy that like small logic in on each document you're querying um um how how would you enforce that as given node has not tampered with the logic of how to change that document yep because it's running i mean it would be running that it can only run the doctype code um it's like running the packages and all documents can be verified so because they're linked lists of records the receiver can actually like parse the records and actually check that uh it's true and so you can always like do the verification the node just like does it for you um cool some other questions what are some possible new doctypes for the prize so again like this is really flexible like doc types are use case specific in some way there's some general ones like tiles three ids verifiable claims um there are other like really cool things you could do like we've been toying with internally this concept of a script doctype where it basically is just some code that you can think of like a script doctype as being an aggregator so let's say there are 20 documents created by 20 users all with the same tags all the same tags so maybe that tag is like a unique topic id somehow like the hash of some combination of things and then you can have a doctype that just like has a script that takes the latest state of all the documents with this tag for example and creates a new document so you can build like commenting systems like that right like if each user is just having an append only log and you have a script doctype which like aggregates those into one document that document isn't like responsible for getting content by a did directly published to it but its content is just the output of the script that it's running um and so there's really cool things you can do that way um which i think there's could allow us to run solid yeah it's like there's a lot of possibilities here um because documents sure it's like out of stat they're really like dynamic objects like where you don't have you can't build a cryptocurrency system in a document for example like i wouldn't advise that because you do have the double spend problem in some ways about withholding records um but if you have things like information uh and various things like that like you just need to sandbox the the amount of resources it can consume in some secure environment uh like secure ecmascript or whatever and then you can just run these computations um it's like this vm um so then what you can build with talk types is really flexible and i hope people come up with some cool things verifiable claims is immediately useful because when we're migrating three bucks to ceramic like we have these twitter verifications and github verifications that we want to associate to a did via its accounts index and so the accounts index will point to these verifiable claims documents which say like this did owns this twitter account and other things like that so those are immediately useful the other ones enable people to build other cool things um i want to build that aggregator script please share the link um cool i can uh i don't have it up on this um computer but let me share a link to our discord where uh one of our engineers has started building a prototype so you can share the latest with that let me pull up um i think that should work i'm on a computer where i don't have my discord on it for this call but um there's a link to our discord if you jump in and ping us we can definitely share that with you um not sure for general absolute storage for a new app should i look to spaces or ceramic um it depends on your guarantees so distributed databases still have a purpose right they are for really dynamic data that you might want to host on a server um that you kind of trust that in a way and it's less critical um ceramic documents do have anchoring so they're a bit slower than like what you would put in a textile thread less frequently updated but you can do interesting things so there's a chance that we migrate some of what are currently spaces directly to ceramic documents because what people are using it for to like store app state every now and then or store like a pending transaction that could be stored in a ceramic document where people are dumping like 10 000 entries into a thing like that should probably be a database um so it really depends on your use case it could be either for the question about spaces or documents and i think that's most of them we're running up on time so any last thoughts or questions before we all hop perfect timing yep thank you very much for presenting um about ceramic and giving us details about three bucks and the plans for the future i'm sure a bunch of these people building here will continue following and building on what you guys are working on it seems pretty awesome cool yeah thanks for having me trent um yeah and please everyone in here feel free to jump in and ask us questions we're always available on chat both in the file coin slack and in the ceramic discord which i shared all right thank you everybody for coming out and um if you need to go back through anything this recording is available on the global youtube channel so be sure to check it out share it around show some people thanks michael we'll see everybody yep take care all good luck hacking 