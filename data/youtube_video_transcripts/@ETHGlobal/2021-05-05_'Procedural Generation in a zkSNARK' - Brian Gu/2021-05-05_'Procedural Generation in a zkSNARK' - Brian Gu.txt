we are at the final stages of this summit this is our last hack of the day and also uh talk i'm super excited about so uh without further ado i'd like to welcome brian to talk about procedural generation using snarks um and he's gonna talk about that from the context of dark forest so brian feel free to kick us off awesome hey folks um i'm going to share my screen here and thanks for having me um youth global team and karthik it's great to be here we're excited to have you all right um sweet so everyone my name is brian um i work on dark forest um and i also do some work on applied zero knowledge research and development with the ethereum foundation today i'm going to be talking about procedural generation in zk snarks and in particular some of the challenges we've run into while experimenting with this technique cool so to motivate everything that i'm going to be talking about in today's presentation i want to start off with this question how could we build minecraft on ethereum so um i think a lot of people are very excited about the idea of decentralized worlds that are very rich and expressive and that a lot of people can participate in and build on and one of the best examples and most familiar examples to many people is the game minecraft which is a three-dimensional sandbox game um with the rich and varied landscape a ton of different you know items and blocks and things that you can build with one of the key uh features of minecraft is its very rich procedural generation base so when you spawn into a world in minecraft you're going to spawn into this world that has forests and oceans and deserts and all sorts of both local and global scale structures and with ethereum and a lot of decentralized computing platforms we don't quite have the same amount like we have very strong constraints on things like you know storage how much can you actually fit into the evm we have constraints on things like um transaction throughput so you know it seems like today we're very far from being able to build out um a complete and rich sandbox game like minecraft on ethereum uh but you know our theory from the dark forest team is that using some techniques combining them with zk snarks we might be able to get closer to realizing something like this vision so to dig into a little bit of context for what we're talking about today we're going to specifically be talking about some of the challenges we've encountered trying to implement purlin noise inside a zk snark um this is a technique we use in dark forest um and it's something that we're exploring more complex variations of uh you know over the last couple of months and and throughout the rest of this year so purlin noise is a procedural generation algorithm for generating rich and varied game world terrain so you can think of it as a function that can map an arbitrary coordinate pair x comma y to say like a height on a terrain zk snarks allow for constant time contract side verification of the execution of arbitrarily complex functions so in other words if i have a if i have a function that would cost a lot of gas to execute in solidity like let's say like hundreds of thousands or millions of gas um if i can wrap that up inside a zk snark then the cost that i pay for execution of this function essentially is just the verification cost which is going to be a few hundred thousand gas on chain um so putting these two things together if you want rich procedurally generated worlds on the blockchain um one idea is to put purlin noise inside of a zk snark so just a quick refresher for um folks who might not be as familiar um a zk snark is a tool that basically allows you to uh prove knowledge of inputs of a function that correspond to some known output so for example um in this slide here we have some very simple function f of x equals x1 plus x2 times x3 minus x4 a zk snark for this function would allow a prover to prove that let's say i'm approver i will give you a claimed output to this function f of x that i claim i have the four inputs x1 x2 x3 x4 for this output um and then i'm also going to send you over a proof which you can check um that will convince you that i do know four inputs which when the function is correctly computed on those four inputs does result in out the zero knowledge property of z of zk snarks ensures that um i can actually do so without telling you anything about these four inputs um all you're convinced of is that i do have the four inputs and that i've executed them correctly uh but it turns out that you know for the procedural generation stuff we're interested in this part is actually not as relevant the important thing is that the verification of the signature takes constant time so more specifically what zk snarks are doing is that they're proving constraints on what you can think of as kind of like the computation graph associated with this function so you know in this previous example we have this function f of x equals x1 plus x2 times x3 minus x4 this can basically be thought of as you know if i want to perform this computation in steps i can create an intermediate value y1 that i set equal to the sum of x1 plus x2 and then an intermediate value y2 that's the product of y1 and x3 and then out is simply just going to be that second intermediate value minus x4 so what the snark sees what i plug into a snark is going to be the input values x1 x2 x3 x4 those intermediate values y1 and y2 and that output value out and what the snark is actually doing under the hood is it's going to generate a signature that is valid if and only if constraints corresponding to those intermediate execution steps are satisfied so when we're thinking about doing the computation we're thinking about sort of traversing this computation graph forwards starting with x1 x2 x3 x4 computing the intermediate values and then eventually getting to the output what the snark sees is it will sort of digest all seven of these uh associate values associated with the computation and produce a valid signature if the constraints hold that the first intermediate value is equal to the sum of x1 and x2 the second intermediate value is equal to the product of the first intermediate value times x3 and the output which i'm sharing with the world is equal to the second intermediate value minus x4 so the snark is sort of basically doing this crunching on seven inputs um so just as an example suppose that i take inputs 2 4 8 and 5. the result that i'm going to get if i plug all these into the function is 43. the snark is basically going to see these seven numbers that are produced during the course of this computation and what the snark is able to do is it will generate a valid signature of the computation if three constraints on these seven numbers are satisfied and because these constraints exactly represent what's going on with the computation um in this way the snark is essentially proving correct execution of the function so um one thing that's important to note is that snarks can only generate these proofs for constraints involving addition and multiplication so in the previous example with this function this function is very simple and only involves additions multiplications and you know subtractions which are just reverse additions but most functions that we find in the wild and that we might care about could involve other more complex operations like division or modulo so this means that in general if we're writing a zk snark to a zk snark scheme to allow people to prove correct execution of a function what we're going to have to do is we're going to have to figure out how to express um correct execution of that function in correspondence with a set of constraints that only involve addition and multiplication so in this example we have a function that looks very similar to that previous function except this second intermediate value y2 is y1 divided by x3 because division is not a valid operation that we can have inside of a constraint for a zk snark what we have to do is we have to express this step of the computation as a constraint that only involves multiplication so here previously we had the constraint y2 is equal to y1 times x3 in this case this expression is satisfied when this constraint y1 equals y2 times x3 is satisfied so this is sort of an example of a case where the execution of a function doesn't exactly line up with a constraint system that you know sort of proves its correct execution but it is hopefully pretty clear to see that a snark that is digesting these seven values and verifying these three constraints is essentially verifying correct computation of someone who's gone through with these inputs and plugged them into these two intermediate values and ended up with this output in other words correct execution of this function corresponds exactly to these three constraints between these seven values um being satisfied yeah so i'm not going to go too deeply into this but when we start getting to more complex operations like you know um convert some integer x into its bit string uh in an array representation we're going to have to use this trick um or tricks like these even more heavily so you know rather than like there's not an easy way to go from an integer to its bit string using plus and times in sort of the ordinary computational way um but what we can do is we can set up a constraint system that is satisfied if and only if what we claim as the bit string of representation of an integer x is indeed the bit string representation and a final piece of nuance with all of this is that in the snark schemes that we use so we're using circom and start.js which were developed by item three the uh all of these operations are happening modulo a 254 bit prime so you can basically think about like there's this uh problem that addition multiplication will overflow if you go past the the value p that is kind of hard coded into the protocol this often means that if we care if we are doing operations um where we're sensitive to overflow we're going to need to add constraints um that ensure that every step of the computation is not in fact overflowing all right so that's just a quick refresher on zk snarks um now i'm going to talk a little bit about purlin noise so as we mentioned purlin noise is an algorithm that allows uh game developers to build rich and varied um terrain that looks you know sort of random globally but has local structure in other words you can see that this terrain here basically is generated by some function let's say f that ingests a coordinate pair x comma y and outputs a height h and the guarantee that this function gives is that points that are close to each other are similar heights so we're not just like this isn't just a random scattering of points but if you zoom way out then you get sort of these global features but also global randomness so to dig into a little bit at a high level how this parallel noise algorithm works the idea is essentially in order to generate the height map of this terrain the first thing that the perlin noise algorithm does is it splits the terrain into grid squares and then it's going to randomly pick a unit vector and assign it to each grid square all right sorry grid square corner so you can see here we have this little table uh of grid squares at every corner we've picked a random unit vector so a random directional vector with length 1 pointing in a random direction these gradient vectors are essentially going to correspond to these unit vectors are essentially going to correspond to the gradients of the terrain at each of these points and so what we're going to do is once we've picked all of these essentially slopes of the terrain at every grid point we're just going to interpolate to figure out what the value should be at all of the intermediate points so in this example um we've got this heat map on top superimposed on top of this grid uh green means higher and purple means lower so you can kind of see like if you look in this grid square the three vectors that were assigned to each of these three corners were all pointing inwards and correspondingly what that means is that on the eventual terrain we're generating at those three points the slope when you're moving towards the center of the grid square is generally going up so you can see that that corresponds to a darker green region over here in this square you see that the four vectors are pointing outwards so what that means is that the slope go the gradient going inwards is going to be sloping down and this sort of represents like a dip or like a valley in the terrain function so perlin noise basically says you know sample gradient vectors at every corner and then interpolate and then you're going to get like a reasonable looking terrain function and there's a couple more tricks but this is sort of like the base like foundation level level one part of the algorithm um so what does this actually look like mathematically essentially it means that we need to be able to pseudorandomly sample gradients um you know unit vectors uh which is hard to do with only plus and times but we have some tricks that we'll discuss for doing that and then the second part is that we're gonna have to just perform a lot of dot products because we're doing all this interpolation um so we're basically just multiplying a bunch of vectors together unfortunately this is actually really easy to do with plus and times which is why this was the algorithm we picked to sort of start exploring snark implementations of all right so what i'm going to do now is i'm going to discuss some of the specific challenges of fitting all of this stuff inside of a snark the first challenge is that you need to be able to pseudo-randomly sample these gradient vectors at every um grid corner so why is this hard well one essentially what we need to do is we need some function f that i can plug in the coordinates of a grid corner um and as output i'm going to get a random unit vector um so i need something that's essentially going to say like hey you know for every grid corner here regardless for every pair of grid corners um regardless of their if they're close to each other or far away from each other the vectors associated with this grid corner are essentially going to be uncorrelated so how am i going to do that um what i'm going to do is i'm going to use a snark friendly hash function essentially as like a random oracle so there exists snark friendly hash functions like mimsc and poseidon and what they're optimized for is they're optimized for creating these for for basically creating these uh you know random looking outputs you can think of uh while being very cheap to verify inside of a snark so mimsc for example just looks like a bunch of consecutive additions and exponentiations to a fixed power um so by essentially plugging in these grid corner points into a mimsy function and then doing some massaging we can get a source of a function that essentially acts like a random oracle from which we can drive the random unit vector that's superimposed onto each grid corner the second challenge that we encounter is that throughout the process of doing uh this purlin noise algorithm oftentimes we find that we have to do divisions and modulos and operations like this um for example like one thing that you're going to need to do to do this interpolation is you're going to need to determine which square are you actually inside and this essentially amounts to doing something that looks like a quotient and modulo operation now the reason that this is hard uh is well there's a couple reasons why this is hard um the first is because you're already implicitly working in this field uh like all of your operations are modulo p for you know the protocol baby jubjub prime p um and so that means that uh if you're not careful about things like overflow then you can open up your modulo zk proofs to certain attacks where attackers are basically able to um or malicious provers are basically able to pretend that a certain value is the result of the modulo operation when it's actually not um so basically we have this modulo circuit that turns that ends up being something like 100 lines in circom where we're doing overflow checks at like each step um the second thing that you have to be careful about is sine since we're working out we're working in mod p natively there's not really the notion of negative numbers so you have to enforce some sort of convention um where like for example we're going to consider all the residues between p over two and p to be negative and then the remaining residues between zero and p over two to be positive um and then you have to do like overflow checks associated with associated with that um so something even as simple as just like proving that you know three is congruent to eight mod five inside of a snark ends up being like more challenging than you might expect um the third challenge that we encounter is essentially taking the randomness that we are able to generate using or like the pseudo-random values we're able to generate with uh mimsy which we're using sort of as a random oracle and turning those into random unit vectors so inside of the snark we basically have to be able to assign coordinate like a vector that has um uh you know length one and some arbitrary direction sort of determined by the randomness to each grid point um this is hard because typically when you're sampling from uh if you're trying to sample a random direction this is going to involve the use of trigonometric functions like sine and cosine um so the first approach that we tried to this was essentially um you know using the value that we got from the random oracle as the inputs into a taylor approximation of sine and cosine for various reasons that actually involve the fourth challenge that i'll briefly touch on this is actually infeasible so what we ended up going with was we ended up using a circuit written by some of the folks over at semaphore that allows you to select from a list of values so we hard coded in 16 direction vectors and using this selector circuit we're basically able to index into this list and pick from the set of vectors so for any given grid point that we're trying to sample a unit vector at we're going to take that grid point plug it into mim c and get this randomness we're going to take this random value modulo the length of the list and then we're going to use the selector circuit to basically pick out one of these unit vectors from this list of unit vectors um and the final difficulty that we ran into here uh that i'm going to discuss in this talk is that with purlin noise you're going to be dealing with non-integer values so for example a unit vector is a vector whose both coordinates are not going to be integers unless you're at you know one zero negative one zero zero one zero negative one um so we've tried a couple we tried a couple of approaches to dealing with this problem um the first thing that someone tried was implementing a series of fixed point arithmetic circuits in circom um these turned out to be like way too expensive to actually be feasible um so what we ended up settling on was we ended up deciding to do all of our arithmetic inside of our zk circuits with fractions and the way that we'd represent this is that we'd hold as a global constant in our circuits the maximum denominator d that any calculation would ever uh encounter and we've calculated this ahead of time by basically like running the um purlin function in you know another in like javascript and sort of figuring out what the maximum denominator we would encounter was um so we'd hard code that in there and then all of the math inside of the circuit would be done on the numerators implicitly knowing that these are numerators of fractions that are like divided by the denominator um so we're tracking this global constant denominator d and we're doing all this math with numerators and so what this means is that whenever we add two values in our circuit we sort of know that we're adding like a over d plus b over d and we're getting the value a plus b over d and it also means that whenever we're multiplying two values we have to multiply the values and then divide out the extra factor of d that we're getting due to the fact that you know a over d times b over d is a b over d squared um so that's how we got around the difficulty with um these calculations not being integer calculations um yeah so the result of this we have a very sort of basic version of the purlin uh noise function implemented in dark forest which those of you who played in the last two rounds have probably seen basically perlin noise allows us to add texture to the universe by making it so that some regions have richer areas with more resources than others um the goal here though would be to get to a point where purlin noise can be used to create like very expressive and featureful landscapes potentially you know something that could even look someday like the minecraft world beyond these difficulties one kind of meta difficulty with doing all of this is that the development environments and and sort of like the dev tooling for zk application development is currently still quite rudimentary um so i'll just give a quick shout out to jacob rosenthal and blaine bublets who have been working on a lot of tools for zk development workflows but all of these uh challenges are made more difficult by the fact that we're still very very early in zk application development and the sort of workflows that we have are not very developer friendly so if anyone is interested in applied zero knowledge development this is definitely an area that a lot of work can be done in and would be very very useful for yeah so that's pretty much it for my talk um if you want to learn more we have a blog where we post a combination of you know dark force game related content as well as some zk development content at blog.zkga.me you can also find us at twitter at dark forest underscore east um and we will be releasing the next version of dark force in a few weeks um targeting around mid-may um finally if you want to reach out you can find me on twitter as well at bboo33 yeah thanks for having me amazing thank you so much brian on such an interesting and uh i would just say like a very technical but super detailed and important overview of how this is done i think this is a key part of what makes dark force a thing um and that's the uh the actual natural sort of appeal to really relying on the zkp's here so this is super cool um if anybody has any questions from the audience please feel free to ask them on the chat and we'll relay them on on this live uh in the meantime i think you've kind of pointed a handful of recurring themes that i noticed from the talk and and i guess my high level question here is um i would categorize this right now as a cold golfing for a lack of a better category and uh and given how early we are in anywhere from the tooling to the development side to just the number of people who are aware of how these things work to get something um in the application side uh what do you think is sort of missing the mouse here like is it the lack of like we need a standard library for for lack of a better way to think about it or we just need more standards on somebody should just do this thing and we just all use the same library every time or kind of what does that repeatability or abstraction look like yeah so one thing that i think about is that um zk application development i feel like is pretty inaccessible unless you actually have you know some certain level of like math background or a basic understanding of like number theory for example so for example like the particular nuances around the modulo circuit and making that secure are like only going to really make sense if you are very familiar with or have a good intuition for like the chinese remainder theorem it's like why do i need to do these overflow checks here what could a malicious prover actually do well the thing that the malicious proofer could do is like you know like because of the chinese remainder theorem you can do like the euclidean algorithm to sort of figure out what the malicious value would be for the modulating i think in short i think what we need is um you know there's a couple of things one is uh a standard kind of library of circuits that people can kind of plug and play into um another would be a higher level kind of dsl on top of for example zircon which already does like a phenomenal job of making any of this possible at all like it still just like blows my mind that it's possible to program ck snarks at all but the next step is that it should be accessible to program them as well you shouldn't need to be very familiar with um number theory in order to to to build applications like this like an example that i've been thinking about a lot is that cryptography under the hood is very complicated but we've sort of figured out collectively as a space how to correctly um abstract away the mathematical under operations under underneath cryptography and provide an api like a conceptual api for developers to know like oh encryption has these guarantees decryption has these guarantees you know message signing looks like this um and you know this is manifested then in a bunch of the sort of standard libraries in whatever language you're using for these cryptographic operations um and then another thing that i think will be really big i mean that will take a while because i think like it's definitely the case that the protocols even it's not even clear what the what the protocol guarantees are going to be in the future um but uh the other thing that i think about that is always ongoing is dev tooling um to allow for just faster iteration cycles better feedback from um like better feedback loops for developers that's a lot of the stuff that um you know blaine and jacob have been doing which i'm really excited about um so it's a combination of a lot of things but i do think we are very very early no i totally i cannot 100 echoed that and i think just kind of this is the natural evolution of new technologies in general like this is the the punch card to fortran era and then we want the fortrans of python i'm jumping exactly yeah it's just like you don't have to think about how registers work um somebody needs to abstract the number theory here um right right um kind of having said that um super excited to see that you're announcing the new version of dark forest is uh and maybe just as a clarification was what you talked about a analysis of what the last version of it was or how you're using these things to now make the next version uh of dark forest more generated yeah so these were some of the challenges that we've encountered trying to implement um just like a very rudimentary version of purlin noise for the uh last couple of versions of dark force we're still using these and you know continually like working on improving them for the upcoming versions um specifically though what we're also interested in is we think that this technique could be a building block for a game beyond uh dark forest as well or for games plural beyond dark force and so what we're going to be exploring in the next couple of months is ways to bring this mechanic into other kind of prototypes or proofs of concept of you know simple blockchain games awesome well with that i want to thank you so much for taking uh time on friday and doing this amazing talk and uh if you have any other questions that have not been answered we'll release them to you directly and uh for anybody who's gonna watch this later um we're watching this now we'll have a uh a snap or a snipped video of this for the just a pretty many talk available online on youtube later so you can all catch up and check out the slides and the maps directly so thanks again brian thanks karthik thanks for having me 