foreign [Applause] [Music] my name is Peter I'm going to talk about scroll tonight and first of all thanks a lot for joining us tonight I know it's very late and I know most of you are just as jet like this I am so really appreciate that you joined also before we start to all of you who listen to the the optimism introduction uh one hour ago I want to make a public announcement so scroll is in fact the only serious blockchain out there and the best layer to read here so I just wanted to correct the optimism team there so any questions all right so who who heard about scroll hands up okay quite a few So today we're gonna see how you can deploy contracts on scroll and I'm also gonna go into some details about how scroll does what it does and and what is it so scroll is a layer two to ethereum and it's a ZK evm based layer too so our goal is to scale ethereum so we want to have you know more transactions lower fees while we maintain the same level of security as layer one so it's a ZK rollout and why is it a ZK evm basically we want to maintain very high level of compatibility with layer one so the idea is that when you develop on scroll it feels exactly the same way as when you develop on ethereum you don't need to learn a new language you don't need to learn any any other tools you don't need to understand what zero age proofs are everything is done under the hood and you just develop your depth and it's fast and it works and it's safe so that's the idea so we're going to start by looking at how you can get started without testnet and the most interactive part of this Workshop is hopefully you scanning this QR code which you can use to sign on to our test net So currently we're in a permission test that phase so that means you have to sign up you have to get on the white list and once you get on the white list you can get some tokens you can deploy some contracts Etc so you can either open scroll.io early Dev or you can scan the QR code is the same thing you feel it and after a few hours we will put you on the white list and then you can start building um we also want to encourage you to join our Discord and then you can also ask technical questions there give us some feedback uh all this stuff all right so we're gonna have a very simple live demo here if it all works okay so so when you get started on Scroll once you get on our white list the first thing that you want to go to or the first website is pre-alpha.scroll.io this is our so-called pre-alpha testnet and this has all the information and all the tools that you need so metamask configuration faucet for getting getting funds and a bridge to bridge from layer one to Layer Two so a bit about this test net so in mainnet of course layer one is going to be ethereum and Layer Two is is scroll but in this test that we're actually maintaining a simulated layer one so we have scroll layer one test net and scroll layer two test net they are both maintained by us so first thing that you want to do is just simply add these networks to your metamask so that you can send transactions and and query the blockchain on these two Networks so after this you're going to have two new configurations in metamask and this automatically will configure the RPC address and also the chain ID okay that should be pretty straightforward and the next thing next thing you want to do is get some funds so so as I said we're not operating yet on ethereum without operating on ethereum test that we're maintaining our own layer one so you need to get some test ethereum and once you're on the test net you can just request some funds and you will get one test ether and 100 test usdc tokens and then you should be good too so after that you should have some test eth and before you can start deploying on scroll the last thing that you want to do is move your funds to Layer Two So currently from the faucet you get your funds on layer one so you don't have any tokens on Layer Two so you you need to use our Bridge and it's a very simple ux you've probably used plenty of you know similar depths you just enter the amount send the transaction and under the hood we're maintaining this bridge from layer layer one to layer two and it's uh relaying uh tokens like eth erc20 tokens you can also relay nfts which I think is kind of unique or not so uh not something that you see so often but actually this bridge is also it's an arbitrary message Bridge so so if you want to build something using this bridge then we're also open to that so just reach out to us so by the end of this onboarding process uh you open your metamask and now you finally have some funds on Layer Two so it's time to start building and I'm going to use this open Zeppelin wizard here which some of you might have seen this is just a very simple tool for putting like implementing tokens with no coding you can just uh choose the features that you want to have so we want to implement an erc721 nft token and let's say it's a scrollers nft this is probably going to be one of the first nfts on Layer Two uh so it's a historic nft and the only feature that we want to add is that it's going to be mintable so we're gonna be able to meet new tokens and that's about it that's the coding part of this so-called workshop and the next thing I want to show you is how to deploy on scroll and I'm going to use remix for that but as I said the main goal with scroll for us is that we maintain 100 uh even though we are a zero knowledge proof roll up or a zkevm we maintain 100 compatibility with ethereum so you can use remix you can use hard hat you can use Foundry all the other tools that you that you're already familiar with so here just click on open in remix to to open this code and I'm just going to use remix as I would use it on ethereum so notice that we don't have any scroll specific here solidity is compiled into evm bytecode as on other evm chains and then you can just simply go to the deployment part to deploy and scroll so select the scroll add to test net and choose the injected provider metamask and you see that I have my uh balance here and just click deploy and then it should be deployed so at this point if this deployment fails for you when you when you're doing it change chances are that you either don't have enough funds or that you are not on the white list yet so feel free to register or reach out to us and make sure that you're on the white list and now we have a contract deployed and scroll it's actually fairly straightforward just as another example I'm gonna mint one token to my own address so call this save mint function again just confirm the transaction is going to go through within a matter of seconds and uh now we can see it on the blockchain Explorer I minted one token to my address thanks so that's the example with remix and for a more detailed tutorial you can go to guide.scroll.io where we have all kinds of guides about our current test net including a contract development or deployment tutorial and this is an example repo that we have again it's just a very simple contract I think if you've developed an ethereum this should all be very familiar to you and you can either deploy with hard hat or you can use Forge create to deploy with Foundry as you would do another change so back to the presentation so you might ask me like okay so what is the point why what's going on Peter why are you telling me stuff that I already know and I would argue that if this is all boring to you that's kind of the goal that we're aiming for so the goal with scroll is that you're building on ZK evm you're building a layer two but you don't have to learn a new language you don't have to learn a new new tooling a new ecosystem you can just use your existing tools out of the box and it works exactly the same way and when I say exactly it's not actually 100 percent the same so we have like some slight modifications uh if you're familiar with the vitalik's classification of ZK EVMS we are aiming for type 2.5 which means that there are some slight differences between layer 1 and layer 2 like the gas costs might be different because some operations are more expensive in a ZK uh roll-up and the other thing is that some op codes might not work as as on layer 1 for instance self-destruct is going to be disabled but I think for most apps that that should not be an issue so now now that you understand that scroll works exactly the same way from your perspective as ethereum let's dive into some technical details of how we Implement these ZK AVM stuff so here you can see like a high level architecture so we're operating on Two Chains as you would imagine layer one and Layer Two and in our case layer one is the ethereum Maynard and the two main components there are the rollout contract and the bridge contract so the rollout contract is basically maintaining the state of the layer 2 Chain it maintains uh the data from the layer 2 Chain that's the data availability yeah the content of the data eligibility and it also receives the zero knowledge proofs and maintains the state route of the layer 2 Chain the bridge contract as you just saw in the example it's for bridging assets from layer one to Layer Two as I said it can Bridge all kinds of contracts uh sorry all kinds of assets and this is pretty familiar uh pretty similar to other chains and now we get to the juicy part which is actually the layer 2 implementation it has let's say four major components so one is the sequencer node which is responsible it's basically maintaining the blockchain so it's a fork of go ethereum it's responsible for collecting transactions creating blocks and yeah just maintaining the blockchain itself then we have the relayer which is a strictly related to the bridge contract so it's for relaying messages between layer 1 and layer 2. both ways and then most crucially we have this component called roller so that is the prover in our system that is the component responsible for creating the zero knowledge proofs so the way it works is that for each block the roller receives this block or receives some data related or derived from this block and using the ZK evm circuits it creates a proof for this block so what does it actually mean so you could imagine that currently we have state a so stage root is a now we get a new block and now we transition to State B by executing that block uh so we have this state transition from A to B now what the roller does is that it creates a proof for this execution of this block and then using this proof you can actually prove that this transition from A to B is correct you can prove this or verify this without actually executing the transactions so that is the essential part how zero noise proofs are used in in all ZK relapse is that you create this proof of the state transition which the rollout contract on ethereum can verify independently so in our case we have a decentralized network of rollers so if you have a couple of spare gpus and you want to earn some money you can actually uh during mainnet or the next testnet iteration you can actually join our test nuts you can spin up your gpus you can create some zero noise proofs and you can earn some rewards for this and to maintain uh this connection between scroll and the rollers we have a coordinator so coordinator is simply responsible for assigning blocks to the rollers receiving the Xenoverse proof and verifying it uh yeah these are the main components and if we zoom into the roller itself like what is the workflow of the roller the input for the roller is the execution Trace so for the block you could imagine that we generate all kinds of informations about the execution of the block so that includes all the opcodes that were executed all the storage entries that were updated all kinds of information and that is the input for the circuits and the ZK evm itself which we are developing uh along with the ethereum foundation is a collection of circuits for approving these uh different state transitions so we have an evm circuit that proves that the opcode was executed correctly then for instance we have the storage circuit that proves that the storage updates were also executed correctly and we have a whole bunch of different circuits proving different things these all create a different CK proofs that we aggregate into single proof and that is the output of the roller and just one final diagram of this whole process like how does it how do we all put it together uh in terms of time so on this diagram you have time as the x axis and we see the process of uh of the zkevm so you can look at the sequencer the sequencer is creating the layer 2 blockchain so it's creating blocks one two three four and all these blocks are first of all committed to ethereum so we have the data available in ethereum at the same time the coordinator will assign these blocks to different rollers based on some some algorithm and the rulers will start a proof generation session so this is a pretty expensive computation but this only has to be executed once and later we only just verify this proof that was created so for each block we create a proof and then finally we can aggregate these proofs uh into single proof and that is submitted to ethereum to the rollout contract and that is verified independently by the contract so that is how it all comes together hopefully to all of you who didn't know how ZK avms or ZK rollups work this kind of demystifies some of the main ideas zooming out a bit so again our reason is to scale ethereum so it should be faster it should be cheaper and it should be just as secure as layer one and that is what ZK evm does and in our case so there are many different companies working on ZK EVMS and there are different design trade-offs to be to be made in our case we aim for as much compatibility as we can and that means that we're aiming for byte code equivalent so that means that you take the evm byte code let's say from remix or from hardtat that you deployed on layer one and you can the in exactly the same way deploy it on layer 2 and it works the same way then we have a decentralization as a main design component so as I said the approvers or rollers are decentralized from day one so decentralized during the mainnet launch and eventually the sequencer is also going to be decentralized and finally we're pretty much aligned with the ethereum uh ecosystem so we're aligned with ethereum's roll-up Centric roadmap and we're also building the ZK VM together with the ethereum foundation uh so there's a lot of like a very highly skilled ZK Engineers working on this if you're interested in ZK all of this is open source so I encourage you to look into it I think it's pretty complex but this should be a very uh interesting thing too and what can you do so we are a sponsor at this hackathon so we really would like to welcome you to build on scroll as you see if you've built on ethereum before then it's very seamless very easy to move to scroll and uh you can build all kinds of applications because scores is the general purpose layer too for instance you could build some more complex amm taxes that might not be feasible on layer one because of the computational burden or similarly some Landing pools with some more more complex uh borrowing computations or I think a very exciting idea is a Webster or three social apps which I think current systems can actually support the user experience that we would expect from a social app but Layer Two blockchains especially ZK avns might be an excellent fit for this uh or you might want to just build some simple nft projects or if you're interested in ZK you can just build a ZK dab on scroll and the advantage here is that we have a lot of Engineers that are super experienced with ZK so if you're if you choose this route then we're more than happy to guide you and give some help so we have uh two bounties one is for the most Innovative dap and the other one is for the best CK depth and all in all you can get like five five thousand dollars so yeah if you're interested please please join or please just find us uh it's me we have our team members sitting at the back so feel free to reach out to us and ask some questions and finally some resources for you to get started first of all you should go to scroll.io early Dev again to get on the white list for our test net and then you should go to guide scroll.io to find all these tutorials on how to deploy it scroll how to get funds all that all that kind of stuff yeah and finally uh here is the most important resources so on the right you get these slides so you can review all the links and everything on the middle is the Discord of scroll please feel free to join and on the left is my telegram so if you have any questions to me or you have any issues you didn't get on the white list Etc please feel free to message me directly yeah and we're also hiring by the way so if you're a zika engineer if you're interested in you know infrastructure engineering feel free to reach out to us as well all right that's uh our workshop for tonight thanks a lot for joining do you have any questions yeah go ahead yeah thanks for the question so the question was that like how much is proof generation is uh reliant on gpus what is the specific requirements that we have here and how does this relate to you know ethereum after the merge becoming more and more green so I think GPU accelerated CK is a breakthrough in the last few years and that's what makes really easy KVM possible so previously we had more stuff running on CPUs and that was not really practical for any you know any practical purposes uh recently we have GPU acceleration and that makes it practical in terms of running time and I think in the future we might have some Asic hardware for this uh so in terms of the environmental impacts there is some similarity here to mining for sure because we have a decentralized network of provers the consume a lot of energy uh to create these proofs I think there are some very interesting or very important differences though because in proof of work you to like useless work I mean it's useful in terms of proof of work but the computation that you execute doesn't have any uh useful results by itself in our case the computation that you're doing is is actually useful because you're calculating these Decay proofs that many many people will use to verify the state transition in the future so so I think this is not really the same thing or the same concern as as proof of work and also there won't be so much of a armed race here because whether it's profitable for you for to to create proofs uh depends on the depends on the utilization of the system basically the more blocks we have the more transactions the more rollers can join the system and contribute but this is linearly uh you know directly related to the amount of usefulness of the network as opposed to proof of work where if your neighbor gets more computing power then you're also forced to get more computing power to remain competitive I hope that answers the question any other questions what happens if the coordinator makes a mistake so what kind of mistake do you do you have in mind error yeah that's a good question like if if something goes wrong what happens and also given that some of these components are centralized on day one is there any kind of cheating that scroll can do or the maintainer of the coordinator can do so the way it works is that before we even do an SDK proof generation we commit the block data on layer one and uh yeah this this data is available for everyone to see on layer one and this uh at this point it cannot be changed and so this is the comment phase and once we have the proof that is what we call finalize when we make it final uh you know it cannot be reverted what's on layer one so so what can go wrong if you look at the coordinator uh it cannot really fake any proves because all the data uh is available on layer one so only a correct proof will go through and it's a roller let's say fake fix a proof we can catch that at the coordinator level because it's fairly cheap to verify that the proof is correct but even if we don't verify that the coordinator level the roll up contract will verify the zero noise proof and will revert the transaction if there's a there's an issue with that that's a I think there's an interesting question here of uh auditability or like how can we make sure that the zika evm is correct because it's a extremely complex you know set of circuits there's not that many people with these kind of expertise who can review and audit them uh so I think the most crucial part is to make sure that this component of the system is correct and for this if you're any any of you is uh you know ZK Enthusiast uh we would invite you to come learn about our circuits and once you have a good understanding start reviewing and start seeing if there's any errors so there's going to be bounties for this we also hire people just for this purpose to make sure that the circuits are correct uh so that's the efforts that we do thanks for the questions maybe one last question if if you guys have any any more okay thanks again for joining at 10 pm I really appreciate it and hope to see you around at the hackathon so enjoy [Applause] 