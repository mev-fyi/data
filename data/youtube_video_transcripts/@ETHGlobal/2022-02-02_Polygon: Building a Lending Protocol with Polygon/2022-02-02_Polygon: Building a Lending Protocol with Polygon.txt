so welcome to the polygons workshop you're going to learn how to build a lending protocol with polygon we have saraj raval here who's leading the workshop feel free to pop your questions in the chat anytime and saraj will take them as we go along and i'll let you take the lead there okay perfect thank you so much all right everybody so today we're going to be building a lending protocol and we're going to build it with polygon but that's only because we want this thing to scale we want to be able to affect as many users as we possibly can with this and we want it to be something that they would actually use so that means low gas fees and high throughput for each transaction really that's the two key metrics we're looking for we want to build a decentralized lending protocol so i'm going to share my screen and we're going to go through this process together of building it and i might talk a little bit about the background of polygon as well as before we get started feel free to ask questions during this i'm going to be um periodically checking in for questions and uh then we're going to take some breaks to answer questions okay so um this is the repository i want to talk about here this is a repository by alejo costa and it is the 20 token vault example project and i think this is the best way to get started with lending there's so many different lending sample applications on github and across the web but a lot of them are you know 2 000 plus lines of code this one in particular it's like 120 which is still a lot but i think it's the easiest way to get started understanding what these steps look like in the lending decentralized space so uh we'll start off with this project description and then i'll talk a little bit about why ethereum and why polygon specifically that we want to build with so at the highest level the idea here is that we have a user and the user is interacting directly with a vault and this vault is represented by a smart contract on the ethereum blockchain so that is the human to machine interface it is from a user to a vault and what a user will do is they will send some eth to the vault and the vault will then say okay now you've given me say 20 heath i'm going to give you that amount but in usd so in order to be able to convert the cost of heat that was deposited with the price of usd per ethe at the time the vault is going to communicate with what's called a price oracle the price oracle is like a decentralized api it's going to return a boolean value not a boolean value it's going to return an unsigned integer value that represents the price per ether in usd and that's going to act as the one source of truth that's off chain that the vault smart contract is interacting with once it knows the price it's then going to interact with the only other smart contract here which is a stable coin and that is represented by coin.sol and it's going to mint that equivalent amount of stablecoin and then the user will then receive that stable coin as a loan at any time um up to a certain time period that we define programmatically the user can return bits and pieces of the loan that they ask for and then they can get their collateral back or they could pay a lump sum all at once and then receive it then now why is this better than traditional lending great question that i'm asking myself it's because we want this to be able to be offered to people who don't have access to financial instruments particularly in the developing world large parts of africa india south asia we need to get them like lending solutions asap today so you know it doesn't really matter ideologically too much about which blockchains you're building with all that matters is will users find a benefit from it today will it make their lives better and i think for a lot of small business owners especially in agriculture tech you know who are looking to grow their farms and you know we need sustainability and food solutions so badly you can't really necessarily get that from a bank in a lot of countries so they have to turn to protocols like this so i think if you are a developer now is a really exciting time to be building with these tools and i want to kind of show you what the stack is going to look like as we do this together here so this is a good starter example and we can see that it exposes five main functions deposit let's that process that i first outlined or we give it withdraw is when we withdraw our ether getvault gives us the total amount of collateral in the treasury of the smart contract estimate collateral amount that is a machine to machine call we don't interact with that that is what the vault smart contract is going to ask the oracle and then there's estimate token amount again a machine to machine function it doesn't deal with us all we do is deposit and withdraw that's all we do as humans but estimate token amount will estimate the amount of stable coin to be minted given the ether so that's it let's see what they're talking about in terms of installation and then running it okay so it seems like we need two r libraries here truffle and ganache and you're going to see these two libraries pop up all over the place when it comes to smart contract development now if we wanted to just build this with bitcoin which is if you look on coin market cap it is currently the biggest uh cryptocurrency in terms of market capitalization it's been around the longest um the only problem with bitcoin is that it's not turing complete so there's a scripting language that comes with bitcoin that is not turing complete so we couldn't technically build something like this if it say had a for loop embedded in the code nor could we do a wide number of different computations and that's why number two is ethereum ethereum is turing complete it does allow you to be able to do anything that a virtual machine computer would be able to do um and so that's what the origin of that uh computer science term is but the problem with ethereum and this is the problem with every blockchain not just ethereum is that it has these this thing called the blockchain trilemma you may or may not have heard of it the blockchain trilemma essentially states that you have three possible features that you can have but you can only pick two of these three so there's scalability security and decentralization you can't have all three you can only pick two what ethereum has done as it has it has picked security and decentralization at the cost of scalability now how are they going to get scalability this has been the hottest topic in the ethereum community perhaps since its inception about eight years ago and there have been a wide range of solutions that have been proposed the ethereum core team primarily vitalik divides these classes of solutions into two layer one and layer two layer one is the main chain and layer two is the side chain which consists of a series of solutions e2 isn't a one day event it doesn't happen on you know june 1st boom e3 is out it's not like that it's a series of upgrades that are made to the software over the course of hopefully this year in terms of layer one solutions the eth core team is working really hard on what they can control that means sharding sharding is this idea of splitting up large chunks of data into smaller chunks and then having that spread out in a more distributed fashion across the notes and that will hopefully speed up the main chain layer one and there's increasing the block size that could speed things up they're switching the consensus mechanism from proof of work which is primarily what bitcoin uses right now to proof of stake where the network is not secured by computing power computers doing random mathematical work solving the associated hashes for any changes in data takes forever to do that instead of doing that the network's consensus is decided by the number of tokens that each delegate in the space or validator i should say has who is securing the network so it's more representative rather than direct is it as powerful as proof of work i mean ethereum already uses this on a side chain and there are plenty of chains that are already proof of stake including polygon but those are layer one solutions you need layer two as well they're both essentially a part of it and layer two solutions include uh plasma side chains and that's what polygon is right now it includes state channels if you ever heard of the lightning network for bitcoin that uses what's called state channels and then the end game vitalik literally called it the end game in his last blog post things called end game literally um is what's called zero knowledge roll ups and polygon has acquired a billion dollars worth the zero knowledge roll ups here's the blog post i'm referring to end game definitely read this if you're looking for a good great read um but it's his last blog post anyway the end game is our zero knowledge roll ups and polygon has acquired so many of these uh different zero knowledge roll up startups um midan and several others hermes because mere protocol because in order for ethereum to be able to scale it's going to need layer two solutions like polygons so what does that mean for us as developers like we want to not get too confused here we want to be able to build for a single stack and then just have that work for as many people as possible right we don't want to be building different things now the great thing about polygon is that if you are an ethereum developer already you are already a polygon developer so that means that you still program in solidity you still use ganache you still use truffle the entire stack is the exact same now what's the difference we're going to go into that difference today it is a single line of code in your truffle config.js file where instead of deploying your dap to the ethereum test net the london test net you deploy it to the polygon test net the mumbai test net and that is a simple single line rpc switch once you make the switch then um everything is going to be deployed and what happens is that on the network what the validators are the network the people securing the network that are paid to do so what they're going to do is with zero knowledge roll ups they're going to take many many transactions hundreds thousands of transactions they're going to roll them up into a single compressed hash this hash represents all of those transactions they're then going to communicate to the ethereum main chain that hey i have all these transactions that have been happening on my chain they have not been using a lot of gas they have not been using you know they've been very fast high throughput sub millisecond transactions you need to post a proof to your chain that these occurred ethereum is they're going to ask that transaction it's going to ask that validator well how can i know that these are valid transactions then what the validator would will do is they're going to generate what's called a zero knowledge proof and that that is a mathematical proof that's going to be able to tell the main chain i can prove to you that all of these transactions are valid with you having zero knowledge of the identities and the details and the metadata of those transactions and that process is actually very difficult it is in the rnd stage right now how do we design these zk proofs there are different versions of these zk starks zk snarks you know plonky 2 all of these different acronym names that essentially represent the same idea and that is compressing transactional data into a smaller package that can then be pointed to from the main chain for its validity and doing this in the fastest way possible but all of that is to say that we as developers can deploy our lending dap to the polygon chain it will automatically be deployed to the ethereum chain and we don't have to worry about too much other than the specifics of our dap and what the architecture looks like and what the experience looks like for end users which we'll go into right now so you know if i'm a new developer i want to learn about polygon i'm looking at the basics on the website okay it's a pos chain it's got some basics architecture looks cool got this nice image here awesome where do i begin so let's start with this uh repository right here so we're gonna download this right here we're gonna do this together live we're gonna download this and while this is downloading i'm going to periodically uh take some questions here so let me just see how to see some messages here chat okay okay uh we could use quantum computing okay so bitcoin is already quantum resistant the core developers have been thought thinking about this for a long time there are quantum resistant uh consensus algorithms already embedded in bitcoin core um which is awesome so we're okay for now in terms of quantum resistance in ethereum that is also being worked on not at the same degree are we going to do it in parallel uh yes let me send this github repository to everybody in the chat let me answer questions for a few more minutes how does polygon put proofs to the main chain is it using one of the zk proof's algorithm yes it's actually using both of the zk proof algorithm it's using zk snarks and zk starts okay so these are both acronyms we can go into the details but midan is the snarks and then i believe starks is the mere protocol acquisition so they're both doing it differently um in order to build with this we're actually actively working on this in terms of like privacy and the associated features the link is not working let me see why the link is not working oh you're right why is the link not working let me fix that right now um here this one will work this this is gonna github seems down oh github is down during a talk what unbelievable how is github down that's crazy well luckily now this work this works okay great okay uh that worked okay so let's go back to this let's start building again i'll remove the chat okay so we have this um we have this lending dap it's this smart contract we want to see what's in there so we're going to open up node we're going to cd into that directory wherever that was the downloads folder okay once we're in there what's this call this is called lending dab yeah let me just find that file hold on see okay hold on let's get into that make sure it's there it is unzipping i guess it's quite big it's quite big okay great we got it here all right so let's build this so we got to open this up in a text editor see what's happening here before we do anything so we'll open it up see what's happening here okay so we got some code we have some we got some packages okay so open zeppelin is going to be used it's like this test framework for building smart contracts it's got a lot of templates and yes it's good for running on windows by the way um and then truffle is essentially our smart contract testing platform it's got everything we need but open zeppelin is for templates for very popular smart contracts stable coins erc20s um you know nfts erc 721 all this stuff there is an existing open zeppelin template for so that's package.json it contains our dependencies and then we have this very crucial line here now uh truffleconfig.js basically tells truffle where to deploy our dap to and we can see that for the networks listed here we have one main network and that's kovan.infp now this is going to link us directly to the ethereum testnet now if we want to switch this to polygon we merely switch this link and that's what we're going to to switch when we do that but let's just run this first let's see if this can run given what we have now remember here the smart contracts i was talking about when it comes to lending we have this stablecoin token and all this will do is it will mint new stablecoin every time that a user deposits some heat it will automatically mint that equivalent in usd stable token for the amount of heat that has been deposited as collateral and then it will burn it whenever someone withdraws their collateral so it's not going to have that amount so that's that's kind of the idea whenever you know say someone returns their money early then uh it's going to be returned early what do you mean by if we deploy on polygon it is automatically deployed to ethereum what i mean specifically is that the polygon blockchain it it has timestamps of all the actions that occur that are occurring on the ethereum blockchain actually satoshi when he first wrote the white paper for bitcoin he never used the word blockchain unbelievably he used the the phrase time chain to describe the bitcoin blockchain because essentially what it is is it's a collection of immutable timestamps it represents time in an unchanging way just like time cannot be changed the bitcoin blockchain cannot be changed and in that way the ethereum blockchain the time chain cannot be changed and what i mean specifically by connecting is that all of the activity that happens on polygon is as valid as all of the activity that happens directly on the ethereum time chain because there are still time stamps of it but what we get as developers is we get to deploy adapt today that lets our users pay much lower gas fees if you ever have to use ethereum you know how much gas fees are they're very expensive you're going to lose a lot of money people don't have the money to be paying for gas piece like that and also throughput it's a lot of congestion you know on the ethereum main chain polygon they go there goes there are a lot faster transactions on polygon um one more question then we're gonna keep going here so is that ethereum trust polygon or polygon works the same way as any other contract and the proof-of-work miners have to validate that anyway but as a whole commit basically bundle transactions ethereum is able to uh there was a proposal for this specifically to accept zero knowledge proofs as trustless um data i don't remember the specific protocol number for that proposal but there was an actual proposal that was accepted by the ethereum foundation into yes being able to give these trustless smart contracts validity all right let's keep going here so um there are four different smart contracts here like i said stable coin does what i said mock oracle all this does oh this one's actually a fake one we don't have to worry about mark oracle we're not even going to use that we're going to only use three coin.sold to mint stablecoin price consumer to get the price of stablecoin at the time usd from ether from this contract address right here now this is a test um smart contract on the uh main chain that already has a price aggregator so it's already pulling from it all we have to do is transact with it and it will tell us the price the transaction parameter the input is going to be the amount of ether the output that it's going to give us is going to be the amount of stable token all right so and then the last one this is really our main smart contract this is the vault and the vault is essentially a lender except it is a human less lender it is totally automated it is a fully automated lending platform that nobody has to enter nobody runs all the transactions are publicly verifiable on this public time chain called the blockchain the ethereum and the polygon blockchain um because you can actually explore both blockchains using block explorers which are web web apps okay um so let's just briefly go over this before we deploy it like i said it's got the deposit functionality and that is going to take our deposit amount in ether and then buy that amount or mince that amount of stable coins sorry and return that to the user withdraw will do the opposite we can withdraw our collateral and then it's going to burn the amount of stable coin that it had reserved for us so that nobody gets it because you got your uh collateral back these are all helper functions getters and setters for different variables but those are really the two key user facing functions deposit and withdraw that we'll want to work on all right so those are the solidity files three of them and we have the migrations file which is just kind of boilerplate code for truffle we have initial migrations again boilerplate truffle so let's deploy this to the testnet together so if we go here we'll look at the two dependencies we have to install okay we're going to install both of these let's make the terminal a little bit bigger sudo install and once i do that then i'm going to do the same for ganache which is our test block chain i'm going to run npm install to install the rest of our dependencies and then we can actually run this and once we run this it's just going to be a collection of smart contracts on the ethereum test net then we're going to need to move it to the polygon test net by changing that truffle config file or line i should say and then that is when we're going to be able to add a user interface to this right because smart contracts are great but we want to be able to let the user interact with these smart contracts from the web deposit add their metamask account you know be able to say hey i've got 10 ether and metamask but i want a loan let me go to lendingdap.com and deposit that ether it's going to connect to metamask it's going to return stable token let's say usdc to that same metamask account and it's fully automated right just and it's interacting from the web with this smart contract on the ethereum blockchain now where does this dap live where is it stored right that's a good question to be thinking about as we go through this thought process it's going to be stored on the interplanetary file system which is a decentralized aws bits and pieces of our web app dap are going to be running from across different nodes that don't know each other but that are all paid with their own token it's called file coin but we don't look at any of that we can we can deploy it directly using this great interface called fleet.co and fleek.co is awesome it's free it's a way to deploy an app think of it like a decentralized heroku we just deploy our app to um fleek it will deploy it to a collection of ipfs notes for us and then all of this is time stamped on the ethereum blockchain they're pointers to all this data so that's the way to think about this architecture we have smart contracts we have a user interface the smart contracts are on the ethereum test net and then they're on the polygon test net once we switch that and then we have the data that's stored in ipfs via fleeq and we ours users are interact with all of this via our regular chrome or whatever mozilla web browser that we're using or brave and that's it that's how it works so let's do that now and i see that some people have some problems with installation that is that is going to happen did i have any problems no i did not i personally did not have problems so let me install ganache i installed truffle now i'm going to install ganache um in terms of issues that could always happen but um you know for that there's always stack overflow i guess i could answer some questions here too but let me continue this because i feel people would um yeah enjoy this so we installed both of our dependencies truffle for building smart contracts ganache for running this on a test uh blockchain and npm install for installing literally everything else and then once we have that we can run these tests and it's going to compile the smart contracts for us then we'll have to add a user interface to actually use this so you know yeah let me see some of these chats can we actually mint uscc i thought we meant a new stable coin actually mark you're right these are new stable coins i just have a habit of calling stable coins usdc but there are a wide range of stable coins and it's not usdc um if we wanted usdc we would use the usdc api um specifically but no we're minting a new stable coin one to one with the us dollar well hosting it on ipfs slow down the process i mean slow down the website um uh so ipfs uh will not slow down the process if the nodes are located close to where the user is interacting with them so basically the more the more decentralized the dap is the more nodes there are this the faster it gets so it's kind of this positive feedback loop where the more people that use it it inherently guests faster without necessarily to having to optimize a bunch of things manually it's just the nature of how the distributed web works where it is not ip addressed it is content addressed so the more decentralized and all over the web these pieces of content are that means the more users that are fetching and getting and sending this content the faster it gets because the content is then replicated more and so it does basically depend on the number of nodes fleek can pin uh your content to yes yeah and you're right it doesn't require pseudo i just pseudo everything because i don't like errors so let's run the this test blockchain here like i said we're going to run the test block chain make that bigger so now ganache is going to be running at port 7545 it's going to give me back a list of contract addresses okay so now i've got these 10 contact addresses contract addresses each has a million ether don't worry about stealing them they're all on the test net so the money isn't real but what is real anyway that's a good question to ask what is real um let's now execute the test suite we have our contract we have our test net running of ethereum and now we can uh run the test net okay so unexpected token what is going on here okay so of course there's going to be a little issue when i try to run the test suite so as any great or mediocre i should say developer i'm going to go to stack overflow and i'm going to see what the hell the problem is here with uh truffle deploy in terms of catch there's a syntax error okay so this person's getting it as well it can be avoided using bash i'm not on windows so why should i okay this specifically doesn't matter to me um this is not related to my problem but i have ethereum dot stack exchange here okay so this was a single line you got to delete the line in deploy contracts.js ah okay gotcha right just delete that file and edit it gotcha so i will do that i will delete that file and edit it i'm going to delete contractsdeployment.js okay and then in initial migrations i'm going to deploy this it says change this to your contract name so i will change that to migration deploy to i'll just create a new file test call it test and it's called test.soul and it's just got nothing in there and this is going to call migrations oh not soul i need to call it test.js i'm going to remove this from it okay let's try that js whatever okay let's see if that works nice that did not work okay that's okay um that is fine so we're gonna we're going to do something different here entirely we're going to deploy this to the web via um remix because remix is a web ide we can just as easily deploy it but we don't have to deal with this right now because i'm probably not going to fix this within an hour so okay let's deploy this to remix which is a better way a faster way let's say it's not a better way but it's a faster way yeah let's see some of the yeah oh it might be the env variable right to the live demo gods yeah that's how it is that's how it is right okay so we're on remix we're going to deploy this smart contract to remix and we're going to call it what are we going to call it we're going to call it um lender lender dot soul under dot solidity it's going to open that okay i've got lender.solidity here and then i'm going to go back i'm going to see what are my three all i care about really from this repository are three different um contracts that's it and i can deploy them from here anyway right so interfaces and then i have the vault so the vault is easy it doesn't have any dependencies so i can just start with this one right here the volt and i will deploy that to remix just like that two remix here we go we got the vault all right and i'm going to call this um i'll call it i volt yeah okay so once that's there we can compile it by going to the compiler and compile lender.sol that's going to compile this smart contract and once it's done compiling i think i compiled it yes i did okay i can publish it to ipfs and this is going to give it a content address these 25 characters are the content address that represents the smart contract and then in the smart contract what we can do if we want to create files for users and records for rows and different things is we can add to this what ipfs this file structure the way it works is it is a directed acyclic graph a dag a merkle dag that means that for every new piece of data a new node in this merkle dag it's kind of like a tree a binary tree it's very similar is created and all of these dags create new hashes and all the hashes point back to the mother hash like the main hash from which everything chains off of and so at the highest level you can think of our website our dap as having a single hash that represents all of the content all of the data inside of it which is nested inside of this merkle dag which ipfs creates it's kind of like a file structure but we don't have to worry about that functionality ipfs does it for us all we need is the highest level hash of our content which can be accessed via the ipfs web and what fleek does is it is a gateway between the ipfs colon slash web and the http colon slash web so users can interact with your dap but from the http www web 2 right so they don't have to switch anything up too much there's a gateway until there are native browsers for ipfs which in a way brave is doing that in others so let's keep going we compiled it now we're going to deploy it and okay it's got to be it may be abstract not implement abstract current's method completely so we're going to get creative here and we're going to go ahead and do this locally i know what to do so here's what we're going to do because this doesn't want to play with us this is development by the way we're gonna i'm showing you the pain of development it's gonna be hard but then it gets easier let's keep going here i have a great solution to this we're gonna go to the academy this is a newer uh initiative that we're launching at polygon it's called the academy if you ever wanted to learn how to build with polygon i've been personally working on this for a few months this is the best learning resource i've curated all of the best from across the web it's a great learning journey from start to finish top to bottom you'll earn nfts as you do it for free there are four levels check it out academy.polygon.technology all right but what we're going to do is we're going to go to this dap starter kit and we're going to add our smart contracts for this lending dap directly to the starter kit so it's already got the front end for us it's already got um the integrations we need with truffle and ganache and open zeppelin and so we just have to run it download it compile it let me send it in the um chat so people have a link to it the starter kit so everybody has it let me uh see what's going on okay so definitely check out that link i just sent it in the chat i've downloaded it locally we're gonna run this starter kit and then add the lending dap smart contracts to it directly so it's unzipping i already have ganache i already have truffle okay and i'm going to create a new react app with the template polygon starter kit okay so i'm going to name my project something and then with mpx i'm going to do this okay so i'm in a different so ganache is running right ganache is already running we just need to deploy some lending dap smart contracts to this so i'm going to make sure this is open starter kits and right now let's see what it's doing it's expanding it so it needs to be able to expand that okay look it's got it and now i will add it make sure i can add this i can cd into it okay so i'm in there and now i will run this but my way so it's going to be the project name is blender and it's going to have this starter kit here okay create react app boom okay so it's creating a new react app installing the components doing everything it's got to do we're moving we're going in the right direction here we have ganache running we have a test net waiting for us okay and actually that test net right now we can switch to polygon by the way so let's do that go go to ganache run polygon command or something what is it it's like run it on polygon i think it's like yeah cli yeah what is it with cli we can do it from the cli okay um all right so this is taking a lot of uh it's doing a lot right now let's do one thing at a time so this is still loading okay good let it load and not cli and then we switch the network to a specific command i'm looking for right now yes here it is it is in the docs all right so cli yep okay there's a cli okay interesting yeah yeah istanbul testnet so here's like that so we'll just do that in a different so we have that running in a different tab on terminal i think that's going to work yeah okay so now this is running on polygon our test net is running on polygon we can close out the ethereum one and this is at a different port now this is at uh what is this this is that or eight five four five not seven five four five eight five four five so we have that good we have our polygon block chain running we are waiting on the starter kit to load we are so close to it but so this will load we'll take those solidity smart contracts that i explained we'll add it to this and then we'll have a user interface ready then we can deploy it to fleek and we have a com website whatever you know web 2 gateway we call it specifically uh to access the decentralized web okay so i'm running pretty lost okay let's um slow it down then we need to make sure we have everything for the starter kit running so all i'm trying to do here guys is create this starter kit which is it contains all the dependencies we need that's all and if we have that we can cd into it and then we can just run it let's run this starter kit and also see what it looks like inside so i'll open it up with sublime and i'll also just a bunch of node modules got a package json i can npm run start so that starts it locally missing the start script okay how about now it needs something else i think it needs some test stuff nope let's see mpmi yup that's the one thank you watch it's gonna get mad at me because i didn't pseudo but that's okay yeah all right yes please ask all questions here thank you thank you okay permission tonight see i i knew the pseudo would fail or the lack of pseudo i should say pseudompmi see this is really like that finals step to really uh make sure everything's working here yeah i just need to to install this like basic set of packages to run the starter kit and then we're going to add the smart contracts and then deploy it to fleeq right build it have it run locally make sure we can visualize it it's on localhost it's connected to the test net and then add the smart contracts for lending deploy it to the test blockchain deploy to fleek show people show investors raise money rocket ship to the moon go crazy in a good way so that's what we're trying to do here we're trying to build high quality depths that people actually use you know we don't want to just build another depth we want to actually build something scalable here yeah so we are we are using the starter kit to create a new react app okay and then we have this set of smart contracts that is not user facing at all they're just like test smart contracts um but what we're to do is we're going to combine these two repositories into one and a lot of development today is essentially combining repositories right and creating something novel something novel is almost always if not always a combination of the sum of its parts nothing is truly unique except it is a unique combination of what already exists so we have a starter kit that one thing it does really well is it combines all the necessary dependencies um into one repository well so nothing breaks and then we have the lending smart contracts and what it does well is it allows a user to be able to get a loan without having to consult a human to do that so how about both if we have both that's why we're combining them then we can have something that scales so this is going to take a while to load the dependencies here hey sorry to interrupt but we're just running a bit um overtime maybe you can take some questions wrap up and we can move it to discord yeah it sounds good sorry about that we can take questions joanna asks i am building planet earth global digital jurisdiction starting to build an interface with proof of humanity very cool allowing people to get planet earth global passports to live and work wherever they want want do you think i can build this on polygon so first of all that's a really cool idea i love that idea um we definitely could use that as a society so i definitely i think uh i'm i just think that's a really cool idea in terms of can you build this on polygon yes you can i think it would be the easiest to build this on polygon today if i were to build something i would do it with polygon today because i want it to be scalable turing complete but i don't want it to be slow and expensive so that's why i would make it for polygon um and especially you know for people in the developing world uh who can't afford some of the higher gas fees because they're priced in a different current a country's currency and subject to inflation and all of that your zip code where you live should not define who you are and the tools that you're able to use yeah i need to install dependencies before the next session next time we're going to continue this on discord yeah we have an east global planning meeting today as well so that's going to happen in a few hours we'll continue i'll be on discord again siraj a very informative session and yeah if you have any more questions we'll catch up over this court and look forward to seeing you for the next workshop by covalent see there thank you thanks bye 