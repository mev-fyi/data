concerns i think we can wait for a few minutes it was a really great quest to figure out what the room we are and how it finds so let's maybe one more minute and we will start so hello to everyone so great to see you here and especially on s global hackathon maybe you know that gearbox originally was a finalist one year ago and really i so appreciate the hackers who create something interesting something new in the fight space so pretty happy to be here and be honest we are very very open so uh feel free during hackathon to ask me or my teammates to help you everywhere because we are burned from hackathons so it's pretty native to be there and let's start talking about gearbox and what we are working on so gearbox mission is to bring capital efficiency in device space and we create the way how to create a composable leverage in the file so at the moment in the second version we can achieve x12 leverage and we provide leverage as a service so we do not focus on make imm with leverage or a service which could help you to open short or long position instead of that we create a really interesting protocol which could provide you ability to use leverage funds across the five protocols and this feature opened a really amazing opportunities because you can create a lot of new composable strategies and another thing which very very significant at this market that there is no funding raise so let's start and make hence jersey from architecture side so as you can see gearbox is two side protocol on the left side you can see liquidity providers these people who are looking for passive strategy they just provide liquidity to get high api and it's available they are looking for they are not willing to sit at the computer 24 to 7 find best strategy and so on and so on and to be honest i am a trader if i go and believe that bitcoin will go up it will immediately go down and so on and so on so for people like me liquidity providing is a good value because i shouldn't spend my time i want to put money and that's all but what is really interesting is the right part and here you can see a trader this guy want to be a more capital efficient so trader could open a credit account credit account is in unify primitive this is isolated smart contract so when trader sent funds to this credit account this credit account could immediately take margin loan from the pool and after opening this credit account trader could send different financial orders or transactions in our way to get this could be executed on behalf of credit account on third party protocol so let's check how it works step by step so on the first point as i said you as a trader could open credit account and here you can see trader provide 10 s and takes 9s from the pool so after opening credit account trader has 100 s each credit account is nominated in one asset so here you can see credit account which is nominated an easy room which simply means that debt interest rate and fees are also in s and then when you open credit account you can use it across different protocol however you have no direct access to the funds so basically you can't put money into your pocket however you can use it for different strategies on different protocols and let's check how it works so from the technical side as a trader you sent a transaction and usually transaction is address and the call data but instead of send sending this transaction to unisvab for example you send the same call data to a special smart contract which is called adapters so basically you have unisopt3 adapter uni swappy to adapter curve adapter and so on and so on and sending transaction to such a contract this transaction would be executed and credit account funds would be involved so basically from developer side you send the same transaction to credit account likewise you want to use and then your funds would be executed so we have a few checks to understand that pool funds are safe the first one we should be really ensured that the contract you want to interact is white listed i think it's a pretty simple the second point that we want to understand that the token which you could get as a result could be used as collateral pretty simple if you want to swap s to die it's okay if you want to swap s to some coin it's not good for us because you as a trader use not only your own funds you use some pool funds and we should be insured and the last check after transaction was done we checked that health factor is more than one which means that we have enough collateral to pay debt back maybe any questions at this point oh it's clear okay so now let's check what means this health factor and how credit account could be could be considered so basically on the right side you can see credit account as a list of different assets and each asset has quantity and price which is taken from chain link price oracle so basically we can compute pretty simple values the first one is portfolio value we can multiply each other quantity to price summarize and get how much money in underlying asset which is s in our case we can get if we swap everything immediately it's pretty clear yeah the next point which is called threshold weighted value or tvv at this page means stress threshold weighted value so basically uh liquidation takes time yeah and during degradation time price can go down so we could make a over characterization however in hour it's a huge over collateralization like 50 percent more in gearbox we use a parameter which is liquidation threshold lti on this slide which represent maximum expected price drop during liquidation time so basically it works as is price is going down health factor becomes one so this credit account could be liquidated by third party liquidators however we have a liquidation threshold which becomes a buffer to have enough funds to send them back to the pool and this liquidation threshold could be close to one for two stable coins for example die and usdc because we do not expect in a few more blocks that the price between die and usdc would be dramatically changed correct by the way as opposite if we have two assets like bitcoin and die of course bitcoin price could go down drastically at this space liquidation threshold could be 0.6 or 0.7 to create enough buffer to be liquidated and after liquidation have enough funds to pay back debt and interest rate and as you just get a discount from uh portfolio value so you as a liquidator because everything computed with changing price feed which looks like pretty fair prices get five percent discount so basically if portfolio costs if portfolio cost 100 s you can take it from 95 s and 5s would be your profit to swap everything back and pay to the pool and simply health factor is just the ratio between threshold weighted value and borrow amount plus interest rate and it's pretty clear that if health factor is less than one that means that threshold weighted value is less than borrow amount and this account could be liquidated any questions at the moment guys do not hesitate because it's pretty complex or not or is clear okay it's okay it's okay okay cool yeah so basically yeah you you can really imagine that credit account have a few boxes with different coins and each your transaction then you put coins from one box and put into other box and then we recompute the value and understand is it enough for us money to pay back so each transaction i know it's a pretty uh strange words but even if you put something into a farm you get some lp tokens so basically you uh subtract from one token and increase the quantity of lp tokens so basically gearbox then you switch in tokens between these boxes or these boxes could be viewed like a table like credit account and then this pretty simple must help us to keep your credit account to be able to pay this debt back and it's really create a good things for us so basically as i mentioned this this crazy accounts you can work on behalf of them with many defy protocols so what we should really do with you is to write a simple contract which is called which is called wrapper which is called adapter and this adapter has the same api like original one if you want to write adapter for uniswap v2 this adapter will have the same api like original smart contract and all stuff would be encapsulated so if you want to use funds from credit account on gearbox you create the same transaction like for original uniswap just make call and methods like create interface in hardhead dot get call data and write methods and parameters you get call data and send it not the original one to adapter and it would be executed so it's a pretty simple integration and another part which is also pretty interesting based on that because credit accounts are really isolated smart contracts each of them has their own balance so you as a user could definitely go to other scan figure out your credit account and get balances and there are one more interesting feature which we implemented with wallet connect because you can connect uh gearbox as standalone application with some native interface like uniswap or earn or something like that to get direct interaction and this uni swap or earn a curve would really believe that you behave on uh behalf of this credit account so a short video we use wallet connect for this purposes and here you can see we enter this wallet connect link then we go to uniswap interface and now it connected to our smart contract and then because we provide the same programmatic interface you have balances from native way and you can really sign transaction as originally so it's totally native experience for end users whoever funds are used from created account smart contracts so basically you sign up through meta mask and all magic happens because it looks like your metamask credit account may be a good example i tried to say it's like a credit card in real world you can open it once and use across many different uh shops or restaurants the same logic here you open your credit account as another smart contract and then you can be half and then you can execute any transaction and build strategies in a more native way uh so just a few questions uh and a few comments here if you talk about gearbox it's a pretty interesting way because uh we really address different segments here for liquidity providers as i mentioned this is a passive uh people who are looking for passive strategies they just provide funds and that's all and on the trader sides it's people who are really could create more value through their strategies trading positions and so on and so on and it creates a good market for us because there is no funding great and if you compare us for example this perp which also works on leverage or square is on the both sides of this protocol you can see pro players and if it's a bull run everybody wants to buy a 0 because we expect that as price will go up it's why funding rate could also increase because nobody want to be other side correct and gearbox total opposite because we do not compete we do not play each against other because this uh guys on liquidity side take value from just providing liquidity for high apy and guys who work on the trader side on credit accounts are pro guys who know how to trade how to make profitable strategies how to earn money and gearbox could be considered like a platform which shares money from people which they helped for capital efficiency and provide to lp site and basically maybe the solution as i said i'm a sheet trader how to provide money and get some some part of profits and let's check how it works maybe on let me check on programmatic say any questions at this moment guys please do not hesitate because it's a pretty complex stuff i know it's maybe not so so basically to understand how to works programmatically with gearbox we have a website dev gear boxify and you can check all these explanations and basically as you can see here we have a lot of such things which connects pools and credit managers which simply a contract which simplify all operations there are another layer which is called core contracts and if you want to get everything you maybe can go to contract discovery option and understand how to figure out and how to take these contracts but if you go to the credit account sites what i believe are pretty interesting maybe it's how it works so from technical point we have a user and user could send transaction to adapters and credit facade which just an interface to work with other stuff like open and close credit accounts provide additional collateral and so on and so on and when you send a transaction it goes through a filter you can see then the code transitioned to this credit account and then it executed on behalf on it on third party protocol in v2 we support uh seven major defy protocols it's uni swap v2 uni swap d3 sushi swap curve careful p tokens as well convex urn and lidar and basically let me share i think maybe it's more interesting for you strategy you can build so maybe it's not the latest presentation but here you can see here some interesting things like yield generation short long position so here you can take x10 leverage then you can go to open credit account and drop btc then you swap to usdc and then you can open short position and put your stable coins into urn so what's impossible because there are a lot of leverage protocols in the space when you can just short and do nothing with this stable coin in gearbox you can simply put it to earn to generate additional apy and it makes your position more profitable and if you found sometimes that it's not profitable you simply could switch from wire to convex to get more apy and it has pretty low overhead because your funds on credit account and you manage them as your native wallet another possible way is to work with lidar with the same things you can get x 10 leverage then open uh zero uh credit account so your debt is always in s then you really take this s and put it into convex and you can get around 40 percent apy because as i said totally is composable you can move funds back and forth to get more api and create pretty complex strategies and we really do not want to show maybe all things i really believe that you can create a lot of stuff what could be used for gearbox and maybe a few ideas here uh that it's how it work from uh feature which we designed for v2 which is called multicall so basically what you should do is just to write an array of things you want to execute in gearbox you can see here i want to make a swap so i uh generate code data for this call so i want to execute function which is called swap tokens for exact tokens it's pretty well known for uni swap v2 i provide amounts what i want i provide path which should be used then and address of created account however it's automatically replace it to existing one and deadline then i create a list of calls and just call function which is called multicol and it's done so the easiest way to build strategy you just explain the system what you want to get and they say do all this stuff and only one collateral check so basically overhead in gas cost could be close to you do everything manually through metamask and then you will pay around 200k it depends how many assets you have for full control check and that's all and you get x 10 leverage which is pretty cool from my opponent uh what's more we have some strategies and ideas about ribbon and so on and let me check from here yeah so basically we try to explain all stuff and provide some additional information how it could be executed so feel free to check here um if you have any questions and as i said from gearbox our best goal is to create great developer experience i believe it's a complex stuff so feel free to provide us feedback which things should be really explained more especially from documentation domain it's a pretty significant for us and maybe a little bit more about things and limits what we have we work with token which have changing price oracles sometimes people asking can i add my sheet coin or not not unfortunately because it have no price fee and it definitely depends price chaining price fit because now we have some conversation with our maker and market leaders to clarify what's the best solution to get price fits on chain in 2022 and chain link is a leader at the moment maybe maker has owned their own um price fees but by the way it's a pretty simple when you start new token and even if it's traded on binance it doesn't mean that it have enough liquidity and if we start to use it as collateral and you as an honor owner of this token have 90 percent of supply it's pretty simple to change the rate chain link will provide the same diet data but at the end of the day it couldn't be considered as good collateral the second limit gearbox yet works only with erc20 tokens which also pretty uh understandable and the latest things that uh to add new protocol to a system we use dao and gearbox dao is a very very active so feel free to go there a lot of people could help you and tell and provide support so basically that's all if you have any questions let's discuss and i will be happy to answer or it could be in person during the hackathon good question you talked a bit about the dab and i noticed that there was a graph with the insurance part so the dow insuring the pool oh yeah yeah cool thanks for question yeah you talk about this insurance yeah now treasury yeah so basically this question is related how gearbox earn money because we take two kind of fees the first fee is like some overhead for interest rates so uh we take a difference uh between interest rate for lp providers and traders and it's like uh 10 percent so basically if you have four person on the pool it would cost 4.4 to trader and all these funds would go to dow to the pool back but what is interesting we do not provide this fees directly to the dow treasury instead of that we reinvest this funds to the pool and then put lp tokens which is called diesel tokens into dow treasury and this approach has a very good three advantages the first one we increase pool tvl by putting fees there the second point tokens which are in doubt treasury generate more income because lp tokens and lp rate is going up with usage of gearbox and the third part if liquidation was a little bit later than expected and we have some loss to keep this lp token rate on the same level because lp earned money then rate of this lp token goes up each time we get money back on the interest rate we burn some token from doubt burn some be talking from doubt treasury and cover this laws so gearbox has automatically working lev insurance for the pools however of course we need maybe more time to generate enough lp tokens in doubt treasury but they really behaves like automatic insurance for all our operations which create additional level of safety but thanks for these questions amazing more questions yep so with that mechanism there's increased liquidity in the pool however if there's ever a late liquidation would everyone suffer including the treasury uh not in treasury so basically treasury holds lp token from each pool now we have four different pools so this picture could be replicated four times we have die usdc wes and rabbit ec basically each pool generates lp tokens when you close you credit account all fees are transferred there so if you have some late liquidation on some particular pool this lp token which correspondingly connects would be burned automatically if we have not enough balance this insurance wouldn't work of course we consider this way and by the way i believe it's totally honest because it creates a good responsibility from the dow side to create really realistic parameters because thou manage these parameters about uh interest rate about interest rate model and so on and so on and thou should take responsibility with their funds to set up this parameters correct if they would be pretty high nobody would come and now could not generate more fees if they could be pretty low it could be a lot of late liquidations and thou would really leave money through this mechanism so it's create a good feedback for doubt to be focused on parameters with responsibility and maybe a few things which could be really done maybe during the hackathon two days it's not much to generate i totally understand that so visit him we have a few ideas what could be done of course the first point is to build some adapters and just to show you how it works uh basically i don't know i think we should have yeah so it's not uh surprisingly and extremely difficult so basically you can see how it works line by line it's an adapter for unisopt3 can you hear font or i can make a little bit bigger let's try yeah is it better yeah nice thanks so basically it's how to build uni swap v3 adapter parameter so we take original function which is called exact input single this parameters and all these data structures was taken from original unislapping3 we provide the same interface like original unislab and as i said if you send this call data to original contracts your own fund would be involved if you send to gearbox adapter the sample data it would be uh executed with credit account funds then the first point we get your own credit account so there is pretty simple function which called credit account reward if you have no credit account yet sorry you will be reverted if you had we will definitely get address of this isolated smart contract which holds your funds and which funds should be executed the next point we really call to credit manager to check that this transaction has enough allowance because it's like automatic improvement and we have to policy for some contracts which we really trust like uni swap we can create max in for some contracts we do not trust we increase this allowance and after transaction we set it to zero but union swap three we totally trust if something happens with uni swap it would be end of defy and we can go to build mobile applications for pizza delivery or something like that so no boring then we really update the recipient of transactions so we want to get money back on credit account not to send somewhere just for security reason then you can see we really prepare uh call data with updated parameters and then it's pretty interesting we check balances of two tokens which would be swapped before just getting this balance off function then we really call function which called execute order and this function translate your call data to credit manager which translate to credit account execute on behalf and return bytes which decoded to amounts out and then you just should run pretty simple function which is called check collateral change and this function do all other magic it compares how many collateral it was before and how many collateral you have at the moment just comparing the difference as i said gearbox is like you move assets between different boxes and if it's enough cultural it's okay it's done if there is some lack of credit your transaction would be reverted it's how we keep things so as you can see it's a pretty simple to build an adapter for third party protocols and start to work there another point which we really definitely believe could be interesting is to build oh is it clear at the moment or any questions yes uh another point which is also could be pretty interesting is to build organize funds upon credit account because sometimes people special institutionals they do not want to behave from one account basically these people you can really make some strategies on credit accounts side and provide tokens for people who trust you as a trader it's also an option like a shares of future profits it also could be interesting and of course different strategies how to invest this money how to get earned from convex from um earn and so on and so on a few days ago uh ilgis our co-founder has a really interesting strategy to invest a part of money in the white dx because it was a negative interest rate and some of them in the gearbox and this difference could also generate additional yields so it's do we do not limited only this gearbox you can be totally creative here and maybe some infrastructure things uh people also asked for so we want to eliminate liquidations when someone is liquidated it's not well for this person and for the protocol to of course we take liquidation fee but it's not we are willing to create nobody could build a reliable business on liquidations as a protocol so maybe any things like connection these protocols who could provide additional collateral like device saver you can build your own boat which could emergency send funds to you you can simply swap some assets for example as i said there is a liquidation threshold so if you ho if you have depth in stable coin and you have wrapped btc of course because liquidation threshold round 0.7 it's low valuated and maybe as emergency thinks you can swap btc back to stablecoin which would increase health factor as result maybe something's there because we definitely want to reduce the quantity of liquidations and maybe ivan has ivan can you really say hello yeah yeah but basically you can provide some additional info about strategies he is a very well experienced guy in strategies and how to earn money very successful guys so basically if you have any information about defy and all the protocols he could also consult here more questions yeah how many positions can there become yeah so basically we have such a things which called all over talking list uh it limits this 2256 tokens because to reduce gas cost to compute this portfolio value we have a few ideas the first one we keep inside the contract like a bit mask and one as a bit means that this token has non-zero balance and we should check it because each computation like quantity of token multiplied to price requires ice to go to price feed requires us to go to token contract and of course on scale it could be not well so basically at this point we have optimization to keep this bit mask to be more gas efficient another point which was implemented in v2 if we found that we have enough health factor we stopped to check in because we do not we do not need to know how many house factor you have we should just prove that it's more than one so it also and as i said because we use bitmask in 256 we have 256 tokens in v1 we have i think around 15 tokens in v2 it would be around 50 tokens as well so many things and basically up to you i think it's cool if you won't even have a lot of them because basically liquidation price and to make liquidation profitable it more depends on minimum allowed borrow amount if you have a huge credit account taking five percent could cover a lot of expenses if you have like one hundred dollar take uh taking five percent it's just a five bucks and there is no way for you to make this liquidation assets are profitable from changing yeah so pretty cool questions thanks for asking yeah so just a little bit sure about so we have a oracle things we have a special contract which is called price oracle it's a core contract which create like a service for other credit managers to compute such stuff basically for basic assets we use this chain link and for lp tokens we have a special contracts which compute these prices based on chaining price fees so let me show an example [Music] yes so this is an example how we compute for example why yarn how we compute why yarn price so as you can see our price oracle has the same interface like original chain link price feed so when you call latest round date which is done by price oracle it really get at first uh underlying asset of iron then we get price per share from bayern pool five year volt then we have limits to be more safety because sometimes maybe someone could find the way to manipulate this price per share so to really uh reduce this risk we compare and if this price per share is out of bounds we immediately reverse and then we simply multiply to provide such a thing so basically this approach could be really used for earn for curve lp and for convex as well so we do all this stuff for you however if you are willing to integrate new protocol maybe you should start to consider how to compute some uh prices for tokens which you get slp tokens there [Music] [Music] yes basically uh as you can see using our you can get up to x3 leverage it's the best case in gearbox you can get x10 which is much more efficient and another point which is also pretty cool so let's consider how it work if we start to think about competition so basically let's assume that traders start different strategies some of them provide more profits some of them provide lower profits and it create demand for pools so interest rate goes up and this interest rate makes some strategies less profitable so people should really switch to most profitable ones so for example if you open as a trader earn position when it was four percentage then the price go down it you have to really switch to convex to generate more apy and it's why we create pretty cool uh interest rate for liquidity providers because liquidity providers uh [Music] get like a part of your profits here if you found a good way to get six percent api from convex it means that you will get four or five on the liquidity providers pool and it's okay more and more guys could go there provide their money for passive strategies gearbox like a money market which can find good market equilibrium with extern leverage i think it's a pretty cool at the moment yeah absolutely because gerbos has a limited assets you ask if you have a limited asset in our you can really provide 1s get i don't know 0.8 usdc and it's not a leverage at all but by the way you are definitely can work with this usdc with all protocols in space in gearbox we have limited protocols however even adding these seven major defy protocols could cover maybe eighty percent of needs of traders and strategies but we are pretty open as i show you on uni swap three adapter it's pretty simple to build such an adapter and connect more and more things i believe we have maybe some lack of the five protocols which we could trust because of course we have some serious attention to security and if this protocol do not pass a few um goods if it this protocol do not get some security audits from well-known firm we simply as a dao i believe do not connect it because it's a high risk and maybe using our funds you can do that but in gearbox we create more safe way in connecting things have some conversation to go to another chains but at the moment we want to focus on zero main net at the beginning we are still very very gas efficient view more gas efficient than our so if you want to open some um short long position gearbox would be like 13 percent gas efficiency cheaper so we focused on that but when we would have enough liquidity find better pmf strategy and people who use gearbox on everyday basis of course we can ask them which network are really needed for you to make more money and we will follow real needs not just to be deployed on 10 networks and then have a few users everywhere so i believe we should really solve customer problems that just to go and check what's going on on other networks any more questions what's about timing i went we have one hour 50 minutes so if you have no questions as i said we really definitely believe that we want to create a great developer experience so feel free if you get stuck ask me i think you can find yeah maybe some interesting ideas is to share what things can be done compulsively so that hackers can qualify for a few things at a time you know like the cross nomination with other sponsors like oh yeah it's it's it's totally possible uh can you maybe provide some additional information on twitter so yeah like for example notification with epms may be uh based trading with you idx rates as we mentioned adapter for one age sentiment are also yeah i i think it's a good point because as i i started gearbox is about composability so we do not want to compete with other staff instead of that we try to combine and really work together so i think it's a pretty cool idea to be integrated with more sponsors and create more value for end users because in v2 it's also pretty interesting way we create this feature called multi-core as i mentioned so you can wrap a lot of stuff in one transaction and basically you create a widget for third-party site you just go to lida and you can see you can get stake s or you can press a button and get staked as with leverage when you press this button it opens a widget you can set up how many uh how much leverage you want enter amount and then in one click it opens your position or increase existing one if you have over the open credit account and for end user it create a very smooth ux because you shouldn't definitely go to our website either you can really go to third party website make a one click and it's done and now you have x10 like the position which could generate a lot of stuff so basically we are really looking for developers who would be happy to create such uh things to work together and to be truly composable it's a good point um so i i think i would maybe yeah let me show if you yeah wait a second you can go to gearbox.fi to check uh so all things you can go to our channel on discord for s global or to go to dow because a lot of supporters zeros and gearbox dials are pretty active to help you will be here in person so feel free to ask and one more question today i have from developer about test nets so i as from my experience i participate in many blockchain hackathons if a project could be shared by a link so you can provide an ability for person just open your application and it works on test net it create a good experience for people and for jury as well so basically we have v1 deployed on coven and to fulfill these needs we create a special service which sync uniswap pairs it syncs chaining price oracle as well so you have prices updated with current mynet and we i got the same problems when we deployed the first version it was like 1s cost 400 bucks and people say oh it doesn't work it's buggy there is no prices in a system like 400 bucks after that we create these things so if you need extra tokens copy zero as well we can support you and provide wherever you want to be deployed connected uh feel free and at the end of the day you can make a really working application on cohen and i believe today we will deploy the second version requires much more syncing contracts because we are going to think earn convex and curve as well to provide a really smooth experience so deploying on common playground you will have the same services the same protocols like on mainnet i think yeah i think time is up here thanks so much thanks guys thank you for your attention and i hope today we will and this weekend we will be something really interesting thank you bye so [Music] [Music] yeah i mean it's your stuff that's gonna pop up [Music] i shouldn't [Music] [Music] uh [Music] so go to go to um we need to set up we need to turn off mirroring yeah [Music] is [Music] and then [Music] so use that [Music] [Music] oh [Music] [Music] um [Music] [Music] that's like [Music] what's up [Music] i'm just closing everything [Music] okay you're ready [Music] [Music] let's make sure [Music] [Music] here [Music] do [Music] [Music] [Music] oh [Music] [Music] [Music] all right great thanks for joining us we're really excited to tell you about mina zk apps built on the amina protocol which is a layer one blockchain focused on zero knowledge with zk app smart contracts and a zk bridge to interrupt with ethereum and other blockchains today we have a few presenters myself i work at owen labs i'm a pm for zk apps we have evan shapiro the the ceo of mina foundation who will talk about the zk bridge and then we have brandon case an architect engineer at owen labs he's going to talk about snarky.js walk through a hello world and give some more info to help people get going okay let's talk about architecture as mentioned mina's later one blockchain um our main net was launched march 2021. the big difference with mina is whereas other blockchains are large and increasing in size as new blocks are mined for instance bitcoin is 402 gigabytes in size and ethereum is over one terabyte mina remains a fixed 22 kilobytes in size all you need is this one zero knowledge proof to verify the entire history of the chain we call this a succinct blockchain using recursive dk snarks the current state of the blockchain can be compressed into a single zk snark letting anyone instantly sync the blockchain with the security of a full node an enormous amount of research has gone into zk snarks lately both inside our company and across the industry and our cryptography team at owen labs has created zk snark we call kimchi which is setupless efficient and extensible and it's based on plot 15. and you might be wondering if we have a 22 kilobyte block chain how do black explorers query this historic transaction data we have a type of node as one one of the many nodes in our network called an archive node but and black explorers can query the historic data through that but you don't need any of that data to verify the the actual chain and the consensus of it and so with mina based on zk snarks we had an opportunity to re-envision the design of a smart contracting platform so let's talk about how zkf's work as a point of reference let's look at ethereum dapps so at ethereum street i'm sure most people are familiar with this on ethereum smart contracts execute on chain users send a transaction specifying a method and data arguments and every node across the network executes these same instructions it solves a real problem but it's very inefficient in contrast mina zk apps use a different model we have off chain execution and the smart contract runs in a web browser using wasm a user will execute one of the methods on a smart contract and private data that that a user inputs into a method will end up the smart contract will generate a zero knowledge proof which gets sent to the blockchain along with a list of state updates if that blockchain is is proven to be correct for that particular zcap account so this gives us a few advantages we achieve blockchain scalability through succinctness we have that 22 kilobyte proof to that proves consensus so that source of truth always remains very small which of course is the key aspect of a blockchain we also get user privacy through zero knowledge because the smart contracts are running off chain in a user's web browser any data that the developer wants to keep private they can they can specify private data arguments that will be input into the smart contracts that the blockchain will never see and then we also have the opportunity to have unlimited option execution so zero knowledge proofs have a unique characteristic where no matter how large your computation is whether it's it's very quick or very long it doesn't matter because that zero knowledge proof that results from running that function will always be quick to verify so we send that zero knowledge proof to the chain and the chain can always verify that very quickly so how does this work a zika app consists of two things so just as a matter of terminology we use the term zk app to talk about you the ui the user interface and a smart contract and the smart contract is written with snarky.js so brandon in his portion about snarky jazz that's what he's going to help people get started get started with so how does this work when a developer writes a smart contract and they run their their build in their application it generates approval function and a verification key the prover function runs locally and generates a zero knowledge proof so this is what's going to run in the user's web browser when they're interacting with the ck app and then it also generates a verification key that they deploy to the network so if you're a developer and you update your application logic you will build again and generate a new verification key that you deploy to the blockchain and then you have a new new deployment so any transactions will then have to pass the verification key whatever at that point in time so again the point of verification to the the chain creates what we call a zcap account this is exactly identical to a mina account however when the verification key exists on it we call this a zk app account and transactions will they have to be valid as mentioned for the the verification function and they won't be accepted by the network if they are in fact appropriate for that zcap account and that's how we can ensure that even with off chain execution that we know that that that zero knowledge proof that the user has run the expected computation um and if they haven't the the transaction will simply be rejected by the by the network okay so in a little more detail let's talk about how a smart contract works a smart contract keep in mind we're running in the user's web browser accepts a few different things we have method arguments which can be private data and then we also have some smart contract states which is public data that lives on the blockchain [Music] and this generates a couple outputs so updates to the stated smart contract that public state that lives on chain and updates to the state of the world so maybe you uh sent mina and you changed somebody else's balance and one really important thing to mention is we have what are called preconditions so if as a developer if you want an action to only occur such as sending funds from account a to account b after a certain block height you can specify certain preconditions and you can specify those based on either the uh and something that's account state related or not network really related even that way too okay and smart contracts the really cool thing about smart contracts on mina protocol is the written type scripts so you have the opportunity to use vs code npm prettier a whole bunch of technology that you're already familiar with and you can download if you want to get started today you can download our zcap cli so for brandon's presentation just keep in mind that if you can run two commands and have a project set up and and be ready to go uh with your p with uh your projects uh and i want to pass to evan to talk about the bridge awesome thank you so yeah i'm going to talk about um a part of mina a really cool component called the zk bridge so this is is this question of okay we have this cool zcap functionality how can we make this useful and available on all these other platforms because we have very efficient zero knowledge proofs maybe there's some way we can get that to other chains which seems like it would be a pretty cool thing and valuable to everyone else on those other platforms so the answer to this we have is this dk bridge which like leverages mina's succinctness for a cryptographically secure bridge to ethereum and other chains typically secure bridge to ethereum and another genes the current you know merkel root of the amino ledger the current state of the muna ledger is correct and has valid consensus information backing it since the beginning of time and you can check that's your knowledge proof and know that you're looking at the correct state of mina and what's cool is this is lightweight enough that we can run that itself inside of an evm contract so that's as if we have a full node of mina in a sense running inside of a smart contract and what's cool then is that anybody can then update that smart contract because the smart contract itself can run mina's consensus and like you know strongest chain rule so it's like this decentralized way of having a contract that contains the strongest state of mina at any time and then what's cool is that with one bridge update so one like verification of a recursive zero knowledge proof you can move over all the state that has changed on mina since the last time you updated the recursive zero knowledge proof on ethereum so if that made sense great if not we're going to run through an example so um you'll see how it works in detail um the example we're going to go with is let's say we wanted like a private proof of attendance so this is like you know i think there is actually group of tennis programs cool this is like a private version of that um and we want to make that work between mina and ethereum so the way this can work is first what happens is um a developer is going to write this program called was at ethereum that runs on mina and a user can create a new zero zika app account i mean up with the verification key for the app the developer wrote great so far and the data field on this is you know all zeros because we haven't filled it in yet but we'll fill it in in a second next that happens is user submits a zero knowledge proof that says okay like in this example i have an identity that identity's been verified by a third party like i went to like the dmv website and like looked at that page and it was good as well as an actual um validity amsterdam pass and they matched and then what i can do is i can make a zero knowledge proof of that and submit it to mina and then that allows me to update the data fields on mina and this dk app in this example to my ethereum public key so note that if i didn't have a valid zero knowledge proof that contained this private information about my attendance i would not be able to update the zk app with that public key and it would just be all zero still but because i was i was able to add my ethereum public key into the mina account great so what's next is that we have to get that minas data count onto ethereum itself and for that we're going to look at what i've called here like the mena bridge account on ethereum which contains as its data not not the whole tree actually but just the merkle root of the tree for mina's ledger and then an operator someone who is wants to update that account in a decentralized way can send over that merkle route and consensus information back to ethereum and if the consensus information in that new proof is actually stronger than the proof that was already on ethereum it updates to that latest latest proof and latest merkle root so after this our microbrew that happens to contain the zk app which happens to contain my ethereum address is now on ethereum great so after that we can so in this example it's like a dao for people that happen to attend here what we can do is someone can attempt to register and the registration process includes a merkle path from the mina merkel route in the ethereum smart contract down to that account that contains that ethereum public key and the user can prove that that was included that that corresponded to like the verification key that actually corresponded to the zk app that was written and that um they actually have the private key that can make signatures which correspond to that public key so in any so in any case so with this they can register themself into a dow using a zk um proof that they have the rights to do that so i i hope i didn't go to that too quickly but that's basically the flow that one can imagine for how you can write something on mina that takes advantage of zero knowledge proofs and then from ethereum or other chains you can then access that as part of your application so there's a bunch of possibilities one could imagine with this you could build a private dao if you wanted to you could pull real real data into like bootstrap more defy things you could build nfts that have some cool zk properties one in particular i think would be cool is like a collection where each person can own at most one nft so like if you have a bunch of capital you're still limited in how much you can take from the collection um you can put like anonymized proof of entry information for ethereum or other chains uh you could build zk-powered games like battleship is like a good one whether it's a privacy element um i think another thing that potentially will be cool well at least interesting is uh making it possible to actually move private enterprise data onto public chains for that interoperability without losing the privacy aspect for those as well as one thing i think is also very cool it's very easy to spin up a zika roll up in this framework because the cryptography is done you just kind of have to like write the recursive step for your zk roll up and then do that option and then submit a big proof back to you know but that's that's all i have for this part um thanks see i'll hand it off to brandon [Applause] hello cool okay i'm going to talk about snarky js so um snarky js is a a toolkit sdk that lets you build zk apps and you use typescript um and so because it's typescript as jason mentioned we can use open technologies uh the the actual execution happens in the browser or node.js typical runtime environment you can use existing javascript and typescript libraries and tools that means you know you can also use like vs code and you get the all the benefits that you get from vs code all the id support of just javascript and typescript that thousands or millions of person hours have been poured into um you get to use that so cool snarky.js um i know like uh maybe some of this stuff seems really scary um after uh you know we saw the details of the architecture and and the bridge example but the code is really not scary um i will prove it so uh in a moment um first so uh i want to talk about like the the base sort of unit of data in zero knowledge programming field element so a field element it can store a number that's almost 256 bits in size for the field that mena uses you can think of it like a un 256 in solidity um but it's just slightly smaller um for those that are like zk like crazy uh people um the the the field in um like the field type in snarky js this is the base field of the pious curve and the scalar field of the vesta curve in in mina's uh pasta curve system uh unless someone on my team corrects me and i got those next up but um uh so but if you don't know what i just said it really doesn't matter um just think of it like a 256-bit unsigned integer um so yeah so so uh in typical programming of typescript like you might sum two numbers by you know creating a local variable uh and then writing the integer literal one the symbol plus and then an integer literal three i guess i don't know numeric literal i don't know what you call them in javascript but um those are javascript numbers in typescript uh we can't override like numeric literals so we have a little bit of like wrapper glue um to to sort of tell the snarky js engine that we're using field elements um so this is how you would add you know one and three and this is a little cumbersome so there's some syntactic sugar um uh anywhere that you that like it's unambiguous what you mean um the the methods except like a numeric literal a string literal that corresponds to a number or um you know another field element so uh you know it's just like a little bit slightly more you know characters than one plus three um cool so there's other built-in types besides fields um here's a few of them uh so besides field bool is one and this is just a field that's constrained to b01 but it has a bunch of helpful methods on it for things that you might want to do with you know pools we have unsigned integers of sizes that are normal for machine like computational machines like this laptop and then public key private key signature that for for mina's system uh we have a schnorr signature um and then some other cryptography things group scalers uh the scalar is the you know other field in the recursive pasta system um again it doesn't matter if you don't know what i'm talking about um they uh all of these have built-in methods on them and because it's typescript and in and because we have vs code and other ids like that you can just you know import one of these things create an instance of it and then write like you know your variable name dot and then autocomplete will just help you explore the sdk you can just write functions um so in typescript you know you write a function like this you can give your uh parameters types and you can return a type um and here we are adding one to x and then doubling it or multiplying it by two um just like in uh typescript i mean it is typescript but just to really show you uh we we can take a part of that expression and assign it to a local variable um so it's just it's really normal programming i'm harping on this because if you attempt to program using any other zero knowledge proof framework uh you will miss um you know normal programming i think um so let's go through a simple hello world okay a hello world smart contract so um we're going to write a smart contract that has a single like piece of state a field element that we call x and we're going to constrain the uh well we're going to have one method called update and we're going to only allow update to replace x with its square so just to give you like a sense of what i'm talking about if we start at three the only update that's valid is nine and and if we're at nine the only update that's valid is 81. um so if we start with you know three update it to nine and then we try and update it to 75 uh the um actually the proof won't even be created but if you try and like send something you know messy or if you try and spoof the chain it'll also reject your transaction cool so let's write it first we extend smart contracts you just write a class extend smart contract we make the state by adding a member variable with some decorator stuff and this this line of code's a bit confusing i suppose but it's doing so much for you that it's it's amazing um so so uh what what this says is um x is a piece of state that lives on chain um and its type is field uh and and you can actually use any type that's built out of field elements here um which i'm not gonna show in this slide deck but you can see in our you know examples um again and this is public and on chain uh so we're going to say what happens when we deploy okay so i mean you know by default there's some things that happen but we want to override the default um by setting it to three so we call super.deploy with the input and we set x to three okay so now the actual update method um so so uh let's just speak about methods i guess um smart contracts have multiple methods or they can this one only has one um and and these are the like things that you can do to a smart contract so this is like the functions you can invoke on it um and uh and jason was mentioning this but um i'll say it again with with the code uh the the state the the member variable there that's public that's on chain um anything you store there is publicly readable you know if you store a hash then only the hash is publicly readable but it's public um the arguments to the methods are private and they are only you know they're only visible on the user's machine and if you don't put them in some public state they will just remain private in this case we are putting it into public state so you can see that online the third line of that method um so uh so yeah so the other thing that's happening here is um on the first line of the method we're calling this.x.get which fetches the current state of the zk app from the chain and there's some magic that happens that gregor can tell you later uh where like this isn't actually asynchronous because we sort of get it before this runs so uh but the point is uh i mean there were a couple reasons we did that but a nice benefit is you don't have to even worry about like async await you can just write normal plain sequential programs um so so that gets the state um and and then the uh and then and then we we do this thing on the on the second line where we uh add an assert um we assert that the square of x is equal to the thing that we passed in um and and this isn't just something that uh i guess typically when you have assertions you put them in there for sort of your your sanity as a developer but this is actually something that is uh sort of part of our smart contract um and and the the thing that actually happens when we run this uh again this is like jason talked about this in the abstract i'm gonna talk about it in the concrete um what we do when this executes is we we produce a transaction that that says it has a proof in it that says we ran the code in this update method with some private arguments um and and the result of that were the following instructions that get sent to the chain uh in this case set x to be nine that's that's the instruction and it assumes a precondition that x is three so so that gets baked in to the the smart contract if if the transaction is sent when the state is not three then this will fail which is what we want um because we only want to update it to its square okay um so so this is kind of what smart contracts look like i mean this is a very simple one but there's there's member variables which you can use for state public state you can override the deploy method and you can add methods with this at method decorator that correspond to the specific you know updates that you want to perform on the well to the network i guess cool so now to test this there's i guess a lot of things you can do the thing that we recommend that you do for this hackathon because it is the most easy to use um at the moment um is testing locally so uh so we have so here here's an example um uh so so what we're doing here at the top we're grabbing an instance of this local blockchain you can kind of think of this like a sandbox vm literally it's like part of mina that's compiled to javascript so it's it is um you know accurate accurately emulating the real blockchain um and uh and then and then we uh we send a transaction um using account one is the the the one who pays the fees for the transaction so you have a private key there um and then uh and then and then in there we're only deploying the smart contract in this example and then sending that's that dot send at the end so and then you know we can also at the top here we can send an update we can update it to nine and then and then afterwards we can we can get account states um and then you know print them out or uh you know check them against something else in like jest and adjust test if you're a web programmer you'll know what that means or you could just put that in another executable for your testing purposes yeah so i also want to just show evan touched on this but um roll-ups here's a roll-up and it's like 10 lines it's probably like going to be 50 lines if you actually get you know unwind the dot dots but like it's 50 lines a zk roll up um this this api we have not fully wired in but i just you know thought it would be really cool to show so um you know at proof system um you extend proof to make a custom proof that's not uh you know like this proof isn't actually on chain uh we like create the proof and then send the proof uh through our smart contract on chain so we extend something different and then uh the you know maybe you're like you deposit money into the roll up you can like send transactions between accounts within this roll-up environment and then you can merge proofs together so uh yeah this is pretty cool uh the one thing i also want to just touch on this for people who have tried to use recursive zero-knowledge proof programming before it's probably not a large number of people but if if this is one of you um you you uh you have to flip between like the two different fields um every time you recurse and this is actually like really complicated uh and annoying to to write code for um and uh the pickles recursion execution engine in mina um like double flips for you so uh all this means is like you really only have to think in one field which is really uh something that makes your life easier so that's that um how do you learn more um well you can go to these places so the docs the discord you should also look for people with these hoodies most of which are members of either the mina foundation or of one labs and we can help you uh you know understand things um oh and the other thing i want to mention um we are like in real time um getting like we have uh we have successfully deployed zk app transaction like zcap smart contracts to a live test network uh and interacted with them uh in a live network environment um in in constrained conditions and we are actively at this second working on making those constrained conditions less constrained so if you are at a point in your hackathon project where you are like i'm done i'm tested it's great and i want to hook this up to a live network then you should look for i'll look for people in these hoodies and we'll point you to the person in the hoodie that you should talk to and uh yeah so that's that um do we have time for questions i think [Applause] um yeah do we want do we want to mic the question answerers i can just talk really well i'll i'll repeat your question okay so given the like constrained size of the chain like how do you infer the yeah so um the question was given given the constrained size of the chain how do we how do we get the state of um anything that we care about uh okay so um there's like a lot of nuance and a lot of different answers so i will answer the question that i think that you're asking um which is and you tell me if i if i'm answering the wrong question um so so this 22 kilobyte number um actually on our home page there's like a uh a superscript and you can click on it and it's a blog post that i contributed to that explains in detail exactly what we mean by these 20 22 kilobytes if you read those details um you'll see there's a proof that's like one kilobyte ish um and then there's like a bit of metadata and a merkle path to an account that you care about um and uh and if you so so how do you uh how do you get the state that you care about you ask a node that has some state um and i just want to highlight the nodes that are participating in consensus and mining blocks they have the current state of the world um you need that to produce blocks you do not need that to be like a full node in the security sense but you need that to produce blocks so there are a lot of nodes in the network that have the current state of all the accounts um there is no node in the that's needed for consensus that has ancient archive state as jason was saying there are some that do because sometimes people want it but it's not needed for consensus but it is needed for consensus to produce blocks to have that state so sorry this is a long-winded answer um but you just go and ask those nodes for the state in the same way that like you go and ask an arbitrary ethereum node for like your account and it gives it to you um it's the same thing do you think there's any limitations with um doing all this boost because they've seen this series there's a verification fee as well yes also there's constraints that need to be met for the proof when it comes in as well as it goes into it do you think if i had like a really big program that i was running do you think that i might be you know yeah yeah the question was um are there constraints on like how big the program is given that there's this fixed verification key um and the naively the answer is yes there is a fixed maximum size that your computation can be per verification key and this is true however because we have recursion uh we can just recurse and loop a bunch of times and do very complex things that don't fit without recursion in to one proof i guess i'm realizing that might not make sense to people but uh it is true so that's the answer uh yeah yeah so to use some snack theme algorithm that like doesn't require a setup for each and every new section yes very good question and i wish that we had mentioned it in the talk i'll mention it now um the mina zk snark does not have a trusted setup it is a it is a false god that i don't know i don't know what the term is uh it is untrue that like snarks imply trusted setups some people have this meme it's not a real thing our snark does not have a trusted setup um and therefore and it's universal and you know someone one of our cryptographers can correct me if i say this wrong but that means that we can basically change what the circuit is at runtime and change and in mina's case we can recurse arbitrary new circuits into the main vena circuit so all this means like when you are writing a zk zk app when you're writing a smart contract you can deploy an arbitrary new circuit and it gets folded into mina and there's no trusted setup there's no setup but uh is there no trust so uh there is full trust and no or sorry you trust no one uh because um the cryptography works without trusting a setup i mean you said that your setup is not trust like did you have like a ceremony no mina did not have a ceremony because mina's snark does not require a ceremony yeah it's more so it is it is safe and the cryptography is even safer than i think i think ceremonies aren't that like untrustworthy personally but but mina didn't have any ceremony and so it's even more safe than if you did so yes it's safe good cryptography i mean it's newer cryptography so some sometimes that scares people but we have very smart researchers and research papers and audits and and uh you know people reviewing stuff so i think it's fine okay yes yeah so actually the recursive zero knowledge proof uh way that mina compresses the blockchain is sort of orthogonal to the consensus mechanism and actually an early test version of mina we implemented proof of proof of work because it was easier but we didn't want to release that so it's proof of stake because we chose that we wanted proof of stake and specifically the consensus mechanism is a variant of auroboros which is um called oroboros samasika and you can look online and read about it there's a bunch of talks and papers and things oroboros was originally created by the iohk cardano folks and mina tweaked some things to make it work in a succinct environment yes yeah so um uh yeah i think so one thing i'm really excited about is uh bringing um mina proofs to ethereum through the bridge as non-transferable nfts um i think that's like an awesome cool thing that that like framework for building that has not been written it would be a really good hackathon project um i'm i'm going to contribute to judging on one of the projects and if someone influenced that and it works like i will vote for that project i mean like uh yeah so um the answer is like uh you should build that i don't know um the the bridge the the zk bridge uh isn't deployed yet right so um uh so you can't actually run it yet on like on ethereum ethereum but you can still build the infrastructure so that right when the bridge is deployed we can do that sort of thing um so i hope that sort of answers your question sorry the question was how do we um how do we interact with erc 721 nfts uh in mina and i guess with mina um i answered one one half of that which was how do you output them uh and then the other half is how do you input them uh and that is the that is also part of a bridge that doesn't yet uh fully exist um but also if you build part of that um it would be a good hackathon project and you can talk to if you have the if you feel like you have enough in your brain to understand how to build something like that um you know one of us in the hoodies can help you understand how to you know do that as a project another question so like if i do i understand correctly that the bridge um basically like you could use it to reduce fees from like um instead of finding the proof on chain on the ethereum chain you have to just verify the miracle path right so that's the the gas optimization that you could do right uh the i well you have to yes well someone is verifying the mean of proof unchained like whoever is updating the bridge but yes once it's already there it's just the merkle lookup okay right yes and that's um so is it supposed to like uh is the me now like are you supposed to update the the bridge on the like who runs the bridge yeah um the uh there are a lot of entities that could uh run that uh like post those updates um the i bet evan has thoughts on decentralized and one can be an operator and if you want to help us test being an operator then you should also reach out i'll repeat on the microphone um the the plan is that uh well it's decentralized anyone can be an operator and we and meena foundation as represented by evan says that uh they want i'm part of one labs separate company um uh they want to help people be operators if you want to be one of those operators you should talk to someone in a hoodie and we'll help you learn about that the question is how does the fee system work um so yeah i think jason mentioned this but um because the all transactions in mina and actually even before zk apps this is how it works um they they all correspond to verifying a proof um they're all the same price so uh they're all the same price um i guess there's some nuance where there is a way to build zk apps such that like a single method um like a single method that you write in stock.js actually like compiles to several transactions um and then you pay per like per extra transaction but it's a fixed gas cost per transaction and you know that means you can do some crazy computation which the user will pay for because when they're when they're using your application they'll perform that computation but in you don't pay for it with gas i'm curious if i have let's say that pending transaction and every one of the transaction wants to interact with one smart contract does it mean just one to enact the transaction will go through and the nine are invalid because good question yeah if you if you build your state machine in such a way like this example where um there's like a sequential ordering of updates that needs to happen um then uh if then there's a race and whoever gets their first wins and the rest are invalid but you can design your state machine and there are a lot of ways to do this in zk apps and like conceptually you you can design your state machine such that updates can be reordered and and that is what you should do if you want that property but it means that you have to think a little bit harder about how you design your smart contract please so that's a really good great question because with the option execution model and off chain storage which is in progress as far as making it elegant there are a couple different approaches to that also the preconditions we mentioned the network preconditions and account preconditions i believe that we can work on that to create very elegant preconditions that might be tailored to a specific app that could really really help address that and then when else when we have roll-ups as well and actually one of our zkip builders in our recent program has started a rollup that would have another opportunity to provide sequencing as well for you know a particular app and use case cool any more questions uh oh go ahead um yeah so the question was um sometimes we need to store things off chain because uh because they're they might be more complex i should just mention because we didn't mention this in the current test net i guess this isn't set in stone um we're thinking that each account has eight field elements worth of storage on chain which is a very small number so so yeah so a lot of times you'll have data that isn't on chain um and the question was what happens if that data gets lost um and the answer is uh your application won't work but mean it will still work so so it's up it's up to your to you as an application developer um i guess sorry there's a couple answers to this the current answer is it's up to you as an application developer to solve this problem in the way that you think is important for your application so the easiest thing to do is just like have a file that has the state in it and you you can think of this as like a single sequencer and this is from my understanding how basically all the l2s work right now that people have a lot of capital on and people seem to be okay with that um you can do something that's more safe and decentralized by you know having like a tendermint chain that keeps track of the state uh or you can have you know the merkle tree in like some i don't know some flash drive that you like hand to make a copy of and hand to your friend so you can do anything for it for the state and um uh the the well as a snarky js toolkit developer person architect whatever i'm called um uh myself and jason and a bunch of other people we will be we will be working on ways to make you know to solve this problem uh in sort of more cookie cutter ways so it's easier for application developers to make that decision and they can just kind of take something off the shelf but right now it's a little bit more manual um yeah hopefully that makes sense cool i think we're out of time actually so thank you remember you can just anyone wearing these colored hoodies um and and or these links um you can come and ask other questions or whatever and please build stuff there's prizes uh i think someone's gonna announce that um so yeah [Applause] we have prizes okay so [Music] do [Music] do [Music] do [Music] [Music] [Music] do [Music] so [Music] do [Music] [Music] my [Music] [Music] [Music] so [Music] [Music] [Music] [Music] [Music] do [Music] [Music] [Music] [Music] so so [Music] do [Music] [Music] is [Music] [Music] [Music] [Music] do [Music] [Music] [Music] [Music] [Music] [Music] so [Music] [Music] [Music] my [Music] [Music] [Music] [Music] [Music] [Music] [Music] [Music] that yeah so the way i tell people put it on the biggest part of your wrist um uh uh up yes you 