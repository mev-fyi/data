[Music] all right good morning uh thanks for coming to this workshop about realizing the full potential of work three it is really about how why would be ebola network and what touring hybrid compute which is only available in bulba would help developers build more engaging more interesting or compelling workflowy applications so let's let's go back in time a little bit right to the original creation of ethereum and the fundamental premise of ethereum is that while bitcoin which is a ledger is good if you can actually program it it's even better computer is very competitive and our hypothesis is there let's take it one step further a more connected computer will lead to a more creative and powerful decentralized system just to give you an analogy right we all have a phone and imagine creating mobile apps without the cloud right you're limited to what you can do on the device itself and that's it is you can still build apps that run on the phone but it's not nearly as interesting right and that's what we do here so you know we started with bitcoin bitcoin script minimal stack based programming language is really designed it's very transaction oriented it's not touring complete and then ethereum came along breakthrough innovation right however it is slow as we all know and there's a good reason for that um the heroes are designed to maximize to optimize for raw compute performance it's designed to be a decentralized system right with with thousands of uncoordinated nodes that could somehow come to come to agreement on something and and that's really hard and in order to achieve that there has to be a lot of limitations imposed on the kinds of computations that you can do that we can do and for example you can only do integer operations reason is if you allow floating point operations what if two computers are running on like different cpus and they come back arrive at slightly different answers it won't be they won't be able to come to consensus and and so so that's why ethereum is is slow and and the computational complexity is very limited right we can only do pretty basic computations you can't even take the square root of a number and get a reasonably precise answer but then l2 layer 2s came along and while the original motivation for creating layer 2s is to address the most obvious challenges of ethereum which is speed and throughput and cost right there's actually an additional major advantages and that's enabling more complex complications and that might seem a little bit counter-intuitive people don't think of layer twos as delivering that kind of benefit right let's using the labels a little faster cheaper oh that's awesome let's just look for transactions to layer twos well the key difference what what is the laser later really is is is we're decomposing this monolithic layer called ethereum that combines execution sentiment and data availability all into one layer we're taking the execution layer separating that into into its own layer and we're calling w2 and the key difference between layer two and layer one is that a layer two doesn't run its own consensus protocol right the whole point is that we rely on layer one for consensus so we don't need to do our separating these two now certainly because of that we don't need to worry about what it takes to ensure thousands or ten thousands of computers will arrive at the same as because relatives are only responsible for execution and what does that mean right it means we don't need to impose the same kinds of constraints on the kinds of computations you can do as you would need to on the layer one and that changes everything right so on layer twos there's only a single sequencer that produces a blocks it executes the transactions and therefore we thought well maybe we could use use this to to advantage the developer's advantage to interact with the outside world to call external apis and after a year's worth of work we're able to overcome evm's restrictions by modifying gas so we have a customized version of guest running on boba network it's called lgtt for touring ltt geth with atomic support for generating random numbers and making any external api quality that you specify that you trust and it's super simple to use very easy these are one line calls what you see on the screen is the pseudo code but like look at the first example touring get random that's all you need to do to get a random number or the second second example you specify the the rpc endpoint that you want to call to let's say get the current call for btc usd pair boom like one column when you're done now how does it work right so let's look behind the scenes a little bit so our l2t gap is the one that that actually makes the external api call on behalf of your smart contract right so it will intercept certain calls that have tutoring calls embedded in them and then called the option api or brand to generate a random number and when the results come back our guest would replace the original call data with modified call data that includes the responses that come back from the off-chain call and this is important because we need to ensure that these transactions can be verified afterwards by the front provers we need to make sure that whatever we've done is fully compatible with the rest of the of the optimistic role of architecture and so we'll write both the original transaction and the modify call data that includes the option api responses into ethereum layer one and from that point on everything is treated just as if it were a normal guest transaction and the key is only the sequencer would call the api no one else because if you let other independent nodes call the same api you might not get the same results back right so it's important that only the sequencer makes the calls and then once the layer 2 block is written back on layer 1 the verifiers and the replicas will use the stored responses from the api call from the block to do their job so here's a diagram that that outlines how how that works all right so so step one l2t gap with interceptions uh would uh what you would bring an lbc call to get and and our guests would be like okay this is a touring car it is because the the endpoint that you have specified waits for the response to come back uh if the response doesn't come back it's gonna timeout we've set the timer currently at 1200 milliseconds right so when you're when you're writing around this you want to have a graceful fallback default value in case the external api doesn't come back or takes too long all right so the response comes back our guest would replace the original call data with updated input that includes the response that comes back from the option call creates a new block and and submits that to layer one and then new block is indexed represents this word to verify this work everything else just works it's taking us a while to roll this out on uh on our main net because there's a lot of work that needed to happen under the hood um these are some of the changes that we need to make and so we modify evm go and and modify the ethereum block format to include the responses from the blockchain and all of the data from blockchain apis are written back to ethereum layer 1. so as a result we put a limit on the size of the response strain that comes back otherwise these calls could become really expensive and then we also added the ability for gaff to replay these compute requests based on the data that's written to ethereum we also modify measure internal data types and finalizing the sample and other parts of how to get minor worker go we also needed to modify all the services that pass data right from layer to layer one and that's layer one how you inject label data into the layer two gaps and and then we tested it and tested and tested finally we rolled out touring on rankin b at uh during east denver and then a month later we made it live on mainland and by now developers have started building on mobile using touring and they'll give you some example use cases for example you can build d5 protocols based on watching assets right such as real estate uh or some sort of bonds denominated in fiat and traffic world you can now start pulling these fiat world real world assets into there's a team on building on bulba creating an nft landing protocol that uses an off-chain machine learning based evaluation model to place you to put evaluation on these entities so that they can figure out how much to land against these collaterals right imagine doing trying to do that all on chain it's just impossible you're too expensive too slow but now you can get the best of both worlds um you might also want to really decide to incentivize your community members to uh to do certain things on social media for example right to retweet or and you can use touring to make to call twitter to verify that to see if someone has actually recreated something and after that verification you can then automatically release or add drop some rewards to these community members right and since it's all happening on layer two these transactions are much cheaper much more affordable than right on layer one there are also down memberships right there that want to connect their members identity with the off-chain real-world identities um now to to some of the web 3 native this might seem like a little weird but if you think about how web 3 is drawing and looping in more and more mainstream organizations into the movement you start realizing there will be actually more demand to integrate what's happening on chain what's happening already exists in blockchain for example there are college alumni associations out there thinking about how do we create entities that represent memberships in our alumni association and and identify them as verified members in a metaverse that they created so in that case they're not really trying to create entities that can be flipped or traded trying to to use entities to represent an identity that exists in the real world that needs to be verified but you don't want someone to to faith until as you know as your as your uh you know as a hardware normally so touring also enables that we can create energies that could be connected to the school's official alumni directory and verify the real world identity of that metaverse character uh you can also create a twitter activity-based token fountain we've created this we've created a boba fountain on a ring breaking beat and you can also use our atomic random number generator for your empties and bottom line is if if we're able to to connect this decentralized computer with the rest of the world with other network computers you can now create a lot more interesting applications right and this here the list is we're just scratching the surface some of these ideas actually came from developers that started trying out touring so we've got a detailed write-up at this link bitly slash get touring the capital t it's really easy to use it's just a one-line call and what really sets us apart at boba here is we're enabling developers to build smarter applications on ethereum we're not just scaling it in a traditional sense of making it faster and cheaper we are augmenting ethereum by enabling you to build applications that can include algorithms that have that are much more complex than what you can execute on ethereum itself all right so that that's a hybrid confused story it's live on mainnet really encourage you to try it and see what you can build with it a lot of developers are finding that this completely changes how they think about what they can build it really expands the design space available to you and um yeah i can't wait to see what comes out of this weekend's hackathon thank you questions yes yeah uh just got a quick question about sort of independent yeah i've got a quick question about i don't know if it's working but um security um so you said that there was a time limit on requests coming back and having a bad response as well do you think it's possible that someone might want to overload the network with requests that might take too long and that might slow down block times or transactions because of that is that something that's possible um it is possible which is why we put a time limit on it of course we have no control of how quickly the external api comes back and um yeah so it's a 12 1200 millisecond timeout fortunately when you get to control which ap as you call and our hypothesis here is that the developers are only going to call but you're only looking for apis that you trust so these are either going to be your own rpc endpoints if you're let's say that energy lending model right you're running your own blockchain evaluation model is your own rpc endpoint but you if it doesn't come back or it's too slow you have full control of how you want to fix that and in the case of calling twitter or whatever that that is a more uh much more established and trusted api so that's less of an issue now it is possible for a let's say a various developer that really intentionally wanted to to deploy a contract they call some random api is just never comes back that that is possible and and um but fortunately we control we do control gas in this case but with the trusted party operates a single single sequencer so if that's the case um we can filter that out that sounds good yeah um what other sort of functions do you see potentially being created in the future as well obviously you've got random number and api do you see stuff like maybe zero knowledge proofs as well um possibly ways of having arbitrary sort of code get run separately and then having it prove later down the line that this has been run and it's valid as well is that something that you think about could you frame that question again sure um so so are you thinking about other sort of like arbitrary sort of functions that maybe developers want to create as well and having those arbitrary functions run on the network and then maybe have like a proof function something like you know zkp where you can prove that those functions have been run correctly the output is correct as well is that something that is you think about with like boba as well potentially yeah definitely that's something that we're looking into great questions a quick question as you have said because of the api turing feature right there can only be one sequencer [Music] the problem that i see is if the sequencer gets attacked goes rogue uh goes offline right this would destroy the roll up correct yeah that's a more general challenge with today's rollouts in general right not specific to mobile touring um so we are we're we've already begun our work on distributing the sequencer to address this availability issue right and in terms of rogue sequencers um uh all of the rollers are going to have to deal with this challenge as soon as we start letting other parties run these sequencers now we are not of course going to operate at world sequence ourselves because that would be showing themselves in the foot we have enough skin in the game to not do that so the idea would be to extend the same to ensure that other sequencer operators will have enough skin in the game through staking other mechanisms that if they do go wrong there will be severe punishments okay but this this api feature makes it harder right so if your evm equivalent like optimism orbiter for example to decentralize the sequencer is easier without the api feature right um because how would you come to consensus yeah so we will we won't be running our own consensus vertical amounts of sequencers we'll be rotating the role of making touring calls for multiple sequences so at any one time there's only one that's been called but there's still in multiple instances right okay another really quick question you pointed out the example of the twitter api right so i imagine you have a smart contract you do the actual api call inside the smart contract right you have to put the twitter api key somewhere right and if it's in the smart contract anyone can see that how do you handle this stuff we do handle it because we have already implemented our faucet uh using that on recovery that requires a user to go through captcha and how do we handle the api key i'll just get back to you on that yeah thanks yeah thank you today i had enough sleep i did thank you will you manage through the hackathon so you get enough sleep you're okay you're excited for the rest of the hackathon super excited thank you that's the spirit thank you all right well thank you for coming to this workshop please uh go to bitly slash get tutoring check out def dot really look forward to seeing you real amazing things on touring and on bola thank you 