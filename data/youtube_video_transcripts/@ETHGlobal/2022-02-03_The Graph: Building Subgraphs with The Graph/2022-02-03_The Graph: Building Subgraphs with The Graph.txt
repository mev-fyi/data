hi everyone from spain okay stream is good great so welcome everybody um to our workshop we're going to learn how to build a subgraph with the graft and here i have with me vish who will be leading the workshop feel free to pop your questions here but they will be answered in the grafts channel disc on the discord and wish i'll let you take the lead awesome thank you so much um hey everyone thank you so much for tuning in today today we are going to actually let me just minimize it minimize this so that i can get a good sense of what i'm sharing and what you folks can see right now right um yeah hey everyone thank you so much for tuning in i am super excited to be here today um we are going to be learning how to build sub graphs with the graph as you can see um in the title and i just wanted to take a minute um by giving a huge shout out to the organizers and um for having me here um and without further ado let me get started with um giving a bit of brief about what we'll be building today um so i thought it would be a really cool uh use case to share with you folks and so many of you will be new to um subgraph development um with the graph or just you know the graph in general so i wanted to showcase how we can use the zora smart contract to build an nft api um and this we'll be uh able to do by building a subgraph um on top of the zora nft marketplace smart contract um using the graph so yeah um let me tell you a bit about myself hi i'm vish i'm a developer relations engineer as a graph and my passion is building deeply engaged developer communities and i invest a lot of my time to help developers become successful with the frameworks and tools that they're using some quick session notes before we dive right into today's workshop moving on with our session it is assumed that you have node.js installed on your machine and you have a metamask wallet set up to get the most out of this and also that you know the fundamentals of graphql but if you don't then that's totally fine um just ping me on uh discord on our discord channel the graph discord channel and i'd love to share a few resources with you um specifically around graphql if that is something that you're interested in since it wasn't the scope of this workshop i've let them add them out right for now um also this is a hands-on workshop and so the pace and the content of this workshop is designed to be best suited for a full stack audience but if you don't see yourself fit into any of these boxes please don't worry i will try my best to give as much context as possible in each step now let's talk about what the graph is and where we come from the graph is an indexing and querying layer for blockchain networks like ethereum and ipfs but that is in theory um let's talk about layman terms you know uh let's let's let me give you an analogy as an analogy the graph does for an open data on the blockchain what google does for the web that's how we like to describe what the graph does using the graph anyone can build and publish open apis known as subgraphs that make data on the blockchain accessible now it has two primary products that um one of which we will dive deep into um so the first one is graph explorer um and the second one is subgraph studio the graph explorer is the place where you can interact with the network and explore existing sub graphs whereas the subgraph studio is something that we'll be using today um that developers like you and i can use to build and publish subgraphs now i have used the word subgraphs a lot of the times in the last five minutes so let me explain what subgraphs are um and like let's talk about the what why and how to use of subgraphs so first of all just to get started subgraphs are open apis built on top of blockchain data now we get asked often why do we need subgraphs the data in our world is in this data driven world all of our data is mostly stored across huge storage networks and blockchains and when we talk about blockchains the blockchain gets a large number of transactions per day and when we say large we're talking about dealing with hundreds and thousands and millions of transactions per day um when we're building applications for the future of the web these applications need index data for high performance and better ui and ux so that the users can interact with the applications efficiently now the main trouble um developers have with building these applications especially if they're building decentralized applications is that um it's it's becoming increasingly difficult to index and query blockchain data because of the high amounts of data and also not a lot of solutions available out there for efficiently indexing this data as a solution a lot of the companies a lot of protocols were developed a lot of developers even individual developers started building solutions which were proprietary indexing servers now the question still remains what is the problem with proprietary indexing servers if we can still build out a solution it's not a problem right wrong proprietary indexing servers would mean that there will be a single point of failure people were still building out solutions um or more specifically to say proprietary indexing servers and deploying these servers to aws um and which meant that it would need more engineering and hardware resources but in the end it also disrupts the core idea of decentralization enter the graph now um when we talk about the benefits of the dra the graph it's easiest it's the easiest way to index and query blockchain data efficiently it's also a transparent and open network um this the graph launched the decentralized network last year and the graph foundation which is my team oversees the health and the healthy functioning of this network with various network participants apart from that it's also decentralized and robust so the graph is aiming to make decentralized apis and enabling developers to access data especially open and public data which is stored on decentralized networks and since the graph and its core technology is built on graphql the benefits become multi-fold because graphql it on its own comes with a lot of good developer experience and a lot of benefits over traditional rest services and rest apis so that's um mostly what i had to share about the graph and what subgraphs are so let's take a quick look at a quick demo of how to build a subgraph i actually realize that i'm sharing just one screen so i'm gonna switch if i stop sharing um does that affect us in any way the live stream i shouldn't awesome awesome let me quickly share the right actually share the entire desktop and we should be good to go awesome so uh i'll also [Music] hide the video panel awesome so um here we're looking at um the subgraph studio on the graph website the first thing that you can do by going to the graph to the subcraft studio is um connect your wallet which will be your ethereum wallet um could be metamask and this is how you authenticate um on those subgraph studio authenticate yourself on the subgraph studio um i've heard i have already done it um so that's another prerequisite that you can set up um now we can quickly start by going to um create a subgraph and we will click on ethereum mainnet if they really mean it basically what this means is that we will be deploying our subgraph to the decentralized network and we will give it um a name let's just call it nft demo and click on continue so this will also take us um to the nft demo dashboard which is my subgraph dashboard and show us a few things like status subgraph slug and deploy key i'll explain what deploy key is and why it is needed but basically it is a key that will help us authenticate our subgraph after we've built it and before we deploy it i like how we have a bunch of documentation here um so it comes in handy when we're setting it up um but basically i will be referring to this blog post um that i will also share on this card later um so yeah first of all um the first thing that you should do is install the graph cli it gives you a bunch of commands to scaffold your subgraph and define it etc etc so i have already done that and let me go ahead and start my visual studio code um i will initialize my subgraph first yeah really desktop awesome so i will go ahead and copy this command right here and while it executes i will explain what it does so um what the graph cli gives us in this command is um a few flags like contract name index events and from contract so basically what the from contract uh flag lets us do is it lets us um contact the smart contract address which is the so zora smart contract address that we will be dealing with here is the zora nfd marketplace so we'll basically be able to use um the zora nft um smart contract as a building block to build a subgraph on top of it and we already have the smart contract address so we are going to pass it using the from contract um flag there's another very important flag here which is the index events studio flag what this basically the sorry the index events flag what this basically lets us do is any of the events that the smart contract is going to emit um this gives us some configuration and some boilerplate code that we can use to interact with these events in the files that you will see later on so i'll go ahead and add the slug and accept all defaults accept me net again accept defaults and this is going to scaffold my subgraph yeah so this as i said is going to give us some boilerplate code um that um that that is basically our subgraph dot yaml file which describes the subgraphs there's also a graphql schema uh file where we use um that file to define our data model which is our graphql schema and that i will show you in a second when this is all set up yeah our nft demo has been created and it is now adding all the boilerplate code to the directory and the next step that we can do here is once that is set up we are going to um i'm going to skip over some of this since we are tight on time but we will be making some changes um to some of the files as i said which is the schema.graphql file which is our data model and there is also a subgraph. we'll make some changes too this is taking a bit of time just give it a minute and we can start exploring our subgraph folder oh and um i am going to take this time to also mention that um you can go ahead and use our discord channel where some of my team is hanging out and if you have any questions we'd love to answer them on discord and if you want any additional resources if you've joined the hackathon if you're building something we'd love to guide you through it so now as you can see um our nft demo subgraph folder has been created so i'm gonna go ahead and open it and we can start exploring the subgraph folder structure so the first thing that you can see here is the subgraph.yaml file since we are a little bit tight on time i'm gonna go ahead and um talk about a few edits that they're going to make here so in the subgraph.yaml file this is a basic description or definition of our subgraph the schema schema.graphql file which is the other file that we will be mainly editing today is um the uh graphql schema that we have which basically defines what kind of um entities are we or what kind of data are we going to make available or indexable uh using this subgraph api that we're building um and there's also going to be a mapping file in the source folder and this mapping is something that uses assembly script which is something that i will explain in just a second so let's go ahead and get started by making some changes to the subgraph.yaml file as i said in the entities there are some entities that we can define here so i'm gonna enter token and user um and these are going to be the entities that we define here in the screamer.graphql file what this basically means is that our subgraph will be able to query this this data that we define in these two entities for the sake of this workshop i'm also going to go ahead and remove these events but as you can see there are some event handlers that have been made available to us um by the smart contract itself as an example i'm gonna take just two of these which is the transfer event and the token uri updated event the token uri updated event basically is an event that is emitted by the smart contract when you index it when the uri of the token has been updated there are two scenarios here that can happen um uh sorry when the token uri has been updated and in the transfer event there are two scenarios that can happen in this event the first is if an nft or an order token is being minted and the second one is if the ownership of the token is being transferred which is why the transfer event is then emitted so these are the changes that we've made i'll also make one more simple change here which is adding a start block and basically what this adding um a start block does is that instead of um starting to index the smart contract right from the genesis we are going to use a start blog so that it starts indexing the zora nft smart contract from a particular desired start block and um yeah looks like these are all the changes that we wanted to make in the subgraph.yaml file so i'm going to go ahead and hit save next let's take a look at the schema.graphql file now this is the file that um is going to this is the file where we're going to define the um the yeah the types which are which are the entities so any type that you wanted to define um you need to uh it is going to be annotated um using a directive which is um at entity director um so here we are defining two types which is token and user so in our subgraph we want to be able to query two types of data first one is all the tokens that a user holds and the second one is the user metadata itself so which is why we are defining these two types now as you can see each type has some fields that are also going to be queryable when you query the gracule api um so the smart contract gives a few of the metadata regarding the token and similarly some metadata regarding the user but since we want to um uh query both of these types um but also not just tokens or just users but both of them combine sometimes in a case where we want to query all the tokens that are held by a particular user in that case we are using the at derived from directive to create a one-to-many relationship from um tokens to users so that um sorry from users to tokens so that a user a particular user can hold um n number of tokens and this is going to define that relationship i'm gonna go ahead and hit save the next thing that we want to do after um after defining our schema.graphql file is go ahead and use the command graph cogen now what this command is going to do is that it gives us some headers and some paper functions and some boilerplate code that is for example typescript and assemblyscript functions that will let us map our local function to the event that is being emitted by the smart contract now since that has this has been done let's take a look at what has been generated here so as you can see in generated we have two files which is in the token folder we have token and then we also have schema so using the the graph cli gives us a typescript library and that typescript library will give us some boilerplate code which is generated using the graph code gen command and what this code lets us do is um in token.ts we have some functions that let us interact with the smart contract itself and by interaction i mean reading data from the smart contract because of course we can't write to it directly and then using the schema.ts functions that we get from the generated code we are able to interact with the graph node itself and by interaction i mean reading data from and writing data to writing new data to the graph node so i'm gonna go ahead and we are not gonna touch the generated code it's just something that we will be using um in our mapping.ts file so i'm gonna go ahead and remove this and for the sake of simplicity and to take care of the time i'm gonna use the function that we the functions that we have defined here so i'm importing as you can see i'm importing token and schema from the token and schema files in the generated folder which has been generated by the graph dot co gen the graph code gen command now i am also going to use this function which is the handle transfer function and i will explain it in just a sec and also the handle token uri function now what this does is as i mentioned earlier from the graph uh subgraph.dml file we have two events which is token uri updated and transfer so in our mappings.ts file what we're basically going to do is write some assembly script code if you've used typescript before assembly script is basically similar to it so we're going to write some assembly script code which will let us um map the um events that you saw here in the subgraph.yaml file to the local events sorry local functions that we're writing here so you can see the mappings.ts file as our business logic of the subgraph any logic that you define here as functions is going to be mapped to the smart contract events so whenever a smart contract is being indexed and the event is emitted the that mapping is going to take care um of the event by calling the function that we have defined and mapped to it and the logic that we've written in the function is going to be executed so here uh we have some logic um that that is used by the handle transfer function and the handle token uri updated function the handle token uri updated function is pretty straightforward um because this event will be this function will only be called when the event happens we know that the token uri will be updated so what we are basically doing is that we are we are getting the token information um and we're also from the smart contract and we're also updating um the token the content uri and saving it to the graph node so that's pretty straightforward of a function the another function that we're using is the handle transfer function now what this function does is um it handles the transfer event happening on the smart contract and it will check two things um the first thing if is if there is an existing token it will execute the function and if the token does not exist it will create a new token as you can see here and then add the and then save the owner of the token it does the same for the user if the user exists it's going to save the user the new user um if the transfer the ownership has been transferred but if the user does not exist first it's going to create a user so these are basically all the um edits that we wanted to make we are going to go ahead and um we are going to build our subgraph so graph build hopefully this builds in time uh we're running out of time yep and the next step that you can see here once that is done is that we will be deploying and testing our subgraph i'm going to close this off so once our subgraph has been built we will be authenticating our subgraph and that is something where we will be using our deploy key so i'm just going to go ahead and copy the deploy key and to deploy uh sorry to um authenticate we're using the command graph auth studio graph us using the studio flag because we're using the subgraph studio and it's gonna ask for the key yep gonna enter the deploy key that is ready to go and we will also use this command which is the graph deploy studio command and then enter our subgraph name which is nft demo and when you do that your subgraph is going to be deployed let's go ahead and add a version label which could be anything i'm just going to write 0.1 and this is going to deploy our subgraph as you can if you can see here it currently the style says undeployed but when it once it's deployed it's going to turn to deployed and then in just a second when the subgraph is deployed we should be able to test it out um using the graphql playground which is the beauty of graphql um actually awesome so it has been our subgraph has been deployed and you can use this link to um use this link to test out the subgraph um it should be it should take a sec no more than a sec and [Music] yeah we can go to the playground and if you there's an example query here and to test out the subgraph if you hit play it's going to give us the first five tokens and the users and their data as you can see here this is the data that we asked for and here you can see the schema um token and user uh all right folks so this is basically um this is what the demo was all about um and if you want to get involved want to join the web 3 movement here are a few resources and a few places where you can get involved i'm sorry for rushing everyone but if you have any questions i would love to support you along with my team and answer any or all the questions that you have awesome thank you so much for being an amazing audience thank you thanks thanks everyone see it's alexa 