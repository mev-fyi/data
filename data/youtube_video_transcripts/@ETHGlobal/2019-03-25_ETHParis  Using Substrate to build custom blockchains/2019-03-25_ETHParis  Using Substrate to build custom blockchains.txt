all right so it's 11:30 I think it's time to get started so I'm Hernando and this is Shawn we're both developers at parity and today we're gonna be giving you a nice walkthrough of how to get started on building with substrate if you want to follow along you can just go to this tiny URL everything you need to get started is on there this is gonna be pretty jam-packed so like we're just gonna fly through so try and bear with us so why are we even showing you this so we've got to hackathon prizes tonight or I guess for the weekend we've got a 2000 euro grand prize for the best hack on substrate and then we've got another thousand euro for the the best run Rob now I'm gonna pass it just Shawn for ya so freeze me ten about substrate so substrate is an open source modular and accessible framework for building block chains basically substrate gives you all the tools you need to spin up your own block chain in a modular way enabling you to be able to you know get your ideas out there working kind of as fast as possible when we talk about again the subject rides all the core components things like a database layer networking consensus engine transaction queue and a library of runtime modules and it's this last point that's actually really exciting all of these different components are built so that they can be extended or customized um so if you know if you or someone who wants to test different networking layer or if you want to test you know different functionality or logic to your chain you can make those modifications I'll having to touch the entire stack or kind of you know scramble within you kind of like interconnected code that's not what the runtime I think one of the most common things people do when they hack on or trying to build off of an existing blockchain and they try to change some of the logic or some of the core way that the state-transition function for that blockchain changes and that's what we call the runtime and substrate the runtime in substrate again is build module II and it's composable we call substrate runtime modules we provide in substrate a package of modules in the substrate runtime module library cuz we call the SR ml which has things like balances accounts fees timestamp upgrading but even things like on chain governance within things like a democracy and Council we even have a or contract later on in the contracts and you can go and pick and choose from these modules what you want and add it to your runtime in addition of course you can create your own module and that's kind of what we're going to talk about mostly I'm in this talk how you can go take substrate build a module and basically add custom functionality to your blockchain so first you can easily set up the substrate developer environment and this kind of really powerful tool for you this hackathon at this 10 sec link we have a github repo here which has instructions and some kind of starting spots we call the substrate package it contains a script that will install all such a dependencies on your operating system give you a substrate no template and a substrate UI I'll talk about those other two packages um so where does this at rate no template well it is a working substrate node which already includes basically all of the kind of core components to get a working node running so things like accounts balances fees runtime upgrades and more so the basically we package a bunch of SR ml elements and got it in a way that it works the node works as is and then what is really nice about the substrate node template is that you can actually just really quickly add and remove modules as needed and create your own module to customize your chain functionality so you know if you're think about hacking a new functionality on a block chain using substrate starting with this node template and then just plugging in your own logic is actually really fast really easy and will work and you find that no template kind of this link again all of these links are found on this slide which we had at the beginning we also show you at the end so feel free not said you have to go over here right now but go back later and uh like these links and we also provide in this subject package of substrate UI which is basically react project with a pre-built UI elements for kind of some of the basic functionalities you might want to do to interrupt your block chain things like creating a look at your accounts making transfers doing runtime upgrades it uses a custom bonds library which is built to work well with reactant is a very reactive library and you can actually using this central UI really quickly extend and add new functionality to your own UI which might interact with the functions that you introduced to your runtime the new modules um there's an alternative if you're more interested in using like a promise based API something more classic which is the polka dot J's API and we have links to all those here and I'm gonna skip over this because it's all found on the slides so I want to talk about the basics of runtime development we're gonna through kind of the the pieces of a module and kind of explained you know like what is needed to make a new module and kind of how it works and then kind of what you expect to see when you're trying to build your own so first let's get a skeleton of module so well I'll go through each of these individual components you can see at the top or importing some libraries or you know things that we need throughout the module we have this something called the public trait we have a way to declare storage declare functions declare events and of course we at the bottom we actually have a way to do internal functions these are things that might be familiar to you if you've built a smart contract before you know it declaring functions declaring events having storage these are all things that we also provide in substrate so start the top importing defining generic types so every module is gonna have a trait called trait and by the way this is all written in rust and we'll talk about rusts a little bit more later but if anybody looks kind of funny to you we're using the Ross program language for all of substrate but we start with with a trait called trait and this is written in define kind of the custom types that your module exposes most commonly you will just expose an event type this is again if you want to use events you need to have this event type there but you can see actually this our trait in inherits from the system tray an assistant trait as things like origin block number hasha County things that you might commonly expect to find in a blockchain and so the idea of this kind of every module exposing their own trait you have a system module which exposes its own traits it can inherit into your module and you can use it again this is all about the modularity of substrate modules and basically allowing you to guess create and import and use modules within one another and do so in a generic way next we have storage so this is kind of a working code for how you like to clear storage so as you can see here we have basically some simple definition for some value this get some value this is a getter function we can generate the allows to access that value within our module and you can see this sum value is just basically au 32 additionally that's just a you know single value storage we can also do a storage map for example from an account ID to a value and so it's ignore to do that we basically just define map and we have the two types that we want to linking a key value pair keep moving forward me you might want to clear an event within your module and that can also be done really easily this code at the top this you know you your basic defining an enum type event we're defining basically the our event is going to emit some value stored event which has an account ID an au 32 and we can call this in our function whenever you know something happens we want to is tell to the outside world and again this it just works just like this and finally we have the module functions and this is really the core piece of your module this is where we define all the public functions that users can call and that could be used to basically expose functionality from your runtime um you can see here that we've used the event the value stored event and the storage item both the value and the map and basically create a simple function that says like store some value what we've done here is every function has an origin origin basically defines where the call is coming from so you can have things like a transaction where it's a sign message from the outside world you could also have you know again substrates built to be very generic so you can even have a bunch origins from within your own runtime which has the property root or you can have things that are not signed things that are just general messages coming from the outside world which you might need to verify yourself things like inherence but for now we're just looking at something making sure that is signed therefore it is a transaction from a user we can from the sign message find out who the user is we can then put the value into the single value storage or we can insert the value into a map using the sender as the key and the input as the value and then at the very end we can deposit an event saying hey everything went okay the value is stored and these are the the sender and the input and then at the very end we always return okay finally one other thing you might find current practice within building a module is doing internal functions so you know it's not doesn't make sense to you know continually repeat the same functions over and over things like if you might want to do a mint or a transfer things like that are familiar in tokens you might call mint in different places within your module functions this implement of module allows you to define basically internal options that can be called from other modules if you make in public or can be called within your module model times so you know if you don't expose it politically has something I can called you still want to introduce some new functions into your code you can do that there and actually just want to go real back real quick back to the end so you can see that these all the skeleton and each individual piece kind of builds towards the larger runtime module yeah so then let's like one more thing about defining custom structs so again if you're building a runtime module you might need to introduce you know custom types or custom structs which have your own you know I guess data format and you can do that pretty easily one thing you will need to include is this parody codec the encoding decodes this derived line at the top is a macro which basically adds a bunch of traits to the struct for example the defaults traits here means that you can create destruct with some default values and basically this macro implements that default function which allows you to have that encoding decode are needed to be used to serialize and deserialize destruct data between our runtime and other you know other libraries like the JavaScript and even within the runtime modules one thing that's really important when you're building runtime modules is to is to make sure that you're conscious of this verify first right last pattern so if you're a theorem contract developer you will actually have to think about designing your module a little bit differently than if you were building a small contract for example in aetherium if a bad transaction occurs the state is reverted in source on top so you can go you can you know modify your storage whenever you want and if at any point something gets reverted all those changes are undone but in the substrate because again you're building a runtime module until much closer to the actual blockchain logic those state changes are will persist if you return an error so um you know I just might ask like why do we persist those those state changes even if there is a some kind of error in the transaction well things like you know increasing the account nonce even with failed transactions things like charging transaction fees when you're out of gas these are things that you know need to be modified in the blockchain even if a transaction fails so when you're building your modules you make sure that you always in your code verify everything first make sure that the transaction or the rest of the code underneath the verifications will not fail and then only write to storage once you know everything will be verified and this is and particularly important when you're creating sub functions for example if you want have a function which hasn't checked and writes has some storage and you want to put that function within another function and you need to make sure that that function that is being called which as a verification is not being called after any storage rights before it I mean if that makes sense so you might have an internal function which writes this which rights of storage you have to make sure that that cannot fail if you're calling with another function yeah so now we're gonna talk about you know ice again I showed you a lot of rust code there and there's some maybe some interesting unique things so we're talk about rust in substrate and kind of what you might expect to see you doing module development yeah so one of the first things that we sought there at the code was result so in rust a result is how we do error handling so a result contains two two types that can either be okay which means you know everything went as expected or there was an error and we need to return that to the user so there are two ways to get access to the data within the result the more verbose ways what you see at the top so you can see that in sure signed function which we saw earlier returned a result so we need to be able to get the value within so if it was okay we'll just return s which is sender and if not we can return air and anybody upstream can handle that accordingly but on the slide you might have seen a curious little piece of syntax which is the question mark operator so the question mark operators essentially just shorthand for that big block code you see up top if you need more reading here it is another thing options so in rust there's no such thing as no everything is typed so we have this type called an option which either contains some value so some with a generic value T or it contains nothing so a none so as Sean was talking about it's really important to not mess with state and if we have like a function overflow or an underflow for instance that can really mess up your chain so we want to check this before we do anything and this function does return an option once again we're working with options we can either do this whole verbose notch thing up top or we've got this cool shorthand called an okay or which will take the result from this functions or the option and then transform it into a result so you can see that we got either some good value like an okay or we return an error like before but we've got cool shorthand to do it and then we also have some hack ideas for you so if you don't really know where to start we've got a list here so if you don't do anything with non fungible zayed be totally cool governance modules something interesting ipfs integration would also be cool Oracle's we don't really have anything like that on substrate just yet hardware wallet integration also good idea earner wallets seem to be a hot topic nowadays so if you could build something like that that would also be much appreciated and we've also got a couple more ideas in there if you need more inspiration so we wanna talk about cycles workshop that we built basically we have a full in this URL over here we have a full kind of four to six hour complete workshop where you from end to end we'll build a crypto Kitty's equivalent on substrate it has all the basic kind of things that are creating a non fungible token transmitting transfers doing breeding and basically walk you through kind of all the things we touched in here with a little bit more detail and kind of hand-holding you making sure that you understand how the element works and really will prepare you to build new modules now the one thing the caveat here is that it takes about four to six hours to complete this depending on how familiar you are with rust or substrate but it's definitely a good reference material that you can go and use as you're developing and you might have a question like okay how do I do a struct definition again or how do i declare events and this tutorial does go through that and explains in a very clear way I mean this is but very much takes off of the crypto zombies tutorial if you guys have done that before so it should feel some of that so next steps for you is to clone and fall the structures from the substrate package again this is probably the fastest way you can get started hacking on substrate then of course you want to join our right channel so the subject technical channel is basically for all developers building on substrates there this has been pretty active for people who have been building outside the hackathon but we encourage you to join ask questions there you'll find myself in Hernando there and also a bunch of devs from parody and people who are building on substrate already and maybe will help you again this is a great way to join the community ask questions don't be afraid to ask pretty much anything and you know people are here looking to answer questions at all times and finally you should with the knowledge you have here kind of like how the modules are built and kind of the components of them you should go and explore substrate runtime module library as I mentioned there are things like balances module account module governance modules now having understood can't understand how it breaks down and what it should look like you can go and read these runtime module libraries and that might actually inform you and teach you how to write things correctly and if you maybe think oh this is the pattern that must be used before you can look at the runtime module librarians have a copy and you know modify the patterns you see there for your own code and finally you should build and substrate this is gonna be a really awesome platform and really I think really interesting place to hack this weekend so we have some helpful links again this entire presentation is at tiny CC slash substrate - getting - started so you'll find this entire presentation with all the links there that we've shown you and we kind of glazed over you can again substrate package is I think the fastest way to get started building on substrate we have documentation that's a little bit sparse right now but it can be continually worked on but has good things like recipes for like these are like common code patterns it has things like some you know smaller tutorials and even some reference information and even if you're not familiar some words or Titan terminology we use in substrate you can find some that information in the substrate - docks we have a substrate workshop which I mentioned and then such a technical which is the chat and these are all tiny GC substrate - technical workshop docks etc yeah and if you have any questions we have a few minutes and we'll be very happy to answer them any questions in the room is anybody convinced to build on substrate yeah no all right well again you can find us we'll stick around and if you want to talk to us we'll be here and we'll be happy to answer any questions and make sure that we can get you started building on substrate right away Thanks thank you [Applause] you to stay on schedule we'll take another break till midnight next up 