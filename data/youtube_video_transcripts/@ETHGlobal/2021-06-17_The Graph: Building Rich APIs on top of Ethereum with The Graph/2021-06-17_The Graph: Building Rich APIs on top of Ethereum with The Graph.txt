before we kick off all right we have nader from the graph who's going to give a workshop titled building rich apis on top of ethereum with the graph if you have questions for another uh let's hold those to the end i know we've got a lot of stuff to cover so without further ado i will hand it over to you matter thank you so much um happy to be here and we're going to be covering quite a bit today so i guess we'll go ahead and get started so to do that i guess i will share my screen and it's going to be kind of broken up into two main parts today first i'm going to be presenting a presentation here so i'm hoping everyone can kind of see this and we're going to be doing a kind of overview of what the graph is and then we're going to go through actually building our own sub graph from scratch and looking at how to kind of query data from ethereum and indexing data from a smart contract so like mentioned my name is nader davitt i am a developer relations engineer developer advocate working in edge of node and one of the protocols that we work closely with is the graph protocol and the graph protocol the founders are the yeah the founders of the graph protocol actually also founded edging node and the graph protocol is now managed by the graph foundation so what is the graph protocol it's an indexing protocol for querying networks like ethereum and ipfs so essentially it's kind of like you could think of it as any public data source in the future and for right now we're kind of focused on blockchain data and um different networks that are evm compatible for now we're working on additional blockchains as well and you know in the future we want to basically be able to index pretty much any public data and have a completely open api layer for any public data and developers can essentially kind of deploy their own apis to this decentralized network using the sub graph that we're going to be looking at in just a moment so with the graph you can basically take a data set that in the past was really not easy to query from a front end or really any type of application and kind of make that data a lot more efficiently retrievable and a lot more performant in a front-end application in a type of way that most users i guess are used to with modern apps so with blockchain data because the data is kind of aggregated over time in these different transactions that are written to the chain in these blocks you can't actually hit a block chain and kind of get a nice data set like you would from a traditional database in the web 2 world now you can kind of make a single read so you can like say okay i want to get this individual piece of data but you can't go through and say i want to query this data set i want to pass in these arguments and i want to kind of get this nice selection set that might be some type of aggregation of data across time or using some some type of you know i guess computation logic that typically would be handled in a server so in the past a lot of developers got around this by building out their own indexing servers and deploying them to something like aws or google or maybe even dealing with that infrastructure themselves but the big drawback here was if you did that it was not only a heavy lift because any type of data that you wanted to index any type of application you wanted to build you had to basically build a new indexing server every time and this was resource intensive but most importantly it actually broke the idea behind decentralization in the first place so if you have all this data centralized in a single point of failure then it's truly not a decentralized application and it's not web3 so the graph solves both of those problems and the graph provides a really easy way for developers to deploy open apis on top of public data like blockchains and it kind of sits in between the blockchain and the smart contracts and the user interface and it allows you to basically define what data you want served what data you want stored and you can also create a diff additional i would say kind of um data access patterns on top of that data by defining that in the subgraph so a lot of a lot of applications are already using the graph you might have used applications like the foundation nft app maybe uniswap synthetics you can go and check out the graph website to see a bunch of different apps that are already using it and we have tens i think of thousands now of subgraphs that have been deployed when i wrote this this slide deck originally it was over 10 000 lifetime subgraphs and i believe now we're over 20 000 developers so you know quite a few developers are building on the graph and i think in the lifetime we're at over 125 billion queries and i believe last month we had over 25 billion queries alone so like i mentioned a lot of different applications are using it a lot of defy apps are using it one of the ones that i mentioned is uniswap but i think this you know image here kind of gives you an idea around the interface that you get after you deploy an api so once your api is deployed how do you know what data is there and how to interact with it well in the graph explorer and in the actual interface for the individual subgraph itself you can actually go in and see a an explorer view that kind of shows you the current state of the graph as well as a way to query data from the graph and understand what types of data are available for you to use in your app now the graph is a decentralized network well actually it has two different ways to deploy today actually we have the decentralized network and we have the hosted network the decentralized network is a fully decentralized protocol with different uh um i would say participants that you can different ways in which you can participate i'm going to go over those in just a moment and then we also have the hosted service which is kind of what we're going to be using today because with the hosted service we don't have to kind of stake any tokens and we don't have to do any of that stuff and it's kind of a great way to kind of i would say just get started understanding how to build but with the actual network itself you can be a participant in a few different ways so you can be an indexer running a node on the network and if you're running an indexer node then you can allow other developers to build subgraphs on your indexer and then you make query fees based on the usage of that um that those sub graphs that you're indexing you can also participate in the form of a curator so if you are someone that sees an api that someone's created and you think that it's going to do well you can basically stake grt which are graph tokens to signal that this subgraph is a very good api or that you think it's high quality and then you can share and receive you know amount of the actual query fees that are gained from that subgraph and if you're a subgraph developer you can also signal on your own subgraph and earn a portion of those query fees as well so you can earn money in a few different ways by participating you know in the network itself and we have some really interesting stuff coming in the next few weeks so keep an eye out there um so how do you actually create one of these subgraphs well this is what the workshop's all about i'm going to actually have an entire end to end code base that i'm going to share with you along with steps that we're going to take so this way if you want to follow along you can or you can kind of follow along at another time maybe so you can kind of watch me and then maybe do this yourself at a later time if you would like so you initialize the subgraph that's kind of the first step and this is done from your local development environment using the graph cli you can then decide which data sources that you want to index so like which smart contracts are you wanting to save information from again these could be a d5 smart contracts this could be nfts this could be marketplaces whatever once you've decided which data you want to store you define your entities and this is done in two different places one place it's in the graphql schema which is kind of the definition of all of the different data that you might want to save and then the other place it's done in the graph subgraph configuration file which is the subgraph.yml and then you define the actual i would say business logic of kind of like how this information is going to be saved in something called assembly script mappings and the the the assembly script mappings are really very similar to kind of writing javascript or typescript so if you're have you written either one of those languages that should be fairly easy and we're going to see that we're going to be able to kind of like deploy this entire subgraph with something like around less than 100 lines of code including all of these steps here and then when you're done you deploy from your cli and from there you can go into the graph dashboard and check it out so with that being said let's go ahead and build something so what i want to do is build a sub graph using an existing smart contract and i think for tutorials and getting started and and i would say workshops like what we're doing a really good place to start is something that's visual so what i'm going to be doing is indexing data from the azura smart contract so zora has deployed their smart contract and of course it's available on ether scan and if you go they have like some documentation that kind of shows you that but i actually have all the steps for the workshop here on this github repo so it's github.com dabit3 slash building a subgraph workshop and maybe i'll go ahead and share that in the comments and maybe we can kind of have that share with everyone here and here i kind of have a link to the the nft smart contract here actually maybe it's here nope that's not the link there is a link to it somewhere but um we'll we'll oh actually here it is yeah so that's the contract itself on ether scan so the way this the way that this is going to work is essentially like i kind of went through the steps but the idea here is like whenever a transaction is written to a smart contract you typically have you know um events that are emitted and in these events you can basically look and see which data is being emitted and that's where you can event source the data for your your subgraph there's a couple of ways to uh source data other than events but the events is kind of i would say the easiest way to get started and that's what we're going to be looking at you can also event you can also source data from just regular functions all right so we're going to be building a smart i'm sorry we're going to be building a subgraph on top of the zora smart contract so we basically want to kind of like have an api that we can basically say let's want to build like an interface like this how could we do that and how can we get that data that's what we're going to be building so to get started what we first want to do is go into the graph console and create a new subgraph so to do that we can go to thegraph.com and i will go ahead and start here so we're at the graph.com and i'm going to go to you know sign in and sign up and if you have already done that you should see kind of your profile here with the dashboard so we're going to click on dashboard and then there's a big button right here where you can click to create a new sub graph add subgraph so i'm going to give this a name like um you can say databit three [Music] well we already have dab at three so let's say you know zora nft or something like that all right so this doesn't matter a whole lot but you know this will be discoverable if you would like it to be so maybe it is important if you're kind of building out a production subgraph to kind of come up with a name that that you want to stick anyway so we have the subgraph name we can give like a sub graph title here we'll just call this sort of subgraph and that's kind of it we can add additional metadata if we want we can make it visible or hidden doesn't really matter i'll make i'll make this visible so if anyone wants to go here and check it out later they can and we're going to click uh create subgraph so we've created our subgraph i kind of walked through those steps here too just to kind of make sure that you know that all this stuff is covered in this workshop materials the next thing we're going to do is install the graph cli and i've already done that but to do that if you haven't already you would run npm install g at graph protocol cli or you can do that using yarn and then from there you'll have the graph cli binary and from there you can you know just use the graph to do whatever you want so to initialize a new subgraph you can just run graphic net and you can either pass in arguments that will kind of define a few of the different things that we want to do or you can just run graphinet and it will walk you through all these steps but for me i want to go down here where we kind of have a few different arguments that we're going to be working with because we know the smart contract address we also know that we want to deploy this querying data from ethereum mainnet so we can define the network and if this was a different blockchain you could also define that here as well we also want to give the name of the contract that we're going to be storing the data i would say the entities as so in our case we're going to say all these nfts are we're going to call them tokens and then we also want to pass in this flag which is kind of interesting which says index events because this will go into the abis of the smart contract and it will go ahead and create some boilerplate code for us based on the events that are programmed into the smart contract so all i need to do is go ahead and copy this and and paste it here and this will go ahead and get it started so for this subgraph name what we need to do here is set up the name that we gave in our uh in our explorer here so for me that was debit three slash zora nfc workshop so i can go ahead and use that and i can define the directory where i want this to go i've already selected mainnet so that's being chosen first i also know the smart contract address because i passed it in here so i can accept all these defaults the contract name as well so kind of we accepted all these defaults and this should go ahead and scaffold out our sub graph and i can go ahead and change into our new directory here and i'm just going to actually run npm install because i think because i have yarn chosen as the default ins installer there there seems to be some issue with yarn installing dependencies all right so we've we've done all that now let's take a look at some of the boilerplate code that was created for us by the cli so to do that i'll go ahead and open up this subgraph in my text editor and here we have our folder structure on the left we can kind of see the different files that were created for us so the three main things that you're going to need to work with are going to be the graphql schema at schema.graphql and here we're kind of given a few pieces of boilerplate i would say code that we could work with we also need to open the subgraph.yml this yaml configuration defines the entire configuration you know for our subgraph and then we also have our mappings which are in the source directory so kind of putting these three things together we're going to be able to create our subgraph so what i want to do is we're going to go back to our workshop and what we want to first do is define our entities so like which data do we want to store from this smart contract like from these events from the smart contract now if we look at the actual ui of zora we might get a good idea of kind of what data we want we might want to say okay this is a piece of data right here and this is one as well so each nft has its own data piece of data we might want to kind of say okay for each item we want to store the metadata we might want to store the reserve price and so on and so forth so kind of like thinking of that as a starting point like where would we start with that i think the most logical place would just be for the nft itself and then we would also need to think past that maybe like for this entire marketplace because i'm assuming that there are multiple contracts put together for this it's not just maybe an nft but it's also the marketplace allowing the buying and selling so let's just talk about the nft itself so for for um you know that you can look into the contract itself and maybe look at one of the structs there but in our case we know that we're going to be having a token and a few of the pieces of metadata that we want to store are going to be the token id the content uri the metadata uri the creator and the owner so the token id the content uri and the meta data uri are coming directly from the event so we're able to source these events using the erc you know 721 standard and maybe also going into their contract and kind of making sure that this all looks like it works um and then we also have these two entities which are interesting because these are relationships right because we have a creator which is not a typical just uh type like of integer or string or whatever this is an actual additional uh parent type so we're kind of like saying creator is another type itself that we're referencing here so we can do that and the graph node knows how to deal with those types of data and we know how to do and we're going to be dealing with those types of data in our mappings so we're able to kind of make this a one-to-one relationship and another interesting thing is that we're also able to make one-to-many relationships so for the user we can also say okay we want to index you know all the tokens but we also want to index users and those the tokens that they've bought and that they've created so doing that we can make that happen using a combination of some code that we're going to write in the mappings as well as this at derived from directive and then dera the derived from directive lexus stefano field where we're going to be deriving this data so for the token array we're deriving uh this data from the owner and from for the created we're defining deriving this field from the creator and these are going to be smart contract addresses and i'm sorry these are going to be ethereum wallet essentially addresses and then using these addresses we can go and fetch that metadata itself or that data itself so we have these two different types and i'm going to go ahead and copy those and we're going to go to schema.graphql and we're just going to save this so we have our token type we have our user type and we're pretty much done there um i have a little bit more information on the draft from directive here but we have nine minutes left and our ultimate goal is to kind of you know finish this in time so let's keep going um another interesting thing that the cli offers is code generation because when we're working in our mappings we're going to need helpers that are going to interact with the different data sources that we're going to start having available as this contract is being deployed i'm sorry when this subgraph is being deployed because when we deploy this subgraph we're going to basically be taking these events that are being read off of off of the chain and we're going to be looking and seeing that okay we're going to have the token address the token metadata uri so on and so forth but let's say that we wanted to actually read data from the function itself back maybe into the node that data we've already stored or maybe we want to actually read back into that smart contract and get uh make other calls as well we can do that using the graph typescript library and in order to do that we actually can get some helper functions and helper code that that is kind of like created for us and we can actually create that code or generate that code by running graphcogen and this uses a combination of our graphql schema as well as our abis to generate the code that we're going to need so if i run graph code gen this should check in our abis as well as our graphql schema and generate the code that we need so we'll give that a second it should let me try running it here there we go so we ran graph code gen and now we see we have this generated folder with some code so we have our schema here and we should see that we have a token type and a user type actually yeah token and user entity actually um we also have our um token folder here with additional metadata and code that we can work with and then we also like have our apis and i haven't gone over these yet but the apis were automatically extracted from the smart contract when we ran graphenetic so this is pretty cool we have the abi of course you could go into etherscan and copy that yourself if you wanted to so keeping going um we now also want to go into our subgraph.yaml and we want to update our fields that we're going to be working with so first of all we have our entities so the entities that we want to work with are only going to be user and token so i can just copy these and we're going to paste those here and these entities map directly to the the types that we created here so we have type token type user sub graph yamo we have entity token and entity user the next thing we might want to do is define our start block because if we deploy it as is it will actually start from the very beginning of the whatever network we're working on so we'll kind of go to the the genesis block but we kind of know we don't want to have to do that we can actually just start right here because this is where the contract was deployed so you can just start there and of course you could deploy from the very beginning it just takes a long time and then the last thing we want to do is we want to make sure we have our event handlers defined and we've already actually had these event handlers generated for us because we use the index events flag and we know that the smart contract emits an approval event an approved for all event a token metadata uri updated a token uri updated and a handle transfer that's our transfer event so like all those have been been generated for us so all we can really need to do is just kind of delete whatever events we don't want to handle so the two events that we do want to handle are token uri updated and transfer and transfer is an event that's triggered when a token is minted or transferred and then a token uri event is is invoked when of course someone changes the uri of a token itself so with these two handlers we can kind of create a pretty decent uh basic api with the data that we want of course we wanted to kind of make this more robust in the future we might handle additional events that do a lot more than this but getting started that's it so we're good here our our subgraph yaml configuration is is good to go all we need to do now is define the functions here for handle token uri updated and handle transfer so we are running pretty close on time so i'm just going to kind of like copy this paste this code and paste it because i'm hoping we can finish in time so in source mappings i'm going to go ahead and paste this code here and here we're importing some of the code that was generated for us by the cli we have our generated slash token um these are classes i guess you could say that we're going to be dealing with and then we also have the token in the user class itself that was kind of created for us to be able to kind of load instances of these items as they're created and let's go over just one of these functions real quick to kind of give you an idea what's going on so for handle transfer this will receive the event that's passed in here so we have transfer so in this event we're going to have these arguments we're going to have an address an address and an integer so here we're kind of handling that in the event and we're going to first check to see if this token already exists because if it does exist that means we're just transferring it to someone else if it doesn't exist that means we're creating a new one so we're going to say if there is no token we're going to go ahead and take that token and you can think of this almost as like an object or a map where we're kind of like having a token instance and we're adding different fields to it so we're adding the creator field the token id field the content uri and the metadata uri now all these fields should map directly to what you've defined on your schema so you can kind of see that these things are already kind of like mapping directly we then save the um the item and then we also do the same thing for user so we're kind of like taking all these pieces of uh metadata all these different fields and saving them so that's it we should be ready to deploy so the first thing we might want to do after finishing writing our subgraph is run a build to make sure everything's working good so we run graph build and it looks like our build was completed successfully so we should be able to deploy so i can go ahead and run yarn deploy and this is going to run a script that's already been defined by the cli for us and this should take maybe 15 to 30 seconds maybe so our sub graph is deployed we see that we have like a deployment id we also see where we can find this sub graph so i can copy this and go there but i really don't have to do that because we're already there i just go back here and refresh we should see that our new subgraph has been deployed and we see that's already been synced and we've already indexed 6000 entities that means we've run over and gone through 6 000 different different actual transfers i guess in our case and we've indexed items from each of those and we can go ahead and hit this to go ahead and start querying some data and we see that we're now getting back data and we can even pass in different arguments here so i might say i want to change the sort direction so i might say order direction descending and then i want to say order by my token id and then we can get maybe some of the later tokens and then if i want to actually see some content i can copy this content uri go into our browser check it out and hopefully it's safer work there we go so that's it we've deployed our sub graph everything in this workshop that we went over is in that github repo as well as the code itself so you should see that the code's there so thanks for checking this out um i hope you learned a lot if you want to join in the conversation with the graph check us out on twitter at graph protocol check out our discord check out our docs keep an eye out for what we're doing the next couple weeks and i'm gonna go ahead and stop sharing my screen thank you so much neter this is great okay i'm trying to turn this that music off all good there we go cool thanks again and uh yeah if you have any questions for natter head to the channels he mentioned and we will see you all on discord thank you 