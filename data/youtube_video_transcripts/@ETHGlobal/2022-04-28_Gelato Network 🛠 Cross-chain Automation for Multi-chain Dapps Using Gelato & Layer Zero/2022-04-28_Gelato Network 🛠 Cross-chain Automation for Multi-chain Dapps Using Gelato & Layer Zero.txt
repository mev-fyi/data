[Music] [Applause] [Music] wow [Music] [Music] yes [Music] [Music] [Music] [Music] [Music] maybe let's wait a minute or so sorry do you have a hard stop in half an hour or do we have a hard stop or is it okay cool all right let's wait maybe a second or so smiley maybe just to to understand maybe just to understand sort of like the uh understanding in the room do you guys know about um gelato already okay semi do you um know about like crosstre messaging okay um all right we'll just if you have questions in between just like maybe raise the hand and then i will try to answer them on the on the fly if something is unclear so and if i go too fast or too slow on something just maybe let me know because we're a small group we can just make it a bit more interactive um cool yeah i think i probably can just get started and then maybe we have some other people joining in later um yeah thanks everyone for coming who's here some familiar faces um and yeah today we will talk about um automation um about specifically cross chain automation um and it's the titles are like a mouthful but we will uh and unpack this a bit now so you know what um we will be discussing and um let me actually just put my timer here so i know if the speed too slow or too fast cool awesome yeah so cross-chain automation for multi-chain depths that's a mouthful and this is what we will be discussing um yeah and i think if you are building an application over the weekend if you are especially want to build an application that requires certain processes to be automated and then if you might build this application on multiple networks not only on one i think this talk will be quite interesting to you and yeah if your question just raise your hand and we'll get them answered all right so this is sort of like the agenda we'll go through some definitions first then we will go into smart contract automation why this is necessary why you need that um how it works um and then we actually go into code um and just start seeing how we can build it maybe um are you all developers or um developers raise your hand please just to know okay all right all right so we got some code here so if it's if you have questions regarding that just let me know um and we all will try to answer them shouldn't be too complex all right so first of all the um the tile is a bit of a mouthful as i said right crosstrain automation multi-chain whatever um and we are now sort of like unpacking it slowly and then going into certain details so you guys understand what's going on um yeah so first of all cross chain the the cross chain part of this whole title like what is it about right so um here you have um let's say two different uh layer one networks you got polygon on one side and then you got ethereum uh on the other side and let's say you are building an application right and that application um has i know it stores a balance of your users for example on polygon and then balance of your users on ethereum and they should sort of like know about each other's balances right then this is normally in like the normal world not really possible because polygon and ethereum can't really communicate with each other directly as these sort of two different networks right um and that's why cross-chain messaging protocols exist cross-chain messaging protocols are sort of this layer in between um that allow you um as a application developer to actually let these two different applications these two different smart contracts that are on polygon on ethereum they can be on any other evm based compatible network as well to communicate with each other and say hey here i just received some money from a user and you should know about this on ethereum for example right and there are a bunch of different um cross-chain messaging protocols out there that you can use some examples include nomad for example and there's layer 0. i think multi-chain just really released theirs a couple of days ago so there are a couple of different protocols you can use to let applications from different networks communicate with each other that's the cross chain part now to the multi-chain part is um applications sort of like uh existed in on each network like in the past right so you had an application on ethereum and and then your user base and your front end was usually just configured to serve your users on this particular application on ethereum right but with all these other networks coming up in the past one or one and a half years we have seen that a lot of applications for example uni-swap or curve or other as well they deployed their applications on all these different networks right so because they said hey we seen that there are a lot of users on for example polygon or on phantom or binance smart chain and we also want to serve these guys so we basically took our application and we put them on all these different networks and now you have sort of like five like you have the same application five times on five different networks right um and this is sort of like what we call multi-chain depths and there are like the the so like generation one multi-chain dabs which are dabs that are completely isolated from each other they're like isolated instances on on ethereum and it has nothing to do with the one in polygon nothing to do with the one on phantom right and if you combine these multi-chain with cross chain you can actually create sort of like a system where these applications even though they live on different networks can all communicate with each other so it feels more like one application rather than um five different ones five different isolated ones that live on different networks yeah and then the automation part so what's automation um and i will go into this um in a bit more detail in this talk because this is what we at gelato do and we enable you to automate your smart contracts on all these different networks and yeah there's uh there's some reasons why smart contracts even though sometimes uh it's sort of like portrayed that they are these autonomous agents and they do everything themselves are actually not that um automated and we go into that in a bit more detail but this is sort of like the last pass the last piece of the puzzle to in order to create truly multi-chained apps that communicate with each other you need sort of automated processes to happen to redirect the information that enables them to communicate with each other like every every day or every couple of hours cool so now we are we are jumping into the topic of why smart contract automation why you need that um and then we'll later go into some demos and some code and some examples all right so first of all what is important to understand is that smart contracts are not smart they are very dumb actually they're quite lazy the only thing they do is they have certain functions right and these functions they contain a cert certain logic and this logic in this in in these functions enable you to change the state of let's say ethereum or this particular smart contract um but these functions that exist there they are not self-executable they don't just like magically um transfer 1000 usdc to your uh to your account they need to be called they need to be triggered by someone in order to actually facilitate that logic um and that's usually an eoa which is which stands for externally owned account so an account external to the system has to send a transaction has to pay for some gas which is the unit of computation in ethereum and once this is done then the logic of a certain smart contract function is actually executed um if no one sends that transaction nothing will happen even if you encode certain rules in your smart contracts nothing will basically happen um by itself so my contracts do not self-execute and this means that the evm so the virtual machine underneath ethereum um it does not support conditional and recurring transactions and if you think if you think about um automation what is automation is just stuff happening like all the time in like a in like a infinite loop type of way and this is not natively supported on evm based networks like ethereum so why is that right or why isn't that supported vitalik why didn't you do it um good question and there are like two ways of thinking about this the first one i call an endogenous evm automation which is basically why why don't these functions just sort of like run in these for loops and just always run and then a certain logic is executed whenever these conditions are met it's because um basically you have in a blockchain yes you have a block and in the block only a certain number of transactions actually fit in right um in in order to counteract spam and people preventing others from actually sending transactions to these networks and getting in mind there's a there's a concept called a gas limit and a block can only fit so much units of gas in it in order to make sure that still sufficient nodes in the network can actually get it and process all the transactions and yet you don't run into a scenario where you have a very centralized network and so if someone would be able to create like these infinite loops on ethereum and a smart contract then no other transaction will ever get mined after it right so if you if you think about it sort of from that point of view it makes sense that okay these sort of infinite loops within smart contracts um if you have these atomic transaction concepts that we have on ethereum then this doesn't really make sense so another approach of trying to kind of like hack automation or these infinite loops into ethereum would be to actually build it on the on the client side so so not like in the core protocol but let's say on full nodes they will have this extra module which then allows them to constantly sort of like check whether certain transactions can be executed and they um they check certain conditions all the time and and once they're met then these transactions will actually get executed however this is very very computational intensive if you think about it let's say you have like 10 000 different sort of automated tasks or jobs running which you have to check every block that whether they can be executed or not right this is just a huge computational load on your system and especially this is also uh subject to like spam attacks so someone could create like i don't know a hundred thousand tasks and these phones need to check all of them at the same time and whether they get mined um and this is just like practically infusible because this would mean full nodes have to beef up their servers significantly which is basically what we always try to avoid an ethereum because this would mean only a very small number of people could actually run these full nodes this means centralization and then you end up with just like one giga computer running all the computation for everyone else and no one can really verify anything so that's why having these sort of um the sort of automation layer on the on the client itself doesn't really make sense so you need to have it also so what's the what's the result here what's the what's the learning is you need to have an external network on off chain external network that actually helps you um automate these smart smart contracts by enabling you to submit these jobs to them and they check them for you um away from the sort of like core protocol and then help you get these transactions mined at the right time yeah and this is basically what we do at uh gelato um and there are sort of like two different parts to it that you can think of one is for like the on chain part and one is the off chain part and the option of on-chain part is is sort of like what we call um our gelato op system or you can think about it as like a job scheduler um and there's the smart contract and in the smart contract you can basically submit um is a standard interface and at the smart contract you can submit um two types of data points one is basically a resolver and one is a target and what the resolver basically says is hey this these are the conditions i would like you to track to make sure that my transactions are executed at the right time for example check that 24 hours have passed on ethereum or check that the price on uni swap for eth ucc just dropped below 2 000 for example right any condition you can think of you can basically define into into these resolvers and then you can define a target smart contract and those targets basically when this condition is met then please execute the transaction at this target or on this target smart contract and this target might be swapping on uniswap or transferring tokens or whatever action you would like to do and you submit this these two data points via this job scheduler and then it's an event is emitted on chain um and then the gelato nodes which are called the gelato executors which is the sort of like secondary middleware network um that lies underneath ethereum polygon phantom vsc medic so all evm based compatible networks and we are still expanding to a lot more and then at some point also non-evm networks we're for example working on like a stark stark integration right now um then these notes they listen to the event of this essential job scheduler smart contract and then they basically process information and then they will for you check every block whether your transactions can be mined uh can be executed or not and if so they will get them executed fast cheap and reliable basically this is what the whole concept here and yeah in the middle uh you've got sort of like a layer of um redundancy which we call the json rpc aggregator because yeah it's actually communicating to the network especially on these low latency networks these very fast blockchains like polygon or something is actually not that trivial in a programmatic way but i will get into that in a bit yeah and the benefits for developers like yourself or colleagues of yours is pretty straightforward first of all you don't need to host servers it's completely serverless right so you have your smart contract on ethereum you got um your ui on your front end on ipfs you automate your smart contracts with gelato and then you fetch the events to display data on your front end with the graph right and you combine all this together and you don't as a team as a developer have to run any sort of server and your applications completely server which is always great and then um yeah so we what what these what what glad offers you is we aggregate multiple rpcs uh which means that we run our own full nodes we work with infura alchemy and all these sort of rpc providers to make sure you always get the right information at the right time and when you want to actually execute certain transactions these transactions go through even if there's a huge spike in demand for block space at that time right and this often happens especially on these cheaper networks then gas prices suddenly like go crazy um and then getting transactions mind is actually very very difficult yeah and this this basically goes into yeah reliable transaction relaying is a very key component here and then there are a lot of like edge cases that we that we sort out for you for example reorgs i think we have seen crazy debris orgs or like polygon and the likes where you think your transaction got mined but then 150 blocks afterwards you actually realize it didn't get mine because it was like a massive re-org in the network and yeah um you have to catch these sort of edge cases and this is like what the system is optimized for um the beauty of it is that it's multi-chain so um let's say you want to deploy your application to five different networks now this would mean if you like build up this whole like server infrastructure and automation infrastructure yourself you would have to like host it and run it on five different networks with five different rpc providers and all of that which is a pain and yeah and then one of the biggest reasons is that there's no single point of failure when you use something like gelato because if you build up your own system you run your own centralized service server then obviously um yeah if your service servers goes down then no one will call this function anymore and yeah your depth will start stop working and it's not really that decentralized anymore and yeah and then there are a whole bunch of other reasons like private key management which you don't have to do anymore in the cloud which is another rabbit hole to go into and yeah and that gelato basically coordinates multiple nodes to always make sure at least one is up to get your transaction relayed which is nice um and yeah so this is like our ecosystem right now of projects that users and they're like a bunch of really cool ones one that we will go into today is abracadabra so we will make a small case study about how they are using us but there are also other projects that are similar like maker daw for example the users to automate the debt ceiling updates on their protocol and then algorithmic stable coins for example users to periodically rebase their token every 10 minutes and then they're like funny use cases like nft nfts or avogadges or something and you can pet them every eight hours and you can automate this padding of your avogadro with gelato like there are um yeah a bunch of a bunch of funny use cases and yeah people do really random like it's completely permissionless so you can do whatever and people do watch trading on uni swap and stuff like that so some shady stuff as well but yeah they it's they can use whatever they want right we can't really control it and um yeah so now we go into uh the demo and how you actually do that um and first what i will do i will start with with a very simple use case um uh how you can automate a specific function then we go into how abracadabra uses this to actually make a fully multi-chain application that does cross-chain message passing which is quite interesting so the first use case which we will be talking about is basically licking ice cream and as imagine there's and then you have an ice cream nft it has three scoops and you can lick it there's a function on this nft smart contract which is called lick and when you lick it one of the ice cream scoops will disappear and it will actually disappear on chain so this is an nft which has all like the svg information stored within it and so it dynamically changes the images on chain when you lick it but there's a caveat to it you can only lick it every five minutes because otherwise you will get brain freeze because you lick it too often right so um you don't want to sit there for 20 minutes and press lick you we want to automate that right and so this is a very simple use case that i can quickly show you and this is sort of the smart contract right here we have this is on polygon by the way this is the ice cream nft and i think you should be able actually to plug it also in openc and then you see it on openc we'll skip that for now and yeah so these are like if you go to the block explorer then there's like this code section here right and you actually see the code of the smart contract you're interacting with and let's check out the function that we want to automate here this is the function it's called lick you can pass a token id this is your nft and then it will basically check whether the lick threshold has been met or not right and if not it will the if you have leaked like you licked now and then you licked a minute later then it will actually not work because yeah you have brain freeze so you can't lick it anymore all right so how would we actually automate it with gelato so there's this application which you can just find under app.gelato.network we just increased the stuff here and yeah i'm connected to the polygon network right now so what you can do is there's actually this tutorial thing which is a bit helpful here so this is the address of my ice cream nft smart contract that i showed you earlier what i can do is i can just copy the address here i can dump it in here now it will fetch all of the api and all the information about the smart contract automatically from the block explorer and then you can select from all the functions that are possible to automate um for example in this case the lick function and yeah so in this case our nft is actually nft number seven two three so we will dump the token id in here and now we can just define hey i wanna lick this smart contract every five minutes you can define like a start date when you want to lick it um but we'll just want to link right now and then you can because transaction costs money right on on blockchains unfortunately so you have to define uh how you want to pay with it and they're like two options one is just a very simple prepaid model so we have like a balance here in gelato where you can just deposit some in this case medic on ethereum eth and then basically this balance gets deducted for every transaction you execute um or there's also another option where you can have the transaction pay itself for example let's say the nft would already send ether to whoever calls that function then you can just select that and you don't need to pre-deposit anything so let me just um here it actually gives you some let me say lick my ice cream in amsterdam sounds a bit wrong but i'll just create it let's crank that up yeah and then basically what will happen is the transaction um will be broadcasted and then hopefully it will get mined and then once it mines the events gets emitted the gelato network will pick up all the information about the task and then yeah it will basically start licking that ice cream and this is and this is now now done basically now as long as there are some balance in this account this ice cream will get licked for eternity um and now you got sort of like an like an automated smart contract here but this was uh this is just like for you to understand how you actually create these tasks and now i think to like the interesting part is um how do you take this sort of like very simple notion and primitive of okay i can automate certain functions and how can you actually do something significantly more complex with that because licking ice cream is cool but how can you actually build these cross chain automated multi-chain depths that i was talking about at the beginning right and um yeah the case studies about abracadabra abracadabra is like a lending and boring protocol it's live on a lot of different networks and sort of like their usp at the beginning was that um hey we will we provide you with like features that are sort of like similar to maker dao and other landing protocols but we are very multi-chain by default so we are we are available on like polygon and on avalanche phantom and all these different networks and um yeah our protocol lives is not isolated but it lives on various systems but um so what they have is um and uh i actually found out that they are using gelato for this by so like accident because i was talking to the developer and then he actually showed it to me on like a video call which was dope and so what they do is you they have a native governance token called spell and spell is their governance token what you can do is you can take that spell you can stake it on phantom you can stake it on ethereum you can stake it on avalanche for example and if you stake it then you are eligible to receive daily um mem rewards and mim is their stablecoin mim is so like one dollar like ucc for example and so you're a user you're on phantom you're on aperture on avalanche or whatever and you wanna stake your and your spell is basically there okay that's got a lot of notifications going on can i do not disturb um exactly so um and so you stake your spell on some of these networks and now there are let's say one million mim rewards that are distributed every day right but these memory whether you have one million one million in mim that will be distributed on a daily basis however um you sort of need to find out which network has how much spell staked right because there is there they think about the application as like one application and then it doesn't matter where you stake you will receive your pro rather share of the total one million dollar worth of sp worth of memory rewards that you will receive right so this um yeah so basically each of the abracadabra implementations on phantom avalanche or whatever they need to understand okay not only how much uh spell was staked on their network but how much spell was staked in total everywhere right and obviously a polygon doesn't know how much spell was staked on avalanche and vice versa and so you need to aggregate that information somehow and basically what they do is they have sort of like a hub and spoke model so they have ethereum as the sort of hub for their system so they have like a one contract on ethereum and then they treat all these other layer ones or layer twos as spokes sort of like as these as these children children chains and and they what they do is they want to relay the information about how much spell was staked on avalanche or polygon once a day back to ethereum so all of the different spoke chains they sent the the amount of spell that was taken on them to ethereum once a day and then this gets aggregated in ethereum and then sometime later they need to trigger in a function that basically then sends the um the mim rewards from ethereum via some bridges back to all these networks and so you every day pay out the rewards that you want to pay out in the sort of like cup and spoke model and to achieve that they require two different types of gelato tasks to actually make that possible and the first one is on the spokes or like polygon or avalanche for example and this is snapshot how much spell was staked and then pass this information to ethereum and then the second task is on ethereum once all the information has been aggregated trigger a function that then distributes the memory words back to all these spoke chains and yeah we'll actually go into how this is done so um the first task right so we are now on let's say polygon or avalanche and we need to check um we need to check how much how much spell was staked and we need to get that we need to get that information over to ethereum right how this will work on like an architectural point of view is that you have to use my contract that stores that information and contains the function that will broadcast this message on let's say um a polygon right it's this m spell reporter.sol smart contract here it has a function called send amount and what this send amount does it it snapshots the amount of spell that you have on this particular smart contract and then it relays that information via a cross-chain messaging protocol in this case it's layer 0 to ethereum and this is triggered every day at the same time basically and at the same time all these networks on polygon avalanche phantom get called by a gelato on this particular smart contract function and then relay the transaction let's maybe have a quick look of how this actually works or how this looks like in the code so um this is the they call it and they they have their repo open source by the way so you can check it out abracadabra's repository they have this function called sender mount here and there's a lot of weird like time time calculation stuff in here but this is really not the interesting point the interesting point is that they have um that they check the balance they check okay what is the spell balance of the m spell smart contract the m spell smart contract is basically just like a staking contract so yeah sure like this bit bigger this is good okay sorry um so what they do is they check okay how much spell is uh staked or how much spell is in the m square contract the m spell contract is literally just a contract which stores where people can stake their spell and then once this is sort of a clear they will encode that information in a payload which is okay just they want to know what's the time where the snapshot was taken and then what this demand and then what you do is you have this end point here and the endpoint is an immutable variable which is sort of the address of the layer 0 endpoint which is this cross-chain messaging protocol that you use and what you do is you say hey i want to i wanna broadcast this payload that i just encoded here right i wanna broadcast it to the destination chain which in this case is chain number chain id one and one stands for ethereum i wanna i wanna um send that information to the spell sender which is the contract on ethereum that should receive that information and yeah when i want to send that payload and yeah you have to pay this crosstrack messaging protocol so they forward a bit of forward a bit of in this case matic to them and then pay for the transaction so basically what this this smart cons this smart contract lives on polygon right it has the center mount function gelato calls the center mount function now to send a mount function via layer 0 calls this smart contract right here which is um this m spell sender contract on mainnet right and there's this sort of like fallback function that they have which is the standard function that layer zero calls which is um the lz receive function and here what they do is hey they first of all check okay is it actually layer zero's endpoint that is calling my function if yes okay then we are gucci um and then what they do is they decode this payload here that we just encoded on the other side on the other chain and then they update the state variables in here so they update okay this chain has 100 spell staked right now all right so this is the first task that is running and you can actually see that um we for example go here the cool thing about this um application is you can actually see all the tasks that have been created in real time so we got this leaderboard and this is like the the real task created by um the death of abracadabra and you see like when this executes for example and you see he created a task and this is this actual contract that is live in production right now from abracadabra and it's being called um yeah and this is this is the the address and this is the function right and then you can actually go to each transaction and and check out how it works um yeah so this is this is so like the first task and then the second task is um speeding a bit up because we already have 30 minutes the second task is okay how do i then take that information about how much spell was staked on all the different networks on ethereum and then distribute rewards and this is actually a pretty simple basically is another gelato task running which calls the bridge mim function on ethereum in the m spell sender contract and what this does it uses multi-chain multi-chain is a bridge that you can use to transfer tokens from network to network and it takes this multi-chain contract and it bridges the mim tokens um on their behalf and how this looks like for the ones who are interested is here's this m spell sorry this is sender contract they have a router interface here from any swap or multi-chain how they're called now and then there is this bridge mim function and what this bridge min function does it just like some calculations how much mimit has and then it's actually quite crazy in a for loop it actually calls the router and just sends mim to all the different chains that have some state stored within it and so what happens now is um you distribute all these rewards over to the network and now this process has been completed and now gelato will just wait for 24 hours again and then this whole process will it gets initiated again and so it runs completely autonomously they don't have to do anything and like if abracadabra developers will stop tomorrow this will just continue forever as long as they have balance in this account right and this of course you can also automatically chop up so if you you can take a bit of your spell or mim that you transfer and you just set it to ether something and you top it up on july and you have this sort of infinite loop running and this is actually how for example beefy does their harvesting quick shout out to xerox merlin who's a developer of abracadabra who i stole this concept from right so he actually he actually did it and um yeah i find it i found it cool that's why i wanted to present it because it's like the first i think the first one i've seen that have completely automated processes across like multiple networks so pretty dope stuff um and unfortunately we run out of time but um one quick thing what i want to mention is not which data you don't even you don't necessarily only have to create tasks which are triggered based on time like every day you can trigger them by any sort of condition you want it could be like price changes it could be interest rate changes it could be your balance changing or whatever and this would require you to create a resolver which is like a smart contract which returns true at a certain time that tells gelato when to execute but we don't really have time to go into that um but yeah i think this is sort of like a good point to to to stop this talk and yeah if you have any other questions regarding specifics of what we want went through or some high-level stuff feel free to ask thanks [Applause] any questions or should we just go outside and then do them privately or something all good okay cool then we can wrap it up so [Music] [Applause] [Music] you 