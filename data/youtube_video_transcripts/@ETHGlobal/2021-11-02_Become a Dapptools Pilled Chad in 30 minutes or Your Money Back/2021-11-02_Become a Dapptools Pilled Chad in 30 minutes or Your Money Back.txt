of transmissions here he's gonna be leading it um and yeah if you have any questions feel free to pop them right into the chat and i'll try to get to them at the end but if not then you can reach him on the dev tools chat um okay transmissions you can take it away cool does everyone hear me all right yep you sound fine awesome okay so yeah as explained this is the the kind of dap tools intro talk uh you see a kind of compendium of dab tools excitement tweets uh so if you've already tried dap tools hopefully you can learn something from this talk if you haven't uh buckle up how do i move slides on okay there we go uh really quick i am a developer very capital i'm a dap tools convert and vocal shill on twitter i mix literally a library sometimes you can find me at transmissions 11 on github and twitter i'm just going to acknowledge georgios who helped with some of the images on this talk and also some of the content so this talk is for developers who are already comfortable with hard hat like if you if you haven't started with ethereum at all uh you might you might want to go learn about some of those basic concepts first but otherwise uh yeah we're gonna take to the next level so i'm gonna start off by posing a question one of these two contracts have in common they add up to they're the top ether balance contracts on ethereum the e2 deposit contract and the wrapped ether contract they add up to hold like 13 of all ethan existence a casual 60 billion dollars as the as might be obvious from the talk that they're both built with daptools you can see in the consensus specs repo they're importing ds test which is the the datpub test framework uh and same with the weak uh repository so if the two biggest contracts on ethereum trust apptools uh maybe you should consider trusting it too so what is the staff tool saying it's tooling for writing testing fuzzing and deploying study smart contracts you hopefully know uh at least three out of four of those things what they mean i was developed by the the daphub team which is like make your dao's engineering division back in the day uh that's uh andy in the top right presenting at like devcon3 it's been used by the e2 deposit contract maker dial fractional reflexer pickle maple countless others it's got almost a thousand stars on github right now and i just gave some logos here uh yeah uh really quickly out of the way it's like kind of a replacement for hard at you can use them in the same project but they kind of serve the same role um and you can get mostly the same features out of both but daptoes has some couple bonus ones that i'm really excited about and i'll be showing you in the talk today so really quickly like why not hard hat you might really like hard hat so so why should you consider switching to death tools first of all nothing super wrong with hard hat like no shade intended at all but writing tests in javascript is just not enjoyable for me and yes that includes typescript i'm sorry there's just way too much boilerplate there's like hundreds of files if you look in like uh paul's ethereum template which is is great but there's like a million dot files and config and it takes a while to install and there's a pre-commit hook there's all this stuff about managing big numbers bnjs bns like javascript now has its own native big number this is all a pain to convert between and when you're just trying to test your solidity smart contracts and you have to like operate in this whole like javascript world of converting these numbers it really kind of takes you out of the mood and it's also just slow for complex tests because you're running javascript isn't a fast language and some of the time you're actually interfacing with your the kind of evm over rpc even which is going to be even slower because you're making network requests each time and the main reason i don't like it is just because it's context switching i want to focus on my solidity i don't want to be debugging some random issue with big numbers or other javascript stuff that's kind of in the way it's kind of a whole level different level of abstraction which is separated from my smart contracts and then the other thing is not enough tools so you might be familiar or might not with fuzzing and symbolic execution here's some really advanced testing tools and uh get you a lot more confidence that your code works as intended uh but currently they require you need to use separate tooling to access them like a manticore kid now these are these are separate from your hard hat project they're they're kind of a pain to set up especially if like you have to like you're writing similar tests for both but they're in entirely different languages in one project uh and because of this not many devs kind of integrate these uh these tools and they're really awesome and they can uh save your contracts from getting hacked for millions of dollars uh so if we want devs to write more secure code we need to give them better tools daptools is that better tools so all right daptools 101 like kind of wide app tools now no javascript you write your tests and slitty uh for some of you that might actually sound pretty bad like i know a lot of people kind of have this grudge against solidity because it's like well it's not javascript it's not super powerful like okay uh there's just kind of a really nice i think you'll find that there's a really nice just kind of vibe with being very close to the to your code and not having this layer of abstraction that is javascript most of the time uh so you write your test in a function in a dot t dot soul file which indicates it's a test uh here's an example of a kind of test function up here uh and then we got features it's fast it's really fast you can run builds in less than half a second you can run a whole test suite uh in in seconds or two you can run invariant tests symbolic tests uh and these can all run in in at most uh you know a couple seconds and with fuzz test uh a little more but it's fast it's low boiler plate i'm going to show you that we can spin up a batteries include adapt tools project that is like completely production grade in 10 seconds with no kind of templates necessary it's got powerful cheat codes which we'll explain more it's got gas snap shotting main net forking stack traces here's an example of stack traces look you can see all the events emitted functions called where it reverts you've got a visual debugger console.log equivalent i know many of you will probably love console.log uh deploying verify on ether scan install dependencies from any github repo built in test coverage invariant test property tests symbolic tests and it's all through the command line so you can kind of build your own kind of abstractions on top of dab tools like really easily just with bash scripts uh so really quickly devtools has a lot to offer it's actually a collection of tools there's seth which is this tool like that lets you read and write from the chain uh dap which is what we're going to be focusing on today which is for compiling testing and debugging smart contracts and then dap kind of uses this lower level tool they've written called hevm which is like a custom evm implementation for designed around debugging and symbolic execution so we're going to focus on dap and what the rhythm for building and testing smart contracts look like but i i encourage you and maybe you'll have a follow-up talk sometime about uh trying to explore seth and hebm uh on your own uh so really quickly uh i don't i i'm probably gonna be going at a pace too fast to follow along but just i'll have these slides i'll send a link at the end so you can kind of use this as a reference you install dap tools you install nyx first then you install all dap tools with the shell installer make sure if you're on an m1 mac you do this in a rosetta terminal okay creating a new project it's really this simple you create a new directory you enter the directory you call dap init boom you're done those are two tests that are already spun up and running that's literally it in 10 seconds we spun up a fully functioning batteries included devtools project with two tests that just ran and look at that little time window at the bottom that took six seconds for the tests and the spinning off of the project so uh the speed to getting started with daptools is really second to none uh so compiling uh you you see this is the kind of default dav tools project structure we have an src folder uh some git configuration but the main thing you want to focus on is src folder we have the testproject.sol which is like our contracts and a testproject.t.sol which is our tests i purposely edited the kind of default to have a broken some broken code that doesn't compile you test that by running build and you'll see this kind of colored compiler output that tells you look you didn't declare these identifiers that's pretty obvious uh and yeah this is less than half a second for a build uh so let's do some basic testing so if we go back to that function we remember we have this add x y function how we're going to test this well first let's kind of understand our tests so in the test.testproject.t.soul file that's where we put our tests you can see that here let's keep it simple for now you can see that we have this kind of test project contract it inherits from this ds test thing it's got a setup and it's got a test so what are all these the the red stuff is the dap tools testing framework it's kind of the solidity library you import that has these these helpers for you uh you declare the kind of contracts you want to test using state variables you have a setup which gets run before each of your tests and the cool thing about setup which makes staff tools so fast is you may be used to like fixtures in hard hat which like you have to explicitly declare a kind of state you want to roll back to devtools automatically just it runs your setup once it kind of caches that state and just rolls back to it for each test which makes it much faster than re-running it each time you can see with the cyan we have a test and then we have like an assertion inside that test which looks uh kind of similar to normal study assertions but there's some more powerful versions that we'll see so this is how we're going to test our ad function you see we call our project contract and we call add we pass the arguments one plus two we assert that this is true that it equals three so how are we gonna actually run these tests well we run the dap test command uh you put this in your terminal in the in the same directory and you'll see this output you'll see it runs the test and it gives you the gas usage of the function which is super dope uh and it tells you that it passed all right that was pretty easy what did that take us 15 seconds probably to get that started uh and you can also use this verbosity three flag uh to kind of see a full stack trace um for the test so you can see that it ran setup it created our test project it called add and then it returned um okay now let's try a let's try making our test fail uh we changed this to this from three to four we introduced a bug so this should fail right we run dot test again it says assertion failed uh the problem is is this error kind of sucks like it may be for now because it's really simple test we can know exactly what's going on but if we've got really complex tests with lots of different values we really want to like get a better error message than this daptools to the rescue uh ds test has a a crap ton of assertion functions that you could take advantage of that are are much much better so we can swap out our assert true for assert equals which all you do is you just kind of put the thing that should be equal to and the second as the second argument and now when we run our test we see this beautiful stack trace that shows us uh it is that the ewinstein match what we expected it to be and what it actually is uh okay now let's make a new function say we have this function called no fun add no fun add doesn't let you it acts like add but it doesn't let you add two values that would equal 69 or 420. uh and it will revert with you cannot have fun so how are we going to test this uh how do we test for reverts so we could let's first just like make a normal test uh like this wouldn't revert uh we we have this test add no fund numbers uh we assert that zero plus 69 equals 69 uh but this is going to fail right because our thing reverts so yeah just as expected if we run our test with that test again uh we can see that it reverts uh test add fun no numbers we can see no fun ad it reverts online 12 in there with the you cannot have fun message so how are we gonna like assert that it's reverting here right uh it's probably simpler than you're expecting that's it you just prefix the test with fail so test fail uh indicates that the test will only pass if the function reverts and now when we run it we can see it passes so test fail makes the test kind of act in the inverse of a normal test a normal test will fail if the test reverts or an assertion is violated test fail will fail if an assertion is not violated or the test succeeds uh and right so this is download here if we like no fun add zero plus one won't revert because that's not one of our our funny numbers the test fails because it didn't revert all right so here's the problem with these kind of concrete tests that you're used to in hard hat uh and you just saw okay well it's pretty cool in depth tools i can write it kind of some similar way but here's what depth really takes to the next level so this this test doesn't really give us a ton of confidence our ad function is correct like what if the add function just always returns three our assertion wouldn't catch that bug in the code to be really sure our function is correct we need to try lots of inputs on it right so we could duplicate it a bunch of times we could have one plus two one plus three and assert on all this i mean it's better but there's still millions of combinations we aren't trying right so this is where fuzz testing comes in what if dab souls could generate random inputs for us we have the so here's how you do that you you have this test add numbers function this is our normal test but we adapted it now it's taking arguments it's taking a u in is taking another u n x and y we call project dot add with those u n values and then we assert that it's equal to x plus y test functions can take arguments dap tools is now automatically gonna like try random u and arguments on this test function for us we don't have to define values in advance so if we run dap test you'll probably be surprised to see that it fails okay what the hell is going on here this is a bit of a complicated error message revert screen and our function looks correct right it's just adding x plus y so if we kind of zoom in on this you'll see that it failed it's it's it's got red and you see this big stack trace and it shows us a kind of counter example the inputs that caused the test to fail you can see it failed due to a revert and test can either fail because their assumptions broke or a function converted in this case it was a revert this is a solidity panic which means it's kind of a slitty compiler check was broken we can look in the documentation since it ends with 11 this means there was an overflow that happened and now this input starts to make sense we have this huge we're trying to add these two huge numbers together which is going to cause an overflow and cause our test function to revert which is going to lead to daptools thinking that something is wrong so we can solve this pretty easily just by changing the arguments of the test function to be un128 if both parameters are and 28 you and the max you and 128 plus the max you and 128 cannot ever like it can't exceed you and 256. so if you run our tests again with these modifications they pass it ran 100 times it's pretty neat that tools is spamming our tests uh in essence with a bunch of inputs uh which gives us more confidence our code is correct by default it tries 100 different inputs you can increase it with this fuzz runs flag now it tries ten thousand okay this is cool but it's just it really isn't good enough yet like we need to be sure every possible combination works if we want to be sure our contract works is intended this might seem kind of trivial with like an ad function you're like okay i mean it's adding two numbers but when you're dealing with your your kind of you know d5 project or whatever where there could be a math bug somewhere that could wipe the entire system you really need to be sure that every last number is accounted for uh the kind of problem with doing this with fuzzing is beyond a certain point like every fuzz run takes some time and if you want to assert 10 trillion fuzz runs that's going to take 10 trillion years all right how do we fix this symbolic execution this is kind of an advanced topic symbolic executions with a test code for correctness you as the developer use the same way you you use fuzz tests you define inputs you run code with the inputs make assertions dap tools will let you know if it can break your tests and give you inputs on how so we're not really going to go into depth about how symbolic execution works but just kind of under the hood it kind of converts your code into math and then it uses a math solver to kind of uh point to places to kind of find ways to all the states your code can be in and if any of those states violate some of your assertions dab tools lets you know we're not going to go into detail so how do we make our boring old add numbers test a symbolic test that will basically in effect try every possible input do you catch that we just renamed the test from test ad numbers to prove ad numbers that's really it so yeah daptos makes it trivially easy turn any fuzz test in the symbolic one so now if we run dab test uh you see it passes uh and daptoes was able to kind of reduce this down to math kind of solve it and show that no branches kind of violated our assertion this is super sick and now assuming there aren't bugs and dab tools of the solver we have 100 certainty that our assertion holds over every single possible input that a system can be in so why should we ever use a fuzz test if symbolic execution tries every input and is still fast like can we just throw away test and use proof symbolic tests are great but sadly they can be used for everything they're constrained by the complexity of the code they're testing blah blah blah basically um like the more the more complex your code is the more states it can be in and the more kind of math equations the solver has to find so symbolic execution basically becomes infeasible beyond a moderate level of complexity so use symbolic tests for like math functions which don't really have a lot of possible branches or isolated parts of your code base but you're probably going to end up using fuzz tests for larger parts that are too complex to symbolically execute just a quick comparison so fuzzing you get fairly strong assurance it depends on how long you run the fuzzer uh and there's no limit to the complexity of tests it can run with symbolic execution you get near 100 assurance uh but it can only be used for kind of simpler code let's discuss one last dot tools test type in variance invariants let you test function test assertions about your higher level state relationships for example like the total supply of the wrapped wrathd3 token should always be equal to its ether balance so invariant tests allow us to kind of just write that and not define all the functions daptools needs to call we just kind of let daptoes explore our contracts on its own and test the assertions to ensure they're always true so how do we do this we have this contract called increase it is a value state variable uh and it has a value times two state variable which we want to assert is always twice the value of value so we can use in we know we can use invariant tests so how we're going to do that invariant test looks similar to normal tests they don't have arguments and they're prefixed with invariant instead of tester approved dot daptools is just gonna look at all the contracts that are stored in your test contract and call them with random values so we can write our invariant like this and variant times two we have an assertion we say that the project.value should always be equal to uh value times it should always be value times two should always be equal to twice uh project of values that's a typical assertion uh if we run this without test we'll see that it takes like about six seconds uh and it tries it tried over 2 000 call combinations and after none of them did our invariant break so this is pretty good like we got some nice assurance about that uh wait did i just oh okay yeah so uh here we have so let's add a new function to our test called break the invariant uh not to our test but to our to our project so we have this break the invariant function it takes a u and eight 8. if the number doesn't equal 69 it's going to revert but if it does it's going to mess up value times 2. so if anyone calls this with 69 our invariant will break so let's see if daft tools can catch this we're not going to change our test at all yes it did we ran daptest and we can see our invariant failed and we can see this kind of big stack trace and we can see it found a way to break it it expected three and it was actually four so you can see in the red all of the the calls it's making it first called increase then it called break the invariant with 44 uh and that reverted and then i called it with 69 and then it saw the invariant broke so we can see it first tried calling it the wrong number and then i called it with the right number and after every call it makes it checks the invariant holds the first two times it did and after calling break the invariant with the right number it broke so this is pretty neat we didn't have to write any specific test logic testing to break the invariant function davtools just kind of found that for us which is pretty amazing so it held each time except for the last okay now we're going to get into some kind of assorted stuff if you're a hard hat used here you probably have fallen in love with console.log where's your console.log don't worry it's right here so we have these kind of it's slightly different um you use events these log events which get printed to your stack trace um it'd be trivially easy to make a console.log type library that just wraps these events if you don't like it if anyone wants to work on that reach out to me but yeah so you just emit log you uint which is the type we're logging here so we log an unsigned integer and we'll see if we run our test that it shows our value here [Music] and basically these logs only show up if your tests fail by default but we need to use a verbosity of two to see logs for for passing tests um if since the test isn't failing um all right you might be wondering okay this is kind of confusing can i give this log label uh wait where did my label slide go uh the answer is yes you just use log named uint with the label so there's a log for every function type uh all right some other features you have built-in coverage so you can have all your tests written um and then you can kind of run down test coverage and it gives you this output that shows for every line of your code um does a test at some point touch that part of the code so you can see here we have coverage for this file and in the console it shows us highlighted in green the lines that are covered so everything's covered here but here in this function not everything is covered so red areas indicate that code is not reached in any of your tests so you need to write some tests where that code is written and then it'll turn green uh this is really sick i'm sad i have to gloss over this because we're kind of running out of time but dap debug is the is this you can run dap debug in your console it opens up this kind of visual menu where it lets you select which test you want to debug uh you select one of them and it gives you this really kind of at first confusing but really powerful debugger view where you can kind of stack opcode by opcode through your code you can see we have a stack trace on the right that updates as you step through your code we see which part of my code is executing in bold you see a live view of the evm stack and yeah and this is really useful for like seeing why your code takes so much gas you can see all the op codes that are run and be like oh there's an extra s load here like let's cache that and it's also useful for seeing what part of your tests execute when things are breaking but is there main networking i see this question a lot and for some reason people assume dab tools like wouldn't have made networking uh it definitely does you can see this in the docs you just run dap test with the rpc url flag in this case we use like coven and fura and then your tests will run in that environment you just write them as normal what if i want to change the current block the current time stamp update a storage slot cheat codes that was this thing called cheat codes they're implemented basically as function calls to the special address there's set block timestamp zip block number updated storage slot load from a storage slot and this kind of other crazy stuff here's an example of using them we define this kind of agvm interface we define the hevm address um and then in our test we can call hvm.warp and this moves the block timestamp five days in advance so this can be used for testing functions that depend on the time right like compound interest uh yeah so that was all i want to go through in terms of slides uh i'd suggest starting with i know i said no templates are necessary but there are some kind of helper scripts you can get and especially if you're using something like vs code which doesn't recognize davtools projects by default i'd recommend trying out georgios's dav tools template uh daptools doesn't end with just the dap command like i showed you make sure you try out seth uh we've compiled the list of daptools projects to learn from as examples in this regifo awesome tap tools repo i'm a maintainer you can find the slides for this talk at tinyurl.comtoolstalk and if you have any questions please reach out at httpsdaphub.chat so this is daphub's or adapt tools is a kind of chat room there's a lot of awesome developers and they're ready to help you out i'm one of them i'm quite active in there i say good morning every day in the random channel please join um authentication is broken for everything except twitter right now um so don't be disheartened just make sure you're logging on with twitter in there i'm active you can ask questions about this talk just ping me or dm me i'm at t11s or adaptables in general uh so that's your place uh thanks for listening that was our quick dab tools overview i think i have uh about at least like four minutes to the end of this talk i might be able to abuse my little five minutes i can use uh after to give a quick demo of how we'd write and test the weave function uh not the weave function a wrapped ether contract so i'm going to try to go ahead with that so here's a test project i just spun up in advance um we can run so we have this we test we have this weave so uh i'm gonna start out really simply by so this is one of the awesome features of devtools is you can install github repos as kind of dependencies you don't need npm modules so you can just do hps github.com uh or or wait you can just type it as like this you can type rari capital slash soul mates this is kind of a a library of solidity functions oh i have to commit this on get first sorry one little quirk add an existing repository desktop test project we can add this repository we're just going to commit this okay so we can install the soulmate repo which is like a and a kind of open zeppelin replacement in some ways uh it installs it into our project and now we can import it so i'm going to import the erc20 base contract from soulmate so that just you just do it like this soulmate tokens erc20.soul and we're going to have our weak contract inherited because raft ether is an erc20 uh they're going to want uh it's going to want a name so we're going to name it wrapped ether we give it a symbol with and we're going to give it 18 decimals so this is the typical ethereum decimal scheme um we're going to give and now we don't need any constructor because wheat is pretty simple but we're going to need to implement the deposit method so deposit is a external payable function uh and just to save a little time i i have the code already implemented down here so i'm gonna uh put this in here i have this other safe transfer library which is just kind of for handling uh heath transfers safely all right so we have a minimal version of the of the wrapped ether library implemented here of the wrapped ether contract implemented here uh now let's test it so first of all uh we can just see our test over here we can build the contracts really quickly to make sure everything works so we type that build in our console works perfectly to see that little check mark so we know it's working uh let's implement a really simple concrete test we can test test deposit uh so our test contract actually starts out with dab tools um with the like a crap ton of ether in it so we don't need to like get ether anywhere we can just write weave deposit value and let's do one ether and now we'll make an assertion that we now have our test contract which it can be accessed under address this has one ether of weak so we the weak token is minted when we deposit one ether we of what so we run dap test boom our test passed uh so you're probably you're probably thinking like okay you just showed us all this fuzz testing stuff why don't you put it to work let's put it to work so we'll we'll do uin 256. 256 amount to deposit uh one caveat here is since we don't have unlimited eth that starts out in this test contract we have to ensure that our balance uh that this amount is not greater than our balance so if this matters greater than our balance we exit the test early uh and now otherwise we can just replace all of our hard coded uses of one ether with amount and if we run depth test you're going to see it tried 100 combinations there in our test pass that's a really simple fuzz test and if we want to like be a little more confident we can bump this up a bit and you'll see that it's just going to try to grind basically our function for any function that for any values you can find that break it and it passed our weak implementation is looking pretty good um i was going to demo with drawing but just to kind of speed this up a bit let's show off invariance really quickly uh so to kind of implement an invariant like the weave balance uh we like here i gave this example in the slides but we might want to say uh a total supply and variant which is like the weak total supply is always equal to the balance of the weave contract oh maybe i'm a little zoomed out by the way i hope everyone could read that um so this invariant now that tools should try to call our we function a bunch of times and see if it can break this invariant let's run this so it's gonna first use our test our test deposit function and that's gonna use our test invariant and both passed so what was that three minutes um and we have a weak contract that we just fuzz tested uh with invariants um yeah let's let's demo one or two more features we might want to demo i'm going to turn this back into a concrete test uh really quickly just for simplicity we can demo our dap test coverage view so if we reset our terminal here and we write dap test coverage you can see that our our weave.sole contract we tested the deposit function but we didn't test this withdraw function so that's something we have to be aware of we can try out the the dap debugger really quickly just to show what that looks like so we have this test deposit function and we can kind of uh step through every part of it so you can see this is the constructor being called let's just skip down the stack trace okay now here's the juicy part so we deposit we call this mint function we get the mess center messed up value you can see the stack updating you see the op codes going one by one you can see it minting the token and you can see the event showing up here on the right so that's the debugger that's in variant test that's coverage and this was all with straight out of the box that tools uh no config required so uh that is the end of my taco i would go longer if i could but yeah i know that's uh we're already over hey thank you so much transmissions for uh logging on and doing this really great workshop and thank you for everyone who tuned in through zoom and thank you to the 20 or so other people who are watching from youtube i want to encourage everyone to again reach out to transmissions keep this conversation going and yeah have a really great day bye thank you everyone 