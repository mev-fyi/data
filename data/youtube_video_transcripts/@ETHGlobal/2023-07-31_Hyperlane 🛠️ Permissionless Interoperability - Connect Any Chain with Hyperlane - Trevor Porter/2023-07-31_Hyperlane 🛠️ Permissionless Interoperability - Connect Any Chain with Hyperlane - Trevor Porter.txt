foreign [Music] thanks for coming everyone uh so my name is Trevor Porter I'm a protocol engineer at hyperlane and today I'm going to talk to you about permissionless interoperability what that means and how you can use it in your hackathon project um so I guess just to set the scene what hyperlane is uh is where an abstract message passing Bridge so we allow you to send arbitrary bytes between two different blockchains so two different smart contracts can interact with one another that live on different genes using hyperlady kind of the thing that differentiates us the most from competitors kind of in the same realm is we allow you to deploy hyperlane onto whatever chain you want so if you want to be on a certain chain that doesn't have interoperability built in into it today you can go to our competitors and they'll say give us hundreds of thousands of dollars and we'll Deploy on to you or you can just go to our docs run a script run some infrastructure that we provide out of the box and you get connectivity with a whole network of chains for free um so to start with some definitions uh so we call ourselves a permissionless and modular interoperability layer um so permissionless can mean a lot of things I think it's usually a marketing term but uh to me it means that you can do something without anybody else's permission right but some people will claim that permission lists uh means that anybody can propose a hard Fork to a network which is definitely true but it's still gated on the Node operators in that Network in order to create a hard floor so the idea with with hyperlane is you literally don't need to talk to us whatsoever you can just go to our docs you can deploy it it's as easy as that that's why it's permissionless um anybody can use it and then interoperability uh it can mean a lot of things to different people that to me it just means some kind of interaction between two different blockchains um so for us we are an interface for sending bytes over the wire between two different chains I mean you can build things on top of this like token bridging but fundamentally just that communication is what interoperability is um so to set the scene why this is even important uh we can look at the history of blockchains and and where it's led us to today um so at the beginning we had Bitcoin and this is really great for payments um but it was not too great for many other things so people got excited by the idea of what you could do with blockchains uh if you look before ethereum existed people had ideas like creating something similar to ens but that required creating an entirely new chain I think it was called name chain or something along those lines and you couldn't use the same security layer for building unique applications with just Bitcoin um so then ethereum came and uh that was kind of the first fragmentation or major fragmentation where you now you had Bitcoin and I had ethereum and ethereum gave you the ability to create applications with the same infrastructure based layer but pretty quickly the limits of ethereum were hit uh there's some serious scalability issues with just having a single blockchain like ethereum that also imposes some very prescriptive trade-offs on applications that are on ethereum so ethereum wants everybody with a laptop to be able to run the entire chain but that comes at the cost of people not being able to have really high throughput on ethereum um so in 2019 around that time there was a lot of talk about things like plasma or shorting or like all these different ideas some of them eventually turned out to be what we call Roll-Ups today um but we also saw the explosion of alt l once and people were moving to these altel ones like binance smart chain like Avalanche like Solana instead of ethereum uh not necessarily because there was anything special about these blockchains but because there was cheaper block space and then new communities were created around this cheaper box base and this was the first kind of Step of scaling but as you scale in in the Paradigm that we've chosen to today you create more fragmentation so to me there are three valuable things about blockchains and it's composability verifiability and censorship resistance and as you scale and create new block space you give up composability so interoperability between all of these is extremely useful in order to preserve that composability and so during all of this things like Cosmos or ecosystems like Cosmos and polka dot Pioneer to app genes which have kind of evolved into the roll-up thesis today so specialized chains that have their own block space um that uh yeah allow for for scaling outside of just the world of ethereum and eventually today we're at Roll-Ups and there are various roll-up ecosystems there's the ethereum Rob ecosystem there's the celestial ecosystem and there are still app chains in the cosmos world I don't think Solana is going anywhere like there's still all of these ecosystems that are being built new Chains new block space um and I think it's just an unavoidable future and as these links get more complex and all these new ecosystems arise there's no good way of interacting between all of these that that is kind of one size fits all um and people are migrating to Roll-Ups um so adapts like Zora they recently launched a roll-up um cello the L1 is transitioning to be able-up um there's a lot of effort on the ethereum side toward growing the roll-up ecosystem um and there's a lot of like discourse around uh Roll-Ups that are using the same da layer so data availability layer of having better and more trustless communication with one another um but this is still like super super early stages um uh there's a lot of research going on there like it's not a one-size-fits-all situation um so we need interoperability between Roll-Ups between chains regardless of what they look like today and we can't really afford to wait for a future where uh there might be more trustless communication so in comes hyperly um and and further to set the scene uh I guess just to like explicitly say like the common path of world to rule of interoperability today um if you're on optimism and you want to go to arbitrum you pretty much need to wait seven days to go down to L1 and then you go back to arbitro and that's just unacceptable uh for the vast majority of use cases so on top of this there have been um different protocols that maybe use an external verifying Set uh to sign off on these messages between these Roll-Ups or um people who provide liquidity up front for the destination on the roll up knowing that they can wait seven days in order to get it in the future um but yeah the general idea is all these different roll-ups they look so different um you might be familiar with storage proofs which is kind of a Hot Topic in the ethereum community of facilitating better roll up to roll up communication and the way those work is a roll-up will learn about the block header of another roll up inside that block header lives uh an attestation to all of the state that lives on that well up and if you come up with this proof to find out maybe what the storage slot is at a particular place in a contract uh in that storage route and you can read the state of another roll up within this roll-up but the problem with these is it's it's so specific to the implementation details of these Roll-Ups um that it creates fragility if one roll up creates a hard Fork what happens to that bridge it's fragile um so what hyperlane does is we don't want to wait for a future where there are all these different types of message passing paradigms um that may be further along than research but look totally different and we can't have them today so how do we how do we get this today we separate the transport layer in the application layer so what does that mean it means that hyperlane is an interface that is constant for all chains but under the hood the actual security that is used for these messages can change and it can be different for different chain to chain connections depending on what is seen as what the application wants or we provide a default security model uh which might be the most trustless security between two different chains so to give an example um if I'm on ethereum L1 and I want my application to send messages to optimism to arbitrum to polygon to Solana the last thing I want to do is do the legwork of integrating with each of those the Roll-Ups their native token bridge I don't want to know the interface and the implementation details of that I don't want a massive switch case statement saying this is my destination and this is the code that I want to run uh I want to just have the exact same interface I don't want to know the implementation details of how it gets there I just want to know sure maybe the this security of that message but I don't want to know the interface into using that bridge and so what we do is we have a contract called a mailbox that lives on each chain and this mailbox is the singular interface for sending messages to other chains or receiving messages from other chains and then applications and this is where the term modular security comes in applications can opt in to what security they want to use for messages that they receive and this is super powerful um because as the new research comes out um you can kind of just change configuration and you get the new research the new products the new fancy ZK proof completely for free but today you can launch and still be equipped to use that in the future and so like concretely uh if you use hyperlane between L1 Assyria and arbitrum today like you'll be using the native token Bridge which is trustless the native Bridge which is trustless um and maybe if you were to go from ethereum to Avalanche like there isn't a great trustless interoperability solution there so you'll use a different type of security other things you can do with this um so I guess to go into the details of how it works uh on this destination side well the general idea is you call in on the origin into the mailboxes dispatch function so that's how you send a message out from a chain and it emits that message there's some off-chain infrastructure that you don't really need to worry about that listens for these messages and then uh comes up with the appropriate proofs in order to deliver these messages on the destination and the way that they deliver this is by calling a function on the mailbox called process and then that mailbox will call the recipient's handload um and there's a set that I missed there which is uh the mailbox needs to know what kind of security that recipient requires and the way that our recipient defines that is through this thing called an interchange security module and all this is is a view function on the recipient that Returns the address of some smart contracts that encoded into it has the rules of how to verify this message and this is the step five right here so you pass in two parameters into verify one is metadata and this can be anything that is specific to this interchange security module you can imagine it as like validator signatures over a message or maybe a proof verifying this message is some kind of off-chain data and then the actual message that was uh that was sent and the cool thing here is that you can actually tweak the security that you want depending on the contents of the message as well so if my application is a token bridge that I've built on top of hyperlane and somebody's sending ten dollars um do I really require them to have the most stringent security for that if that security has like a monetary cost probably not so like I I could choose for a really low value transfer to maybe require like an M of n validator signatures over this message uh but if there's a million dollars going over maybe that's where I'm willing to put a cost onto the user where they have to process a more expensive proof in order to verify that this is correct um and like I mentioned this is future proof so as new things come out you can really easily just change out the transport layer under the hood without having to make any changes to your application um so yeah this all kind of leads up to our special sauce which is permissionless deployment and so in a world which I think we're seeing uh where there are countless roll up as a service companies a bunch of new Roll-Ups being created each day new chains um whether in the cosmos ecosystem or elsewhere um there's just this explosion of of chains that's occurring in this last year like speaking to so many people here like there are a lot of new chains being created as well um and there's this problem of like when you create a new chain it's this entirely isolated ecosystem and the first question that clients develop as a service companies ask is how do I tap into uh the rest of the ecosystem and if you are let's say an ethereum L2 you get a lot of that through the native bridge but if you're a Celestial L2 because Celestia is just a data availability layer they don't have any kind of smart contracts on on the L1 um you don't really get any benefit of of that native token bridge to to bring in liquidity into your chain um so what hyperlane provides uh is just go to our docs you can do it if there's a chain that you guys want to deploy hyperlane onto during this hackathon like it's as simple as just going to like going to our docs running some scripts and then running some infrastructure um I've talked with many many teams who have asked like our competitors uh to go under their chain and yeah the answer is pay us money um and I think that's just not quite in the ethos of crypto like if you look at uniswap for example the reason why it uh it got so big and why it's to this day like still pointed to is a great example of what Defy is and can be for everything uh it's the permissionless nature of it it's the fact that I could just go to the uniswap V2 Factory call a function and create a new pool and so unlocking the long tail of assets and a long tail of chains and I think is going to be like extreme importance to this uh this industry as we'll be heavier into roll-ups and so just to talk a little bit about things that you can play with and build on top of hyperlink and so it's all fine and dandy like let's say you're a new chain uh you roll up you deploy hyperlane onto your chain and what you get out of the box is bytes over the wire but what can you do with byte server wire you can build applications on top of that and really anything that you want um but an example of that is just basic token bridging we have our own twist on token bridging called warb routes and instead of like a classic token Bridge so a token bridge when I say this it's like a lock and mint kind of thing where On the Origin side let's say I have a token I send it into some contract where it's escrowed some message is sent to the destination chain and then a new token is minted and given to me and that new token we generally call a synthetic token because it relates to the existence of a remote Chain's real canonical token I mean a classic token Bridge they usually have a security model that they impose on the entire bridge and it kind of turns into this Honeypot of like this is like a specific one size fits all security model that is being forced onto this token Bridge um whereas with warpouts it works for permissionlessly deployed chains and it allows the deployer of a warp route so the deployer of this bridge token to specify what security they want for it um so it it's kind of like a tool in order to bring tokens onto your chain into terms that you want to so we have three different classes of these so there's a native War brow and what this means is let's say you're on L1 ethereum and you have eth is the dative token um so there is a smart contract called a native warp route in which you just send your Ethan there you call a function your native eth is escrowed in there and then that's where the on chain or the message is sent to the destination chain where then a synthetic token is minted um we have the collateral version which is for an existing token that isn't the native token similar idea escrowed and then mint and these are particularly useful for chains let's say it's a roll-up um that maybe wants like a backs on its chain and so you have a bridge that is lock and structure that you get to define the security parameters for and you get to deploy yourself and so we offer uh scripts to deploy these things really easily we offer a UI that you can customize to look however you want as well and that's what that screenshot is there and it all just kind of works end to end out of the box yeah great question um so yeah Circle supports uh Native transferring between two different chains I think today it's ethereum and arbitrum or Avalanche arbitrim as well ethereum Avalanche and arbitrum so those those three um and yet this is great I think you should use this instead of War props because circle is a testing to like the validity of all of these tokens and they've like blessed these tokens on all three of these chains um and I think you'll actually see like a continuation of this for like a very popular fat head chains these kinds of tokens um will have canonical representations on those chains but for the long tail of chains uh circle is not going to support some random roll up out of the box um because they have no incentive to it so that's where hyperlane warp routes would would come to play I mean that kind of also like plays into our uh eyes being set on permissionless deployment for these long title chains um so that in that scenario um the canonical usdc token on arbitrim uh you could bridge that to like my roll-up if you wanted um and in that scenario would be the usdc would be turned into a collateral warp route on arbitrim and then it would be sent over to my roll up and then it would be minted to me as a synthetic token um so I think these things aren't mutually exclusive and like I think the trend of long tail chains having canonical representations for these kinds of centralized stable coins will will continue as well yeah exactly yeah yeah so that's it if it's not the canonical one like in in our jargon and some people use it differently um that's a synthetic token so it's like pegged to the value of of a token that exists on a roach and come on cool so a couple other things that you can build or play with that we've built for you that are really cool Primitives um of these things called entertain accounts and interchain queries so this is borrowing from uh the cosmos ecosystem where they have these same Primitives um but for context the cosmos ecosystem they have this like really robust way of communicating between chains called IDC but the implementations today are very specific to the cosmos ecosystem so it only really works for these chains that have the same kind of consensus mechanism whereas hyperlane it works anywhere in any kind of execution environment and so we can look at kind of the cool Primitives that they've played with and built already and then bring it to the rest of the ecosystem and what entertaining counts are is a smart contract wallet that lives on remote chains that is controlled by a smart contract on An Origin chain so an example of this could be like a dow for instance that lives on ethereum they can control a smart contract wallet on some remote chain they can own contracts through that they can call contracts to that they can own tokens they can own ethereum like native tokens they can do anything um and another cool thing about this uh there's this word called like counter factual addresses which are addresses that you can generate and know what that address is without actually creating it or requiring any action from from the owner um so an example of this is like if you're familiar with create two if you know the uh byte code hash and then assaults in order to deploy this contract you know that it'll exist at a particular address and then the importance here is then like the uniswap Dao if they wanted to use interchange accounts they don't need a dowel though in order to create one of these they can just know that they own this theoretical address that exists on a remote chain without any kind of action on their part um and then there's this thing called entertain queries uh which allows a smart contract on one chain to query some State on a remote chain and then get it sent back to it so I can maybe I'm on my roll up and I really want like chain link price feeds I can use interchange queries to query the current chain like price feed that lives on ethereum and then I get back a call into one of my functions without value um yeah I'll leave it here for any kind of questions uh I was thinking I could do a live demo but I don't have the time um but yeah if I were to ask you guys to have one takeaway from this it would be um that hyperlane is the only permissionless interoperability uh project and um yeah we're excited to kind of hear you guys feedback about it if you're deploying to new chains um or if you have any like cool ideas around modular security that you guys are going to play with I think they're just so many things that uh yeah I would be doing during this hackathon on hyperlane so if you have any like ideas that you want to get back on feel free to let me know um how do you take any questions vs ever oh we have a booth downstairs as well that's it yeah uh equation related to uh like bridging yeah that you've uh called warbroads basically yeah um like uh what's your take on like uh bridging data I mean not just related to tokens and uh nfcs but everything else like how do you do everything else yeah so hyperlaneous allows you to send anything over the wire so you can send if there's like kyc data on one chain or something like that you can send that to to a remote chain um you could even have applications that are natively multi-chain meaning that their state kind of exists on these two different chains or multiple different chains um kind of like a distributed system type deal and yeah I think there are just so many interesting things that you can you can do on top of that you can have uh like like multi-chain liquidity layers so you could have some kind of protocol where you have pools on different chains and when you want to go from token X on chain a to token y on chain B and you use an abstract message passing bridge to to first do that swap then send a message over to the destination to another swap things like that um so I think there are so many things that are like super super underexplored um I will say like once you add asynchrony into uh building these applications so like when you just write a normal smart contract today like you have a lock on everything that's happening on that blockchain and that means that you can interact with all these smart contracts and and know that there is synchronicity in all of these interactions you have and if it reverse that no state pages will occur once you add asynchrony in here things get a bit harder so it does require like a little bit of careful design and and what these messages do and maybe you'll want timeouts for these messages and make a fail safe but yeah there are a lot of cool things you can do with it now thank you that answers the question uh like uh do anything yeah basically I mean did a round of applause for Trevor thank you 