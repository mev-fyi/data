[Music] [Applause] [Music] very briefly body statum datum is a framework which helps developers build applications fast on different chains and on different on different protocols we support a lot of features out of the box you don't have to build your own nodes you don't have to do the rpc calls you just call one of the ready-to-use features and you are you can integrate it directly into the application you can build basically any app you can build the nfd marketplace you can build wallet you can build some d5 protocols whatever you want it's just up to you on more than 40 different blockchains what's the benefits or why should you choose to work with some framework or over the native rpcs you don't have to know blockchain you don't have to know how how rpcs work you just need to know how those common features works under common features or like ready-to-go features from us i mean mean an ft operation create wallet operation signed transaction operation something very let's say easily understandable from the developer perspective what actually like what was the development process of of of building an app inside atom you as the developer will we'll start with with playing around with the apis you obviously has an idea what you want to build you will just take a look like okay i'm going to build at 750 marketplace what i need to do that i need nft contract i need some some wallets i need some some apis but you find out okay datum gives me let's say 90 percent of these like ready-to-go features but i need like 10 percent of some custom rpc call or some custom operations you need to do on a blockchain we don't like look you inside the tools we we give you and uh like every good framework should give you freedom and the freedom means if you don't find the things you need in the framework you just go a level below that framework and the level below is of course rpc notes with the rpc note you can do whatever you want and that's basically very very very quickly these slides and now i'm going to focus on like some real live demo real life hacking i'm going to show you how the platform works what do you need to do we're going to mint nfds we're going to mean an empties on solana we're going to mean the nfts on polygon we're gonna i'm gonna show you how datum kms works what it actually is and i'm gonna show you how you can interact between datum and metamask if you wanna build some kind of defy application so let's quit this let's open postman my best friend and uh from the start this whole this whole postman collection and every example i'm gonna show today is available is available on our public github i believe you can find github.com datum io and when you search for the repositories it should be devconnect 2022 so there's visible postman collection there's present postman collection metamask page i'm going to show later today and some readme files so everything is there you can just play around by yourself so today's today's workshop is gonna let's say i'm gonna show you like three three different topics first topic the most simple one is nfts i believe you're all curious like how to work with nfds you don't know solidity you don't know rust you want to mean then if this on solana and polygonal any anything else out there and for that we have done the abstraction for you which means we have already like endpoint where you can very easily mean nft on the chain of your choice the like the interface of basically all operations we have is trying to be as abstract as as similar between different chains as possible which means most of the time would you need to chain what you need to change when you are doing cross chain application and working with polygon or ethereum or i don't know solana is just the chain parameter inside the request you choose soul we're gonna work with solana you choose eth we're gonna work with ethereum but let's start from the scratch let's start from the from the first operation in order to to let's work with an ftes or let's say you want to build an application your user has to have a wallet or address or something where he actually receives the nft or from the for the address from which he want to send some other transaction maybe solar nfds away to someone else we give you the choice very easily to just generate generate a solana wallet and the result of the operation is address and the private key i want to say out loud that don't use this endpoint in your production apps because it exposes the private key it travels through the internet which means it's compromised you shouldn't use it of course we give you other tools which you can use locally in your in your app like some client based sdk or datum kms or datum cli where you can generate those wallets or do any operations with the private key securely in your parameter so let's we've created a wallet i think that's that's uh let's use it like this for the demo purposes i don't care what we have actually done uh we have called an api call to to our ueu region and you need to pass and an api key you can obtain in our dashboard when you sign up which i forgot to show you how to actually do it so if you head to the datum.io you would get started you can create an api key here you sign up you create an account and you can create free api keys from for which you can you can build you can run you can you can play around in the list of the api keys of course you can show it copy paste use it in your app so let's get back to the let's get back to the to the postman so i have created an address i should obviously send some some solana tokens there from the from the faucet so i can perform some transactions let's use solfet when you when you create a testnet api key in our platform for solana we are using devnet because it's a chain which should be used for for developers so let's send one let's send one soul to my address and let's check if it's there or not looks like it is so i have some balance to work with right now the next step for you you create an address for a user or for your application and right now we want to mend nft for minting an ft again we have another operation which is in the nft surprise surprise and there are some couple of important fields you need to you need to enter in order to meet nft for so long this is a little bit different than for evm chains i'm going to show you later how to mean the nfts on on a polygon which is same for any evm chain but for solana you just need to specify the metadata the metadata are stored on chain with in comparison with evm chains where you are storing just the url to the to the ipfs or some other third-party metadata storage and we are gonna use the the address on which we're gonna mean the nft so the recipient is gonna be our address and the mentor could be our address as well let's use the private key of our of our created address and let's mean nft i'm gonna mean nft some random stuff with some default metadata name symbol and url of the of the image and yeah i forgot to enter the the verified creator which is myself and the result of the operation are three fields the first and the most important field is the transaction id with this transaction id you can easily check on the explorer if the transaction actually passed or not or you can read the transaction from through our api we can see that the transaction looks like path it's successful and the result of the operation is new token which is minted and when we check the token address nft address here in the response which is the same here you will actually see the new limited nfds for solana we are following the metaplex standard which is like de facto the only way how to work with nfts on solana so we are like fully compatible with any like nfd marketplaces or whatever which supports nfd's on the solar chain so great we have created nfds and we have sent it to us as the owner another step the logical one is i want to send an f3 from my address to somewhere else which again requires transfer operation in the transfer operation you again need to define from who you want to send nft what's the private key of that address who's going to be the recipient and the contract address represents the actual physical address of that specific nfd for the polygon example we're going to see small difference because obviously we are missing some kind of identifier of the token there is no token id for evm chain there are token ids because it works slightly different for solana each nft is a unique basically program on the chain which doesn't have additional identifier so let's use our sender our sender parameters like i'm going to send the nft from myself to someone else and i need to use the correct token which i want to transfer and the result operation is again the transaction id which we can verify on blockchain that the nfd has actually changed the ownership from myself it was sent to someone else very easily straightforward in three operations you can create addresses you can mint and fds you can transfer them of course there's much more to that in our api documentation you can find everything you need if you want to like reads operation read metadata or do some other things with solana and now let's do the comparison how the same nfd is minded or how dissolve is handled on a polygon which is like l2 for ethereum this this approach is valid for all evm chains ethereum cello binance margin polygon harmony and anything else we have added in our platform so again as for the solana first step for polygon is generate the wallet for evm chains we support like hd wallets out of the box so we give you the mnemonic and external public key which points to like millions of addresses under this one specific mnemonic so we need to do like two additional steps here in order to get one specific address and one specific private key if you wanna create an address from the from the wallet we have created you need to say i want to create address number zero from this wallet extend the public key bam you have address if you want to create address number i don't know 1000 you just enter address 1000 you have i think up to two more than two billion addresses available in one in one mnemonic but i think we are fine with one so let's use address number address number zero which is this one we should send already some test net assets so let's go to matic fall set and let's send here some of course of course i'm gonna use my i'm gonna use my personal test net faucet for this this could happen only on live demo right the default is empty so let's send here i don't know zero point ah this is not enough let's pick different account this one let's enter i know 0.5 matrix great thank you matic faucet for helping let's go back so in order to obtain a private key from the from the mnemonic we have created again there is operation generate private key from the mnemonic again i'm gonna say out loud don't use it on production use some safer ways i'm gonna show you which ones so from this mnemonic we are generating private key for address zero zero zero address private key it needs to match one of the biggest problem when developers are playing playing around i have used incorrect index i have used different xpath and mnemonic and it's not working blah blah blah blah blah just focus so we have a private key here the safest way how to actually validate if this private key points to the address you think it points to is just import it inside metamask and you will see that the address is correct and we have a balance safest way just double check i'm gonna keep this window open it's wonderful so we have a balance we can actually proceed to finally minting some nfts on evm chains when you wouldn't work with nft first of all you need to deploy nfd smart contract under the nfd abstraction here we are talking about erc721s we also have erc1555s available for you so semi-fungible tokens the let's say steps for working with them are basically the same as for seven to ones just the small nuances so let's create new nfd let's deploy it on matic chain with some random symbol and we are going to pay the transaction cost from our private key from our address the result is transaction id you have we have created like a very let's say useful some kind of utilities for like smooth like flow of the application which means you want to deploy an ft obviously you want to find out what's the contract address of the deployed of the deployed contract so we've created a very let's say small utility from this transaction id tell me what's the contract address and what other construct that there is here so we don't have to verify it on a polygon scan or somewhere else and for example if you are building some kind of let's say nfd heavy application when you are like real time deploying new nfts you need to do programmatically these kind of operations you must have you must have a tool for that so we have deployed a contract and right now we we finally can mean our nft the difference again between solana and and evm chains is that it 11 7 to 1 and 11 55 standards bold requires the metadata to be stored off chain somewhere else and stores only the pointer to that metadata you want to you want to attach to the nft so in order to actually meet an ft you need to have some kind of url which you want to use most of the nfts out there are using some decentralized storage systems like ipfs file coin ar view etc etc we have integrated we have integrated ipfs where you can very easily again in one api call basically store any anything you want on ipfs and you receive the ipfsc id so i'm gonna i'm gonna store some crazy build smart contract compilation information to the nft i actually don't care usually what what you are storing in the metadata is really up to any application if you are building some let's say if you're a content creator and are creating music or art or videos you are storing there are some videos if you are working on a project which where you're gonna mind those nft as a utility nft which could represent tickets to represent memberships it could represent i don't know what some fractional ownership of some piece of land why not you will obviously store the metadata something else than an image but let's just store this so this file on ipfs and the result is a ipfs identifier so in the mint operation we can actually mint nft with some metadata we are gonna use the deployed smart contract we have we have deployed as a contract address we are gonna work on matic chain this is the recipient of the nft we're going to mint this is the private key which will mean the nft so we need to use our private key we are going to send nft to us and we are gonna mint nfd number one the token id in the seven to one world should be some integer or integer really extremely huge integer 256 bits it can have if someone is interested so you can create a really a lot a lot a lot of tokens under one contract so let's mint obviously the result is the transaction id of the operation and we can check this transaction id on the on the faucet on the on the polygon scan the result of the operation is nft which was minted from zero address to me as a as a recipient with some metadata attached same as for solana we want to transfer this nfd somewhere else so we're going to use the same v3 nft slash transaction operation as we were using for transferring the the solana nft if you're gonna work with ethereum again we're gonna use the same operation that's what we call cold ones deploy on every chain so let's transfer our our nfd on the matic chain right we're gonna transfer nft token number one to new recipe end from we're going to transfer it from our address and here you go again transaction id in the meantime polygons can finally load our transaction and we can see that we have minted nft from zero address to ourselves token number one you can see that if we take a look on how actual like parameters of the operation look like you can see that we have minted token number one to this recipient and this is the metadata connected to it so everything we have entered in the operation is visible on the chain and let's check the transfer transaction transfer transaction is again very straightforward we can see that we are transferring nfd number one from ourselves to someone else and basically i don't think i have anything more to say regarding the transfer if you want to now support not not matic but you want to work on on a binance smart chain or you want to work on ethereum or you want to work on cell or you want to work on harmony this all is available basically only by changing the configuration of the request we give you not only the the right operations but if you want to build some reason of application and it should like have full set of features you you want to use you need also you also need to read you need to read which nfds are hauled by which addresses what you own what was the nft transactions how the nfd travels between the the different accounts on the chain we have these operations available for you as well we got you covered so for example if i wanna see the the balance of one specific address which nfts it owns we can just check this one and you can see like this was my address and the address owns these token ids on this specific nft contract with some metadata attached so you can see i've already play around with my metadata file i think i should have used something smaller but i think you get a point where we are you can see all the balances of a specific address the time when those nfd's appears in this endpoint varies how fast we index the data internally on the faster chains it's pretty fast we can we can scan polygon quite near to real time for slower changes like ethereum it can take like two to three minutes since the transaction appears in a blog and since we do our internal stuff there are of course more operations than just get an ft's by address everything can be found in the api dock which i think i should show how you can get there inside the resources there is a api doc link where you can see a list of all the operations we support and we are we were talking today about nft section so you can see here all the operations you can do on top of the nfd here are some ride operations here are some read operations get nft transactions by address etc etc everything you need to do in order to build something something real this is basically basically pretty much it in terms of the nft workshop and right now i want to focus on on the kms and i want to focus on the on the metamask because yes we have play around with apis we have like pretty like decent understanding how the flow should look like what operations should we do but this is actually not how you're gonna build your production application you're not gonna send private keys over the internet to us to sign something you can do it some projects do that but please don't please don't don't don't this is just for you for playing around as i said at the beginning we have other options how how you can like build the the the production application one of the option is to use our client libraries datum js it's a javascript sdk which you can download you can include it in your app on your back end or on your front end and do all these like sensitive operations locally i mean generate wallets or sunny transactions the sdk looks pretty simple when i open some some let's say unit test which actually shows you how the how the sdk looks like you are building on top of the sdk you want to work with a transaction section and you're going to mean the nfts the body of those of those calls are near are almost the same as for the api calls it's just the different wrappers on top of some on top of some some objects in the in the javascript but basically we are reusing one to one datum js format inside rest apis but you can use your private key here because obviously you will include this in your back end so if you are building some custodial applications some custodial wallet or custodial marketplace and you are already managing the private keys of your users you can like use the private keys on your site if you are not using if you are not building for not building custodial solution but you are building something something let's say more defy and you want your users to sign their own operations with metamask or with something else you actually want to know how to how to do it how to sign some transaction how to sign mint and ft operation uh with metamask no like i wanna use the same like cool features the same abstraction method same in the nft transfer nfd operations but i want to let the users to sign that i have created very very ugly example html page where we actually gonna connect this page with a meta mask we choose some some some account in the metamask and we're actually gonna mint the specific nft using metamask with the signing and then we can take a look inside the code how this all was done i need to choose a correct account for this i think it was this one yep i think it was this one so i'm gonna first of all i need to like enable metamask connect some account from the metamask and then i'm gonna internally mint nft with some specific token id with some random metadata i actually don't care what i'm gonna mean i just wanna show you how to mint it so i don't think this will work because i think i have wrong i have wrong account yeah exactly so let's dig dive into the code before that this is what needs to be changed i need to use my api key of course because i'm going to communicate with the platform i'm going to perform some post request to the api and i think there was another one here and what i'm gonna do i'm gonna basically use the same request as i was using for minting i'm just gonna replace the from private key with some placeholder value which we internally understand and we just like give you the recipe to be used inside metamask so i'm gonna use this contract address i have deployed i'm gonna mint it here to this guy with some metadata and i need to connect the correct correct account inside metamask which was the last one efdm so let's connect to metamask let's try to maintain fdes and metamask window pops up it was correctly connected you can see that i can sign some transaction let's sign it and the result is shown here again transaction id and we can check it on the polygon scan if it's actually working or not this looks like a magic internally it's very it's very simple internally what we are actually doing we are leveraging the the standard metamask interface how the metamask connects the to the blockchain application where we just work with the ethereum object in the in the javascript world and then for minting nft as i said we are using the same api call as we're using in the demo but instead of a private key we are using a signature id signature id for us means that we don't sign the transaction the private key in our api but we just prepare a transaction object which should be signed later on it could be sign inside metamask or it could be signed inside our key management system release statement ms which i'm going to talk like in next one a minute you can enter any signature id here we just mint the we just send the mean operation we receive some some response we perform reading that responds so we're actually fetching the transaction object which we want to assign inside metamask and just do some magic and send the transaction config for signing to the metamask i'm not saying it's simple i'm saying it's like 30 lines of code but this operation you are doing right now could be anything it could be minting nft it could be sending ethereum it could be transferring erc 1155 it could be some approval on top of the smart contract it could be whatever anything you want to prepare on the client could be signed with this approach with metamask so if you want to build quite quickly uh some defy app you want to use metamask you can leverage all our pre-built pieces of functionality all the features using this way and just let the metamask do the do the signing and then like last part of the workshop is going to be the completely opposite type of application and we're going to talk about the custodial application want to build and the way how to ex how to work securely with the private keys if you are building a custodial solution i've seen crazy things i've seen projects where storing private keys non-hashed in the postgres database on their application server i saw projects who were sending private keys over internet edit they don't care eventually all of them like stopped working because they got hacked or like there was some other problems connected to that but none of like if you want to build something really serious something which should survive at least first hacker attack from from some random guy you need to really understand and pay attention to working with the private keys if you don't do it properly you can be like really in a bad place or in a bad situation what's like unfortunate is that like it's not unfortunate but more and more new developers are joining victory space more and more web 2 people are trying to build something on top of the blockchain but they actually don't have any previous experience they don't know was the correct patterns they don't know the private key must be stored securely they don't know like how to do it and it was the correct flow and because of these there's so many problems and so many like failed projects or hectic projects out there in dayton we understand that and that's why we're trying to guide you using trying to guide you to use proper design patterns while building your app and actually you can't do it badly if you follow like these main ideas and the kms is basically that example so i'm really gonna start showing that because we are bad on time if you want to like datum kms is a is a key management system which means it's a small tool which runs again on your infrastructure which holds the private keys the mnemonics everything on your side and it automatically communicates with our api on the cloud like fetching some transactions which should be signed from the api signs it locally and broke out broadcasting the blockchain with this setup you basically your private keys never leaves your perimeter the private keys leaves leaves in your server secured as you secure them because the transactions are being fetched private keys are not being sent away if you want to work with the kms you need to pull the kms docker and you need and first step which you want to do is basically set up a wallet file which will like securely hold all your private keys for that there is like a bunch of cli commands you can work with the most easiest one is generate managed wallet or store managed private key if we have like external private key i have example of these calls in the readme so right now i'm gonna store my pre-generated private key for the existing polygon account i just need to point out the the correct volume on my drive and say hey datum kms i want to store managed private key for a matic on the test net chain the door can just start it will ask me for the private key which i want to store which i believe is this one it will ask me for the password which is used for encryption of doublet file for the first time just enter some password you want second time we'll have to repeat it my favorite password is one two three four five and the result of the operation is that datum kms grabs the private key stores it in the wallet file and generates signature id which actually represents that private key inside this kms instance right now my kms can start fetching transactions which are connected or sent with this signature id so let's say i want to mint new nft i want to mean then fd number 10 but instead of a private key i'm going to use signature id and tells and this inform this like body tells the api internally that hey this guy wanna store the transaction for the kms signatures later on so the result of the operation is not the transaction id on the chain because not no signatures were done no transaction was broadcasted to the chain the result is some identifier of the tr of the operation which should be signed later on you can get the details of that operation using kms get details stuff and you can see here some let's say information where the most important pieces are the chain we are working on matik the serialized transaction field is actually the transaction which will be signed inside the kms and the hashes field represent the private keys which should be used from kms to sign the payload so right now the transaction is still in let's say the spending state and once the transaction is signed there's going to be new field takes id present with a specific transaction id what we need to do from the kms perspective we need to run it in a docker mode if we wanna like start kms fetching if we want to kms to start fetching the transactions from our api we need to run it as a docker daemon using this command you are actually saying hey kms i want to start you in a daemon mode this is my api key so under this api key you should you should communicate with the api i wanna see only transactions which are connected to polygon on the net network so right now i have one transaction pending inside my inside my api key space so kms daemon will start you need to enter of course the the password to decrypt your wallet store and kms starts fetching the transactions from the from the platform i think we have a lot of transactions there under these signature ids which i don't like for any reason but i think this one is the one oh not this one let's see if this one got processed it got luckily so let's take a look what happened here under my api key i have a lot of other pending transaction which should be signed one of those pending transaction was mine and the transaction got picked up by the kms it was signed broadcasted and the transaction id was attached that kms to the kms transaction object we can right now check on the on the polygon scan like if the transaction actually passed or not and yes it looks like we have really mint token number 10 as we want it and when you take a look how we actually did it we haven't sent the private key anywhere the private key remains secret and safe inside our kms i know it was a lot but right now it's time for any questions you might have for i think we have a microphone somewhere i don't need the microphone okay okay go ahead so thank you very much for your implementation it is very very clear you use metamask but can i safely assume i could use any other kind of one-in-time just replacement for for the connection yeah for the stream the question is if i can replace the metamask with any other uh wallet like let connect whatever else yeah if the like if the principles how those like wallets are working are similar to to metamask so you are passing the transaction configuration which should be signed then yes you can use whatever it's really up to you awesome there's any more questions we can ah another one great can i implement it with nft videos oh what do you mean by that so can can you have it with anything but if i take for example have an extended video in this case would well if you mean like an ft minted video is like actually the existing nft already on the chain and you want to remind it again yes you can because like technically speaking this is just mint and ft and i don't care what i'm minting like you can mean whatever token on on with whatever metadata so it's really up to you what you want to mention if you are going to create new nft this is the operation what's actually inside that nft it's really up to you okay guys if you will have any more questions we are here like yeah go ahead thank you for the talk since you supported the vpn function do you have planned the bridging functionality into your sdk the question was again for the for the stream uh that we have a lot of vm chains integrated and if we plan to add some bridging functionality what we have available in each of our integration of every blockchain is that you can easily let's say call smart contract you can perform write operation on any smart contract available on that specific chain so if there is a bridge already which is a smart contract base which usually they are you can actually right now working with that bridge just by invoking the bridge method for example we're going to send an empty there and call something on a bridge yes from the abstraction perspective right now we like don't plan to add some custom bridges or like do abstraction for existing bridges if you want to like bridge yourself those nfts and build it by yourself you have couple of options you can create you can like integrate some existing bridge or you can like deploy your nft contract different chains and basically create your own bridge that you will like burn on one other bin on another one and basically will bridge like this with some metadata connections between those or which is even better solution you can basically send your nft to some specific address which you own and you say that this is my breach you will mean another one and like do it by yourself yes you can yeah it would be great okay guys i think we're on time so thank you all and as i said we are here to tomorrow on sunday as well to answer any questions thank you [Music] [Applause] [Music] you 