[Music] [Music] oh uh super excited to be kicking this off um a little bit about me my name is kevin jones uh you might see me running around here i'm actually the photographer for the event as well do a lot of fun stuff but i'm also a developer you can follow me pretty much uh with this qr code it'll bring up my contact and all my socials um i full-time job i work for a web 2.0 web 2.0 company called nginx you guys may have heard of it before but i'm also a developer advocate for scaffolding and that's what i'm here to talk to you guys about it's basically a toolkit for prototyping and building on ethereum quickly i also um i started a a non-profit for blockchain education i also uh teach a kind of a solidity course through a company called growic uh and yeah again i'm a photographer and filmmaker so if you want your picture tape and come find me later um pretty much uh scaffolding is an open source toolkit uh it's available on github if you do a search for google for scaffolding first thing is going to come up is the the github link um it's basically uh a collection of different tools that you're going to utilize to essentially get up and running with a development environment to build on ethereum right hard hat react some hooks pretty much all the plumbing you need to be able to quickly deploy quickly test your smart contracts and quickly kind of build in prototype applications so it's perfect for hackathons or you know basically trying to create prototypes really quickly there's been tons of other projects that have actually utilized scaffolding even uh the actual build guild which is what i'm a member of uh is using uh scaffolding as well there's also what's called speedrun ethereum which is kind of like this way to do challenges and go through and learn about how to program and how to build smart contracts and how to build dabs but there's been lots of other successful applications that are built on um scaffolding so it's definitely worth checking out eventually once you start messing around with scaffolding you'll you'll check it out you build some daps um you'll start messing around and toying around with things like solidity by example right so you might go to solidity by example and uh start kind of like pasting um you know stuff from solidity by example into your smart contract deploy those changes you can do things like define primitive data types to find variables start to learn solidity right like deep deep dive into solidity and how it works but eventually uh if you want to get deeper and you want to kind of want to test your skills you'll go to speedrun ethereum speedrun ethereum is this again it's this kind of experience that you go through and you go through these challenges so like the first one is you actually build an nft it's a simple nft example then you build a dex a decentralized staking application you bring it build a token vendor a dice game and then eventually you actually become a part of the build guild uh and the build guild is just basically like i said a collection of developers that want to build and and build on on ethereum uh so definitely check that out that's my quick show about speedrun ethereum um everything you need to know about scaffoldith is pretty much available here so if you guys scan this it'll give you the link to the github it'll give you the link to build guild the speedrun ethereum the twitter that you can follow pretty much everything is available here and uh if you guys have any questions or anything like that i'll just gonna throw my info again if anyone wants to connect with me i'll be running around happy to help you guys but anyone that's at home wants to connect on my socials please do so uh what does the architecture look like so this is kind of like a real real rough look at how it how it's set up um we scaffold heath uses yarn so the only dependency dependencies really on your on your on your machine is going to have git to be able to check out the repository yarn to orchestrate and run some commands to get up and running and to to kind of do things like deploy uh if you're not familiar with yarn it's basically like a package manager but it also has this cool scripting functionality where you can like write special yarn commands to execute commands uh from other different uh applications so it's really great for like tool kits because you can just make all these yarn commands to do everything you need and the per you know the developer like yourself don't really need to understand uh what's going on in the background you just need to know like okay yarn start is gonna spin up my react app yarn chain is gonna spin up my hard hat node yarn deploy is gonna deploy my changes so to get up and running it's super easy go to the github check out the repository right do a yarn install the yarn install is kind of like going to depend install the dependencies right everything you need to get up and running after that's done then you're going to do yarn chain to spin up your hard hat node then you're going to do a yarn start to spin up react because we use react and then do a yarn deploy to deploy your smart contract so what does that look like let's uh let's just go right into demo mode here um so i've basically gone ahead and i've already kind of checked out the repository uh so hopefully you guys can see this out there i've gone ahead checked it out and i've already also done the yarn install but in case you need to install any dependencies you'll need to make sure that you do that make sure you're using the newest version of yarn package manager there's like an old version of yarn make sure you're using the newest version of yarn package manager make sure that you have no no js installed on your machine i think it's 16 or above do the yarn install you're good to go all you got to do next is just do a yarn chain okay so yarn chain is going to essentially spin up a copy of hard hat running on localhost available and that's it you're ready to go you have a blockchain set up right so everything you do in scaffolding basically the result revolves around like kind of a couple windows open you keep the hard hat chain open and that just is always running that's kind of doing your your you know evm kind of uh simulation right and then you open up a new window go to the same directory and do a yarn start uh that's gonna spin up uh react react takes a little while to to first get up and running so that's gonna excuse me take about a minute so we'll come back to that and then what you're going to do is just open a third window and the third one is really the one you're mainly going to be utilizing to do your deploys so all you got to do is do a yarn to play so what that's going to do is it's going to take there's an existing smart contract it's kind of like a hello world smart contract that has everything you need to kind of just understand how basics of of a smart contract work so we can see that it deployed successfully after i did the deploy and we can also see that where it was deployed to we can see how much gas was used which is you useful if you're trying to like optimize for gas during your deployment and then you can also see that it published a subgraph so if you're into the graph or you're familiar with graphql apis sub graph is basically a graphql api for all of your events so you can actually use that and that's also comes with scaffolding as well it's you have to do some docker stuff but it's available for you there so during the deploy that's that's taken care of so now we have scaffolding up and running we've done the deploy um we've got our ui here so real basic kind of run through real quickly you'll see there's some tabs basically in the in the ui the first tab is where you're going to build out your app like your app so imagine it's like an app within scaffoldings which is an app right so you're going to start building there's a special directory structure i'll show you where you go there and edit that home.jsx file and that's where you can start building your app but all the other stuff for like connecting your wallet and getting up and running with scaffolding as far as as far as developing and testing is already set up so you don't have to worry about like it uses ether's js so that's already piped up it's got this burner wallet in the top right corner you'll notice so you could connect to like metamask but if you don't want to mess with metamask you can just use the burner wallets that come with scaffolding and it's just basically in-browser wallet so what happens is you get this kind of random generated mnemonic inside the browser and then you're able to start transacting right away so i can just come over here to debug contracts and i can see the functions of my smart contract so before we get into that let's open up text editor with the directory structure so i can just give you guys like a real kind of over overlook on what it looks like so this might be hard to see for you guys and i'm not sure if i can zoom it in but i can just walk you guys through it so there's a packages folder inside the packages folder there's really two places you'll be working mostly hard hat folder and in the react app folder okay react app obviously everything with the front end hard hat is everything with the back end right so inside this contracts folder inside hard hat is that hello world smart contract it's just a real basic smart contract what it does is sets the version of solidity we're going to use with the pragma we import what's called hard hat console which is so we can print out uh logs to the hard hat console if we need to see what's going on during the deploy or during a transaction and then the smart contract is called your contract and we can see that there's a set purpose event and we can see that there's a string defined like a variable named purpose and we can also see that the constructor is empty so we're not doing anything fancy during the deploy and then we just have this basic function and the function just is allowing us to change that that variable that we've set um set there so we can test it out let's just we've already deployed our changes so we can actually test that and see what that looks like so um you'll notice if i try to come over here and i say like eath mexico like that try to hit send it's going to tell me i don't have any money i don't have any funds i can't you know my accounts are at zero so all i got to do is click this little thing grab months puns from the faucet and then instantly it's going to take money basically ether from the hard hat instance put it into my browser wallet so now i can operate now i can send a transaction and we can see that i updated the purpose so what's cool about scaffolding is it's giving you your contract in this ui so you can start testing kind of your assumptions and your you know your ability to transact in the application um so we can see the contracts there we can see that it doesn't have any value we can see its address we can see that purpose but now we can kind of start touring around and changing some things so first let me minimize this and let me go back over here and actually let's let's change some things let's uh first of all let's let's just do something uh silly like set set an owner variable so we could say like [Music] address public owner equals and then we can grab our address from the browser which is this one right and then we can set that in there save that and then we can come over here and just do a redeploy now if you've made a change to your smart contract you can just do to play um if you didn't make a change to your smart contract and you want to force a new contract to be deployed you can do a yarn deploy reset and it will just give you a brand new version of the contract so you can keep doing that over and over and over again but we just made that simple change and we can see now we have a new variable we have an owner variable called address right so what could we do with that well we could like do something like a require statement right we could say like require that the message um sorry message.sender which is the global variable is equal to owner otherwise you are not the owner like this boom right and that and let's do a another deploy so what we can do now is we can open up a new incognito window right we can go to our app again which is on localhostport3000 and we can see now that we have a copy of the of the app on both ones and we have two different accounts we got the account that is the owner which is right here and then we got this kind of like uh purple blocky dude right here so i've got to grab some funds to this kind of like another um account and then i can come over here and say all right well let's let's make a change like this is so cool and hit send and just going to tell me i'm not the owner even though i have some money i want to interact with that contract i've done some kind of level of access control using that that require statement and defining the variable um that's a proper way to do access control so let's let's change that let's actually do it like this let's say let's get rid of this variable and let's do what's called inheritance instead so you can see you can kind of see what i'm doing i'm toying i'm messing around setting some variables testing to make sure that my my functions are working now i'm going to do what's called inheritance i'm going to inherit open zeppelin's copy of what's called ownable ownable is like kind of like a set way to do access control it's a it's a smart contract that was designed or created i should say by open zeppelin it's kind of like the standard de facto way that you do access control so i'm importing that then i can do your contract is ownable like this inherit from that other smart contract and then what i can do is i can require instead something like this only owner so that's a function that's a modifier it's called a modifier so i'm i'm grabbing the modifier from the ownable smart contract um and i'm inheriting the smart contract so that way i don't have to like set that um hard-coded right but if we do that let's go ahead and try to do that deploy do another deploy um okay so what's different here well if you look closely the owner does not match my burner wallet the reason why is because scaffolding uses utilizes hard hat our hard hat by default uses the very first like account of like toy ether that it has for it to deploy it's called the deployer so it's the first account so right now we have a smart contract that we have no control over so the next part that you get into as you start building around scaffold eth is you'll find this deploy con folder right and inside that deploy folder what's really important in here is you get an instance of the contract right and you don't you do the deploy here so you can do things like pass arguments like let's say you wanted to pass like a supply or a variable or something like that you could do that and pass those across in the constructor but most importantly we can do what's called a like a transfer so it's already here we can just paste it in and what we can do is grab the address again and then we can paste it in which i think this time you have to actually put it in quotes let's see if that works so um one one additional function that you get when you inherit ownable is called the transfer ownership function so all we're doing is getting a copy of the smart contract as we're deploying it and then when we do that it's called the the copy of the contract is your contract then we're calling that transfer ownership function and transferring it to this address so we can say save that and then redeploy again and let's see if that worked the deploy worked it transferred it hopefully and it did so you can see now that we deployed the smart contract with hard hat but then we took control of it with our because we have this kind of like identity right in our browser if you were deploying to like a test net or like a main net you wouldn't probably use the burner wallet you'd use like metamask or some other kind of a wallet to kind of take ownership but you get the idea so we're kind of going through and we're doing these tests um let's do some more stuff let's just let's have some fun here so we've already transferred the ownership we can do the access control but it's not a very interesting uh this isn't a very interesting smart contract like just for one person to change a purpose uh it's kind of centralized right so let's remove that and let's just let anyone call that function but what we can do instead is we can do a require statement okay so you know solidity has these these global variables one of them is message sender which is the the person that's calling the transaction but you also have message.value right so we could say that the message.value needs to equal some new variable that we're going to create called price and say not enough money otherwise if they don't send the value then we'll say not enough value okay so then we could come up here create a new variable we could do uint public price equal and then we'll do .001 ether like that so if you start start deploying and building smart contracts you'll learn that everything you do is in ether or it's in way and most of the time everything that you do in your application you have to kind of like calculate how much weigh is how much ether but you can hard code the ether here or you could hard code it as just whey we're just going to be make it easy on us and we're just going to say ether so 0.001 ether so we'll save that and let's deploy it and let's see if it works oh so we also have to make this payable as well i believe see if that works there we go so i always do that i always forget to make the function payable so we've made we've made this function now able to accept value right we've required that someone that wants to interact with this particular function they can come in here and they can change it if they want but they'll have to pay a price so this is the way that i told you about so .001 ether is equal to this much way right so if i want to come down here and i want to change it to eth mexico again you'll see that the the front end is automatically adapted and now it knows that hey we got to send the value with the actual purpose so we can say like eath mexico and we could now there's this cool thing i could just copy paste the thing because i know what it is here right like this or you could type it in .001 ether with this little green button it's kind of a cool tool and it will just do it for you so if you're just kind of thinking about ether you just boom obviously in your ui you wouldn't want the user to have to type in one zero zero zero zero right um but let's do it did it work it is if if we wanted to change it again and we didn't put enough let's say just say we let's say we set 999 and test send not enough value right so now we've created this kind of like cool functionality and what's happened well our smart contract has some value right now we're able to actually like use the smart contract as a bank we haven't created any way to withdraw the money so it's a little bit of a black hole right now because there's no withdraw function but you guys get the idea but we could do something else cool we could like say well let's um let's require the value but then let's change the value after someone submits it so we could do something like price just with one change price equal price uh times 101 divided by 100 see if that works i think that should work so basically we're going to increment it by one percent every time someone goes through and calls the function successfully so now if i come in here and say well let's change it to uh scaffold whatever scaffolding and let's call the right amount that we need paste it in there send boom so what's happened well we've got a new price we can see that it's incremented so with just one little small change we're able to completely change the behavior of the smart contract but you can see what we're doing here is we're going through and we're doing things um you know and testing out so if you're if you're getting started with scaffolding well first of all it's going to be easy to just like get all your teammates set up because you can just be like go check out this version check out this branch and you're going to be up and running right then it's really easy to kind of start testing and you know maybe one person's in charge of certain functions um and then you guys could just share your code and distribute and drop it into and to the branch as you need it so if you want to learn more i would suggest you know going through solidity by example coming through here and kind of like you know like learn how the variables work right like learn what the what the different kind of variables are local versus state versus global and actually like come over here and put them in here right and copy paste them into your smart contract and test from there another cool thing is well first of all the the the base version of scaffolding is just the start actually um after you kind of get up and running with the basic version and you're you want to kind of venture out into like doing more advanced things like you've kind of just you've started building and learn how solidity works you might want to do something like an nft right you might want to build an nft so um if you go to the the base version of scaffolding i should say the base path for the github you'll notice there's this challenges directory i talked about it earlier it's the speed run ethereum challenges all of the challenges have their own repository that you can basically build off of and like in a good example is the very first one which is the simple nft example it's basically just a uh erc 721 smart contract and it already has a lot of functionality to create nfts so let's spin that up real quick and show how easy it is so i've shut down my other instance and i've already gone ahead and checked out this version for you guys so you guys don't have to wait for the yarn install because it takes a while especially if you're on bad internet connection but let's just make sure boom everything's good um we can also so we can also do git branch just to make sure that we're in the right branch so i'm in the challenge zero simple nft branch same thing goes for just real quick let me show you real quick when if you're in the basic scaffolding directory and you go here you can do a search for all the different branches here right so like if you say nft there's a simple nft with next js there's a ticket nft there's also like uh see if we just do erc 720 1155 there's an 11 55 there so my point is if you're going to get started on a project that's going to use like a certain starting point just build off of that branch and you don't have to waste all your time like importing whatever version of open zeppelin and testing it's going to be ready to go and you can build from there that's why scaffolding is here for you right so i've already done the checkout we did the yarn install let's do the yarn chain and we'll do the yarn uh start and we'll do yarn deploy and we're going to have to give it a second but that's okay let it deploy so it's going to let us deploy even though react is not up and then now let's open up this version of the of the code and then i do want to show a couple other things so first of all let's look at the contract the contract is sorry let me close all these other ones i was obviously in there earlier so the contract's a lot different it's not just the hello world right purpose it's an erc 721 pretty much turin complete ready to go to build your smart contract off it has all the functionality to mint an item it has the you know the the functionality for the uri uh it also has some cool stuff where you can it just automatically allow you to upload metadata to in the in the ui i'll show you in a second but the whole point is it's ready to go so if you're building an nft project you would start here and then i want to show real quickly before the app comes up is the react app so inside the source directory there's the app.gsx folder which is like that main application it's called the scaffolding app right but inside of views is where you'll edit like other things like this well actually you won't go into the example ui you'll go into uh index.js i believe well this version doesn't have like a home directory so but on the other version there will be a home directory for you um i can just show it real quick yeah here so if we go to react source views home so this is where you kind of build out your app right and these are all those examples that we saw in the ui so anyways react is a whole nother beast but we're not going to go too much into that but let's see if the ui showed up and it did let's close this thing we can keep that open actually so now we'll notice that we have this year collectibles tab right so i got three minutes so what's cool is we can just grab some funds men and nft and just like that we got an nft and it's uh this cool little buffalo that austin griffith colored at home so yeah basically then i can come over here grab this address transfer it transfer come over here refresh and now i got the buffalo on the other account so you can see you automatically have this ability to create nfts mint them around move them around the metadata for all this is editable so you can like change the image you can change the uri it doesn't have to be a bison there's a bunch of different ones we can actually mint some more see what else is cool it's going to see what other cool nfts i'm going to create oh zebra cool what's next so yeah you get the idea and this is all coming from like i think a json file that's kind of in there so you can edit that and build as many kind of layers to that nft as you want to but yeah start with this branch and then you'll be good to go so that's pretty much my demo pretty much here does anyone have any questions i got enough time for like two minutes for a question that'd be cool if you had a question someone huh anyone anyone the which one ring could be oh yeah so uh everything we're doing here is localhost that's a good question so you could totally ship this to a test net um it's just a matter of changing a few variables inside of the source files so one is inside of the app.jsx file you just have to change the network to whatever network you want so it'll be like network.localhost we can actually look at it real quick so if we go to uh views let me grab the other one because this one's so we can go to uh home and then we can go to app.jsx and we can see here that we have the network localhost so we could just change that to wrinkybee if we want right and then that app is pointing at rinkaby um same thing goes for the deployment you can change it in the deploy as well so like if you come up here and we say um in the deployment i'm trying to remember where it is but it's uh inside the heart hack config so you can do it either by specifying a dash dash network flag when you deploy or you can just come in here and change this to ring to be like that and then that will deploy to ring to be uh so the yeah the brows not speedrun ethereum but the burner wallet so it's it's also a um so the question was we didn't have to use metamask why is that that's because scaffolding uses a burner wallet functionality that's also available as a separate source code uh inside of this repositories folder and it's just a burner wallet um which i think where it is that's the punk wallet i know it's in here somewhere but there yeah it's basically a burner wallet functionality that comes with scaffolding yeah so that way you don't have to use like worry about nonces or anything like that or transaction problems yeah all the dependencies are are going to automatically be deployed um but they're available in the package json you can see like what needs to be installed uh but it'll do it for you so but you just need to have github react node.js sorry node.js uh get and uh yarn and then you'll be good thank you guys good luck hacking do you need and then oh wait sorry yeah yeah but it's good i think we can go this just this side yeah here we go yeah that's good all right did i start cool all right hi everybody uh i'm jack and uh i work at of one labs we're the company that incubated the mena protocol and uh in this presentation we'll kind of talk a little bit about what mina is what makes it special and how you can get started building zk apps using snarky js so our agenda for today is you know first we'll be looking at mina then we'll take a look at zk apps and run through some simple example code and start gts and then finally we can kind of talk about where you can learn more and go and open up questions and answers so muno works quite a bit differently than other layer one blockchains you're probably familiar with let me see if i can make this a little bit bigger actually sorry this is uh not i might just all right i'm just gonna read off the screen um so uh probably the kind of easiest thing to grasp about me if straight away is just that the actually i'm sorry i'm gonna switch this really quick um i'm just gonna have it mirror my screen okay uh sorry here we go so uh mina stays 22 kilobytes whereas other blockchains increase in size the current finalized state of mina and all of the information required in order to validate that uh a fixed 22 kilobytes this is possible because we use these things called recursive zero knowledge snarks which are it's a type of zero knowledge proof where we can actually take the last state of the blockchain which is itself zero knowledge proof and we can take transactions which are also zero knowledge proofs and we can prove all of these zero knowledge proofs inside of another zero knowledge proof that's the same size as each of the constituent proofs so yeah this is made possible by our proof system called kimchi which is is really just an implementation detail from the perspective of developers but it's something we've spent a lot of time making really really good and well suited to this use case and uh it has some properties that uh are yeah just really cool so it's succinct that means that the proofs stay the same size um it's recursive that means that we can verify proofs inside of other proofs it's efficient and extensible so it can do the kind of math that you probably need to do in order to build applications things like hash functions work efficiently or i guess one hash function works particularly efficiently um yeah so the amino block chain stays 22 kilobytes but applications also work quite differently on on a blockchain like ethereum you you know are sending some sort of request basically to the ethereum nodes which store and run your code and then um you know they all have to do this at once in order to to be able to to kind of ensure that we're doing it correctly and and if you want to verify that the current state is true you take all of these signed transactions and sum up the effects of them with mina the smart contracts actually run off chain they live in the user's browser and and they're written in typescript and you can kind of think of it as the user just runs the smart contract uh or just runs the typescript code and proves that they've done it correctly and they actually send this proof to mina um this is useful for a couple of different reasons the most interesting i think is that you have privacy by default so anything that you do you're doing on your local machine it doesn't leave your local machine uh unless you deliberately send it away and so this opens the door to a whole you know bunch of different kinds of applications that i don't think people have been able to think seriously about building on on blockchains like ethereum yet um it also opens the door to decentralization because the blockchain can stay 22 kilobytes as we said or the current finalized state can stay 22 kilobytes so you can have wallets that verify the chain state themselves not in the way that like light clients work but in a sort of in a way that's as small as light clients and actually even smaller than light clients but as secure as as a full node and they also have this kind of interesting idea of interoperability because you can verify the entire mean of state in in a in a single proof if you can write a like let's say an ethereum contract that verifies this proof you can actually bridge the entire amino state to ethereum in one single like non-interactive uh uh transaction you just send the proof to this smart contract on uh ethereum if the you know proof is valid that's a smart contract checks if the proof is valid and if it is valid then the whole state is bridged over to ethereum um and so ethereum foundation and uh mina foundation have actually funded a project uh that's doing this right now nil foundation is working on a bridge and there's a demo that works on uh one of the ethereum test nets uh so that's pretty cool too the other thing that you have is uh there's no gas model [Music] because the smart contracts execute on the user's machine and the amino blockchain is only verifying proofs you can do as little or as much computation as you want and it will always cost the same amount the proof is well it will always network demand will affect the you know the price you have to pay in order to get the transaction included but no matter how much computation you do it'll cost the same amount on on the you know a given day um and so yeah this opens the door to doing you know to building applications that require dramatically more computation than uh are possible on ethereum right now and there's kind of even this idea of uh being able to do a lot of execution off chain goes kind of even further but you should actually build applications that fit a really different uh model than is possible on blockchains right now in like the the user flow is kind of different and so i'll actually talk about this at the very end um as kind of like a bonus um so yeah what is an example of this look like well if we want to prove that we have more than a thousand pesos in our bank account but we don't want to reveal the exact amount or any identifiable information about ourselves and then we want to bridge this to to a chain like ethereum you know this is something that's possible with mina that it would be all of these bullet points would be hard to do with anything that came before mena so proving that we have a thousand pesos in our bank account we're actually working on something called zk oracles right now which is a process where we prove a tls handshake inside of a zero knowledge proof so that we get the ability to basically take any information on any website and pull it on to the mena blockchain uh without having to worry about like a you know a quorum of of like oracle operators cooperating or incentivizing them or paying them or anything like that it's we rely on cryptography instead of game theory and so it's pretty much if you go to the website the website proves to you that it's who it says it is and it proves to you that nobody is tampered with the information in transit and uh then we create a zero knowledge proof of this so that this proof is non-interactive and you can just put it on chain uh so let's say yeah i wanna prove that i have more than a thousand pesos in my bank account first i can prove that i went to my bank account's website and that it said that you know it sent me this page and so this page has all my information and so we don't want to reveal that because it would you know it would make it really easy to steal our identity and so then what we can do is we can take this proof and we can prove about it that uh yeah just that our account balances is greater than a thousand pesos um and so now we've you know augmented the data so that it's still useful for what we want it for but it's not um you know going to cause problems from a privacy standpoint and then uh you know that attestation which lives on mean it can be bridged over to ethereum and so all of these properties come from just you know the fact that we're doing things a lot differently we've kind of rethought how blockchain should work in the context of you know efficient zero knowledge proofs um so zk app consists of two parts we have the smart contract itself which is written in typescript using our library snarky.js and then we also have the ui which you can also write in typescript and uh you can pretty much write your smart contract as you know uh something in one repository put it on npm and import it into your ui uh and yeah it's a very straightforward workflow so snarky.js contract yeah it's written in typescript and it eventually compiles into two things one of these is approver function which is what the users will actually run when they interact with your application this is what runs in their browser so it will do what you tell it to do but then it'll also generate a proof that it did what you told it to do correctly and then that's what will get sent to mina it'll also generate a verification key which is the thing that actually gets stored on mina and commits to the like business logic that's in your smart contract and so this verification key is a small sort of random looking number that is computed by really complicated means um but ultimately can be used to verify that any interaction you have with your smart contract is a valid interaction for for the code that you use to generate it so when we deploy a verification key uh to the mena blockchain we create something called a zk app account it's uh there's not as like well-defined of a difference between like a i don't know like a an externally owned account and a contract account as there is on um on a blockchain like ethereum uh with mina zika app account is basically an account that has one of these verification keys associated with it and it will only accept transactions if they have a valid proof associated with that verification key and so this is how you can constrain these accounts to be usable only in you know some specific way that's defined by your uh your your smart contract logic um and so you know when we when we deploy one of these accounts then we can interact with this account you know doing whatever we want to as long as we are also as long as our transaction is also accompanied by a valid zero knowledge proof um but if it's not accompanied with by a valid zero knowledge proof then the transaction just fails the blockchain won't mine it um and so yeah this is how we can constrain you know you can constrain the functionality of this account in whatever way you want by this means uh so inside of a zk app we have a bunch of methods and these are the things that users can call the methods taken so i guess yeah so we take in some sort of arguments that the user can generate we take in smart contract state so this is the state of the smart contract before our method runs and then we also take and take in you know state of the world which would be something like block height or i don't know verifiable randomness um what we spit out is uh a zero knowledge proof that proves that what we did we did correctly and also updates to the state of the world and updates to the state of our smart contract and so as long as the zero knowledge proves valid then these updates are committed um so yeah we use snarky.js to write these smart contracts snarky.js is a typescript library and we chose typescript for kind of a couple of different reasons but really the reason why is because the javascript ecosystem is really strong and we're really ecosystem focused we want to make something that people can use to build uh you know cryptographers can build some fancy cryptography library and then people who are not cryptographers can use this fancy cryptography library to build some really great idea um so yeah you can use vs code npm pretty or eslint whatever the vs code support is great the intellisense really uh yeah it makes it pretty easy to figure out snarky.js even if you don't ever look at the docs you can just kind of look at the intellisense and get started um but yeah we also have things like npm and eslint and so the idea is just that uh we have minimal developer tooling um we didn't want to reinvent the wheel we wanted to let people use the things that they're familiar with and the things that are mature um to that end the developer tooling that we do have is called the zk app cli and it's really easy to use and and really powerful despite being simple and elegant it's uh you know you can just yeah it's just a node package you can install it uh as it shows here and then if it can deploy your contracts to the amino blockchain it can scaffold these contracts so that you have um yeah like linters set up that will help you um yeah prettier and yeah it'll set up a project that uh has an ad contract by default and this is probably a good place if anybody's thinking about maybe building something just install the zk app cli look at the ad contract and see what you think of it i think it will be pretty intuitive just looking at it with no context even um so yeah moving on to snarky js uh zk apps are written in typescript using snarky.js we use existing open technologies it runs in the browser and in node.js you can use existing javascript and typescript libraries and tools excellent vs code support um yeah so okay what is uh why do we have to use snarky.js like what is a zero knowledge proof is zero knowledge proof is basically a math problem um well a zero knowledge proof system is basically a math problem and zero knowledge proof is a solution to one of these math problems and so you know this gets complicated because you have to be able to configure our math problem to represent some kind of smart contract logic that uh that yeah we want to allow people to prove that they're doing correctly and so um this is what snarky.js does it handles most of this hard work of turning a program into a math problem but at the end of the day the math problem is the thing that's used to check that people are executing code correctly and it's also um well it's a math problem so it's it's defined over uh you know it's not defined over like strings or booleans it's defined over numbers and in fact a specific kind of number called an element of a finite field it's not really important to dive into what that means if you're curious you can just google it but from a developer perspective it really works very similarly to like a uint um 256 in solidity um you have you know natural numbers from zero to a number that's almost uh you know the same as the max for unit 256. um so this element is uh so sorry this type is represented as something called field in snarky js and you can work with it directly there are some reasons why you might want to it's very efficient to work with it directly because ultimately this is what everything turns into in the math problem but you don't have to if if that seems pretty confusing we've built types on top of the field type like uh bull and uint64 and other types so that if you want to use the things you're more familiar with you can and then this will do the work of figuring out how to turn these into field elements under the hood for you the downside is that they're a little bit less efficient than working with field elements directly but you can start with something that's easy to implement and then optimize where you need functions are just normal typescript functions and data are normal typescript classes um so if we look here we have you know a function add one and double we pass in something called x which is a field and we return a field and so what we're returning is x add one multiply two um and so yeah kind of a common question is why can't we use the javascript infix operator here why can't we do you know x space plus space one uh well the reason why is because javascript doesn't know how to make sense of field elements and it certainly doesn't know how to turn them into an equation and so um this is what snarky.js does it lets you define uh addition over these field elements and it figures out how to turn this edition into something that's a part of the math problem so that it's constrained by the proof when we pass in a one here you can see so this is just a normal javascript one and it gets promoted into being a field element of value one this looks a little bit weird and in practice it actually ends up just being very elegant this kind of chaining api is something that lots of people have told us they like um and and i've also kind of grown to like it um so yeah here we've got another example we're taking a field passing in a number one it gets promoted into a field of value one and then we're adding to it a field of value three to get a field of value four so sum here will equal a field element of value four um so yeah let's look at a hello world example uh we're going to write a smart contract with a single state variable called x and it will have an update method that will let us replace x with its square and um we can only update it if we control uh a secret admin private key so this is kind of the like um the requirements for our contract and now i'll get into how you build it um so okay so yeah here's what we have we have this idea of you know x is equal to three we want to be able to call update with nine and a secret key and as long as the secret key corresponds to um uh the you know secret admin admin key and as long as nine is the square of three then we'll be able to update and then we can call you know the same thing again with 81 and we'll be able to update again because 81 is the square of nine but if we call um uh if when x is equal to nine we call update with 75. it will simply fail we won't be able to generate a valid proof because 75 is not this you know the the square of nine um so to write a snarky.js smart contract we just extend this smart contract class in snarky gs you just import it and you know extend so here we have a smart contract called hello world it's that simple um and then if we want to define state that's going to be stored on the mena blockchain we yeah we have like a variable here called x and we use this state decorator um in order to say we want to take this variable x we want to store it on the mena blockchain we want to make sure that any time it's updated it's being updated in a legal way and we also want it to have the type of field so we could change this field type to like public key or uint 64 any kind of type that's comprised of fields in order to make them easier to work with but in this case we're just using field um and so yeah this is a part of on-chain state now um the other thing that we're gonna do here is we're gonna look at this deploy method so this is sort of used as like the constructor this figures out how the contract should um be before users interact with it but at the time that it's deployed to the network uh so uh don't worry about these deploy args or these first two lines are just here so that the zk app cli can like hook in and figure out how to put it on chain it's really straightforward from a user perspective this will get scaffolded in when you zk project but then we have this dot x set to three and so this is going to take our on chain state variable here x and it's going to set it to a value of three three is going to get promoted into a field element and the on-chain state is going to be you know equal to a field element of value three and then we have this party.set value this self-update delegate admin private key don't worry too much about party either party is basically something that well okay don't worry about this very much at all what this is doing is it's basically taking a property of the zk app account and it's changing it to something different so in this case we're setting this property to the admin public key so that then we can verify that the private key corresponds to this public key and only allow people who possess the private key to interact with this smart contract and so i should also say this party and this whole deploy method is something that will default to something that makes sense you will not have to think about this in the most cases you'll just sort of not touch deploy and work work forward however you want to or you'll just use deploy to set the initial values but the idea is that this is here so that you can when you need to change things but you don't you don't have to worry about this kind of level of complexity straight away so yeah then inside of the smart contract underneath our state declarations in our deploy method we have methods that users can call and so we specify these using this method decorator and the method decorator basically says hey this is something that users are going to call and when they do call it you need to remember what you're doing and then you need to prove that you did it correctly and so this update method gets passed in a squared which is a field element and an admin which is a private key which is comprised of field elements but you can see you can work with the private key type here directly and so what we do is we have this constant x which we're going to set equal to this dot x dot you know get so we're going to get the value of x which is going to be a field element equal to 3 i think if we look at the last side yeah it's going to be equal to three um and so x is gonna be you know equal to the uh on chain state value of x um and then we're gonna assert that it's equal to x so this is kind of a confusing line what is this doing well um this assert equals it doesn't return like a true or a false it's just something that it has to be true otherwise the proof can't be generated you can't generate a valid proof unless x is equal to x um and so this seems kind of superfluous here it's just like a a best practice um but what it means is that if x doesn't equal x you can't generate a valid proof um or i guess if this dot x which is you know the x from um uh um the s state variable uh isn't equal to you know the x in this scope it does it you know you can't generate a proof and so then we take x and we you know call the square method which is built into the field type um and then we assert that it's equal to squared and squared is the thing we pass in and so if we don't pass in the square of x we just can't generate a proof and and you won't be able to send a transaction to mina and then what we do is we take x and we set it equal to squared so we set this state variable x equal to the squared value that we passed in and so again you don't have to worry about this code running unless all of these assert equals are true the code will run on the user's computer but they just won't be able to generate a proof and so if they can't generate a proof none of this stuff can be committed to to the blockchain so um yeah it's pretty straightforward in that way um so the state of the zika app is public unless it's stored as a commitment but that's pretty easy we have a hash function called poseidon which is really efficient and it uh yeah so you can just hash anything that you would want to store as private state and then pass it in and verify that the hash is is correct um in the middle of your method i mean then any arguments to a method are private unless uh they're stored as arguments you know directly and so what this means is that even though we're passing in a private key to admin it actually uh we're passing in a private key to update it actually does not matter because this private key never leaves the machine it's used to generate the zero knowledge proof and then it's not used again um so the update method in this case uh yeah calls git which fetches the state from the the mena blockchain and then we also assert that x uh let's see we assert that x oh yeah sorry um we assert that x is equal to its square and then we set that equal to the new value of exon chain um then we have sort of one more thing to do which is that we want to make sure that this uh can only be called by um the person who has the private key associated with admin um i'm sorry the yeah the person has the private key associated with admin so what we do is we can take in you know the admin public key and we uh i'm sorry we take in uh the admin private key which we pass in um oh okay i'm sorry we create a variable called admin public key and we set it equal to this result of this two public key method on admin which is the private key that we pass in so we pass in a private key we compute the public key from it and then we set it to admin public key and then we ensure we assert that this is equal to the admin public key uh property in our zika app account and if it's not equal then we can't generate a proof and we just can't interact with the smart contract so um this way only somebody who has the private key for the admin account can use this method and uh when they do they won't be revealing their private key um so when we uh run update nine with our secret key um what we're proving is that we ran some code in the updates method with some arguments and the result was so this is all we're proving we're just proving that we ran some code with some arguments and the right thing happened um the result is that we'll set x equal to nine and um what we assume we know what we're proving with the zero knowledge proof in this is that x did or in order for the zero knowledge proof to to work x has to be equal to three um admin secret key has to correspond to admin public key and then the delegate property on the account has to be equal to admin public key so yeah this is pretty much the anatomy of one of these smart contracts we have a field uh sorry we have state defined at the top we have a deploy method which sort of uh you know sets the contract up as we want and then we have methods that users can call and as a bonus really quickly uh one of the interesting things that you can do with mina that you can't do with other blockchains that i kind of hinted at earlier is you can actually take some of this execution in a totally different direction so in the case of something like a game you might want to yeah let users play a game without needing to submit a transaction to the chain every time that they make a move and pay gas fees and um you know wait for a block to be mined and so um this isn't possible on other blockchains because the smart contracts have to run synchronously or yeah so so on on mina you can actually build smart contracts that run asynchronously and this would look like uh i could you know make a move prove that i made the move correctly send it to another player they would verify that i made the move correctly prove that they made their move correctly and we would go back and forth until eventually we have one proof that represents the entire game that it was played correctly and everybody's move and then that proof could be submitted to mina at the end uh in order to settle the game and get like an nft for the winner or something so this is a you know a totally different approach uh the users wouldn't have to pay gas and they also wouldn't have to wait for for blocks um and this is just sort of one thing you can do you can do so many things so differently with mina and so if you're curious about it come talk to me after um where you can get involved is we have uh yeah build zk apps make educational content and help mentor people uh you should join the zca app developers channel on discord it's cool it's full of people who are building zk apps and we have uh backward looking grants quarterly um so if you do good stuff we might just give you money um but not until you've done good stuff um you can learn more in the yeah the zika app developer discord is the best place and the docs these are the two places to go to but we also have twitter's for mena protocol and of one labs which you should definitely follow because there's cool stuff on them and that's it no time for questions and answers but we have a booth right in the middle come talk to me if you have any questions i would love to answer them all right bye guys thanks so much to the organizer of the event this is really cool thanks for having me here this is a real pleasure i am miguel martinez solidity developer at other companies um yeah i've been involved in the development of the third iteration of the ave protocol that was released a half a year ago and this is why i'm here today for i'm going to give a great overview of the new features that the of the version 3 of the protocol as well as giving you some really cool ideas to be on top of them also i'm going to go through some of the developer resources that are available for you guys to create stunning things as soon as possible for the hackathon so yeah let's start for those that don't know what away is or how abe works this is a quick 101 about the protocol the users can come to the protocol with some crypto assets and supply them in order to earn some interest on them they can also use them as collateral to borrow crypto assets so they will take out over collateralized loans since they since these positions are called over quadralize the value of the collateral should be always higher than the value of the assets that they borrow so users need to keep and maintain their positions and if they don't do it there is a third actor in place called liquidator that has the ability to pay someone's debt and claim some of the collateral at a discounted price the interest that the suppliers are earning is based on the interest that the borrowers are paying for their loans and this the interest rate of the loans are calculated algorithmically so this is what why the protocol is called an algorithmic lending market yeah there is around 12 billion dollars of total value locked in all the net all the markets of the other protocol in the protocol we have the concept of market which is each deployment of the protocol on a specific network so the previous iteration of the aria protocol the version 2 has worse deploy on multiple networks like ethereum polygon and avalanche but the third version was deployed on some other networks like optimism arbitron harmony and also phantom there is also some other let's say peculiar markets like for example the real world assets one forward by centrifuge and also the permission of market ave arc which also is also powered by fire blocks shiva bank and securitized among others a little bit of alpha here there is more markets coming soon so you're gonna getting to know just take a look to the governance forum there is a lot of discussion there so yeah the ibm is brings groundbreaking new features on top of the foundational elements of the ib protocol like for example a tokens stable rate instant liquidity credit delegation and so on and so forth and there is three main areas of innovation capital efficiency risk and security and also decentralization so let's dig it into the capital efficiency the first one the big one is portals portals is in my opinion one of the most interesting ones in terms of ux and also multi-teen nature since it gives the the opportunity to the users to bridge assets from between chains in a simple simplest way so while the previous iterations of the protocol were deployed on multiple networks with minimum tpl the users had no way to move assets from one network to another in an easy way they had to withdraw the assets from the market of the on the origin chain and then breached these assets and finally supplied the assets again in the destination market with portals users don't have to breach their assets in their own they don't need to unwind their positions and they can bridge the eight tokens that are with a token what is called the the assets that are provided to the to the protocol they can reach the a tokens from one network to another in a seamless way without losing a penny of a dollar on interest all in one transaction so portals is not a bridge solution to be clear portal is portals is a set of contracts that are that contains all the logic needed for supplying assets in a different manner by special entities which are called ports a port is just any kind of entity that is while listed by the community by the governments as a authorized bridge that is able to move assets between chains so let's say that a user wants to breach a tokens from ethereum to orbit room this port will take the a tokens from the user on ethereum and will mean in an instant way freshly new a tokens on behalf of the user in the destination chain in this case arbitron now the port should we draw the a tokens from the origin chain bridge down the legend from ethereum to arbitron and finally backed the underlying tokens that back the a tokens that were mentioned previously in arbitrary in this way the process the protocol is completely solvent and backed at the end of the process as you can see this feature will bring a brand new wave of use cases on top of the on top of the protocol because it allows to breach assets in a seamless way and we will see for sure protocols for cross-chain borrowing or things like that yeah this is efficiency mode this allows to increase the the collateral efficiency of the protocol providing higher collateral factors to the users this is possible when the user is supplying or borrowing assets that belongs to the same group of assets also known as categories but it's a category that's that's the question a category is just a group of assets that shares the same nature or characteristics we need to categorize the assets in groups because there is a variety of assets listed in the protocol that has different characteristics nature or even price volatility so grouping the assets that have the same price correlation allows the protocol to minimize the risk as well as provide higher collateral factors to the users so in this example in this diagram you will see three categories we have this table category also one for east derivatives and also another one for btc this is just an example we could have different categories in the future and needs to be decided by the community for sure and talking about the established category here we have a usdt dye usdc in some markers there is even the the euro pairs here and in this case dye is giving 75 percent of total factor while usdc is giving eighty percent of collateral factor so that means that the user when they use dye or usbc as collateral they can take out 75 or eight uh 80 uh die out of their 100 die or usdc but if the user joins the stable concatenate emote category he can enjoy a maximized volume power and he will be able to get up to nine ninety seven percent of collateral factors so the user can borrow up to 97 die from uh using their 100 dies collateral in this case yeah so this is particularly interesting for use cases like high leverage tokenized position or even high leverage farming positions and this this also allows to have diversified a diversified risk management position since now the user can choose in which category you want to play yeah in terms of risk on security there is a bunch of new things that the governance can enact to keep the protocol all safer the first two is supply and borrow caps these two are pretty easy to understand they are limits that can be placed on individual tokens on the supply or the borrow or the borrowing side so the user can only supply or borrow up to a certain amount this is very useful for mitigating attacks like oracle manipulation or infinite minting in these cases the attacker tries to trick the system in some way supply an alert amount of collateral in order to drain the liquidity so with these caps the protocol can now limit this kind of attacks these two measures come hand by hand together with the isolation mode but the insulation mode is more interested when assets are getting listed in the protocol when an asset is listed as isolated you can only use these assets as collateral by itself you will only be able to borrow stable coins against it also the isolated asset has a debt ceiling so the user can only borrow up to a certain amount of stable coins using this isolated asset as you can see assets in isolated mode in isolation mode allows the protocol to isolate their risk and exposure to a certain asset and this is very powerful because it allows the community to list assets in a more secure way so network assets can get listed in the protocol with maybe more conservative risk parameters to start out with and basically prove themselves as a viable candidate candidate to get completely listed as collateral in the future so i can imagine assets being listed as uh in isolation mode first then going with some supply and borrow caps and at the end none of these measures are all yeah the centralization the third version of the protocol comes with more fine-grained permission in and roll system that gives more flexibility to the protocol so first we have the risk admins these are entities that are while listed by the protocol and the governance that has the ability to update the risk parameters of the listed tokens or assets of the protocol without without the needs of an unchained boat so things like collateral factors liquidation thresholds or even interest rates are the things that can be updated by this by this role these entities could be maybe contributors of the avidah like for example gauntlet which is a contributor that has been pushing risk updates regularly for a long time or even some kind of automated agent that pushes updates on the risk parameters given some metrics of the assets this is maybe the case of the chain links proof of research technology this is something that has been has been discussed in the community forum the chaining proofs of resection research technology allows to monitor and keeps track of the reserves of the asset of those assets that requires uh some level of over collateralization or things like that so things like stable coins or bridge assets so if the invariant doesn't hold if these assets are not overclocalized anymore there could be an automatic agent that keeps track of this event and updates their risks their risk parameters accordingly or even past pause the data shelf of the protocol also listing up means this is just another entity of the system that has the ability to list new assets in the protocol a part of the let's say canonical or regular way of listing new assets and also the isolation mode we could have new innovative ways of listing new assets for example we could have a permission listing or listing new assets based on a certain amount of tokens that are as taken stacked in the protocol just a way to backstop the the in case of a shortfall event for example so this would bring new interesting strategies to listening assets in the protocol yeah of course there is a bunch of more new features that came together with uh with the version 3 of the protocol there is the introduction of the permit on all the functions of all the main functions and user-facing functions of the protocol this is a way to save gas basically so the users don't need to approve before the actual action they wanna they wanna perform also the repayment with a tokens pretty useful in the case the user [Music] supply and borrow the same asset so they don't need to flash longman swap or swap with collateral and things like that this is also pretty relevant these days because it allows to mitigate the risk of having assets or being blocked in the contracts because now with the this feature of repayment with a tokens there is no need to retrieve the underlying assets of the pool from the pool we could have secondary markets around the a tokens so if some entity locks the uh underlying tokens of the that is there that the pool is holding nowadays it's not gonna be an issue anymore there is also a simplified flashlight function this comes with a 20 percent gas reduction uh pretty useful in case you want to take a floss loan of only one single asset also a another entity called flash borrowers pretty relevant for those for those protocols that are using other flash loans in a day-to-day basis and also a new a new set of smart contracts that allows uh having multiple rewards at the same time for the users so now any every team can provide incentives so the users can get more rewards using some kind of assets in the protocol and yeah let's dig it now into the resources that you have available in case you're gonna build stunning films on top of it so just a bit of context the pull contract is the main point of interaction in the abbey protocol it contains all the crucial and key functions there is some pretty simple functions like supply borrow withdraw webpay and things like that and there is also secondary functions like for example liquidate flash loan enabling e-mode enabling an asset as collateral among others so if you want to interact with the other protocol you should take a look to this contract and start talking with it basically if you are writing smart contracts i encourage you to take a look to these two npm packages the core v3 and also the other periphery v3 if you want to talk with the pull contract you should use the the core packets and if you're gonna interact with the rewards with the treasury contracts with ui adapters you should just use the periphery one there is also this qr code that links to the registry of npm packets there is a lot of interesting package packages there just take a look there is one for the abbey token also another one for the cross chain governance adapters and yeah there is also a very helpful and powerful uh package uh which is a javascript sdk so it contains a lot of control helpers that allows you to interact with the with the protocol we have the need of loading the contrast api and all that work there is also a really powerful tool which is called a sandbox with this cool you can take any production market with your b3 and create a fork of it inside of a heart not hardcore node you can also fashad all the listed assets so you can create complex positions and you can even connect the interface of the ava protocol with this environment and just try yourself how does it feel from the ui perspective so please take a look if you want to create something really quick during these days now you wanna if you are more interested in the data in the data and you wanna fetch the live data so what is currently going on in the other protocol right now you can use the this couple of contracts these are contracts that can be used as data providers they aggregate all the relevant information in this case we have the ui ui pool data provider that contains all the relevant information for the pool and also for getting to know what is the state of the user of a user position inside the pool and also the ui incentives data provider that provides all the information regarding the incentives so what's the distribution of the incentives what are their addresses the apy and things like that there is also another package that allows you to format all data so you can apply the correct decimals to each thing and i think it's also pretty uh useful and helpful and yeah there is also the if you want to take and retrieve the historical data you should use the subgraphs that are available and yet you can just fetch the user transaction history or historical rates or even the balances of a user of or of the pool at a specific block blockade and yeah that's pretty much all guys these are the prices for the hackathon please be creative there is a ton of things that you can create i already give i gave some ideas of cool things that you can create like for example high leverage positions diversified risk management also automated agents for listing new assets or for updating updating risk parameters also protocols for cross chain borrowing for sure so let's make your imagination fly a part of the things that you can build on top of b3 there is always a lot of things that you can create for example on the government side or just as an integrator in the governance side there is a real need of tools applications and even dashboards not only to enhance the governance process but also to uh increase the participation of the governance which is also always a really good theme for the protocol and of course there is a lot of room for to innovate in the case you are an integrator because you can create a fixed term lending a fixed term lending protocol or also under collateralized lending protocol or everything that came to your mind in terms of in terms of supplying or borrowing crypto assets if these ideas are not enough you can take a look to these pages there is a call for hackers here also there is some interesting brokers for proposal on the ave grants dow side and for sure the developer docs are pretty helpful for all of this and that's pretty much all guys it's a real pleasure thanks for coming and if you have any question or do you want to talk with us what's going on in the crypt ecosystem what's going on on the other companies or the other protocol just reach out i will be around next to the lens booth and the abbey both thanks a lot [Applause] so we'll be super inclusive here it's over there okay okay so yeah so uh i'm david i'm a product manager at alain a lens contract developer on lens protocol and we're going to give a quick overview of of how lens works um as well as kind of a bit about how we think about apps that are built on top of lens uh so alan you can start us off yeah okay um [Music] yeah so as soon as alan was saying uh some of the problems with existing social media is fundamentally you don't own your data your data is owned by the applications which you use facebook twitter we all know their names and lens kind of offers something different lens is a decentralized social graph protocol that developers can use to build social experiences you can build apps and tools on top of composable and decentralized social graph this allows you to focus on the user experience instead of user acquisition the user of one's lens app is also the user of another fundamentally all the data belongs to the user and they choose how to share it the lens protocol additionally empowers creators you can post from a singular front end and it will go to your audience regardless of what app they are using they own the links between themselves and their community and it forms a fully composable social graph so how do we do this the lens social graph is built on nfts uh standard erc 721 it all centered around the profile nft this is your profile it has your profile image your name all kinds of different metadata you can define as well as all of your posts and publications when you post you're posting to this profile people can follow you so if i wanted to go follow alan on lens i would call follow on his profile nft and a follow nft will be issued so again following is directly on chain and lastly there's posts comments and mirrors the ways you actually post to the graph these are not nfts they actually live inside of your profile but you can add logic to monetize them and turn them into an nft so instead of just tweeting randomly i can make a publication and i can sell or of a photo and i can sell that five times 10 times for 5matic 5e you pick the price and um [Music] [Music] um hws on chain of chain public prior depending on the case so as alan was saying when you when you post your profile there's three different types of publications there is the simple post the comment and the mirror the post itself is uh just content this can be of any content type text image video anything the comment has content as well but it also has a reference to another publication um again the content can be anything um and lastly there's the mirror the mirror is simply a reference a mirror is a repost uh similar to like a retweet the key thing about lens is lens is fully agnostic to where the data is stored so all we ask all that is asked for in the contract is the content url or the link so you can decide to say hey the content lives on ipfs or the content lives on ar weave or the content lives over on amazon s3 fundamentally we've left that open to you as the developer to un to decide and it is fully flexible to whatever use case you have additionally for smart contract developers there's ways to extend lens with modules um there are three different hooks where lens call will call out to an external module the first is the follow module so the follow module is executed when somebody tries to follow the profile so if alan were to try to follow me all of the data about how he's trying to follow gets forwarded to another contract and that can be any logic for example i can say alan in order for you to follow me you have to pay me 5matic or you have to hold a board ape or you have to already be following lens protocol the logic is fully configurable for you as the developer posts and comments have two other types of modules a reference module this determines whether or not something can be referenced um and that'll that call that's called on comments and on mirrors so an example of that is only my followers are allowed to comment on my posts or re or mirror them i could also say that only people who hold more than five fwb tokens are able to comment on my post or mirror them and they allow you to restrict access to certain communities and the last type of module is the collect module this is how you monetize publications and again it is fully configurable to how the developer wants so if i were to post a really great image or hear my time in mexico city i can say hey this i want to create an nft out of this i'm issuing 10 of them and they are five matic each i could also say you can only these are 10 of them one matic each but you can also only collect it if you follow me already again all of the logic is fully configurable this is a really awesome place if you're a smart contract developer extended el primero [Music] [Music] reference mode is [Music] so in addition to the lens contracts we also have the the lens api which is a an api service that ave companies is currently offering and there's part of the benefits we recommend using it for hackathons because it allows you to build lens apps really really quickly uh there's no need to worry about indexing querying data dealing with blockchain reorgs speed of fetching the data you don't have to worry about pre-filling contract data it exposes a web 2 style interface for you to interact directly with the protocol if you know how to use graphql you're going to feel right at home with the lens api additionally we have a gasless api that allows applications to pay for gas on behalf of their users and in addition today we turned on a signature free api that allows users who opt in to allow apps to sign on their behalf allowing for one-click access incredibly smooth experiences definitely recommend you try them out on some of the app lens apps out today additionally the lens api integrates more protocols than just lens currently it allows you to pull data from ens proof of humanity po-op civil.org and today we also added worldcoin's world id verification it allows developers to add data from all of these protocols to make holistic experiences support for more protocols is coming so if you're a protocol and want to work with the lens api please come by the booth and chat we want to make sure we can get everything that causes great experiences to be linked in there so one thing we think about is that lens allows for the building of this thing we call the experience layer all these amazing front ends that integrate multiple different protocols to create holistic experiences and we've seen this a bit today so for example ave you can access the ave protocol through a variety of different experiences app.com zapper rainbow instadap or even the coinbase dot browser and for lens we're seeing the same come about there's lens friends leinster iris favor lens tube these are all different experiences built with lens and other protocols and each is a unique experience and it's something that we really hope to see when people build front ends with lens this is kind of how we think apps are structured when we when we build lens apps there's the blockchain the bass that you're built on um lens is on polygon but there's a ton of other applications over on mainnet ethereum or gnosis chain avalanche optimism you we all know the various chains there's applications that live on top there's lens on all of its modules there's live pier co-op proof of humanity ens all of d5 like avi and urine there's this middleware layer that helps developers build apps the graph by economy as well as the lens api and lens js and other open source package to help people build lens applications and then there's the experience layer the actual place where you go to experience the application where your users are so that is things like lenster xyz lens friends lens tube each of those providing entirely different experiences made by combining applications beneath them potentially across different chains and so you know we think lens apps use a slightly different structure than most normal ones the [Music] [Music] yes we have time for questions um so if people have any questions you can raise your hand we'll we'll try to answer as many as we can um in addition after this talk will be at our booth and also in the back if people have more technical questions we're happy to go into into in depth um in both english and in spanish oh so at the beginning you you told that uh every profile is an nft right and every follow uh it's an nft too so as nft is standard 721 and it's and it's tradable so imagine i can sell my profile is that correct and what about the cycle about that so like if you sell your profile yeah you are selling all your followers to which i mean like because they follow nft points to a profile so you you are i am selling all my profiles so i am selling to another guy or another woman um what i am and what i built through the my behaviors through my social behavior so what about that yeah it's it's the same as if you were to sell like your twitter account today they have access to it's you know you're selling your posts your reputation it's just another asset and do you think that is good why not i think there's reasons why you would want to transfer maybe i want to move from a ledger to a multi-sig or if i'm a company i want to move it around between different accounts i think there's many reasons why you would want transfer and why you would want a marketplace i don't want to pass judgment on what developers want to build like a profile can represent many other things than just a you know just just just uh my identity could represent like a community or a group and in which case you want that to be transferable yeah yeah and and i just wanted to know if but you already answered it uh if there was uh like some security uh uh locks or something like that preventing that but i i think that there is not right no i i think we we as as you own your profile that allows you to sell it too so it's like it's up to you and i don't know i don't see any like a special issue with that but we can just discuss but we are not talking like selling a car or selling a computer we are talking like selling our profile that's all i think thank you thank you i i would highlight that lens has a lot of different ways for you to keep your profile and your nfts in a secure wallet while still letting you post and have access from a hot wallet so the dispatcher functionality as well as meta transaction you can read a lot about this in our documentation at docs.lens.xyz allow you to give access to your to your account without allowing it to be transferred around so there is security measures in place but fundamentally just like in d5 you control your assets with lens you control your content you control your reputation you control your profile and hello yeah okay my name is felipe um i have a question about identity on verified identity how do you handle fake accounts considering brands are gonna start creating profiles and also celebrities about it how do you handle someone is not gonna try to fake someone else so part of it is you know lens is meant to be an unopinionated agnostic bass layer that who is real who is fake who is spam is not those are application level decisions and we defer to each application to make their own determination that is part of why in the lens api we provide information that may be useful maybe we can tell you that this profile has been verified by world id or this other profile has been verified with proof of humanity and you can use that as a verification system alternatively you can use your own part of lens being agnostic means we put the hand we put the control in you the developer to determine what you want to show in the experience and the lens api is going to give you helper data but we think it's important that the decision is with the developer with the front end to make their own decisions i would i would personally love to see social verification tools built on these heraton so feel free to do that hello i have a question regarding the how do you manage like this algorithm to choose which content you uh show to which one so i i would like to to know more about that yeah so lens itself has no concept of of algorithms or of how to display them lens all it is is a a way of a way of having social relationships and content represented on the blockchain um applications decide how they want to present data they can use their own app they can use whatever their uh their own algorithm is to determine what to show to what users that is for each application determined when we say that it is the experience layer and you're competing with the best ux that includes having the best algorithms having the best filtering and the best recommendations that's really what the different applications compete on the api will provide certain basic functions like you can call for a timeline or you can call for recommendations and those algorithms uh have been documented and they're in the docs i believe the timeline is just reverse chronological order based on people you follow um it's very basic we encourage you another great thing to build during this hackathon would be an api that does a more sophisticated timeline query um so again lens is a protocol on the base layer doesn't even know what a timeline is that is for you as like an application to implement thank you hello yeah very quick uh when or how is one going to be able to claim their own handle soon tm uh no uh so ev everyone if you staked eth to have your ticket here at uh for eth mexico you've now been whitelisted so you can go to claim.lens.xyz with that wallet um if you're having any issues yeah awesome thanks um additionally if you stop by the booth and and you gotta get a po-op or get a pull-up from one of the team members you'll be whitelisted shortly we intend to go full permissionless as soon as we can the team is working very hard on it when alan is not giving speeches that's like his number one smart contract task so we're hoping very soon hello uh i'm considering to create a vr application that works on rinse protocol so like sms application on the vr but i'm wondering how we can access the data actually uh when i see several implementation right now they are calling uh api.lans.dev so is the data available on via smart contract or we need to use a rest api for that no no you can use the api or you can build your own index or if if you want so basically data is not available via smart contracts but it's available via rest api so it's it's it's in the the data of it like you know fundamentally when you think about what a lens publication is you're you're it's a transaction on chain that just says in this place of state you know this index this is what a publication is and it has a content uri so there needs to be some software that will run through all of the various transactions and and kind of assemble the relational structure we offer an api there's also the graph there is lens js there's a bunch of different solutions alternatively you can run your own indexer the data is available on chain you just have to know how to query it properly is it on polygon chain or polygon okay yeah yeah basically the smart contacts are not good for complex query so it's good for random access but it's just that so the contacts are like emitting events of every like meaningful operation and then you can build your own in indexer to index those elements and reconstruct the data which is basically what our api is is doing so it's like you're providing something similar to the graph is doing as well right yeah okay thank you [Applause] [Music] it's uh very nice to be here as always heath global did an amazing job with this venue and thing so props to them um but yeah we will be talking through superfluid today so i'm my name's sam i help lead developer experience at superfluid and i'm going to show you how a superfluid works and how you can use it to build money streaming applications so what is superfluid well superfluid is a protocol which enables something we like to call real-time finance so real-time finance enables you to amongst other things stream money with no capital in a way that's 100 programmable and unchained alright so what does this mean well money streaming is this idea of taking any recurring transaction and instead of setting it in discrete lump sum intervals i can define a what's called a flow rate and send you a certain amount of tokens per second and that money just trickles to your account in real time right so it's a really really cool opportunity to bring recurring payments into web 3 natively and what it does is it creates this really cool link between the value you provide and the value you get in return for that right so if i'm an employee and i go into my job and i clock in at work right in a lot of cases what i'm doing is i am working and then i'm waiting two weeks to a month to actually get my paycheck what if i could clock in and every single second that i'm providing value i got value in exchange via something like a money stream right and what this kind of thing does is it enables you to send money with no delays there's no unpayment risk right for every second you work you get paid and there's also no intermediaries because this is all done on chain and we live in a world with with at least less intermediaries here in web3 so the protocol is it's not a layer one right it's not anything like that it's not a rollup this is a smart contract framework that is uh made for the evm although eventually it will be probably chain agnostic and environment agnostic um and what it does it allows you to create these open-ended agreements between two accounts right so what you do when you create a money stream is you engage in a kind of agreement right so i can opt to send you uh one token per second right and as soon as i've done that i've sent an on-chain transaction which says that now my balance is going to be decremented by one token per second and yours is going to go up by one token per second right so this is really cool for a lot of reasons but what's really interesting about it is that these tokens that enable this right can have really interesting ways that their balances can be changed in accordance with those agreements right so we in order to actually make this happen right this is pretty innovative like in order for you to actually send money on a per second basis normally a lot of you are probably thinking all right am i gonna have to call it's something calling transfer every single second to make this happen and that's not the case right we built this additional token type which is plugged directly into superfluid protocol and is compatible with many of the other features you used to with tokens right so we inherit all of the standard erc20 methods and you can use them anywhere in web3 right so we have we have two types one type of super token is one that's just deployed out of the box as a super token right so this this is one that you know maybe you deploy it tomorrow and you know the super super tuning is you know sorry a super token exists um so you don't want to deploy a wrapper around an existing token um we also have wrappers right because we know that composability is so important so you can wrap die you can wrap eth you can wrap usdc as a super token and be able to use it anywhere else in web3 so these agreements that i mentioned right these are these connections between two accounts and what they do is they allow you to calculate something called a real-time balance on that super token so on the super token itself what you can get is based on like how many money streams you have outgoing at this given point in time we can calculate what your net flow rate is right so use the example earlier where i am sending out one token per second and someone else in the audience is receiving one token per second we can calculate your net flow as whatever that is when you combine all the different money streams you're sending receiving at once right so if we have that right we also have the block.timestamp value which is changing for us every single new block so what we can do is anytime you want to create a new money stream or do something else with your super tokens we just calculate all right how many tokens you have in this moment before we perform that next state changing operation and everything shakes out properly given the accounting that happens in the token if you have any questions about how that works specifically i'll be standing right over there after the talk we can get into the details but the thing you need to understand is we're kind of we're doing this by hacking the block.timestamp value to move money effectively for us right it's pretty cool the other cool thing about this is that because it's a smart contract framework there are a lot of things we built into it to make it programmable right so you can provide like an access control layer so there's something that's very similar to erc20 approve methods so i can grant you the ability to open streams on my behalf and we also have these things called super apps which you see here down in the middle that are these cashflower smart contracts that can react to specific events so if i send a stream into a contract it can react and then do something for me right one example we'll go through later on we'll actually get into some code will be one that can take in a stream and the second that it starts receiving those tokens can redirect those tokens to whoever the owner of that contract is so these superfluid apps are again very important in terms of uh painting the picture of the potential of what superfluid can offer right you can put anything you want inside those callbacks not just like open a stream for me you can do anything else and what this does is it allows you to chain all of these different operations together and form a crazy network of cash flows right so this is super fluid right now as it's deployed on polygon with each individual node representing an account and all the connections between nodes representing cash flows right so all of the the teams that are building products on top of superfluid are participating in this giant network of cash flows i'm actually impressed that it rendered properly because this is a lot of information but it's really cool and what you can do if you build on superfluid this weekend is build an application that plugs into this giant network of cash flows right so you can grow this network and you can also tap into it right in terms of your user base so with that being said let's talk through prizes at east mexico and then we'll get into some actual tactical building stuff right so again if you want to go take advantage of the network i just showed you there are some opportunities here we have 10k worth of prizes in usd one for the best overall project one around d5 and then some other general prizes here as well if you have any questions on them please feel free to uh come on booth and we can and we can uh clarify them for you um and yeah so in terms of building on us there's a couple of things you want to know about one of those things would be our developer console we'll use this in a little bit um to just see the effect of creating money streams and deploying cash flow where smart contracts we also have a dashboard that's really cool if you come up to our booth you'll see we have this huge tv monitor that will show the balance taking up in real time so if you want to see how that works right and even get a stream yourself you can come up to our booth and we can show you and we also have an sdk that i'll make use of here in a demo in just a second but this is really useful because it allows you to interact with the protocol without using any solidity at all right as long as you know typescript or javascript and most of you devs here you probably have at least dabbled in it if you're here um you can open streams just a few lines of code using that sdk so let's build what i'll do here is i'll share my screen in just a second but i want to give an overview of one of the applications i want to walk through briefly to give you an idea of how simple this can be to create smart contracts that interact with our protocol so we're going to create this thing called a money router right so it's going to allow you to manually send a money stream into a contract and then manually call a function on the contract to send a stream out of that contract to an address you choose right this is it's going to look a little bit like this right one of those super apps i showed you earlier which can take streams and automatically send them out it's just going to be a little bit less fun because it's not going to be automatic i'll show you in a little bit an example of a contract that can automatically the second it takes in a money stream send it out but we'll get into some of the more advanced class stuff in just a second so you can find all of these examples if you want inside of our repository here to make sure you guys can see this but instead of our repo we have a super examples folder and what you can do is you can actually just plug in and fork some of these things this weekend if you want to build a superfluid related project all of these we try to make them so they have really really good documentation good comments if you have any questions about them we'll be here but the the example we'll be using first is just this money streaming intro example so you're welcome to come back here you can fork this repo if you want and uh and follow along if you'd like or just try it later but if i pull it up here i'll go to the contract itself and make sure you guys can see it zoom in just a little bit to me just a little bit more we have some boilerplate here up top right where i'm importing a bunch of contracts um and what i'm doing is i'm using this library called the cfav1 library to allow me to open a stream and solidity in one to three lines of code a piece right so it's fairly simple so once i have this all set up in the in the constructor right i have some state variables that i declare up here but in the constructor what i'm doing is i just deploy or i guess i instantiate this this library here and from there we can actually get into this contract and use it to start opening up streams so there are a few key functions we'll use there's some access control stuff here up top that i won't really go into today but the key functions that matter here are one sending a lump sum into a contract you might want to just send like a lump amount of a token into the contract so we have a function that's going to let you do that on the contract itself we have a function that's going to let you create a flow into the contract and then we have another function that's going to update that flow into the contract or delete that flow to the contract and now that we have streams going into the contract we need to also send streams from the contract right so i have the same exact three functions but coming from the contract so what i'll do is i'll fill in some of these functions just to give you an idea of the simplicity here inside the let's go to the create flow into contract example inside this all i have to do is call cfav1.createflowby operator and pass in the sender the receiver the token meaning the super token i want to use and the flow rate right so very simple literally one line of code and i can create a stream into the contract in terms of creating a stream out of the contract right it looks almost exactly the same but there's no buy operator thing here right and the reason why we have to use this buy operator bit in the create flow into contract function is that once i create a stream into the contract like if i were to pass in uh like the message.sender being like the contract itself that's not going to work because even though i'm calling this contract i'm calling this function on the contract the actual message that sender on that function call is going to be the contract itself right so this is just tracing the value of message.sender within your individual calls but here what we can do before we actually make this call is use our acl features which allow us to provide access to a different account to open a stream on my behalf right so this is just like an erc20 approve where i can allow somebody else to create a stream for me right it's fairly simple and we'll go through a script that shows you how to do that as well okay so we have that function i'm just going to copy this over to the update example and it'll be almost the same exact thing except i'm just going to change it from create to update so that's pretty pretty simple there and i will do the same thing for this example right so instead of just create i'm going to change this to update and it's pretty simple i just have to make sure that the flow actually exists right if i try to update a float doesn't exist that'd be kind of nonsensical and it's going to revert but if i update the flow with a new flow rate itself it'll work okay so i'm going to leave it there for now there's going to be some functions here we're not going to implement just for the sake of time i don't want to be too redundant for you guys but what i'll do is i'll just deploy this contract using our little deploy script here we'll do this live which is always fun because it means i might have to debug live but hopefully not so this is deploying and while this deploys i want to show you a couple of other useful tools right so i mentioned this thing called the superfluid console this allows you to just search an address and see everything that's going on with that address so if i copy and paste in an address that i'm going to use quite often here which is just this one it'll pop up on every network it's being used on and i can track everything that's happening with it right so i can see all of the dive that's flowing on test net this is all fake money guys don't worry this is this is fake um but you can see all the money streams that i've created you can see the tokens that i hold right it's a really really useful tool so if you're building something on superfluid this weekend i highly recommend you check it out we also have dark mode we know everybody likes dark mode so that's another plus but if i go back into the s code here looks like we had a little compilation fill bit here see i told you we got a debug live this is what we love let's go back in here yeah i think i just forgot to save let's redo that so as soon as this deploys we'll be able to create a stream into this contract itself same thing here let's figure this one out new flow right there we go see we make mistakes too guys all right so i have this this is deploying for us uh all right we have another one which is always also fun looks like i did the same thing here just for the other the other example all right same thing let's pass in new flow rate and running a little bit ahead of schedule on time so we should be okay there we go all right so this is compiled and then the second this deploys what we'll be able to do is send funds into the contract itself and then open a stream from that contract to a different address okay this is just loading for me alrighty gotta love alchemy with the rpc all right i do have a backup example here which is something i'm glad i prepped but the goal here will be as soon as this is deployed all right it looks like it did just deploy as soon as this is deployed we'll be able to create a flow into this contract and then ultimately create a flow out of the contract right so first i'm going to approve a token send into the contract okay so we'll go here into this token approval function send this transaction here so instead of deploy i'm just going to approve this token approval just like that so i've just passed in this address of the contract and then here what i'm doing for the approval i'm just is i'm just calling approve on the diax contract so this is just going to approve this diax token right that's just which is successful this is going to give the approval on the dax token such that i can then send money using this function call here so do the same thing where i'm just going to pass in the contract address to this one so we'll send a lump sum into the contract alrighty and then i can run this script here okay paste that so now we're going to send somebody into the contract and in just a second we'll be able to see this money also inside of the console right so as soon as it receives funds i'll be able to search it just like i was able to search this address and we'll be able to see that this now has some super fake die tokens okay so let's make sure that approved all right we just successfully sent funds to the money writer contract and uh that's not what we want to do we want to paste in the address of this contract okay so i'll paste this in cut this off and in just a second this should show up for me but now that we've done that what we can do is now create a stream into the contract as soon as we use this acl approval bit so remember this acl feature allows me to approve someone else to open a stream on my behalf okay so in this case i'm just going to approve the money router contract itself to open a stream on my behalf okay so i'm going to create a flow into the contract using this script i'll paste it in just right here as the address and then what we do is we use the superfluid sdk i guess we got to go into the acl feature first so what we'll do is we'll use the superfluid sdk to approve the money router contract to spend some tokens for us right so this is just called update out update flow operator permissions we pass in the address of the money router we specify the super token we want to use and then we give it a flow rate allowance right so this is just the amount of tokens we can create in terms of flows sending out per month all right so this is what this amount correlates to this looks like a very big number when in reality it's just the number of way we're going to send per second okay and this permissions value will just grant all permissions right there's a there's like a bit map value here you can look up in our docs if you give it a one it's just gonna give you the create permissions in the case of a seven you get all the permissions right so you can do anything you want all right so let's load this again so it can show up when when we're back here but let's call this acl feature grant that access and then create the stream from the contract or into the contract from us okay so let's call this function here using this script all right so we'll run this acl approval this is just going to offer our approval and then the second we're done with this we're just going to call the create flow into contract function on the contract itself and then because the only two values it takes if i start to create flow into contract it's just going to take a token at a flow rate and then it's going to handle the rest for me in here i can just pass the token i want to use the flow rate and i'm good to go i'll be streaming money alrighty so this is all set up properly and then i'll run this one so the second this loads we'll be able to see money take tricking tick uh being sent in real time into the contract all right so this is the contract itself see there we go it's popped up on gwerly we can see it has a balance of 500 tokens right so we've been able to send that lump sum amount so it's sitting on 500 tokens and then the moment this one actually finishes we'll be able to see that money being sent in real time okay just a second here other features here that might be relevant in terms of checking out like protocol level stuff or the subgraph right so what you can do is write custom subgraph queries inline which is pretty awesome we use this quite often for just like looking up internal data ourselves when playing around the subgraph people ask us like how they can get specific types of data within their applications and usually the best place to go for this is this subgraph explorer console right you can just use this to pretty easily just salute different data you want to get look up specific things you can use events so i highly recommend using this as a as a place to get data within your applications all right so it looks like this transaction is hanging for me which is no fun but in the end the goal of what we're trying to do here and this is what will happen as soon as we have this propagate is to get something that looks a lot like this right so this is an example i prep beforehand just in case we had transactions not processed fast enough for us on stage and what we can see here is we originally had a balance of 500 but then we sent streams from the contract or send streams into the contract i'm sorry and when we did that we created a flow that is going to send the equivalent of 33 tokens per day or about a thousand tokens per month and we have about six tokens that have been streamed from the time that i opened this uh to right now so money is flowing real time in this example and this is the end result of what this function will do is as soon as it uh it actually goes through okay so that's the like the manual example right that's manually sending a stream into the contract and if we wanted to we could just call the create flow from contract function to send streams from the contract in a manual way right this is something you guys can all do very easily but what we also want to show you how to do is create these programmable applications where you can do things automatically right like let's say that i want to send a stream into a contract and have it automatically the second it gets funds send a stream out of the contract right and where this becomes really interesting i'll go back to my slides here is in the case of like tokenized cash flows or revenue-based financing right so there's a contract that we use for the base of a lot of our examples called the tradable cash flow that can receive streams and send them out but the other cool thing is that it's also an nft right so you can imagine let's say i'm a business let's say i'm a subscription-based business and i have one of you in the audience paying me for a sas subscription what happens in the web 2 world is a lot of people that run sas businesses will raise new rounds of financing all based on existing revenue right it's just revenue based financing right instead of having to loot themselves and sell a portion of their company to raise more money what they'll do is they'll say okay financial markets i'm having somebody pay me 1 000 a month for my sas subscription instead of me taking this money and waiting to get an additional thousand dollars every single month why don't you pay me eleven thousand dollars now and i'll redirect the entire subscription value to you so you make twelve thousand dollars throughout the year and gain a one thousand dollar profit right that's a simplified example and there's obviously gonna be other things that underwrite that that transaction but what if we could bring that exact same model into web3 and that's what the tradable cash flow does right it lets us tokenize these cash flows and plugs them directly into defy so again sending streams into the contract the streams are automatically routed to the owner of the contract and each time the contract is traded all of those cash flows go to the new owner right so you guys could do really creative things with this where maybe you split a small portion off as a fee to somebody else or add additional crazy features into it as well but i'll show you how we actually can can build this in just a few minutes so again back in this super examples folder if you go to the tradable cash flow example you can fork this yourself and start playing around but this one is pretty simple to set up and i won't go as in detail as i did with the the last contract because transactions seem to be taking a little while to actually go through but what i'll do is i'll walk you through the key functions on it so you guys can go in and take a look yourself so if we go to the tradable cash flow contract here we can see that it's really really simple right all it's doing is it's deploying an nft right so this this contract is inheriting from an nft contract and it's inheriting from this redirect all contract too which this redirect contract has all the cool functionality in it and i'll go through that in just a second but it deploys nft here with a name and a symbol and mints one of them to the owner of this of this contract right that's it really simple the nft stuff is all the stuff you guys are used to but the new stuff is on this redirect all contract so the only interesting thing we have here on the nft contract is we use this before token transfer hook this is a hook you can use you can actually see in the open zeppelin interface for the erc721 standard but you guys can just call this change receiver function inside of the before token transfer bit to make sure that before the token itself is actually transferred if it's ever sent that all the streams are deleted to the existing owner and sent to the new owner so if we go into the redirect all contract which is again where all the cool logic takes place we're doing all the super fluid stuff here up top we're importing all this boilerplate we've got some events we declare you guys can use we're using the cfa library to make it really simple to open streams we add some stuff in the constructor we also initialized the library here just like i showed in the last example but then what we do is we do something called the registering the app with the superfluid protocol right so what this register app bit does is it will allow the superfluid host contract which is like the brain of the superfluid protocol to call these specific functions each time a like one of these operations takes place so all you have to do is deploy this contract and send a stream into it and one of these functions one of these callbacks will run for you instantly so it's called the after in the case of a stream being created in the contract it's called the after agreement created contract function and this logic inside of here will run automatically for you right so it's it's being called by the superfluid protocol and inside of this you can do whatever you want so in the case of the update outflow function let's go to it here what we're doing the simplified way to explain what's happening here is we're just checking the current state of the contract itself right if no stream yet exists in the contract what we're going to do is look at how much money is coming into the contract and then we're going to create a stream of equal amounts to the owner right that happens down here in this create flow example if there's a stream already existing into the contract and the stream was updated right what we can do is just make sure that it's updated so that it mirrors the amount coming in and we need to make sure that amount equals the amount going out and in the case of a deletion all we need to do is delete all the streams going out of the contract right so pretty simple right simple like if-then statements to get this really cool functionality and then in the case of the changing of receiver again this is just going to be called each time that the token itself is actually transferred what we do is we check who is the current receiver all right that receiver should no longer be receiving these streams so we delete them right here and then we need to create streams to the new receiver so we can see who the new receiver is and we can create a stream to them equal to the exact same amount that was being sent to the old owner right so it just matches up and again this is all here you guys can fork this using your own applications make it better i'm sure there's gas golfing opportunities in here if you're so inclined feel free to go crazy but that's the idea there right so in the case of this contract it's going to receive tokens and send them out automatically so that the balance of the contract is always zero but the owner has this asset that is now a tokenized cash flow so again highly recommend you check that out but to wrap up here today there's a couple of things i want to mention right the first of them is this thing called superfluid reactor so there are quite a few teams including some of the logos i show i've shown here that have built pretty good traction or raised money building a project on top of superfluid right and the superfluid reactor program who is also kind of spearheaded by yao here in the back uh she'll have a soleil tag you'll see her as solei in discord she's helped lead this but what we've done with the reactor is formalize some of the help we provided to projects like yours that might build this weekend and if you guys want to raise money we'll provide coaching on how to raise money if you guys want help shaping your idea we do that as well if you guys want technical review technical help we can do that too so again it's something i just want to plug briefly because we do really value our developer community and our ecosystem and i think that you should know that if you are considering building on superfluid you have resources and the final thing i'll leave you with is uh something kind of fun that i'll plug really briefly it's a it's a podcast we just launched yesterday called devs do something so our first episode was with rahul sithuram from k'nex the cto of conext and the the methodology behind this was again we really valued developers we looked around at all the podcasts out there and there aren't that many like really highly technical web3 podcasts there's a lot of really great content out there but we want to go super deep so with rahul for example we went deep into like how they do uh design and like actually launch new features at connext we went behind these scenes and how they they approached security and testing we walked through like literally like their github actions and stuff so if you're interested in in some tech alpha i highly recommend you you check out the devs do something podcast and and give it a listen and also recommend people you'd like to have on it so that's it for me today sorry we had some of those transactions not not work live on on stage but uh i hope you guys consider doing something with superfluid and if you have any questions please feel free to find me in the hallway over there thank you you 