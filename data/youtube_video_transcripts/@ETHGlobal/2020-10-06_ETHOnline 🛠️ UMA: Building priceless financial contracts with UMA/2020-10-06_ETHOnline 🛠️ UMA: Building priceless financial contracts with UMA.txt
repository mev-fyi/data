everybody to the boomer intro workshop titled building priceless financial contracts with uma joining us today is hart and sean who will be taking us through the session one quick reminder for everybody to stake their spot for eat online if you are having any issues please don't hesitate to reach out to myself or anyone else on the youth global team and with that i'll pass it over to heart to introduce himself and get the session started hey guys all good on the stream okay hey all i'm heart lamber um i'm one of the co-founders of uma presenting with me is john brown who's our technical evangelist developer relations guy um who's active in our in our discord on each global um we're super stoked to be here because we love these global events and we love these hackathons um and we're really excited to just walk you through uh our our version of how to build um pretty cool financial contracts and synthetic tokens on uma so i'm going to do a screen share let's make sure this works emily thumbs up that that screen went through looks good cool okay so yeah sean why don't you introduce yourself for two seconds just so people know your voice uh hey everybody my name is sean brown uh like hart said i am the technical evangelist so really my job is to interact with people like you and help you build on top of uma so um you know if you're pretty active in this hackathon you'll probably interact with me a few times yep so guys we'll do a quick outline of our agenda here we get our introductions we'll check that box um i'm going to do a quick presentation quick quick little overview of how we look at oracle risks and our sort of philosophy here and how our priceless contracts work this whole concept of how we can actually build d5 contracts that minimize oracle usage rather than be reliant on on-chain price feeds um and then sean's going to go through and do a cool demo of how to actually create a synthetic gold token using uma and kind of show you guys how quick and easy that can be um and then we'll just reiterate the prizes we have in this hackathon and leave some time for q a uh generally speaking we want to make this like pretty interactive um i think usually people save questions for the end but if anyone has any burning questions please do feel free to kind of jump in um all right so let's get started with kind of our view on oracle oracle things and if you think of defy most of d5 depends on some sort of price feed for something that's happening um off chain um or some sort of lending requirement and if you think about this like let's just take the typical example example of like maker or compound or a lot of these sort of lending like protocols where you have two states you have the state where um the collateral backing of position is good and in the green or it's not good you're below your collateral requirement and you need to get liquidated and the typical way this is all configured is there is a price feed there's an on-chain price fee that determines whether you are in the good state or the bad state and that's all well and good that's all well and good except for this price feed is pushed pretty infrequently and becomes this point of arguably centralization a point of brittleness a major point of of weakness in this system design and kind of more importantly from the perspective of a cool hackathon project um it's expensive and difficult to have a price fee pushing uh prices on chain um and you can't really have a price feed for anything you've got to like do a lot of work to have one of these things exist um also talk more about how the the relative lack of frequency of price updates can be problematic for some types of financial contract designs um so you know the example here is that you've got this point of bitterness like we saw in the bzx flash loan attack you get one bad or inaccurate oracle price feed and your whole system can get wrecked there's this major point of uh dependency uh or brittleness around this this price feed that is pushing prices just by reading from an apac um so i've already kind of made this the the broader philosophy here or our our kind of look or approach to um this this system is that oracles are this major point of weakness for d5 that as they're currently designed this on-chain price feed is brittle and kind of dangerous and our best approach is attempting to minimize oracle usage and changing the design pattern so that we are using an oracle as rarely as possible as a form of dispute resolution so this slide here we go back to the middle slide we want to make sure that a position is correctly collateralized but our whole approach here is to look at it optimistically to look at it like we are going to say hey let's use participants on the blockchain to actually observe the state of a contract and not push a price fee to the blockchain but only have those participants observe whether a contract happens to be correctly collateralized or not and you can think of this for those of you that are kind of familiar with um layer two systems for scaling ethereum this is almost like a layer two approach or layer two kind of type of thinking applied to oracles where we're gonna say hey this contract is correctly collateralized until somebody tells us it's not and only when somebody says hey this thing is uncollateralized only then then we will liquidate the contract and if somebody disputes that then and only then we'll call an oracle so it's this whole idea of pushing the monitoring of the collateralization of the system to the participants of the system itself without us pushing a price to the blockchain one analogy that can be useful for thinking about this is thinking about um traditional legal contracts and you know financial contracts are really their analogous to legal contracts in the real world and um the example we like to use is if um if sean and i were to write a legal contract between the two of us say under the state of new york law we would write this contract well hoping that like the other side does the things they say they're going to do in the contract we only use the court system we only litigate this contract if sean and i failed to do what the contract specifies and we're trying to apply the same approach here to defy contracts where the oracle is like a court system that we would only use in the example of there being a dispute a genuine dispute between counterparties or between participants so this design allows us to be more performant because we are not pushing prices every 15 minutes to a blockchain this is literally happening in close to real time the moment somebody thinks a position is under collateralized they can go and liquidate it that lets us do high performance things it lets us do things in closer to real time and lets us scale uh d5 contracts where we don't need to be constantly pushing prices uh to the blockchain to do interesting things so um just to put some terminology here we call the kind of top layer of this oracle process we call it the dvm the data verification mechanism and the design or the goal here is to use the dvm as rarely as possible it's like taking somebody to court so we designed these contracts these priceless contracts where participants observe and make sure that they're working correctly and they only use the dvm if there's a genuine dispute so this is like a cool tweet we had from earlier in march when we were first putting pushing this out and people like this idea of generally minimizing oracle usage it sounds great but the other important aspect of why this makes things so resilient is that it changes the design approach for how oracles get used rather than having an oracle be real time and timely we actually use a dispute as an after the fact look back in time uh decision about whether something was correctly collateralized or not it slows down the process and it lets us in a more much more decentralized way understand whether uh a liquidation should have happened or not um so this is just a slide on how the uma token accrues value but the uma token functions as effectively a seat on the jury to determine whether these disputes were correct or not if we want to extend this court analogy so it's a voting system where owning tokens gives you the privilege of just resolving disputes of resolving whether a price should be a or b and the system itself has a unique set of token economics which i'm going to discuss in a another presentation later in the summit or you know you can see some of the stuff on our website um but our token economics works such that the uh uma token holders themselves extract fees when needed to maintain the security of the system so that's my quick kind of overview of our philosophy around this priceless thing um i'm not sure how easy it is for us to take questions right now but maybe we'll just um let shawn move forward and then take questions at the end what do you think sean sounds good to me um yeah so sean's gonna go through and give us a cool demo of how to actually create a synthetic token and yeah you took over the screen share great can everybody see my screen okay good awesome um yeah so now we'll get into the actual hands-on portion of uh this presentation so like hart said uh we're going to basically try to show you how in 20 minutes you'd be able to use the uma infrastructure to create your own example synthetic gold token so the idea behind the synthetic gold token would be that this would track the price of a gram of gold against uh basically a us dollar or what we'll use in this situation is an example die token um and just to reiterate uh like hart said and like i said in my introduction um i'm really not an engineer like that's not my role on the team um so really the purpose behind this demo and the purpose behind this walk through is that this can be kind of spun up by anybody with like some preliminary technical knowledge um and so on this slide we give a real like brief overview a step-by-step instructions with links to each part of the documentation that would walk you through the steps that you have to take to do that and then this continues on the next slide where our ultimate goal like i said is to create this synthetic gold token and we'll display that within uh a metamask account that's basically connected to our local test network or local development environment um so hopefully you know with murphy's law and you know live coding and all of that uh you never know but hopefully at the end of all this we'll be able to display this synthetic gold token in our metamask account so i will minimize this now and yeah um so now let's uh we're going over to our terminal here and i really want to start this basically from you know step one um so right now we're in in empty directory as you can see titled ethonline um the first step would be to go into the uma protocol github uh so it's you know github.com um protocol slash protocol and clone the protocol repository so just requires that you have get on your machine already but we'll clone this here next um we're going to want to think about like our prerequisites and uh also our dependencies so uh if you follow this documentation that's listed in the slide deck basically the only two pre prerequisites that you need are node and yarn um so real quick we'll just make sure that we have the latest stable versions of this so yes we have the latest stable version of node which is good and we also have the latest stable version of yarn so we can navigate into our protocol repo and now that we're here we can install our dependencies so just takes a yarn command and this will take a few seconds um so while that's going on we can talk about what we're going to do next uh the first thing we're going to do is of course compile our smart contracts um but then as i mentioned we're going to uh start developing on a local test network uh so the next portion will be actually spinning up that local test network using the ganache cli which is one of the dependencies that's being installed right now and we'll just use this command where basically we'll spin up our test environment where we'll have some example ether counts that have you know a large amount of eth in them and we also set a large gas limit so that when we deploy our smart contracts um we don't run into any issues with you know the gas limit there so this is this actually just finished um so i've got a few errors uh i think it's just a problem with my local environment so we'll proceed and uh see if that causes any issues but i don't think it should um so next we will compile our smart contracts and this will also take a few seconds um so as that's going on uh one more thing to note on spinning up our ganache uh test network is we'll actually add one more uh flag to this command and that will be the dash d flag which stands for deterministic um the only reason why we're doing this is for demo purposes because i wanted to basically set up a metamask account beforehand where we could use that mnemonic to connect the metamask account to our local test network so yes let's see awesome so this is finished now and uh in our small probably can't read this but in our small uh terminal over here we will spin up this ganache uh test network with the dash d flag and we can now see that we have an example test network uh spun up on our local machine on port 9545 with some of the parameters that we talked about and also example accounts with a million eth in each of those accounts so i think this is probably a good time to talk about our metamask account and uh like i said the goal of this is eventually at the end uh we'll see that we created a synthetic gold token and hopefully we can see that in our metamask account um so to do that we're going to need to connect our metamask account to our local test network so to do that we just come in and we specify a custom network essentially so like i said um this is on our local host uh port 9545. so we'll connect that and yep so awesome now we have a million test eth in our uh you know development metamask account wish i had you know an actual million eth but this is just test teeth and we'll use this to pay for like our development transaction costs and all of that so we've now compiled our smart contracts and deployed um and spun up our local test network so normally what i would advise doing is actually running our truffle tests um with the test command just to make sure that like all the dependencies installed correctly and your local environment is set up for development correctly um but this takes like 10 to 15 minutes so just in the interest of time we won't be doing that today but probably a good thing to talk about is um within this truffle test command we can see that we pass a network flag so uh for the test command we would be passing the test network or our local ganache network that we just set up um but like this is important to think about for later because if you are following along right now or you're trying to do this later on and you want to deploy this you know somewhere that's not your local test network then you can do that pretty easily by just passing uh parameters to this network flag and connecting uh with a couple of options that we have here so like in this command here when we run this truffle command we can see that we're trying to connect to the rinkeby test network and we're going to try to connect with a mnemonic so all of those instructions are here and you can think about like the steps that i'm doing today as being translatable directly over to you know test networks like rinkeby or covan and also uh to mainnet as well cool uh also uh just to reiterate like hart said if anybody has any questions i know i'm going through this kind of quickly uh but you know don't hesitate to say something in the chat cool um so moving forward to like the actual synthetic token creation and the exciting parts in this um so we have our local test network running and uh like i just talked about we'll connect to that in our truffle console by running this uh truffle command so we'll do that awesome so now we're connected to our test network and we'll go ahead and migrate our contracts and so you can see in the logs here all of the different contracts that are being migrated to the test network um we don't really have time to go through each of them today but it might be useful to you know look through those logs and kind of understand some of the things that are available there um and then the next step that we're going to do is creating uh an amp creator or a contract factory for this thing that we call the emp um the emp stands for an expiring multi-party contract and hart talked about this a little bit but like one of the things that we offer is uh these priceless financial contract templates um so really anybody can create one of these templates but when they're created uh that template itself or like the factory that can create like instances of that template needs to be approved by uh the uma network before it can actually be used on mainnet um so that's what we're doing here is we're creating an instance of this uh contract factory great and next we'll actually get into like some of the financial engineering aspects of this um and talk about like you know how easy it is to do a wide variety of things just by parameter parameterizing uh that's a tough word to say uh this emp contract uh in different ways so i know this is kind of difficult to look at but this is the step that we'll be defining these uh parameters and i think this is this should be a little bit easier um but if we look at some of these parameters and think about what these things mean um the first the first thing is this expiration time stamp um so like i said we're creating an expiring multi-party contract and the important word there is expiring so this contract will expire at some time in the future so this is where we define that uh so uh this is a unix timestamp and i preset it for i believe this is halloween of this year so it will expire at the end of this month um and the next thing would be this collateral address so like i said before um we're going to create a synthetic gold token that's collateralized and die uh so normally this address would point to like you know the test net address or the main net address of whatever collateral currency you want to use but for development purposes here we have that address basically on our local test network um but you could you can kind of think about the financial engineering aspects of it here because like you know if you say use a stable coin like die as your collateral currency in a financial contract then you have a very different contract than if you use something like say a wealth or like something that's more volatile because then you kind of introduce other other aspects or like other exposure to position holders in this financial contract and so you can use basically like any erc 20 token for this collateral but also similar to the financial contract template this needs to be approved by the uma network it needs to be proposed and then approved by the uma network to use this the next thing is this price feed identifier and probably the last parameter that we'll talk about and this is probably the most important um so here is where we define like how this token actually gets its price like what actually gives this token uh the price that it trades at so uh right now we're defining uh the price identifier as gold usd um so i mentioned earlier and we can also see it in the name here but what this will be is basically the price of one gram of gold in us dollars um and similar to the collateral currency and the uh contract factory this also has to be proposed and then approved by the uma network um and basically you think you can think about it as like a deterministic way to get to the price of something um so like when you actually go to the oracle or the dvm for a price request uh you need that oracle to return like this specific price identifier so for this specific contract what it would return like at the expiration time would be the price of one gram of gold when this contract expires um kind of like hart was talking about as well like if a dispute process happened and like somebody was under collateralized and then got liquidated and then a dispute happened then a price request would happen at that time stamp as well for basically the one for the price of one gram of gold in us dollars so i know we covered a lot there um so just want to make sure that there aren't any questions all right cool um sean there's a couple um questions in the chat but i'm not sure if heart has answered that for you okay great yeah yeah the answer sean i'm uh i mean i'm i'm handling some questions in the chat for you so uh i don't think they're directly relevant to this demo so far awesome keep and um yeah if anyone does have questions around this demo maybe drop them in the chat here and we can like we'll address them in real time cool cool thanks hart so uh now that we talked about the parameters for a while um we'll actually use those parameters and create uh a financial contract with those parameters so we'll take uh take those things that we just talked about and create a financial contract with an expiration of october 31st tracking the price feed of basically one gram of gold in us dollars and using die as the collateral currency for this financial contract so we set the constructor parameters there and then um we won't talk at length about all of these things but you know i i mentioned uh there needed to be an approval process for uh the collateral currency the uh financial contract template and also the price identifier so that's just what we're simulating here is we are approving all of those things and basically adding them to like the white list that allows for them to be used on this uma network so we'll just run through these commands real quick so first we are approving um that price identifier that we listed in the params earlier we're then registering and approving that financial contract factory for the emp and then the final step is we are registering and approving that collateral currency so die in this case cool so we're all set up now and we've approved those things on our local uh testnet um and now we can actually uh submit that emp contract and create that thing so we'll oops so calling uh the create expiring multi-party uh function will create that emp and create the instance here so now that we actually have the emp created if we type in emp which is you know our variable name here and then dot and tab we can see all of the different methods that we would be able to call on this financial contract a couple of useful ones that we'll use today would be emp dot token currency which returns the address for that synthetic gold token that we're creating with the cmp contract and then the other one would be emp dot collateral currency so we'll call this method to return the address of the example die token that we're using as the collateral currency uh for this contract so the cool thing that we can do with this and like the reason why we did it is if we go back to our metamask account that's connected to our local test net we can take like this token currency address and we can add this token to uh to our meta mask and register it so we input the token address and we can see that it's returning the token symbol that we defined earlier so now we're actually able to track that synthetic gold token in our metamask wallet and then similarly we will do the same for the example die that we're using so we will add that token as well and now we can track the amount of dye and synthetic gold that this account has on this local test net cool so like we have the instances of these things created but we actually haven't minted anything or like taking a position in any way um so that's what we'll do next and we'll actually like first issue ourselves uh some example die so that we can mint these synthetic gold tokens um and then we'll mint those synthetic gold tokens and talk about like what our collateralization ratio is and like what some of this actually means so first uh using this command we can see that we're basically minting uh 10 000 uh die tokens and allocating that to our development account so we can run this and since we're actually tracking die in our metamask account we can see that our die balance has now gone up to ten thousand and then we can also approve uh the emp to spend our die for us so that we can then uh mint uh synthetic gold with it so now that we've approved that and we have die in our position probably the next thing that we would want to do is use that as collateral to mint synthetic gold um so if we think about like what the price of one gram of gold is i didn't know this off the top of my head but i looked it up beforehand um it's approximately like 60 dollars a gram so if we wanted to achieve a collateralization ratio that's kind of typical for like a financial product and also is one that we defined earlier in the parameterization step so if we wanted to achieve a collateralization ratio of 1.5 then we can think that a token sponsor would probably need to basically you know use about 900 worth of collateral uh as collateral for say like 10 synthetic gold gram tokens if that makes sense so in this commands we'll actually mint these synthetic gold tokens with our die so here we'll change the actual numbers that we're using because we're tracking a price index that's more expensive than just like a one to one a one dollar uh to one token ratio so we'll mint uh 900 or with 900 die will mint 10 synthetic gold tokens and submit that transaction and now if we come back over to our metamask account we can see that we've minted or created uh 10 synthetic gold tokens with 900 dies our collateral so in basically this situation with this financial contract what that means is um each synthetic gold token basically tracks the price of one gram of synthetic gold so at like the contract expiration i should be able to basically return these synthetic gold tokens for the amount of dye uh that the price identifier or the oracle returns at that time [Music] cool and i think the last thing to touch on is uh i don't i don't think we necessarily have time or like need to get into this today uh but this tutorial goes on to basically show you how to do other functions that would be necessary as like a position holder so an example would be you know returning some of those tokens for a specific amount of die um so you could do that by running these commands uh and then also depositing and withdrawing collateral um so if like a position holder wanted to you know add to their position to make sure that they're correctly collateralized or withdraw to you know maybe they're over collateralized and they want to use uh use their currency for something else you could use these commands to do that as well and basically interact with your position in like any way that you would necessarily need uh and i think that basically concludes the demo um so i'm pretty happy because we accomplished what we set out to accomplish uh heart any anything that i missed or anything you think we should focus on a little bit more um i thought it was pretty good demo i'm biased sean but i thought it was pretty good demo um so uh there is one question here that um i think is worth uh digging into tomorrow is asking how long the price id whitelisting process would actually take um and i think it's important to note that what you did here sean is you ran this locally where you can create whatever you want locally nothing's holding you back um for this to exist on mainnet in production it's pretty open like you can literally create a token to track something you come up with um however you need to get that price identifier the price id approved by the uma token holders and the idea here just to make this make logical sense is that my token holders in the dvm have to be willing to vote on the thing that you are asking them to to approve um and so uh they need to make sure that they're able to vote on this thing and so we have a process where we write what we call an umit you uma improvement proposal uh to uh to define what a new price identifier looks like and then we asked tokenholders to vote on it and that process could take as little as four or five days to kind of introduce it to the community and then go through the voting process uh and once it's approved then that price identifier is real and you can create your synthetic token on mainnet um and so we're quite excited to see people people are beginning to do this um create price identifiers fires for all kinds of cool things um and so really like your eth global hackathon idea could become a mainnet thing um pretty easily with this like four to five day process um so it's one question um uh carl's asking another question is do we have an additional uh token that represents the collateral and is the collateral transferable um so the emp contract the way this is written um the emp contract is what holds your collateral and your it's not a token because it's not fungible in the same way that when you mint die the your vault or your cdp you can um it's it's it's not tokenized because each cdp is different it represents a different amount of collateral and all those sorts of things um i actually believe you can transfer ownership over a token sponsor position i believe there is a transfer function i'm actually that's an engineer question that would allow you to transfer ownership of uh your sponsor position but it's not tokenized um carl's also asking where can you see the collateral position i mean it's a it's easily observable in the emp contract itself and we've built some tools we've built a tool uh tools.lumaproject.org that provides um some insights into um emp positions um yeah but also carl hop in our discord and ask more questions and sean can go deeper on this um uh tomo's also asking if third parties can add or remove collateral from your position um third parties can add collateral to your position so if somebody if you are a token sponsor and you created say these 10 synthetic gold tokens and you're at risk of becoming under collateralized and let's say my new friend carl wants to add for some reason wants to add collateral to that position he can go ahead and do that and the token allows that however he can't withdraw collateral without my uh he can't withdraw collateral because it's my position right so um anyone can deposit additional collateral but no one can remove it um besides the uh the the position owner um those are actually some pretty good questions those are yeah very financial engineering centric too which is always awesome um maybe the last thing i i'd sort of add to uh to note here is that as a team we are pretty um we're pretty into financial engineering and pretty into inventing cool new things um and so our discord like we are all about working with people that try to come up with cool new ideas or cool new ways of of creating new financial products um both using this emp uh contract and then also innovating on how to modify or hack the emp or other related contracts to do other things so for example sean is working with somebody in our community right now to create a price identifier for uh tracking the price of gas on ethereum which is going to allow us to create gas futures or tokens that track the value of gas on ethereum which we think is pretty cool um there's a bunch of other ideas in the works that i won't get into right now of um different interesting types of synthetic tokens people are looking to create um and i'd also add that at hack money um which was the global hackathon two times ago um the potion labs team came up with this like brilliant way of creating an insurance or kind of a new form of options contract that is a significant modification of the emp to uh to create a type of insurance on any type of really on any type of erc20 asset which we thought was pretty cool yeah um sean you want to handle this question what's this when somebody wants to close their position and return their synthetic gold let's say the price of gold went up where does the initial die come from to pay out the profit so remember uh this is robert's question um it's useful to think of the participants involved if i go and i mint these 10 synthetic gold contracts with dye i still own those contracts i'm not short gold um until i sell them so if i sell those gold contracts and let's say the price per ounce of gold shawn what do you say it was like 60 bucks 60 bucks yeah well per gram actually definitely not per ounce per gram yeah so okay so i sell these 10 10 tokens which represents 6 grams of yeah they represent 10 grams of gold for let's say 600 dollars i sell those to sean now i'm short gold because i have to make me maintain the collateralization requirement of my sponsor position and sean owns gold i can close my debt position at any time as long as i get back 10 gold tokens i just need to get those back but if the price of gold went up and i want to close my position i'm gonna sean's not gonna sell those those 10 gold tokens back to me for 60 bucks he's going to only sell them back to me for whatever the market price is so if the price is now 70 dollars i would have to pay 700 to buy back those 10 gold tokens sean makes his uh his 100 bucks on this trade and i now have my 10 gold tokens which i can use to close my debt position to close my uh my token sponsor position and also to add to that like as a position holder because like i'm keeping track of the price of a gram of gold and i know that that's going up i'm probably also uh if i'm you know following the correct collateralization ratio i'm also adding to the collateral that's backing those 10 tokens so when those are redeemed like the extra price amount comes from the added collateral that's still backing that yep good question good point of clarification um and yeah robert so i missed that question earlier you asked that earlier but uh i missed it um cool so sean why don't we uh just the last two slides here um let's just give a quick overview of our prizes again um so we're gonna be awarding five thousand dollars worth of prizes uh three thousand bucks the first place 1500 second 500 a third um one fun cool thing we're gonna do is we're gonna actually use the uma token holders uh to actually vote on who should win these prizes um we're just gonna try doing this and we're going to do this using a snapshot.page voting thing so i i think that'll be kind of cool and kind of fun and um this isn't voted yeah yeah so so that'll be kind of fun to see see how this works we have office hours in our discord channel and we also have a calendar of events with everything uma related at gallant calendar.mlproject.org please do jump in our discord uh or you know there's two discords either in the east global discord in that channel or um in our own discord um feel free to join that and uh sean's got all of our social media and website links uh up here um we really i don't know we really love these youth hackathons um they're really fun um they're fun to do in person they're actually fun to do online too so we're here to like help out with you guys um hit us up uh we want to be responsive uh sean what we got on the last page we've got uh our people right our people yeah yeah so these are just like some of the people that you'll probably interact with on discord um so just get to know them because you'll probably be talking to them a lot if you know you're building a project with emma yep and uh you know we're what are we we're six days into october um we got a solid three weeks to go um we uh we want to see you guys build cool things so hit us up and um let us know how we can help cool thanks so much hart and sean that was a great session and i'm sure you can even share these slides in the uma sponsor discord channel and the hackers can go through that in their own time but if there's no more questions from anyone on the call i want to say a big thanks to sean and hart for the session and um yeah if you have any questions feel free to reach out to them in the sponsor channel and i'm sure they'll reply quickly thank you emily cheers guys thanks so much emily thanks guys have a good one 