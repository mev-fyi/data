foreign [Music] my name is Angus and I'm going to be talking today about Mina protocol and snarky JS so there's a quick introductory slide here as I said before my name is Angus midmund and I am working to developer relations for the Mina Foundation um I live in Edinburgh in Scotland and my Twitter is at blockchainbeard so you can follow me on there I also have a poll going for all participants of East Tokyo it's about how you um add people when you're kind of exchanging telegram information so I'd be really grateful if everyone votes in that poll I've put a prediction for what I think their outcome will be as a sha256 hash and I'll reveal it when the poll closes at the end of the day on Sunday so there's a funny picture of me as well blending into the uh the background of the sign in momina hoodie I've actually got the trackies on today but no hoodie because it's too hot so the structure of the talk today I'll first of all introduce uh like the Minar protocol and give you a quick intro as as to what like uh zero knowledge proofs are I'll talk a bit about ZK apps the kind of applications that you you can build on top of mineral protocol a bit of a deeper dive into snarky JS which is the typescript library that you can use to build zero knowledge proof-based applications and then I'm going to tell you about a program that we have got going at the moment called ZK ignite and also the next steps for how you can get started building stuff so the first section what is Mina Mina is an L1 blockchain that's built from the ground up using zero knowledge proofs and so to give a general introduction about what zero knowledge proofs are it allows you to verify information in a private trustless and decentralized way so that has a number of of useful properties that allow you to do things like create ZK Roll-Ups and zke the ends um of which you know you might hear about from other uh people here at the conference you can do private transactions um and keep data more private or or hidden in some way you it's good for for doing private voting it's got a lot of applications when it comes to Identity as well which is obviously an important aspect of like web three and also you can can verify large amounts of computation uh efficiently so a zero knowledge proof effectively says that you can prove that a program has run in a valid way and that the output is valid um you can prove that efficiently so the it's it's it's fast to to verify the proof and you can do that without seeing all of the inputs necessarily you can do that just by using what we call the the constraints so that gives you options to give your users more privacy and security by keeping their information private and also has implications for for verifying things and scalability as well so just to give you an idea these are kind of like the function prototypes or or kind of declarations for some cryptographic Primitives that you might be familiar with a hash function you put a string into the hash function which is H there and you get out the hash which is also a string so you can tell that two pieces of data are the same if they have the same output from hash function right there's public key signatures so you have a sine function so you take a private key you can sign a message with the sine function and that will give you an output of a signature right and then you can verify that signature using the corresponding public key right and so you put that signature the message and the public key into the verification function when you get out you know either this has been signed by that private key or it hasn't right so then you can tell if a private key has signed you know like a message or a transaction with a zero knowledge proof right the way to think about it is there's a compilation step so you compile your program and then that gives you so you have some code you compile it and that gives you the verification key which is a string the key the verification key or index that's a string then you have a proving function you you so you have the program you run the program with some inputs right you use the proving function to then generate the proof the proof is a string as well right and so then when you did the compilation step you get the verification key you use the proving function to create the proof then you can verify you take the proof you take the public inputs but not the private inputs and you use the verification key that you create you created at compilation time you run the verification function and that gives you the Boolean the the the proof is valid or it's not so now what we're doing is you can verify computation not just that something has been signed but you can verify that a program is run correctly and you can keep some of the inputs private or hidden so you only need some of these inputs the public inputs so that kind of gives you an idea of how it's different to these other these the the zero knowledge proofs are different to other cryptographic Primitives and I'm going to talk a little bit now about Mina protocol which is as I said earlier a layer one blockchain that is built entirely using zero knowledge proofs now as I said before zero Lodge proofs you can verify efficiently and so Mina is a succinct blockchain it's been built using zero knowledge proofs so that it's very efficient to verify the state of the blockchain so that means that you can verify the state and and run a like a light node on a variety of different Hardware including a mobile phone so that's what that diagram on the left is saying it works using um recursive ZK snacks so recursive like proofs to kind of Link the the the states of the blockchain together and so to move it on and that's what this diagram in the middle is signifying and so that's what keeps it lightweight as well the fact that these proofs can can be recursive you can prove the last proof you can kind of chain them together and the proof stays the same size it's a constant size and it's fast to verify and also it's interoperable in the sense that because you have this lightweight proof that you can quickly verify you can use Mina as a kind of ZK layer and then take the state of Mira and kind of verify it in other environments including for example ethereum to have it function as a kind of ZK layer for other blockchains or environments so this isn't just stuff that we're kind of uh postulating on there's actually a grant being given jointly by the Mina foundation and the ethereum foundation to this other foundation called the nil foundation and they're building um in evm Mina State verification so so in in the future when this is um ready to go you'll be able to verify the Mina state in an evm smart contract which is pretty cool because then you can do whatever you want Amina verify any VM and then you know do stuff on the EVN chain I'll take questions at the end but thank you Jonathan um we also have the open Mina web node so basically you can run this this node in a web browser so when I was referring earlier to those that diagram where it says you can run a node on your phone you can actually spin up a meter network node in the web browser right so you could in theory submit transactions directly through the web browser without having to go to like a third party uh RPC provider so coming on to to like what you can do with me at the hackathon right is you can build apps on top of mina that use zero knowledge proofs we call them ZK apps and so just to introduce the concept to think about the concept of ZK apps ethereum uses on-chain computation so you write your code in solidity and then you you put the actual code onto the blockchain and then all the nodes in the blockchain network when you say you want to to run a function in your smart contract they all run the code that they have on the blockchain and so it's verified by the fact that everyone does the computation right and gets the same result all the nudes on the network on Mina the ZK apps use off-chain computation with on-chain verification right so you do a bunch of com compute off chain and then you generate this proof that I was talking about earlier and then that gets verified by the network so this has a number of advantages one you can keep things you can give your users more privacy by keeping uh inputs to the function private there's no gas fees in Mina so you don't pay for computation you just pay for the block space you do all the computation you want you generate a proof and then you put that proof in a transaction all you pay is the transaction fee there's composability using snarky.js our typescript library so you can kind of program your own ZK apps to to fit your use case and there's scalability through rolling up rolling things up with with this recursion that I'm talking about so the fact that you can use proofs to generate further proofs means that you can kind of roll things up and collapse them all down into to single proofs that kind of verify everything that you've done um and also the interoperability thing through the the blockchain being lightweight and quick to verify the state of so to explain that in slightly more debt just the process of it just to kind of help you get a mental model of what's going on when you do the compilation step that I was talking about you so you write some code that's going to be your ZK app and then you compile the code and that produces the verification key and so then you'd send the transaction to the meaner Network that creates a ZK app account so an account for your ZK app and that verification key is stored in that ZK app account right so now you have a ZK app that is is associated with this verification key that's on the network right now on the left hand side of this diagram this is your ZK app so you serve the ZK app to a user in a web browser for example right they run the ZK app with some data inputs that they put in to the the web browser when they run the app that's the program bit that we got out of the compilation thing that I was describing earlier so they run the program and it generates the zero knowledge proof so they generate the proof and they include that zero knowledge proof in a transaction the transaction gets sent to the minor Network and the meaner Network uses the verification key that you sent when you deployed the ZK app right and then it uses the verification key with that verification function with your proof and that then says whether this proof that you've generated is valid or invalid if it's invalid then the transaction is tonight doesn't go through so that's kind of roughly how the the verification happens when you deploy you put the verification key on the network and then the network nodes basically check your proof against that key when you use the ZK app and create the proof so ZK apps are composed of methods right and methods you can think of as like functions uh in other smart contracts so there's this diagram on the right basically you have inputs and outputs to these methods right you can have arguments that go into the method you can have there's a very small amount of like on-chain state that you can manipulate and it says here are some values from the state of the world so that's you know another database that you have on your website or or some other thing that you can kind of control or change and then that's the input to the method that the method runs and then as as a as a result of the kind of logic in it you can make updates to the state of the smart contract or you can make updates to some other thing based on something that happens in your method and so if you want to learn how to to write methods we need to go into snarky Js Nike JS is the typescript library that you can use to define create and verify zero knowledge proofs so it's giving you as a developer the flexibility to build applications that use zero knowledge proofs without having to be a cryptographer or kind of a high highly capable functional programmer who can understand dsls in or camel I mean if you are into that sort of thing you should definitely still come and talk to us because you know it's all kind of under the hood but snarky JS is basically giving you the typescript interface that a lot of developers are more used to so here's some some logos that you might recognize so we have basically uh familiar tooling that you'll be used to we've got good intellisense support in Visual Studio which makes it the developer Journey a bit easier um and you can write all your tests in JavaScript using GIF so this is five steps to show you how easy it is to get started the first one is to install the ZK app CLI tool which is yeah it's the CLI tool that kind of helps you with with building as in you know compiling uh configuring and deploying your ZK apps then it's one simple command ZK project creates your new project directory and it actually has a demo kind of smart contract in there already the fourth step is to configure it with our kind of test net information there's also a step here where you need to go to the faucet if the first it's giving you any any trouble you can kind of come to the booth or message me or tweet at me and I can give you some some test at me now because I've managed to secure uh a supply of it especially for this weekend and then all you do is ZK deploy Berkeley and then you know that's it you've deployed your ZK app so to program instant rkgs you also need to understand that we use field elements so these are elements of a a finite field which we use because that's how the cryptography works it's Nike JS it can store quite a large number up to almost 256 bits so it's a built-in type in snarky JS and it has built-in methods as well so uh down here you can see an example where you declare a constant called sum and then you make it out of two new Fields one of which is doing the dot add method to another New Field which is three so that'll that that sum will end up being four but it'll be a field element right which is what you need to use if you want to do things as an rtjs there's also some other built-in types including some crypto stuff so you've got public and private keys and signatures um and also like there's the there's a miracle tree implementation that you can use for things and these all have built-in methods on them as well so if you want to find out more about that it's all in the docs or you can use it uh intellisense if you use Visual Studio code that'll tell you you know what the methods are so this is kind of an example smart contract that just to give you an idea of of what it looks like I thought I was gonna have a kind of pointer that I could use so I'll try and point and I can actually refer to the lines so in line 12 you've got this state right kind of uh variable called num so you have a very small amount of on on chain kind of State Storage and then what what this uh is doing is this method down here on line 22 is saying we set the initial state to one which is a field remember because we're using field elements and then the update method on line 26 is saying check you know get the current state check that that is actually equal to the current state so you're kind of putting it into the proof that this is the state that you got and it's equal to the variable that you have and then it's saying add to to the current state so then this is the kind of this the demo smart contract that you get so it'll just every time you call update it'll update the state variable by by two so that's what snarky.js looks like also this is a the Mina color theme that someone made for visual studio like the syntax highlighting so if you want to get hold of that I think we can maybe link you up to it but I'm not entirely sure uh so next steps recursion we've been talking a lot about recursion obviously making some bad jokes with the bag within a bag but one of the really powerful aspects one of the powerful features of snarky JS is that you can um you can do infinite recursion right so you can use proofs as input to other proofs so you can kind of roll proofs up into a single proof to verify that several things have happened with intermediary kind of proof stages so this is a diagram here of kind of oh here's a snark and then you put that into the next snork and kind of the proof stays a constant size the whole time so you can kind of infinitely roll up these proofs right and so an example that I was I'll take you through is in the case of a card game if you're a player one you take your turn according to the the rules of the game you produce a proof that you've done a valid move you've passed that proof to player two player two can verify the proof they can verify that player one has taken a valid turn then they can make their turn they can pass the proof to player three player three can then verify that player 2 has taken a valid turn as well right and so in that way you can kind of go through as many hands of the game as many rounds as you want and then you can do it all off chain and then when you have the end proof that's kind of the end state of the game you can then put that onto the blockchain to show the three players have played 20 rounds of this game okay and so this is something that's quite interesting a lot of the time when people talk about Roll-Ups they're talking about batching transactions together right but no with Mina and Nike JS you can start to think about rolling proofs up together right and that opens up quite a lot of different kind of ideas and use cases so that's something recursion is something that that is really quite um exciting about about snarky JS and we'll open up new different ideas so here is the prize pool for Etho hackathon first prize is eight thousand seconds six thousand third prize four thousand dollars and there's a two thousand dollar pool for kind of runners-up who don't get the top three but still submit a project that's built with snarky.js there's also this program called ZK ignite which I mentioned earlier it's a sort of cohort based grants program so you submit a proposal there's some voting and if you get funded you get funding for your project and also you kind of go through the process with a bunch of other projects so it's a kind of cohort like that and you get Hands-On support and kind of training and kind of community type things going on and so there's a new cohort starting on the 24th of May you can scan this QR code to get more information and one more QR code this is like the hackathon starter kit it's got a link to the documentation and also a couple other things so please come and talk to to us after this Workshop as well or at the booth which is in there I'm not going to try and describe where it is we've got a big minute sign behind our table though and so that is the end of the presentation thank you very much for being here we've got about eight minutes left for questions so I'll take this question down here first so there's a verification keeper app yes that means there's a trusted setup per app like uh that's that's a good question reference there is not a trusted setup per that and so it's because the the proof system that we use it's called kimchi and it uses something that's like bulletproofs that uses the inner product argument to avoid the need for trusted setups don't ask me to explain it more than that because I don't know all the math but it's it's kind of the inner product argument um way of of it's kind of like a it's something that is has I don't want to call it a workout either I'm not sure the correct terminology but basically there isn't a need for trusted setups because they use this inner product argument methodology so this verification key what is it it's a string it's an input to to each proof of the app so when when we're talking about the network the the verification key when you deploy your ZK app the verification key gets stored on the network and then the miner Network uses the verification key to verify the proofs so that the verification key and the proof go into the verification function and then out comes proof is valid proof isn't in a brilliant does does use some prolonged light setup flunk light it's so the it says the the docs say the proof system is plunk ish right and also there's the Mina book which is a load of documentation about the proof system which has a lot of math and a lot of cryptography which I can point you to which will have all the answers that you're looking for thank you I'm sure so you you mentioned when you deploy a ZK app you store the verification key on chain and there's also some a very small amount of state that is Unchained that is accessible to each of these CK apps is that correct yes how is the blockchain fixed size with that state I'm assuming there's not an upper limit to the number of zika apps that can be deployed on on chain so how can you store verification key on a fixed size blockchain without increasing the size the only limit to the amount of ZK apps that we'll have on chain is the imagination of developers like all of you also the blockchain isn't a fixed size in the sense that so the state proof stays a fixed size which you can verify the whole state of the blockchain from but obviously there's there's other things which kind of make up the blockchain right and that goes into how the mirror network works in the kind of different roles and entities that there are there's different kinds of nodes right that have different storage requirements but the fixed size thing so you may have seen this before as well it's a number of kilobytes the fixed size thing is the the size it takes to verify the state of one account and that includes the kind of the the overall State proof for the latest Block in an amino blockchain so this the state proof is what's fixed size it's not the state yes 69 okay and so the but to verify the state of a single account it's a fixed size per account so and I think so then I think it would be if you wanted to run a node with the whole state of every account I think it would be n accounts times that number but I'm not sure on that I mainly dealing with the the ZK app stuff so but I'm sure we can we can get someone to to go in depth on the on the Node stuff with you if you like at the booth thank you there's a question over here thank you it was nice presentation could you tell more about the vision of um Ezekiel apps ecosystem what types of products you want to have on it like defy some games or whatever that is a very good question so we've just run the first cohort of that ZK ignite program and the kinds of zika apps that were funded by a kind of Council of electors who were kind of community members the kind of things are getting funded are L2 Roll-Ups that do kind of batch things together transactions or um other other kind of bits and pieces But but so we've seen a couple of roll-up Solutions we've seen data availability Solutions so at the moment there's still quite a lot of infrastructure and tooling being built there is one thing was really cool actually it's a a kind of verification app for people who get kind of different colored belts in martial arts and you can kind of check who has given whom each belt and things like that so that one was quite interesting I think when it comes to things like defy we because the computation model is different to evm quite a lot of the things that we think about um in defy it's not really defined how to do it on Mina yet so that presents to you an opportunity I think it's but also a challenge so you know you kind of need to figure out a different way to do things on Mina but then if you do figure it out you'll be the first person to do it so that's why it's both a challenge and an opportunity I think um but but we really are just getting started with ZK apps um so it's it's a good time to get in early thank you one last quick question and you can ask me questions outside as well I always just wondering where the proving actually gets done is it in the user's browser or is it somewhere else it's in the browser so yeah so I think we have like enough time to do this answer so you run a ZK app in the browser and what that is doing is running the program and then producing the proof and that's the proving right so you run the program you produce the proof in the browser and then the verification happens in the network okay I'll ask later about timing though does that have substantial lag or is it pretty quick or yes you're right that is a question for for come to the big one more death later there's a lot of asterisks attached to that so thank you very much everyone though bye-bye to everyone on the internet 