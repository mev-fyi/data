for those of you who are just joining we're just waiting a couple seconds for the stream to go live before we get started awesome hey everyone thanks for coming to uh our first day of hack money workshops we have hardik from learn web3 dao doing a workshop on build an nft sticking game fight contract um questions go in the zoom chat and hardik will answer them as they come in and with that being said i'll pass the mic along to hardik perfect yeah thank you anna welcome everyone um so today we're going to be building game fight contract she said and somebody asked me this last time but i also have no legal middle name it's a single name um i'm the co-founder of learn web3 dao um huge decentralized identity maxi has spent most of my life in that field in web3 um i currently work at three bucks labs this is the team behind ceramic network and previously used to work at dapper uh building flow blockchain adapter wallet so today we're gonna i'm gonna try to divide it into roughly three sections uh we're gonna spend like a couple of minutes understanding what we're building um spend most of the time actually coding it out and then i'm gonna leave some buffer room at the end for uh q a and uh discussing certain things um before we proceed uh somebody has a question in chat so i'm sorry if i butchered this name but um jose ramon asks is this workshop in one of the existing learn web 3 tracks the answer is no this is actually not part of our tracks but it will end up being on learn web 3's youtube eventually so you can watch the recording there i mean on youth global's youtube and also on our youtube um and yes marco it will be reported and available perfect so what is nft is taking um it's kind of a new trend in this space we've seen uh apecoin banana coin milk coin like apecoin obviously from the board apes ecosystem banana queen from cyber cons you're one of the first people to get this thing going um milk coin from cool cats and it's basically an attempt at merging the nft ecosystem with the defy ecosystem and the main use case is you can provide exposure to your ecosystem beyond like your five 10k uh nft holders um and this allows you to also like you can integrate the crc 20 token into future projects and whatnot so the possibilities are really endless right you can keep building utility for this token you can kind of incentivize your long-term nft holders by um like having them stake their nft and give out the token mint future things using only the erc20 token so creeps was a project that uh minted out a few months ago and the follow-on mints they did like future generations of their project and sort of side projects um it was they only allowed minting in their tokens so you couldn't mint with ease and the only way to get their token was basically be staking or buy it off of secondary essentially um it allows you it allows users to kind of borrow against these tokens and again like provide exposure beyond the 10k nfts um so sora is asking so it's basically an erc20 and a erc721 how is this different from an erc 1155 well it's different because we're not like we're not combining the two per se like in erc 1155 would what we're saying is you have an nft collection that you already launched and like it's sold out and you have a bunch of folders and you want to introduce like a token in the ecosystem to kind of give people more exposure to your ecosystem without needing to buy a like complete nfv like board apps for example right a board costs over 100 ease and you can't expect everyone to be able to afford that so the currently the cheapest way to get exposure to the board ap ecosystem is through a coin um right that's what we're trying to do and the ape coin like apart from the initial airdrop the way you get it is people with apes can stake their apes to get a coin and then sell it on secondary so that's what we're kind of going for here so um looks like i forgot to change the title of this slide but this should be building a game fight contract um but roughly what we're gonna be doing is so we are limited on time so i have some things i've already kind of pre-built and some things that we're gonna do live right so we have an nft collection um we're not going to be building this live we i have the code for it already and i'll give it to you in a second um today live we're going to be building out this taking contract mainly and the idea is any nft holder can kind of stake one or multiple nfts in the contract um they're going to be earning a yield of a thousand tokens a day um it's pretty basic while the entities are in the same yield they can unstake at any time and they can claim their uh tokens that they've accumulated at that point at any time so let's get started um so i want you if you if you guys are going to be coding along i want you to kind of go to this link github.com i'm going to post it on chat as well by the way so github.com slash learnweb3do hack the money workshop and when you go to this when you clone this repo you will find there is it's a hardhat project that uses typescript and there are um i created like some boilerplate files and a few basic uh scripts i will go over them right now so let's actually just switch to vs code and let's kind of take a look at what's already here before we uh proceed further perfect so the first thing is there's an nft contract it's called nft dot sol it's a super simple erc71721 nothing fancy at all just for the sake of the tutorial all it does is it inherits from your c721 it has a certain number of macs and ft's and anybody can come and mint it for free no limitations at all um obviously if you're doing this in a for a real project or an fp contract it's probably more complicated than that but it doesn't matter as long as it's a erc721 it doesn't matter this is just for demonstration the second contract i kind of have here is the nft staker and this is completely empty um and because we're going to be coding this live today and there's nothing else in this contract right now except just the imports we're going to be using and the basic declaration of the contract itself um other than that there is a deployment script we can come back to this but basically there's a deployment script to deploy both of these contracts and i created a few different hard hat tasks that are gonna come in useful later on um if you're not familiar with hardhat tasks they're basically a way to kind of do things in the console in the terminal with hard hats like calling smart contract functions and whatnot or doing something on the ethereum network so we're gonna use this for testing and i'm going to demonstrate that the contract actually works and i'm not scamming you guys here after we are done writing this but we can get into these more later um if you're absolutely new to hard hat tasks the the hardhat documentation provides a very good overview of this we will likely not have enough time to go super deep into how exactly these tasks are working but feel free to go through this code there's not too many there's only like five or six and they're pretty straightforward all right let's get started with the actual code so nft is taker so let's try to think about like um what do we need what do we need to build an nf3 staking contract right um people think it's some sort of like uh so huxwell is asking the private key is an end dot example this is not a real private key um if you look at it it's just abc 123 adc123abc12p it's just like the default one that hard hat generates for you and instead of a new project don't worry i'm not leaking my main net funds to you all all right so what do we need for an fp staker we need um well obviously we need a way for people to stake uh one or more nfps and then every 24 hours um they should be getting 1000 tokens and this should be also like prorated right so you if somebody only stakes for like half a day or like one hour you you shouldn't just get zero you should still get like a fraction of the thousand tokens um oh you want me to zoom in for sure let me know if that is okay perfect so yeah we need a way for people to stake one or more nfts um every 24 hours that are going to be getting a thousand tokens uh this should be prorated for smaller times and then we need a way for people to unstake and we need a way for people to claim those tokens right um so like what kind of interactions is the contract going to need we will kind of figure it out as we go but there are some things that we obviously need so we know that we are going to somehow need to talk to the nft contract kind of to do things like transferring nfts in and out so you probably would want to keep a variable for that somewhere and then we probably want to keep track of like every user's stake how many nfps they've staked what are the token ids of those nfps um how much tokens have they accumulated over time so we could probably go with something like a struct or a staker and um yeah the rest for us will figure out as we go so for these two things i'm just going to define them right now so we import if you notice we imported the interface for erc 721 so i can just do irc 721 nfp contract and this is going to be pointing to our nfte contract and let's define the stakers product what do we need here we need um we need to track how much yield are they earning right so curve yield is like uh like if you have one nft state you're getting a thousand tokens every 24 hours but if you have two nfd staked um you're getting 2 000 tokens every 24 hours and 5 is 5000 tokens every time so on so what is their current yield um carl is asking chad so what are these state nfks used for in the decks the staked tokens are used for liquidity um so in this case they're not used for like we're not trying to build a decks right we're trying to build um a way to sort of extend the utility of your ecosystem and kind of give more people exposure to your ecosystem so it's very similar to again like board apes doing a coin or uh milk token from cool cats and so on like they're not necessarily trying to build a debt so you can take a coin and put that on a debts if you want but the way to get eight coin is by staking your apes in the apes taking contract and it often times it provides like um a way to get into the ecosystem without needing to committing to buy a full nft and then you can build your own utility around these tokens right like minting uh future things with these tokens or i mean possibilities are endless build utility around these tokens any way you want um yeah through minting through downloading um yeah you can set up a dao where these tokens are required for like governance voting or whatever yeah anyway so we need to track x number of tokens every 24 hours uh so like how much are they earning every 24 hours then we're gonna track um their rewards so how many tokens have they accumulated but not claimed so far right and then we're gonna keep a track of um last checkpoint so this is kind of like when was the last time rewards were calculated i'm saying um and we'll figure out why this is important shortly but we basically want to keep a timestamp of when did we last do any on-chain calculations for the rewards um and then lastly we'll just keep track of uh which nfts did they state uh so this would just be a unit array of token ids so perfect so now we have a staker struct and we need a way to like map every user to this so it's just like map an address to a stator and call it stakers right and let's also define some constants while we're at it so um let's say events constant seconds per day it's 24 hours into 60 minutes each into 60 seconds each right solidity represents time stamps in seconds uh not in milliseconds so you have to keep be mindful about that and then base yield rate um how many tokens are they getting every 24 hours um so they'll be getting like a thousand tokens and we say ether to convert it to like the 18 decimals representation but this actually means a thousand tokens um or you could just do like a thousand into 10 to the power 18 if you wanted to i just think heather makes it look a little bit cleaner but okay um all right let's let's get started and if we need anything else we'll kind of figure it out as we go so you kind of understand the thought process of where it's coming from and i'm not just doing random stuff because i have the code open in front of me um all right so let's start off with the constructor and well first things first this is an erc20 contract because we are going to be sort of minting new tokens right so we need to be able to call the erc20 constructor and the erc20 constructor takes two things a name and a symbol um so we do need a name and a symbol coming in from our constructor as well so that we can pass it on um that's one thing and secondly we need an address to the nfpe contract uh so that we can file functions on it um so i'm gonna take that address there as well and in our constructor i'm just going to say nfp contract equals irc 721 all right um fairly straightforward nothing special uh just constructs an erc20 and then creates a pointer to the nfte contract this one cool um now i mentioned we need basically three functions really to get this going so we need a state i'm just going to declare them and then we can figure out what to do with them so we need a state function it needs to be public we need an unstate function it also needs to be public and we need a plane function which also needs to be public right so in staking i mentioned that we can stake one or more nfps in the same transaction right so what we want from the user is we probably we we're gonna ask them for which token ids they want to stake right so it could be one it could be 10 however many they want and we can do something with these token ids so let's let's think about what it means to start staking right so first things first um anything related to this we probably want to check values or right values in the destruct so i'm going to say sneaker or a user is stakers message.sender all right let's load up their struct from storage and i'll keep a local variable to keep track of their current yield because this is going to be modified um because if there's taking more tokens their yield is going to update and then let's loop over all the token ids they sent us and do some checks on them uh like making sure that they are the owner of those tokens and whatnot so we do 4 and 256 i equals 0. i is less than length and i plus plus right so first thing we need to ensure that they actually own that nft before they can stake it so we're gonna require on the nfp contract that owner of uh every erc20 oh sorry erc721 contract has this function called owner of that just returns the owner of a token id so we need to require that the owner of this token id oops sorry new keyboard getting used to it um owner of this kogen id is actually just message.sender and nobody else otherwise we give an error saying not owned all right and then if they do own it um then that's that's pretty much it like we don't need to do anything else anything other special um we what we can do is we can transfer the nft from their account to our account uh note that this doesn't mean they need to approve our contract beforehand but more on that later um but yeah so we transfer the nfp out from their account to this contract and then um one thing we actually want to do is we want to keep track of the original nft owners right so after somebody stakes it if you call the owner of function it's going to say that this contract is the owner of that nfc and um that's not super great because we want an easy way to check when unstaking for example who the original owner of someone was uh some nfp was so i'm gonna add a second mapping over here um that's gonna go from you in 256 to addresses and this is just going to store token owners right so token id to address so once we transfer the nft from their wallet into our contract you can update token owners to say that um so the original token owner for this token id is actually message.sender so you can come back to them later on and assuming all of this is fine we can update their yield and increase it by our base yield rate which is a thousand tokens every 24 hours and lastly i'm going to update the store the staker struct to include this token id as part of the state nfps array perfect um cool and so we go in a loop we do a bunch of things we transfer out all the nfts into the contract we update the token owners list we update their yield and we push the stake then they took an id into the staked nfps uh list what now um so we need a way to kind of um tell the contract like hey like um actually let's let's think about this right so i mentioned earlier we have a variable called rewards where we're gonna keep track of how many tokens are have they already accumulated right and also a last checkpoint about when was the last time rewards were calculated on chain so why do we need this right um so as you might know like in solidity units have a default value of zero so when we first start off and we first create this struct if it's a new user um both of these values are going to start off at zero right and solidity also doesn't have a way to like kind of do things on its own right like contracts cannot just randomly um start firing transactions or start firing functions right they somebody needs to execute a transaction from the external world and pay gas for it so calculating rewards on chain like um you can only do it in very certain situations typically front end like if you go to like a staking pool today and they have like this number updating like live super fast on the front end um that's not happening on chain that's just happening on the front end um but on chain calculations like you need somebody to trigger it you need somebody to pay the gas to do the math and update those values right so instead of kind of making like explicit functions like hey calculate my rewards again um what we can do is we can every time the user interacts with the contract so if they're staking if they're unstaking um those are really the only two core functions so every time they do that we just calculate the rewards again as just as part of that transaction um so yeah i i hope that made sense um why we want to do that so i'm gonna create like a function i will keep it empty for now um let's call it accumulate and we will fill this out later we will think about what the actual calculation needs to be but for now what i'm just gonna say is after staking we accumulate any of the rewards they got oh actually this is another great point right so imagine you'd had one nft staked for the longest time like five days and then you come in and you take a second one at this point we need to do an on-chain calculation because we need to say that in the last five days you got five thousand tokens because from this point on your yield is going to be calculated based on the stake of two nfds not one in ft anymore and if we don't do that calculation right now future calculations might be messed up because we don't know how much time was there only one nfd and how much time were there two nfds so before we actually finish the staking function and increase the user's yield we need to accumulate the rewards and then we say okay so their yield is now updated to this new yield that we've been adding to the entire time and that's when the function actually finishes so if you had one staked um you have like let's say like you staked one early on and then for five days later you come around you take a second one so we accumulate all your rewards for the one you had in the last five days and then update your yield for the future for whenever you calculate your rewards again um and accumulate is just gonna kind of play around with two values right it's gonna play around with rewards and last checkpoint um so we can actually kind of do it right now so last checkpoint is um let's actually let's load up the um uh yeah actually so the last checkpoint is just going to get updated to like currentblock.timestamp and rewards are going to be calculated based on a formula and it's a pretty simple formula but i'm going to create a helper function for it just to keep it a little bit cleaner so get rewards taker this can just be a view function and what we need here is let's take this user okay so we load up the sticker in memory um now there's a couple of things first of all there's a there's an edge case here where if user.lastcheckpoint is equal to zero you actually want to return zero and guess why that is does anybody know why this is i'm gonna move on to writing the rest of the code try to answer me in chat if nobody answers i'll explain why uh why we need this edge case over here otherwise the normal formula for this is basically we calculate how much time has been spent so far um like in seconds we multiply it by how much yield the user makes in 24 hours and then divide it by the number of seconds in 24 hours um this might make more sense if i write it so we take log.timestamp and we like to block the timestamp minus user.lastcheckpoint right so this will give you how much time is left uh how much time has passed since the last time rewards were calculated and we multiply it by user dot current yield and current yield is based on how many tokens they are in every 24 hours but it's not necessary that 24 hours have already passed or maybe like more than 24 hours have passed actually um it's not always an exact multiple so we take this and then we divide it by the number of seconds per day and this basically you can think of like this divided by this as the yield per second and you're multiplying it by how many seconds have passed uh since the last calculation okay so we have a few different answers for last checkpoint um yeah pretty much all of you are basically right um so yeah the last checkpoint is zero we don't want to return anything because there's like log dot times time minus last checkpoint will be like a huge huge huge number and this just basically means that they're staking something for the very first time so because the only time this is true is when they literally just come in and stake the first token and accumulate gets called the very first time uh so we want to return zero to prevent them from becoming an overnight veil than that this is the general formula for accumulation um so yield per second multiplied by the number of seconds that have passed and in accumulate we just update their current rewards and we add um these many awards to their account basically perfect cool so that's actually that's actually all we have for staking um let me just do one final quick recap and then i'm going to try to rush through a little bit through unstake we're at we're about 30 minutes into the talk i want to wrap this up in the next 15-20 minutes hopefully and leave some time for questions so yeah what happens in staking load the user storage keep a local copy of their yield i mean you could replace this by just doing user dot correct actually no you can't you can't do that because you want to accumulate um and also like reading and writing from storage variables is expensive in solidity so it's better if you have like a local copy of the variable if you're updating something in a loop and then just update the storage variable later on outside the loop but anyway i'm beside the point we have how much yield are the currently earning we loop over all the tokens they want to stake if they are the owner of all those tokens we take all those nfts into our contract update our token owners list update their yield add that token id to the list of nfds they staked accumulate any rewards um from the past and then update the yield they're going to be earning from now on perfect unstake is actually going to end up looking decently similar to staking um so oops sorry new keyboard problems i bought a like much smaller keyboard than i previously had so i keep hitting buttons on accident because i'm not used to the size but i'm trying i'm trying okay so unstake as well like they could be understating one token more than one token so you're gonna take an array right um i'm gonna load up these faker struct from storage for easier access and similarly i'm gonna keep track of their uh how much yield are they currently earning in a local copy and again we're gonna loop over um we're gonna loop over uh all the kubernetes dimension so for even if i equals zero is less than length i plus plus um [Music] the list says i guess you should calculate the words first and then update last checkpoint um uh it should it shouldn't make a difference um oh oh sorry you're right you're absolutely right my bad yes if i did not if i calc if i updated last checkpoint before calculating rewards this would just turn out to be zero nice cat sorry uh that was absolutely my bad thank you thank you for catching that malaysia um anyway so we loop over the tokens that gotham is asking wouldn't that be a waste of gas i'm not 100 sure what you're referring to here um but happy to answer if you could expand on that a little bit more but yeah so unstake we're going to loop over the tokens they want they wish to unstake right and well first of all we need to make sure that um they were like the original owner of this token so if we do have this token id in our contract um we should have the original owner for it in token owners array and otherwise we give not original owner right and actually just to be safe we can also add a other second check saying um in case you missed this line but i don't think this is super important because you will see why but we can check if token id is i the owner of the nfv currently must be our smartphone fact than nobody else um actually yeah maybe maybe maybe if you if you're a smart contract further sends the nft's out to somebody else for some reason um you can only understate if the contract still actually has it so we check that the nfd is actually staked and that the person asking to unstate was the actual original owner right and if um and since we're doing this in a loop um we'll say if user dot current yield is not equal to zero yet um this should be if yield is not equal to zero sorry um and in that case we do yield minus equals base yield rate so for every token you unstake uh you get like a thousand tokens less every 24 hours right and then and then we actually need to do something um a little bit actually hmm you know what i'm thinking we can actually save a lot of gas on this i don't know what i was thinking when i made this uh sorry it was late we actually don't need to keep track of every single token id that they're staking there's no real point to doing that and it's just a waste of gas and storage um now that i look at it with a fresh set of ice but okay so for every token they on stake would reduce their yield and then really the only thing we need to do is send the nft back to them right so nftcontract dot save transfer from um this smart contract over to message.sender's address over to token id and like tokenity's eye and once again before we actually update their yield in the struct we will accumulate any rewards they might have gotten up until this point so do an onscreen calculation again and then update user dot error yield equal zeal all right um perfect so it doesn't make sense so let's do a quick recap so you load these struct from storage create a local copy of how much yield are they earning right now um we loop over all the token ids they want to unstake ensure that they were the original owner of that token id and ensure that our contract actually owns that token id right and at this point we should actually also be updating token owners token ids i to just be equal to address zero um because they might sell the nfp and then come back later on and then do some weird stuff but okay um let's just do that and actually we'll just delete it or delete it reset it to zeros anyway so update the owner remove their ownership from the token owners mapping uh update our local copy of the yield so for every nft they unstake we reduce their yield by a thousand tokens and then transfer the nfp out from our contract to their address and before updating their yield in storage we accumulate any rewards they've gotten up until that point and then we are done with the unstaking function perfect and the last one is actually the simplest claim is super simple um claim all we really need to do in claim is that we take up uh we figure out like how many rewards have they currently earned right so they have some rewards that we calculated at some point in the past but before they claim we're gonna accumulate the rewards once more to make sure we're using the latest values so we accumulate the rewards and then we just need to mint them so we message we meant some tokens prc 20 tokens to message.sender whereas user.boards and then we update user.rewards equals 0. you can mark this as a non-re-entrant just to prevent from reentrancy attacks over here actually if the user receiving this token is like a contract they could do some funky stuff with it maybe um yeah um should be but for for right now we're not gonna do any reinforcing going on here okay so yeah this is super simple right we accumulated the rewards we meant that many um that many tokens to message that center and we update the rewards okay so jose ramon is asking a very good question what about the well-known warning for not using block.timestamp for time calculations is this taking formula used in production okay so the reason people tell you not to use block.timestamp is actually not that it's like completely bad right like miners have uh the power to kind of change it a little bit if if it benefits them a decent amount right because uh when miners propose a block they can kind of update the timestamp to be like a couple minutes ahead or a couple of minutes before than it actually was if doing that somehow uh is incentivizing them because some contractors trying to use that value to do something so typically um block.timestamp is something that's we don't worry about we we don't use or we don't recommend if we're trying to do calculations within like short time frames and also if it's like short time frames but large incentives to kind of try to cheat that um in this case we were kind of like if you if you bump up like block the timestamp a couple minutes up or down it's barely going to make a difference to how many tokens you're earning just because like um you're not really earning that many tokens every second and having a couple minutes up or down it doesn't really change that much and uh miners would typically not care about earning like for example like five more eight point than they would have um if they hadn't done that um so in this case it's usually fine there are sort of nfd's taking contracts in production on mainnet right now that do um that do use this formula or like similar formulas so in this case it should be it should be fine don't worry about it too much huxwell is asking why are we using a memory locate memory variable oh um okay well huxley is asking why are we using a memory variable here but a storage variable here um well this is because sorry is somebody talking i can't hear you um okay the get rewards function looks kind of sus you can impersonate another address and get the rewards well this is a view function this is not doing anything this is just calculating um the rewards for a certain um for a certain address it's not like irresponsible for sending you any tokens it's not responsible for updating any storage values or anything like that it's just calculating how many rewards a person has gathered and it's just a view function the actual accumulation only happens in stake unstake and claim in which case you only call accumulate and get rewards for the person calling those functions itself so it should be okay um okay huxwell it looks like somebody answered your question stories versus memory can be a confusing topic i understand um probably don't have enough time to go super deep into it but since we're not trying to change any variables persistently we don't need to use storage and storage is more expensive um um yes lewis you're right i did mention that you probably want to use a reentrancy guard here actually but then i was just thinking about erc20 contracts um not really having a kind of like uh kind of like a hook uh to notify the recipients when they receive the um token so like there is no function being called when they receive the erc20 token re-entrance is very common if you're sending eth because then the contract can just implement a fallback function or if you're even sending nfps uh they can implement the on 721 received hook but in erc20s there is no such hook so it shouldn't matter but you could apply a re-entrancy modifier here if you wanted to just to be safe but to my knowledge um i don't think there is a hook for erc 20 transfer security i forget where it used to be located okay contracts um security entrance regard okay open zeppelin contracts security reinforce and then we can apply non-reentrant to claim okay um can you leonard is asking can you come back on the top of the code um so oops what is the name that's not if i spell it wrong i'll do anything here yes yes okay so um what i need the receiver contract is erc777 it will also implement drc20 no that is fine that's not what i'm saying like it can implement the rc20 that is fine i'm just saying there is no erc20 doesn't have a hook uh that gets called when you transfer something so if i'm sending you or a contract an erc20 token hi so it looks like hardik's internet went out for a second uh we're just gonna wait a couple seconds for him to come back online thanks everyone for your patience so we're just going to wait a couple moments for hardik to rejoin as his internet comes back hey guys i'm back so sorry about this live demo issues um did not expect this to happen but my internet just died and i had to rejoin um can you guys see my screen somebody let me know if you see my screen looks great perfect thank you sorry about this guys um so yeah um i forgot what we were talking about um but yeah i think i was saying that erc20 doesn't have a transfer hook so it should be fine i mean worst case scenario we we did add the non-re-entrant modifier so in case the implementation gets updated to have a transfer hook then this will stop re-inferency anyway um yeah um i kind of want to we have like 10 minutes left in the demo i kind of want to quickly start showing that this actually works uh while we also answer questions on zoom so let's compile these contracts and hopefully they compile um we're going to be doing all testing on a local hard hat note just to keep things fast and smooth perfect so they compiled and what i'm going to do is i'm going to start up a local hard hat node using npx hardhat node this is the local test environment um perfect there we go i'm gonna open another tab here a little bit okay let's go perfect so um i wrote a bunch of tasks as i showed you earlier um so essentially i have some commands that i pre-configured to be able to demo to you so one of them it's free mint free nft which we can use to like win the free nft from the nft contract and then we have a couple of helpers to get your nfp balance get your token balance um we have one to set an approval so since we're transferring tokens in and out sorry transferring nfps um in and out of the staker contract um you need to provide approval over your nfps to these taker contracts so they can move nfps from your account um and then we just have three more functions for state unstake and claim they don't do anything special they just really just call those functions with arguments that provide so i'm going to be using these to kind of show show it to you how it works all right so um before we do any of this let's deploy our contracts to the local network so i'm going to run the deployment script it's going to first deploy the nft collection and then it's going to deploy the sticking contract all right so keep a note of these two addresses um if you're following it live it may be different on your machines but all right so first things first we want to mint a free nfp so we have something we can stake and then stake i'm going to run this task successfully minted nft and all this time like we can look at the hardhat node that transactions are being called and blocks are being mined on our local node we can check that we actually got it by doing get nft balance and this should say that i have one yes i have one nfps and when starting out i don't have any tokens i don't have any tokens i've earned from staking because i haven't staked anything yet so i own zero staked nifty tokens so um before i start staking i need to set approval um on the staking contract to transfer my nfps in and out so actually just in really i guess and now let's mint a couple more free nfps so we can experiment with staking multiple removing one removing multiple and so on all right so i'm gonna stake one token to start off with so this this hardhat test just takes in a list of token ids which are comma separated so i can do like one two three and so on um i'm just going to take one token for now uh it'll be token id1 the way the nfp contract is implemented and oops transfer to a non-implementer oh of course i need to add on erc 721 received to our staking contract to let our nuclear contract know that we are safe to receive 721 tokens um i'm just going to copy it because this is nothing special actually um if you're not familiar with this it's just a magic value function it returns a very specific set of four bytes which lets erc 721 contracts know that it is safe to send 721 tokens to the smart contract um but unfortunately it does mean we're gonna have to redeploy our contracts and start from the top i forgot to add that okay so let's let's deploy again okay it's hard to have run deploy localhost all right our node is running and perfect compiled and it deployed all right i'm going to mint a couple nfps again mint one mix two all right and let's get back so let's start a state token id1 and oh this time i did not give approval set up revolverall first uh it said transfer caller is not approved so makes sense now let's try to stake took an id one perfect so we staked one um and we're earning rewards like as we speak right so because the rewards get prorated every second i'm earning like a minuscule amount of tokens and let's try to um let's try to unstake this token back and this should stop our rewards from accumulating and we'll try to we'll claim those rewards and we'll stake two tokens back again so let's do a claim so before this i had zero staked nfp tokens in my wallet once i claim it um and i do if it's hard to get token balance i should have like a non-zero amount right and it's going to be represented in way so this is represented in like 18 decimal places so it's actually like a much like if you convert it to um like pure token representation it's like much smaller than a thousand tokens this is represented in 18 decimal places so divide this by 10 to the power of 18. and if i get my nft balance now you'll see i have both the nfps on me because i unstaked everything now this time let's take both of them together let's take token 81 and open id2 and we'll let it accumulate some rewards for a little bit um we can check our nfp balance to see that we have zero nfts right now because they got transferred to the staking contract and instead of unstaking both let's just unstake one of them let's just unstake token id2 we're like right on dot really right on that of the time um all right and claim some more tokens and we should have a slightly higher token balance than we previously did yeah um so we had two tokens and we roughly let them in for the same amount of time like a few seconds and 15 20 seconds maybe each but this time we had two tokens accumulating rewards so we got like three something and we added like six something to it because we doubled the stake ended up at nine something um you try to convert this actually i'm going to go to eat converter.com go here put it in as way so we have like less than one token so far really um which makes sense we have like 0.98 tokens in the amount of time we've been staked but yeah that's that's basically it we're right on time so i'm gonna basically stop here if you're interested in looking at this code the full code is also available at if you go into the repo hack the money workshop there's two branches over here there's the main branch that i pointed you guys to earlier which has the starter code but there is a second branch completed which has the full code in case you guys want to take a look at it or work with it in the hackathon build a game fire project in the hackathon but yeah thank you everyone for coming um i really appreciated having you guys here um q a we did that if you want more of these tutorials i run learn web3 so you can join 25 000 other builders for free it's a completely free course if you're looking to get into webft and start building and i wish you guys the best of luck in your hackathon and anna over to you awesome thank you so much hardik that was super super interesting um really engaging i i like i'm sure everyone loved it um so thank you so much for your time for doing this workshop with everyone um yeah for the rest of you we have some couple more workshops um today we have um teller and badger dao so hope to see your faces there as well and otherwise we'll see you at workshops tomorrow and the kickoff on friday with that being said have a great rest of your day evening morning wherever you are sorry about the internet issues all worked out see you guys 