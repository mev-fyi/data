hey everyone uh yeah thanks for having me um i'm kevin oh i'm wearing many hats at polywrap but uh in general i do developer relations engineer uh software engineering and some operations work so here today i'm going to talk about our project polywrap and our goal is to become the universal web3 integration standard before i dive into the tool chain i just want to talk about the history for a bit polyrap was first conceived at hackfest in august 2020 by jordan caesar roberto and ori and it was elected as a finalist at the hackathon which gave the project a lot of attention it gave it the momentum it needed to grow into a dao which is a decentralized autonomous organization with 60 plus members we were able to raise funding attract talented developers and some amazing launch partners some of our launch partners include wallet connect fleek gnosis three bucks labs pocket network tourists and many more um just a note about our launch partners these are partners that have been helping us during our pre-alpha and the ways they help us is you know reviewing our documentation helping us with development doing press releases and a lot of other things so yeah if any of you are watching any of launch partners are watching thanks so much um and some other news where we've been working on pre-alpha and our alpha version will be releasing in about a month and jordan one of the original developers on polyrap will be speaking at youth cc in paris later this month so polywraps solve what we call the web3 integration problem so how do we define integration integration for web3 developer is if you want to integrate protocol business logic let's say like unit swap or make your douse um like unit 12 swap function or add liquidity functions or make your dials mint die or you know deposit collateral if you want those into your own decentralized application that's what integration is in web3 and it's difficult today because of the tools that we have and to really understand web3 integration we have to start with web 2 and what integration looks like in the web 2 era so in web 2 if you're a web 2 developer and you want to integrate api logic into your application for example reddit twitter google or stripe all you have to do is send a rest a query to a rest endpoint and for example twitter would tweet on your behalf and it's it's fairly easy to do um there's a lot of tools for this and there's a lot of standards because um you know it's been around for a long time and you know exactly where to send the fetch requests with web3 centralized servers are replaced by decentralized networks like ipfs or the ethereum blockchain um so so uh protocol to interact with protocols uh what protocol developers have done is create sdks that you can integrate into your decentralized application and most of these sdks are in javascript so all the business logic that used to live on centralized servers are now bundled into your application allowing you to interact with protocols like do queries or mutations and while this is great there are a lot of issues when it comes to these types of sdks especially with javascript so what are the issues with javascript one it's not standardized so if you were trying to integrate say the business logic of uni swap maker and gnosis into your app they're all written in in different ways and you'll find like it's going to be difficult for them to be composable the second reason is that it's not scalable so when you want to integrate more and more business logic into your decentralized app you'll have to download more sdks into the dap this is going to bloat the dap increase the bundle size and just make the app run a little bit slower the reason is javascript slow and insecure so we all know that in the crypto space and in the blockchain space that security is paramount to the success of any protocol so this is a huge factor too and lastly javascript is not multi-platform the javascript is a language that's written primarily for the web develop developers and if you wanted to say developer your app on a drone or some other iot device it's going to be a bit harder so what what a what a protocol developer has to do is develop maybe another sdk in another language and this presents another issue because now they have to um maintain multiple sdks at once which increases like the the maintenance costs so our solution to the web3 integration problem is polywrap so with polywrap we're trying to take the ease of web 2 development and how easy it was to integrate api logic into your applications without sacrificing decentralization so the idea is that you would write a protocol business logic and bundle it into a what we call a polywrapper or a wrapper and then deploy that wrapper to the centralized endpoint like ipfs then your client when it launches would download these wrappers at runtime um and be able to use the exported wasn't modules so i'll go into more detail about what that all means and for our example we'll be using uni swap so we developed a uni swap wrapper and what it is and this will be the same for any um rapper whether it's union swap or gnosis or any other protocol but the the composition of the wrapper is pretty similar so you have a manifest file in yamo format and all this does is that it orchestrates the package then you have a graphql schema file so wrap wrappers are queried at runtime um using graphql in your application so this graphql schema file will provide the types and the the the shape of the the queries that you can send to this package and most importantly it contains the business logic of union swap in wilds and modules so webassembly allows for exporting functions that can be used in your javascript application so all this is done at runtime you can build your webassembly business logic using different language that compiles bouncy web assembly so for example right now we have support for assembly script which compiles down to webassembly and then once you wrote all your business logic um and the graphql schema you can deploy to the centralized endpoint in this example we're using ipfs but we also have support for enfs and more support for other methods coming soon so here's what happens at runtime your application launches if it's enabled with a polywrap then the polywrap standard will will download the business lot the the wrapper at runtime which includes the business logic in webassembly modules webassembly the webassembly modules export functions like say swapper functions that let you add liquidity and then they could be used in your application so unlike a javascript sk none of the business logic is bundled into your application it's all at runtime and since webassembly doesn't assume running in a web environment there's potential for your application to use business logic in any type of environment so today we have support for web apps but it's possible to you know run daps on your apple watch for example or the phone or even a drone and again webassembly it can be written in just one language that compiles down to webassembly so this could be assembly script but pretty soon we have support for rust and go um so unlike uh like protocol developers creating sdks they don't have to create a separate one for javascript or python and be able to and be forced to maintain all those they just need to write one sdk in one language so yeah there's unlimited possibilities for um when it comes to polywrap today we have about maybe six rappers deployed to ipfs with the major ones being uni swap and ens but um we are going to be developing more and we're we're going to have bounties open for uh people to contribute to the project and create their own wrappers and deploy to ipfs to expand the ecosystem so now i'm going to talk about the developer experience of polywrap and how you would integrate it into your your decentralized application or that so all you have to do um a few steps so the first is to install the client so npm install at polygraph slash client-gas and by the way this is assuming you're you're creating a javascript application today we have the client in javascript but we're writing it for python in the future too and second any protocol is just a request away but once you instantiate the client you can call the query methods on it so here where we have a query method and it accepts one object which has two properties a uri that points to the wrapper that you want to use so in this case we want to use the unit swab business logic so we're pointing to where the uni-swap business logic is being deployed which is e s slash api.uniflop.edu and then in the the query property the value is a string that that shows which which method we want to use from the business logic so here you can specify either mutation or query here we're using mutation and we're showing that it's a just a generic swap function now building your wrapper this is if you're a protocol dev team that wants to build your wrapper and deploy to a decentralized endpoint for other people to use so first you would define your schema and graph the graphql file and on the left here we have the the type which is a generic query and then generic method with arguments custom type and it returns a string and then on the right you would implement walls and functions so what you see on the right here is a language called assembly script and it's and you notice that if you're from a javascript or typescript background it looks very similar so if you have a typescript background you can you'll most likely be able to implement something like this but what we're doing here is importing the custom types that we wrote from w3 w3 is just a custom folder that holds code generated types that you can use in your your wasm implementation and here we're defining different functions inside the that would hold the business logic and you can customize it however you want and it's highly composable so this means that you're able to import other wrappers that are deployed into your own wrapper uh which is really cool so here on the left we're importing like a generic query from another wrapper that's deployed into our application and then on the wrap on the right we're uh able to import that query and use its methods so just reviewing the benefits of using polywrap it's multi-platform meaning that it can run in any environment that can execute wads and functions it's hyper composable meaning that you have other wrappers that you can lean on as dependencies and put into your application it's fast and secure because it uses web webassembly the webassembly is a low-level language and it runs very quickly in the browser and all webassembly modules are given allocated their own memory to use so it's pretty secure and it's scalable because no business logic is um bundled into your application the only thing you have to install in a javascript application is the javascript client well so now i'll head over to our demo all right um what you see here is the uni v2 swap page except that our team uh went through the entire interface code base for the swap swap page and we replaced all the unisop javascript sdk with our own polywrap functions which was a huge task so i'm going to show you how the swap works but first i want to show you the deployed polywrap the univ2 polywrap business logic so we deployed it to enf which is the ethereum name service and if we go down here you'll see this is going to be the uri that we ping with graphql and you can see the content that it resolves to in this case it's an ipfs hash and this ipfs is going to hold the business logic so if i click this it'll send me over to ipfs and you can see this is what we consider the wrapper so it has the yaml files that orchestrate the entire package again it has the graphql schema that provides the type and the the shape of the queries that you can send to the package and most importantly it has the web assembly modules which were originally written in assembly script but compiled down to webassembly we separated mutation which is functions that provide write operations with queries which is just allows you to fetch data from the protocol so this package is downloaded at runtime and just showing you the code here on the top here we have three functions that are called when you perform a swap best trade exact swap call parameters and exec call and this is what the code looks like in your decentralized app so here after you instantiate the polywrap client you can call the query methods on it and we're pointing to the ens uri that you saw earlier which resolves to the the polywrapper and then you can call queries so here we're calling query and we're specifying the function that we want to use in the exported the instantiated webassembly module that exports these functions and here we have a variables objects that can hold variables to be injected in this template literal so if i go over to the variables tab you can see the different variables that are being put into the query i'm going to perform a swap here just wait a little bit and then click this to perform the swap and then metamask will pop up and then we'll just wait for a little bit for the transaction to confirm but yeah what you just saw is um all the the business logic of uni swap b2 happening at runtime so if we open etherscan here we can see that the transaction is successful well all right well thank you everyone um this has been pretty fun and uh you know if you want you can follow me on discord and twitter is on the bottom left here or please visit our website we're looking for contributors and uh looking for people to join our community the community is super supportive like if you have any questions with building your polywrap applications or wrappers you can just ping me or anyone in the channel so yeah thank you so much 