foreign [Music] [Music] foreign [Music] [Music] [Music] foreign [Music] foreign [Music] foreign [Music] [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] foreign [Music] [Music] foreign [Music] foreign [Music] [Music] foreign [Music] foreign [Music] [Music] [Music] foreign [Music] [Music] [Music] [Music] [Music] foreign [Music] [Music] [Music] foreign [Music] foreign [Music] foreign [Music] thank you [Music] thank you [Music] [Music] thank you can hear me okay yeah I think yeah it works I think we're a few minutes over time so we'll get started shortly once people are ready [Music] thanks everyone for coming in all right wait till the last few people take a seat and then we'll get started all right coming in coming in I think we've got a we've got to talk straight after this so we'll try to get started so thanks everyone if you want to take a seat and then we'll be good to go all right as you probably guessed I'm not sure where the noise is coming from I think it's coming from out there but yeah let's just begin all right yeah so my name is James and we are wax we're a team within the privacy and scaling Explorations group in the ethereum foundation and uh yeah our focus is uh well the pse's focus is enhancing ethereum through cryptographic research and we're one of the teams who's exploring a scaling solution so the privacy and scaling exploration does a lot of things around privacy but yeah our Focus initially was on scaling so in today's talk we'll be talking over the BLS signature aggregation which is where we began uh we'll be talking about user operation compression and reducing costs with that additional verifications that we'll be exploring in our V2 and also Integrations and how we can make that easier for everyone to integrate and use and then we'll conclude with the summary so let's begin with BLS signature aggregation so the problem we're trying to solve is the roll-up cost problem so we all know layer twos are cheaper but we can actually get more savings by doing something called Signature aggregation for every transaction on a layer 2 you've got the transaction data as well as the signature data that gets rolled up to layer one and that's a significant cost with BLS signature aggregation we use a different signature scheme that lets us combine every transaction signature into one so instead of having say 200 transactions with 200 signatures being rolled up only one signature needs to be rolled up so the cost reduction is quite large with for the signatures and this is possible because rather than use the protocols ecdsa signature scheme we're using a different signature scheme which needs to be verified on chain and for that we need a smart contract wallet so it's a lot to taking it once but basically the way um yeah the way that works the way I sort of visualize BLS signature aggregation is that you'll have many unique transactions um sorry many individual signatures but they can be combined together or aggregated into one basically the space of one but still give you the ability to verify that all of the individual transactions were signed by the corresponding public keys so again it's just a nice um thing mathematically that BLS does that I don't understand but we just get to use it from the outside which is quite nice so we want to make that easier for others to use and benefit from under the hood it's something like this each public key and private key um so each private Key signs a message so use the corresponding public key to verify all against the single signature but we don't need to worry too much about that overall the way we can make that work is that within the wallet we'll need something that can sign with the BLS scheme and that's a client module on the left that'll then send the signed user operation as we're calling it to an aggregator which will combine many different user operations and BLS signatures into one and then submit that on the right to the smart contracts on a layer 2 which is our verification Gateway and BLS wallets that's sort of just the pieces broad brush stroke but when we zoom in a little bit this is what it looks like a Dap will propose a user operation now this terminology that we're using is 4337 terminology or account abstraction as you've probably heard of and so the user operation can consist of multiple actions those are um then yeah the DAP proposes that to the user's wallet the wallet will then sign that user operation and many while it's in parallel are obviously signing different transactions those get combined together or aggregated via the aggregation server but also there's additional compression that we do to again reduce the size of what gets rolled up so in the end basically the essence of this is we're trying to reduce the data that will get rolled up so some of the yeah we'll talk more about compression after with those bundles with that bundle of operations and the single aggregator signature we then make the call to the smart contracts that bridge across to these contracts is what we want to reduce so now that it's small we've passed the Gap we've had our savings we now need to expand it again to fully verify it so we'll have the expansion done on chain as well as the verification done once we have all those user operations verified we can then get each smart contract wallet to call its corresponding data so that's sort of the end-to-end flow but with the um yeah with the smart contract uh wallet we have to do things on chain that would normally be handled by the protocol like the nonsense gas so those are additional parameters now we had to send that we didn't have to send before so let's look at how we can do some compression to save that foreign thank you James so yeah I'm Andrew and let's talk about user op compression so I want to give some context uh zooming out um you know I'm talking about compression so let's talk about the actual bites um that we have to work with so this is what a vanilla transaction looks like to just send some eth um and about roughly the second half of this transaction data is your signature so you might imagine when we switched to using BLS signatures that the effect of that is going to be something like removing the second half of uh of these bytes however the reality is a little bit more complicated than that and so instead of going from 120 down to 60 by doing that if you just call our Gateway directly in order to process your operation your transaction data is going to look like this instead um so what we but we can fix this problem um with compression there's quite a bit to do and then we can realize the benefits of those BLS signatures and also take it a step further and apply that compression in other ways as well for additional savings so zoom in a little bit because I don't expect anybody to just understand a Big Blob of bites like that um this is the same bites as the previous slide all of the examples by the way here are like properly encoded transactions and a couple of them are posted on chain as well and there'll be QR codes for uh viewing those on the Block Explorer um so yeah so here is just pointing out the the bits and pieces that are in there or Draw your attention to the signature which is on this slide this is the transaction on part of the transaction envelope that's around that orange data section so we're using BLS signatures and you know a different system and all that but in order to actually get this data on chain we still need an eoa transaction which means that there is still an ecdsa signature involved here and so that becomes part of the data that's shared between all of the user operations that we bundle together inside of this orange data section um so let's continue zooming in and have a look at what's inside of those bytes so this is them um so like this is the solidity ABI to specify what's going on and so we just have that little uh transfer in there and so that's represented by those red bites the ones that are in Black are our shared bytes and we compress those as well um but it's mainly about these red bites we're just currently sitting at 640 at the moment and so those bytes the compression that we can apply to those how small we can get that determines the uh like the long-term cost performance of this model um so 640 is a lot but we can also reduce that by a lot as you'll see uh some of you may be familiar with this tweet from vitalik last year we've been inspired by you know this and also from the Hubble project and also other sources um so I won't go into this in detail I don't have time um but I'm pleased to say that what we've implemented is very similar to what's represented in the ideal stateful compression in the bottom right corner there so without further ado this is what the same transaction as before looks like when compressed so we've got the link there you can go view that on the Block Explorer if you like but the main thing to to note here is the 640 bytes from a couple of slides ago are now represented in just those 17 bytes there instead um and so now that I can fit this all on one slide as well um we can have a look at what this looks like when you include multiple operations into one bundle so have a look at that empty space uh in there but uh just underneath the red bites so we're going to include two more transactions uh let's make them erc20 transfers um which is important to note that you can actually include all sorts of different transactions into the same bundle and they all benefit from the combined signature aggregation so that's what that looks like there you can see we can just slot them right in there and we have some erc20 transfers as well so continue to zoom in let's see what's actually going on with those 17 bytes how does it represent uh what's uh what's actually happening um in that operation so this is then the annotations so all of these fields I won't go through all of them all of these are variable length Fields so in particular you take for example that nonce field is only currently taking up one byte but one byte can only represent 256 different nonses so there will be a big limitation if it was only that but this just expands gracefully like all the other fields if necessary to accommodate the extra space so as you get into hundreds of nonses then you'll start using two bytes eventually you might use three bytes if you're really prolific and interior can go up as much as you need but you probably won't go more than three boats um secondly I'll draw your attention to this build is particularly special so this is representing the BLS public key of um of that account and so yeah three bytes is not enough to represent a public key and so but what we're doing instead is we're saving this data in a registry so the idea with that is that you know your BLS public key that we use to identify you that does need to get posted onto L1 at some point but what we can do is effectively it's compression we're de-duplicating that data but instead of having to do it in one within one block or like within one batch that gets rolled up like in the um the z-lib stuff that some of the chains are doing now instead we're deduplicate sorry deduplicating it across a much wider time span by just saving those bytes on chain and then we can refer to them again later um another thing that we are leaning on quite heavily with the encoding uh is this format called pseudoflow which is a format for representing decimal quantities really efficiently what this format allows us to do is if you've only got three digits of precision in your quantity say you're sending you know 0.101 if that's only three digits in there and we're we're able to represent that quantity in only two bytes if you need more more digits than that obviously sometimes you do need more digits um then it again expands gracefully and you can still do that as well and supports the full un256 range um finally on the compression side I'll leave you with this to just summarize the amount of bytes that you need for an erc20 transfer under different scenarios so in the vanilla transaction which is this is the status quo today you're looking at 150 bytes to 180 bytes depending depending on how you count them but if you use wax if you're in a bundle of five transactions uh then you're only going to have to pay for 55 bytes each and if you can aggregate into a hundred then you're only paying for 22 bytes each so this is pretty exciting we're looking at reducing the amount of cool data by almost a factor of 10 and so chorus that corresponds to being able to do 10 times as many transactions so we're pretty excited about that um all the stuff that of this compression stuff that's all implemented in our V1 contracts uh but we're also looking towards a V2 with uh some new and exciting features so to talk more about that I give you Jake thanks Andrew so next we're going to go over um for our V2 some additional verification methods we're looking into using the erc4337 kind of framework before we jump too much into that kind of talk about what kind of accounts currently exist on ethereum and verification methods we use with those the most common one you have nowadays is an externally owned account also known as an eoa uses ecdsa signatures and the same curve that Bitcoin uses um as far as for the asymmetric cryptography these commonly are hierarchical deterministic wallets and sometimes can also be multi-party computation wallets with a like shared private key um but then on the other side we also have Smart contract wallet accounts which really can use any sort of signature or like verification uh sorry signature curve that's supported inside of the evm it still commonly is going to be ecdsa but um we can really use a lot of different things such as BLS um inside of that you may commonly know existing smart contract accounts with like safe Origins and different uh protocols like that so those are kind of the two things there's a very good comparison given by the 1kx network that goes over the difference between all of these different wallets um highly recommend checking it out at another time I'm not going to go in depth into this but I really want to focus in on two advantages that smart contract walls have which is their ability to be programmed on chain and then also the composability of the different things that you can use inside of those so with waxv2 we're using erc4337 to implement using that common account abstraction spec in this kind of uh what we're going to take advantage of here we have our bundler which is very similar to the aggregator Jane mentioned James mentioned earlier which allows us to bring together those user Ops and submit them we have our entry point contract that's going to be connected to our account and then we're going to basically validate those user operations see if we're going to pay for them and then we're going to execute the actual main functionality inside of them one of the cool things about this spec is that the I account interface we use for checking and paying is very generic it basically takes in a user operation and the wallet basically will tell the entry point and the bundler whether or not it's going to work with that validated data um validation data that passes at the end as part of that user operation we have a field called Signature which is just an array of bytes and that array of bytes could even though it's commonly going to be a cryptographic signature we can really put anything we want in there that can be used for the account and for verification so now that we have this what new verifications could we use with this smart contract wallet well we could use some basic web auth maybe have a username and password accessing something but there's better things we can use such as web authen also commonly known as pass keys this is basically using asymmetric Keys similar to what we would use in ethereum and other blockchains for signing into web 2 servers and accounts it's device and domain specific and it already has support from companies such as Google Microsoft and Apple but in theory any web 2 company would be able to implement this as part of a login and so we can take advantage of the fact that those are asymmetric I mean those asymmetric keys to actually allow these to sign for a web 3 account so anyone potentially with accounts already at these places that has the web auth n could control an account using those another one is potentially using zero knowledge proofs as a way to uh sign your user Ops so on your device which is the prover you're going to have your private inputs and you're going to have an expensive computation to generate a proof we then push that proof and maybe the public signals into the signature field of that user op and then finally in the evm and that entry point our contract can go to a verifier contract and verify whether that proof is valid and whether it's going to process that user up and so in this way we can use those proofs to authorize a user op um this opens up a lot of different possibilities of different things we can do such as using new signatures and curve schemes that the evm does not support so anything we can Implement in cercom or newer DSL such as Noir can be used for example you can already do EDSA Ed DSA signatures inside of cercom so you could use that for verification in a smart contract wallet you can also use newer BLS curves like BLS 12 381 which is what the current ethereum consensus layer uses to um validate those but really we can also do anything that's provable inside of a proof as part of that verification so one thing that's being looked into there's a pending paper that will be coming out soon called contract wallet using emails is using an email as a proof meaning that someone could have a smart contract wallet and actually send transactions just using a normal email message and generating the proof that they control that email address and that the content inside actually matches the transaction they want to do but you could probably think of a lot of other things you could prove with a zero knowledge proof that you could use to verify via Smart contract wallet finally one of the cool things too with the verification is it generally is very is cheaper to do inside of the evm than maybe doing a normal solidity based verification so the gas costs sometimes are linear with the number of constraints in the circuit but some work that's being done to lower those could eventually make it log of n or constant time to verify those proofs you still have the uh the issue though on the device where the proof generation can still be very computationally expensive so what does this allow us to do um we can have multi-factor off situations where we combine and compose multiple of these together and so for an account for smaller things you might be able to use one of these methods for sending small things and if you want to upgrade the implementation or send larger amounts you would need say two of three to do this so in this example you might have an ecdsa or BL assigner your friend may be just using their email to help you and there may be a bank or institution you trust that also is a backup signer for those and so for small things like your bank paying your bills for you are you sending money um like you would on venmo or something you might only need one of these signers but if someone wants to change the signing scheme or do a recovery then you might need two or of three of these people to do it but we can have a bunch of different verification methods for that another one fun one is recovery and migration which we can have basically people move from centralized accounts to decentralized accounts progressively so for this example let's say grandma wants to play web3 poker she's a poker fiend she wants to try it out and so she can actually create an account abstraction account with her Facebook login using web authen she can then choose her best friends on Facebook to be her social recovery people in case she loses access to that counts then let's say Grandma kills it a poker and makes a ton of money now she doesn't want Facebook to be able to rug her and take all that money away so she and her friends get together and migrate her authentication to something like a hardware wallet so she can really have that secure scheme um control over those new funds and so what this really leads to is kind of almost a Cambrian explosion of different verification methods we can use this is when multicellular life kind of exploded into the world uh 600 million years ago into a wide variety of things we see today and so using things like our current signatures BLS web authent and dkps we have a lot of different new verification methods we can use but there also are a lot of cool ones we want to look into that maybe don't exist yet or maybe you will build during this hackathon or some other time and we're excited to see what those are and so to make all this easier we're going to bring on Blake to talk about Integrations thank you Jake um yeah now I want to talk about what our team is doing to actually get some of this work into developers hands and in order to do that we've been recently working on a node module called ethdk um this is a node module that we're hoping that will allow developers to easily add some of these experimental features into projects they're trying to get into end users hands um because we do know like sometimes if you're building a product for a user it could be hard to take the time to experiment or integrate a Cutting Edge feature that you don't know exactly how it works so we want to take some of that cognitive load out of the hands of the Developers um when talking about building this node module there were two things that we wanted to focus on first one is just keeping it simple um and with that we wanted to keep it simple just in like the terminology that we use it seems like for example this first one I have up here a wallet versus account seems like the ecosystem is like settling on the terminology of account over a wallet so we want to make sure our code reflects that so that users that are developing with this node module know that they're creating an account and it's a programmable smart contract account um and then another example this one's both terminology and in the functionality of this function we implemented is uh RV once our contract wallets have a form of social recovery available and in order to set that up you need to call the set recovery hash function on the actual wallet contracts and pass it a recovery hash but that requires you to know how to generate that recovery hash so in our noon module we created a separate method called set Trust an account the terminology of this better communicates what you're doing you're setting a different account that you trust to be able to recover the original account and then we also just pass two parameters we pass a recovery phrase as well as an address so that you don't have to know how to actually generate that recovery hash and then we also wanted to focus on just some sensible defaults there's a few things that we know based off of building our wallets and our aggregator that you need to do in order to get the full benefits of our tech for example as we talked about earlier the reduced costs on layer twos you actually need to be using a layer two you can't do the big BLS signature aggregation on an L1 and get the same cost benefits so we want to make sure that the developers know that they should be using an L2 and then also we want to make sure that our contracts are are already deployed and verified on the specific networks that we're trying to support so these variables can be constants within the node module that are easily exportable uh if you wanted to you could easily like override any of those defaults but we do want you to just focus on using the features and not finding of where a specific contract wallet's deployed on chain um so where are we now with each DK we currently have a beta version published to npm um and it works with our implementation of our V1 uh contracts and then we've also demoed it in our instant wallet you might be familiar with a burner wallet uh the instant wallet is just our version of a burner wallet that uses our smart contracts behind the scenes and then we are starting the uh the work on our V2 smart contracts so the hope is that we'll come out of our beta version when we have the V2 contracts available and we can also integrate some of the modules that Jake was just speaking about before me um and travel the section I just wanted to show a quick example of our V1 or our beta version of ethdk as you can see at the top I'm importing a create account function as well as the networks objects and then it's just like a few line of codes to actually create an account and then set your trusted wallet so here is I just called a create account Factory function with a couple config properties and I can await that and then print out the address and then down below I just create a recovery phrase and pick an address that I trust and then I can call the set trusted account so as you can see you don't have to know how like the contracts are actually set up you can just easily use the functionality that we're trying to get in the hands of developers but yeah we're really excited where we can go with this especially with our V2 contracts and then with this coming out of the the beta version so keep an eye on the the link on npm and I think to wrap it up I want to hand it over to John who is going to aggregate all the points that we just spoke about cool yeah thanks Blake so to wrap wrap up all that's been said yeah so wax started off to bring cheaper L2 transactions to evm chains to enable new applications and we can do this through BLS signature aggregation which can reduce the call data that gets posted to L1 by combining many signatures into a single signature but the signature aggregation by itself won't get us all the way so we need to do some cool data compression as well using the techniques that Andrew mentioned earlier in the presentation and it's important to mention that the gas savings we've spoken about can be used in addition to the gas savings from l2s there's a lot of Buzz around the design space the account abstraction opens up ERC 4337 in particular is a very unopiniated standard and gives developers a lot of choice in what they can do it's a lot of unexplored ground and as Jake mentioned or sort of anticipating or hoping there will be a Cambrian explosion as such of accounts using lots of different verification methods were in particular excited to try out web orphan and zkp email verification in our upcoming modules and you have the freedom to use these modules in various ways for example you might be able to use werewolfen as a multi-factor authentication say if you're sending a transaction that's like over five dollars you can use your web orphan then you might use your zkp email to recover your account alternatively you could even use the zkp email as your multi-factor authentication the possibilities are you know are fairly Broad and you can do all this while enjoying the cheaper transactions brought about by BLS tick aggregation and the cool data compression and at the top layer we'll have the fdk which will wrap all the BLS components together in a intuitive abstraction for developers to use so we've just about wrapped up our V1 contracts and we're looking to V2 to apply some of the Lessons Learned there and we're starting that now basically so V2 will enable BLS signature aggregation in a 4337 compatible modular smart contract wallet and you'll be able to add additional verification modules in there to enable more expressive transaction verification and recovery options cool so yeah the future of where transaction costs are going and also account ux is very exciting and we're really looking forward to Bringing these new developments to the ecosystem if you want to learn more please check out our web website at getwax.org and if you want to learn more about the PSC and what we get up to please check out applied zkp.org thank you all for listening [Applause] I'm not sure if there's time for questions or one question if anyone has no questions all right we'll wrap it up there thanks again [Music] [Music] all right can you guys hear me okay test test okay let me just start it here all right um hey guys my name is Nick Fett I'm one of the founders of teller and I'm here on behalf of gnosis chain so [Music] figure out how to click here um before I get into just what teller is I thought I'd at least I have to at least say the sponsor who brought me here in why not this chain so for those of you that don't know about no such Jane notices chain is an alternative L1 so similar to ethereum it is an evm and it's got the works so it's got a bridge explorers amms all the wallet support and I know you guys are like well why the hell do we need another L1 or another thing another chain but the truth of the matter is if you actually look at all the l2s or anything that's actually cheap they're all like really shitty there's like a multi-sig or a centralized sequencer or an admin key and they can like rug you at any point so if you want to actually build a censorship resistant application come to know Sister chain we'll we'll love you over there so okay on to teller so uh kind of how I got started with teller back in back in 2017 I was trying to build a derivatives protocol I was trying to do where you could like do you could lock Ethan to a Smart contract then you would have long and short tokens that represented like long Bitcoin short Bitcoin and I know this was like novel back in 2017 and um anyway we got an ethereum Foundation Grant to to start building that and you quickly ran into the problem of okay well who gets to say what the price of Bitcoin is and the problem is is that smart contracts can't read outside information so due to the fact that you have to be able to like replay it for all of time you know if you were reading an API if you know somebody a year down the road tried to run that smart contract function they would call the API and it would get a different result so things would break so you actually everything needs to be an input and this input is What's called the Oracle so who gets to do that is is a big problem for things obviously such as price feeds when building derivatives and then other things you know Bridges other pieces which I'll kind of get into so you know what are the oracles so back back in 2017 there actually was an oracle live on ethereum this was if you guys remember Oracle eyes this was Thomas bertani he ran Oracle eyes and he you you would like pay him a quarter or 50 cents in eighth and he would return the result of your API call and that was literally the the Oracle that people were going live with in production back then you know this was pre-chain link for everyone and that's obviously a really really bad Oracle the reason is is that if he died or if he decided to change the value or rug you you would have no recourse um so you know you can go beyond that and it's okay well how could we make that a little bit better I don't know like we trusted Thomas let's trust vitalik and you know we'll trust stunning uh so okay so we'll do a multi-sig and that can also be an Oracle and you know that's like um whenever maker started they were one of the first people with their own kind of custom Oracle and it was basically just a multi-sync they they had you know 14 people and it was a multi-stick and it and it worked um you just have the trust assumptions of a multi-sing but it basically you have to kind of rethink about how you're thinking about an Oracle and it's just how do you come to consensus on data and this is sort of the problem because it's you know in in the blockchain world we're really sort of honed to thinking about coming to consensus at like the chain level but then at the app level it's still the same way how do you come to consensus quickly on a piece of data and you obviously can't build a blockchain you know it's like now it's actually possible with Roll-Ups but like build building blockchains on top of blockchains to decentralize it gets gets really old really fast so we'll kind of go into how we solve that problem and how some of the other people are and how you can use them so what are oracles used for obviously there's there's price feeds um Bridges so Bridges or oracles if you have gnosis chain over here and ethereum over here that they don't know anything about each other you might as well be reading an API from coinbase a bridge basically just reduces the Assumption you have more generalized oracles where you can ask it any question like you know who's kind of like at the bottom prediction markets you know who's the president of the United States who won the Lakers game you can ask it these general questions or you can have very very specific oracles like what's the block header of Bitcoin next it's still an oracle but and you need some way to come to consensus around it other things you know insurance as well anything off chain anytime they talk about if you hear somebody say like oh we're gonna put real world data on Jane it's sort of this Meme and the problem is is okay well who's putting the real world data on Jane you know that's an oracle problem you probably have some centralized entity that is in charge of saying it went on chain or it went off chain and that's a problem you should maybe use tellers to decentralize that a little bit um but as we kind of go into building this you know these generalized consensus mechanisms the scalability trilemma it holds for oracles too so if you want this thing to be really really fast uh it's probably not going to be very decentralized and it's just a trade-off and so any Oracle that you guys see out there that you're thinking about using if they claim like we can you know update your price feed with instant finality every block and you're like there's there's just no way um besides the fact that it would be really really expensive to write that much data at a chain um because you can kind of think of you know if you had the question or you know like who's the president of the United States what's like a really slow Oracle if you guys remember like uh one of the original oracles out there was auger for those that you know or like gnosis but back when gnosis was a prediction market and basically what you would do is you would have all these tokens and you you would have like you would have to ask it a yes question or a no it would have to be a yes no question and then people would stake all their tokens on whether it was going to be a yes answer or a no answer and it would take like a week and that was a that was an Oracle and that was a valid it was a great way to to do it the obvious trade-off there is it's super super slow so didn't really work for Price feeds so um we we've since come to some better Solutions um which gets me now to how teller actually works um so teller it's it's kind of a simple Oracle we we really focus on how can we actually be decentralized you know we we came into this space you know if we're building on ethereum if we're building our gnosis chain if we're building on these Networks you're only as decentralized as your least decentralized point so what you want to do is make sure that the Oracle isn't that sort of centralized choking point so how can we make sure that this is decentralized in the sense that anybody can do it and anybody can validate it and so what the way our Oracle works is you you stake some teller tokens so you grab like on Main net it's like a few thousand dollars worth of teller tokens not not a crazy amount um and you lock it into a smart contract then somebody else comes and they tip they say hey I'll pay one dollar or probably on ethereum more since the gas is really really expensive I'll pay you one dollar if you submit the price of Bitcoin on chain all of those staked reporters then uh right now they're all like Mev bots on our Network they they race each other to go and submit the price of Bitcoin Unchained you you don't want to use it right away though so this is sort of the caveat that makes it slow is you actually need to validate it because there's no way for the smart contract to intrinsically know that that value is correct once you put it on chain you can put anything on chain but it's an optimistic Oracle so you put it on chain if nobody disputes it for a period of time then you can use it what is that period of time well that's up to you if you wanna if you want to YOLO it and say you know five minutes okay you can do that if you want to wait 10 minutes 15 minutes we have a mainly usually it's really really fast like a minute for a dispute just because all the other reporters are running these monitors to catch each other and because if you catch it you submit a dispute fee so it's a small fee and then if you win it gets pulled off the data gets pulled off goes to a two day long vote you can win the guy's full stake so it's very profitable to to win these disputes and um but yeah and then for the user so the way that we sort of use teller to make it really really fast is if once that data gets pulled off chain it you don't have to wait for that result you as the user don't actually care the next person would just throw it on chain and that's who your dollar would go to so it sort of just the wait period is roughly how long you are going to wait for uh dispute um all right and then your smart contract reads the data so now let's kind of get into what are just some best practices whenever doing these oracles and you know you guys are at a hackathon so I wanted to like try and keep it hackathon focused as far as what can you build with oracles what what are good use cases for a blockchain um the biggest thing and the biggest problem that most people have whenever they're starting to use an oracle is like you'll hear people with very very Niche use cases so it'll be something like uh you know I think there was one guy he wanted to do car insurance on the blockchain car insurance is really really hard and you know like he's like well could there be an oracle that says you know whether or not somebody got an accident like if you think about it who's that Oracle like who who can actually validate that and and the problem and that's a problem of you know you want it to be something that everybody can validate because once it's put on chain if you can't go actually see that that person got in a car accident you can't validate it or say anything about the truth of it so there would probably be rampant insurance fraud and this is a problem with most things so you know if you have some calculation that takes really long to run or you know if there's you know the classic the classic example is like what is it like crop insurance in Africa we're gonna make on the blockchain um you know if it whether it rains in a certain region this was this was always like one of the one of the old examples that people would do at a hackathon and the problem was always well how do you tell if it rained in a given region you know like is there it's really really hard and it's not necessarily straightforward whereas like the price of Bitcoin we all know you know we know what the price of Bitcoin is it's very very easy to tell if you lied um but that you know on the price of Bitcoin piece too um there's actually a lot of trade-offs whenever you're even defining the price of Bitcoin so for instance if you're talking about the price of Bitcoin you can have okay well what's if you say what's the price of Bitcoin on coinbase that's a different answer than what's the price of Bitcoin as a median between coinbase Kraken and binance and that's actually a different answer than what's the price of Bitcoin if you just answer it and there's actually different trade-offs for each one because the the first one what's the price of Bitcoin and coinbase super super easy to verify um and if you're you're using this D5 protocol for instance as like a hedging platform you know what exchange you're able to hedge and that and that's super useful for financial tools the downside of course is decentralization you know you know they you know that the person if you want to throw that Oracle feed you just have to go throw the API in coinbase and go go make some big trades on coinbase whereas if you just say okay well what's the price of Bitcoin and this is where that subjective data comes in in the middle okay so you know if it's just the price of Bitcoin well maybe there's like a one percent wiggle room in there you know because it's not going to be exactly the same on every exchange so you sort of have to be okay with that wiggle room but um yeah just different different sort of trade-offs you have to think about as you're putting it on we always recommend don't like any any oracles that's like oh just put in your API and we'll go get it it's like well that's that's a centralized API like you don't want to use that for your Oracle you have to think about how can you get the data without a centralized API and then you can potentially have a decentralized Oracle in the future so all right I'm going fast because I know we were started a little bit late so Gonna Keep Us on time um this is just the basics um how oracles actually work so there's several different kinds of oracles there's push oracles and pull oracles so a push Oracle is one that will push it directly to your smart contract and Implement an action a poll Oracle is one say like chain link or or teller where it updates its own smart contract and then you have to run a function and go grab it so there are two different things usually they're actually converging as time goes on just because um what you can do now is is there's a lot of whether it's gelato or the keeper Network or those you can just sort of automate the action once once the pole Oracle is ready run some action and push it to your smartphone so that's usually best practice now um do we want to look at code real fast we can uh yeah we can show you guys how easy it is to kind of look to build an oracle um sorry can you guys see that can I zoom in better all right I can zoom in again it's so the way the teller works is it's a generic Oracle so and this is what's kind of important that I wanted to show you guys um we have a helper smart contract you can just come so this is sample using teller it's a repo in our GitHub um you just npmi using teller pulls it into your node modules and then you can import it and do sample using teller is using teller makes it easy to to inherit it but the way that teller actually works as far as getting what you want and knowing is it's this uh we call it query data so we we have these data specs for how we Define what a piece of data is so the spot price data spec what we do is here is we encode the word spot price and then for instance gno USD and that's asking the Oracle for the gnosis US dollar spot price obviously um there's lots and lots of different data specs that we have so you know other ones that we have are like snapshot vote result so you put in a snapshot vote ID and a chain and a contract and it'll go get you a result of a snapshot proposal other ones you you can do like evm calls to different chains so you just need to give it a chain a contract address and then call data and it will return that call to your smart contract um but basically and these are ones that we already have but you you can actually come and it's open source so you know like we have these hosted on ipfs you can make your own data specs so if you want to really think about okay what's something custom that I would want to do um really the sky's the limit you know there's a lot of different pieces that we've done another another fun one is is we do like cross chain balances so like what we do is we'll return like a Merkle root of all the balances so if you have a token on ethereum and you let's say you want to airdrop over on um polygon to the Token holders of a token on ethereum all you would want to do is you could put like the Merkle root of all of those balances over on ethereum or over on polygon and now people can go and claim it and prove that they have that balance and that's a much more efficient method than bridging over all the balances so basically yeah kind of just telling you you can put on whatever you want it's not limited by any type it just returns bytes data so you'll have to decode it at the end but if you want to return very very very large strings you can do that um and then yeah you just you run um once after after you would tip for it or put it on chain yourself you just run git Data before the query ID and then this one this is showing down here the best practice block timestamp minus 15 minutes you're waiting 15 minutes for a dispute making sure that it's it's valid um and then you can update it so that's about as simple as it gets I'll go back to my presentation I know we're they're ending over there so I'm guessing that means I have to end right um and but I wanted to give kind of before [Music] before we ended just um I know some people were still looking for ideas or if you wanted ideas these are some of the cool ones that I was hoping people would build whether hopefully on gnosis chain or with teller other ones so things that you could do you could build token Bridges so you know we were just talking about how you can use that evm call but like you could make it a mixer which is what I think people should do so you you could Fork some tornado cache code where there's a proof of a deposit but why don't you just take that proof go put it on another chain now all of a sudden you got a mixer and it you could put it on 10 different chains if you put a chain ID in there as well and now you're mixing across chains so some cool ideas you could also I want to see somebody do a brc20 on chain so you could use an oracle to go grab ordinals data from the Bitcoin blockchain you put that stuff tokenize them put them on the ethereum network maybe get some of the Maxis on board um other things uh Bounty programs so we've we've seen people do this with oracles you can use an oracle to bring on how many Twitter followers do you have how many Discord followers does your channel have how much volume does your token have and then you could set up Bounties in a decentralized way like hey I'll claim this I'll get you 500 new Twitter followers the Oracle will bring on the start Twitter followers in the end Twitter followers if you if you bump that number up by 500 you're going to get this bounty you could do something like that with an orbital other things that we're working on you you could really go if you wanted to get really sort of econ about it you could build like a decentralized CPI so like how would you do that you know that's more of a question for how do you structure okay what data do you put on chain how do you put lots and lots of that on chain and then yeah kind of last same thing like music bounties you can put on Spotify streams you can put on um okay did an artist release a new album something like that um lots of different things you can do with an Oracle and and hopefully it kind of sparked your guys interest so anyway uh here's my contact UM thanks hopefully you guys learned a little something about oracles definitely give me a follow on Twitter do I have time for questions or yeah if you guys have a question or two I could answer it [Music] yeah so he asked if we have a token we do so you have to stake our token that's that one um you know well yeah so he asked like how do you validate like if you're asking for a cross-chain information how do you validate that it's not a fork of the chain and that's why it's like optimistic so you would want to wait on it you know like it would the person could potentially get slashed if they're doing it and and you would have to well yeah it would probably be invalid and we get voted and dispute it but you know you if you were the user so like you would want to wait like it would depend on what value you were bringing over right like if you were if you were doing a token bridge for instance and you're bringing over ten dollars like nobody's gonna Fork your chain over ten dollars like you can probably read it relatively quickly but if you're bringing over like 100 million dollars like yeah you're going to want to wait for you know 100 block confirmations to make sure that thing's secure so yeah I think that's just general best practice for these Bridges but all right well thank you everyone [Music] foreign [Music] [Music] [Music] [Music] thank you [Applause] [Music] [Music] foreign [Music] foreign does this yeah everyone I'm Miguel from Walgreens and I'm here to talk about world ID why it's needed how you can build with it and how it's really released to integrate and you should definitely include in your projects so usually I will start this talk talking about like Sim resistance and airdrops and none of the maintaining all of those things but I feel like by now we all know why those are problem and also like the Wally sensing really really fast we have all of these AI stuff coming soon like if you look five months ago when we didn't have imagination we didn't have UTP for all these things the world has changed massively even then and things that didn't really seem like an issue then like being able to tell who was a human and who was and outside of crypto now we are becoming a really big issue everywhere and so these problems of questions in you know like for projects for the wall for everything um how do you know what's real but also as we continue to build a system where these things slowly take over maybe hopefully not uh how do you continue building the systems that you want to do how do you fairly distribute all the value that is generated by these things and these are the questions these are all these questions relate to personhood the idea of who is a human and the goal of altcoin is to build the largest network of real humans and identity Network and an economic work Network by giving away ownership for free to every human now when we started this project the first question that was really clear was okay how do you know what's a real unique person if you're if you want to give something away from free people are going to try to game that and if someone does they kind of like ruins it for everyone so how can we ensure that you are a unique human and you haven't claimed whatever it is that we're giving away yet and what it became clear really quickly is that there were three requisites for whatever solution we picked which were that it was Private that we didn't get a database of everyone in the world's information that doesn't seem great that it was inclusive meaning that everyone in the world would have closer to an opportunity to sign up an example is something that's not inclusive would be maybe you know like asking for a driver's license for the US that this qualifies most of the world and that it was robust meaning that it would actually hold billions of humans in the system without breaking and making it easier to scale and we started looking at Advantage like maybe we can use email or font it's not great because I mean I already have multiple phones and multiple emails and that's without trying to get in the system so it's not super robust maybe you can use kyc this is not great for the Privacy reasons because now you have everyone's kyc information which is an ideal maybe you can use web of trust the idea of humans voting problem humans this sort of maybe works but the issue is you need an initial set of humans that are trusted and you cannot start from zero which is what we're trying to do and then the last option is Biometrics something that every human has and in a way you can use to tell if they're human we start looking into things like fingerprint and the issue with most of these are mostly that like they don't contain enough information so something like face ID can unlock your phone Apple locks it out after like 30 inputs but according to their numbers one in I think 30 million people could unlock your phone so it works if you're trying to unlock your phone and it looks after 30 embeds doesn't work if you try to onboard 8 billion people to assist them so fingerprint doesn't have enough info same for face same from Palm DNA kind of has it but it's also like really expensive and really slow and also come on like people are really complaining about this being creepy in my universe taking their DNA and so the thing that was left was irises and then we started to look at okay let's say that we go with Services how do we do that can we just have people take a picture of theirs in their phone and same issue as before there is not enough resolution if you even if you get really close the image does not have enough data enough pixels need to actually capture it you depend online on lighting and also not everyone has like an iPhone with an amazing camera some people have worse cameras in their phone or maybe even no camera we try with off-the-shelf uh sensors maybe the ones that they have on some airports where they can just like look at you and scan like that the main issue there is that Urban quality what those systems are trying to do is check if the if your Biometrics match to what they already have in their list so it's not saying is this person in the list still like saying is this person equal to this person so that is much easier if you actually want to differentiate between humans this wasn't enough and so our solution was unfortunately it seems like we have to make custom hardware and no one wants to make custom Hardware because it takes a lot of money of time and everything but we did it we went through a bunch of prototypes and we ended up with this thing dear and the point of the orb is to first of all make sure that you're real make sure that you're not trying to trick it somehow that you're not showing it a screen with a picture of an eye or a dog or I don't know taking it to a kindergarten these are all things that people have tried uh then it will check that you have a unique Iris that you have not already been onboarded to wallcoin and we do this using an iris code which is a measure of the randomness of our of your iris which makes it so that we don't need to actually store a picture of your iris or Biometrics in general you're more curious about that you can come find me later on aggress playing fireworks and then it verifies your wall ID and quality is a name that we came up with for this system that acts as an internet passport it's an entity protocol and like any passport it has a bunch of stamps so for example when you get verified with the orb you get the orb stamp meaning that this person has been verified by the orb we've also been working on it in other stands for people that don't have access to the orb yet where maybe it's not the most secure thing ever like again one of the things that we support is phone number and people can raise their multiple phone numbers but the idea here is that if we have this passport full of uh to Identity signals to prove for example that someone is human you have different levels of how hard it is to get those stamps and for people that cannot access the orb it is better like they having a unique phone number still needs something because it means that if you want to I don't know like attack a system now you need a thousand phone numbers or maybe Millions instead of nothing so the end goal is the goal but as you're building this protocol we want to make it so that us or anyone can add more stamps to this protocol to add more indications of whether a person might be human or not and our goals for this system was to make it privacy first maybe even Anonymous to make it decentralized using the tools that crypto give us and to make it open source because it feels like those are the requirements that like if I was working a project I would be comfortable with adding something like this and yeah we built this system called waledim the system is very complex behind the scenes it uses zeroes cryptography it does all the machine learning stuff from the orb but we worked really hard to simplify it so that when you are working on it there's just two things that you need to worry about and those two things are signing with worldcoin Anonymous actions signing with all coin is intended for web 2 applications for the original applications to use as assigning with Google replacement or any other sign-ins and makes it so that they can make sure the users are unique humans and also have a unique account without actually learning any information with them so as an example this is the open AI this is our version of the openai chatibility signing page they haven't integrated that at least yet and the idea would be similar to how they have continued with Google continue with Microsoft they could continue with wallcoin that brings them to this page where they just scan the QR code with their phone and then when they click approve sign in they're signed in in a completely animals way and the application only gets a random ID and then for anonymous actions we build something that works across every single type of the centralized application and that gets validated on chain making it so that you can have Anonymous actions that cannot be tied to each other so an example here would be if you're building something like snapshot or a bowling platform you will be able to have a unique action for its governance proposal making it so that like you can steal on this proposal make sure that people are only voting once and they are not like attacking the vote somehow but at the same time not being able to trace people between boats so you get Anonymous boat here Anonymous boat here on different proposals and you have no way of telling if these boats are from the same person or not but when someone tries to vote twice on the same proposal that's when you can identify them so in a way it's a fully Anonymous capture-like system that lets you tell not only if someone is human but also have they done this specific action before which makes it really really powerful and the best thing about it is that it is really really easy to integrate both on and off to so hopefully the thing I may have to really quickly turn the display because we didn't rehearse this before so that it mirrors there we go so I'm going to show off a bunch of examples about this and maybe a little code um hopefully this is big enough so that everyone can see it if not you can let me know and I'll make everything bigger the first one is the demo that I explained about obviously like this is not actual sativity this is a demo that we made but we basically were willing to show how the experience will be so you go to the page you click login you get taken to odd zero now this is really cool all series a platform that lets people set up authentication without actually writing any code so this means that even if you don't are nothing I don't know how to code you can still take advantage of wall coin but yes going in here clicking them on the other two of us or clicking a bunch of buttons and now you're a thing you have signing with worker in your site so obviously for this hackathon week here I have a slightly more technical things online stuff but you can also use it without any knowledge of code so as I said before I get a QR code and then I just need to go to the world app on my phone scan the QR code with my phone and then it would show the do you want to verify signing with welcome here after I confirm it takes me home and in this case we just made an example of a hypothetical human mode that will be enabled if you sign it with altcoin another example of this slightly more complex is we go to the wall lady peterbs page which is a little page that we made so that people would be able to adopt um for little cuts orbs so this is a page that allows people to Mint on nft and then we give them the physical thing and implementing this in page is very very simple we have these packets called ID kit that has a holiday week react component and in here you would just pass a bunch of settings like an up ID action all these things you can get all of these from our developer portal and I will later share a link to the documentation whatever all of this explained including starter kits and all of that but the idea here is you guys like initialize this way yet with a bunch of parameters then on success you get the proof you save it and then when it's time to actually do something like this like in this case actually mean the nft when you're calling the smart contract in this case I am calling it here because it allows people it the way that we build this app specifically allows other people to pay for gas instead of the user but basically in here what I'm in calling the contract aside from the address of the user and the name that they have chosen for their real mascot it also passes the three parameters of the proof in order for the contract to verify them now if I go to the contract which is over here this is a fork or for starter kit so again most of the cooling here you'll see commented out and explained somewhere else but there's this adopt function that as we saw before receives an address the name and then a bunch of parameters and the code here basically is going to take this nullifier has in a way is unique for this action but it for the same User it's always going to be the same number so the check is very simple we first check has this user already done this if it is we stop the execution after we call the quality contract and tell it please verify that this user does this proof actually is valid that the user is human and then when that succeeds we just like Mark it as this user has already done that and then afterwards is our custom code from Indian nft or whatever it is like I mentioned before if you go to our documentation or our GitHub page you will find um enough starter um fun restarted for the smart contracts and then also an often I think it's called often anyways that livings are in the notion that I will give in a second and often starter kit for people that want to validate the proof without a smart contract through our API which is the exact same floor but instead of calling the smart contract you call an API or Onsen and so let me go back to the slides there we go and so obviously this has a lot of use cases you can imagine for example airdrops which is why we initially built it but also governance voting like vitalik has been charity and everyone like stop doing the coin bowling it doesn't really work but no one really listens and more that's mostly because we have no way of actually on Centrelink users that they were human before now we do there's also a big so the central social media movement lately with for lens for example that tries to figure out the next generation of social media and algorithms are very vulnerable to manipulation and especially if you have instead of accounts and captures smart contracts that everyone is still including Bots can call so incorporating some incentive layer for boyfriend that you're a human also works and there's a lot more stuff that you can play with basically there are reason for us being here is for you guys to get inspired and then see what you guys can do if you want to see more concrete examples on our documentation we have a use cases page that goes more into detail on things that you may want to build with this what is possible Etc and we also have 20K in prices for a bunch of categories these will all be need Global page and on the intro keynote in a few hours so I'm not going to go over them right now but basically you can play around with it and probably make something cool we have this SDK as I mentioned before developer portal and this is a QR code that gives you access to it we are in early stage rolling this out basically this lets you skip the waitlist if you don't manage to actually capture this right now don't worry come to our booth downstairs we still give you a QR code we have like the little stacks of paper that have a bunch of QR codes that you already have gonna give you like five seconds to take that picture but again if you miss it it's fine and yeah as I mentioned before we have made this page volcan.org list 123 which is an ocean page full of resources it outlines the prices the QR code that I that I just showed the documentation all the story kids so interesting ideas basically everything that you will need this is the one that you need I probably should have a QR code to do this as well but it's a pretty easy to remember URL and as I mentioned before downstairs our booth we have a big stack of papers with a bunch of QR codes and this is one of them so to summarize a little bit we are building wallaby which is a global entity protocol it's fully it's fully open source it's private it's a centralized and it lets you check if people are unique humans right now it uses these signals of urban phone but we want to continue exploring also whatever things people might add in the future maybe at some point instead of just being able to know whether someone is a human or not you can also use NOS proofs to prove other identity attributes we are again still exploring and we hope that you guys explore as well and that's it I think I have some time so if anyone has any questions that's the time yes [Music] right so the question is if the weather gets saved to a wallet and the answer is it doesn't basically the way that quality Works behind the scenes it's it is a secret it's a it's a separate private key that your phone generates and the reason why it's separate from your wallet is because you want to be able to be to use this from any wallet at all thanks to it being anonymous that means that if you have multiple wallets or even multiple identities if you have an anon on Twitter you would be able to use your quality from for some things that they want to do like Maybelline proposals and then for some other things from your entity without being able to talk to yourself uh so again the way that it works is it's a separate key you use that together with zero Edge proofs that is already handled for you from the app and integrate with idkit but it is not tied to any wallet and that makes it so that you can use it with any wallet yes right this terms as of right now are meant as one-time stance we are not we may at some point as we are getting more data and as I mentioned the part of the Iris scanning process in both machine learning so as those algorithms improve we may be able to improve their accuracy and maybe reissue the stamp or like have a new one we're still figuring that out this the protocol is made so that stamps are a one-time thing but you could issue multiple ones in the future uh the way that the orb Works basically you need to go to the other ones and then once you have the equivalent on your phone you don't need to go again but in the future as new stamps get added or as some stamps improve accuracy if it's meaningful you could think that they maybe make like a B2 stamp or something of that of the sorts yes right so the way that it works is first of all orb takes a picture of you and combines that with the public key that you that your phone generated that is shown to the Orbison QR code you have an option to explicitly opt in to let us collect data like the photos in order to improve the algorithms but by default that is not the case so in the case where you don't consent to that the images get deleted immediately after they get converted into the iris code and they would never leave the orb uh for the case where you do consent they get encrypted and stored uh in a cloud so that we can use them for training and then the iris code and the public key goes on chain to a Smart contract and then they are stored also as a mapping because at some point we want to enable the idea of you being able to go back to an orb and we kind of like invalidate the old entity and we and issue a new one in to make sure that like if people lose it they can still go back and recover it that is not in place yet but we still need to like tie the iris code to the public key in order to enable that in the future the really good news about that is since the public key is not tied to any of the usage and also the Aries code is there's not a way to recover that into like knowing who you are without you getting scammed again it's still fully private even though we are storing those two pieces of information yes so can you speak louder yes as I mentioned that is the QR code that lets you skip the waitlist if you scan this one you get like an inbite that lets you skip it again if you don't capture this will be downstairs you'll be able to get the link there the waitlist is mostly as a way for us to work closely with developers and make sure that like we can give them all of the attention of the nail that we don't have like a thousand people suddenly trying this or like thousands of people and we're just like being flooded with ideas on how to improve it um but the protocol is ready it's just a way to make sure that the developer experience is very good by working closely with the developers that we are letting access to and participating in hackamas like this so again this lets you skip it it's below that's I think it's so oh as something that I want to mention before we all go is in previous hackathons we've had this thing where people will actually go through the flow do almost everything right like uh like let's say the inter-ready etiquette widget which is the preferred way to do this they would integrate that we get they would set everything up they will then get the proof and they will not validate it and this is not great because it means that anyone with some basic knowledge of like hacking or doing bad stuff can just give you an invalid proof and if you never check it then did your like the whole purpose of this is good same thing for if you actually take it that you take it on your client on the front end then someone can just like interested that request and change it so unfortunately if you do that we will not be able to give you the price even if you really want to and you've built something really really cool so I feel like I'm saying this at every single conference and someone still forgets so I'm going to be saying it again uh once you get the proof even if if you do it through the API if you do it on chain make sure that that proof that you get you send it either to your backend or to a Smart contract and actually validate it there otherwise this whole thing has an sui but doesn't really serve any purpose so please remember to do that and let's see if this hackathon we can get no one making this mistake yes sorry not exactly yes I know these are two separate things we have the world app which is like the world that we get people there is the application where you through which you use wall ID but at the same time it also creates a wallet for you so the wallet is separate to wallaby for this is intended because the flow the way that we're importing people with blockchain is we are all over the world going to every single City that we can think of being high in Boots there in like the streets in shopping centers whatever and actually talking to people explain to them how crypto Works what walkway means what ethereum is what stable guns are all of those things and so for those people that are getting onboarded to crypto for the first time I don't have a wallet we also give them a wallet so when you actually download the workwind app you will get a wallet now that wallet is separate from gravy and for example I already have my wallet that I've been using for years and so when I'm using wall ID what I do is I connect when the application tells me to connect I want to connect with like maybe my existing wallet and then I just use the wall app for wall ID so so these are separate things as of right now yes the wallets that we create when users create the app are nurses safe Wallets on polygon that will be optimism soon but that is unrelated to Holiday think I think we're out of time so thank you all for um listening and if you have any other questions I'm pretty easy to find I'll probably be around the booth downstairs is very close to the entrance and yeah come find me Good Luck building with IV and I'm sure you'll make some really cool things [Applause] [Music] thank you [Music] [Music] foreign [Music] foreign [Music] [Music] thank you foreign [Music] [Music] [Music] foreign [Music] foreign [Music] foreign [Music] Network a pleasure to stay here thanks for coming it's good to see people who would like to win up to twenty thousand US Dollars the second one so we have really nice bunches but first of all I would like to introduce who we are why we are here and why you should built on top of one inch Network to to the end tomorrow so who we are I am also a hacker back 2018 I started with my co-founder Anton bukov to travel around the globe uh first second one was December 2018 I met vitalik buterin I met a lot of other people and for now it's cool it's really cool I had already like 15 16 years of software engineering experience but never participate on hackathon and for now we can build this island over just tonight something which can win a prize and we can sort of pay for our airplane tickets for hotels actually we almost never needed a hotel because we were staying always on a venue uh also when we've built a one-inch first protocol back in 2019 in may we didn't sleep I didn't sleep 56 hours so it was quite hard but you see nowadays we have a huge set of protocols we started with the aggregation protocol then we have built liquidity protocol uh we came to our Dao our token was launched by the foundation back in 2020 we have built our self-custody wallet um because we didn't find the proper wallet out there as the mirror Mass was really terrible and from upon you kind of still the issues with other Wallace that's why we just have different teams working on on the space to just not compete but improve and add value to the space we have our limit order protocol is fully decentralized one based on signature similar to zero X and other approaches but highly efficient we introduced our Fusion this summer last year we did hackathon over one month with our people in Dubai they got breakfast lunch and dinner Spa gym pool family could come so we just tried to to create such an environment which you meet here at the GH Global I got on and it worked we were able to deliver in just one month diffusion and we were really happy about that nowadays we are also working on institutional products we try to enter the space of traditional finances and improve their settlements for example with our swaps with our aggregation um like we are like three years old I would say the project almost four years old um the first year we just were working with Anton in the nights I was working for Porsche and here for near protocol and one day we raised money so in total we raised like 190 millions of West dollars and uh continue to develop new products to ship new new new Innovations we keep 70 percentages of the aggregation market share this Market we created actually on the hackathon we came to the idea how to uh make a swap more efficient by aggregating among these realistic changes and choose based on specific algorithm only those pools which makes sense to use as liquidity source so at the end they usually get the best rate limit auras market share is about 80 percent which is huge we achieved like in just one year from zero to to 80 percent of the market share and uh overtook 0x and other protocols we have four and a half millions of wallets who are using one-ish protocols it's not huge but at the end like you can see in the left corner they generate 330 billions of US dollars since 2019 and they have 180 actually more 180 core contributors around the globe uh like Freelancers who are full-time working on on one inch Network protocols we see Dex volume continues to grow and uh it looks like we are we can overtake yeah uh centralized exchanges because uh decentralized exchanges are more efficient than centralized so you don't have to trust anyone you just interact with the smart contract you have no intermediates except validators of course and this is Room to Grow for us all here who is developing that three space but we have current limitation defense space we have unfavorable swap rates we have math attacks at first my like really painful MAV attack last year when ethereum dropped to 1000 I had because of tax reasons I had to sell my ethereum to buy again so to just declare loss in my tax report and I was front-run I lost 10 ethereum it was really painful for me so I could use this money just to to for my daughter or I can like for charity or whatever but some some attackers got it so and I went to to our teams and I said like guys it doesn't work we need we need solution for this and then we came to the idea with the fusion I will explain a little bit later um and of course we have problems with three space that the user experience very complicated still very complicated we from our side we try to improve with the Vault we have really nice ux UI now we have this kind of meta transactions with Fusion uh it improves but still there's a lot of things to to to to build to the problems front running attacks so someone see a transaction into something before you extract value from this the math attacks are like if someone don't know how it works in terms like math someone is monitoring the mempool and analyze make it sense to exchange before you to exchange after you to extract value from from your trade if you for example exchanging directly on uni swap so someone is doing this and they make a lot of money back in 2022 they just earned one half billions of US Dollars just by out of thin air how U.S government says nowadays so and this is like around 10 percentages of of of the transactions so and now you have two ways you have the 30 path with using daxes directly you don't get the best rate you don't know really where the liquid is concentrated um and you don't know we are we are the tokens listed and uh you may you face also the map attacks you faced here front running attacks um so this is not really efficient and that's why people from outside we call it tourney pass like black forest you don't know what foot can which animal can can attack you in the next time and we try to build the other other side yeah uh where we come to to our Fusion and uh but but before I would like to explain once again about the aggregation itself maybe not it's not clear for everyone um I know some some people are of you are very Advanced uh but some people still like just know that I can go to UNI Swap and just exchange there uh this more yeah we we came to the idea we found on two aggregate among distraction exchanges and multiple Equity sources right now we have on if you do more than 25 000 liquidity sources each smart contract with liquidities on liquid source so um at the beginning we just exchanged on one market just for example ethereum to die but it makes no sense to just use one market because if you exchange hundreds of thousands of US dollars maybe 10 000 investors make sense to use also other markets like ugt Market UCC Market uh if you to to something else so in this case you see ethereum to see usdt this is a compound usdt action Pathfinder our algorithm Buffet can also build a path to just put ethereum into UC Landing pool of compound for example so in this case we use market makers who also integrated in our aggregation protocol and and routing we have unusual we have sushi swap you see part part we exchange to die but we exchange through usdc from UCC we go to UCC and from dive we go also to UCC and then in the end they usually get the best experience like best best experience and best execution rate because we actually did an Arbitrage just actually an Arbitrage algorithm which we are using um so Fusion this is new new approach uh how to exchange assets nowadays it works very well on ethereum since uh when you do the transaction by yourself if you do this transaction by yourself and the amount is higher than around 10 000 US Dollars someone will frontrun you someone will send it to you and you will lose a good amount of money in normal cases like 50 bips what you will lose and this is not how it should be and fusion solve this problem Fusion is based on our limit order protocol uh you just give a signature that you're okay to exchange one asset against another asset in a specific amount and you would like to exchange four specific rates not just for one specific rate like if you do a normal limit order this uh is a kind of uh this is a specific grid we call it which use the current market liquidity because our our algorithm knows exactly how many tokens are where and which rates you get for which amounts for which pairs that's why we can build such a nice grid and you see the price go going down from the current Oracle price and goes down to the current market rate if you do Market swap so when you do Market swap you face a price impact so you get less than you have originally because liquidity is not really huge and every decks need to earn something yeah use weapons like different pools 30 beeps one beep five beep 100 beeps so of course all algorithm can optimize this but yeah still still is kind of difficult um here to achieve the the best best execution so we we were thinking why why should we do a Dutch auction in linear we could just use discrete which comes directly from from the literature amount from from from the current Network so in this case someone exchanged this rule case 3700 if you don't use DT and they got 2 345 bucks more compared to if they would just execute it by themselves uh theoretically should she would face the math attack would get actually less and also if they wouldn't face their meth attack because they would use maybe RPC of flash boards or our Rabbit Hole um our percent point which protects people as well from front running attacks um anyway uh this execution was better because we see these partial Fields you see here small partial Fields these are greens Green points Arbitrage Traders when they see such Arbitrage opportunity they go and hatch on positional centralized exchanges they are exchangeles with only qdt also the hatch with other networks as well for example if you're buying a polygon like metic token the potentially they will exchange it like hedge deposition market rate in the reverse Direction and another Network where they see more liquidity and and come back to to ethereum to Arbitrage back and actually we allow over time to sell specific amount of tokens by giving a chance to arbitrus 3D to Arbitrage this trade that's why it's it's better than just doing a market market uh trade actually market makers are selling uh tokens over weeks months and theoretically you can also set up with a custom mode you can set an order to sell it in maybe two days because you have a talk and it's not super liquid but the there's some liquid on centralized exchanges and then if you set such or arbitrustrator try to to chart with Rush among distress exchanges and different networks and also centralized exchanges um how this works under the hood it's very important to understand it is kind of Autobook some people are switching like swapping in One Direction the other in the other direction if you don't use DC uses it to ethereum then our resolvers who are able to settle the trades can match these orders that's why it's also sometimes very efficient to use all the fusion because they are also other people who would like to to exchange tokens maybe in the reverse Direction and um so the resolvers these are professional market makers they have a special game theory for economics we changed it recently also in December together with Fusion release you need to stick one-ish tokens to get unicorn power this unicorn power decreases in time based on the burning curve that means you have to maintain all the time to to to have almost one token to one unicorn power so and with this unicorn power you can become resolver or you can ask someone to delegate the Unicorn power to you to became to to become top 10 resolver on on the top 10 result can execute the uh the settlement so the settlement is done through smart contracts for this industrialized manner fully permission permissionless in terms of everyone can send their order but in permission manner the only specific resolvers who were selected by the community or had enough unicorn power they can settle the the trades and and have the chance to Arbitrage among centralized exchanges already said um decentralized exchanges also with only Equity there are market makers like winter mute trading with only liquidity and providing better rates then you can get on unisol because they can hatch positions they can use options in the background to to to just to kind of hatch so what is important use user you just sign them like permit yeah you sign a message you send it in a network and you don't pay any gas uh with the execution of course there are some gas cost costs market makers resolvers need to execute it somehow on smaller amounts if you use Fusion you will just get a little bit less uh destination token for example if you're exchanging you if you need to use DC you would get just a little bit less usdc because the rate would be worser than if you execute by yourself but anyway you you get the same if you send your transaction on legacy mode by yourself you do the um this aggregation Thing by yourself you pay the gas cost yeah in ethereum and in a fusion mode resolver pays the gaskets and they're taken to account how much they pay and if it's profitable for them if it's not profitable of course no one will take it but we set the orders we have presets we set specific price ranges in the terms that it's executed very fastly so map protection I said already how it works um how to integrate the fusion itself you have a nice SDK written JavaScript um I'm sorry if someone would like to contribute to write like to write a SDK in other languages you are welcome to ask for a grant we have a nice Dao and 18 millions of US Dollars no doubt you distribute for those people who contribute to one-ish network you can write and fight them for example so how uh how to get a quad it's simple you use the SDK there's a nice method get quote you you form your request and you you get the quote uh what is the current market rate Market Return of the token period on the amount you would like to exchange so it means you can just easily build your own UI which is maybe more user friendly than ours or you you put a specific product which use Fusion under the hood to maybe rebalance a bundle of assets or something so you can place the order it's also very very easy SDK with the proper endpoint Network um we have also nice documentation I will show you where to find it you can get all orders maybe you can build something what analyze auras or maybe filters to orders based on specific criteria or you build an Explorer for for one Niche Network like Fusion Explorer is also one thing what you you can get maybe a grant here and also you can apply maybe for Grant at the dollar to to work on that maybe full time so you can scan the QR code you will get the documentation and um I have still a little bit time I would like to show you how it works and of course you can get in touch with us anytime we also hear a downstairs on the ground level we have a booth you're welcome to come also to get such chips like a little bit later distribute there are some one inch W so you can play around with the fusion mode and exchange it in fully gasless manner so I will show you how it works so we have here our one inch and I would like to use our one inch wallets to connect so now I need to find the proper wallet SEC yeah this one and we can use one inch wallet connect so very easy connected and now I have some unit uni swap tokens which I would like to sell and I would maybe sell it to usdc so by default we have like legacy mode because on smaller amounts you can send the transaction by yourself pay for the gas costs and you will not face the meth attack because it's not profitable for the maps under under estimated 1000 bucks but anyway if you have no ethereum on your wallet you can still perform the trade because Union supports permit permit is just allowance signature which you give from your wallet and we will do it now so we have auto mode which is in three minutes the expression time is in three minutes so with the which gets in which takes into account the gas costs for the Arbitrage for the resolvers and resource Traders so we ensure that that rate will be executed so I get you notification that I have to give a permission and now I have to sign this swap and you see here we have pending status we have expiration time uh we have three minutes something we give like 20 seconds for for people to sign because sometimes people are too slow they need to use Ledger or other Hardware wallets so and it should be executed then next 30 seconds I'm pretty sure so you see you you will receive 500 at least 529 use usgc because gas costs right now are very expensive on ethereum of course we are supporting other networks so you can work with other networks we have arbit room and and where you don't pay a lot of a lot of money so in meantime as long as in a pending process um compared to legacy mode if you send the transaction by yourself anyway you have to wait sometimes if you use Market gas price you wait maybe 30 seconds until the transactions are included in the in the block so it's similar here for small amounts for bigger months you have huge profile like huge benefits by using Fusion already explained we have nice doc portal you can find you can find it here under more documentation and you get kind of deeper insights uh how this how it's set up how that works how to become become a resolver and we have also nice SDK repository you can you can also walk through all the examples real real examples there's some auction calculators and yeah and to to the bounties um to the boundaries so we have the first task where we say we would like to see someone to build on top of one is Fusion integrated how you want asset rebalancing mechanism swap interface integrate one of your products which you already have built somewhere I don't care so for me it's important that Fusion is integrated and used somewhere there it makes sense we have also this thing with with their resolvers which I explained oh no actually we were hearing this sound I didn't recognize they have this magic sound when it's filled so it's filled and we got 549 uh West dollars and it was yeah it's a little bit below than 595 because it wasn't profitable for anyone to take this Aura because they had to pay the gas costs yeah so the money is not coming from nowhere someone need to pay in any time yeah but compared to what if you do it by yourself you you trade by yourself you pay anyway the guest costs so it's comfortable in the case also when you have no ethereum on your wallet um so to the second task we have our resolvers you can go to you can stack one-ish tokens you can lock up to two years uh we're flocking to you by two years you get almost one to one one inch token to one unicorn power and it decreases in the time and then you can delegate to uh to the resolvers there are already some you can also create by your own some uh but you need to of course you need a lot of Delegation power so we have we have here top 10 and the top ten they have 270 000 unicorn power delegated so 200 000 of initiatives you need theoretically but you can ask the community you can ask core contributors as well to delegate to you if you if you would like to participate here um you don't need really money you just need support from people um so we have this delegation and these people these companies who run the resolver they distribute um kind of uh incentives for people who delegate to them so it makes no sense for me to delegate to someone just just like that yeah here you see APR how much how many one-ish tokens the this resolvers distribute and based on gcpr most of the people delegate the the tokens to earn on that you can't build something on top of this you can tokenize maybe these positions you can create a maybe a pool that the thing is every time when I delegate and when I claim the tokens I need to pay gas and it's painful on ethereum right now since the mem coins so maybe a good solution would be to create a smart contract which is kind of pool everyone can participate uh like bring on one-ish tokens this contract can stake and Delegate for specific resolver and also move to delegation based on the APR and also claim rewards and distribute rewards for those who participate so this could be one one of cool ideas what you can build here and we have really nice prices so for the for the fusion integration for the first place you can get 4 000 West dollars it's a lot back to my times I I was lucky to get um if on if you're in New York haircut on 350 bucks to be able to pay the airplane ticket to Stuttgart back so when you have gold one inch but nowadays yeah it's really nice to see that all the other projects are offer offer nice nice bounties which you can really easily earn by just not sleeping two days uh yeah and open track just come with what you think uh I can get give you some um give I can give you some example I'm running out of time um we are working on P2P network uh pgp not the network for storing um uh industrialized Mana limit orders like mesh network uh and fusion auras and if you are if you build something like this on hackathon over two nights I would appreciate and you can see a nice nice Bounty for two to one two thousand five hundred US Dollars thank you very much if you have any questions I will stay outside and yeah we have here Booth we can also come to our booth and speak with us as well thank you very much it was a pleasure [Applause] foreign [Music] foreign [Music] foreign [Music] foreign [Music] [Music] thank you [Music] thank you [Music] foreign [Music] [Music] thank you [Music] sit on hello oh look at that if I talk like uh is it loud enough all right a bit closer all right yeah that's good I'm all right we got some stragglers if you this is unrelated to the talk but if you want to be added to my hackathon social graph come talk to me afterwards and I'll add your address to this this is all the people that I've met at the hackathon all right um here's what we're gonna do we're gonna we're gonna launch a Roll-Up in 30 minutes this time if I fail I'm not going to shave my head I already did that um so you're just gonna have to trust me yeah yeah yeah yeah exactly well last time to be clear I I did do a thing where I said I would do this in 30 minutes or I would shave my head and my computer crashed so it was the computer's fault but I I you know whatever my hair is growing back so it is what it is all right so um you know some context here really quickly uh you know optimism is building has been building stuff for a long time we've been building this blockchain op mainnet um and we were like hey you know people are starting to use this code uh to run their own stuff why don't we just like make that official and um and make it really easy for people to spin up their own roll-ups using our code and then they can they can help us build the software because they'll be using the same code and so then they'll be help you know they'll be building the software too and everyone kind of wins so we came up with this thing called the op stack which is basically the code that powers the the optimism Collective and and um you know it does a lot of things but one of the most important things that it does is it you can use it to run a Roll-Up um so there are easier ways in practice to actually run these things people now have built you know tooling on top of this where you can really it's it's close to one click to deploy these things there's things like conduit um and uh and Caldera and these companies now that are spinning up that'll help you run and roll up but if you want to understand kind of what's going on under the hood and the different components involved it's nice to be able to do it from source and to kind of just spin up each of the components one by one and get a good sense of what's happening so um this is kind of the the slightly more in-depth version uh than in practice what people would be running in production but it's worth understanding this so you know we're going to be we're going to be doing it from source which is you know it's always more fun so okay so the you can follow along with this if you want if you go to stack.optimism.io and you go to the getting started page um I'm going to keep this like on the left here but I'm really just going to be talking about it so you don't have to see that and maybe I should make my vs code a little bigger okay um but yeah so a lot of the op stack code lives in the optimism monorepo big old monorepo so you know just clone it start with that pretty easy [Music] um and the mono repo has some stuff that you need some stuff that you don't need so we're just going to build some of it but it's really pretty straightforward this is gonna like I don't know who knows if we even take take 30 minutes we'll find out all right boom optimism right we got the mono repo here there's a bunch of stuff in it don't worry about it we'll get there is this too small should I make this bigger all right good um obviously install dependencies whatever that's going to take a minute it always takes a minute whatever how's everyone doing um you good life good okay I'm I swear to God I'm not shaving my head again all right all right all right as long as I can have 40 minutes all right so this is this is uh all right we're done right so we installed our dependencies um and then we're just going to make some of the components so I'll tell you in a second what these are so generally speaking an OP stack system or just a client for for this system is broken up into two key components just like in ethereum you have a consensus client and an execution client we essentially have the same split there's this thing called the op node the op node that's the that serves as the consensus client and then there's a another component that serves as the execution client and now there's actually multiple implementations of this so we have two two implementations of the of the consensus client that's op node and Magi which is the uh the version that a16z built and then we also have two execution client options there's op Geth and op Aragon which are just slight modifications to get the naragon that make them work as you know our execution client so you can mix and match between these things you can run op node with opgf or you can run Magi with OP Aragon or whatever combination you want just like you can in ethereum right now we're going to use op node and opgf that's just sort of the reference implementations that op Labs has been working on and so every single client in the network runs these two services for itself right just like in ethereum you run a consensus client and an execution client we're doing the same thing and and then there's these other things called the Batcher and the proposer so the Batcher is a process that talks to the sequencer node and it gets all the data from the sequencer and it puts it on on L1 in this case we're going to be using girly so it puts it on Gurley and the proposer is something that exists for now but won't exist relatively soon which is something that sort of proposes what the output of the L2 is to the main Bridge which allows users to then withdraw funds from the main bridge if you don't you know for testing you technically don't need to run the proposer but why not but you do need to run the Batcher and you need to run One op node opgf pair together which forms one nub uh we're only gonna be running one node right now which is the sequencer node but you can also just attach more nodes and they'll communicate over a period like a peer-to-peer Network and share blocks with one another and that all just happens kind of automatically which is nice so the only other thing is that we we've separated um we've separated Geth out into its own repo we usually do everything in the mono repo but we guess specifically we like to have a very minimal diff on top of gef that that's what keeps things simple so there's actually a website that you can go to which is opgath.optimism.io here we go so we go to op hyphength.optimism.io you can see a detailed description of every single line of code that we have changed inside of Geth and what it does so if you're curious as to what the diff actually achieved go to ophyphengath.optimism.io you can see every single line of code with a detailed description of why that line was changed um Okay so we've separated out Geth and we have to make death same way you make death normally it just builds so that takes a second and we'll also need access to a girly node so we're going to be attaching this to girly but you can attach this to any chain as an L1 any evm chain um could put it on polygon put it on whatever you want doesn't really matter as long as it's an evm blockchain you can use it as the L1 curly is just easy and if you need curly if just ask me I have an enormous amount of girly ease to give away so let me know all right cool so we've built most of the software now it's just sort of about configuring it and running it which is really really simple for the sake of this demo we're going to generate some some keys there we go so if you go to the contracts Bedrock repo Bedrock is our upcoming upgrade that's that runs all this stuff um we have this command oops this re-key command the re-key command just generates random random private keys for you um so I'm just going to take it I'm just going to copy that you don't need to use this you can use your own Keys your own accounts this is just a useful thing to quickly generate private keys and accounts that you can use and you need to fund them so these numbers here are pretty pretty high I don't think you actually need these this much eth in them right now but girly girly sometimes gets very expensive at random points um like last week when it was like 10 000 gray which is ridiculous so uh some you know I recommend probably doing this on sepolia like some other network other than girly just because Gurley is kind of kind of a mess sometimes but yeah so you need to fund all of these wallets with a certain amount of eth there's an admin key that that deploys all the smart contracts there's the proposer key which is going to propose those outputs and then there's the Batcher key which is going to post that that L2 transaction data to L1 each one of them needs a slightly different amount of eth these are suggested numbers but you can do more or less or whatever so so the next thing so we've just generated Keys the next thing to do is to configure the network so to configure the network uh We've we've kind of done a lot of the work for you as part of this demo um where are we so packages contracts bedrock and so if you go to the deploy config folder inside of contracts bedrock there's a getting started Network and the getting started network has what you need to fill in all you need to fill you need to fill in a couple things and the uh really most of this is pretty simple you fill in the admin what says admin with the admin key that you got whatever says proposer with the proposal key whatever says Bachelor with the Patcher key it's just find and replace so that part's pretty simple we'll do that in a minute the other thing is that every Bedrock chain needs to sort of tie itself to a to an L1 block that it it sort of starts from that's where it starts you know the chain starts looking at data after that L1 block so we're just going to go ahead and um and find that block I'm realizing now that I need to I need to get myself an Alchemy endpoint all right give me a second here okay so girly right great copy that okay so um it's usually recommended to grab a finalized block just why not and then we're just gonna grab some of the some of the fields so we want the time stamp the hash and the block number pretty simple so we pull that out here's the so we're just going to use block eight million 988 274 is our starting block for the network uh this is the hash of that block and this is the timestamp of that block so we're going to take that hash and we're going to stick it into this thing that says L1 starting block tag and we're going to take that time stamp and we're going to stick it into the thing that says L2 output Oracle starting timestamp and then the rest of this is pretty simple we just kind of go back and forth finding and replacing so we've got admin here we're going to find and replace that with the admin address don't worry about it we've got sequencer gonna replace that with the sequencer address proposer and badger we could probably automate this more but again like in practice you aren't really going to be doing it like this you'll be using more tooling to automate all this stuff this just gets you a sense of where the config actually comes from so that's the first step now we have a configured Network we basically just need to deploy our contracts so that's simple enough we're going to create a DOT EnV file or you can copy this dot EnV file I guess um whatever I don't really care about any of that we need two things we need the uh RPC that we got from alchemy that the L1 RPC and we need the private key of the account that's going to deploy everything in this case the private key of the account that's going to deploy everything is the admin key it's that simple enough the last thing is just you need to send money to the admin key otherwise you can't do anything so I'm going to have my whale account send some money to the admin key come on what's it doing I blame the internet okay all right on op Gurley wait that's op girly I don't want op girly I want Ethan Gurley what is it doing do I not have genes girly there you go that's why okay huh oh this is frame this is a very good wallet if you're interested worth worth trying in my opinion um all right we're gonna send girly eth I'm gonna send five girly eat to oops to my admin admin wallet here uh if I can find it Jesus what what is it doing all right yeah great all right sign send fantastic done okay so my admin key has ethnow pretty simple now I just deploy a bunch of contracts you know there you go all right so hopefully that was enough Eve and I can just start deploying stuff Maybe okay so this is the part that kind of takes a while which is really annoying um we basically just sit here and deploy a bunch of smart contracts so that's just going to start happening in the meantime I can kind of talk about what we're going to do next it's pretty straightforward so the where are we yeah so we at once all these smart contracts get deployed we basically just have to configure the op node and configure opgf the op node is going to generate a Genesis Json file which is the same or it'll it has a command to generate a Genesis Json file that's the same type of Genesis Json file you would expect for any network same thing and a roll-up Json file which just has some config config values in it and then we need a JWT token for the communication between the op node and opgf that's exactly how it works in ethereum as well it's not different so you know same concept and and then we're going to initialize opgath we're basically just going to insert the sequencer key into the uh into gaff which we can actually do now while this is happening to save some time here so we can make a directory we're just going to call it data oops oops that's not there we go we're going to create a password in this case the password is password so probably use a real password in production but whatever and then we're going to take the sequencer key and we're going to dump it into a file easy and now we're just going to import that sequencer key so should just be able to import it boom so now we've imported the sequencer key you can see this this address here is the same address it's been imported and then once we're done with the other thing we're gonna we're gonna initialize GIF with the Genesis Json which is how this is exactly how you would initialize GIF in ethereum as well so we're almost done here once all the smart contracts get deployed this is actually really fast girly is usually not this fast so I'm I may actually make it today we'll see well in the meantime while this is happening we can also set up the command for initializing the op node we won't run it yet but we'll get there so uh you know what I'm just gonna copy this you can just copy paste this I don't know why I'm pasting it like that oh and I forgot my where's my Alchemy key I paste that in there too all right so once this is done deploying I'll just run this command we're almost there this is the slow part so close we'll be there in a minute I don't know any questions in the meantime probably got like five minutes it's pretty simple you just follow the instructions and then at the end of this you have a roll-up so you know the fun stuff though is to go in and actually hack on it which you can do so you can you know there's a inside the op stack docks there's a lot of explainers for uh what we call op stack hacks which are things you can do to mess with the op stack so you can do things like add a pre-compile you can manipulate the derivation function so the derivation function is the piece of code that looks at the transactions on L1 and figures out what the L2 blockchain should look like as a result but you could do stuff like one of the examples that we give is have something that automatically tracks the burn on L1 so every single block track how much you know how much gas is being burned in that block and automatically update a smart contract on L2 to reflect that new thing so you can essentially the way that you can think of um the way you can think of all these chains is that they're really just indexers on the L1 State and we made it really easy to modify the indexer so you can index all sorts of stuff you could create like a a blockchain that only exists to index uniswap trades or you could have like an oracle on Layer Two that automatically pulls in chain link updates from L1 and makes them immediately available on L2 so there's a lot of different things you can do but that in order to do that you just need to modify the the derivation function and there's a tutorial in here about how you can modify that derivation function yeah so you so the question was if you wanted to index like every block and every you want to index every transaction as well you can you can index literally whatever you want yeah you could build like a whole block Explorer that's actually a roll up like like a roll-up that indexes a whole bunch of stuff on L1 and then pipes that data into smart contracts on this layer two and then the cool thing is that the whole thing is you can you can like fault prove it right like you can run these optimistic fault proof so then not only can you like have a roll-up that's actually an indexer you can also have Smart contracts on layer one that like read the data from the roll up and act on the roll on that data so I mean it depends on how fast you want like your proving time to be you know like I mean you can make it if you're okay with the security properties you can make it like 30 minutes or an hour or something like that um you know and eventually you'll have ZK proofs to be able to do the same thing to be able to prove it pretty much immediately so you know the future of this is that you have these very very detailed indexers that then then report data back to layer one so the like the layer one smart contracts can just access like all of the information of every other smart contract in an extremely efficient way um okay great wait what is this uh phase two did they change so here's the other thing about this is that the is that we're also modifying this at the same time I'm I'm not surprised if they did not update my no wait phase two wait phase two oh okay wait wait wait I think this is good I think we're good we're done we're done okay great so I should just be able to configure this now boom all right so I have my Genesis Json file that I just generated I'm going to generate a Json web token as well so I've done that I'm going to copy that so I'm going to copy genesis.json into uh opgath I'm going to copy the JWT into opgath all right we might not get around to running the batch or but you'll get there okay now we just initialize Geth that's easy enough I just run that initialization thing boom we're done initialized um Okay so the next thing is to run opgf I just need to export a couple things into export whatever come on all right we have to automate this a little more the thing is we didn't want people to audit we didn't want to automate the tutorial too much because then people would be really confused about what was happening under the hood but I don't know that's the wrong thing too okay ah all right just follow this export all the things that you need to export [Music] and the address of the L2 output Oracle is the last thing that we need I don't know why we need this deployments getting started L2 output Oracle proxy okay all right so hopefully this just works now [Music] okay all right so Geth is running that's simple um and now we just need to run the the op node hopefully and of course that doesn't work because it's a different terminal Okay so all right let me minimize this so we have the two things running um yeah so pretty simple at this point we have the we have opgath running we have the op node running it's essentially iterating over the chain and figuring out when you know it's it's just loading bits of the chain right now it has to catch up so we're at three two seven I don't know what the current Gurley dot what's the current block current block is 397. so if you give it a second in uh in a few seconds it's going to start producing blocks at this point it's going to start producing empty blocks uh and I've been told that we have to kill it there but if you keep following this uh it's I mean at that point we have we have a a sequencer running at this point so then we just start submitting it you just have to run this bachelor program and that's it you just you just make sure that the bachelor has some eth start running and you have a roll up and then you can do whatever you want so start messing with it there you go it's producing empty blocks start sending it transactions it'll produce non-empty blocks all right I'm getting kicked out but if you want to keep chatting later go to stack.optimism.io have fun mess around do crazy stuff and I'll be here all right bye [Music] [Music] foreign [Music] foreign [Music] foreign [Music] [Music] foreign [Music] hello everyone my name is Alexander and here's with me my colleague Dima and we are from polygon ID and today we will demo you how to issue your first credential and verify it on chain so let me first start with what's what's polygon ID so polygon ID is a cell soaring identity solution that is leveraging zero knowledge proof technology for ultimate user privacy basically it is scalable it is verifiable on chain and off chain and we are using verifiable credential standards and dads so how how it works in general so we we have basically three parties it's uh identity holder it's the user that is having his credential there is always issues that is issuing credential so it's it's like a source of trust and verifier it's a party that is requesting something from from the user like some statements about a user based on on credentials that he has and let's see how it works on example so a user receives credential from from a university let's say that basically it's it's assigned by uh University it's a it's a piece of data in Json LD format and it's digitally signed by the university user receives it in in his identity wallet and stores on on his device it's not on chain it's on his device and then when time comes and when a verifier needs to to get some data verifier ask some some questions and for for this we designed a special way of asking questions with zero knowledge proofs we are calling it GK query language so verifier generates a zero zkea query and gives it to to user and users and scans it with his identity wallet and accepts what what he needs to to share or to to prove and generate zero knowledge proof that is then sent to to the verifier and verifier just to verifies zero knowledge proof and checks that it's it's valid and so it's basically it on on High level um for for the builders we have um we have mobile application and SDK we have issue node for for the issue side and we have verifier libraries on hold link and on JS to to verify zero knowledge proofs and generate ZK query requests and also on chain verifier in in solidity and now to the demo okay just a second I'll prepare for the demo okay so so yes initially I will start with some explanation of the schemas so before you you will start issuing any credentials you need to build your schema this is actually the data type or like a schema that you will issue for example this can be in this case in this example this kych credential it has two attributes this is birthday and document type you can build whatever you want maybe it will be in your case passport credential and you will put five attributes or it will be I don't know like my ethereum Community member and it will just with one attribute but you are free to build your own credentials with your structures with your attributes and design what actually your specific use case will require and you will need you see here we are using the xsd types we're not supporting every types we are supporting just some subset of types because in zero knowledge proofs well you technically cannot use everything but for example we are doing some trick with Selective disclosure where you can use string values and then verify the string values with zero knowledge proofs and with this trick you can use actually any type of values but they will recognize it as a string and you cannot verify and use all the power of zero knowledge query language and for example you know chain verifications you always also will be a little bit limited but if you are like okay with to work with integer values and with like numeric data types you are fine and you can just build a lot of use cases so we have a tutorials for this I will not spend too much time for this schema Builder just because right now you need to build it manually in couple of months we're planning to release schema Builder application it will simplify this procedure so you just in the Builder just select your fields that you need and it's just generate a schema for you so it will be not as difficult as it is right now so right now let's go to the each year this is our issue node this open source you can download and run it on your local machine install it on your server or something this is specifically designed it for the issue actually this is like demo application but this is easier part it will be not like accessed by the users it will be accessed by the issue so you will issue some specific credentials for your community for your users for your I don't want different developers so for your specific needs so here you can import schema I will show you example for example this one [Music] fetch it preview so you see all the fields that is defined in the schema some fields are mandatory and they are specific for polygon ID and for verifiable credentials like issuer issuance date expiration date and you have your custom Fields like Thursday document type maybe credit score and this is will be a fields that you specifically will Define so as I have this schema imported I will go back and will issue credential okay so we have two options one the credential link so create like credential and send a link to the user so he can download it to his mobile wallet or if we know in advance his identity we can issue this credential directly to his ID but at the moment I don't have my identity linked to this node so I will use the link Okay so this is a Time until credential will be accessible this number of possible issues let's say I will put one I select my type and this is a birthday I will put like 1991 first month first day document type 2. and I will create a link so now we'll generate a QR code for the user so he can download this credential by his wallet so my wallet foreign so we just connect QR code and we can get credential to our phone just just this time I usually I should receive the push notification but maybe because of the connectivity here I just need to scan and fetch it okay so you see I have a credential was this birthday and document type on my home now I can go to the verifier let's start with the website this is off chain possibility so you can build the Gated access on your website and then can I can ask hey I can ask this query so so this is a code that is hidden in this QR code um let me make it a bit bigger so we're asking the specific query to the user wallet so hey do you have this context like credential with this context in your wallet do you have this type ksh credential and do you have the birthday field that is less than 2000. so if I match this criteria we can generate a zero knowledge proof that will prove uh like this request to the verifier so verifier will be sure that all the requirements are met so let's try to do this a bit smaller so you see we have the request on my phone he's asking if I have kych credential if the birthday attribute is smaller than two thousand and I can generate a zero knowledge group okay let's take some some moment so we'll generate a zero knowledge proof and send it to the back end so backend can can verify zero knowledge proof because it's not enough only to verify zero launch groups you need to verify zero knowledge proof and if the required if it match the request that you asked so you mentioned the request and response actually all the criterias and you are verifying okay the it was used like Thursday the this birthday is less than two thousand okay so here in token I can show you the token that was sent to the verifier you see we have only some meta information and zero knowledge proof so this is a zero knowledge group that is answering on our question so as a user I'm not exposing any personal information to the verifier I'm only generating zero knowledge proof with this with the sensor so the same thing we can do with the smart contract so the smart contract also can be such a verifier that can ask user to generate a proof and prove him some like specific statements so the same request that we did for the website I can do that for the smart contract and in this case the smart contract will be the same verifier but you can build some business logic inside your smart contract for example you can build the your C20 smart contract which accept only people who are about maybe like 20 years old or like from specific country or not from some other countries like I don't like from China Russia also something something like this it's very based on your like specific requirements for your business logic so here is an example of this smart contract verification okay where's storage approves okay so the question where is story to proves actually proof is generated every time when we are answering this request and share it with verified so we'll share it so if this is website it will be on the back end of the verifier if this is smart contract I send the proof to the smart contract and smart contract will verify and like it will be no no they're generated on the flight and every time is sent to the verifier so here we just see I connect to metamask so it's how wallet connect is working first we're connecting and then generating zero knowledge proof and then send the transaction with a proof so here a generator proof and send it let's take a look on the meta mask okay to wait a second okay success so what is the request inside the smart contract is actually the same but we put this in a QR code to give a wallet some explanation right now like our wallet is not fully supported everything because that's why we need to provide some additional metadata with this transaction data this address of the smart contract and specific method that you need to call to to share the zero knowledge proof but inside the smart contract we store it the same request as we had and the same request is verified inside the smart contract so your smart contract can build a business logic and verify zero knowledge proofs and can can like request that different verifications for the users and based on this again you can build like shielded access maybe some business logic maybe you like give to your community members some additional preferences so what you can do you can build like off chain for your community members issue credentials that they are your community members and then when you will do a token distribution for your community members if they can prove this to the smart contract you will add some I don't like additional value so of the tokens or like distribute some additional preferences in your smart contract also we can build like uh like owner transferring only if I like send a specific zero knowledge proof to the smart contract then you can change the owner of the smart contract so this is query language is flexible you can build your own business logic and just extend the possibility of smart contracts with some additional business logic that will be embedded in this zero knowledge proofs what's cool about this that your identity in a different smart contracts will be different for example you can reuse different verifications but your identity will be not tracked in a different smart contract the same you can do with a with the same smart contract for example the same verification can be used with a different ethereum address so your identity kind of decoupled with us with your ethereum address that's why like you can reuse verifications you can reuse credentials and well the sky is the limit of what you can do with with query language and uh with this verifications okay um yeah that's it for the presentation we will now go too deeply in the smart contracts and uh like in the circuits just because we have very little limited time so maybe have some questions clarifications yeah do we have a specific type of proofs so our circuits they're kind of generic you don't need to like write your own circuits what you need to do you need to Define on the schema for your credentials and you can use this query language with your specific credentials so the type of proofs we have like four different circuits like a with a different type of kind of proven so we have a two type of roofs one is a signature which is well just just a signature and also Mercury proofs so for the miracle 3 proofs credentials must be published on chain and on chain so this is two type of proofs for them we have different circuits but query language and the rest of the stuff is generic so you don't need to to do like anything like to write your own circuits or write your own proofs everything is written and embedded in the libraries and you can just reuse all this functionality technically you can extend this functionality if you need for you know for your use case if you want to write your specific proofs based on the our identity system this is possible but this is baby jab jab signatures used right well we're using baby jab jab Keys specifically to prove something inside the circuits so there's a specific baggage-up job key that you need but yes it is the cdsa um you cannot use like ethereum keys for this type of signatures you need to derive like different type of keys this is like they're on a different um but this working with ethereum with polygon with any uh evm compatible chain so and kind of the pluggable system where you can build your use cases so we have actually all the parts of the flow like for the e-share for the verifier for the user for the user like for the wallets we have the sdks for the e-shares we have all the libraries gssdk that you can if you want to build your own node you can you can do this for the verifier we have like verification libraries written in Goa and JavaScript so let's cover majority of the cases and again you can write your own if you if you wish or if you need for the smart contracts also we have some common smart contracts with some standard interfaces that you need to inherit for like for your specific smart contracts this is like they extending the functionality with ZK set request and set response functions that you can replace or rewrite or build your own like specific business logic and verify zero knowledge and verify your specific cases amplify a specific requests that you will do because you can actually in one smart contract you can embed multiple verifications it should not be just one like I want to know your age maybe I want to know your age also that you're a Community member maybe if you are like participating in my double activities maybe you are like GitHub contributors and so on but this is specific for the specific implementations that will be built on top okay so any other questions good so last thing if you are curious we have tutorials on our polygon website Xerox polygon and all the things that I sh all the things that I showed they are available there you can just pause the tutorials and you will have the same result good thank you [Applause] thank you [Music] thank you [Music] foreign foreign [Music] 