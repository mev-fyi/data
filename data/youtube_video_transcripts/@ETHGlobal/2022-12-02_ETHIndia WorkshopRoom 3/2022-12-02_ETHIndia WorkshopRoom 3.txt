thank you a little bit thank you foreign sure I think there's that if it works no no no no sorry yes it's working thank you all right I think uh I've given I've been given the light to proceed so as one of the first speakers uh I would like to welcome you all to eth India and I'm Rajiv um I'm a security researcher and founder of securium I'll be talking more about that later but this this talk it's it's definitely not a workshop it's it's a talk uh 30 minutes is not enough to dig into how to do smart contacts securely but we'll be talking a lot uh well I'll be talking a lot about the high level aspects uh trying to impress upon you the the status of smart contact Security today what is what is the status is it enough why isn't it enough what what is being done what are the challenges what are the opportunities and so on so hopefully it's going to be very relevant to you all um you know as you hack away your projects you need to pay attention to this so that your projects don't get hacked later on right and the just a quick note about the title um I know how many here are old enough to be fans of the western genre of movies but my dad really likes one of these Wild West Classics The Good Bad and the Ugly with Clint Eastwood and some other characters so that's what we're going to get you know I'm going to talk about that uh well taking inspiration from that but really flipping it and starting with the more skeptical pessimistic Outlook as to what is wrong what the ugly side of security the state of security today then get into all the things that are being done badly in smart contact security and then finally we'll end with an optimistic tone of you know the the good parts of why we are here and all the things that we can look up to so if you if you Google um for a stock image of security and swiss cheese so swiss cheese is uh you know one of the favorites of all the security researchers and it looks like this it's you know it's one of the cheeses if you've eaten it has a lot of holes and that's how the security folks see all the platforms right so there are seven layers to the platform there's typically a front-end a middleware a back end and all of them have bugs vulnerabilities some small some big some of them are patched and you know many are not so when you look at the vulnerabilities right the hazards as this document says so you have a lot of vulnerabilities that are you know being exploited that are attempted to being exploited and if you notice there are a few of them that get prevented because of all the security measures at different layers and then some of them pass through so the arrow that passes through is um is the loss that is not prevented right and in the case of um in the case of the crypto Wild West are we still on can you guys hear me okay so um so in the case of the crypto Wild West this is Amplified I would say like 10x if not more so there are a lot more layers a lot more holes a lot more arrows being shot at the Target and many of them going through right and we have very few plugs that actually prevent these hacks today so security is all about I mean it's all really about assets right security really looks at three aspects we have assets that are protected by the good actors and then you have the Bad actors who are trying to get those assets right without the right authentication and then we have a lot of actions that make these two things possible right so it's I mean this is this is sort of a way of life but it gets Amplified many many times over in in the crypto Wild West so you have the good actors but wherever there are a lot of assets you obviously attract the Bad actors who go after those assets and many of them actually succeed and you know you have a lot of these wanted posters that we have to deal with later on so how bad is it right how ugly is the situation here's a dashboard from defy Lama which you may have heard of um so I think so this was a statistic that was collated by one one researcher over there and uh you know the dashboard was created and we'll also look at the framework later on but this is what it is this is the state and if you can't notice the numbers what this is showing is the top 100 most severe exploits in terms of the funds lost only in the last two years right and if you look at the y-axis I mean that tells a story so this is we're not looking at thousands of dollars we are looking at hundreds of millions of dollars right so every line that you see in that access is 100 ml 200 and so on and then the story really starts all the way back to the Dow exploit so that's the first bar that you see that happened in November of 2016. and then there was I think the one in 2017 was the parity hack and then all the others are really in um the last two years right so we'll dig deeper but this is the state of Security today or insecurity today and if you look at the total value hacked it's a non-trivial number right it's close to six billion dollars and most of it uh and we'll talk more about bridges so a lot of it was lost because of Bridges or because Bridges got exploited but close to 5 billion dollars got lost in D5 right across the various protocols and this is all in smart contracts right we are not I mean this discounts any of the centralized exchanges all the mess that you guys have been you know that we all have been uh reading about in the last several months so this is unacceptable right if we want to be a layer that is a financial you know that settles Financial transactions where we want really to trust in code it has to be you know everything else should be trustless or trust minimized and we want to trust in code then the code cannot be this insecure because if this is a state of the art then we cannot expect people right retail institutions to really trust their money and put into these contracts right over time so this has to change so this is really the ugly part now let's sort of dig deeper into few of these statistics this and this this particular analysis created a framework for um the different types of hacks to categorize the different types of hacks I haven't looked I haven't analyzed if the data is complete or if it is accurate but I think it's a good running example to you know hopefully make the point over to to everyone here but if you look at the frequency of hacks by categories right so the the analyst decided that there are four categories we have infrastructure protocol ecosystem and smart contracts but the way to think about it is infrastructure is really everything that is not related to Smart contracts so anything in the web 2 space anything that is off chain anything to do with custody of private Keys all that falls in that sector right in that bucket and that is non-trivial right so that is 23 in this analysis so the the story here the model here is that yes smart content and all the other three sectors add up to 77 percent right so smart contract security is way way more important but you cannot ignore the infrastructure the web to the off chain parts right so that's the takeaway here and we um maybe there's a good point to talk about some of the categories right so protocol according to the analyst the protocol category really is all about the smart contract logic that's been implemented within your protocol right so as you go and hack away your projects whatever the application is you know it could be a decks it could be anything it could be an nft trading platform anything right so the logic that you write in salinity or anything else that is the protocol logic right and there could be bugs there could be vulnerabilities in that logic those could be exploited to really get all the tokens in um you know in your protocol ecosystem according to this analyst is anything where your particular application works with other applications right so think of flash loans and we'll get more into that so that is so anything external to your protocol but that is still on chain oracles other protocols other dependencies you have all that comes into the ecosystem category and finally the smart contract is actually the smart contract language or platform category that is really all the hacks enabled by virtue of the evm or the language itself in which the smart contacts have been coded up right so let's dig deeper before that so if you look at the frequency over time I mean there is no sort of key takeaway here except that I mean these are happening every month and note that these were the top 100 exploits right the minimum was I think like three or five million dollars exploited so there's a long tail of exploits that have not been considered in this analysis right and day in and day out I mean if if you're active on Twitter just this morning I think there was an incident that was bubbling with one of the protocols on the branch chain where uh I think a deployer key got got stolen and then the attacker actually deployed um you know upgraded the contract which had uh sort of a different mint function that could be rugged and the attacker minted I think billions of those tokens and the you know that was still uh being analyzed right so there are all these things happening on I think the takeaway here is that these hacks are happening every day right I mean every week if not every day right something is growing and the funds stolen are non-trivial right so look at the y-axis it's 200 400 600 million dollars and the and these have been the numbers have been compressed you know uh to to report on a monthly basis so if you look at some of the the longest polls here right the longest bars uh the longest columns here there have been hacks I think the largest amount was north of 600 million dollars right so those were um you know most of them in the 600 500 range were all Bridge related attacks just because they hold so many assets but those are the ones that you see here in uh red and um yellow so this Rises some of that into the different categories and the hacks again the bridges stand out so if you are interacting with the bridge if you're building a bridge if you're you know building a protocol that works with Bridges something to pay a lot of attention to now let's go into the smart contract language that category right so the two things that I would like to call out here are the re-entrancy and the delegate call exploits so the first major exploit on ethereum which is well known well publicized is the Dao exploit right this was in 2016 of November it was I mean it really opened uh our eyes to a re-entrency exploit and since then you'll be surprised to see how often the re-entrancy exploits I mean the vulnerabilities exist in different code bases and they're exploited you know on a regular basis and the second one would be the delegate call exploit I mean delegate call is something that you need to wrap you know we need to wrap our heads around because this is a functionality that if you have coded it in any of the other languages you wouldn't have really paid attention to but in in smart contact languages when you do a delegate call there's a lot of things that happens in the background that if you are not paying attention to it could be a recipe for disaster right so those are the big takeaways here and when it comes to the ecosystem hacks uh the keyword like I said earlier is Flash loans and one of the big categories there is the Oracle price manipulation attack right so just just Google for it there are fantastic ad articles written about it um so this is extremely common right so this is like 50 of this category is all price Oracle manipulation hacks that's still you know that continue to happen the second category is The Flash loan governance attacks so if you have looked at any of the token based governance models then flash loan introduces a new Vector where somebody can you know flash loan a whole bunch of tokens that are used for governance and they can make the governance go one way or the other right so all these you know pretty pretty graphs pie charts are there in the source I didn't create them I think it's a very you know good way to sort of convey the point so do do feel free to go and take a look at it later then if you look at the protocol logic so if you do recall I mean this was one of the biggest sectors right of the hacks so in this case there are obviously many many components to this because that is the nature of application logic depending on what what your application is doing you know you could have new ways attackers could have new ways to exploit it right so there are many categories here but the ones that stand out are Access Control exploit so Access Control if if you know is something that is fundamental to security if you don't have the right access controls you know some unauthorized in this case an attacker can mend can do something else with your contracts and exploit the funds right and the other one that is really common is the math mistakes so if you're looking at anything in the space right unless it's a very simple contract there is going to be a lot of math especially in the defy space right you have numerous protocols that are trying to optimize every aspect of you know D5 lending derivatives uh all those aspects right so those again are places where developers make mistakes and these are not very easy to spot right because these are extremely uh you need to understand the protocol logic you need to understand the math there are certain Corner cases in solidity or the math library that you're using you need to be aware of all of that now the so this is uh this is an interesting one right so if you look at the hacks by Chain the the wrong takeaway from this is to say that oh you know the the biggest change right the biggest sectors here are the most insecure now the reason why you see ethereum or BSC right or the the other l1s or any of the other l2s right so these are the places where there is a lot of innovation happening right there are a lot of protocols being deployed you know either Originals or in some cases clones and in the process of cloning you may have copy paste bugs as well so this is where there's a lot of activity this is where you have a lot of assets where a lot of actors a lot of actions are you know persisting right over time and so it's natural for the security or for the attackers right to go after places chains where there is a lot of activity happening because or where there are a lot of assets locked because that is how they get to exploit it right so that's sort of the takeaway all right so we talked about sort of the ugly and the bad uh pictures uh yeah can we get to the questions at the I'll get to it at the end I think there's a different setup I need to use for Q a but I'll get to it um so if you look at so if if you're not convinced that the State of Affairs is bad or ugly right then please please reach out to me after the talk I would like to chat with you but this is you know not the state where we want to be and definitely not the state where we want to head towards right and the reason for why this may be the case so I have sort of listed 10 aspects of web 3 which makes thinking about Security in this space very different from web 2 right so let's let's sort of dig into each of them and uh see why those matter when it comes to thinking about the security of the space keys and tokens I mean this is something that is fundamental to web3 I'm sure you've heard of not your keys not your tokens the way we think about Security in this space right unlike the web 2 space where you think about passwords here we are looking at keys and tokens once you sign a transaction once it's gone right it's not reversible right and the way I mean there are challenges not just with custody of keys there are challenges with how it is used with every aspect of it right and tokens there's a whole bunch of them and that itself over the last five or six years have led to Unique exploits if you've heard of you know erc20 you know the exploits there erc721 erc77 so each of them comes with its own flavor of attack surface right so that is that is one that makes us very different but the thing that is fundamentally different in this space when it comes to thinking about security is the threat model so in security you always think about two things trust model and threat model who do you trust who are your threats blockchains are all about the Byzantine threat model so look it up this is a threat model where anything anywhere any place can be arbitrarily malicious there's really no notion of a trusted Insider and everyone else like how we do in the web 2 space anyone right it could be the miners the validators the developers could rug uh the users could abuse the system over time it's really all about the mechanism design so this is something that has to be you know critical I mean that has to be front right and Center when you think about Security in the space and obviously Unstoppable and immutable I mean this is where we are headed to uh definitely with the layer ones smart contracts I think that's the ultimate goal but then you do have the possible features emergency recovery upgradability and other things where a lot of things can go wrong but this aspect I mean imagine if your contract that you deploy right is Unstoppable and immutable think about what if there are bugs in it can you fix it can you stop it can you apply a patch right all these are very different I mean the way you need to approach it in this space is very different and we're just I mean we are less in this space ethereum space we are less than 10 years right into this you saw the history of ethereum as you walked along the hall right so like 2013 2014 and we are less than 10 years right so we have a new architecture it's evm based 256-bit stack based we have new languages mostly solidity we have wiper bunch of them coming up we have many tool chains uh I don't know what to use hard hat brownie but now there's Foundry whole bunch of them right so all these things are still very early and they themselves may have bugs that could lead to security exploits the other interesting aspect is that this space the ethos in this space is open source and transparent by default right with smart contracts you deploy them the expectation is that that the source is going to be verified it's going to be open um and it's going to be transparent right so there is no more walled Gardens where you can hide behind security by obscurity right everything is transparent to anyone right to your users to the abusers to the attackers so it's not just in the technical layers but it's also in the social and the governance layers where security is different pseudonymous teams reputation has to be thought out in a very different way Dao governance has to be thought out in a very different way the way that you can roll out security patches on a protocol that is governed by a Dao there's going to be a window uh there are in a compound for example had an interesting incident with that then composibility by Design this is again you're not you're not your protocol is not going to operate in a silo right it's going to work with you know maybe an oracle feed maybe other protocols maybe definitely you know the off-chain stuff a lot of lot of things happening so the attack surface here when you think of composability right and this composibility is changing over time this makes the attack surface right grow exponentially what your constants are what your constraints are right what what configurations are all these things keep changing so it's really a moving goal post that has to be paid attention to and all this is happening in compressed time scales and what I mean by that is I mean if you've been in crypto you know that one day or one week in crypto is like 10 for the rest of the world right there's there's so many things uh that happen in crypto that it's really hard to keep track of but then there are all these new things that are happening so how does that affect security becomes an afterthought right so there are a lot of shortcuts that are taken that a lot of partners that are cut and think of your development right so as you finish your hackathon how much how much time have you spent in thinking about the design do you have a documentation for it have you written a spec for it right what are the invariants what are the properties right all these things sort of get moved to the side or get pushed under the rug and then projects get deployed right which is a significant factor in them getting exploited right so this is not right and this leads to this if you've heard of the test in prod mean this is what you know causes where the actual test is happening in production so you see failures you see exploits that are undesirable and finally if I mean I've talked to many developers in this space and when we talk about when we say security the first thing that comes up is audit so security has been audits have become synonymous with security in this space which is not desirable right I mean audit being treated as a silver bullet is I mean if you understand security that is not the place to be right I mean audits are critical today but you can't just put it over the fence throw it over the wall and say hey you know what I got an audit great everything is going to be good I mean majority of the hacks that have happened right if you look at the details a lot of them would have got audited right so things would have got missed things I mean a lot of things that would have gone wrong in the process so these I think 10 sort of vectors right really make I mean should forces to think about Security in this space with smart contracts in a very different way so it's all I mean it's not all bad um let's let's talk about the good right so there are again insecurity this is something that's very well known right in security you think about three stages things that you can prevent things that get through because you couldn't prevent so you had to detect them so that you can remediate and respond so today a lot of the focus and security is happening in the prevention space which is good right I mean there are still big big gaps so audits for example is something that I mentioned there is a lot of emphasis on audits a lot of Reliance on audits that needs to be tempered with an understanding of what an audit is and what it buys you it is not a guarantee of uh you know zero bucks by any measure so there are multiple multiple teams innovating in the audit space so uh audit contests are something that that is interesting so you may have seen code Arena and Sherlock where you have audit contests where the audits are being crowdsourced right so that is that is an interesting sort of innovation that is happening in this space um then there are a bunch of tools and methodologies that are being innovated here you have Slither Echidna from Trailer beds you have scribble and others from consensus you have formal verification tools from sartora so I mean this is a space where formal verification actually becomes much more tractable doable and very attractive for various reasons so I won't I won't get into that but sultura has a top tomorrow so if you're interested do attend I think you'll find it interesting so a lot of lot of things happening in the prevention space then we get into detection these are things where projects have been deployed you know on chain and now um you know there may be bugs so what do you do right so you do have bug bounties bug body platforms like uh immunify which you may have heard of the bug bounties I think the last number was like 60 plus million dollars have been handed out by immunify to various white hat hackers who reported these bounties right so that I mean that tells you the the scale of things in this space then you do have Innovation happening with the tenderly on the monitoring side um and filter so look them up so all these you know they monitor on-chain activity for um for what may be anomalies in the behavior and then they send you uh reports right I mean open supplement Defender whole bunch of tools in this space so a lot of lot of things happening response is I would say probably not I mean the the space that hasn't uh I mean it's very ad hoc today right what happens when there is an instant somebody somebody notices something wrong with the protocol you know based on on-chain analysis they raise them you know they put they send a message in the protocols Discord or telegram then something you know gets posted on Twitter one of the white hat hackers or security researchers learns about it and then they start diving and discussing this on Twitter and then if there was an exploit I mean an active exploit that could potentially be uh I mean that's still happening that can be stopped then there is an ad hoc war room that is set up and then you do have uh sort of an adult set of white hats who get called into the War Room who try to go and you know front-run the attackers and all this pain all these things right so this is I mean this is good that it's being done but there's a lot of scope for improvement in this space in in terms of response right and there are a lot of people a lot of teams that are working on various Solutions in the space I mean I just uh I mean these are like 64 security researchers and teams um who are building tools and services in this space and um they were all uh you know they were all speakers at uh trustex which was an event that secured him hosted in Amsterdam earlier this year so we we do have a lot of people but you know you saw the scale of things right six billion dollars we have like 600 plus protocols being tracked by uh let's say defy Lama right so we need many many more so as you go and hack your projects think about the security and you know if you're really interested in security do come there are many of us here do come and reach out there are many you know ideas that need to be worked on there's a lot of heavy lifting that needs to be done right not necessarily by people dressed like this but there is a lot of work to be done right and we have a long way to go right so how does aquarium fit into the space so securium is the mission is really about educating and evaluating ethereum security it started about a year ago and secureum is known really for its boot camps free smart contract security boot camps entirely online and you see the QR code that's the you know address of the Discord everything happens over there it started about a year ago with a grant from the ethereum foundation where we also collaborated with some leading Partners in this space that you see here completely free we had you know thousand plus people sign up 600 plus people who took I mean this was a boot camp right this was a boot camp uh for three months right and fantastic fantastic turnout and since then what we have done is we've moved away from a discreet three month one month kind of a boot camp we now have an always running boot camp that is free for all the participants every month there is a smart contact security quiz that is designed by securium or one of the mentors and uh yeah I mean challenge yourself uh come reach out to us and there are many other security players like I said as well and with that I'm done so I'll be around for the rest of the event so if you have if you want to talk about security do reach out we'll be happy to chat more and I think I have a few minutes for questions for which if you speak I think if you speak into your into the microphone then I should be able to hear and respond to you well one there are there any questions I think there was one question from here all right let's see if this works no oh does he need a microphone oh I think you have to use a microphone I think you had a question about this so this different color are different protocols or no these are the these are the layer one chains right so you have you have ethereum okay this this doesn't show so you have it all the protocols on ethereum that got exploited are in that blue sector okay yeah so there is a protocol so why ethereum is in multiple times yeah those are all the bridges okay so yeah that's the question like the different color represent a different uh protocol and bridges yes so you do have l1s and then you do have the bridges where you have multiple L ones and then you have some l2s as well so you see arbitrim you see polygon um I don't think it's a optimism but yeah sure yeah okay uh the question is uh the Oracle is a very critical part of if we want to have a blockchain once currently we have the access of data which are the on chain on all of them but if you want to the accessible the smart contract application over the use case of a normal people so Oracle is one of the key part of that so some of the companies are doing a good Oracle but they are data are not efficient so so modularized as per our application requires so how the Oracle solution are we can improve on a better way in the future maybe like which type of oracles are should be the best and secure way to use those Oracle actually right so I think I think there's a lot that we can get into the details of the oracles but I mean in general right the things that you want are from an oracle you want it to be decentralized right and I I talked about the The Flash loan and the price manipulation so you really don't want that right so I can I can point you to entire blog articles and research articles that have been written on that right so as a user I mean I don't know if you're asking it from a user's perspective or from uh um you know protocol developer perspective but from a protocol developer perspective if you have a choice of oracles right you need to see you need to think about decentralization you need to think about availability and really dig I mean this is I'm just scratching the surface I mean these are the key points and then how are you using that data right the staleness aspect of oracles right whatever feeds you're getting price feeds anything else that you may be interested if they get stale what is the impact to your protocol right so I think those are all the things Yeah so basically means as Oracle like for example Oracle got hacked or some project was good hack as in the Jews said the response detects and so if you detect after deployment some response so there is one tricky thing like this some people tell that upgradable contract are not good because that are the the basically the the key part of that like uh you don't uh owning that contract anyone can come and the protocol can change this contract so basically if you detect the on chain any issue or any security bug so are do you recommended to have the contract of protocol or D5 protocol should we have upgradable or it should be the the migration like migrate to one to other or what was the best so there are yeah so there are pros and cons I think there's the community is divided between upgradability and in the bad the good thing about upgradability is you can upgrade fix the bugs the bad thing is that process itself very few people understand how to do it in a proper way there are so many you know proxy patterns that you can look at and each one has its has so many new answers right so again happy to chat and to go to the details I don't think there's a clear answer because it's it's about ease of upgradability I mean ease of um you know fixing bugs and anything else versus the downsides being if you don't do it the right way right you're I mean forget about upgrading you right you're you're done yeah so I don't know if you have time but yeah maybe one more uh I said I have two small small questions first thing is in the recent times a lot of hacks have been on the bridges uh end of things yeah so how can we improve on that security part on the Bridget side and the second thing is uh like me and my friend here we are the part of an in-house auditing team at a service based company and we are extremely interested into security we started doing all the online ctfs that are there and even reading this aquarium blogs as well so what else can we do to you know get uh speed up on the faster uh get speed up on the security side of things like learning that yeah so I think the second part I'll take it offline we can chat more right because that that is uh I mean there are so many things you can do to speed up but I think it's also about how much time you spend and you know the resources and so on but your to your first question I think the bridges out of the top uh four Bridge hacks I think one was really you know based on um the the web 2 side of things right there was a spear fishing um somebody somebody's um laptop got I mean server whatever it got hacked and then they got access to the validation Keys uh so validator keys and that you know caused you know they got all the five out of the nine and so on right but the others were about smart contracts about the logic right so I don't think there's a simple answer of you know would one thing have prevented every you know each each one of those um but I think it's really all about the entire process right so there are many things that can be done and we are still working on it all right I think I had one question yeah uh okay sorry I think I'm done we shouldn't find me outside yeah happy to talk to you thank you thank you foreign right yeah all right hello okay everyone we're about to start uh you all have headphones with you just tune in to channel number three uh to listen to what Alec has to say and uh we're about to start we're going to close the doors but obviously entry is still allowed and uh please do not take the headphones with you and after the talk is done you will also have time for a q a all right thank you thank you welcome everyone Thanks for uh thanks for tuning in super excited to be here I am Alec wantock co-founder and CEO of ballast and we do Universal software deployment and monetization and uh I'm going to tell you about what that is and uh hopefully we're going to be able to do a demo here but the internet has been quite shaky so and unfortunately my demo does require internet access but uh we'll go over the uh the overview and I'll show you some Great Links where you can find some resources to get started either way but uh yeah let's just jump into it but uh yeah at the end of the day right now today web 3 is not fully decentralized and even though we're putting massive amounts of energy into decentralization it's pretty much completely centralized at the distribution layer so even though we're building all these web3 protocols we're falling back to web 2 platforms like GitHub and versal netlify uh and app stores and so really at the end of the day these problems these have major problems in that they own all of your products because they have ultimate control over it they actually own all of your users as well and the crazy thing is is that when your users actually buy something they don't actually own it either because it's just a mark in the database somewhere and that they could control that and remove it whenever they feel like it so it's this really crazy situation that we found ourselves in because we're relying on all these centralized companies and Gatekeepers for Distributing our software and at the end of the day also they take often 30 plus percent of your revenue and when you're actually Distributing software you often have to tie multiple different uh SAS products together and everything like that so at the end of the day all we're trying to do is publish and potentially monetize our software and they're making it pretty uh insane but uh it's a good thing that we do have the tools to solve this and that is balanced so valus is a web 3 native software deployment protocol that is designed to replace all of these traditional Gatekeepers it is an easy way to deploy any type of application you can deploy web apps mobile apps and desktop apps in a super seamless easy way and then we deliver it to every single platform as well and basically what we're doing with ballast protocol is we're taking the same security that powers these multi-billion dollar blockchain networks and applying that to the software distribution process and so we're basically getting the security that we get from all these multi-billion dollar Networks right out of the box and really let's just save a bunch of time and money from configuring things and reducing the operational costs and the ability to uh avoid these crazy fees as far as the marketplaces go as well because now you can directly monetize things to your users instead of going through a company so valus also securely delivers software to any platform you could take pretty much anything as input you can connect it to a GitHub repo or you could drag and drop your build we support web desktop and mobile platforms which includes of course websites uh Mac apps Windows apps Android apps and Linux apps and then everything is stored on ipfs and filecoin and we use polygon for managing the access control and managing the accounts the projects and then the versions underneath so all the core logic of the protocol is powered by polygon and basically it just ties together all these different protocols and is super easy to use interface and then once it's all deployed there we make it available on regular HTTP so you get an ipfs Gateway URL out of the box as well as a web 2 subdomain for free out of the box and it's of course available on ipfs and our desktop mobile clients as well and then we're rolling out the ability to also publish to the existing app stores so that you can get the best of both worlds and then to avoid the 30 fees you could direct them to the ballast desktop launcher and mobile launcher so uh we can avoid that 30 Marketplace fee and replace it with a five percent protocol fee that protocol fee also covers the gasless transactions so you don't have to actually hold any crypto to get started uh you could just basically publish for free and get it going uh it also covers all of the decentralized storage and everything that surrounds it um and instead of having to tie together multiple SAS products like GitHub versus nullify or a fast lane and configuring all these build pipelines which could take weeks to even months to do in a production ready environment it's just one single interface and you could just go ahead and pick your platform pick your targets and click deploy and you should be ready to go in really minutes and uh what does web3 web software distribution really look like so it includes the base fundamental features that you would expect from any software distribution system which includes being able to deploy your application being able to fetch and install it in an easy and secure way as well as auto updating it and then we have this awesome thing called software license nfts so that if you're actually trying to sell an application you could go ahead and create we use ERC 1155 for it basically all you have to do is set pricing for your product and you can accept any types of tokens as a payment mechanism and then we're also adding Fiat Gateway on and off ramp support so that your users can also purchase with cards if they want to um and then you could withdraw into fiat currency as well but so basically it's using crypto as the the backbone and and the rails with awesome interfaces on top to make it super super easy even if you've never used web3 before or if you're a web 2 developer and you're not even trying to get into web3 you can definitely still use this and get all the benefits from both and really this looks pretty familiar to existing things like we poured over the the common features from platforms like versal and steam and GitHub which includes the ability to version your software uh publish and auto update your artifacts and manage both the team level access control and project level access control so you can add any addresses to an account and then they can publish to any projects underneath and then you could also be more specific about the access control and say hey this key can only publish to this project and you could also do really interesting things like multi-sig releases so if you're very security conscious about this or you're a larger organization or if it's a protocol that multiple teams are helping build they can actually come to consensus and coordinate on these builds as well so it's a really interesting uh way that we could sort of escape the web 2 uh version and once reported over again we have a unified interface for publishing web desktop and mobile software and then we're no longer relying on a single entity for distribution and if you're using the native ballast desktop and mobile clients that has its own ipfs node built in so the more people that download and use your software the more resilient it becomes we also host back-end infrastructure and and synchronize and make sure that everything that is uploaded to ballast has a copy on ipfs and filecoin but you could plug in your own infrastructure you could plug in your own ipfs nodes you could plug in your own polygon nodes whatever you like or you can even do hybrid deployments and use some ballast.io stuff for some things your own infrastructure for others so it's really up to you however you want to configure it or you could completely self-host and not rely on anyone at all and uh you can basically monetize software like I mentioned with software license nfts and so essentially this is a new way to do digital Rights Management DRM and traditionally we have to go through Apple Google or Steam and basically give them 30 of our revenue for that or we have to tie a bunch of these other crazy apis together and Licensing systems are usually very complex and they're changing a lot but this is the most modern way and it's the the web 3 version of the DRM and this is the future of digital Rights Management and again you're monetizing it directly with your users so you don't have to go through any entity for doing that and uh like I mentioned as well Dallas can coordinate releases organizations can coordinate releases um in various ways and add different levels of security there and then we could do really really cool stuff like creating an auto update system powered by smart contracts and ipfs so for even use cases like critical infrastructure you can imagine that these things could be updated whenever you push an update the rest of the devices can actually pull that update from each other since it's all decentralized storage and CDN from that and so yeah it's again a more advanced way to deploy auto updates to your infrastructure regardless of what type of platform it is and how does it work well basically um I'll keep this uh as high level as possible but we use web3 native building blocks to create this secure infrastructure and basically create a new software publishing protocol layer for this so from the software developers perspective all you have to do is just publish your software and we use your wallet as a web3 native identity but if you don't have a wallet we have passwordless email login so you could just log in with your email address and get moving no problem and then you can manage pricing via the software license nfts Say Hey I want to if I'm selling a game for 20 usdc I can do that or if I'm selling an app for five usdc something like that or even your own custom token whatever you prefer you could configure that way and multiple options as such and then you could go ahead and withdraw balances in crypto and in the future in Fiat as well uh upcoming pretty soon here and then everything is stored on decentralized file storage so all the software in valves protocol gets stored and archived onto ipfs and filecoin and duplicated on different miners around the world so you're pretty much guaranteed that that software is going to exist um and then the cryptographic hash of your software is then registered in the vallus registry smart contract so all the stuff gets uploaded to decentralized storage and then you take the result of that and then we put it in the smart contract and this basically manages the entire core logic of the protocol so it manages the entire version history across your entire organization and it also manages the accounts and the projects as well so it's a it's a three layer system so it's the count that control the projects that publish releases and so it keeps track of everything there and it coordinates all of the organization members and it manages all the security features as well so super super easy stuff there and then if you're monetizing software we support various software likes instead of T networks we're deploying to several others right now as well but the idea is that you could go ahead and create that on any network and then accept payments like I mentioned as well and then from the end user's perspective it should be pretty seamless uh there's there's a few different ways that you can launch it we give you a web 2 URL as well as ipfs Gateway URLs so you could direct your users there you could also embed that stuff into your existing websites and do download links and stuff like that as well but from your the end user's perspective they're launching and uh and and downloading things and just as easy as ever but in a super secure and decentralized way and then they can go ahead and purchase the software licenses super easily and then very soon here they'll be able to also purchase that with credit cards and Fiat as well so that is basically the high level overview of the way that the protocol works but then this creates That Base infrastructure that anyone could build upon as well so how do we use it there's a few different methods so we have a web front end and again the internet is not loading and everything right now apologies for that but uh we have a web front end that is our main dashboard you can manage everything there it's super super easy it looks like virtual uh it's very familiar you can navigate and you can see your accounts and all the projects underneath and manage everything in a nice clean UI as well as set up uh automatic deployments with your GitHub repo so that's the main interface most people use and then I'll show you this in a second but the sapphire launcher is our native desktop and mobile client so this is essentially you could think of that as an alternative app store or a steam but for web3 and that has its own built-in ipfs node and its own built-in wallet that passes everything through super transparently so that from your end user's perspective let's say you're building a game right now most of the time if they were to go and pick up an item if you were minting an nft there it would actually stop your gameplay and you'd have to jump out and sign a message whereas with this it can do it super transparently when you need it and then anything that affects money past a certain threshold it'll do a nice steam-like overlay that's like hey by the way just to confirm this might withdraw like somatic from your wallet just just making sure that you want to do that and then it makes it super super seamless for the user as well and then we also have a CLI so you could publish with the CLI super super easily you could put it in any CI CD system so if you're using GitHub gitlab whatever you prefer Circle CI you can put that there as well as publish it from your local machine that also supports Advanced configurations for multi-platform releases so again just like the web front end you could configure hey I want to publish my web my Mac version and my Android version all in the same release and the CLI does that super easily as well and then our GitHub action is basically taking the SDK and making it native for GitHub but you could also tie that in with the uh the automatic deployments as well so if you're already using git of actions all you have to do is add the vallus publish at the end of your workflow and it's super super seamless and then we also have typescript and go sdks so basically the typescript SDK is what powers all of these other things so um it just wraps all the different protocols together and again is basically the core logic of vallus protocol um and then we also have go sdks for depending on your use case as well so if you're doing like you could do cool things like auto update your go binary by fetching the latest release and and doing that so really cool stuff there um the web um so hopefully I'll show you this and hopefully the internet will work but otherwise this is basically what the web front end looks like you have your accounts you have your projects underneath you could create more projects when you go inside of these you could create new releases you could configure uh the project settings as well as uh the different types of platforms that you're targeting and again it's all the logic of the protocol is is available here and a super easy familiar way and then the sapphire launcher is the cross-platform game and app launcher and so you can see here um this is a web 3 game that is launched super natively um it's got a built-in wallet there that passes everything through um and again provides that super easy familiar interface for you so instead of having to rely on the App Stores you could direct your users to this and avoid those 30 fees but it also has its own built-in ipfs node as well so everything that it's downloading gets cached to local ipfs so it becomes more and more redundant as people use your software and so the more and more people that use it the more and more copies exist and the more and more censorship resistant it becomes as well and so this is available on Mac windows and Linux and Android and iOS we're figuring that out there's definitely a lot of uh restrictions there but um that'll that'll be coming soon but uh the CLI again super easy interface basically you just install it um we use valves basically um we use your native keychain um on Mac OS on Linux we use gnome key ring and on Windows it is the credential Vault I believe it's called um but uh basically these are all super secure ways that are powered by Hardware security on your desktops it stores a fresh ethereum key in there and since it's powered by meta transactions we can add that to the account and then to publish you just publish your account name your project name the version and then the folder that you want to publish you could also do a more advanced configuration by configuring a vallis.yml file and I'll show that to you in a second but this is a really really easy way to get started and to just super easily publish and then the get of action is something very similar so all you have to do is say Hey whenever I'm pushing to the main branch go ahead and give it a publish and you could you could pre-fill any of the previous steps here in this example basically we're publishing to Acme co under the test project and we're publishing the build folder from that and and again do the access control features with this you could generate a fresh key that only has access to that one project or it could have access to multiple if you want you can add it to as many as you like but it allows you to restrict the access for that particular key and you don't have to hold any crypto inside of it so you could basically store that as a GitHub repository secret on your repo and then it will use that as a signer and where we have meta transactions out of the box so you don't have to sign any uh you don't have to pay anything for crypto and it will automatically publish super super easily there and so that's that's really nice if you already have workflows and then we have an automated uh an automated uh deployment system as well so on the web front end you could click the deployments tab and you could choose the GitHub repo and it will automatically generate the keys for you add it as a secret and set up the deployment process and open up a pull request that has this GitHub action on your repo and so you don't have to rely on any third-party infrastructure except for the stuff that you're already using instead of having to trust random build servers that who knows who's running that we could already use the existing stuff there or you could use your local machines or you could use a combination of so um and then we also have an SDK this is just a quick example of fetching the latest release you can generate the project IDs release IDs from there and basically this allows you to interact with the valves protocol programmatically and the valve SDK contains all the logic of everything so you could create accounts with this you could create releases or projects you could create releases you can also manage the pricing for your products as well as purchasing the products and you could also use it to write files to ipfs super easily we have really nice helper functions like called Write Json write file and write folder and all you do is just pass in the the file or the array of files and it gets it onto ipfs super easily and then you can use that to programmatically create a release so if you're doing Dynamic assets or things like that you could basically use that for Version Control any type of data that you want so some use cases are for that uh could be like if you're building a game you can upload certain assets programmatically and then load them in um and we have some awesome other use cases too where folks can create other accounts um and even uh universities and stuff like that underneath with with uh with certificates and stuff like like they were mentioning as well but uh but basically you could use that to get access to all the access control features the versioning features for whatever type of use cases you need that aren't necessarily supported by the front end or the CLI out of the box you could also use this to contribute new types of software as well but yeah where do we find this and how do we get started with it everything you need is on vallus.io right now there's a banner at the very top as well that says hey if you're here at eth India click here and it'll send you the guides and shows all the Bounty information that we have as well you can find everything on the docs as well and then join our Discord we're always super happy to help we have folks from around the world so someone's going to be online if you need help and we're always really excited to to hear what you're building so please send us a DM of what you're building and we're happy to to help you anytime and then like I said as well everything about vallust is open source from the ground up from the smart contracts to the sdks the sub graphs front end everything is open source and you can find it on our GitHub at vows Dash IO and you can see everything I'm saying here is is actually true so there's that and uh thank you so much I am going to I really hope this internet is going to work out for us here um it let me just see real quick if it does it looks like it's not going to we'll give it a shot all right we'll give it a shot but uh I'm gonna go over the if you go to the main website you could see this link here if you click that Banner it'll send you the guides that has information for everything that you need so it has the bounding information for eth India um and it also shows you how to create an account how to create the project and then different ways to publish and so like I mentioned you could use the web dashboard for that we have examples for publishing next.js apps uh react apps Unity apps other types of binaries and then ways to monetize your apps as well using the software license nfts and then we're also doing social media challenge for uh this actually should be hoodies but um yeah for the hoodies that uh that we're giving away as well um yeah just share a pic with the some of those team members and we'll do that and then we're also doing a ledger giveaway as well so the the top three projects that also participate in these challenges are eligible for that so really exciting stuff there um and uh yeah it looks like this uh this uh Internet isn't gonna work out for us unfortunately here um that's definitely uh apologies for that but uh basically through the web front end um you could configure all the automatic deployments and uh sorry if anyone heard that but uh this uh mic over here basically um we just released this new automation piece if you go to your project there's a little rocket icon in the top that's called deployments you click that you pick your GitHub repo and then you just it'll it'll automatically generate the key for you all you have to do is give it the build and install commands we have out of the box build and install stuff for next.js as well um so if you're building that you should just be able to click continue and then the ability to also publish to different targets is coming as well so by default everything is being published over the valves protocol but we're also enabling automatic ways to then publish to these other app stores as well so you basically get the best of both worlds there so you get access to if someone is already using these app stores which we all are right they can download your app from there but if they're more like hardcore web3 then they could use the sapphire launcher and you as well can embed download links on your website and directly use that for the payment flows and everything like that to bypass a lot of these fees so and then uh if you're downloading the sapphire client for mobile as well it'll do everything super seamlessly so all you have to say is hey just download Sapphire and you can install all my apps from there um and yeah again since that all has the built-in stuff the more people that use that the more resilient the software gets and so yeah unfortunately I guess I'm not going to be able to do the demo because it does require internet access and it looks like the Wi-Fi just keeps disconnecting and reconnecting uh so definitely apologies there but uh again the guides should have everything that you need but I will show you what at least it looks like to configure the CLI and I'll give you a preview of this Sapphire client as well so um for this basically this is our this is the desktop client that uh okay sorry these lots of technical difficulties here um but okay cool uh yeah all right okay let me just maybe Justice here all right well we're rolling with it okay yeah you know there's a the nature of demos right but uh okay okay it's stable all right cool cool uh maybe not okay foreign okay cool anyway this whenever you do see it every couple seconds um you could see that uh we we show different featured apps and different featured games uh and again send us your your apps and games we'd love to feature you um you could also see what's featured on testnet I will say uh it does require for the bounties for eth India it does require using the mainnet uh ballast site but you can see top Publishers I'm sure you might see some familiar faces there you can see recently updated Stuff newest stuff from there and then you can also launch these things as well so potentially yeah yeah so again internet stuff going on here um it's pretty intermittent so it's yeah basically uh yeah anyway so we'll roll from there but that is the desktop client um that is available for beta so join our Discord and send us a DM and I will send you a copy of that um and would love to to integrate your apps as well into that and make sure that your app uh gets the perfect uh seamless experience that it deserves um as well and then for the CLI we have an example projects repo on our GitHub as well so you could check that out and we have different examples for multi-platform projects next JS projects react projects using the SDK and node.js examples and pretty much anything you need but I'm going to zoom in here a little bit um hopefully everyone can see that boom um basically what this project is multi-platform Project demonstrates the full capabilities of the valves protocol here so essentially what this is is a combination of a go binary and a website so if your most organizations tend to build cross-platform like we'll have a mobile app and a website or a desktop app and a website or various combinations of so you can include them all in a single release with this so we just have an example for a Hello World Go binary that gets compiled to Mac builds both for Intel and M1 arm64 Linux we have amd64 in here we have a web uh front end here and then as well as Windows and then all you need to do to configure that is basically um you just set up your account you pointed at the account on vallust that you're trying to publish to you set up the project same thing and then you could give it a release here that can come from wherever you'd like as well but you just basically give it a version and it'll publish from there and then to configure the different platforms all you have to say is which platform it is and where it's at so for the web builds you just say web and then you we have it in the dist web folder we have Darwin amd64 so Mac Intel builds Darwin arm64 Mac arm builds uh Linux windows and then we have a bunch of other supported stuff as well um and you could also add custom platforms as well so there's no limitations there and again with this SDK if there's a custom platform you have you can always implement it that way but then basically we combine all of this together into a single release and then when you view that on the project page you can actually see a Mac icon a web icon Linux icon depending on what it is the launch button will default to your preference it'll default to the web first and if you don't have that it'll default to the the current running platform and then same thing for the ability to install and everything like that and then all you have to do to publish is type vallus publish and basically what it'll do is pull the same keys that are inside of your keychain um that also is shared by the sapphire launcher but it'll use that to sign a message it'll upload everything to ipfs automatically and it'll publish the release in the exact same way that the the website does as well so you can stick this in a CI CD system you can run this on your local machine I just ran this a little bit ago and that's the log that we got so I just published o215 with that and then we get our a couple different URLs here as well so you can access it in various ways and then we also provide automatic sub domains for you so basically whenever you publish a release you automatically get your project dash dash account name dot on.vals.io so we give you an out of the box URL similar to things like virtual as well from there but uh yeah I I really wish I could be uh demoing this right now because it's super cool uh and super seamless but uh yeah again if you go to the website and you view the guides there um and you come reach out to me anyone on the Dallas team we're super excited to help uh get you published and uh yeah I guess uh we will we open it up for QA right now and uh yeah sounds good cool I'm gonna put on some headphones so I can hear everyone uh and then uh yeah Whoever has the mic um can go ahead and ask their question but give me just one second okay cool oh cool I can hear myself all right well anyone who has a question uh please feel free uh to grab a mic and uh yeah we have a couple minutes here uh to go over questions uh yeah exciting stuff so yeah we'll get a we'll get some mics going I don't know if the system there but uh cool cool all right got one coming here cool cool by the way I like this uh this setup as a way to avoid like cross noise and stuff I think that's that's pretty cool definitely very clever uh there yeah so I wondered was that if I'm hosting my application on ballast so uh do I have the option like does it always run on the sapphire launcher like if I'm is it if it is running on the sapphire launcher then like you know what are the benefits that I'm getting if it is running on the sapphire launch for sure so you can always run it on the website uh you can access it in all those different ways but the benefits you get out of the sapphire launcher is that it gets cached automatically to the local nodes as well and then it has a built-in wallet so instead of having to constantly sign stuff um and uh constantly like pop out of your application to do things it passes it through every app that is is included here so uh basically if I were to launch this you could see that this is just a regular dap here um really awesome dap and then it passes through uh if I were to switch the network to um here let me uh yeah I'll I'll deal with that but uh basically yeah you could pass through the wallet uh and it'll automatically go from there um and then same thing from here so if I were to launch this um I gotta cache this but uh yeah basically as you're playing the games uh it'll pass through automatically so you won't have to worry about um help having them configure anything this is has everything built in so basically it goes live like it just goes along as a if I'm playing a game it just goes along with it so there's no interruption and nothing else exactly and if you're building a Dap then this is a way to install your dap locally so that you can access it without having to rely on another endpoint in the future yeah so it's basically like you know there's uh there's no uh listing uh Hardware or this thing any resistance that I'm facing if I'm just running on this effort launcher got it yep yep and then there's an additional benefit here so that uh yeah all of the things that are purchased through this bypass all the App Store fees and everything like that yeah yeah awesome yeah thanks for your question sweet I think we have time for a couple more cool sounds good sounds good all right well uh anyway yeah I guess um if we don't have any more questions but uh yeah definitely uh again sorry for the technical difficulties you know demo stuff but we roll with it we're in web three we're Scrappy we got this no problem um but uh yeah please find us uh whenever you're you're publishing and uh yeah we're looking forward to seeing your apps and yes send it to us in the Discord and we'd love to highlight it we'd love to Spotlight you on our Twitter spaces or do a play session um in our Discord as well um we've been doing that as well with our community members for that so real exciting stuff there and uh yeah looking forward to seeing what people build good luck everyone thank you let me just change the display for you can anyone hear me okay awesome uh hello everyone this is Sanchez metal from the next hello hello can you guys increase the volume hello guys you cannot we cannot hear now is it better uh nobody can hear me hello hello see this is full check check it's coming does this work hello everyone uh this is 2017 start with the how we can build a zap we everyone arguing that here we have an audience who was who is kind of aware of how the contracts works out and we don't have a site okay well I will start something so if anyone can hear me yeah but yeah yeah okay it sounds good um again I think I've already gave my intro I can do it third time uh this is Sanjay mittal and I don't know if Mike is working or not I'm gonna shout it up yes uh so we are building Crossing domain applications everyone is aware of dabs I'm assuming that's the case everyone is aware of how the smart contract works if not we will go through that don't worry at all uh but let's start with the mindset that if we are building adapt or any applications they are not existing only on ethereum now we have polygon we have optimism we have multiple chains which are coming up and they have their own incentive the whole liquidity segmented is all across these trains one has bigger or one has another these uh there they have these incentives which are run uh multiple times and that's why people are getting more and more interested in zaps or we call it Crossing daps uh let's start with a basic intro we which we will be using these terminologies a lot uh we are not going to say chain because we know that there are multiple uh networks which are not exactly a chain they are we can categorize it in a protocol or it could be a roll up which is very dedicated to a specific problem so uh any L1 L2 side chain and non evm comparable we'll just call it domain right uh so I I'm assuming you're you guys are with me right now and uh uh as I said zap is a cross scene domain native app so this uh any application which we will be building right now is going to be a cross-saint app that means it is available on ethereum polygon uh any of the evm chains any of the non-evm chains as long as we are supporting and we are checking accounts agnostic as long as it's secure right uh so let's start with the second part uh yes we are a bridge and people have this question are we secure is it uh we have seen a terrible year last year and we saw three billions of hack uh and uh are we are we the same no no no no but we everyone says that so let's explain how we are different but let's start with why Bridge art unsecure why we saw this three million three million oh sorry three billion three billion of hack which happened last year what happened is that we are there are bridges which use these trust assumptions which are basically validator sets uh multi-six so you are depending on these 10 people okay can I Bridge my like million of dollars for and I will trust you guys okay you three I love you and you will uh you will you will take care of me right and that's the trust assumptions which we are making with these stupid uh Stupid Bridges which are using multi-six or validator said that's a that is simply third party and uh how we can sub it and yes there are some code bugs which uh which we have to make sure that we have simply much more large audience we have these tvl caps and we have much more audited power uh audited contracts so people can go through ad and they can report any security issues which are which they are seeing uh so let's all let's jump on to why connects and uh how we how we approach this problem so connects uses modular stack we uh we don't create any new cross assumptions we are not adding any sort of value data set we are not adding any multisex what we are doing this is the interoperable Dilemma if you guys are not aware of I'll run through you very quickly so everyone um if people don't know about scalable Cinema that's okay so when we are talking about interoperable trilloma that is that is where we are talking about trust minimization journal generalizability and extensible so when people try to create these Bridges they try to take these shortcuts where they do trust assumptions and try to avails generalizability and extensibility so they can use a common interface for the bridges and they can have like a bunch of money goes from one side to another but don't don't never think about the cross minimization but we as connects we take pride in it we we absolutely take pride in is that we 100 focus on Cross minimization we make sure that this is happening and then the user interface or the user experience yes it's very important that if it's going to be horrible I'm like you are secure guys but that's right so we want to make sure that we have cross minimization we have good user experience and how we can expand it to more chains how we can make sure that anyone who is coming Crossing can easily come and they they don't even think about it like okay which roll up or which chain I'm using I just have these six five params which I have to put in and I'm all done all good so what we do is that first let's start with how we are focusing on security we focus on security by using transport layer which are underlined which are present for these Bridges so we don't create a new messaging layer we use these uh existing messaging layer which are pretty secure already or they are the securest one for those bridges so when I'm talking about polygon the POS Tech is the Securities they use valid data set but that value data set actually runs the whole chain so even anything happens to POS Tech the chain will dissolve itself right so B the POS Tech is the security on right now and for polygon and same when I'm talking about Cosmos ecosystem it's going to be IBC right and when I'm talking about Roll-Ups it's going to be Roll-Ups so V uses that as a transport layer and then when we we have another security layer above it where we have watches at whenever you are sending a message from one side to another when we when we have when we are receiving this message from polygon to ethereum we have this Watcher set we have we have 20 minutes where you can make sure that okay anyone sees that this information is not correct guys even if you are using amb if it's falsified we can make sure that doesn't happen to us we can report it and stop that that bridging uh which is coming up so uh running too quickly how we can do it we have pause button so on each contract we see that this something is going wrong we have this pause button press it so right nothing is stolen everything is secure we have TBL caps we make sure that we have a TBL caps we know that we will start with like some table cap and once we are increasing it we will have another audit we'll run through the community that please if you see anything report US we have incentive for them and we have five drills which we run through every time where we see that if anything happens how we can do it I mean uh you have to run through it right you have to be prepared if anything worse happens we have to be there and uh formal verification additional audits we do it all the time uh generalizability we have an arbitrary message passing that means that you can pass any message it could be any piece of information it's not only token it could be nft it could be a simple I love you message I don't know anyone wants to do that and if they want to send like a uh do a dow governments uh they want to see like uh do I send if if there is a away in case right now we have polygon uh ethereum on on multiple chain it's existing but how do they do go a dow governance they can use cross shape and they can have the voting mechanism properly done for this so an extensibility we are present on all the chains um connect works so it's very simple for a user or adaptive upper what they have to do only is that use this x call I will run through the interface itself they have to go through the X call and that's all it's needed for the DAP right you have these atoms you have to put in there and everything is taken care of the connects uh you can absolutely understand how the architecture works and uh you we have these providers what they do is that they see okay there is a request of completing this message I will run through it I will wait for the messaging layer for one and two hours but for users for the DAP it's going to be one to three minutes at most at most right so you're you're having these transdictions which are happening from polygon to optimism in two minutes in a single call and you can have like multiple features available you can put it in the encoding and you can have like a uni swap trade happening you can have uh uh like abundance of use cases available where you can do anything anything cool in a single call which can happen in one to two minutes right uh let's run through how we can do this uh so let's start that 10 minutes which is on the clock uh she'll be on the zap so why uh it's one click ux as I explained better liquidity what we have right now we can Avail better liquidity if we know that there are incentive provided to the routers and there are users who wants to use it uh cheaper and faster transactions of course if you go like each and every chain it's going to take like a huge time apps also it's not going to be cheaper at all you have to make these three to four or five calls where you have to execute it right you go make polygon ethereum optimism on optimism you make a swap so four calls already added right four transactions already added here uh we are doing arbitrary message passing so you can do a lot cool stuff and that's what it is and we don't pick anyone winning we are chain agnostic users are going to use these multiple platforms so we have to make sure that we can actually onboard a lot of users and that's for the dabs right and uh we have a unify interface for all the chains so it's not going to be different for anyone and uh we can pass as I said we can pass any message and that will that can be encoded into call detail uh okay uh so I will run through really quickly how we can do everything uh on these uh on these slides I was gonna do a live example that would have been so clue but uh cool but the internet is not working over here so so let's start with the anatomy of a zap uh when we are talking about these that one simple use case of interaction would be that you can use a simple x call which is available on cunning sort soul you can make provide the parameters and then you can execute it another one is that you can have something cool over here happening on source.so right you can have some functionality over happening here and then you can transfer the money so you can like maybe do some uh swap which happens over here and then you can use x call and then you go over there and then do another swap or anything whatever you like right and let's let's jump on to what we can build with this right uh we I will run through this really quickly and uh I will put in every we have these code examples where I will explain like how exactly you can do it uh it's over here right so um uh what we can build we can do token bridging we can do Simplex call where you have to transfer your money from one screen to another you can have Crossing governance where you can do voting uh yield optimization so ethereum has already consumed everything like any better apis which is already available so let's find out crossing right we can have it we can have really better API which is available on optimism arbitrum or any other chain which is popping up right now right they provide these incentive for the users to come and provide the liquidity over there so you can Pro get much better epy all across These Chains uh Dex Arbitrage you can have different swaps rate decks liquidity you can provide the liquidity to the decks again better apy uh cross-involved strategy it's really cool really really cool so if you have these walls and strategy management you can have these fonts which are already available on these multiple chains and can execute really uh I mean uh it's it's more like LP providing as well as you can have these uh have these strategies which are already given through yarn possibly and you can uh really amazing I'll go through that in one second and we have these chain across chain loans so you can borrow on one chain and provide like uh paying on on the train right uh we have cross chain nfts so let's make it cross scene right so if if we have an nft on ethereum do we want to use it on a game of optimism or the marketplace is going the chain the gas fee which is provided on polygon is going to be cheaper so we want to like make a Marketplace which is available on optimism we can trade on polygon so once we have these these things Crossing we can have much more functionality available um uh guys I know that we don't have internet but you can scan the QR code you can start with this template which is available on zap starter where you can uh I'll give like 10 20 seconds just uh this scan the QR code or read the link or click a pic and then you can go through that later on right uh uh okay so uh connect with us but we can show this QR code later on let's jump onto the straight on the code side right now um yes so we have docs which are available you can open that as well uh quickly click epic and I will just go through the next slides awesome so when I said X call X call is the main function which uh dap or the user needs to understand a user doesn't even need to understand that needs to understand that so we have these this x call function where we have these seven parameters which you need to provide to make any x uh Crossing call right so you're providing a destination chain where you want to execute this function however you want to receive this these funds and then you have these Target address uh this is to address so it could be a receiver address or where you want to execute like a new functionality that would be your target address erc220 the token which you are transferring if it's uh if it's not related to token you can address zero this and you can send any arbitrary message through that uh delegate this is of say functionality if something happens I will go through that later on amount slippage and call data call data is one of the main way you can actually encode something if you are not encoding it's a simple simple transfer you can draw just zero exit slippage maybe mentioned three percent so we know that if it's going through the amm we wouldn't suffer loss so there are like two types of building which would be simpler for you uh simpler uh which we can do uh that is X call through XC SDK so you don't have even have to jump on the contract side and if you are doing the contract integration that is going to be a asset transfers on authentic unauthenticated calls where you don't you don't know you don't have to know on the target side from where the uh where this call is coming up let's start with SDK it's pretty simple right so we have these X cards available we only uh we we are doing an approve for the token and uh once we have done that we are simply creating a call uh it's called using the NXT SDK base so you can download the SDK you just create this simple call and you are done with it and that's all you are already acrossing app uh for this uh as I said there are like lots of lots of functionality I will mention one of them which is like very popular to you guys is that Dex Arbitrage so uh on if you are talking about a price uh probably of it and on ethereum it could be way different on polygon it could be way different on optimism and you have to spot these decks Arbitrage and you can make a good trade you can make money out of it and that will happen in one to two minutes so you spot that you make these transactions your Armani and that's what the Dex Arbitrage is going to be about uh this is a simple transfer as similar to the SDK but we are not using SDK we simply want to use contract you can just under encode everything which is happening over here so you have Alliance happening you transfer the tokens and uh you have the approve happen you just X call it let's jump on to the really cool part uh so as I explained initially we had the source contract we have these Target contract right so in Source contract what we are doing over here is that we are sending a simple message that is a new greeting we are sending a simple uh hello world over here and we are just creating X call here right so when uh we already saw like if we can try if you want to transfer a token that can happen right that can easily happen you just put it with address 0 is you can put the transfer the token address and you can put the amount and that's that's what it's needed but when we are sending an arbitrary message you don't even want to use the token transfers you can do this where you can uh simply have these Target contract created where this is going to exist on destination chain and this is the target address which will be on the source contract once you do that we have uh you are simply checking that okay uh did I receive like a suffice amount if you want to and you can receive the message by simply decoding it so you encode the call data you do decode it and send it to the function so we have a simple very simple example where we are sending a simple message but ex just think about this if we are encoding a swap data for uni Swap and we are sending that we are encoding that and decodes over here and then we process that function further here so you can put any functions on the destination side and easily can execute it through this so you can uh you're talking about a one to three minutes of execution uh uh you where you are doing in a practical where you have to do five calls five transactions if you are not Crossing and you can do simply through this and yes uh these are the three examples which I'm providing over here making you do yield optimizations you can spot the best yield out of all the networks cannot known Crossing loans you can borrow one side you can give it to another side uh think of it this way we we have uh we have a position created on ethereum but I have once on polygon right so I want to complete my I would just want to like send the funds from polygon and complete my position on the ethereum and that can happen in single column that's what the processing loans are about Crossing nfts have already gone through this uh there is another part of this in the Target contract we can have authenticated Target calls so sometimes we want to make sure that this call where it is coming from we want to make sure that this is the address I want to transfer right so the source called Source address where I'm receiving that I want to make sure that On Target that it is the one and that is required in case of Crossing governance or in case of Crossing wall strategies on even craze of Crossing nfts we want to make sure that the where I'm from where I'm receiving this address uh these fonts or these nfts are I'm getting a call of executing or transferring the funds from this destination to like a c c chain and that is coming from this Source address and that time we have to use these uh this authenticate call uh so we here we have a modifier where we are putting only source and we are sending these origin sender and origin that would be a part of the reconcile call which happens underline the bridge and it will provide you the address where the call came from and that's that's what will authorize that authenticate does and that will take 30 minutes so you have these two cases where you can execute things in one two to three minutes and where you uh where you have use cases where you can do 30 minutes one hour depending on so you have these two really cool ways to actually Implement multiple ideas thank you very much guys uh that's all from me uh we can run through this all the ideas I would love to hear from anyone if you are online you can send us the send us these eggs ideas on the discount which is available on the connects so you go to the connects.network you connect with us on the Discord and we can chat more over there anything else I would love to hear the questions right now anyone with the questions uh I'm happy to take right now oh awesome yeah hi I'm Adam here so basically we are trying to build something on the next and uh trying to build it they're not once yeah can you hear me now yeah yeah so yeah what my question was like basically we are trying to build a a smart content in which we can transfer the tokens from one chain to the other and I saw the slides that basically we can use the X call functionality of connect and would love to build on that uh one more thing that I wanted to know is that can we have the access to the PPT slides as well because the code was not quite visible from back here yes for sure uh this these uh these slides will be sent shared on the Discord Channel we will share it on the ethnia as well we will have our group uh you can connect on the Discord where we can hear that there as well and also you can run through all of this on this app server so everything is provided on jumpstarter you can simply use this template and can go through the contract examples we have in put in so even if you want to use contract examples you can go through this we have like these multiple exams already provided here as well as the SDK example is on the like the pH behind us so yes everything is available hit us up we will be happy to help in any way possible we can we if you guys want to bring some we will be available throughout the night we will be available tomorrow so yes good thanks thank you very much awesome thank you guys very much [Applause] and can you hear me if I have to hear to them but they're not going I guess hello can you hear me okay hey good afternoon I'm Hari from ey blockchain research and development team today I'm going to be talking about Starlight one of our r d products compiler which allows solitary Developers to generate privacy preserving applications without knowing much about gkp or much about what cryptography go behind the scenes before I get started I want to just quickly explain what evil does and what e y does in blockchain space basically so we've been we've been building a lot of blockchain products over the past few years and we are fully focused on open and vocal about our support for public blockchains and everything we built is on public blockchain and not just any public blockchain but unspecifically on ethereum uh Global blockchain leader Paul Brody has recently taken a chair seat at ethereum foundation so that kind of shows the collaboration and commitment we have with ethereum Foundation ethereum ecosystem now if you work in a firm like ey you know many people ask me as well you know what what does Eva have to do with the public blockchain and a lot of our clients are banks and accounting firms and you know Enterprises who wants who who doesn't want to put their data into public blockchain and uh very rarely that we get a use case like for example you could have an ESD use case where somebody wants just one Enterprise want to create a carbon offset and they just want to create some nft tokens they put it on in the blocks here and that's fine for them because they don't want privacy but more often than not privacy is a very important factor uh for Enterprises to use public blockchain so most of the work that we do in our R D team is based on creating privacy tools to build on ethereum and in our privacy suits we have two solutions one is nightfall Nightfall is a ZK optimistic roll-up Solution on live2 we have already joined with polygon and it's already in testing beta version it allows you to transfer your erc20 erc721 w105 whatever it is under privacy so that's that's one bit of the puzzle right you can transfer privacy you can transfer data in private name the second bit is and this is the most important and mostly neglected one is as what about the business logic when you when you what about when you want to create a business logic in privacy or in other words uh what if you what if you want ethereum to understand privacy right ethereum's brain is it's smart contract smart contracts doesn't really understand privacy it's it's everything you put it on the smart contract is public and everybody can see it and a lot of companies don't want the data to be put in public for example your raise medical records all your business agreements you don't want them to be entered and the difficult part is it's not like a ZK roll-up solution where you're just transferring a token it's it's very customized and it's very specific to the use case so you can't really quickly have a tool where you can just put it in and then you create a private Network out of it but Starlight aims to kind of solve these problems another problem that we ran into when people came up a lot of clients came up to us and asking for privacy to be included in their solution was was it took a lot of time for us to educate our developers on what gkp is how to use this what elliptic curve is what the points are and all these things so out of all this frustration is what stylized was born Starlight kind of tries to solve all these issues it removes the learning time it takes all the burden off developers all we do is all we do is a pretty simple three steps and you can take enormous smart contract and you can have a fully private smart contact ready so I'll explain the three simple steps which are pretty easy first step is write your solar D smart contract which you already know right so Step One is check step two is you add certain decorated decorators into smart contracts and what I mean by decorators are like decades are like your keywords that you use in a normal programming language like private protected or anything which the ZK compiler The Starlight compiler understands here we have three decorators which which are smart contract understands uh compiler understands and based on the use case you have to use you have to choose which uh decorator you have to use third step a favorite and the EC one is just to run the zapify it does everything for you it creates a complete zero knowledge application which circuits with the shield contract and all the backend containers as well ready for you so you don't have to really worry about what goes behind the scenes what happens how to build a circuit and what are the commitments to be used everything is done in the back end for you the this is pretty easy for the use case there are a lot of use cases where this can be applied now that's it it's pretty easy to use right we can start using so but let's let's open the cover a little bit understand what happens under the hood here okay so in Starlight when you run this app if I command three steps happen first step is pass then transform and then generate in pass and this is how the compiler basically Works in past what we do is we take the solidity contract which is decorated now we kind of split them into two halves the first half contains a contract and then we have these decorators the mapping between the two Still Remains and now we take the solid day contract and we convert it into an abstract syntax tree or in basically into its Json form of the code itself or programming languages have this AST which you can have now this AST is a pure solid TST to which we kind of add back the decorators we splitted previously that's what happens in the first state so you do the passing eventually you will get a ASD which is the normal solidity code plus a little bit of what the decorators for added now in step two is the transformation where we take this AST and we convert it into three different abstracts and tax strings one is for generating your circuits which is for your zero knowledge proof generation and stuff second is for your smart contract smart contract basically does the on-chain verification of rows and then we have the third orchestration as Steve which which is for the backend containers and testing now once we have the three STS ready then we do the reverse of what we did in this first step that is we take the AST and then we create the code from it we take we create the zero knowledge code from the circuit ASD we create a Serial smart contract from Smart contract AST and we call create kind of an orchestration code which kind of connects all these things together no that's it so we get with these these three steps now so I spoke about the decorators and how these decorators are right so now let's just look at how the transpiler works so you you can assign that you you have a variable unsigned variable X and that you want to kind of keep Secret in your smart contract it could be your age it could be a phone number it could be anything that you want to hide from your Shield contracts hide from the public now you are a decorator secret is one of the decorators that we have unfortunately we couldn't use private because private is already used so secret is a decorator that we have and then that's the second step where we kind of decorated third step is running zapify and once you run zapify it creates everything that stands out that zap is kind of far form for zero knowledge application it contains the contract circuits and the backend containers circuits are basically built in Socrates in Starlight and these circuits contain your private public input and your information and your kind of the course as well contracts contracts is a shield contract it's not really your smart contract The Shield contract is is for your own chain verification the only thing that happens on chain is your verification of your commitments and in the backend containers we have a blockchain client which could be your Guinness get or anything that you can just configure and connect like you try and connect your device Socrates is the backend that we use to create the generate proofs and to kind of do the setup we have Timber Timbre is another excellent product by our ey team it's it's it's a Merkel tree which stores commitment in a very efficient way so that you don't really have to pass through with too much or you have to reveal the commitment to to view what it is and then finally we have a testing infrastructure which is ready where you can deploy the different test Nets in ethereum and see how it works now we now I spoke about a lot about decorators so let's see uh let's see them now right for the first decorator is secret secret as it names that if you want to keep a variable as secret if you want to keep keep a variable confidential from the information you call it secret now you can have it for State variables you can have it for function parameters we intend to add it for functions but basically whenever you want to have a variable that has to be kept in the circuit which has to be in private State you name it as Secret now I want to focus on the right side here and the yellow bits so you here you have an unsigned integer X which is kept a secret and also a function parameter y in the function add which is secret now what you're basically doing is adding X into X Plus y and I'll get to know in a bit but this is what basically does then the next step we have something called known known uh so so now we can we can do the contract right now now it depends upon we have we have the state variables and all but but what's the use of it if we can't modify it if we can't use it a lot so that's that's that's for the other two decorators come in the first one is called known is when only the owner of that particular smart contract owner of that nullify I can edit it now the second one is unknown where anybody can basically edit the data now I'll get a bit more in detail into how how the known works and it's important to know how the commitment structure of known and unknown works here so no one is a so so when you say a non but it basically means is that only the owner of that particular commitment should be able to edit the data only the owner of the particular commitment should be able to increment uh the data X plus five and somebody else tried to know with the zero knowledge application kind of throws an error so for a known to work for somebody to call the non-function you have to submit a couple of Pros the first one is the proof of knowledge of the existence of the old commitment this is this is done without really revealing the commitment by using the timber tree second is providing the knowledge of secret key knowledge of secret key is basically it's related to what the public is and you just have to kind of authenticate who you are and then once you do that you have to nullify the commitment which means that you have to kind of delete the commitment from database and then you add the new commitment so that's what known does it's pretty easy because you only have one state every time you delete the previous commitment and you have only one commitment unknown is a bit different and there are a lot of use cases when you want a lot of people to kind of many people to kind of edit into your secret information for example your balances where you want people who uh who want to transfer your money but you don't want them to debit from your account right so you want the credit to be given by everyone but the debate to be only by one person so this is the case where you know multiple people are trying to edit a particular secret variable and uh at certain situations that's when we use unknown well unknown does is it creates something called Partition variables or partition commitments where you don't have just one single state in previous state we had only one state and we kind of delete the state and we override it with a new state in this one in unknown statement we have a lot of part commitments and these part commitments come together and kind of summation of it is what the whole value is on the example as you can see balance is something that has kept us unknown so anybody who's holding the balances anybody can transfer to my balance so if somebody who's uh who's a sender here it debits from his account and from the unknown the unknown balances is actually of the recipient so it's not his own account but with unknown you can you can kind of edit his secret seat as well next one it's important to know the commitment structured a little bit the commitment the first thing that holds is the state variable ID now solidity has this state variable ID in itself which which is a unique ID that is given to each variable then is a state value State value is the value that it holds it could be a number it could be a string or anything and then the public key of the owner and we have a solved kind of award duplicate commitments or commitments that have duplicates it's pretty easy for a normal State variable because we have a state variable ID that is unique now it's a bit tricky when you have mappings or when you have like arrays where you know you can have one state Bill already and there are a lot of elements related to it in this case what we do is we take the mapping key we take something called a mapping key which could be your address which could be the array index and then that is replaced instead of the state variability so it's basically a hash of the state variable ID and the mapping key that's the first input the rest of the three inputs are pretty same I'll give you an example here of a developer use case and what really happens now we have a secret mapping here of an address to An Answer integer which is the invoice of the people that they are and then we have two functions add invoice and pay invoice what add invoice basically does is that you can add invoice someone's account and then pay invoice is you can pay off somebody you know whoever you're earning it now in this case basically what when you call the ad invoice API what happens is it checks for the commitments uh in the database for this particular owner that we have for example if you want to add invoice to the owner it checks and database for this honors database is there or not it can be done by anybody so it checks for that particular honor and then once that check is done you create a new zero knowledge proof using Socrates and you push another database now this proof is then given back to the orchestration file so the orchestrator first calls the Socrates and it creates a shielded proof means they are knowledge proof and gives it back to the orchestrator the orchestrator now contacts The Shield contract which is on chain and the on chain proof is verified once the proof is verified we update the states and everything is done now you don't have to know uh all of this to build to build on Starlight all you need to know is to write a solidity smart contract and add these decorator system and required now something that we understood is that privacy has become a big factor and something that we haven't worked on a lot a lot of Industry applications or general applications require privacy and people to be building on privacy application we believe Starlight is a good tool that can help you build it now you can you can use our repo here this so all our products in r d both Nightfall and starlight are completely open source for people to look at please please have a look and provide feedback and work on it as well and I'll take maybe a couple of minutes for quick questions and then I'll any questions yes can somebody your mic please thank you so how will it uh so how will how it will integrate with existing tool like hard hat and truffle because uh you know uh basic solidity has like ABI and here you have AST so will those sorry so yeah you can try it on uh infuri we have tested in Fiora we are just we are deployed in polygon testnet we we usually use ganache uh to kind of test it we have we are deployed we don't get so so it doesn't really matter you can deploy it in any any platform that goes it will it will we haven't tested in hard hat but I'm pretty confident it will work as well any more questions because we're done and today we are gonna see a talk about uh about the safe but specifically the safe core SDK and we're gonna mention uh what are the safe modules and safe transaction guards and also how the safe currency K can help us manage them foreign so the content will be covering today is an overview of the safe architecture and we're gonna see the safe core SDK monorepo that is in GitHub available how the transaction flow works on the safe where multiple signers uh must to have a need to sign a transaction then we are going to talk about the safe modules and how they can expand the functionality of a safe also safe transaction guards how they can check or add some constraints to the transactions that are being executed and then we are gonna see what hackathon bounties we have and how to contact us and what resources we have to help you during the hackathon so first of all I would like to ask you if you please could raise your hand to see who knows about the safe what the safe is okay who's using the save who knows about a transaction guards or modules okay pretty good so pretty good so let's start with a safe architecture a brief overview we have different layers the main one will be the contracts the more the most critical one and there we can find the save contract itself there are a couple of contracts that interact among each other then we have some libraries for example the multisend that allows to execute batch transactions we have also the save modules and safe transaction guards that will be see will be we'll see later we also have a layer of services that we run but you can also run by yourself being the most important one regarding this talk the safe transaction service because it will allow us to collect the transactions that are proposed by any of the signers and also the signatures from the other signers so somebody can execute a transaction finally and the last layer are the interfaces so we have different interfaces like the web interface mobile apps CLI and some sdks here we will covering in the sdks the safe core SDK so let's see how the SDK mono repo looks like and what it is the safe core SDK it is a software developer tools that facilitate the interaction with the smart contracts and also the services and because it is a mono repo there are some packages inside of it so let's uh see what they do quickly the first two the Safeguard SDK types and Safeco SDK utils it's pretty easy to see what they do right the one of them exports types makes them available to the other packages and the utils has some utility functions then we have the next two the safe web3 library and the safe ethers Library these are two wrappers of the web 3.js and the ethers JS libraries and also uh allowed to get instances of this of the safe smart contracts depending on the version you want to use and the network you have to provide it connected to after that we have the safe core CK this is the most important package in this mono repo it will need one of the previous packages like web3 or ethers that will provide a connection to the to the network and then you would need to provide a safe address in order to initialize these packets if you don't have a safe address you can also deploy one with it and this package is all about interacting with the smart contracts everything there happens on chain and you can get information from the safe like getting the owners the threshold the nouns whatever you can also create and prepare transactions you want to execute sign them and execute them and finally we have the safe service client uh as you if you remember before there was a one service the safe transaction service that allows to collect transactions that are proposed and its signatures and this safe service client consumes that API so you can also get information from the safe by consuming this uh this API but also have access to the history of transactions check the transactions that are that are pending and required your signature you can also propose a new transaction you can get the balances of the safe the usdc conversion Etc so in this Mana repo we have like these packages we also have a guide that will show you step by step how to use the SDK how to propose a transaction sign it execute it and we have a playground this playground run is something new uh it is a a folder called playground where you already have a few scripts just have to modify a couple of uh configuration parameters like your safe uh the RPC you want to use Etc and then you will be able to deploy a safe to propose a transaction to sign it and to execute it so let's see how the transaction flow looks like and how it is different from the external own accounts for external Loan account the transaction flow is easy right you have just an account with a private key that gives you access to everything inside that account however the safe because it is a small a smart contract where its main functionality is being a multi-signature wallet we need a couple of signatures so these signatures together can approve what the transactions we want to execute if they reach a threshold we can Define so for example two out of these three signers need to approve every transaction we can use the safe transaction service to collect these signatures of chain this is something optional but we will use it to afford some gas and as we saw before uh the the flow would be to initialize the core CK deploy as if we don't have it create propose confirm and execute so let's see how it looks uh the code we need to import the safe core SDK Library save ethers if we are using ethers and then the the safe service client we need to provide to Define our provider get the signer and then initialize is each of these packages uh by providing these parameters after that we can create a transaction object with the destination value data operation if it's a call or delegate Call Etc we can convert this object into a safe transaction object that will also be able to handle the signatures and then we need to use the service the method propose transaction to propose it and to send this transaction to the service then if we are running a client like this one using a different signer we have the service to get a transaction if we already know the safe transaction has we can use it to get the transaction completely otherwise we have a variety of methods you can we can use like get pending transactions for example and then from there we can get the transaction we want to execute finally we can call the service confirm transaction but before we need to sign it with the safe core SDK Colleen's sign transaction hash and once we call the service this signature will be submitted after that we just need to execute a transaction once we have enough signatures so uh before that before executing there's optionally a method that is called isvalid transaction that will check if this transaction will be will fail or not here if the transaction is executable then we can call the method save execute transaction passing this object so that's how the basic flow works now let's see what are the safe modules this is the main flow and the the save modules are very flexible and allowed to uh allowed to increment or to expand the functionality of the safe because they offer us another flow for these transactions that is more flexible that don't depend on designers so uh we need to deploy a safe safe module in the same network where we where our safe is and all the save module needs to do is just call the method exact transaction from module in the safe so the current flow when you want to execute a transaction you are calling the method in the safe exact transaction inside of that method does contain all the logic that checks if the scene if the signers did sign the signature the the transaction but here this save module you can start with an empty one just calling exact transaction from module passing the transaction and it will have root access to execute the transaction this is very flexible because safe modules are like a white paper a white paper you can feel but also the responsibility of doing it well uh it's on you so all the logic not forsaking designers but for Designing how do you want to make a transaction valid or executable or not depends on you so multi-signature control is the basic functionality the safe has but safe modules also give us uh the opportunity to increase it for example assigning roles We could decide to assign admin rights or token voting or spending limits for example this would look like admin rights if you know zodiac which is a Dao tooling standard or they are building tools for those they have a module that is the role modifier and there you can Define okay for these you can Define uh different roles that and assign addresses to these roles meaning that some addresses will be able to execute or to call a specific uh to basically to execute transactions with uh where the parameters of these transactions are checked so somebody could execute a transaction that where the destination is one specific address but other addresses won't be able to do that but they will be able to do other things depending on the roles for token boating for example you can decide check to check if if the transaction like if the approvers of this transaction have some balance of a token or nft and if some of them approve a transaction then allow them to execute it or spend the limit you could Define that some account is able without anybody other or with any other confirmation they will be able to spend a certain amount of accept of a certain token in a certain period of time like weekly daily monthly this is for roles but also for Recovery mechanisms modules would allow at some point of time when a depending on on your logic the a safe is not used to trigger a transaction that or replace the current owners with the people who is activating this mechanism or just transferring the fund somewhere else and we could do that with social recovery by defining your friend your friend's addresses and giving them access later in time or a secret questions like if you remember long ago uh when you were logging into a web page there was did you remember your password do you remember your password and then uh it would ask you what was the name of your first teacher or whatever you could do something like that or custodial recovery or hybrid uh custody Etc and also modifiers modifiers are kind of modules that allow to be chained so each of them offers adds some constraints for example adding time logs to the transactions so you have a queue uh establishing cooldown periods or bonds where the people who confirms if a transaction can be executed or not have to deposit something Etc how the current does the course Decay facilitates the interaction of or the management of the of safe modules there are a few methods that are available for example get modules when you where you can get a list of the modules you have enabled into your safe then is module enabled because I think I didn't say that in order to execute this uh the transactions from the module it is mandatory that the module is enabling in the safe that means that at the beginning the signers need to create a transaction to enable that module it's not that anybody anybody can just deploy its own module and connect it to yourself so that's the basic thing so with the SDK you can enable a module disable a module check if enable module is enabled or not and get the list so that's for modules and then we have the transaction guards safe transaction guards are also smart contracts that need to be deployed in the same network and they somehow are connected to the safe but they are not a starting point in the transaction flow but somehow they will take its place so here we see the the transaction flow designers the save the network and the safe transaction guards that are connected to the safe as as the same as before transaction guards need to be enabled or disabled by the by designers and once a transaction guard is enabled what they do is they have to implement an interface with two methods each of these methods will be run before and after the transaction does some State changes in the contract so we will have a method to do a pre-check and another method to do a post check and these methods will receive the transaction and will be able to parse it and act on it depending on the values of the parameters if the texts that are there pass the transaction will be successful otherwise the transaction will fail and you won't be able to execute it we saw the the advantages or how the functionality can be expanded with the modules what transaction got guards at is basically more protection you can define an allow list or deny list you could freeze an account Etc how this would look like for example for creating creating an allow or deny list you can deploy your or create your own transaction guard with these two methods and in the storage of the smart contract you could have a like a data storage structure to keep a track of a list of addresses and then in the first check for example you could check if the destination of the transaction that is going to be executed it is inside the list or not and act on that to freeze an account for example you could have a variable in the storage of the smart contract that is a switch a Boolean what you can say okay this account is freezed or is not do you see any problem with that it is very cool to be able to freeze an account but if you turn the switch off then the next transaction there won't be any more transactions right because there's no way to turn the switch on again so it's very important that all the that this kind of transaction guards parse a specific way of turning them on just um denying all the transactions except the one that where the date of the transaction or the encoding data allows to turn this switch on so it's very cool but also uh you have to know what you are doing now how the safe core SDK helps with safe transaction guards similar to what we have for modules we have the method get guard in this case saves can only have one transaction guard and you can uh enable them or disable them these methods return a transaction that is ready to be signed by designers okay so that was basically it we had the safe course Decay safe modules safe transaction guards and now what you are all expecting what are our bounties for this hackathon so the safe ecosystem Foundation has available 10 000 upper app for grabs and this will be given to the best projects that I'll be on top of the safe it is an open Bounty so uh everything that is built on top of it will apply but we have some suggestions or ideas you can you can use for example having a sub-dial management tool right now subdials or Dows like to have sub-dials with different uh funds and would be cool to have a tool that allows to do all the accounting thing for all of them that's an idea improving the security with transaction guards anything like the deny list or the allow allow list everything you can think of also working with modules thinking for example on our family that shares an account and the different people have different kind of access to the funds different rights also anything related with our account abstractions that you can think of another thing for example to create a chat where designers of the safe can interact or can chat with uh among themselves also a tool that allows a safe to publish official messages so anybody can read them and whatever you want so last thing you can find us on Discord at chat nosys minusafe.io our forum uh and also on Twitter at safe now I will show our QR code if you want to get your phones ready with a safe hackathon successful guide success guide and there we have some Learning Materials past workshops we did also pass hackathon projects and the winners so we can have some idea of what others build and also some general ideas like the ones you see with the safe modules transaction guards and safe apps so now take your time to scan it or take a picture of it otherwise we will be all the weekend in our booth so feel free to come share your idea with us and we will try to help okay and now some links that are also included in the in the guide for our GitHub the safe course DK repo also the safe contracts repo or the Zodiac if you want to check some modules and guards and then some documentation so that's it thank you very much and good luck with the hackathon thank you also if you have any questions just foreign okay let's try to skip if I'm running late yeah sure I'll I'll do it and then I was like how do you know all right I look test test can everybody hear me yes alrighty uh how's everybody doing like it's been a long day it's gonna be a long weekend um well I'm appreciate you taking the time to learn about hyperlink my name is nam I'm one of the co-founders here at hyperlane and we are doing what we're calling building The Interchange Highway so first you might ask yourself like what the is The Interchange Highway and what we think of The Interchange highway is basically kind of the situation that we find ourselves today where we have all of these really amazing blockchains right like blockchains are really all about like kind of valuable states that can be like accessed by anybody and Modified by anybody right like the analogy usually it's like in our computers but now we have so many of them that there's a lot of valuable States but they're all isolated um and so those kind of like computers might be might as well be different galaxies and the problem is arises is that the state is fragmented and so when you build an application today right like you have to pick one chain which also means that like you won't be able to access all the state on all the other chains and so developers can only really serve users on that chain they can compose with protocols who are not on that chain and oftentimes people what they do is they end up just like you know about sushi right like they just end up deploying contracts on multiple chains but for all intents and purposes those deployments of the contracts are completely independent right basically effectively different applications and so we know that like that's just not going to be tenable right like there's no world in where let's say the internet is like not composable across many different websites and so the question is like what is the end state and so people have thought about this problem for a while right like we're not the first ones uh there are what we call different eras of interoperability so in 2016 we started with like the cosmosis and polka dots of the world right like that's where they got started and so basically they were able to like derive interoperability protocols that are able to natively verify other chains that are built within the same context so that's where kind of the cosmos app chains kind of um arise right like IBC is able to natively verify the consensus of other chains um via IBC um however 2020 comes around and there's all of these side like alternate l1's popping up and there was no interoperability protocol that existed between all of these other l1s but at the same time there were all these users who had this like kind of goal of like hey there's like a lot of popping up Avalanche popping up so how do I get to use these applications right and so like there's what we call this kind of like makeshift user-facing bridges that came up and are now what we consider bridges for the most part right like it's like end users going to a bridge bring like depositing the tokens into the bridge and then getting either a wrap representation on the other side for them then to use um and so yeah most Bridge volume is basically through those bridges but we also have seen I think the kind of downside of those bridges because they're oftentimes built an ad hoc way uh there's been a lot of bridge hacks because there's no kind of native verification that can really happen um and oftentimes like new chains just came come up with like an ad hoc bridge to build because they needed some value to come from ethereum to their chain and so we believe that 22 2022 is a start of like what we call app Centric interoperability and so instead of like an application making the user figure out a way to come to the applications chain we think that applications will incorporate kind of that problem of interoperability into the application itself and so that users are able to use the application from whatever chain they happen to be in so we call those inner chain applications and so to be able to build these internet applications what you need is what we call The Interchange highway right like this kind of this vision of The Interchange Singularity is like applications that just live on every chain users can use them wherever they happen to be and so important piece for you to realize here is that hyperlade is not enough itself another blockchain and it doesn't rely on another blockchain to kind of like be solving all of our blockchain problems and instead hyperlane is a network in between blockchains that facilitates state transfers between the blockchains that we have today but especially the blockchains that will come up in the future and so our effort basically relies on us creating this like safe fast and accessible kind of Highway between blockchains and so how does it work um at the kind of service it's pretty simple so we basically have what we call mailbox contracts on every chain and so you as a sender whether you're a smart contract or like an eua you basically call the dispatch function on the mailbox when you call the dispatch function in the mailbox what ends up happening is that the message gets enqueued in the Unchained Miracle tree in the mailbox and so then validators can observe that Merkle Tree on that origin chain mailbox create a signature and then on the destination chain the mailbox contract can verify those signatures alongside with a medical proof for that message can then process the message by calling handle on the recipient of that message and so the API is pretty simple we think it's like this so on the mailbox An Origin chain side you call dispatch with the destination chain which is like just an ID for the chain the recipient so the address on the recipient on the destination chain and then the message which is just like arbitrary bytes that you can specify and on a destination chain the recipient will be called uh with three parameters the origin chain so where did the message come from the sender who sent the message and then again the message bytes um that were sent and we have a message explorer that can kind of show you the progress of the message as it crosses the chain uh and if I'm bold enough I'll try the live demo right now um I think the internet has been pretty rough but let's see if that works so basically what I will be doing is I'll just go for the quick start tutorial and basically uh using metamask and so first what we'll do is we have to find the mailbox contract on our origin chain so it is a list of them right here you can open them up oops of course I don't think that will work I guess uh see that's what happens when you try to do a live demo um we might have to come back to this like let me try my phone all right let's give it 30 more seconds and if not I'll just have to skip the demo today up cool all right yeah so basically on our dark scene you could find kind of like all the mailbox contracts and all the different chains so let's say right now let's try to send from a Fuji to Mumbai and so basically what you can see here is we call the dispatch function right the first argument is as I said the the domain ideas and so you can find them on the docs as well so the domain ID of Mumbai in this case is 80 80 0001. the recipient address so in this case uh it is bytes32 instead of address because not every chain has just 20 bytes of addresses right like eventually like Cosmos and salon and others actually have 32 bytes for an address and so you if you send it to an evm chain you'll have the zero pad it to 32 bytes we have kind of pre-deployed test recipient contracts on every chain but you could also obviously like just enter your own recipient in here right now and as a message body you can again send arbitrary bytes and so we can just like let's say like uh do hello from if India right and then that's like just ETF encoding into a particular string so we'll do this and then we can send the transaction and hopefully if everything goes well we just call metamask right here right we get the transaction uh there you go so in the moment it will be mined right here and as I mentioned you can use the hyperlane Explorer to kind of track the status of your message and so hopefully if the you can see here that we are sending from Fuji to Mumbai right so you can kind of open it here and um yeah so you can have someone see the phases here whether we send a message transaction has to be finalized before validators can attest to uh the validity of the message in the Merkel trade uh and then like once that is once the vowel is basically signed a signed the miracle root the relayer which is permissionless can process the transaction under destination chain and so I think we'll have to wait a couple seconds and in the meantime I'll show you a test recipient contract so this is the contract that we specified here on the sending side right um and so all the contract does let me show you what it does recipient here is like on the handle function right like it receives origin the sender and the call data and so it will emit a message event here and then it will set these two uh these two State variables and so okay cool so a processed we can open the transaction we can look at the destination processing if you're on a destination chain and then if we look at the logs we can see the received message that was emitted by the test recipient right and so as you saw there's like a very simple like sending a message across the chains and it's as simple as calling a function call on a smart contract um so one thing we haven't noticed is that to be able to do this right you need to have a smart contract on the origin chain in the smart contract on the destination chain and we were constantly thinking like how can we make the developer experience better because basically the message Api has no concept right of like what the data is that you're sending and how it's structured however oftentimes what you want to do is you want to like be able to make a function call on the destination chain right so let's say you have a Dao instead of like a down ethereum where it lives right like it it wants to own assets on other chains right like you could totally use the message Api to basically deploy a smart contract on both sides and basically relay authenticated calls across but we can just do this for you and so interchange accounts are basically a middleware abstraction that allows senders on An Origin chain to have a proxy account on the destination chain and that proxy account will only ever accept basically function calls that were sent from the origin sender and so that basically allows for what we call like a much like kind of like nicer experience because you basically ABI and call the function call you give that to hyperlane hyperlane will basically like forward the call to that proxy account where we call the ICA and then that proxy account will make the call to the recipient and so kind of the outcome of this is that on the origin chain you make this functional call which is very similar right you just like API encode to call as you normally would if it's a single chain context and on the destination chain you actually have to have no contract at all like you're just making a direct function call from the ICA and so we can highlight that as well so again on the page here on the accounts we have the quick start tutorial so all we have to do is we have to go to the uh ICA router which is this address and we basically here have this distance function right again we have to specify the destination domain uh so actually let's do it again to Mumbai the target which is again our test recipient and then this is the ABI encoded function call right so in our quick start you will see here that um we're just going to call Fubar with these two arguments and I just like kind of encoded these two arguments in here and that will ultimately generate uh this uh this API encoded function call and so if we once again write this and then I do is on metamask we'll have the transaction and just to show you what the uh test recipient this is the fuba function call that we got called and so let's once again look at our messages refresh he is yeah we got once again sending from Fuji to Mumbai um and then once this is processed in a hot second actually I I'll show those later because you can imagine what's going to happen like the car will be made and then on here um so you saw like we just emit this receive call event and we like write those two variables that I can show you whenever that's done um all right next one uh so that's if you want to basically write from An Origin chain to a designation chain but let's say whatever you want to actually do the reverse right so let's say you have a contract on polygon and you really want to access some State on ethereum right for example like the the V3 swap on like uh Eve to usdc right like which is probably the most secure top uh but you're on polygon so what do you do uh once again we've kind of thought about like what it would be a better developer experience and the best thing would be right like if you want polygon can just like Abi Abi encode The View call send it to hyperlane and hyperlane will basically do like the view call on ethereum for you and then call your contract on polygon with the results of that query and so that's what energy inquiries is so the way it works once again is that you basically pass to a query function your API encoder function call and then the Callback which is the function on your own contract that should be called hyperlane will relay that message over to the hypercultural destination chain it will make that call as you specified onto the sender and then the result will be put again into a message back to the origin chain and that result will be put into the Callback function as you specified and so again the nice thing is that on the destination chain there's no contract that you have to have to write just on the origin chain you specify destination chain the target you want to make the view call against the query like the view call itself API encoded and obviously the Callback on the sender as well um and so once again let's do a demo which is uh right here uh actually wait it's now right here it is right here so basically the this time is a little different because we have this uh test query Center contract on the origin chain which will do the query right because in this particular case like the way you receive the result is a function call on yourself on the sender and so we've pre-deployed those contracts right here you can see uh the interface of it here if you want to look at the contract real quick um tests test query sender right so basically when you call query address all it will do is we'll call the query router on the hyperlan contract with uh the destination main the API encoder call and then the Callback which is handle query address result right which is this function so basically if you as the developer just have to kind of like make this call and you can expect that the hyperlink contract will call handle a query address results with the actual result that happened on the destination chain and so let's actually do that right so in this case let's say we are sending the girly which is the domain five right here [Music] in this particular like in this quick start example what we're doing is we are um just uh reading the owner a state variable of a particular contract so in this case this is just a contract that we have and the owner of that is like one of our keys uh but then the basically like the view call that we're making right it's like this owner and so that's API encoded it's just this particular byte string and so basically if we do those three things pass that to query address one can once again uh make the query and this is maybe interesting because once the transaction is finalized we can also see that our previous ICA account call was delivered let's see okay so so we're sending from Fuji degree right and this is the query the first leg right where we're basically saying like hey what is the owner uh what is the owner address of this particular account and so let's wait until the transaction gets processed on the destination chain and so to be clear what we're doing is right now is this part right like we're sending this this message right now so let's just see once that goes through I think early in Mumbai have been pretty like congested like not congested but it's just like not as easy to include transactions uh lately anymore um but so once that goes through there you go right so we took I guess it took only like what 20 30 seconds uh so basically we can see is let's just open it in a block Explorer uh right like basically like return this query so that was this is the address that we were reading this is the result of the address and so this transaction hash right actually ends up sending a message back to Fuji and so if we add this transaction hash to our search you can see it's actually two messages right like one is the one from Fuji to girly and then here's the one from growing back to Fuji and so that already like processed and so here on the Block Explorer uh we are able to see that the query was resolved with uh this data and that's the um nope that is the um last address result here right like you can see that this is the address that we got returned um cool all right um so last but not least uh sometimes what you want to do is you don't want to just send messages but you actually want to send value right so the manage API all it does it sends arbitrary bytes but like how do we decide what value is is obviously like a much bigger topic if you're interested come back uh to a booth to talk and talk more about it but one thing I have like that's like a key part here is that like whether you actually sending canonical tokens versus rap tokens right so like right now when you say let's use Wormhole to send usdc from Eve to Solana actually what you end up doing is you're depositing usdc on ethereum and then portal mints like a wrapped usdc version on Solana and there's obviously all kinds of good and bad things about that we believe that there's going to be many different ways of transferring value and so we have what we call the liquid layer API which allows you to use full single interface different value Bridges right and so for example you will be able to use portal but also like circles native usdc Bridge which burns usdc on let's say ethereum them and then mince it on Avalanche and so you never have this kind of like wrap token issue and so the API looks very simpler it's similar to the master API where you send your specified destination chain a recipient message and then the three additional arguments are the token that you're trying to bridge at amount and then the string of the bridge itself so in this case would be either Circle or portal um I'm gonna skip the API demo here but like if you're curious uh it is obviously on our uh docs page right here and last person is the thing that I want to kind of like highlight as well is that when I had this uh diagram here it was very simplified right because basically it said like oh the mailbox of Val will verify signatures but one of the key points that I think everyone should take away from this talk is that bridge security is very hard right like every second bridge basically has been hacked and part of the reason why is that uh there's no such thing as like one security model fits all right like a hacker here if India has a very different security requirements than like let's say unit swap 101 so like do like governance decisions to cross chains and so we have what we call Sovereign consensus which allows the recipient to specify the security model under which the recipient accepts messages right and so for example in the simple case here if India you could say like oh like any value signing a message it's okay for me to accept a message but if I'm unit swap right like I might actually want like higher security uh to accept messages and so basically you can create these things what we call isms interchange security modules which the recipient points to and then basically the hyperlane API will first call the ism with icon is valid uh function call and only if that is true it will actually call handle on the recipient and so that allows uh applications to specify their own security and so like you know in default case right now of hyperlane you have this like validator set that you use but you could imagine isms that have like optimistic modules so you could imagine isms that for a specific like chain pairs actually use like a ZK Bridge or something and so we think that as a developer you are able to kind of opt in into the same API but we'll have different security going forward um all right I think that's it I know we are all running behind so if you have any questions we have a move over there we'll be here all weekend uh we also have bounties uh 10K uh and we're generally just looking for like very creative uses of hyperlane like as we mentioned in the beginning of the talk we believe that the future are interchange applications applications that live on every chain like it just doesn't make sense to me to have an application that only lives on one chain and then all the other users you just like like out of luck like you have to come figure out a way to come to us right like a no world our application successful if they just force users to jump through hoops to use your application um so yeah if you have any more questions please come by uh come by our booth and yeah hope you have a good weekend bye ya foreign foreign is this working finally can you folks hear me awesome you folks are so patient I'm super grateful for patient audience always because like you never know what goes wrong with like demos and the demo gods are not happy with me like ever so I think that's what happened today what we're gonna make do with what we have super excited to be presenting here um in my home country uh in global hackathons have always been super close to my heart because I started um in the beginning of this year in a new space um with um my passion for graphql and I think that's what I'm bringing to the table for you folks today um so we're going to be learning how to build decentralized graphql apis using the graph so a quick show of hands before I give my introduction or like go into the specifics of it how many people here know graphql or have heard about graphql that's that's a good number I'm impressed um how many people know about the graph hahaha awesome we could we could work with that awesome awesome so um today we're gonna be learning how to build a Zora nft smart contract a uh an API for the Zora nft smart contract um using the graph but before we jump into that hi I am wish short for vishwa Mehta and I am a developer relations engineer at the graph foundation and um this is what what I do I am super passionate about developer education and um right from the start right from my University days I've always been really excited about like talks and giving workshops making sure that any um content format that I can you know contribute to is helpful for developers so that I can help them become successful with the tools and the Frameworks that they're using so that brings me here again if you have any questions by the end of this Workshop presentation talk whatever feel free to reach out to me on Twitter at vishwa Mehta 30 and with that we jump right into it doesn't want to move okay um so let's talk about what the graph is let's start with right from the beginning so the graph is a protocol an indexing and querying protocol for web3 for networks like ethereum ipfs and so much more so but that's a lot of like jargon web3 decentralization graphql the graph indexing querying so I get a lot of like questions around where it fits into the stack so let's look at this tag you folks are here at a hackathon right so you will be building projects you will be building Taps um so let's kind of like picturize where the graph sits into your dap stack right your web development stack so I really love this diagram because it shows the UI layer the sub graph indexing layer and there's the contracts which is your data layer so the graph as an indexing layer sits right between your front end which is your UI and your backend which is basically all of the data that is coming from Smart contracts on the blockchain right and um with that subgraphs are becoming a de facto standard of how you query data that is being indexed by the graph protocol from the blockchain and that's why we say that the graph is now a default part of the web 3 stack awesome moving forward uh let's talk about the data scenario here I get often I often get the question like where does the graph come into picture we we saw where it fits into the stack but like we we haven't yet talked about why exactly the graph right why should you be using the graph how it is going to be helping you in your journey uh so I I think I need to begin from the data bottleneck that we have um in this data driven world of ours nothing is possible without accessible data right and especially with blockchain data if you're building decentralized applications you want to make sure that your UI has a very robust experience for your users you're bringing very fast and performant and efficient uh UI ux to your clients and for that we need index data so that is point number one point number two is that blockchain um has can anyone guess like how many blocks so far ethereum has the block count any guesses wild guesses that that's that's an accurate one yeah yeah it keeps changing and yeah um I think the number that I saw right now is like 16 million so it's in the same ballpark but it just keeps on increasing and every block has thousands of transactions again it just like keeps on increasing by the hour by the day so what I'm trying to say is if you want to build a Dap using blockchain data which is increasing like day by day it becomes increasingly difficult to index that kind of like heterogeneous data which is out there on the blockchain it is D5 data it is nft Data dials governance whatnot so what if you want like a very specific piece of data right um do you start indexing the entire blockchain like do you start indexing all of ethereum no so that's why we need organized data which is well suited for your web 3 applications your decentralized applications and as a solution developers have been building proprietary indexing servers um so far now let's jump into why we don't want to do that is because it is error prone it is a lot of like complex code that you will need to write but three main points the first one is that if you're building um a proprietary indexing server it is a centralized point of failure which defies the ethos of web3 which is decentralization it just goes against why all of us are here hacking and learning at this hackathon right so that's Point number one the second is that um it's a lot it's a single point of failure so if it the indexing server goes down everything goes down you don't want to do that um and the third but again most important point is that it's a lot of infrastructure to manage it is a lot of investment of hardware and engineering and monetary resources in running that one indexing server all by yourself whether you're a team or an individual engineer now that is where the graph enters the scenario and that's why we say that the graph is in it gives you a global open API but it's not just an API it's a decentralized transparent and open network of participants like subgraph developers indexers curators and delegators and it is making sure that you can index your blockchain data efficiently but also um can do it in a more decentralized manner and of course um it's built on top of graphql so it brings the benefits of graphql to your table um if you want to learn more about graphql I think it's a pretty nifty thing for front-end developers and it has been a game changer in the data accessibility landscape so basically using graphql the graph has built a unified data access layer for blockchain so no matter which data is coming from which smart contract it is woven into your sub grab which is pretty basically like a single endpoint that you just like query every time you want your data from the blockchain to your application and the graph has been powering D5 applications not just D5 applications but this has been like one um vigorous use case um and also a really exciting one um so it has been querying on-chain data like trades and exchange volumes total borrowed supplied stake yield farming total value locked and so much more so all of these like cute little icons that you see um these are like projects that um have been powered by the graph D5 projects and if you talk about other some of some of the other leading projects in let's say websites is coin market cap coin gecko if you've heard about it then there's like nfts and Dows so Juice Box Dao there's foundation in the world of D5 I'm sure you've heard about it it's uniswap and then there's synthetics all of them are powered by subgraph data through the graph and we have um a hosted service that we started with um about 44 years ago so for four years over it has been supporting subgraphs and subgraph developers um but it was a way to start with um our initial idea so that we can make sure that we achieve product Market fit uh we have tested it out before we go live with the decentralized network and we have had the time to get good feedback from our developers um so we started with the hosted service which was run by our one of our core Dev teams our original core Dev team um Azure node but from from that now we're moving away by sunsetting the hosted service because we want to make sure that we can find a solution which is more scalable and more sustainable and also fits into the web 3 mission which is the decentralized network of the graph and so we've successfully migrated 350 plus adapts and have been they've been like paying queries for GRT in GRT on the network um so 39 plus I think the count is a little bit um higher now uh all of these chains amazing chains that you see and you probably worked with built on are supported by our hosted service and with that I think we've discussed the graph a lot we've talked about what sub graph sub graphs are and we've talked about like why it makes sense for you as a developer who's building dapps to absolutely use the graph in your stack so let's see some code um now I typically do like a live demo of this like a live um coding session so that I can take you through the entire process of like how to use the subgraph studio how to get started by initializing your sub graphs scaffolding it um designing it as per your use case as per the data that you want and then finally deploying it but um just to make sure that we're right on time and also to make sure that nothing breaks because of the Wi-Fi I'm just gonna run you through the code here so um here if you see the subgraph so this hasn't load loaded yet but basically if you want to get started you just need to go ahead and go to the subgraph studio on the graph.com website and um create a subgraph so I'm just gonna show you like a nice little screenshot of it so this is something that you will be seeing um the prerequisite here would be that you will need node.js installed on your machine to make sure that you can install the graph CLI um and then that you also have a metamask wallet using which you can sign into the subgraph studio and you go ahead and first create a subgraph slug basically just create a sub graph on your dashboard the next thing you see will be this kind of like a dashboard for your subgraph with some documentation really helpful documentation on the side and now I'm gonna run you through the kind of like um commands that we need the first one is the npm install command for the graph uh graph protocol CLI so this is just a one-time thing once you've installed the graph CLI it's going to give you some really cool utility commands that you can use to scaffold and design and deploy yes your sub graph for that you can either use node.js or you can node npm or you can use yarn um when you're done with that uh you are gonna be like we want to initialize our subgraph so the graph init command is one of those like commands given by the graph CLI um that you see here um and it basically scaffolds your sub graph it gives you some boilerplate code to get started with and let's go ahead and see what kind of boilerplate code it has given us and this is Frozen I think I'm just gonna give it second I guess yes we got it awesome so once you've initialized the graph your your sub graph this is what you're gonna be seeing basically and it's a I I think it's a pretty cool folder structure right here because it's super clean you see it and you know that there are three main files that we want to be looking at the first one is the subgraph.yaml file which is your typical configuration file that describes your subgraph like which kind of um Network you are working with the name of the token that you're working with and your data source that you want to pull in as a smart contract from the blockchain so that is basically this right here um now you want to enter and this is basically the smart contract address of the nft the Zora nft smart contract that you can get from the Zora documentation and just want to call out one really useful information is that you would also want to um Define a start block is because you don't want to start indexing from the Genesis block if you know which block you want to start indexing from uh just go ahead and pop in the start block ID here the address and um and then there are a couple of entities here um so enters entities I will go more deeper into this when I talk about the schema.graphql file but just as a quick overview entities are basically all of the fields of data that you want your sub graph to query from the smart contract so for example there's the Zora nft smart contract right so here we're defining two types of entities which is like token the first one is token which is all of the nft data and the second one is user which is the user metadata and I think it's gonna start making more sense once you see the schema.graphql file but before we move on to that one last thing uh here in the subgraph.yaml file that you would want to Define is the event handlers so every smart contract will have events that it emits every time you start indexing it and you want your subgraph to listen to those events to make sure that there is some kind of business logic that is implemented when you listen to those events and then when the business logic is implemented your um your local code and the code on the the and the events is being mapped and you can query all of that data from the events to your client so here we will be dealing with two kinds of events basic events from the Zora nft smart contract which is token URI updated so every time the URI of your nft is updated this event will be emitted and we want our subgraph to listen using mappings to make sure that we can query that data and the second one is the transferred event so there are two scenarios here either a new nft would be minted and in that case this event will be emitted but it could also be an existing nft whose ownership is is being transferred from one owner to a new one and with that we can move on to the schema.graphql file I know we're moving fast here but um we can all you can always come back to me with questions I'm just trying to make sure that I can give you a good overview of the folder structure of the subgraph but everything else that you see right now is super specific to what kind of sub graph you want are defining is it like an nft API is it for your defy use case is it for governance Etc so the schema.graphql file you see right now is basically a graphql file if you work with graphiel at all you can understand what this does is that you're telling your sub graph what kind of data it wants to query it needs to query from the blockchain so I want all of the nft data and the corresponding user metadata so that's why I'm defining using at entity directive I'm defining two types which is token and user so for the all of the token data and the user metadata I'm defining these two types and the at entity directive is a basic graphql directive that lets you define types with top level fields for all of the data that you want your graphql API to query and give a responsive um so it comes with all of the other fields like if the token has an ID a created ad timestamp metadata and content URI Etc and then the corresponding creators and users of the nft are then be being stored as using the user object type here so there can be a simple type in graphql and there can be an object type which is basically the user type that we've defined here which can then further have its own sub level fields that you can query so for the user metadata we want to be querying all of the tokens that are being owned by an owner and all of the tokens that are being created by a Creator all of the tokens that are being minted right um so that are those are the two relations that we're defining as part of the user entity the user user type that you want to query using your sub graph um and we're doing that again with another really cool really Nifty directive uh the graphql directive which is derived and derived from directive um now basically instead of this directive you can use alternatively you can create an array um of all of these like creators and owners but this is something that's um a bit more performant that's why we're using it here and once you've done that um you want to move to the mapping.ts file so basically what the mapping.ts file is it's it's a file where you Define all of the business logic that you want to run once your subgraph has started um using like querying all of the index data and the smart contract is emitting the data so you want to map the events that are being emitted by the smart contract to some kind of local uh locally defined um functions or let's say like event handlers basically so you want to handle those events that are being emitted um and the graph the cool part of the graph CLI is that it comes with typescript support out of the box so it gives you really cool typescript library that gives you some helper functions that you can import while writing your mapping.ts file to make sure that you're writing um your hand your event handler as well uh and easily so to to be able to do that uh there's another command which is called the graph code gen command um it's basically just you just enter graph code gen you run it and um it will give you like the uh out of the box typescript library that there is it will generate all of the um the helper functions and that you can go ahead and import here in the mapping.js file and once you've done that so if you can see here in the generated folder the functions that it has generated for us to import there are basically two types of functions the first one that you see token is something so um you can only read data from the smart contract from the blockchain but you can both read and write data to the graph node which is like a local storage um so the schema uh the generated schema file is basically giving you all of the functions that you need to interact with your graph node which is basically reading and writing data onto it because you also want to save data that you have gotten from the smart contract and then the token one is the generated uh file that lets you gives you functions that will help you interact with your smart contract like read data from the smart contract and finally we have defined here the two event handlers for the two events that we were dealing with here in our subgraph is it's basically handle transfer event and the handle token URI updated event so any events that you're dealing with you would want to write an event handler so that you can perform some kind of like business logic in your subgraph once you start listening to those events and um so this is basically like assembly script so anyone who's used JavaScript or type types trip this should be a very familiar kind of Syntax for you and I wouldn't just to stay within timing I wouldn't go deeper into what this exact code does but basically I've already defined what each of those events meant and so we're making sure that every time the event happens and there's an updated piece of information we're saving it to the graph node and we're retrieving it from the the smart contract and we're saving it to the graph node so that we can query it via our sub graph later and once we've done that I think we're super close to the end of it which is that you have initialized your graph as your sub graph you have defined it based on the smart contract that you want to be using and the kind of data that the kind of events that you want to deal with and the final piece here would be to deploy uh see if not happening so the final piece here would be to deploy your subgraph so we have another um another command here that lastly you would want to run is the um the graph deploy command and it should if you go to the graph documentation you should be able to see the graph deploy command so you authenticate your subgraph finally and then using your API access key and then you deploy the subgraph tab getting a little stuck here and there but um while that happens so sorry about that while that happens um I think we've concluded our Code walkthrough of like how to initialize a subgraph how to define it and deploy it and what's once it has been deployed in your subgraph dashboard you should be able to see that the subgraph is now it just went off cool you will be able to see that the subgraph has now been been deployed and there is like a really cool um play graphical playground that you can see um where you can run some sample queries and you can test out whether your sub graph is working or not and uh I think I lost my presentation um never mind so um so you can you're once you've deployed your subgraph you should be able to test out the sample queries in your graphql playground so um come by the booth I might be able to show you the actual live demo um so if this is interesting to you test out subgraphs we are giving away cheat sheets at our booth and um I think Simon has already you know done that here as well so the cheat sheet is basically um a good one-on-one of like how to use subgraphs how do you like what kind of commands you need to learn to basically initialize create and deploy a sub graph and so if you're hacking at this hackathon if you're building a Dap um the main takeaway here from this talk slash Workshop is that um subgraphs are a really cool way to efficiently Access Data from the blockchain and it's a it's a really cool decentralized graphql API that you could be building for your dap as long as you're dealing with on-chain data so basically there's like no programming language barrier it's language agnostic so whether you're using python on your front end you're using JavaScript any kind of like react framework you view framework some graphs are still relevant the graph is still relevant and it is also Network agnostic so if you're using the hosted Service as I said um we're live on 39 plus chains so it also doesn't depend on what kind of network you're using and with that I will conclude my talk and thank you so much for being such a patience audience thank you foreign uh it does work there we go we got it okay okay uh wow this is very weird I didn't realize how strange it is talking into a microphone and not being able to hear yourself so um I'm gonna go pretty quick because it looks like we're way behind schedule I'm Jack I work at a company called o of one oh wait I think I think this only works if I stand right in front of it so we'll give it a go so okay I'm Jack I work at a company called oovon labs and we incubated uh the Mina protocol which is a layer on blockchain that we're going to be talking about today uh I'm based in Denver Colorado that's my Twitter and I'm a developer relations engineer so um okay I'm just not going to use this I think it doesn't work so okay so what are we gonna go through uh we're gonna talk about snarky JS which is the Smart contract language that we use for mina um we're going to do a simple example of a smart contract that checks if the number you submit uh you know is passed in as an argument is is the next value in the Fibonacci sequence uh then we're going to make this recursive uh and then finally we're going to talk about the Mina protocol and uh uh we'll talk about where we can learn more and we'll do questions and answers after you can come grab me I'll stand next to the door for a little bit okay so snarky JS it's a typescript library for defining zero knowledge proofs and it's also the smart contract language for the Mina protocol uh this is what it looks like hopefully it looks like something that you can figure out because it is something that you can figure out uh everything is in typescript so you can keep using the tools you're familiar with uh like npm prettier eslint vs code and it's very easy to learn uh you can see here the intellisense support is super good so you can just dive into a code base and if you're curious about what something does hover over it and you'll get a pretty good explanation it's also extremely powerful uh this is for two reasons one is kimchi which is our proof system and we have fully trusted setup we have custom constraints for hash functions elliptic curves and encryption this just means that these operations are very efficient the proof size is constant thus the O of one it's recursive meaning that we can verify proofs inside of other proofs and it's plonkish so we can add new features like Dynamic array access and a couple other things uh really the point of this is just that we've put all the horsepower that we can under the hood here so that's one side and then the other side is is you know what does it actually look like to use this what is the snarky Jazz library look like and um there's a few things that make it really powerful one of the first is we have method chaining uh this makes it very easy for developers to think through their programs in a pretty linear way so you can kind of see here we have an example we've got this value guess we can call the equals method on it pass in zero and then you know we can call the not method and so we're going to take something in this case I guess I think an array of fields and and you know we're going to get a Boolean out in this is is not red Peg uh this probably seems pretty familiar and that's the point uh we've done our best to make programming in Starkey Jess feel a lot like programming in in uh ecosystems you're familiar with already uh also we have structs what should the are exactly what they sound like they provide a layer of abstraction that makes data quite a bit easier to think about um we can see an example here uh we have this struct it has you know an array with public hand string and it's called by Tuple and then we can uh down here uh you know pass this in as an argument this type and so a fundamental requirement of all zero and all true systems is that the values are ultimately represented as something called a finite field element and um these uh are for the most part like unsigned integers but there's a kind of a couple interesting features uh or things that work differently and so uh structs eventually fundamentally they're all composed out of these field elements but with this uh abstraction you know we can we can Define things like this that are much easier to work with and so the struct will figure out how to take this information that we know how to work with in a format that makes sense and turn it into this underlying field representation so finally plenty of the stuff this stuff is already implemented in starkeyjs so we have all sorts of different types you know these are these structs for groups public Keys private Keys signature scalers Etc efficient hash functions efficient encryption and decryption efficient signatures we have a miracle trees and uh an API for recursion and more coming all the time so a lot of stuff that you need is just included in the starkeyjs library to begin with okay why did we choose typescript uh because we're ecosystem focused so the idea is that probably some people want to build Crazy cryptographic Primitives that let you do things that seem impossible and that's awesome you should totally build those and then there's other people who might want to ship you know user-facing products that make use of these powerful Primitives and the idea is that you'll just be able to you know import uh a library with whatever crazy thing like card card shuffling or you know something that's hard to do and we want to have code reuse that's as high as it is in the JavaScript ecosystem I think that that will kind of allow a whole new type of application to to kind of come forward which is you know applications that have the best product people and the best sort of like cryptographers working together to sort of you know open doors uh this is just a rehash we'll go through it because we're going real quick so how does snarky chest work here it is in five sentences uh it's a typescript library all the information is represented in one of these snarky just compatible types um so these are all composed of the field type and you know can be constructed using this struct abstraction um it provides classes and functions that are compatible with this field type or the structs that are composed on them so we have like for example you know if we have a field of value one then we have an ad method on this field type that we can use to add another field to it um okay so snarky Jess can represent any of the operations that we do this way as this kimchi arithmetization which is basically a math problem that represents the program that we write in Starkey Js then when a user interacts with the snarky.js program we can use this math problem version of the program to generate a zero and all truth that their interaction was legal how do the SMART contracts work developers write the smart contracts in typescript and they deploy the verification key to the ZK app account so zcap account is just like a contract account on on ethereum I mean it works a little bit differently but it's the same idea so a user generates this verification key for their program and they deploy the verification ghee to Mina and then we have a new smart contract on the media Network users run the smart contract in their browser and then they generate a zero knowledge proof that their interaction was valid uh when you know when it comes time for people to to uh actually interact with the app once it's deployed so we can kind of see what this looks like we have my cool zika app a user does some stuff with it in the browser they make a transaction and the transaction has a zero knowledge proof and they send it to Mina and if it's valid then everything associated with that transaction gets committed and if it's invalid then it's dropped so if the mean of blockchain can validate the serial knowledge proof then it commits any of the relevant State updates this is kind of what the sun's up looking like we have a smart contract method it takes in some arguments some state from the smart contract and some values from the state of the world so smart contract state is exactly what it sounds like arguments are things that the user provide and values from the world can be things like block height you know um verifiable Randomness that kind of thing and what we get out when we run it is updates to the state and updates updates to the state of the smart contract and updates to the state of the world and a zero knowledge proof and so we passed the serenology font Amina and uh the um if the proof is valid then the state gets updated as as described here which we'll skip through that real quick okay how do zika apps work um so you install your smart contract in your UI repository and then you deploy it and that's all uh it's just typescript so you can publish it however you want to on GitHub or or using npm and then you can just install it you know exactly as you would any any other uh dependency um the the smart contract is is really just a dependency of your front end in this case and you call it just like you would any other Library okay so we'll get on to an example and I'm sorry that I'm going so fast like I said we're way behind time so uh come stop me after if you have any questions I know I'm kind of glossing over some stuff but here's what we'll do we're going to write a smart contract that calculates the next number of the Fibonacci sequence and uh it'll have two pieces of state and minus two and N minus one and um it'll have a it'll have a method update and and so this will let us update n minus two and N minus one but only if we pass in uh the correct number the correct you know next number in the sequence and uh so to write our ziki app we're just going to extend this smart contract class um of snarkyjs into you know Fibonacci Sequence and now we have a smart contract and we'll Define some State and so zika apps can contain uh you know on-chain State and in this case we need you know two pieces of it n minus one and N minus two and they're both of the type field we use the state decorator um to to basically tell snarky.js hey uh this is a variable and and you should do all the sort of work to make sure that when a user uh Alters this variable in their um their browser then then if if necessary we reflect this change in in the actual blockchain itself uh so only types that are built out of field or or structs that are composer Fields can be used for these State variables and uh I think that's kind of all there is to say about State um we'll come back to it in just a second uh the next thing that we're going to do is we're going to override this deploy method so this deploy method is a method that's run when the smart contract is deployed it's kind of like the Constructor or like if you have like a truffle file it's the the um the JavaScript chunk that that deploys your contract um so in this case we're you know we're going to pass in some things from basically our our deploy tool um and then we're also going to set n minus one and N minus two to their initial values and so we're going to set n minus 2 to a field element of value 0 and then minus one to a field element of value one and so now when the smart contract is deployed um we know that these values will be initialized to zero and one respectively finally we're going to define a user callable method uh in this case update and so update will take one uh one one argument uh n of type field and we can make as many methods as we want each one can have its own logic and do as much computation as you'd like um so the methods of the smart contract describe you know how it can be invoked once once the smart contract is actually deployed and um it's worth kind of calling out here that this this value is actually private uh any anything that we pass into to these user-defined methods is private until the point that it gets like mutated and emit emitted in an event or or used to update some sort of on-chain state so of course the the state of the blockchain is public and the events and stuff are public but the actual execution of this code is not public you do it yourself in your browser and you only share a zero knowledge proof that says that you did it correctly and then any you know meaningful output of this so in this case this n value is is not going to be uh you know revealed it we pass it in but we are passing it in on our local machine and and so it doesn't it doesn't ever like reach the nodes um so that's a like yeah that's something kind of worth calling out is is that uh you can anything that you pass in is private and along the the course of the execution it remains private until you do something not private with it basically so uh the update method we're going to use this uh get method on uh n minus two and N minus one and this is going to grab these values from the blockchain and then store them in these local variables um so when we when we run this code you know we're going to grab the values from the actual blockchain and put them in our local runtime and then what we're going to do is we're going to add n minus 2 to n minus 1. in order to get the next number in the Fibonacci sequence and we're going to assert that this new state you know the next number in the Fibonacci sequence is equal to n the value that we pass in and what this assertion statement does is it basically says well first of all if this doesn't hold true stop the execution but second of all um set up the zero knowledge proof in such a way that even if a user could override you know the the air that this throws they will not be able to generate a valid zero knowledge roof there's cryptographically nothing that they can do in order to make a valid zero knowledge proof for um you know invoking this method unless what they pass in does equal new state which also equals you know n minus 2 added to n minus 1. finally the last thing that we have to do is we'll set our on-chain state to new values so we're going to basically take our new you know the value that we passed in the next number in the sequence and we're going to set that to n minus 1 and then we're going to move n minus 1 over to n minus 2 and N minus 2 is going to get you know sort of pushed off the end just so that's it that's kind of the basic structure of the smart contract we you know uh uh Define state set up our our deployment and then Define the methods that users will be able to call once the smart contract is deployed now we're going to do something extra cool and I'll just flow through this really quickly the point is kind of like uh to understand what's possible just because we have limited time so um what we can do this smart contract as it works right now is the same as an ethereum smart contract a user calls a method they create a transaction they send a transaction they wait for it to be mined and they pay a fee but uh Mina allows you to structure things quite differently using recursive zero knowledge proofs and so instead of writing a smart contract what we do here is we create a ZK program and a ZK program is kind of like a subset of a smart contract it's a provable program it doesn't have the connective tissue for things like State and and that kind of thing um so it's a provable program but what's really cool is that if we look at these methods we can see um as input we can actually take proofs and the output of sort of running this is also a proof and so we can verify that the proofs that we pass in are valid inside of this proof so we can have a proof that accepts other proofs as arguments and then verifies that these proofs are valid and then also does some other thing and and this is really powerful because you have arbitrary branches and merges and you can do it an infinite number of times so you could do something like use this to prove that you've kept a correct moving average for 100 years or 10 years without uh without having to store all of the the previous data you could use this to do something like make a smart contract that I don't know maybe does like machine learning inferencing or something and has to you know scale horizontally across many machines um and you can do it for simpler more practical things like if you want to build a game you can build a game where one user makes a proof sends it to the other user the user validates their proof and then builds the proof on top of their proof that proves that their move is legal and so you could do something like build a game where users go back and forth peer-to-peer there's no blocks there's no fees and at the end and we get a single proof that attests to the fact that the entire game has been played correctly and then we can pass that proof as an input into a mean a smart contract and settle the game that way so this opens the door to all kinds of crazy stuff mostly probably people who are interested in kind of the scalability aspect so come talk to me about this more after if you're interested um yeah it's pretty simple we can just uh have our our we basically make a type for you know the type of proof that we're going to use and then and then we pass this in you know as an argument in our smart contract and call verify on it okay now let's talk about the Mina protocol what is Mina it's a layer on blockchain that proves its entire finalized State using recursive zero knowledge proofs so it works kind of like we just described um while other blockchains grow they need all of the information in order to be able to verify any of the information basically Mina does not you just need a zero knowledge proof and the information that you're interested in in order to be able to verify that that information is is valid and so it stays a fixed size 22 kilobytes um is this cool or is it actually useful uh it's it's both it's really cool and it's really useful so the first reason is obviously privacy I think we kind of touched on this a little bit before but ethereum spark contracts uh run on every single node so all the information is is public um you can see what this kind of looks like if we call some method on an ethereum smart contract we send it to every single node and every single node has to has to run this method mini smart contracts run in the browser and so the arguments and intermediate sorry the arguments and the intermediate values are private by default uh what this means is that you know the user runs this the smart contract themselves uh they don't have to share what that looks like with anybody and then they just take the relevant State updates and the proof and send that on to the mean of blockchain mina simply verifies the proof and updates the state on chain if if you know the proof is valid okay uh what about scalability there's no gas model uh for ZK apps they run off chain and so the amount of computation doesn't affect the transaction cost you can actually do an unlimited amount of computation especially using this recursive proof mechanism um and and then send you know a single transaction that attests to all of this so developers uh yeah can use recursion to build application specific Roll-Ups we kind of touched on this a little bit earlier um what about decentralization okay so as we talked about uh Mina stays 22 kilobytes and so it's our the amount of information you need in order to verify that the current state route of mina is valid is is 22 kilobytes and so it's possible in practice is that there's no need to rely on trusted third-party node operators like inferior or Alchemy or you know something like that you can run basically a node that only worries about your account but doesn't have any sort of other like security concessions um it's a full node but it's a full node only for your account uh bridging is another thing that we can do kind of differently than than I think a lot of other blockchains uh a smart contract on another chain can Bridge the whole mean estate just by verifying the most recent proof that Mina generates and so what that means is that uh well I guess here's a good example we can write a smart contract on ethereum with a method and the method will take in as an argument the mean estate route you know the root of this Merkle tree and it will also take in the most recent Mina zero knowledge proof and we can pass in the zero you know then any user can call this method pass in the most recent zero knowledge proof and pass in the mean estate route and this ethereum contract can check that the the zero knowledge proof is valid and if it is then it can update the state route on ethereum and then when a user wants to use some you know specific information from Mina they can I don't know grab this chunk down here and provide the rest of the Merkel path and then validate validate it against the um the the actual uh State Route that's stored in this in this bridge contract in this case and so this is not just hypothetical the nil Foundation is working on this right now with a joint Grant from the ethereum foundation and the Mina Foundation um so yeah you can actually check out a demo we'll have a QR code at the end that um has this demo we pass in our you know three relevant pieces of information and create a transaction and actually eventually set it through metamask to one of the ethereum test Nets I forget which one another thing that work kind of differently as oracles um this is something that I'm not quite as exposed to but the kind of broad Strokes idea is that users will be able to create proofs that they've accessed a website through you know this SSL exchange and so um when you you know go to a website right now you have a little lock in your browser and it basically says you know we use some protocol to ensure that I'm talking to the party that I think I'm talking to and they're talking to me and nobody's tampering with anything in the middle but the problem with this is that it's it's an interactive exchange and so it's only compelling to the you know to the two parties involved in it using zero knowledge groups we can take this interactive exchange and make it non-interactive and so what this would end up looking like in practice is a user might be able to do something like go to I don't know a website that publishes the results of soccer games and they could prove I went to the New York Times or whatever website publishes soccer games and I saw that on this page um we had the results of this soccer game uh I'm sorry football game uh published as um you know let's say I don't know America lost um let's say that uh then we can take this information and and pass it you know straight into a smart contract we can get a non-interactive proof that we went to this website and that it said that this was true and then we can pass it into another smart contract on the blockchain so this opens the door to to kind of people being able to create oracles without having to set up these complicated pools of of like relayers that are gonna like you know I don't know steak some sort of sort of capital and and participate in some kind of like Game Theory thing um you can just cryptographically know that you know this person really did go to this website and the website really did say this thing what else is possible well we actually don't even know everything that's possible yet and that's why we're really excited to be here because um there's plenty of things that we hadn't really thought about six months ago that seem like a good idea and uh like a feasible idea now and that's kind of what we're hoping is that you know everybody at eth India probably has a lot of collective brain power and maybe we can find new things that we can do with me you know that we didn't even know were possible yet we have all this technology and it opens a bunch of unique doors that nobody has really explored yet and with a bunch of people I think we can kind of explore all these Avenues together and maybe find some really cool things that nobody has even thought about doing yet uh we'll skip this and now we'll talk about where can we get more uh so how do you get started it's really simple we have a single developer tool it's called the zika app CLI it's very powerful and it's very easy to use it's just an npm package you can install it and then you can run ZK project uh and then a name let's say hello when you do this it'll create a project for you scaffold it and and also include um an example smart contract and an example test and so you can just you know install the zcap CLI create a project and then start poking around with it and look at the intellisense in vs code and get a sense for what's going on I mean you can even deploy this to like a Berkeley QA net or I'm sorry Berkeley testnet tonight um uh uh there will be cards next to the door when you leave that have simpler instructions for this so yeah you can get started in like five minutes this way we also have a bunch of tutorials and um other documentation I will have a link for that after um how can you how else can you get involved so you can visit our docs that's probably the easiest way to get started you could also apply for retroactive grants we have a retroactive grant program um we have also ZK ignite which is a uh I don't know I think I think we'll have more details um at the desk but it's basically a program where we have I think I think we have the next slide talks about it uh and then finally you can you can also build a ZK app which is a good thing to do because zcaps um yeah are all eligible for the prizes here at uh at eth India okay so yeah ZK ignites um you can start building zika apps and get rewarded from a pool of 250 000 Mina um with some bonus prizes this is a code you can scan to kind of get signed up and then you know in order to kind of get yourself up to speed on all of this you can also check out the docs at um uh Mina protocol.com forward slash CK apps it's and this is a QR code that you can scan really quickly if you're I'll snap back to the other QR code in a second this one has got links to the presentation here and some of the things that I talked about in it like for example the nil Foundation bridge I think it has links to the docs uh some GitHub repositories um some other things so I'll do this one for a second and then I'll flip back to the other one in five four three to one and if you miss it just come stop me after our booth is in the middle kind of right in the between the hallway between like the left section of the room in the right section of the room um and here's the the ZK ignite cohort zero QR code awesome I'm sorry I went so fast if you have any questions uh come talk to me after I will have way better answers for you then um but uh thank you so much for having me and uh I hope this was interesting 