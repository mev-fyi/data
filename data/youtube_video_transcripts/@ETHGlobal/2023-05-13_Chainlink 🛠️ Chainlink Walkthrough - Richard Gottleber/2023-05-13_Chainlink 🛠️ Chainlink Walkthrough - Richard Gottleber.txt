foreign [Music] I'm Richard one of the developer Advocates at chain link labs and today we're going to take a look at what is chain link and what are a few of the products that chain link offers so let's Dive In all right so first question what is chain link in order to understand that we need to make sure that we have a base understanding of a couple of Concepts the first of which is what exactly are smart contracts and what's the purpose of them a basic definition is that a smart contract is a digital contract it's stored on a blockchain it automatically executes when certain parameters are met now why are they important well they're important for two main reasons in my opinion first they're transparent that means anyone can see what the terms of the contract are and they enable you to know exactly what's going to happen when those conditions are met additionally they're distributed combined with transparency the fact that they're distributed means that you remove Trust from the situation in a traditional World contracts rely on a third party and they rely on trust that the parties involved in the contract are going to do what they say and honor the terms of the contract even when legal systems are fairly robust this isn't a guarantee it's a almost always most likely things will work out type of promise and that is something that smart contracts can remove smart contracts replace that third party they replace the trust no longer do you have a trust-based system of agreements now you have a system of agreements which allows users to rely on cryptographic truth so we have a truth-based Agreement System instead of a trust-based one so that's why smart contracts are so important and so powerful that transparency the removal of trust being necessary for them to function and the distributed nature of them now in order for smart contracts to work they live on a blockchain and blockchains rely on the different nodes within the chain reaching something called consensus what about consensus how do we reach an agreement within a network of nodes for certain values let's take a look at a simple example what's one plus one we can all agree that one plus one is two it doesn't matter when I ask you that question it doesn't matter where you are when I ask you that question it doesn't matter about any other inputs into the system one plus one is two this is a deterministic value and blockchains work exceptionally well in fact they rely on deterministic values to reach consensus if you think about us as a network when you ask me what one plus one is I'll tell you two and when I ask you the same question you'll give me that same answer that means we can reach consensus we could come to an agreement on what the answer is we all agree that it's two now what if I were to ask you a little bit different style of question what's the current temperature it depends I mean it depends on where you are when I ask you this question there are other factors that determine the answer to that question that's a non-deterministic value anytime that you can ask a question and the answer could be it depends you know that it's a non-deterministic value and the real world is full of non-deterministic values in fact pretty much everything in the real world when it comes to data is non-deterministic it's going to depend a lot this brings me back to Smart contracts they have phenomenal power much like Genie phenomenal cosmic power but deterministic values mean much like Genie itty-bitty living space right they're confined to blockchains traditionally smart contracts can't reach out to the outside world that's referred to as the Oracle problem now this isn't a limitation that we can't overcome right we can do something about that we can help our smart contracts interact with the real world and oracles are a solution to the Oracle problem and that's exactly what chain link is it's an oracle Network in fact it's a distributed Oracle Network so just to make sure that we're all clear and Oracle is a device that interacts with off-chain data to provide that data to Smart contracts essentially this unlocks the full potential of smart contracts now you may be wondering could I set up my own Oracle the answer to that question is yes you could set up your own Oracle and it would work you could bring off-chain data on chain and you could you could own that but I see that as a bit of a limitation because if you notice we have a decentralized network that is the blockchain and now you're effectively centralizing it with a centralized node for your Oracle if something were to happen to that node or if that node were to be a bad actor well you're kind of in trouble because you have centralized that and that again is what chain link offers it offers a decentralized Oracle Network so the Oracle Network that chain link offers is much like the network of a blockchain where there are multiple nodes participating but they are participating in a decentralized fashion so there's three main things that we're going to talk about today when it comes to what chain link offers the first is data feeds next is vrf or verifiable Randomness functions and the third is keepers so let's take a look at each of these and walk through a quick demo of how to use them we'll start with data feeds data feeds as the name implies are about bringing data on chain feeding that data into a blockchain and what does this data look like it can be any data it could be Market data Bank payments retail payments it could be anything that's available via an API the most common use case that we see are asset pairs so let's take a look at data.chain.link and what this looks like in practice if you head to data.chain.link you'll see various data feeds I mentioned that these are asset Pairs and if you take a look here the first one you'll see is eth in terms of USD let's dive into that one what we have on this page is the trusted answer that's going to be the aggregated response from various oracles on the right side of the screen you can see all of the different Oracles and the price that they're reporting there's a few things to look at on this screen the first is that trusted answer that's going to be the aggregate answer based upon all of the different values reported by the oracles this is how you can overcome the issue of bringing non-deterministic value into a deterministic landscape like the blockchain each node reports the price that it thinks is the proper answer to the question of what is the value of eth in terms of USD for this data feed we take those prices and we use the median value to bring the data that is non-deterministic into a deterministic answer given various inputs when taking the median you now have created a deterministic question given a set of inputs what is the median value that will always come out with the same answer this is how you've taken a non-deterministic value and brought it into the blockchain and made a deterministic on the left hand side we can see that trusted answer as well as the trigger parameters those are going to be what causes this price to update on chain so if the price deviates outside of the threshold that's set or if the heartbeat comes up that will be just a Time based trigger if we scroll down on this page we can find more information about this including the history as well as more information on each Oracle node and the data that it's reporting at the bottom we'll find the users of this data feed these are the people who are vested in keeping this data feed accurate and up to date let's head back and talk about the next product verifiable Randomness functions now you may have gone through a course or learned about how to get a random number on the blockchain using some sort of seed like the block hash this works to create a fairly random number but there's a small issue with that and the issue is that those values can be known before their mind onto the block what that means is that a malicious actor who is adding blocks to a blockchain can know the outcome of that random number ahead of time and based on that they could decide whether or not to add that specific random number to the block that they're mining essentially I like to think about this as if you were rolling a dice and you can't necessarily determine what value is going to be rolled when you rolled it it's still random but a malicious actor could essentially re-roll that dice until they get the outcome that they would like that's an issue especially when you need random numbers that are verifiably random that's where chain link comes in chain link will provide a verifiably random number from the Oracle Network to a Smart contract and this prevents the miners from being able to act in that malicious fashion additionally I mentioned it was verifiably random there's a cryptographic proof included with the random number that will demonstrate how that number was generated next let's take a look at keepers chain link keepers are a way to automate smart contracts we talked earlier about how smart contracts are like Genie from Aladdin and one other Factor about smart contracts is they are exceptionally lazy they're not going to do anything without an input something needs to call a function within a smart contract in order for it to execute that's where Keepers comes in Keepers will allow you to take a smart contract and based upon either time-based or a custom function execute the code within that smart contract now again you could create your own node that would call Smart contracts much in the same way as you could use your own node to get a piece of information off chain on chain but the keepers Network again brings that decentralized Network where you have again the benefit of decentralization and you can ensure that your contract will be executed in the same fashion now let's dive into some code and take a look at each of these products a little bit more closely and see how you'd actually use them in a smart contract so the first thing to know is that when it comes to examples and code with chain link you're going to want to go to docs.chain.link this is the best place to start when it comes to finding up-to-date information as well as examples we'll start with data feeds if we head down here we can see that the supported blockchains is broken up into two different areas the first being evm chains the second being Solana Solana is separate because it's kind of a different Beast if you've ever used any of the programming Tools around the salon ecosystem you'll know they are much different than solidity so that's why it's broken off into its own space let's start with data feeds if we head to data feeds we can learn about data feeds and we can learn about using data feeds that's rulehead using data feeds right here on this page you can see an example contract and this contract will allow you to get the price feed for each in terms of USD let's go ahead and open this in remix now if you're not familiar remix is a web-based IDE for solidity this means that we can both deploy and interact with contracts on blockchains it's pretty great and you can do it all from your browser let's take a look at this contract and see what exactly we're doing the first thing you'll notice is that we're declaring the solidity version then we're importing a contract called aggregator V3 interface that's going to give us the interface to the price feed aggregator contract we have our contract called price consumer V3 on line eight you can see that we are setting up a price feed that is one of those aggregator interfaces there's some notes talking about what network we're going to be using as well as what the aggregator is and an address something to keep in mind each asset pair aggregator has its own address you can find those in the documentation I'll show you that in just a moment we have our Constructor which goes ahead and sets up the price feed and keep in mind Constructors are only run when a contract is deployed they kind of set up things that need to be configured when that contract is deployed and finally we have our function get latest price it's going to return one value the price now this looks a little strange we have all of these commented out values and the reason for that is within solidity you need to account for every single value that a function returns this latest round data function will actually return a round ID the price when the round started a time stamp and what round it was answered in but we're only interested in the price so you can either comment them out or just delete them completely it looks a little strange because essentially the signature for this function would be comma Enterprise comma comma comma again those are commented out there just for readability and understandability of this example contract finally we take that price and we return it that's it it's a pretty straightforward and simple contract but let's take a look at how to deploy it if we head on over here to the deploy and run transactions we'll need to ensure that our environment is our injected provider that will take the wallet from your browser and inject it into remix so that you can interact with the blockchain in this example I'm using Brave and I'm also using the brave wallet but it functions basically the same as metamask we'll also need to select the correct contract anytime you have a contract that Imports other contracts they will be available here to be deployed so just keep that in mind and make sure that you're selecting the correct contract and finally we can click deploy we'll need to approve the transaction and wait for it to actually be deployed we should see a green check mark down at the bottom of our screen once it is deployed all right we've got that green check mark and we can see on the left hand side we have our deployed contract if we open that up we can see all of the functions that were deployed within our contract now we only have one it's get latest price let's see what it returns when we click it we can see that we get this price and this price seems like it may be a bit out of line with the current price of eth but there's something to remember when it comes to pricing data solidity doesn't have the concept of decimals that means that we need to somehow account for decimals and the way that we do this is by multiplying a result by 10 to the eighth power in this case so we'll need to insert our decimal to understand what this price actually is if we were to go one two three four five six seven eight places and insert a decimal point there we would see that the price returned is actually 1917. so just like that we have gotten a price data from an off chain resource on chain that's awesome and I think it was pretty simple and pretty quick next we're going to take a look at vrf or verifiable Randomness functions let's go ahead and take a look at that now again we'll start at the documentation page so docs.chain.link if we scroll down we'll go to Randomness or vrf now here again we can learn about how to use Randomness how chain link vrf works but I'm jumping straight into get a random number for this one we're going to need another asset Not only would we need test net eath but we'll also need testnet link tokens this will allow us to create a subscription that we can Fund in order to get our random values so if we follow the instructions here we can open our wallets and make sure that we are on the go early test Network I am we can then go to the go early faucet and get some testnet link or eth if we need them and then we can go to the subscription manager now subscription essentially the way I like to think about it is it's a bucket of link that we can allow other contracts to use so we'll create a subscription it will autofill our address if we've connected our wallets you may have been prompted to connect your wallet when you came to this page the first time we'll create our subscription and we'll need to approve that subscription once that's approved and verified then we can go and fund our subscription and while we're waiting for this to approve something to keep in mind is the way that subscriptions work is we need to create a subscription we'll get a subscription ID then we'll create our contract to interact with that subscription and when we deploy it we'll let our contract know about the subscription ID once we have deployed our contract we'll come back to our subscription and let our subscription know about the address of the contract we've created essentially we need to let the contract know about the subscription and let the subscription know about the contract all right so we've got our subscription created and now we can add funds to it I'll go ahead and just add five link again we'll need to approve this transaction as well while we wait for this to happen let's head back to the documentation and take a look at what we need to do next we've gone ahead and created our subscription we've added funds after we add funds we'll need to add that consumer that's going to be the address of the contract that we deploy but we haven't deployed a contract yet let's scroll down and see if we can find an example create and deploy a vrfv2 compatible contract fantastic we'll go ahead and open this contract in remix and take a look at what it does so again kind of similar to the other contract we're declaring the version of solidity to use and we're importing a couple of contracts from chain link the first is a coordinator that will allow us to request that Randomness value and then we have a consumer that's going to be helping us here in this contract go ahead and consume the values returned from the coordinator we see that our contract here is using that consumer base V2 we set up the coordinator interface we have a few values here we have a subscription ID that will be that subscription that we just created we have the address for the coordinator one thing to keep in mind this address again will change based on the chain that you're on at the end of this demo I'll go ahead and show you where you can find these different addresses we have a key hash the key hash is also going to be dependent upon the network you're on we have a callback gas limits this limit is going to be the maximum amount of gas that the fulfill random words will be allowed to use depending on what your fulfill random words function does will determine how much you need to set this to for the example this will work just fine we have a request confirmation that's how many blocks need to be confirmed before the request is sent back to us number of words in this instance it's two that means we'll get two random values back now words is a computer science term that is technically correct but sometimes I think it can be confusing to people when they first come to these contracts when we're talking about vrf and you see words just think random values we have an array to store the random values returns we have a value to keep track of our request ID we don't really do much with it in the example here but if you had multiple calls for different things being made you could map a request ID to a specific thing take for instance nfts if you are using random values with an nft you may want to map the nft ID to the request ID to keep track of which request is for which nft and then we also have the owner of the contract we have our Constructor which remember Constructors are run when the contract is deployed this Constructor takes a value in we'll need to supply our subscription ID then we set up the coordinator the owner and we also set that subscription ID to what we passed in next we have our request random words function this function essentially reaches out to that vrf coordinator and says hey unlike some random values please and it passes in all the information that we've set above like the key hash the subscription ID the number of confirmations the gas limit and the number of words that we're looking for once that coordinator actually generates the random values it will then come back to our contract and call the fulfill random words function this is where you would use those random values in this case we're just storing them but if you wanted to do something with the random values you'd put that in here and finally we have a only owner modifier just to make sure that only the owner can request random words all right so let's take a look at deploying this again make sure your environment is correct as well as your contract you'll notice this contract it needs a value it needs that subscription ID so let's head back to the create subscription and grab that subscription it's asking us for a consumer address that's going to be the address of the contract that we're about to deploy but our subscription ID for this example is 101. now when you create a subscription your ID will be different well back here we'll give 101 to our deploy and we'll go ahead and run this transaction confirm it and we'll wait for that green check mark that means that our contract has been deployed successfully while we wait let's go ahead and take a look at where you would find the different values for the different chains I mentioned in data feeds that we could take a look at that as well here under data feeds in our documentation you can see contract addresses and all the different chains on which we have data feeds you can see each of the chains and the asset pair as well as the address that you would need to provide similarly under using Randomness for vrf we have a contract addresses section as well this will include the coordinator the link token some different hashes depending on which gas line you would want to use if you're on a mainnet there's multiple gas Lanes most of the test Nets just have one gas line but you can find the different information that you need for different networks here in the documentation all right we should be deployed and we are fantastic there's a couple things to look at once we have given our contract address back to our subscription so we'll copy our contract address this is the contract that we just deployed and we'll put it here as a consumer again we'll need to approve this transaction and once this is approved we can go and actually look at our subscription it'll have some interesting information like the history what our current link balance is how much each consumer has used of that balance and information like that all right our consumer has been added let's go ahead and view our subscription so as I mentioned here you can see all of the information about the subscription and let's go ahead and call our subscription here so we'll request random words we'll approve this transaction and once it's been successfully submitted we should be able to see it in our subscription all right it's been submitted before we head into our subscription we can take a look and we can see our request ID cool let's head to the subscription and refresh this page and take a look at what it says now so you can see we have this pending transaction that means that we are requesting Randomness but it hasn't been fulfilled yet remember we have to wait for those block confirmations the amount of time that this takes can vary depending on which blockchain you're on how fast blocks are mined as well as how many confirmations you're requesting confirmations you can increase the number and end up with a more secure random number but the trade-off is speed so more secure but slower or a little bit less secure but faster again it's a verifiably random number so you can trust that it's random when it comes in all right so we refresh the page and we can see now our history no longer is it pending we have our Randomness and we can see that we've gotten a response back in our subscription page we can see how much link it cost and we can see that you know our one consumer has spent that same amount one nice thing about this subscription interface is you could add another contract from the same subscription and have two consumers or more using that one source of Link if we head back to our contract in remix we can now take a look at the random words something to keep in mind this is an array so it's going to have two values because that's how many requested in this contract arrays work with a zero based indexing system so the first value would be zero the second would be one so if we look at the first value zero we can get the result of a random number again if we take a look at number one which would be the second value in the array we'll see that it's a different random number so just like that we've set up a subscription and deployed a contract to Generate provably random numbers in solidity that's awesome let's head to the final thing chain link keepers all right as always we're gonna head to docs.chain.link as our place to start and then we'll head to automate contracts because that's what we want to do we want to automate a contract with chain link Keepers now when it comes to contract automation Keepers version 1.2 just came out and there are two ways to automate contracts now the first is time based if you're familiar with operating systems that are Linux based you may be familiar with a command called cron cron is essentially a time-based triggering system for Linux Unix systems chain link Keepers uses the same sort of interface to generate the time-based automations if you're not familiar with what a cron tab looks like or how to set up a cron tab I recommend a website chrontab.guru it will take you through everything you need to know and explain what the different values in a cron tab are we can take a quick look at it now this website will let you pick random cront tab values and it puts them in what is essentially plain English at the top cron tab is broken down into five different sections it's going to be the minutes the hour the day the month and then the day of the week the first day being the date of the month this is a great resource if you'd like to look into it more but just something I found helpful when it comes to ensuring that a cront tab I create is doing what I think it's doing but let's head back to the documentation we're going to take a look at time-based automation first and then we will take a look at custom logic and we will do the same thing in both of them and what we're going to do is we're going to deploy a contract that has one value a counter and it will increment that counter on a regular basis so the first thing we need to do is we need to head to keepers .chain.link again this is going to be similar to vrf in that we'll need to create a new upkeep similar to vrf subscriptions but slightly different so let's register a new upkeep and I mentioned that we're going to do time based now we're running into the first problem we need a contract so let's head to remix so it's remix.othereum.org and we will create our own smart contract we'll just call it count.soul all right what do we need for our basic smart contract the first thing we'll need to do is tell it what version of solidity we need and we can just kind of follow along with the same values that we've been using we also need to name our contract we'll call it counter and with encounter we can create a value a uint called counter and we can make this counter be public that means anyone can access it outside we'll need our Constructor and we don't actually need to do anything in our Constructor here so we'll just have it other than set counter equal to zero so when this contract is deployed we'll set our counter equal to zero and then we can create a function and we can call it count it'll take nothing in and what it will do is it will say counter equals counter plus one this will allow us to increment our counter now this function we're going to need to call it from outside of our contract so it will be external that means that we can call it from outside but not inside and that's it this is our entire contract it looks like I'm missing a semicolon up here make sure you have your semicolons and yeah we've got our contract so let's go ahead and deploy this contract again we'll make sure that we inject and we pick the right one and we'll go ahead and deploy now when this is deployed we can then have the address and give that to our new upkeep that we're creating that upkeep is going to need to be informed what can actually be done with our contract if you verify a contract on the Block Explorer of that Network the keeper interface can go ahead and read that information in this contract's not verified we'll copy the address of it and we'll come here and we'll take a look at what we need to do next it couldn't fetch the ABI because the contract's not verified so we'll need to provide the ABI that's the application binary interface essentially it lets other programs know what can we do with this contract where do we find the ABI in remix right here under our compiler we can make sure that we pick the correct contract and then there's this ABI button right here when you click it it will copy the API to your clipboard so we'll head back and paste it in we can see it gives it some information about what the inputs are and what the different functions are and we can do next now that we provided the ABI the keepers interface is aware of what functions there are available in our contract this is a pretty simple contract it has one function so we'll select that function and click next here's where KRON comes in so this cron will give us some things that we can do like you know every 15 minutes every hour the first of every month we'll pick every 15 minutes to start with and then we'll change it to be maybe a little bit faster so we'll say every minute we want this keeper to execute so every minute we should see an increase in our counter we'll name this upkeep we'll say count we'll give it a gas limits and we can go ahead and just go with the defaults here again this is going to be a limit based upon the amount of gas that your function needs we do ask for an email address this is to provide information based on your upkeep if you have an issue like you're running out of Link or something like that and we can register our upkeep again this will take some confirmations from your wallet and it will also transfer some link from your wallet to your keeper so this does take two confirmations and once they have been confirmed our upkeep should be ready to go all right our upkeep has been registered let's take a look at it we can see here all the history and all the information as well as a projected time of next execution this one's pretty straightforward because it's running every minutes once our upkeep has run we should see that our counter has increased now while we're waiting for this upkeep to run let's head back to the documentation and take a look at custom logic again we'll need to register a new upkeep and we'll need to have a contract that is deployed that's a keeper compatible contract so if we look at creating a keeper compatible contract it requires two things the first of which is a check upkeep function that will return a Boolean as well as possibly some data that lets us know if we need to actually perform upkeep and that tells us what the second function is it's perform upkeep so with a check upkeep function and a perform upkeep function we have a Keepers compatible contract now there are example contracts here and we can scroll down and see one this contract essentially does the exact same thing as our other contract but it's a little bit more involved because we are using that custom logic so let's open this example in remix and take a look at it as well so again we have our solidity version and we import keeper compatible interface we set up our contract named counter and we create our public value of counter we create two other variables as well the first is an interval that's going to be how often we want this to run in this case remember we're doing the same functionality but we're using custom logic instead of strictly time-based logic we keep track of the last time stamp that's going to be the block Dot timestamp in our Constructor we'll pass in the interval in seconds of how often we want to update this and we'll set our last timestamp to the current blocks timestamp as well as setting our counter to zero we then dive into two functions the first is check upkeep which takes in some call data as well as providing the upkeep needed and the perform data if we have it in this example we're just passing back upkeep needed that Boolean value true false so upkeep needed will be determined by looking at the block.timestamp subtracting the last time that we did something the first time this runs that'll be when the contract was created but as we'll see and perform upkeep it could be the last time that we had performed upkeep and seeing if those two time variances are greater than the interval if it is that value is going to be true and we need to perform upkeep so what does perform upkeep do again it takes in that form data and it checks once more to ensure that we actually need to do our upkeep and it's important to do this because you always want to make sure before you make a change on chain that you are actually needing to do it so we check again that block timestamp minus the last time stamp is that greater than our interval if it is we'll update the last timestamp and we'll add one to the counter it's doing the exact same thing it's a little bit more involved because this perform upkeep and check upkeep methods allow you to have any validation that you need to check if you actually need upkeep you could look at things like pricing wallet balances essentially the sky's the limit when it comes to what you can do with custom upkeep functions so before we dive into adding this to a keeper let's deploy it first same thing that we've been doing this whole time injected and we'll make sure that we pick the correct one here we'll send it an interval we'll say 60 seconds and click deploy we'll confirm this and while we're waiting for this to deploy we'll head back to our other time based keeper if we head here and refresh our keeper details we can see that hey it's actually run twice while we've been waiting so if we look at our contract that has been deployed and we take a look here at what our counter is set to you can see our counter has now changed to two so this contract is incrementing itself automatically on a Time based interval of one minute roughly again the time-based intervals of very low values like that can be less than perfectly accurate just because we're requiring a block to be mined when we check so depending on what chain you're on that could be a little bit tricky when it comes to very small time-based values just something to keep in mind alright so this counter is working on a time-based interval that's amazing we'll go ahead and close this down just to keep things simple and we'll head back here our contract is deployed now so we'll copy this contract and we'll head back to creating a keeper so where do we need to go we need to go to Keepers Dot chain dot link all right and we'll register a new upkeep here and this time we'll pick custom logic we'll enter the address of the contract we just deployed and it'll try to verify it as well if our contract was verified it would be able to ensure that it was a keeper compatible contract because we haven't verified it we can still deploy this keeper but it's relying on us now to make sure that the keeper contract is a keeper compatible contract we'll provide a name again so we'll just say count two we'll give it a gas limit and we'll go ahead and give it the same one we gave it before we'll give it some link to start with we don't need any check data but we do need an address and we can register our upkeep once this has been confirmed we should see upkeep kick off pretty quickly I often get questions about upkeep and how can we ensure that someone doesn't call perform upkeep other than the keeper in my mind one thing to keep in note is best practice is why wouldn't you want someone else to call perform upkeeper that's going to be the function that costs gas if someone else wants to pay my utility bill for me awesome let them do it but make sure that you have your perform upkeep set up in a way that it will not be a problem if someone else calls it or if it's called repeatedly that is why in this example we are checking again to make sure the upkeep needs to be run it's always good to make sure that that one only runs when it's actually needed so just something to keep in mind but locking that down so that only the keepers Network call it I think that that's not something to worry about you should focus on it from a how do I make sure that no matter who calls this it only actually does what I want it to do if we head back here we can see that our upkeep has been registered we go ahead and view our upkeep we can see here we've funded it we've created it we'll need to wait for it to actually run all right we refresh the page and we can see hey look it actually did run and we performed our upkeep fantastic let's head back to our contract and take a look if we open up our contract and we check the counter hey our counter is one we have an increment encounter again in this case it's based on time but using custom logic that we defined not just strictly based on a cron Tab and this really opens up the opportunity for automating anything that you can come up with so that is some of the products that chain link has to offer I really appreciate you taking the time to walk through this and if you have any questions feel free to reach out you can find me on Twitter I'll put my Twitter handle right here and yeah have fun building I look forward to hearing from you and seeing what awesome projects you come up with hi I'm Richard one of the developer Advocates here at chain link labs and today I have something really exciting to share we've launched a new product chain link functions which brings the power of serverless functions and cryptographic guarantees to your decentralized application so what does this look like let's find out chainlink functions provides your smart contract with access to a trust minimized compute infrastructure it enables your contract to send code to a decentralized Oracle Network or Dot each Oracle will run the code in a separate serverless environment once the oracles have their results the Don then Aggregates that information using ocr2 and Returns the final result to your smart contract your code could be anything from a computation saving gas by running it off chain and fetching data from an API now it's important to note that this currently is in beta in fact it's a closed beta there will be a link in the description to sign up given that things may change from the state they're in when I am recording this but most of you should see something that's fairly similar you will need to take a few steps to get everything set up and running and then you can look at both of the examples so what does this setup look like well first you're going to need to install node.js version 18.0 or greater you'll need to clone the function's hard hat starter kit onto your machine you'll need to get some link and Matic because we'll be using the Mumbai test Network you'll need to obtain an RPC URL from a node provider like inferior or Alchemy you'll be using Alchemy if you follow along with this example you'll need an API key for polygon scan to verify your contract and finally you'll need your wallet's private key remember that's something you never want to share with anyone many of those set up the foundation is late let's look at the starter kit all right so here we have the starter kits it's on GitHub let's take a look at the readme and see what we need to do it walks through an overview explaining functions lets you know what test Nets are currently supported uh Gets You Through setting up your wallet getting funds and providing step-by-step instructions in our getting started guide if we need that but we can skip straight to the quick start make sure you have node version 18 installed and then you'll need to clone this repository to your machine I've gone ahead and done that the next thing we'll need to do is open up that directory and run npm install so let's do that now all right so here we have the repository clone to my machine I'm using vs code and we can see here that we're in the repository cell the function's hard hat starter kit so the first step is to run npm install this will install all of the dependencies that we need for this project great that's done so what's next well we'll need to go ahead and get a GitHub account set up and get a personal access token from GitHub this will allow us to share our our encrypted secrets with the Oracle Network so how do we do that if we head back to the readme we can visit github.com settings and from here we can set up a new token all right so we'll click set up new token and we'll see something like this we can create the token name functions example set the expiration this is how long it will be available for the description if you like who the owner is and the only thing that we need to change is we need to go to account permissions and we need to change it for just we need to say read and write once we've changed that we can generate the token and here we have the token we'll need to copy this and use it later we'll head to our starter kit I'll just make a new file and we'll paste the token in here so remember this is private right you don't want to share this I'll be removing this token after I get done recording this video so it won't be of any use but this is one of those pieces of information that you wouldn't want to share because it does give read and write access to your gists all right so we've got that value stored what's next well we need to set up the environment variables now the way that this is done is through the EnV ENC package it will encrypt our sensitive information so we need to set that up the first thing we need to do is run this npx EnV ENC and set a password this will set the password to actually encrypt those values so we'll set our password and that's it all right so we set up that encryption password now we need to set some of the environmental variables up which ones do we need to set up well for this tutorial we'll need to set up our private key that's going to be for the wallet that we're using to deploy the contracts we need to set up our GitHub API token that's the one we just generated and you can see it above we'll need a polygon Mumbai RPC URL remember I'm going to be using Alchemy for that we need a polygon scan API key if we want to verify our contracts and then finally one of the examples here uses a coin market cap API and we'll need a key for that you can get one at coinmarketcap.com API how do we actually set these up so we use npx EnV ENC set from here it will prompt us for the first variable name that we want to enter so I'll use private key for this example then it'll ask us to input the value for that variable I'm not going to input my actual value here and you'll see why in just a moment but I'll put private key here do we want to set another variable sure let's set another variable we'll set GitHub API token and we'll set this to the value we have above once you've set all these different variables you press return and we're done now why didn't I enter my actual private key it's because if you want to check what you've set you can type MPX EnV ENC View and this will show you everything that's set so we have our private key and we have the value remember I typed in private key here you should actually input your private key we have our GitHub API token and I need to go through and set the rest the polygon Mumbai RPC URL the polygon scan API key and the coin market cap API key so once you've got all of those set you're ready to move on to the next step I'll go ahead and set them now off screen and we'll be back all right so you set those different values your environment is ready to go what are we going to be looking at the first is going to be this calculation example.js now what this file is is it's a calculation that would be a very expensive in terms of gas on chain it's a continuously compounding interest rate and you can see here it takes in a few things so we have the principle amount which comes from args4 what is rx4 we'll get to that in just a moment we have the apy times 100 and then we have our decimal percentage time in years Euler's number and the actual calculation itself this is a very complex calculation in terms of what it would cost on chain we're running it in a Javascript file like this it's super simple we run that calculation and then we return the value rounded this value will be passed back to our contract so we have this args value here where is that coming from well if we take a look at functions request config we can see a few things here in the actual request config the first thing to know is the source that's going to be that file we just looked at that calculation example right that's what it's going to be reading in to actually run within the functions we also have the args if you remember it was four and five that we were looking at and they start at zero so we have zero one two three four and five so those two values that we're passing in come from this arguments are right that will be passed in to our JavaScript cool from there the other thing to look at is this functions consumer contract you can see how it's laid out here we set up our contract we have a few things set up like the last request ID any error or response we have some events we construct our contract and then we have this execute request function this is what's going to be actually making that call out to the Oracle Network so you can see it initializes request it loads some information in we actually make that request and then we get the request ID back if you're familiar with vrf functions is kind of similar in the workflow we make a request to the Oracle Network we wait for the Oracle Network to get back to us the response and this can come back into our contract with a another function the other function is this fulfill request function so we go out we make the request it runs our JavaScript code and then it's going to come back into our contract with the fill request here the fulfill request is very simple all it's going to do is update the latest response and error values and then emit a event we can run it with npx hard hat functions simulate and what this will do is it'll run it locally on our local machine now we can see it got back here this decoded value of 1 million and some change so that's going to be the value that's actually calculated by this calculation example here where we have our total amount of Interest right our continuously compounding interest great so we've run that locally how do we actually deploy this the way to deploy this is with MPX hard hat functions deploy client we'll need to pass in the network that we want to deploy it to that's going to be polygon Mumbai for this and we'll go ahead and verify it so with this command it will actually deploy our contract our consumer contract this functions consumer.sol to the Mumbai Network we'll need to wait for the block confirmations to come back and we'll have our contract verified if we want to check it out on polygon scan great so it's done right so we've deployed our contract the next thing that we need to do is we'll need to go ahead and create a subscription so we can do that with MPX hard hat functions sub create so use MPX hard hat functions sub create we'll pass in our Network again the amount is going to be how much link that we're going to supply our subscription with and then the contract address will need to be the address of the contract that we just deployed well plus return it will go and create that subscription for us again we'll need to wait for those block confirmations and our subscription is confirmed now something to keep in note here is this created subscription ID in my case it's 778. yours will be different we'll need to keep track of that because we'll use it in the next step as well as our contract address so we've deployed our consumer contract we've created a subscription how do we actually run a function into the Oracle Network we do that with npx hard hat functions request we pass in our Network again that's polygon Mumbai pass in the contract address that's the contract that we deployed our consumer and we pass in our subscription ID when we press the turn it's going to check a few things and ask us if we're sure if we want to continue we'll say yes we do want to continue and now it's actually running that request in the Oracle Network there's submitting our request and we'll get the response back from the Don here shortly and there it is we've got our response back that's pretty cool we've run this code in the distributed Oracle Network we saved a ton of gas because we're not actually doing these calculations on chain right that's massive but this is just running a basic calculation what if we want to do something more interesting like hitting an API well if we head to API request example here we can take a look at this file really quick it's going to use some arguments that are passed in remember those are going to come from our request config so it's using one Bitcoin BTC Bitcoin and BTC and then we'll check and see if we have our secrets.api key the reason we'll need that is for coin market cap if it doesn't have that set it'll error out you'll then create some requests for us right so these are the actual API requests we'll hit four different apis one from coin market cap one from coin gecko one from paprika and one from a bad API just see what happens if we have one API that's not working we'll use those we'll make those requests we'll check for errors we'll log the errors if we have them now console log we'll see what that looks like here in a minute because we will get an error from our bad API and then finally once that's done it will go ahead and calculate the median price based on the responses so how do we actually run this well there's a couple things that we need to do we need to go into our functions request config you'll notice this calculations example that's what we used just a moment ago we'll comment out this line and we'll uncomment the one below it this is going to change the source file of our JavaScript the other thing is that that new API request example it needs those Secrets right so we'll need to uncomment the secrets line as well give it a save and we'll run the same exact command that we just ran our contract hasn't changed we've changed our config so that'll get picked up by this functions request command and we're ready to go so we'll go ahead and run this command and we'll see things look a bit different we'll say yes we're sure we want to run this and we can see here that locally it decoded this new value based on those API calls sweet how does this look when we get to the Oracle Network you can see it's using our encrypted secrets from our gist that's really cool and it's actually making the requests to the dawn right now and the reason this works is because we're using a unit in both examples and our contract's not really doing anything with the value other than logging it if you had something more complex set up you need to change your contract as well but we can see here that's we have our value came back here as the value of Bitcoin we can see the transaction cost and we can see that our just was taken care of so that's really cool we've used chain link functions to reach out to an API and bring data on chain I think this is super powerful I'm excited to see what you start building with this I'm really looking forward to the potential and the power that's being unlocked with chain link functions so go out there and build and I'll catch you in the next one foreign 