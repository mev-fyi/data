foreign [Music] talking about super chain 101 so without further Ado please welcome Carl here with me to uh tell you all about soup chains hey Carlos hello how's it going it's going great we'll uh we'll let you get started welcome alrighty wow I apologize for the semi-salse advertising because this is definitely not a 101 this is more like a uh significantly more um very very in-depth if you want a real one oh uh the Devcon talk is probably the way to go but you know what we are all about getting into the weeds also notably notably some of you might have seen some of this presentation before um because it is on the um but I think it'll be a good refresh there's way too much information here um so it's it's a good one but yes this has to be a boring presentation because it's very in the weeds let's go let's do this time's up okay so super chain to the rescue Ramen why are we building the speaker chain well it's to scale because blockchains are so insufficient for the decentralized weapon we want to create why is that well because of congestion oh my God so blockchains don't scale right like we are often paying 15 and you know 13 for a transaction it's insane my transaction was just an electric Electronic Arts trying to tweak now not tweet I'm trying to act um and it paid 13 for that transaction no way no way no way so we need scalable infrastructure that is decentralized can still support the insane amount of traffic interput that we you know require and so this isn't new right like this has been a problem from day one first response to the Bitcoin white paper we very very much need the system but the system that you proposed does not seem to scale sorry Satoshi um we have to make progress on top of it so anyway this has been plaguing the industry since 2008 it's now 2023 goodness gracious let's do this so okay before we like you know and and cried let's imagine a future because we are very close to that future we are incredibly close what if things were different it wasn't just crypto wasn't just about you know me and clients and you know it was also and everyone was using it for literally everything all like you know from social media to games to Etc and the whole world was running on decentralized well you know what would that be like right we can literally abstract away the back end software stick we don't have to worry about what provider we're using because we're using a decentralized network of providers that are all competing on the same internet standards it's like standards for the entire internet's back end and additionally usually had we would so much more composability people can actually work together application developers can work together the boundaries start to dissolve between one application or the other and we don't need to worry as much we can think more about the applications that we're building and not so much just about the infrastructure I mean let alone all of the amazing open source software that we would then be using and this is how we clearly you know the the internet from a Walled Garden you know difficult to hack on and contribute to your ecosystem to a vibrant vibrant world and so obviously of course in reality these pictures were going the other direction stopped using sunblock that's our sponsor um okay anyway no we should we have to oh my gosh I literally need to do these slides into Twitter you can build in this world right like you should be able to build the application Logic for Twitter that is horizontally scalable as a smart contract in a hackathon weekend that's where we need to be okay so the decentralized win obviously still can be realized we've been working on it for years started out building out east 2.0 like we were trying to Shard ethereum directly then we realized that we needed to build it out in Layer Two which we you know formed plasma group to scale ethereum and that way and then we realized that not only is there a scalability problem but for optimism we realize there's a public goods funding problem AKA there's no way to build open source software and get get rewarded for it so that's that's kind of the transition from plasma group to optimism so anyway but it's not just been us it's not just been us building out this Tech it has been a massive web 3 ecosystem full of developers and tons of incredible contributions talking about Roll-Ups the role of centric ethereum road map and it has allowed us to over time to find the instruction layers that allow us to scale this software together right in order to really unlock the internet stack we needed to define the stack of software that all works together the transport layer you know Etc that all works together to serve the internet we're doing this same thing this time for the decentralized web for the base essentially the stateful decentralized web first you know web one was kind of stateless so all of these different contributions they've led us to L2 they've let you know shout out to Barry Lynnette um we are starting to see the architecture clear and clearer and so that's really what this talk is about it's trying to give you the intuitions around what are the different layers of this stack and how do they all fit together and how all of that comes together to tactical congestion with the super chain let's super hack pal one two three okay okay so what is the super chain curse the basics right scaling to score the internet why is that well because a chain you need to be able to sync the chain download all the transactions replicate it on your local machine that is a critical property of chain software but if we were to just increase the size of a chain arbitrarily well what happens the blacks get bigger and bigger until my computer explodes and forms the black hole because there's too much information in one place we need to horizontally scale it's a fundamental law of nature um but it's not multi-chain right the super chain is not quite um you know the Loyalty chain future because multi-chains are insufficient they each different chain has its own different responsible own different validator sets so each one has security so as you bridge from chain a to chain B to chain C that is actually a different asset that you fundamentally created versus bridging from chain a directly to chain C so you really can't this is this weakest link security really increases the risk of you know building out cross-chained apps and also the flooring chains is super expensive if you have to replicate all of this infrastructure form consensus Etc it is very expensive so we need a system where chains are truly commoditized where we can really make use of them as a fundamental construction on the internet similar to how virtual machines commoditized anyway it's not model chain it's not multi-chain it's super tuned let's go okay so Super Jam properties we kind of go into all of them but I'm not going to really go into that because there's too many words and I like pictures so if it's not margins that will be changed so first up just one one visualization that we can start with is it's all these different layer twos that share a bridge and share node software so they're all instead of having totally isolated ecosystems they're all using the same standards to communicate with each other and they are all on the same security model using a shared rate okay so it means that means that because all of these op chains are standardized the dabs that are building on them get superpowers because now I don't need to think oh is this going to be compatible with this chain do I need to change my application for that change no instead you can write an application once and be ensure that it is compatible so you can then build out these abstractions and deploy directly on the super chain so I told you that we were going to be a little different from this stuff you know online that you can find already so this is a bonus this is a bonus section governing the standard Okay so shout out to David standardized open source modules for layer 2 Chains that's the op stack uh if you like Google it or you you YouTube it um so that makes sense right open source modules make sense right it's all open source if it's your license modules it's swappable the you know we broke it out the proofs are modulus and you can do ZK proofs optim you know fall proofs Etc but what does it mean to what does standardization really mean this context because it's actually a little bit it's a little it's a little nuanced especially when you're in a decentralized protocol context who defines the standard okay so let's unpack that I I recently I've recently started to like cats not gonna lie uh anyway okay the op stack right everyone's familiar hopefully so don't be stack implements that is the standard right and it implements a shared bridge and consistent client software across all of these different opjs now notably it is still the case that you can plug different things in or configure it in different ways but the way that you plug in those modules and the modules they are standardized so that you have nice abstractions that you can play with and kind of a shared ground that you can rely on um now how do we think about The Spirit Well up the optimism governance optimism Collective governs the op stack you know sets v0 V1 and that boom that expands out to the rest of the client software the shared Bridge so that everyone is upgraded on the same version similar version two everyone is upgraded all in the same version all of these just op chains stay in lockstep what does that do well it helps keep a vibrant ecosystem and I'm telling you more so all let's see all of these different opinions okay so first off let's talk about Standard Security what does that do for the security model of these chains well what I talked about before with the multi-chain stuff where you go from chain a to chain B to chain C and that's a different token that you cut out on chain C versus jna to chain C that is not the case because do have this Standard Security across the bridge okay so that's useful that's already useful that means that we're you know not fragmenting uh you know the token standards and all that stuff but another and very important point is universal tooling now I already mentioned all of these things but I think it's worth repeating so we can gain some intuitions for this stuff so let's say a developer is deploying their smart contract to NLP okay great well let's say they now because they are all the same software like all of these OB chains the standardized that same deployment works on all of Europeans and that also goes for the tooling let's say block explorers wallets you know debuggers Etc they all work on the same standard this is the power of standardization more broadly but I'm just trying to really connect it to why we need it in web 3. now deciding just a couple Chains It's a bajillion chains tons and tons of chains what can we do now well we can actually build out abstraction layers so that a developer instead of thinking about the chain that they're deploying to right yes it's compatible with all of the chains that's great but now we can actually go one more step meta and say okay we're going to build software that abstracts it away and now I can deploy directly onto the super chain broadly I can think about oh I need to instantiate I need to provision uh this many chains for my application to work right the idea to Auto scale all of those things start to become possible once you're on the same standard you're sharing the same apis you're working together in an open source manner so now the block explorers don't just have to be on a perching basis they can be abstracted and they can be on the super chain basis wallets they can be on a super we can have cert to see super chain wallets emerge that you know that all of these means that have standardized security so you can display the asset and it will doesn't matter which shame it's on or similarly debuggers debug across the super chain send one transaction boom have it affect the whole network so that's the power and I'll just say right now like similar what I said about kubernetes or uh you know containers I'm I'm ready if you're not just Uber and he's ready for supernetties uh you know like let's build out all of this software and obviously it is nowhere near to that today but that's the key power of Open Source now speaking of the key time open source let's talk about Cooperative Innovation let's talk about sharing our Innovations okay so another shout out to to David Hoffman go live he kind of talked about this analogy for EDM equivalence which is exactly the analogy that we use kind of for the OB stack and that is the Peloton so the Peloton is like you know when you're working on when you're racing in a bike you kind of break the wind first here right you're you're so it's actually you you use less energy if you're you know riding behind folks who are out this allows everyone to move faster right because they get to trade turns you know this guy's in front and that guy's in front of the night anyway et cetera you can look about Valentine's workout I don't know how to bite um but the cool thing here is that the pelotonist randoms like the standard right it's the open source standard everyone is benefiting they're all working together they don't need to worry so much about upgrades about customizations Etc now boom someone Forks the sack right it's MIT license it's open source they change something up maybe another person does the same boom they change something up now they're riding VR venturing into totally new territory that means that they have the latest and greatest craziest software but they've also incurred a bit of a maintenance bourbon right they're hitting the wind so what does that what do they do well they ride out front with their Innovations but then they contribute them back to the stack and now everyone who's in the Peloton is benefiting from that Innovation and we push the industry forward that is what it is all about it's about building open source software and standards to push the industry forward and that is the beauty of Open Source now what happens what about let's let's you know open source is one thing but open source has had a bit of a struggle and that is that there is not a strong incentive in a decentralized system to contribute back to the you know Upstream to contribute back to the collective really and what does that mean that means that if I build my custom software there's an incentive for me to keep it to myself you know add some kind of proprietary license instead of giving it back to the public good now what do we do for that well obviously optimism is not just about scaling ethereum but it's awesome and so retroactive public is funding let's go so another incredibly cool thing is that the standard also encodes standard ways to give back to op stack contributors and reward them for their incredible contributions that push the stack forward that means that we're not only benefiting from the open source software permissionless Innovation Etc but that permissionless Innovation wondering once it is integrated once it is really caused impact the people who build it get rewarded impact equals profit so this is exactly how you know this kind of creates this nice flywheel where demand for Block space increases sequence of Revenue and that goes back to the builders users and importantly how does it go back as a distributor because that is a non-triguing governance problem well critically it is a citizen's house discretion that means one person one vote we care about people always in balance with the token house and nice checks and balance the system the bicameral anyway I can get into that for a long time the point is that it's all about non-cutocratic governance that is truly decentralized to govern and contribute to the set so so we're making public goods profitable in a non-pludocratic way we're making them sustainable so people so we know that we can rely on the open source infrastructure and we can make sure the internet is decentralized because one of the things that we don't really recognize is that it is incredibly important that the incentives of the system the incentives of the decentralized protocol promote decentralization versus allowing centralized parties to out-compete the decentralized ones all righty so let's do this so we're back we're back we're back that was a nice little bonus right reminder building out the super chain they're all standard deploying the super chain coming soon now it's been a decade friend pretty kind of savage how long we've been working on this thing but but we are closer than ever and really this is a green field the green feel Green Field and you can contribute to help this thing become real sweet all right that's governing the standard so architectural foundations this is the thing that I was talking about this little in the weeds the boring stuff let's get into the boring stuff no okay it's all about abstractions when things are beautifully done there's usually a well thought outset of abstraction layers so derivation that is the core abstraction layer being most important so this is the process by which the L2 state is determined that means that it is essentially it is a pure function so you use this derived function boom now it spits out the L2 chain it's a pure function so if I have ethereum that's the ethereum block space now I run this derived function and I get the L2 alrighty so if I send a transaction let's say I'm I send a transaction to ethereum the derived function pure function transforms and it's wholesaling index or like a uh you know yeah an index on ethereum boom it now updates the balances in L2 and this continues even if there's nothing happening in the blocks it's still producing L2 box now similarly Alice didn't submit to L2 I mean uh L1 directly or can submit to a sequencer which then submits it on her behalf and this you know amortizes the cost of the transaction and also provides her low latency confirmations that UI function happens again boom now we have the L2 because remember the sequencer submitted that transaction to well pretty simple okay so let's go over this is an important game everyone needs to remember miss this is where we're in Mythbusters the sequencer can forge transactions true or false okay well we're gonna see so Alice sends a transaction to the sequencer it's assigned transaction only Alice knows the private key the sequencer changes the recipient of the money of the tokens let's say and now the transaction signature well it's invalid but the sequencer is not done yet the sequencer will submit that transaction to ethereum okay uh oh the sequencer just submitted in an invalid transaction what's gonna happen well doing right this derived function happens when I'm I'm locally deriving the chain this is not necessarily something the sequencer does anyone can derive the chain I spin up a node I'm dragging the chain right remember so I locally derived the chain as I'm deriving the chain I realize that this transaction is a little iffy it has the wrong signature so I'm gonna throw it away boom and I'm gonna create an empty block ignoring the invalid transaction myth busted the sequencer cannot Forge transactions that is incredibly important you're meant to not it really must be that the state of L2 is derived and determined objectively based on layer one that is critically important and no one can change that no one if I'm deriving the chain myself no one can make me derived okay so that's deriving one chain but really all Roll-Ups are just different derivation functions so there's the L2 chain and it's you know it's the it's the result of calling but they each have slightly different derivation function okay so you know the red derivation function results in the red chain blue and the blue and purple and the purple if that's purple and they each have their own sequences that are submitting transactions and of course when those transactions are submitted boom now there's new transactions on Layer Two for all of the different layers so if I want to submit to you know red chain I can or I can submit to you know uh blue chain and derive that I can do that or let's say I derived it all works this is why L2 scales by the way because every time I decide to sync a new chain I'm not syncing all the blocks on all the chains I'm only syncing the chain I care about this is why we need a super chain this is why the kind of movement chain thing doesn't quite work out okay so now that was that was that was their driving chains but let's go to driving's super chains okay so practically infinite roll of chains what does this do so instead of defining our DUI function as just a function of L1 we're going to define the derivation function as an L1 comma the configuration of that chain and make sure that that configuration is of course a standard configuration otherwise the derivation function will throw that results in an L2 chain but notably if you change the config so let's say you change the chain ID now you're deriving a different form this gives you access to basically an infinite number of chains it's literally it is a standard so you can ins you know instill and derive all the things kind of like looking into a kaleidoscope all of the you know stuff is there but you're just looking at it from different angles and kind of getting a different view of what's going on got it you know gotta have a little trippy imagery in the when you're talking about Infinity it's pretty cool that's that's math for you um okay so you're deriving these Infinity Chains It's not Infinity of course there's a limited number of bytes and practically okay so that is how we get a bajillion chains all right let's see okay I think 15 minutes less um so let's talk about cross chain messaging but we'll go reasonably quickly so how do these chains communicate with each other because we talked about how you get the state of a chain but now Howard's chains talk to each other how do they bridge between each other so Alice and Bob they're they are let's start off what does messaging look like in a normal World Alice sends you know write a letter she has a two and a message and a proof the proof is her signature she goes and she gives it to Moe the male person and can mow the male person gives it over to then heat back to the two he uh checks the signature to make sure it's from Alice and then reads the message you know well what if I told you that these were actually chains they were chains talking to each other well actually what happens is Mo initiates tells Alice chain hey I want to bridge my tokens to Bob chain sends that transaction migration tokens boom now Alice chain has just jealously you know does its magic and it generates a message that will go be sent to Bob that we want to send Bob now Bob Mo the person who you know initiated the transactions where the analogy breaks down a little bit but it's pretty close Mo takes that as well as a proof a proof of the validity of that trend of that message and sends it over to Bob and Bob validates the two the message and the proof and the proof the message is executed on blockchain right so what we're doing is we're relaying a message and we are proving it now how do we actually how do we actually achieve this well the two is easy the message is easy but the proof is pretty hard to do so what is that I how does this actually work in practice and how do all these proof systems work just in general right we're talking distracting layers we need to be able to think at a high level and then zoom in to each each detail so first we're at the level how does this work generally well a message is generated on red chain and that wants to be related someone wants it to be relayed on Blue chain well what happens is the two is of course blue chain the message is arbitrary and the proof we'll get to that so that is the proof actually how does blue chain know that red chain actually sent it well because blue jay knows the derivation function of red chain based on its chain ID and chain config what can it do well it can derive in some way boom it derives the chain based on L1 because of course all these chickens are connected to so derives the chain and then it checks the author indicate authenticity of that message so you might notice a problem right if you heard to do this kind of like fully verifying proof it would not scale whatsoever all the chains would be verifying the messages so what do we do well all of these crew systems they somehow manage to compress that proof into a small number of steps whether that be a fault proof or a validity proof they are all running this derivation function in some sense and validating the correctness now the fall proof does it only if you are only if there's an error and the validity truth does it up front you know using using math or some other method so importantly right I was thinking about modularity importantly all of these truths are valid all of these proofs are fine so the op stack it's all about modularity you need to be able to do fall proofs and to station based living through zkp validity proofs all that needs to support all proof types so now we can message between them but each message is asynchronous well we don't have time fortunately to go into sharing sequencing directly but you know at a high level it's actually very simple basically if you want to be able to send these messages back and forth you need to be able to do them atomically and therefore you need both chains the sequencers on each chain to coordinate and get those messages get a guarantee that both messages will be played on each chain at the same time that showed sequencing and it gives us the ability to do things like flash loans and really tighten up that interoperability and so boom we can coordinate these sequencers and you know there are many different ways to do this okay so now we've got messaging synchronization but I cannot end this talk without talking in the room scaling data availability we still have the bottleneck right if you if you were looking at this system you would notice that we're deriving infinite chains great fantastic but we're only deriving it based on a very limited amount of data that is I mean that means that we've only scaled compute we've not scaled data yet that is the data bottleneck um what am I gonna do so what do we need to do well first we can add more album data availability so that's either p4844 that is the most key fundamental thing that we're shipping actually very soon so very excited for eip4844 additionally in order to horizontally scale at least in the near term we need to do more and that is where the plasma protocol and alternative data availability providers come in plasma remember plasma group we're going back to Our Roots baby okay so plug in additional data availability for buttons with a plasma API how does that work okay well notably this is not just alt d a uh in like uh in the abstract this is a protocol for coordinating and basically allowing alternative data availability providers to plug into the same unified system so what do they do well we augment L1 data availability instead of taking the raw transaction data what do we do is instead of submitting that to ethereum we hash it and we commit to that raw transaction data and we submit the commitment to ethereum that allows us in the derivation process assuming the data is available to pull in all of this information and validate it against the ethereum total ordering of exact and that also allows us to plug in multiple different data availability all setting their own commitments in a standard format and process that means that we've gone all of these we've horizontally scaled data availability which means that we've got infinite chains which can meet infinite data very exciting so this is how you get you know close enough to Infinity obviously it's easier said than done but importantly the data availability provider may break and this is what makes it a plasma I suppose so the data it's the data that was committed to on ethereum becomes available what do we do well we can do a data availability challenge notably these are subjective they cannot be penalized directly on ethereum ethereum doesn't know who's right or if the data available is available or not it's off chain data but users can submit this data availability Challenge and then withdraw from the chain so how does it how does it work well give me the data and tells ethereum to give me the data now either one of two things either the data is revealed aka the data availability availability provider or the commitment is deleted from ethereum and is therefore ignored from the total ordering of transactions that is directly available on L1 so and that is all all done in this derivation process that we talked about before um it is not any different and so this also by the way just doesn't know that means that if you if we build out the right obstructions then the proofs that are that work for that work for Roll-Ups roll-up chains also work for plasma chains now notably plasma chains are fundamentally less secure than Roll-Ups there is no way to get the same level of security uh for your data as posting it directly to ethereum but it does mean that even if the date availability provider is you know goes offline you don't lose safety you won't lose you'll lose access to the data for a short period of time but you can always get that data with a date availability challenge so not too bad um great so these are the two things right roll up all data on L1 secure and expensive plasm commitments to data on less secure but nearly free very exciting infinite chains chain messaging synchronization into new data that is how we create the super chain let's go alrighty oh no it's congestion what are we gonna do pow knock them out we're done we are in that world we believe in that we know we can create the decentralized world and it was created because of folks like you contributing to the op stackers folks like me we're all doing it together it's one happy party of Open Source software notably this is all not actually here yet however we're still building it right we're still building it we know that the concepts this is what I just talked about is a culmination of an enormous enormous amount of research that has been done in the ethereum and elsewhere communities finally ready to be implemented in open source license software for the community for the world public goods forever so to infinity and beyond right we are so close we can see that incredible future ahead of us we are getting there we will then we it will get there with all that public goods funding generating Revenue with this open source software that goes back to the contributors that built it very exciting together we can build the open source internet and realize ethers Phoenix impact equals profit the earlier you start building public goods the more profitable uh the shall be because some more impact because we are currently in a state of honestly a little bit of Crisis not to scare you but we're very unclear if decentralization on the Internet is going to win hopefully it does for everyone's sake because we're humans and we want the internet to be human first so that's how we create the super chain which burns the collective come contribute welcome to the collective because you're already in did I tell you anyway stay optimistic thank you whatever I actually didn't get the questions I'm sorry we actually am a couple minutes uh so uh anybody in the audience wants to ask any questions feel free to send them in the chat and we'll relay them here we do have one question right now which is kind of from we just talked about uh in the last couple slides the question is around the incentives for actors to challenge uh if the data is available and then kind of how do you think well the economics of all that hey okay great so basically the problem is that this is the fisherman's dilemma so if you want to look up the problems with this we don't do data availability stages for oh there's a really nice property on L2 with data availability providers so the who pays who pays for the data that question well it is the person who wants the data pays for the data itself because we can't figure out if the person who is asking for the data is asking for it because it is genuinely not available or just because they're trolling the data availability so there's an interesting catch though it might not be attributable but it is subjectively attributable on L2 for the person who's submitting the challenge so I know it's like just griefing the data availability we need to protect against that the person who submits pays the bond but if I am a user of a data availability provider and they go Rogue I submit the challenge and I get off of that data availability or in migration so that is actually how who can remain secure and also you know kind of get around the trickiness of the fisherman's dilemma again this doesn't negate the need for Roll-Ups Roll-Ups have this incredible Unstoppable property that Plaza's just fundamentally cannot because of the petition against the level awesome um hopefully Laura your question got answered uh if uh just any follows sort of put that in chat we'll relay that to Carl but that was an amazing Talk Carl thank you so much for that amazing 201 primer and sure and uh looking forward to seeing more on the super Channel sick all right thank you 