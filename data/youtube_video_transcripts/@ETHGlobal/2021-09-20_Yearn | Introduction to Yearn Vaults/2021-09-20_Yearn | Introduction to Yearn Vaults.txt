hey guys from your finance here i'm going to give the workshop i will do during votes today i hope you enjoy it let's go to the presentation now let's talk about how to build on top of yarn vaults gearbox are simple token containers it's like a transparent box where you deposit your tokens and then those tokens are taken by investment strategies they're going to do all the heavy list lifting from the world the cool thing is that we don't have to worry about the complexity of the protocols we only have to worry about how to interact with the volt so the vault is kind of like the front end like the smart contract front-end for all those investment strategies so the vault is written in viper because we didn't have the all the mathematical functions that we needed in solidity so back then we decided to do it in paper don't worry it's like using any other smart contract on chain it's just the same you can use solidity anyways and the the vault tokens are erc20 so that's super standard we all know it you can transfer vault tokens to a friend to a colleague or whatever you can swap the world tokens for other tokens you can use them as collateral in other particles that accept vault tokens as collateral that's a cool thing because it's an investment that your that has utility and do everything else you do with tokens like take getting the balance of it etc the vaults are going to keep the accounting that is to say they are going to have the amount using balance off and also the price per share the price per share is the value that will be used to adjust the amount of yv tokens to know how much underlying you have the underlying tokens is the token you deposit another cool thing that we are we are super super super can it's it's immutable code so it cannot be changed or at least most of it can't be changed and the parts that can be changed are managed by your governance that is to say wifi holders and able to seek for execution also the volts are going to be able to handle multiple strategies so that's abstracting difficulty to us and keepers keepers it's another value function but those those little bots allows us to sleep well at night they automate the the that strategies handling like the safe reach ratio when it's a collateralized position and also handling the harvest harvest is what we use to collect the rewards and invest the money so let's talk about interactions we know that the only important thing is to interact with both first thing important how to deposit super easy it's just calling the deposit function so on the right you will see a flow the user calls the deposit function the user sends the tokens and is going to receive yd tokens so if you deposit die you're going to receive yv die that's your receipt you got to call it somewhere then those funds are going to set to default until the harvest function is called and those tokens will go to strategy any strategy many strategies that depends how it's uh set up at that at that moment in time we're not going to go to dpt into that right now then the withdrawal functions the the withdrawal well it's similar uh the user will will call the withdrawal function and it's going to burn those yv tokens we talked about why we die for example so then the wall has to search where do i get those tokens from those die so it's it's going to search in what we call the withdrawal queue that it's a queue with all the strategies that the vote is managing when the vault finds the the one it's going to call withdrawal it's going to get the tokens and send the tokens to the user this is not a complete one it's it's a high level one because sometimes the volt is going to have tokens uninvested sits in there because the harvest function for example has not been called so the withdrawal is not going to be a deep withdrawal that is how we call it when it goes to the strategy to to get the funds but it's going to be a cheap withdrawal because it doesn't have to go to a strategy to withdraw the phone now what's what's the withdrawal queue the withdrawal key is super important because it's the order in which the the strategies are called to withdraw funds in case of a strategy is depleted or the buffer sitting in the vault is depleted okay so so this is the order we do we do it have a sense so we order them in from the cheaper to the most expensive in gas cost because we want users to withdraw as cheap as possible and also if for example some protocol has some withdrawal fee or or something and for that reason we wanted to be the last one we just put it at the last place but let's say that you want to withdraw no matter what yeah i know no one wants to lose money but we need max loss because for us it's super important that our users are always able to withdraw no matter what if you want to you withdraw and lose 50 okay put 50 in max loss and you're going to be able to withdraw this only happens when the strat the vote has to do a deep withdrawal so it has to reach the strategy and withdraw the funds what what you have to take into account is that if a strategy has a loss that is not being accounted to the vault when you withdraw you are going to get hit with all the laws it's not socialized so that's something to take into account when withdrawing now the price per share super important view function super important because when you're going to deposit or withdraw this is the right ratio we're going to use to convert underline in in our example die to vote tokens why we die so for example when the volt is deployed and the price per share is one you deposit a hundred die and you're going to get a hundred yves i after some some time and with yield accruing uh let's say that that price percentage is two and you deposit 100 die you're going to receive 50 why we die that is that doesn't mean that you have less money or you lost money because those why we die you gotta multiply it for the price per share in this case two so it's 50 times two it's going to be 100 that's the underlying amount of tokens that you have invested another another great thing we we don't want to eat sandwiches no nobody wants to be sandwiched mev is super popular right now so we implemented what we call profit lock so when we have profit we're going to lock it for six hours and release it little by little linearly so although profit is not going to hit all at once you are see uh you will see a slow increase in the price per share we don't have only one volt we have many volts and we we started uh with the volts v2 we we saw that we needed to migrate from one version to another because we found uh above because we found an optimization because we needed to implement a new feature to make things better cheaper everything so that's why we have the registry it's just a smart contract that we use to keep rep record of the deployed vaults so when a new version is released we're going to call new release that is going to deploy a new vault and it's going to have a new release a new release version then the new experimental vault is what we use to deploy bolts that are not production ready yet so strategists use this to deploy volts and test on a tax for example then when the vault is ready test it battle test it ah governance can call endorse vault and that what is going to show on the main website uh new vault it's the same one it's the same thing as experimental but it can use it can be used to to create a new production board the difference between the two of them is that new experimental vault is permissionless anyone can call it new vault is can only be called by governance because that is going to show the users that the vault has been tested and latest vote it's an important thing because it's what allows us to know which one is the latest ball the latest version of the vault first for for a token for a particular token so if you bought latest vote die it's going to give us the address of the latest vote that we deployed for the die token of course for always production votes now yeah all this thing is good theory is good but let's do some integration work okay let's go what what how come we need integrate okay we have the router and the wrapper the router is going to send the user vanilla tokens that is to say yv tokens you're in tokens it's super simple it's non-custodial that is to say it's not going to you hold funds user funds and users will be able to withdraw using your website or earn smart contracts i don't know that's a good thing a bad thing that depends on the use case the wrapper it's similar to it but the user will receive a custom token so they can receive the yv token for example or whatever i want to call it you can you can you can program more custom logic because this contract is going to hold funds that's how it's able to to mint new custom tokens but it also it also is going to help you with migrations and it's going to automate some registry use usage so let's take a look at the flow here the router you see the user again calls the deposit function this time it's going to use the integrator router if the contract that sits in the middle between the vault and the user it's going to send the tokens to the integrator and then the integrator is going to call the deposit function of the vote but it's going to use the third parameter that is called the recipient that is going to tell the vote that you're the positive for a friend in this case for a user so the the integrated contract is going to send the tokens and the vault contract is going to send the yv tokens directly to the user then the user will be allowed as you can see in the flow to withdraw using the yearn smart contract or your website okay that's the main difference not calling tokens and being able to withdraw from yarn so now let's let's go to the wrapper this is our overflow you can see it uh and the main difference is it it's going to hold funds so the user is going to call a custom function that you can call it whatever you want it's going to send the tokens to the integrator contract that now is using the wrapper that contract is going to call the deposit function to the vault to deposit the tokens but this time the rapper the integrator contract is going to receive the yb tokens and then it go it's going to do whatever it wants with those tokens and then send the user the integrator yb tokens so it's a different token that user is not going to be able to withdraw from the yarn from a yarn vault yeah okay so those tokens those yb tokens those funds are held inside the wrapper contract that the integrator is using so when the user wants to withdraw into step eight is going to have to call the withdrawal function again you can call it whatever you want of the integrated contract which is going to have to call the withdrawal function on the vault receive tokens and send the tokens to users you can have custom logic all over the place like the withdrawal function maybe doesn't help to go to the vault all the time it can have a buffer in the ring the wrapper or whatever you want so this is more flexible but it's also more risky because you're going to hold funds so what are the wrapper and the router doing to help you with automation first they're using the best vault function the best wall function the code you can see it on the right is really cool because it's going to return the the latest volt the latest version of the vault for a certain token nice thing about this uh you can override it um maybe the best the best vault for you is not the latest version but the one that is performing the better or the one i don't know whatever whatever condition it's best for you you can change it but for us this is this is what we use the latest version of the vault so uh when you see withdrawal the withdrawal function from either the router or the wrapper it's going to uh loop through the walls to to withdraw always from the older one so that's cool because you don't have to migrate for example you have both versions 0.2.0 0.3 and 0.4 so when you withdraw it's going to withdraw first from the 0.2 version so there's no need to migrate users are going to migrate little by little little all by themselves without knowing and and you are abstracting all that custom logic from them and that's great same thing from the for the deposit function the users always call the same contract the same deposit function and they're going to deposit to the latest version even if they have tokens from other versions of of other worlds so that's a great thing also you're you're you're always helping users you're always obstructing difficulty from users and that's that's amazing for us the latest one and this one only we've only implemented it for the wrapper because the wrapper is the one holding funds so the if you want to migrate to force funds migration uh we all we have implemented the migrate function this is going to withdraw from older versions and deposit to new york ones this is good because uh at some point in time or very old bold versions are going to be deprecated and we're not going to be harvesting them anymore so the fans are going to be sitting there so it's cheap to withdraw and you can migrate all the funds this is only possible right now with the wrapper because it is the contract uh holding funds the router is not holding funds so you you could need a lot of approvals but you can do it if you want of course you're now the technical expert and that's great but sometimes you can need ideas so we are here to help you we created what we call a pool of ideas the pool of ideas is just a webpage when we where we allow community to submit their their ideas and say they are looking for a team so if you don't have ideas and you have a team go there pick an idea contact the person and let's build the future finance together you can always always reach us on discord we're on the oh youth online discord and we're willing to answer all the questions thanks a lot for watching bye 