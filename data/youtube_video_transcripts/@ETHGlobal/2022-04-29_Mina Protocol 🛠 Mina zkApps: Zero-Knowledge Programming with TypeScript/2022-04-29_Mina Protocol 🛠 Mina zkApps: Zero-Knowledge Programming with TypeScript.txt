[Music] [Applause] [Music] great thanks for joining us we're really excited to tell you about mina zk apps built on the mena protocol which is a layer one blockchain focused on zero knowledge with zk app smart contracts and a zk bridge to interact with ethereum and other blockchains today we have a few presenters myself i work at owen labs i'm a pm for zk apps we have evan shapiro the ceo of mina foundation who will talk about the zk bridge and then we have brandon case an architect engineer at owen labs he's going to talk about snarky.js walk through a hello world and give some more info to help people get going okay let's talk about architecture as mentioned mina is a later one blockchain our mainnet was launched march 2021 the big difference with mina is whereas other blockchains are large and increasing in size as new blocks are mined for instance bitcoin is 402 gigabytes in size and ethereum is over one terabyte mina remains a fixed 22 kilobytes in size all you need is this one zero knowledge proof to verify the entire history of the chain we call this a succinct blockchain using recursive zk snarks the current state of the blockchain can be compressed into a single zk snark letting anyone instantly sync the blockchain with the security of a full node an enormous amount of research has gone into zika snarks lately both inside our company and across the industry and our cryptography team at owen labs has created zk snark we call kimchi which is setupless efficient and extensible and it's based on plog 15. and you might be wondering if we have a 22 kilobyte blockchain how do black explorers query this historic transaction data we have a type of node as one one of the many nodes in our network called an archive node but and black explorers can query the historic data through that but you don't need any of that data to verify the the actual chain and the in the consensus of it and so with mena based on zk snarks we had an opportunity to re-envision the design of a smart contracting platform so let's talk about how zk apps work as a point of reference let's look at ethereum dapps so at ethereum student i'm sure most people are familiar with this on ethereum smart contracts execute on chain users send a transaction specifying a method and and data arguments and every node across the network executes these same instructions it solves a real problem but it's very inefficient in contrast minazik apps use a different model we have off chain execution and the smart contract runs in a web browser using wasm a user will execute one of the methods on the smart contracts and private data that that a user inputs into a method uh will end up the smart contract will generate a zero knowledge proof which gets sent to the blockchain along with a list of state updates if that blockchain is proven to be correct for that particular zcap account so this gives us a few advantages we achieve blockchain scalability through succinctness we have that 22 kilobyte proof to that proves consensus so that source of truth always remains very small which of course is the key aspect of a blockchain we also get user privacy through zero knowledge because the smart contracts are running off chain in a user's web browser any data that the developer wants to keep private they can they can specify private data arguments that will be input into the smart contracts that the blockchain will never see and then we also have the opportunity to have unlimited option execution so zero knowledge proofs have a unique characteristic where no matter how large your computation is whether it's it's very quick or very long it doesn't matter because that zero knowledge proof that results from running that function will always be quick to verify so we send that zero knowledge proof to the chain and the chain can always verify that very quickly so how does this work a zq app consists of two things so just as a matter of terminology we use the term zk app to talk about you the ui the user interface and a smart contract and the smart contracts is written with snarky.js so brandon in his portion about snarky jazz that's what he's going to help people get started get started with so how does this work when a developer writes a smart contract and they run their their build in their application it generates approval function and a verification key the prover function runs locally and generates a zero knowledge proof so this is what's going to run in the user's web browser when they're interacting with the ck app and then it also generates a verification key that they deploy to the network so if you're a developer and you update your application logic you will build again and generate a new verification key that you deploy to the blockchain and then you have a new deployment so any transactions will then have to pass the verification key whatever at that point in time so again the point of verification to the the chain creates what we call a zcap account this is exactly identical to a mina account however when the verification key exists on it we call this a zk app account and transactions will they have to be valid as mentioned for the the verification function and they will only be accepted by the network if they are in fact appropriate for that zcap account and that's how we can ensure that even with off chain execution that we know that that that zero knowledge proof that the user has run the expected computation and if they haven't the the transaction will simply be rejected by the by the network okay so in a little more detail let's talk about how a smart contract works a smart contract keep in mind we're running in the user's web browser accepts a few different things we have method arguments which can be private data and then we also have some smart contract states which is public data that lives on the blockchain [Music] and this generates a couple outputs so updates to the the state of the smart contract that public state that lives on chain um and updates to the state of the world so maybe you uh sent mina and you changed somebody else's balance um and one really important thing to mention is we have what are called preconditions so if as a developer if you want an action to only occur such as sending funds from account a to account b after a certain block height you can specify certain preconditions and you can specify those based on either the uh something that's account state related or net network really related even that way too okay and smart contracts the really cool thing about smart contracts on mina protocol is the written type scripts so you have the opportunity to use vs code npm prettier a whole bunch of technology that you're already familiar with and you can download if you want to get started today you can download our zcap cli so for brandon's presentation just keep in mind that if you can run two commands and have a project set up and and be ready to go with your with uh your projects uh and i want to pass to evan to talk about the bridge awesome thank you so yeah i'm going to talk about um a part of mina a really cool component called the zk bridge so this is is this question of okay we have this cool zcap functionality how can we make this useful and available on all these other platforms because we have very efficient zero knowledge proofs maybe there's some way we can get that to other chains which seems like it would be a pretty cool thing and valuable to everyone else on those other platforms so the answer to this we have is this dk bridge which like leverages mina's succinctness for a cryptographically secure bridge to ethereum and other chains the the idea here is that so we have for mina this recursive zero knowledge proof that updates every single block and says the current you know merkel route of the amino ledger the current state of the muna ledger is correct and has valid consensus information backing it since the beginning of time and you can check that zero knowledge proof and know that you're looking at the correct state of mina and what's cool is this is lightweight enough that we can run that itself inside of an evm contract so that's as if we have a full node of mina in a sense running inside of a smart contract and what's cool then is that anybody can then update that smart contract because the smart contract itself can run mina's consensus and like you know strongest chain rule so it's like this decentralized way of having a contract that contains the strongest state of mina at any time and then what's cool is that with one bridge update so one like verification of a recursive zero knowledge proof you can move over all the state that has changed on mena since the last time you updated the recursive zero knowledge proof on ethereum so if that made sense great if not we're going to run through an example so you'll see how it works in detail the example we're going to go with is let's say we wanted like a private proof of attendance so this is like you know i think there is actually group of tenants brokers this is like a private version of that um and we want to make that work between mina and ethereum so the way this can work is first what happens is a developer is going to write this program called was at ethereum that runs on mina and a user can create a new xero zika app account amina with the verification key for the app the developer wrote great so far and the data field on this is you know all zeros because we haven't filled it in yet but we'll fill it in in a second next that happens is user submits a zero knowledge proof that says okay like in this example i have an identity that identity's been verified by a third party like i went to like the dmv website and like looked at that page and it was good as well as an actual um valid amsterdam pass and they matched and then what i can do is i can make zero knowledge proof of that and submit it to mina and then that allows me to update the data fields on mina and the ck app in this example to my ethereum public key so note that if i didn't have a valid zero knowledge proof that contained this private information about my attendance i would not be able to update this zk app with that public key and it would just be all zero still but because i was i was able to add my ethereum public key into the mina account great so what's next is that we have to get that meanest data count on to ethereum itself and for that we're going to look at what i've called here like the meena bridge account on ethereum which contains as its data not not the whole tree actually but just the merkle root of the tree for mina's ledger and then an operator someone who is wants to update that account in a decentralized way can send over that merkel route and consensus information back to ethereum and if the consensus information in that new proof is actually stronger than the proof that was already on ethereum it updates to that latest latest proof and latest merkel route so after this our micro group that happens to contain the zk app which happens to contain my ethereum address is now on ethereum great so after that we can so this example it's like a dao for people that happen to attend here what we can do is someone can attempt to register and the registration process includes a merkle path from the meena merkel route in the ethereum smart contract down to that account that contains that ethereum public key and the user can prove that that was included that that corresponded to like the verification key that actually corresponded to the zk app that was written and that um they actually have the private key that can make signatures which correspond to that public key so in any so in any case so with this they can register themselves into a dow using a zk um proof that they have the rights to do that so i i hope i didn't go to that too quickly but that's basically the flow that one can imagine for how you can write something on mina that takes advantage of zero knowledge proofs and then from ethereum or other chains you can then access that as part of your application so there's a bunch of possibilities one could imagine with this you could build a private dao if you wanted to you could pull real real data into like bootstrap more defy things you could build nfts that have some cool zk properties one in particular i think would be cool is like a collection where each person can own at most one nft so like if you have a bunch of capital you're still limited in how much you can take from the collection um you can put like anonymized proof of on-chain information for ethereum or other chains uh you could build zk-powered games like battleship is like a good one without some privacy element i think another thing that potentially will be cool well at least interesting is uh making it possible to actually move private enterprise data onto public chains for that interoperability without losing the privacy aspect for those as well as one thing i think is also very cool it's very easy to spin up as you can roll up in this framework because the cryptography is done you just kind of have to like write the recursive step for your zk roll up and then do that off chain and then submit a big proof back to you know but that's that's all i have for this part um thanks y'all hand it up to brandon [Applause] hello cool okay i'm gonna talk about snarky js so um snarky js is a a toolkit sdk that lets you build zk apps and you use typescript and so because it's typescript as jason mentioned we can use open technologies uh the the actual execution happens in the browser or node.js typical runtime environment you can use existing javascript and typescript libraries and tools that means you know you can also use like vs code and you get the all the benefits that you get from vs code all the id support of just javascript and typescript that thousands or millions of person hours have been poured into you get to use that so cool snarky.js um i know like maybe some of this stuff seems really scary um after uh you know we saw the details of the architecture and and the bridge example but the code is really not scary um i will prove it so uh in a moment um first so uh i want to talk about like the base sort of unit of um data in zero knowledge programming field element so a field element it can store a number that's almost 256 bits in size for the field that mina uses you can think of it like a un-256 in solidity but it's just slightly smaller um for those that are like zk like crazy uh people um the the the field in um like the field type in snarky js this is the base field of the pious curve and the scalar field of the vesta curve in in mina's uh pasta curve system unless someone on my team corrects me and i got those mixed up but um so but if you don't know what i just said it really doesn't matter um just think of it like a 256 256-bit unsigned integer um so yeah so so uh in typical programming of typescript like you might sum two numbers by you know creating a local variable uh and then writing the integer literal one the symbol plus and then an integer literal three i guess i don't know a numeric literal i don't know what you call them in javascript but um those are javascript numbers in typescript we can't override like numeric literals so we have a little bit of like wrapper glue um to to sort of tell the snarky js engine that we're using field elements um so this is how you would add you know one and three and this is a little cumbersome so there's some syntactic sugar anywhere that you that like it's unambiguous what you mean um the the methods accept like a numeric literal a string literal that corresponds to a number or um you know another field element so uh you know it's just like a little bit slightly more you know characters than one plus three um cool so there's other built-in types besides fields um here's a few of them uh so besides field bool is one and this is just a field that's constrained to b01 but it has a bunch of helpful methods on it for things that you might want to do with you know bools we have unsigned integers of sizes that are normal for machine like computational machines like this laptop and then public key private key signature that for for mina's system we have a schnorr signature and then some other cryptography things group scalers the scalar is the you know other fields in the recursive pasta system again it doesn't matter if you don't know what i'm talking about um they uh all of these have built-in methods on them and because it's typescript and in and because we have vs code and other ids like that you can just you know import one of these things create an instance of it and then write like you know your variable name dot and then complete will just help you explore the sdk you can just write functions so in typescript you know you write a function like this you can give your parameters types and you can return a type and here we are adding 1 to x and then doubling it or multiplying it by 2. just like in typescript i mean it is typescript but just to really show you we can take a part of that expression and assign it to a local variable um so it's just it's really normal programming i'm harping on this because if you attempt to program using any other zero knowledge proof framework uh you will miss um you know normal programming i think um so uh let's go through a simple hello world okay um a hello world smart contract so um we're gonna write a smart contract that has a single like piece of state a field element that we call x and we're gonna constrain the uh well we're gonna have one method called update and we're going to only allow update to replace x with its square so just to give you like a sense of what i'm talking about if we start at three the only update that's valid is nine and and if we're at nine the only update that's valid is 81. um so if we start with you know three update it to nine and then we try and update it to 75 the actually the proof won't even be created but if you try and like send something you know messy or if you try and spoof the chain it'll also reject your transaction um cool so let's write it uh first we extend smart contracts um you just write a class extend smart contract we make the state by adding a member variable with some decorator stuff and this this line of code's a bit confusing i suppose but it's doing so much for you that uh it's it's amazing um so so uh what what this says is um x is a piece of state that lives on chain and its type is field and and you can actually use any type that's built out of field elements here um which i'm not going to show in this slide deck but you can see in our you know examples um and yeah and this is public and on chain uh so we're gonna say what happens when we deploy okay so uh i mean you know by default there's some things that happen but we wanna override the default um by setting it to three so we call super.deploy with the input and we set x to three okay so now the actual update method um so so uh let's just speak about methods i guess um smart contracts have multiple methods or they can this one only has one um and and these are the uh like things that you can do to a smart contract so this is like the functions you can invoke on it and and jason was mentioning this but i'll say it again with with the code the the state the the member variable there that's public that's on chain anything you store there is publicly readable you know if you store a hash then only the hash is publicly readable but it's public um the arguments to the methods are private and they are only you know they're only visible on the user's machine and if you don't put them in some public state they will just remain private in this case we are putting it into public state so uh you can see that online the third line of that method um so uh so yeah so the other thing that's happening here is um on the first line of the method we're calling this.x.get which fetches the current state of the zk app from the chain and there's some magic that happens that gregor can tell you later uh where like this isn't actually asynchronous because we sort of get it before this runs um so uh but the point is uh i mean there were a couple reasons we did that but a nice benefit is you don't have to even worry about like async await you can just write normal plain sequential programs um so so that gets the state um and and then the uh and then and then we we do this thing on the on the second line where we uh add an assert um we assert that the square of x is equal to the thing that we passed in um and and this isn't just something that uh i guess typically when you have assertions you put them in there for sort of your your sanity as a developer but this is actually something that is uh sort of part of our smart contract um and and the the thing that actually happens when we run this uh again this is like jason talked about this in the abstract i'm going to talk about it in the concrete um what we do when this executes is we we produce a transaction that um that says it has a proof in it that says we ran the code in this update method with some private arguments um and and the result of that were the following instructions that get sent to the chain uh in this case set x to be nine that's that's the instruction and it assumes a precondition that x is three so so that gets baked in to the the smart contract if if the transaction is sent when the state is not three then this will fail which is what we want um because we only want to update it to its square okay um so so this is kind of what smart contracts look like i mean this is a very simple one but um there's there's uh member variables which uh you can use for state public state you can override the deploy method and you can add methods with this at method decorator that correspond to the uh specific you know updates that you want to perform on the well to the network i guess um cool so now to test this there's i guess a lot of things you can do the thing that we recommend that you do for this hackathon because it is the most uh easy to use at the moment is testing locally so uh so we have so here here's an example um uh so so what we're doing here at the top we're grabbing an instance of this local blockchain you can kind of think of this like a sandbox vm literally it's like part of mina that's compiled to javascript so it's it is um you know accurate accurately emulating the real blockchain um and uh and then and then we uh we send a transaction i'm using account one is the the the one who pays the fees for the transaction so you have a private key there um and then uh and then and then in there we're only deploying the smart contract in this example and then sending um that's that dot send at the end so uh and then you know we can also at the top here we can send an update uh we can update it to nine and then and then afterwards we can we can get account states um and then you know print them out or uh you know check them against something else in like jest and adjust test if you're a web programmer you'll know what that means um or you could just put that in another executable for your testing purposes um yeah so uh i also want to just show evan touched on this but um roll ups here's a roll up and it's like 10 lines it's probably like going to be 50 lines if you actually get you know unwind the dots but like it's 50 lines a zk roll up um this this api we have not fully wired in but i just you know thought it would be really cool to show so um you know at proof system um you extend proof to to make a custom proof that's not uh you know like this proof isn't actually on chain uh we like create the proof and then send the proof uh through our smart contract on chain so we extend something different and then uh the you know maybe you're like you deposit money into the roll up you can like send transactions between accounts within this roll-up environment and then you can merge proofs together um so uh yeah this is pretty cool uh the one thing i also want to just touch on this um for people who have tried to use recursive zero-knowledge proof programming before um it's probably not a large number of people but if if this is one of you um you you uh you have to flip between like the two different fields um every time you recurse and this is actually like really complicated uh and annoying to to write code for um and uh the pickles recursion execution engine in mina um like double flips for you so uh all this means is like you really only have to think in one field which is really uh something that makes your life easier so that's that um how do you learn more um well you can go to these places um so the docs the discord you should also look for people with these hoodies um most of which are members of either the mena foundation or of one labs and we can help you uh you know understand things um oh and the other thing i want to mention um we are like in real time um getting like we have uh we have successfully deployed zk app transaction like zcap smart contracts to a live test network and interacted with them in a live network environment in in constrained conditions and we are actively at this second working on making those constrained conditions less constrained so if you are at a point in your hackathon project where you are like i'm done i'm tested it's great and i want to hook this up to a live network then you should look for well look for people in these hoodies and we'll point you to the person in the hoodie that you should talk to uh and uh yeah so that's that um do we have time for questions i think [Applause] um yeah do do we want do we want to mic the question talk really answerers i'll i'll repeat your question okay so given the like constrained size of the of the chain like how do you infer the state of like any particular contract at a given time yeah so the question was given given the constrained size of the chain how do we uh how do we get the state of um anything that we care about uh okay so um there's like a lot of nuance and a lot of different answers so i will answer the question that i think that you're asking um which is and you tell me if i if i'm answering the wrong question um so so this 22 kilobyte number um actually on our home page there's like a a superscript and you can click on it and it's a blog post that i contributed to that explains in detail exactly what we mean by these 20 22 kilobytes if you read those details um you'll see there's a proof that's like one kilobyte-ish and then there's like a bit of metadata and a merkle path to an account that you care about um and uh and if you so so how do you uh how do you get the state that you care about you ask a node that has some state and i just want to highlight the nodes that are participating in consensus and mining blocks they have the current state of the world you need that to produce blocks you do not need that to be like a full node in the security sense but you need that to produce blocks so there are a lot of nodes in the network that have the current state of all the accounts um there is no node in the that's needed for consensus that has ancient archive state as jason was saying there are some that do because sometimes people want it but it's not needed for consensus but it is needed for consensus to produce blocks to have that state so sorry this is a long-winded answer um but you just go and ask those nodes for the state in the same way that like you go and ask an arbitrary ethereum node for like your account and it gives it to you um it's the same thing do you think there's any limitations with um doing those proofs because i've seen this there's a verification key as well i guess also there's constraints that need to be met for the proof when it comes in as well as it goes into it do you think if i had like a really big program that i was running do you think that maybe i might be you know yeah yeah the question was um are there constraints on like how big the program is given that there's this fixed verification key um and the uh naively the answer is yes there is a fixed maximum size that your computation can be per verification key and this is true however because we have recursion we can just recurse and loop a bunch of times and do very complex things that don't fit without recursion in to one proof um i guess i'm realizing that might not make sense to people but it is true so that's the answer uh algorithm that like doesn't require a setup for each and every new server yes very good question and i wish that we had mentioned it in the talk i'll mention it now um the mina zk snark does not have a trusted setup it is a it is a false god that i don't know i don't know what the term is uh it is untrue that like snarks imply trusted setups some people have this meme it's not a real thing our snark does not have a trusted setup um and therefore uh and it's universal um and you know someone one of our cryptographers can correct me if i say this wrong but uh that means that we can um basically change what the circuit is at runtime and change and in mina's case we can recurse arbitrary new circuits into the main vena circuit uh so all this means like when you are writing a zk zk app when you're writing a smart contract um you can deploy an arbitrary new circuit and it gets folded into mina and there's no trusted setup there's no setup but is there no trust so there is full trust and no or sorry you trust no one uh because um the cryptography works without trusting a setup i mean you've said that your setup is not trust like did you have like a ceremony and uh no mina did not have a ceremony because mina's snark does not require a ceremony yeah it's more so in his sight it is it is safe and the cryptography is even safer than i think i think ceremonies aren't that like untrustworthy personally but but mina didn't have any ceremony and so it's even more safe than if you did so yes it's safe good cryptography i mean it's newer cryptography so some sometimes that scares people but we have very smart researchers and research papers and audits and and uh you know people reviewing stuff so i think it's fine okay um i guess that relates to some mechanisms yes yeah so actually the recursive zero knowledge proof uh way that mena compresses the blockchain is sort of orthogonal to the consensus mechanism and actually an early test version of mina we implemented proof of proof of work because it was easier but we didn't want to release that so it's proof of stake because we chose that we wanted proof of stake and specifically the consensus mechanism is a variant of auroboros which is called auroboro samasika and you can look online and read about it there's a bunch of talks and papers and things oroboros was originally created by the iohk cardanofolks and mina tweaked some things to make it work in a succinct environment um yes how do you connect yes like an nft yeah so um uh yeah i think so one thing i'm really excited about is uh bringing mena proofs to ethereum through the bridge as non-transferable nfts um i think that's like an awesome cool thing that that like framework for building that has not been written it would be a really good hackathon project i'm i'm going to contribute to judging on one of the projects and if someone influenced that and it works like i will vote for that project i mean like uh yeah so um the answer is like uh you should build that i don't know um the the bridge the the zk bridge uh isn't deployed yet right so um uh so you can't actually run it yet on like on ethereum ethereum but you can still build the infrastructure so that right when the bridge is deployed we can do that sort of thing um so i hope that sort of answers your question did you repeat the question sorry the question was how do we how do we interact with erc 721 nfts uh in mena and i guess with mina i answered one one half of that which was how do you output them and then the other half is how do you input them uh and that is the that is also part of a bridge that doesn't yet uh fully exist um but also if you build part of that um it would be a good hackathon project and you can talk to if you have the if you feel like you have enough in your brain to understand how to build something like that um you know one of us in the hoodies can help you understand how to you know do that as a project another question so like if i do i understand correctly that the bridge um basically like you could use it to reduce fees from like um instead of proving instead of verifying the proof on chain on the ethereum chain you have to just verify the miracle path right so that's the the gas optimization that you could do right uh the i well you have to yes well someone is verifying the mean of proof on chain like whoever is updating the the bridge but yes once it's already there it's just a miracle look up okay right yes and that's um so he's supposed to like uh is the me now like uh are you supposed to update the the bridge on the like who runs the bridge um yeah um the uh there are a lot of entities that could uh run that uh like post those updates um the i bet evan has thoughts on the plans that will be decentralized and one can be an operator and if you want to help us test being an operator then you should also reach out i'll repeat on the microphone um the the plan is that uh well it's decentralized anyone can be an operator and we and mina foundation as represented by evan says that uh they want i'm part of one lab's separate company they want to help people be operators if you want to be one of those operators you should talk to someone in a hoodie and we'll help you learn about that the question is how does the fee system work um so yeah uh i think jason mentioned this but um because the all transactions in mina and actually even before zk apps this is how it works um they they all correspond to verifying a proof um they're all the same price so uh they're all the same price um i guess there's some nuance where there is a way to build zk apps such that like a single method um like a single method that you write in stock.js actually like compiles to several transactions and then you pay per like per extra transaction but it's a fixed gas cost per transaction and you know that means you can do some crazy computation which the user will pay for because when they're when they're using your application they'll perform that computation um but you don't pay for it with curious if gas have let's say that pending transaction and uh every one of the transaction wants to interact with one smart contract does it mean just one turn the transaction will go through and the nine are invalid because good question yeah if you if you build your state machine in such a way like this example where um there's like a sequential ordering of updates that needs to happen um then if then there's a race and whoever gets their first wins and the rest are invalid but you can design your state machine um and there are a lot of ways to do this um uh in zk apps and like conceptually um you you can design your state machine such that updates can be reordered and and that is what you should do if you want that property but it means that you have to think a little bit harder about how you design your smart contract please um so that's a really good great question because with the option execution model and off chain storage which is in progress as far as making it elegant there are a couple different approaches to that also the preconditions we mentioned the network preconditions and account preconditions i believe that we can work on that to create very elegant preconditions that might be tailored to a specific app that could really really help address that and then what else when we have roll-ups as well and actually one of our our ckf builders in our recent program has started a roll-up that would have another opportunity to provide sequencing as well for a particular app and use case cool any more questions uh oh go ahead i think we need to store more complex data on off chain because this is not that uh yeah so the question was um sometimes we need to store things off chain because uh because they're they might be more complex um i should just mention because we didn't mention this um in the current test net i guess this isn't set in stone um we're thinking that each account has eight field elements worth of storage on chain which is a very small number so so yeah so a lot of times you'll have data that isn't on chain um and the question was what happens if that data gets lost um and the answer is uh your application won't work but mina will still work so so it's up it's it's up to your to you as an application developer um i guess sorry there's a couple answers to this the current answer is it's up to you as an application developer to solve this problem in the way that you think is important for your application so the easiest thing to do is just like have a file that has the state in it and you you can think of this as like a single sequencer and this is from my understanding how basically all the l2s work right now that people have a lot of capital on and people seem to be okay with that um you can do something that's more safe and decentralized by you know having like a tendermint chain that keeps track of the state um uh or you can have you know the merkle tree in like some i don't know some flash drive that you like hand to make a copy of and hand to your friend so you can do anything for it for the state and um uh the the well as a snarky js toolkit developer person architect whatever i'm called myself and jason and a bunch of other people we will be we will be working on ways to make you know to solve this problem in sort of more cookie cutter ways so it's easier for application developers to make that decision and they can just kind of take something off the shelf but right now it's a little bit more manual yeah hopefully that makes sense cool i think we're out of time actually so thank you remember you can just anyone wearing these colored hoodies um uh and and or these links um you can come and ask other questions or whatever and please build stuff there's prizes i think someone's going to announce that so yeah what's our prizes we have prizes okay [Music] [Applause] [Music] you 