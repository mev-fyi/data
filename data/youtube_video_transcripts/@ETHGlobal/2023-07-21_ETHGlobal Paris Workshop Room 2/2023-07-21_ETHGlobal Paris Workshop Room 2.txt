foreign [Music] foreign foreign Okay so hello hello [Music] can you hear me yeah so good morning everyone uh well with affirm Ashley welcome to East Global the first talk and yeah today we have some sweet things for you ideally I'll be talking about some of the things that developers fall in love when you embrace them when you discover them when you think okay how could I be doing this before right uh let's get started so we are in 1970 uh welcome to uh digital Equipment Corporation uh the computer they released was called PDP how did it work the entire system was basically on program right and if you needed to change something basically there was one program running the entire thing uh there needs to be one program for every architecture there was no way to add to remove it was basically something monolithic but then came operating systems so you have a trusted kernel that can basically do everything it likes and then you have untrusted programs that interact with the kernel to do things so that you can have many programs and you can basically forget about what's behind and how does this look like so at the Double half let's say the D is the network basically the things that um you know the hardware itself and then below you have different programs that might need to interact to these resources so for example if you want to use Spotify Spotify will talk to the kernel in a kind of standardized and abstracted way so that it can use the speaker so that it can use maybe the network on this display whatever right but fast forward into the future where are we let's say 50 years later in let's say 2017. yeah well I think we're the same place because back at the time every protocol that needed to be made had to be made from scratch because there was nothing to build an abstraction on top of right so basically well writing the entire protocol every single time there was no way to add and remove features there was no way to you know easily customize things but then these chains this started to change when argon in 2017 released Aragon OS the first version it was the first solution to a problem uh it was revolutionary revolutionary in many terms and still as of today it is unhacked it's very robust and it worked based on templates right as the different templates for ngos for cessations for profit companies and it was good for some of these use cases but at the same time it had some challenges for for it to be used in simpler use cases and some of the Lessons Learned is that there are not two equal communities two thous are going to always need different things and they are going to have different flows they're going to require something new to them at the same time the same Dao always evolves over time you can start today and you have no idea of what your community is going to look like in the future what you will need and you cannot I mean it's super hard to design for this ahead of time and another lesson being learned is that many times argones has been forked and has been implemented in you know for very big projects like Lido the central line and so on the thing is that this is not ideal because you need to fork and maintain a big code base right so if you can extend instead of forking and maintaining the whole thing that's a big bonus and for this this year in 2023 March this year we have released OSX which is basically a massive Leap Forward which consists of two components so we have a dial core and then we also have untrusted plugins or external addresses let's say contracts that can interact with the dial core doesn't it sound a bit familiar to you I think it should because basically we're talking about the same concept of an operating system which is there are some plugins some contracts some wallets that want to use the dial right they want the doubt to do something with shared resources pretty much like programs do in operating system so for example if a plugin wants the dial to transfer some die to another address there will have to be some governance proposal on the plugin but essentially the plugin will need to have permission to go to the down and then now internally has a permission database which is basically the Bible of everything that can happen within this community right but then we have been talking uh at least the title is about the Unix of ethereum let's get a bit into this what's the index philosophy if you're developers you're most certainly aware of some of the basic uh principles of it which is writing programs that can do one thing and do it well right the components building problems that can work together that they can talk to each other very easily that you can compose that you can combine and architect something bigger than just the program itself that needs to grow indefinitely and also flexibility if you build small pieces these small pieces should be able to work in many scenarios not just for one specific use case right that should be reusable by many other tools so again you can build more complex things and more interesting things this is a very simple Unix program all it does is just opening a file reading some data and right reading it back writing it back Etc the blue Dots here the blue functions here they are the absolute simplest things you can find you don't have a open file function you don't have a right buffer well no you have a generic function that works everywhere for every single kind of thing but on top of this this for example with programs like the one we had here imagine we compiled this we eventually have a layer on top in which we can start composing some of these programs some of these binaries that we made to make something more interesting more complex and marked out of the way how do we translate many of these terms let's say for ourselves for Argon OS X so in Unix everything is a file okay for us everything is a permission because eventually you want to execute something right there are system calls like read write exec etc for us there is doubt.execute asking the kernel to do something permissions for example change Mod change Group Change owner well we have granting and revoking permissions and then we have some of the basic utilities like LS copy Etc which are some of the plugins that we ship ourselves and some of the planes that anyone can do can be a multi-seek can be token boating Etc there are some additional getting principles that we have inherited not only from Unix let's say but some other languages like for example rust we like there to be only one correct way of doing things right we lack Clarity we like developers we want developers to be explicit about they do if this code is going to be audited it needs to be obvious what the code is doing we don't want any hidden magic behind the scenes at the same time we want people in general the community to only pay for the gas for features that they need and that they are using just no hidden bloat not just shipping 20 million things that you don't use but they are there right and it needs to be easy to understand and to reason about because after all it's all about security um so then let's start talking about plugins because our organize X is basically about a community is basically something valuable that needs to be protected by many people there needs to be many people behind for this to be secure and for this we need plugins what is the plugin basically the applying is our way to solve a small problem a small custom problem uh following the index fellows of his so make it simple and stop rementing the wheel basically reusing everything else that we as argon offer for free basically plug-in versioning upgradability so shipping new versions um allowing people to easily upgrade to the newest features that you ship maintaining data maintaining statuses using the permission management system which is one of the top most built of things about the initial versions of our organos also interact with all the plugins also combine different plugins together to achieve the custom signers that you now needs and more that we're going to see really soon so and the end call of these is supplementing the will because we want to ship fast because we don't want to you know be rewriting things that have been already soft in the past so how does a plugin look like so first of all the green box here is let's say the plugin that for example we would like to have a multi-secret okay but at the same time we're going to need what we call the plugin setup just above right what does this plugin setup do it's a contract the developer does which manages installations updates of the plugins and uninstalls it's basically a scripting in which you can do basically everything on top of that when you want to publish a plugin version you publish the plugin setup we have a registry and then in this plugin registry you can create your own repository you even get an ens if you want and then you keep publishing different builds if you choose your plugin to be upgradable people will be aware that there is a new version they can create a proposal and they can get the latest and greatest features that you just shipped to them even yourself and then on the other side there are all the goodies to just make all of this accessible to uis to any applications that you can think of so in the end what's the landscape that this leaves us let's say so as I said there are not two does that are exactly equal so most likely you could for example want to start with a down with maybe one of the sick plugin and then maybe eventually install another one maybe install a token voting one and maybe the feature maybe you want to do off-chain voting and you install a third one and you decide that you want to remove one of the other ones so you're basically decoupling let's say the shape of your dial the shape of your community from how the actual dial works so for example here at the top imagine that there are many operations that the Dow can can perform many functions these functions they have different rows Associated to them when you install a plugin you granted some permissions and depending on depending on the permissions of this plugin the address can perform these operations right but if tomorrow for example I decide to remove the multi thick plane let's say I am doing a clean uninstall and then I could install maybe another thing but that token voting that could do the exact same thing but with a different logic so you're basically setting yourself to be feature proof in terms of evolving operating without committing your doubt to B as it is today forever so let's see some code because my whole point on the presentation is to show you how easy it is to do a plugin so this is the absolute most simple plugin that you can get all you have to do is inheriting from plugin clonable for example or from plugin UPS upgradable you get for free all of the tooling you can just simply forget about the rest in this example we have a plugin what it's doing is preparing a list of actions and this list of actions eventually we connect to the dial to which this plan is linked let's say to which this plugin is listening to the permission database and we're asking Dada to execute these actions that's it that's the hello world that's a hello Tau let's say plugin that you can build um what if for example our plugin wants to start using some additional permissions for itself what if we want to restrict uh the plugin itself we don't want just anyone to go there we want some function to be guarded so first of all we will need to create here our own permission ID which is basically about 32. um computed by hashing some value and then below on the function that we want to guard we are going to add this modifier this is the basic building block then only the people who holds the permission in this case my plan permission ID under those database is going to be able to use this this is something free that you can grant you can remove you can evolve you can iterate you can have another plugin with a different logic you can have a different version of this plugin with uh maybe fixing a bug Etc so it gets really really really flexible for you to just evolve how does applying setup look like so there is the I plug and setup interface which is basically the method that your install script should Implement so this is a two-step process step number one you prepare the installation the update or the an installation of a plugin and then step number two the Dao has a proposal and eventually the community accepts and decides to apply the permissions that you have requested and essentially the plugin becomes installed updated whatever here you have some example of one of our own plugins so the music plugin what you have is a Constructor we do the initial deploy to have let's say the implementation on chain that we will then carbon copy we don't need to deploy every single time so we use proxies so in this example what we do is previous installation your function will receive some parameters that you're going to encode with the settings of this particular plugin and then you you can just simply copy this line that we provide you the tooling to just use it and then this creates a proxy with your specific plugin instance you get your very own plane and then the last step is requesting permissions this may seem about purpose but essentially what we're doing here is well we're building a list of permissions so we're saying please allow the dial to upgrade the plugin settings or please allow the Dow to upgrade the plugin itself and at the same time oh please Dao allow the new plugin to use to do execute or to do something right so you do your wish list of permissions and then the community assesses whether they like them or not and eventually if they approve them these three permissions here are going to you know make it to the dials permission database okay so what is a permission as we saw before basically it's a source of entropy a string hashed which is then a number and we use it to Shield functions and permissions they look like granting permission to who to do what on where so allow the dial to do this on the plugin but what if we want to we want things to be a bit more um let's say more granular what if we want some conditions to to be a bit more restricted right so you can use permission conditions which is nothing more than a contract that you can Define right so for example when you have something in trying to execute some operation you could tell that okay whenever someone wants to perform this action ask this contract and if this contract says yes you just continue right so they allow for us to basically decouple uh the fact of the features themselves with the restrictions and this prevents things like plugins going super complex because you need to combine a matrix of you know I want to do this but not that but yes but no it gets extremely complicated if you can decouple these two things again you can have very composable very modular things very very modular protocol without needing to remember will because most of the time some of these conditions will have been implemented by someone else right same as plug-in some of these plugins will have already been implemented by someone else and you can just pull them and get let's say their upgrades for free as well so in the end permissions for us would look like Grant permission to a certain contract to do certain a certain role on some Target optionally when a condition is met and with this you can just go and build the Moon so uh this is how simple a permission contract would look like the only thing it would be to implement is basically the is granted condition um it would receive the parameters of what is being attempted to do and eventually it needs to return yes or no in this case first parameter being greater than the second one so this is all I've got for you there's much more you can just find us uh Carlos and Juliet we will be here around um we have here a couple of um plug-in examples for you so one is an example of a plugin to understand how it works okay and the second more is second one is more of a project in which you get a plugin and you get also the all of the internet testing and some JavaScript client for it to connect on a UI and also some basic uh subgraph indexing in case you want your right to be more uh you know user friendly and all of this feel free to take pictures of this QR codes at the same time you can also go to devs.argon.org and you'll get all the whole documentation of the protocol and also you can join us on this course so we yeah some people from the community are very active also helping around and yeah the tldr for me this guy is basically the limit if you don't have to remain the will to build the next big thing and you can focus on customizing only what you need and recycling everything that there's around then basically you're ready to go build the absolute Next Big Thing so that's it pretty much um I'll be happy to ask many questions and expand any of the topics that you think foreign [Applause] [Music] thanks for the presentation I would have a question about the initial deployment of a Diago those the initial deployer or owner needs to write code as a smart contract to set up everything and to include plugins or is it just a call to an existing contract so you could decide to deploy yourself but most likely you want to use something that we call the Dow Factory so you call that a factory which is a contract that we deploy ourselves is there and then you pass it a list of the plugins that you want it to have right so by default the deployer if you happen to deploy yourself you would be kind of having total permission on it with the intent of installing a plugin and then dropping this permission and yeah I can give you more examples on that absolutely but yeah there's a contract that does everything for you can you please tell us what are you like most popular plugins for now which you created I mean your team and the water like custom plugins your clients and other that was created that are like very commonly used uh so we ship four standard ones which is the multiplying we also shipped another variant which is called the address list right which is a a version of it which is intended for everyone to vote whereas in a multi-seek you only expect some people to just say okay right in another list you have a at least an explicit list of addresses and they both and then you have the evolution of these which is token voting so you can vote for 10 years 20 token Etc it supports delegation and supports many things that you expect then there is another interesting plugin not interesting we call it internally the dictator plugin which is basically the admin plan which in which one address is able to do everything this is in cases that for example you need to experiment or you need to kick start the Dao right you could manually Grant permissions to yourself but the idea of having applying the benefit is that everything is encapsulated right you just add it as a whole and remove it as a whole so you could start us with this plugin then upgrade to multi-seek then upgrade to any of the other ones that you would say regarding what the community is doing I don't know maybe in Juliet Carlos can expand on this but the idea as of now depending which we are is people do their custom thing right it's not that they're just publishing plugins around this may well become let's say the next step but at this point is more like not needing I mean being able to recycle and just adding the extra plugin that this this very small thing that any of these system plugins could not possibly solve for you touch if this replies the question hi can you hear me yeah I guess I thank you for representation I'd like to ask uh if I'm gonna use the argono6 yeah will I be able to use the auto-generated client yes it is done on the Aragon app I'm sorry I have you to travel could you speak a bit louder yeah so I can close the door thank you yeah thank you so let's say I'm gonna use the argonio six yeah to create uh my Dao will I be able to use auto-generated client yeah as it is done on the Argon app so uh what we ship is uh the Argon SDK which basically provides all the tooling to um to interact with basically uh web ethereum ivfs and sub graph okay then on top we built abstraction layer so that you can interact with anything related to the dial in general but at the same time we also um oh sorry about that so the second example here you get an example of a JavaScript client that uses the SDK right to just um at the custom things that you need for your client right so the idea is that you get maybe 95 of the tooling is there and you can just right away start calling um you know web3 call this contract or ibfs fetch this data Etc so it's not appreciated because the custom bit that only you know well you need you know what do you want we can possibly know how you intend to use for example maybe you want to use the graph or maybe you want to use a backend and index something there or maybe I mean there's no general rule here and last question could I use uh SDK to work with already existing one that was that uh created from the client as well from the app you have for example HD data to get all of the dials as long as you can basically call the contracts as long as you from JavaScript you can simplify the information obviously yeah so again the message the SDK gives you um all of the building blocks for you to build on top we use it ourselves to build our own plugin clients right and you can just replicate this um just write the custom five percent think and forget about the rest because we did it [Applause] thank you [Music] okay foreign [Music] associated [Music] um adding videos [Music] foreign [Music] I just have sides no sound in here yeah foreign these lights are so bright it's fine it's fun thank you all right all good all right should we get sorry amazing hi everybody my name is Shea I'm from flashbots and today we're going to be talking about Mev about the history of strange things in the med pool um briefly uh oh hold on there we go um at a glance this is what we're going to be talking about today I'll share with you kind of the history of interesting things that have happened on chain we'll talk about new emergent phenomenon and then about how you as a user Searcher or an application developer can leverage these tools today um there's a brief introduction if you are not already familiar with flashbots we are a research and development organization dedicated to mitigating the negative externalities of Mev so we develop protocols like the ones you see here boost and Mev share as well as products like our bundle relay for Searchers the protect our PC for users and wallets and our block builders and purpose of this is to ensure that the Mev supply chain stays decentralized but what does that actually mean um if you will indulge me I want to start by taking a quick walk down memory lane looking at some of the interesting things that historically happened on chain and I'm going to start if you are an OG you may have seen this slide before it is a deck put together by one of our mates a few years ago to show how Searchers were engaging with the very earliest form of flashbots and I want to share with you some of my favorite anecdotes and stories from this because I think they're quite Illuminating and still true with the market of searching in Mev today so to begin with uh way back in the early days of flashbots one of the earliest interesting scenarios we saw was when a Searcher named Nathan entered the chat so Nathan was a very sophisticated Searcher who in this example we see he was able to bait essentially a sandwich bot and steal about 250k from them and this is actually an example of one of the earliest kinds of exploits in Mev affectionately known as salmonella essentially the way this works is that you create a token which simulates differently from how it executes so the sandwich bot in this case actually run by miners was able to buy the tokens but then couldn't sell them back and whoever baited them was able to drain the pool we also in the early days saw a lot of PVP games between different Searchers that were competing and fighting with each other so this is a very cute screenshot actually of two of these Searchers who had I think one of them had wrecked the other one left them a nice message on chain saying good game well played and then finally another theme we see is the entrance of new paradigms new protocols for searching so this example is of uni swap V3 it's really interesting actually when uni V3 was launched they're basically were very few people who actually upgraded and integrated it it took months before we actually saw like a competitive landscape of uni V3 searchers and I call these examples out because I think three key themes here three constants if you will in the history of searching and they are first of all that there are new exploits that emerge maybe used to be the salmonella exploit now it's something like the low carb Crusader the second theme is that there's also new paradigms that emerge for searching so different protocols different ways of thinking and the final constant is that despite all of this in the face of all of this change Searchers adapt with style so you know you see the very cute P2P messages this one I don't know how easy it is to see on the screen but this is an example of a Searcher who is actually recently trying to integrate a new protocol called Mev share and they realized that their bot was not going to be that profitable when it first launched so they called one of their functions the charity function which I thought was very cute but um what's happening now like what is the new frontier in searching today that was a few years ago what's happening today and I want to share with you a few things I've seen in the past couple of months that I think are quite interesting and allude to maybe a new paradigm in searching and in Mev more generally so I'll start with this one a like a month maybe two ago uh we saw this token launch happen and it's a pretty standard token lunch uh the team announced it on Twitter in advance and immediately after the token was launched we saw this bot essentially background the launch to basically snipe and grab a bunch of the supply um the reason it looks weird is that the token launch contract had a clause that tried to prevent people from basically loading up on this token but as you can see that was no barrier for the Searcher they were able to just kind of get around it by making a bunch of requests so all of this is pretty classic token launch token sniping stuff nothing weird here uh but there are two weird things if you take a closer look at the Block where uh that Searcher transaction landed the first is if you actually look at the original transaction that launched the token uh you will see something strange which is that this is a flashbots bundle this is a response from the flashbots locks API which tells us that this was actually a private transaction it's kind of weird how did this Searcher know to background them the the transaction itself was Private what's happening there the second thing you might notice is there's actually a third transaction after the launch transaction and the background which is a transfer from the Builder to the original launch address of about twenty thousand dollars that's that's weird so some portion of the searcher's bid was actually refunded back to the user weird I have one more example for you uh yeah essentially how did somebody back run a private transaction and generate so much value one more example which is in this block I want to take a quick look at another similar case these three transactions this is about a week ago we saw first a user Make a trade on a decks they were swapping some eth about 10 eth for this random token called woofwork they actually got completely wrecked not by an Mev bot just because I think the pool was quite a liquid they basically went from 10 East to almost zero dollars very sad you can see this is also a private transaction okay people make bad trades all the time this isn't that unusual uh but what is kind of interesting is again we saw a Searcher back running them in the same block despite this being a private transaction and that Searcher knew which pool the user was trading on weird we also yet again saw a refund from the Builder to the user who made the original trade so what's happening what are these weird phenomena that we're seeing um this is actually not a fluke this is an example of a new emergent phenomena that's happening today on chain and it's called an order flow auction so essentially the squad status quo right now is users will either send their transactions to the public mempool or they will send them to private channels like for example flashbots protect which is where these two examples came from and Searchers are able obviously to see what happens in the public mempool but they're not able to see what happens in the private mempool and that's actually pretty sub-optimal while these private channels are really great for protecting users from things like front running um as we have seen there's a lot of value that is on the table to extract even just by back running these transactions which is something that's fairly neutral usually to the original user in just these two transactions alone there's about 15 eats on the table that's just sitting in these private channels so order flow auctions try to find a balance between protecting users and internalizing the value they generate the premise is that when users transact on blockchains they generate value and right now that value is primarily captured as we have seen by Searchers or the validators they have to bid to for inclusion but we want to give users a fair price for their transactions and the way that we do this is by allowing Searchers to bid for the right to execute them essentially allowing us to strike this balance between protecting users and internalizing or refunding them the value that they create through Mev so this is essentially what we're trying to do is allow some valuable actions to be taken on private order flow the the problem though with all of this is that searchers can't exactly be trusted so users are using these private channels for a reason they don't want to get wrecked we need to find a way to kind of balance that concern with allowing valuable generate Mev to be generated and the Really the trade-offs here really come down to privacy you know the more you information you have as a Searcher the more efficiently you're able to background or bundle some user transaction and this is also good for the user because it means that they're able to get a higher bid in the auction on the other hand if you reveal too much information somebody could you know generalize front run you on another domain or take some other action that negatively impacts the user so at flashbots we have thought a lot about this exact problem this trade-off how much information do you share and what we found is that it's not a one-size-fits-all problem different use cases need to share different amounts of information to strike this balance between protection and value internalization and we call that concept programmable privacy concretely uh the idea behind programmable privacy is that you control what information you share and we call these pieces of information hints so an example of the hints that you might see are things like the contract address or the logs maybe the call data Maybe nothing the transaction hash that a transaction emits and what's very interesting about this is it creates a new paradigm for searching as a Searcher you will have to actually update your strategy to search on these hints and incomplete transactions rather than on complete transactions that you're used to seeing in the mempool so for the rest of the time what I want to talk about is one particular protocol for order flow auctions that uses this concept of programmable privacy I'll talk about what it is how it's architected and then how you as a user more an application developer a wallet or a Searcher can interact with it today and that protocol is called Mev share so if I take a quick step back to orient us if you have seen any flashbots presentation you have probably seen this slide if you have not here's the slide you will see it many more times after this but essentially this is the Mev supply chain in other words it's all the steps that happen from when a user submits a transaction to when that transaction is included on chain and that includes you know the user's intent which is then signed through something like a wallet submitted and bundled by Searchers merged into a block by a block Builder and then finally confirmed by a proposer or validator and to zoom in a bit where Mev share lives is right here so at the very start of the transaction or muv supply chain and the protocol is pretty straightforward it it about three steps and there's really one primary actor which is called the med share node and the map share node is responsible for doing a few things first of all it receives transactions from users second of all it shares whatever hints that user has asked for with the Searchers that can publicly see this data then it receives partial bundles from Searchers which are just like usual bundles except because we don't share the full signed transaction as a Searcher you're not going to be able to put a transaction in your bundle so instead what you would include is an identifier for the transaction whose hints you thought matched whatever you wanted to put in your bundle so for example that identifier might be the transaction hash so a partial bundle would be a normal bundle but with some transactions and some hashes finally step three the Matchmaker will receive all these partial bundles and then it will convert them into full bundles by inserting the signed transactions that correspond to the hashes that Searchers have specified and the the resulting full bundle is then sent on to a block Builder pretty straightforward foreign to the existing flashbots architecture like that protocol is all very interesting and high level but like how do I touch it where does it live today what does it mean for me as a user a wallet application developer or searcher so here is where it sits if we look back at the original diagram flashbots protect is a protected or private channel that users or wallets can submit transactions to and what we've done is flashbot says implemented one instance of a Mev share node which is that party that sits in the middle of the protocol and that node can be accessed directly through the flashbots protect our PC so these things are now combined together and what this does is allows Searchers to in a safe way try to generate additional value on top of this private order flow so flashbots protect is now upgraded and has a bunch of useful properties for users it gives them both protection and now with Mev share the ability to internalize Mev that they generate and for application developers or wallets it gives you a lot more options about how you actually design your application in an Mev aware way through this configurable control panel where you can decide what information is shared with who and how so to go a little bit more specific concretely as a user the way that you would interact with this is really easy there is a button on the flashbots docs you just click the button it adds the RPC to your wallet I think it takes maybe two or three clicks depending on what wallet you're using and it's fairly straightforward all you have to do is switch out your RPC to get these benefits as a maybe more sophisticated user or an application developer or a wallet you also have more options these are available to everyone but especially recommended to folks who are developing their own applications that want to kind of Tinker with how the med share protocol works so you can select a number of things including the hints or privacy settings that you want to share as well as the other block builders that you might want your transactions to be forwarded to for example to have increased inclusion rates you can also select things like how refunds are distributed what percent of the searcher's bid goes to what address or another and you can also configure even more advanced things which we call validity conditions a refund is one example but it's basically a way of telling a block Builder how it is required to treat your bundle happy to talk more about that after if anyone is interested as a searcher though what does this look like I think this is the biggest step change with something like Mev share and programmable privacy is how Searchers are going to interact with this new paradigm well there are about two or three things that you'll want to think about and the first is how to consume data you're going to be using hints instead of mental transactions which means you have to listen to the med share event endpoint listen to the nodes hints instead of listening to the public mental and you're also going to need to parse a different object you know you're going to parse something that has these hints in it rather than a full signed transaction this is an example of what some common hints might look like the second thing is you'll have to change the way that you think about sending bundles in particular we talked earlier about partial transactions or sorry partial bundles which just include the hash of a transaction so you'll have to adopt that new paradigm and the way that we do this is through a new API um we've gone from each interesting piece of this once you've got all the Integrations hooked up is how you actually change the way you think about your searching strategies so you know you're not able to do things like simulate a full transaction anymore which means that you're going to need to move or change the logic that you use as part of your Bot and there are about two ways that we think about this broadly the first approach I would call on chain searching and basically what on-chain searching is is moving all of the computation you used to do off chain into a smart contract that's executed on chain so as an example if you're used to seeing the amount or that somebody is trading in their call data or their logs you might actually have to use the reserve Deltas on chain to run a calculation like at execution time to figure that out now the other way you can think about searching on a programmably private transaction or set of transactions is to do it in a more probabilistic fashion so for example instead of knowing the amounts and the direction that somebody's trading you can just guess basically say well I'll send two transactions one for each direction that they could possibly be trading on this pool and then I'll also you know for each of those directions send a bunch of different possible sizes if this is an ARB for example the thing I would emphasize and stress to all of you is like it took about three months for anyone to really become competitive on uniswap V3 mem share is also very early and this Paradigm is new and that means that as a scrappy early Searcher you actually have a huge advantage we're sponsoring some prizes for the scrappy Searchers who want to try this new paradigm as well as you know wallet application and other developers who are interested in experimenting with mebshare so I'll briefly talk about what those prizes look like uh the first thing is we're giving a prize for the coolest Med share bot um essentially come up with something weird deploy it land some bundles this should be open source we're also giving away the prize for a design that uses medshare in an application so really get creative with this it can be fully implemented it can be an architecture spec but the idea is to have some sort of specification for a new configuration a way of using validity conditions or hints in an application also please make it open source there's a theme finally um we're giving out a prize for an onboarding viral website for the protect RPC uh we currently just have this button in our docs we want to see what interesting things you might come up with all these value props we've talked about today and how would you want to communicate that to somebody again we build open source software so please make this open source and that's it um I think to conclude there are like I mentioned at the beginning free things that remain constant in Mev new exploits emerge new paradigms emerge and Searchers adapt to a style so we're very excited to see all the stylish ways you will interact with this new paradigm um you can reach out to me and the team will also be in the Discord for the rest of the hackathon that's it [Applause] questions foreign um you know two days [Music] ago [Music] um is um resolution [Music] um yeah videos [Music] foreign hello everyone I'm Vivian I'm from privacy and Skilling exploration team and today I'm talking going to talk about how to hack on the ZK project yeah and this is the slides there's a link and then the first link is the slides so you can see the examples and links in inside [Music] foreign price so I'm going to introduce a little bit uh so we provide five uh 5K and we will choose four projects and you can these four projects you can choose either uh uh three of these projects and first one is semaphore and then second one is unirp and the left one is each E2 easy k e c DSA and I will going to introduce these three projects later yeah so you can choose one of them to to hack yeah and I will introduce a little bit about ZK really short so uh here's an example so how we verify a transaction is correct so uh for so how how we verify that the X this equation is correct then we provide a plain text X so the minor and others can verify oh you know uh the the acts of this equation yeah so what decay does is that we provide a proof and then you don't know what is the equation and then on chain you just verify approved and then tell tells you if it is correct or not so it is the Decay dude on on Chen [Music] if you want to know more about zero knowledge you can go to the ethereum duck website and there's a zero knowledge proof page and then audio X part is also provide some materials for you to learn about ZK yeah so I'm going to introduce the first project called semaphore and semiform is in uh like an identity system and then you can generate a identity and then you can generate a membership proof of this of a group and then also you can include a signal in the proof tool such as to vote or endorsement some some information in the it in this proof and there's a symbol for website and then you can uh getting started easier in in this website yeah so what semaphore can do is something like you can prove that you you are a member of One of a group and then you don't reveal Who You Are and like I said uh you can endorse and signal so you can include a signal in this proof to prove that uh I I want to say something oh no okay like like voting always told blowing yeah so I will provide some example codes here like how you generate and random identity so you you install the semaphore identity package and then you use the new identity function to create identity and there are several uh secrets and uh or public signals in these identities they are called trapdoor no fire and commitment and you can go to the documentation to see the definition of this different uh different terms yeah so this basically how you create an uh identity yeah and then you can add at your your identity to a group and then you install a package called semiform protocol group and then you can create a group with index one and then you add a member in this group always then add member function yeah and then how you generate a Decay proof and you install the a package called semaphone protocol proof and then there is a general generate proof function inside and then you you can um generate a external normal fire and signal in your proof an external nullifier is used to prevent your action being doing twice for example if you want to vote an event and then the external new fire is the name of the event like the topic and then your signal is your vote like you vote one or two or three or something like that so the signal can be uh can can happens many times but the external neurovirus it can only happens once yeah so you include this information in your proof and then I'll call it with the generate proof function yeah and there's a verify proof function as well so you provide the proof and then the group dips and then the group divs is the Mercury dips so and then I think it's provided in the inner group object so you can just use the group dips steps and also semaphone provides a CLI to install the package easier so you install the COI and then you can use semaphore create and your project directory to create your your project and if you want to explore this commands you use the semaphone help to help you understand these commands yeah if you want to learn more about semaphore you can use the demo app or go to their Discord to ask them questions and then we are also in the first floor so you can find us and then ask us about if if you have questions yeah in their documentation yeah so the second project is called unirap so unirp is a private and non-reputable data system and it is also and provides an anonymous to to users but in the same time the user can prove how much how much data they have and then if you uh you can go to this unirp.io to see the document yeah so what it's used for you can use it for the reputation or data application for example you have GitHub and then you want to prove that you have how many stars in GitHub and how many followers in GitHub you can use this protocol so you turn the web to data to web3 and then you can generate a zero knowledge proof to prove oh I have I have such amount of stars in GitHub yeah and also you can improve the membership of oh I'm a user of GitHub something like that yeah and there are some example applications that build uh by our collaborators so the first one is a trust list so uh you can it's a uh you can sell product product and then you choose which uh which buyers you you want to change uh transaction with yeah and the users are Anonymous and then the second one is what I said you can Bridge your web to reputation to web3 yeah and then the Third example is a social media so we can build an anonymous social media and then other people can upload or download a post and then if you are not able to generate a positive proof in the future you are not able to post in the in this Anonymous social media yeah so it can help to manage an anonymous social media in Webster yeah and then the last example is uh water zone so it is a vote like a voting system but it's different from semaphone is that in the end of the hack Zone you you finish the proof uh you think with people finish voting and then you can prove that how much votes I have yeah it is uh a little bit different from semaphore yeah so to install this package you use the npn install your new rap core and they are the file of the following example codes yeah because they are pretty much oh sorry yeah so uh the the first uh the example here is that if we want to deploy a unirp contract we use the deploy unirap from the contract package and then you just connect your wallet and then call the deploy unit smart contract yeah and if you want to connect to a deployed unirp contract you provide an address and then your the provider or your wallet and then you can connect to a deployed smart contract yeah and then the protocol is uh like this floor so the users are up just providing proof to the testers and then a tester or relayer will submit the proof to Smart contract to verify this proof and then the users can uh see the data on the smart contract and then know how which data is my uh which is my my data and then you can generate a valid proof to prove them yeah so uh so they are tester here is like an application and then you set up roles for the data how user can can can get data like for example like the GitHub GitHub is in a tester and then other developers are users in this application and then let the GitHub will manage how users get uh received stars or followers and something like that yeah so the the tester is pretty much like a and an application and set up roles for users yeah so uh you can sign up and attest her with a wallet oh here's the wallet example so you call this a small contract and then call the function a tester sign up and provide an airport lens yeah and you can go to the document to see the the definition of like Epoch or epochet and then there's another way to sign up and the tester is using a small contract so you with the small contract yeah so if I'm a user of this application you can generate uh so how to sign up a user so user can generate a semaphore identity here and then create a synchronize all the untrained state with the user state a class so you provide a proverb it is a used in a circuit is help you to provide a zero knowledge proof and then you will provide the unirp address contract address and then you provide a provider and then your semaphore identity and then you you use the start and wait for sync to start syncing the whole event happens in unirp contract and then you can generate a sign up proof with the Gen user signup proof function and if you want to return and you just call the users users they stop or it will keep syncing synchronizing all the states yeah and when user generate this proofing client the user can should submit this proof to the tester or application itself and then to call the a tester only did a test can call the unirp contract to send a proofs on Trend and then update the unirab smart contract state yeah and how users received testations or data or reputation the user should generate a temporary identity called epic so you can imagine that you have a list of wallet accounts and and people cannot link all these accounts to you but uh so but in example for uh in unirp you can generate a set of apar keys and then you can prove that all these this as that is yours yeah so epic is one of this like address but but it only lasts for a park and Epoch can be like one day or seven days or one week or something like that yep so if the the upper is too short you're not able to use this airport key for a long time but if it packs too long you are you should wait uh you should use the same identity for a long time yeah so this is how you generate a temporary identity called Epic yeah and a tester when the a tester see this apple key he can send data or a testation to this airport key yeah so in this uh example um uh the testers and the index we all data index 0 to 5. yeah because we provide uh for example six data lens so you can change six of six of them yeah but uh this in this example is that if we Define a field index 0 is the GitHub Stars so if and and it increased by five so you give the index 0 index 0 to 5. yeah it is how if you don't want want to know more about data you can go to the documentation to see how data is defined yeah and when an airport ends we the users will call a user State transition to receive all the data to uh uh the user itself so after users they transition the user can prove how much data he has yeah so here's an example to generate a user's day transition proof and also this user should submit this proof and then it can be submitted by a relayer so yeah I use the signer here but not relayer yeah and after user say transition the user can generate approve to prove uh how much data he has for example if the user has have five and then he can prove that oh I have at least three yeah so you don't have to review all your your assets or amounts of data in it but you can generate a valid proof to prove or you are in a certain range of data yeah and then you can also build a tester with the CLI is more easier and this Con this CLI I will provide a circuits and contracts and relayer in front end so you can start the app by yarn build and with hard hat node and then deploy your small contracts and then you can start the relayer and front-end client yeah so the last project is called E2 easyk easy DSA so it's it's a private ecdsa signature verification so you prove the ownership of ethereum address yeah so the problem with the previous example is that you you have to generate a new identity secret but it is really hard to manage uh many different secrets so this use this example is that you can use your wallet to generate a proof so you don't have to manage a new Secret yeah and then you can use the LDK ecdsa for a verifier contract so that your your contract can can still verify assets but you uh but but with uh ZK they can prove and then you can use for an anonymous airdrop yeah or a Discord verification but uh I'm really not familiar with this project so please go to the website to check how uh how it can be used yeah so this the also an example code here yeah and there is a demo app so you can prove your assets with your wallet uh yes in this link yeah so we have these three projects and yeah 5K bounties so if you are interested in one of these projects please uh uh heck it yeah so oh if you have more further questions you can go to the PSE Discord now there are many people there to answer questions for for people yeah and thank you [Applause] questions um [Music] thank you hello that's it [Music] thank you very much it's impossible to stop this later um okay hey so I'm Leo I'm from sismo and so today we are going to do a workshop so I will there is be a very few presentation but more like trying out a bit our tutorial our like boilerplate and stuff like that so I hope you enjoyed um so at this mom what we do is that we leverage their own knowledge proof to enable users to aggregate their identities and selectively declose some piece of personal data directly to Applications I'm going to so here we can see we have 0x1 and 0x2 and we are able to aggregate this data generated zero knowledge proof of some small piece of personal data inside it and bring it to an application with what with a single sign-on so SSO flow I'm going to do a demo right now so you will more understand how it works so for a bit of context around this this demo last year what we we have done is um we have printed the code of tornado cache with a two meter high artwork so it was a physical piece of painting and so two months ago it arrived on Twitter and people ask us to have it and to have a version of it so what we did is we did a lottery to be able to gain this artwork the problem was okay we wanted to gate this Lottery only to users of Donald cash but when you used another cache you can deposit and withdraw a lot of time so it's highly uncb resistant so we decided to also add a way to have CB resistance on to enter this Lottery we use Gigan passport for that so git gun passport is a way to you you connect your Twitter your GitHub so it's a bit like doxing because all happened in your public identities and it analyze uh your activity basically the commits you have made um the tweets you have made and based on that it will give you a score of CB resistance and and for instance 15 score 15 is a good score of visible resistance let's say I am human so here uh sismo is very interesting use case because you want to prove that you have used Orlando cash with a very private toilet you don't want to reveal at all and you want also to prove that you have a git gun password so basically that you are simple with your very public uh wallet ens and so using sismo and sismo connect you will bring these two data without revealing the address that was used behind so let's go let's go to the demo um so we have what we call the App Store so it's apps.tism you can go there and try it out you click on demo here and here you can see the lottery registration so basically to this is the application Lottery registration to be able to enter you are going to do a SSO flow sign in with gismo and requesting data from the user to be able to enter the two data we request here is okay I am well done education depositor on mainnet and I have a Bitcoin passport with a score more than 15. with this move I'm redirected to my sis mode data table so the system data voltage like a password manager when you import all your different different accounts so this one is a demo one so we can see here there is a lot of icons that I already have been imported I can use show you mine the my real one you will see it so I won't do all the when because otherwise I will dox myself but you can see I have a lot a lot of accounts and I import them just once and like in password manager in one password functions you import your different icons when it's imported it's linked to your Vault and in this system what we call the World secrets that you will be able to use in zero knowledge proof to prove that you earn these different accounts so thanks to that you will be able to prove to application that you own your different accounts if you want and we will see this later how to use the devex to request some proof of ownership of different accounts but you can also do some membership basically it's what is this membership it's you have groups of all the icons that have exactly the same characteristics for instance here you have the tornado cachetron depositor groups if we see the content of the groups it's all the deposit on minute so it's basically all the icons that have made this action so what we are going to do is that we are going to prove in zero knowledge proof here so all happen in the browser that we own an icon that is inside this group and we are going to send back this proof to the application that will verify it verified of chain or on chain if we take the click on passport it's exactly the same so you have the group of all the gitken passwords and we can see here the contents and there is a particularity is that it's a key value that a group so the key is the accounts and the value is the score of your git gun passport and what is interesting here is that you can do predicate or statement around this value the application can request and this is what's happening here that okay you are part of this good but also you have a score that is more than 15 and the application won't know exactly which score I have inside but the application we know that I have more than 15 and this is just what is interesting for the application so I do generate executive proof this is generated it's sent back to the application and I can verify my ZK proof and I will be able to enter the lottery so here the flow the verification happen of chain but it can also happen Unchained we have a solidity library that can we can call to verify the proof so we have what we call the Factory The Factory is the UI UI Dev tool that enabled to um to browse the different data groups and create data groups so data groups here are very important because it's a source of data you will be able to use inside your application so we can see here for instance there is around 1000 groups that have been created so you can go there it's all open and you can like search for instance the gitcoin passport one is here we can see the last generation the Next Generation so the groups are snapshot groups they are run at Daily frequency and you can choose basically the frequency you want for your group to refresh this data um I will show you how we can create a new data groups so you can do all in the UI tool also you can do a manual group like basically you just put your your addresses your list of addresses or you can use what we call data providers data providers are just a way to fetch data from the outside world so for instance here we have a lot of data providers that have been made by the community also you can then you can also code your own data providers that will appear here for all the other Developers um so we can create a group together I propose that we use like the GitHub one um here you can see the different accounts we have we have like web3 accounts but we also can have like GitHub Twitter or telegram accounts so basically if we do a group of all the GitHub contributors of the repository you will then later be able to prove that to a part of this group without revealing exactly who you are so basically you can import your reputation from your web to activity in this example or bring some web to activity and webto activity together in one proof so here we can take for instance so let's take I don't know so let's take the foundry one so it it's an interesting one I think there is no group for this one so you just need to put here the Repository so here we know that there is uh 274 accounts that contributed to a Foundry if you just continue so here you need just to put the description and specification around your data group so other people can can search for groups and reuse them for their own application so when you create groups you just bring data for all the other people to be able to generate zero knowledge proof out of it so let's say you know that a group of all the contributors to Foundry so that type groups of all are committers to the so in the specifications what is good is to put the very more precise one like um to put all committers to the Repository okay so let's say a Foundry GitHub contributors that are groups here you specify the frequency you want so either once it will be completed just one so are we clearly let's put daily because then we will have updated data if it is here public information is to be able then to contact you if we want to change the group or whatever so I will put mine because I'm the one that did the group yeah and let's go okay so you see your group is being created what happened here it creates so the factory is a UI tool On Top of the sismo Hub which is a repository that contains all the infra that computes all these groups and put them in knuckle trees in what we call Poseidon knuckle 3 to be able to use them inside zero knowledge proof so it completes all these Michael treats and the root and chain and then it's available for everyone to be used here what happens so you can see the code you can directly code your own groups by hand as a developers and do really more complex stuff like using multiple data provider together Computing some score around it and trying to normalize stuff whatever you want once we have this group so we can do zero noise proof out of this group so what will happen here it will be automatically checked if all is good then it will be merged automatically and when it's merged it's deployed for instance we can see an old one so you will understand for instance if you see today there was this group that was created and so here we can see that the group is generated the Merkel trees are created and then the the groups and the root of all these Markle tree are sand on old chains and then they are available for uh to be used in seismo Connect okay so while it's it's generating and deploying we are going to effectively so use the system connects to an app so we have provided some boilerplates for that you can go to stocks.io and we have here all the section build resistmo connect in the overview you will see so exactly what I demote you so you have a button you do you need to to force the request you want to do to the you for the users so basically you will say Okay I want that he is part of this group this group and this group the user generates his secret proof in his browser send back the ZK proof to the application your application and you can verify it of chain or Unchained okay so um sorry so if you go to the installation here we have a create system connect uh script that will basically set up all the different baller plate we have so let's start running it what is the name of your project so let's say Workshop so when you start swap the the script asks you for an app ID what is an app ID it's basically when when you create an app on top of these modes like when you do um connect with Google you need to register your app so the proverbot will allow you only um your front end to be able to request data from the user so it's for security reason basically so you create your system Connect app so it's very it's very easy it's permissionless you just need to to go to the factory again and to create your system Connect app so let's say is global Workshop for this Global washer so it's fun when you add a picture and authorize domain so here you can put like localhost to test in localhost and then once you deploy you can update it to add the authorized domain for your app and by creating this Hub this app you will have an app ID so this app ID is is the one you will put into your piece of code like uh when you install the front end and the social system connect button and the system connect verifier exits and let's start by the option so we have enough chain and the Unchained boilerplate so you can do what depending on your oh yeah sorry I am so sorry is it better like that thanks so yeah you can um so let's go to the off chain one to start so it will set up an xgs application which is more connect installed in it uh okay let's go to Workshop yamdev so here you will see okay you have the Phantom the web you have your button and this is what is used to request your ZK proof you have the system connect config where you have your app ID and the different data you want to request and then you have your API your backend to verify to verify the proof okay so when you launch it you arrive you will arrive on a very simple front end that you can modify to just do your needs but here you can see what we are going to request so we are going to regress for authentication so it's basically proof of ownership of an account and claim requests that are basically proof of membership into a group ID you can see the different group ideas here so you can see when we click it goes directly to the different group ID system web contributor for instance okay we do provisional generator so here you have like six different disciples so it takes a bit more time in the browser to run it's around two seconds by ZK proof so if it takes a bit of time okay it was pretty fast it verify okay then it's very fast so it calls the back end and verifies the result and prints the result here so then you can use them to do whatever you want to store it into into the database or whatever and if you want to update so let's try to update it so here you can see the button it's very easy you just need to put your config oh sorry just need to put your config with your app ID and here you can impersonate accounts and you have your app ID that was automatically filled and you have here the accounts that you can impersonate so you can change this to say Okay I want to so we use Foundry let's impersonate const which is Georges okay I think I've okayed mistake here okay so we do again you approval with this mode and we can see here so we have our is global Parry Workshop so it discovers the app ID and changed here the impersonated account so now I use the care const let's go see our group how it goes so it's been sent on change so yeah it will be ready in around two minutes I think so during the time it sound let's try to set up the maybe Unchained bowler plate so we will have the Unchained one so we are using fundry for this one um so I know if you are very familiar with hungry but we also have a package for our that but we advise you to use Foundry and we have so this border plate that are all well set up so it's a good I think it's a good reason to start and Foundry directly if you want and it's really like a 10x tool when we compare to to the all others so I really advise you to do it um okay so we start to gain the create system Connect app let's take again the system app ID so we have this one and we take the and chain one so in this bottle plate you have a front folder where you will have an xgs application with all wagami and VM that will be able to allow you to call directly your contract and you have a SRC folder here with adverb that's all that is using system connect to verify the proof it's very easy you just have to put it here and to import it from this Library so all this is in the documentation also also so in the installation spot then you have a claim with this small function where you will have the system connect response that you will be able to verify regarding the data you wanted so you need between the front and the back end or here the smart contract you need to have exactly the same requests otherwise it will fail because um you request something and you verify it but if it's different it does not correspond specifically it's like a signature when you do a signature you verify your signature against a specific message and you verify that your public key corresponds to this verification here it's exactly the same so um let's go to I'm going to so yeah we don't have a lot of of time so I'm going to modify it to just put our new group ID and to use an authentication of type volts so I will explain you just later what happened so we are going to say okay I want to verify a claim request from being part of this group so let's go on our so it's almost finished okay let's go to browse our groups okay so our group is here we can see the content of the group so we have all the contributors our guide consists here so it will works in the value the data providers was developed to put the number of commits you have made so then here it will it's interesting because we can do request of having done like more than 50 contribution into this Repository we take the group ID here and I can put it directly there um now if I go to the button path so we are looking for The sismo Connect system connect button here we see our config where we have same so our different impersonator address so let's change this one and let's change our request so here we have our authentication request and our claim requests so we say we need to have exactly the same between the front and the smart contract so we put a vault so here let me explain you the world we have created an app and we are doing zero knowledge proof from a user to an application this app has an update this app ID is a random number basically inside your system Data Vault you have a secret that is stored in the browser in the in the system manager and if you hash in the Run let's prove this secret with the web ID you will have a unique number The Vault ID that will identify you to the application this volt ID is is very important because it can be used as a nullifier for your app let's say you you do Network you can just store this volatility as being used and the user won't be able to claim again his adopt or another chain you can use it like a bit more as a user ID into your app and it's like an anonymous user ID but you will be able to authenticate each time and you don't need an email or I don't know or whatever so um so let's go do here it's just embarrifying this is okay I think this is almost done um sorry the group ID is here and here we go okay so when the the creates more Connect app has launch it's a you need to launch the local chain um this is you just so you can like you know deeper your contract easily and don't pay each time on your local chain uh sorry I need to go to the Unchained Foundry and launch my chain and same here I will go to the front end and do yam Dev so all should be explained here I know I have okay so all here should be explained uh you know when you run it you have all the explanation on what to do exactly here so let's go to our new system connects ah yeah it's because I have the of chain one sorry so I will read like launch it again okay so what happened when you launch the front it will also deploy your contract into your local chain and each time you modify your contract it will redeploy into your local changer constructs um okay so here it asks me to connect my wallet it's just I need to need to switch sorry okay so we say I am in this local chain I'm connected with my account I do claim with this more I see that I request only ownership of my volt ID here it's my random number that will be completed in zero match proof and here we are checking that uh get most which we are impersonating here is part of the fund regular repository group foreign so what happened here is that we download the world group in the browser and we generate the ZK proof out of this group so all happen in local in your browser but I think this is because the Wi-Fi is a bit slow but let's try again okay maybe let's take another group let's take I think we were going to take the rest one that we already have uh that we are going so we need to to change if we change the group we need to change it also in the contracts let's go again I'm a bit out of time sorry okay let's do claim with system again so now we have the rest GitHub contributor group we do generate zika proof we are redirected back to the application and we can do our claim with this more okay so sorry for that um yeah I think we are running out of time so I won't keep you more and yeah so um if we want to build on this more go to builders model tell you here you will enter the telegram Channel where you can ask for help for whatever happens and we will be here doing the support all the weekend thank you for your time [Applause] [Music] [Music] how do I mirror it how do I mirror the display to advance Maybe cards okay so maybe bear display I'm trying to change the mirror where do you do the mirroring okay thanks ah okay great thank you thank you hello hello [Music] um [Music] that always works um thank you everybody they all actually showed up for this so go you um we are going to have fun and um we're also going to roast the organizers for having terrible Wi-Fi at the hackathon boo but good food yes but yay food um right So the plan always is to start five minutes late because who actually needs 30 minutes um and uh here we are so I am we're going to talk about reputation and making it useful and portable um and then we're going to talk about uh some sdks that might be useful or interesting for some of your hacky hacks um I Am David Phillips this is me on the Bird app the Twitter um I put this picture in there so that you know I'm cool um so you respect me yeah that's me yes yes I'm a California native born and bred now San Diego um now I reside in New York and now I'm here to chat with uh all the Parisian wonderful hackers and people from around the world um but we're gonna we're just gonna jump into it so quick context show of hands who has heard of dids or who has built something with them it's exactly one-third oh exactly half welcome um so we're just gonna do a quick overview contextualize like what is identity how do I see this in the world and then how does this evolve into you know this digital analog hybrid crazy future that we have going on um traditionally we use credentials to get access to things um the the the passports right we all had one to come to the country uh in the US they're really militant about making sure you have an ID card to get into a bar and even if you look 50 they won't serve you a drink um but these credentials generally come from black boxes they're institutions that we don't really have control over insight into or a deep understanding of how they work or why they work how they do um but they allow us to do lots of nice things these credentials these identities that we carry around or proof of identities that we carry on in our pockets we can ride airplanes we can get mortgages so right now there's this like massive Trend and that's ongoing it's not slowing down so it's just a you know a couple of data points for you eight percent more time year of year has been spent online every year for the last 15 years um so we're starting to run into this thing of we have these really nice it was really nice versions of physical ID cards in analog identities but that all starts to break down when we start to look when we look into the Digital World um you know how does I how does identity how does it how is it useful right how do we take our self with us to different parts of the internet because if more of our lives are happening online well you know wouldn't I like to have some credibility uh when I show up to a different ecosystem um so that's that makes the next point it's like okay we all have wallets it's a wallet and identity um I would argue no some people would argue yes but I think good identity ultimately um is Sovereign secure and portable and that's the litmus test that it needs to be able to pass and so identity our wallets are great because they are secure and they're Sovereign but um they're not a wallet address isn't necessarily useful beyond the bounds of a specific blockchain ecosystem so we can build all sorts of wonderful history and ethereum but it breaks down when we you know go over to Twitter or some e-commerce platform or anywhere else that we do things that are important on the internet um racing along here but what we are going to look at today is what is an identity graph how can they be constructed and how can they become super super powerful tools uh not only in the as a vehicle of individual sovereignty but in terms of what you can reliably gain access to or how you can represent yourself online um so what is a did um yeah what is a did so a did is a key pair it oh yes a did is a key pair um so you have a public key and a private key the way next ID works is it's the same you can basically have the same Keys they're using on ethereum and it is a key pair that is used to sign and certify control of an identifier or an entity on the internet so as you see in this little visual you have like an avatar or an ID that is a key pair that is a did and you're signing a message to say I own or I control this ethereum address I own or I control this lens profile this ens or a Reddit or a Reddit account or a GitHub account and so what we're doing is we're taking these disparate identifiers these different pieces of ourselves and we're creating a single graph that is a more holistic representation of our self um and we're gonna know why this matters and why this can be cool in a little bit but I'm just going to pause there and take any questions that have come up from anyone because small group I can so the cool thing about dids is you don't actually need a specific ecosystem or a blockchain because a cryptographic signature is at is a standalone as a standalone unit uh publicly verifiable it's really easy for me to say to look at a signature and say you've proved by signing this message like when you sign into any dap you've proving that you control that address without basically giving them your private key for them to be able to execute transactions and so we don't have like in did world we don't have the need for distributed like a a single distributed Ledger because there is no double spend problem there's no like oh this is a transaction that's being used to spend money it's very much um using your like a base cryptography unit to say I control I control a Twitter account or I control this address is that a little helpful great question great question yes so who creates the standard who creates a did for a user for a user so because it's a key based technology it is by nature Sovereign in that sense and what I mean there is you as the key holder you can only create a did um you can you can only modify this graph if you hold the private the private private public key pair yes no no this is great no this is great I'm sure common questions yeah yeah um so when you sign in to adapted have you signed in with ethereum yeah um there's not really a huge question of does the person who signed this message to gain access to the system did they control this public did they control this address uh it says the exact same mechanic in the system as that system thinking and trying to solve exactly that so because it's like it's the problem that we have I have whatever Recreation Center public private key email right yeah so you're talking about that from like uh an attribution in kyc standpoint yeah so we don't we're we're a bit agnostic to that that part of the world there's a lot of people thinking about that problem doing really great work on it and we support all of those use cases uh where we you know like they're people that want to build really rigid kyc systems there are people that want to build like fully Anonymous did graphs and we we try to create treat them both the same to power them both yeah of course there's one more question okay cool I'll keep moving um dids are basically a self-issued key pair and they're used to certify ownership and control um so you're taking an avatar or like you know a verify a link a bonding entity you're saying I own this other thing pretty simple just the connecting fiber like in a spider web um [Music] yeah so for the today we're going to we think about it as like this is doxing technology or this is like this is a violation of privacy uh because there's a lot of different strong ideas in our field um we like to think of this or conceptualize the the data data and identity there's above the water Iceberg and there's below the water iceberg below the water requires some sort of selected disclosure um but all of us probably have some sort of public online presence excuse me thank you um so we focus entirely on like what do you want to present to the world um about yourself that you you similar to like you participate on Twitter so you're generating a public data footprint [Music] uh so now we get into a little bit of like how that gets built and how that gets generated there are three key pieces to next study that we're going to talk about and how to use them so there's proof service this is the create and store the dids there's relation service which is querying them um so if there's anyone that's ever created a did for anything we've ingested almost all of them and so it's a simple API backed up on our weave so it's publicly available but you can relation service is way too query them you get the data so you create the data you read the data two different services and then the third thing we're going to talk about is a nice new way that we've packaged those things together and for Universal profile experience so we're going to talk a little bit about what a universal profile experience is in a minute um but that's the part that we are most excited about and that we really hope that you have a look at as well because we would love your feedback because we just released it this week um it is not in the App Store but it is there are docs available for it yeah super good question [Music] um so we talked a little about what the identity graph is revisit how it can look um this is an actual example from our system so this is my co-founder yisi we have here the ethereum address and then that was linked to Twitter which was a little link to a key based thing and that way actually all the way over to GitHub lens profile and then our our next ID binder so what we think is really really cool and exciting here is if you have any node in this graph you when querying our system can return and resolve to any point of it so what that means is if you're building a wallet for example you're like um it would be really nice if I could you know have a secure way of sending someone money using their Twitter handle if someone's interacted at any point with the did system and bonded their Twitter which is the most common activity now it becomes trivial because I type in you know david.david.you know Twitter David David's Twitter or at David and then I know beyond a shadow of a doubt I'm certain that the that the owner of that Twitter is the owner of that address so I can send money on basically any team so we're going to jump into the universal profile SDK here um pretty simple there's basically four different endpoints um and I'm happy to get into details or you know just talk directly to you after but the docs docs are all there this is at api.web3.bio so please check that out and let us know if it sucks we want to hear about it it doesn't um and then I'm going to jump over to proof service in just a second um but I'm going to demo live demo why not where is it and [Music] cool why if I don't feel me now bear with me one second so what you're able to do with um it always breaks when you demo it huh um yeah so this is a universal profile of you um and this is what you're actually able to get with the API is all of this stuff that our friend DC has done is available in this display and you're actually able to plug this into your apps so that when someone signs in with an address you hit our API and say does this person have a an ID graph and then it returns a did graph and so you're able to create a super rich display of user information without forcing them to like manually Port that over once again like they have a hundred times before so we have hundreds of thousands of current users that have that are that have dids and then there's a module where you can actually prompt them to create one for the first time as well any thoughts or any questions there yeah random question so you said that yeah these are independent on they can be yes so where our question is where do the pids live yeah so we use the same all the same crypto got cryptographic processes that ethereum uses because those are best in practice uh but these actually live in an in on our weave uh so they're totally decentralized database that everything gets pushed to and then um we have we keep a copy of those in AWS and have a really high performance API to make it so you can actually do things with them super easily so we don't we don't try to dox or aggregate any data that a person doesn't want aggregated about themselves and so a really important thing is like a did is not a transaction between two addresses it's a signature certifying that the same party controls two different identifiers or two different entities yeah um so our apis are really high performance they handle about 50 million calls a week right now so we do actually have some users and we look forward to welcoming you into to that family as well um so on the proof service side it gets a little bit more Technical and I'll try to say higher level and that we're getting a bit more into the leads towards the end um but the way for example that you can actually create a did that binds an address to a Twitter is with something called a proof post so we have our Avatar or our you know our what we call they just think of those as Keys you know your did Keys you're posting a special string on Twitter that our system ingests that is the verified basically you have to post a special string that the system generates for you to say yes this is the cryptographic signature that says I own this Twitter account so it's like it's like you tell us you're telling our back end I own David PCO that's my Twitter handle yes yes and then you have to post a special sequence of characters like 0x1234 on your Twitter account to then complete the generation of that proof that you own that entity and then the did gets issued in the system or by your dad gets issued by itself through the system uh so a little bit um maybe unfamiliar but uh I promise you when you look at it it's a three-step system and uh is pretty easy to build on so if you're interested um this is kind of our full stack and structure detailing you know where stuff lives how the model and data storage Works love to talk to you more about this but uh I don't think it's too important to go into right now and uh that's where we're gonna wrap it up so thank you guys for coming if you have any questions I have five more minutes to monopolize the space um and you have been wonderful yes so yeah thanks uh uh thanks man uh so the the integration to these other kind of web 2 properties is it done via Olaf or maybe I miss that um so the answer is the answer is yes and so we we like to bypass oauth whenever possible to reduce and eliminate platform risk um and so we do that with that proof post mechanic that I showed or that I showed a second ago because um like for example a post-based social media won't turn off like they're not going to eliminate somebody everyone's abilities to post but they do turn off apis right so you just essentially do it out of band Yes we don't count on their consent to be able to certify that ownership or their their collaboration though we do have it in some cases any other questions yes hey um so you you did tell if your talk is uh about um yeah take a reputation anywhere um do you um have some a research on uh having some reputation score of this kind of process yeah just to assess a reputation or provide any signals or insights regarding that yeah so reputation is there's a lot of different approaches for it and I think the easiest one to talk about is Bitcoin passport where like the more things that you have linked together the higher degree of probably like the higher score you have of being a a person um what we view as reputation might be a little bit different than um we have then we have historically or traditionally and what a what I mean there is what I mean there is we treat humans and machines the same we don't really care that much if a machine is participating in a certain ecosystem because it can provide machines can provide value um is I'm not sure I'm really directly answering your question but what's important here is that you have a persistent footprint that can travel with you beyond a single chain or Beyond a single platform so what we want to enable the same way that defy allows for monetary and transactional portability across dapps what we want is to have is to create a world where wherever you go online you've brought the parts of you that matter along with you is exactly the glue yeah it's the webs of the spider web yeah and after you can build on top of all that any kind of algorithm that will score the reputation I guess you're providing the glue that's enabled to link your own chain of chain social network and certain data and there's also there's other standards called verifiable credentials that are getting great adoption um where you actually can package up a government-issued ID without disclosing what that ID is um and say there is a government issued credential associated with that this address without showing your name or height or address or anything like that so this is the glue layer and then the other pieces they get built and put in on top of that so if you did want to have a proof of personhood on top of a did system you know there's there's a lot of cool things people are doing there yeah thanks everybody um next dot ID is our is our white so the next dot ID find docs and then um the other link that I already gave you as well thanks guys [Music] [Music] thank you okay is this okay can you hear me it's good for the mics brilliant sorry for the uh slight delayed starting I'm also holding my charger which I hope I can plug in at some point if uh I'm low on battery hi everyone my name is Angus and I'm going to talk to you today about Mino protocol and snarky JS so it's July 21st today there's my name yes my name is Angus I do developer relations and I talk to people about Minor protocol and tell them about building ZK apps with Nike JS I live in Edinburgh in Scotland uh there's a picture of me doing steganography so blending into the sign and also if you see the keynote like main stage presentation tonight you might see me in a pickle costume um so you can follow me on Twitter as well blockchainbeard um and you know send me memes that would be cool today the structure of the talk will be introduction to mina protocol and zero knowledge proofs we're going to talk about ZK apps how they work with with me now snarky JS that's how you build zika apps that's the typescript library and we had a program called ZK ignite which I'll tell you about but I think the applications have just finished but you can still find out about how you can get involved and some next steps particularly how you can get support for the hackathon this weekend um right my bags arrived so here we go thanks for carrying the whole thing up Yasin I thought it was probably easier than trying to explain to them like where the adapter was in my bag I've got quite like a complex packing system so zero knowledge proofs who here has heard of CK good lots of hands going up for those of you who are watching the Stream so I'm gonna do a kind of Speed Run introduction to zero knowledge proof just so everyone has kind of has the requisite knowledge to be able to understand what what zcaps are and how they work so it says here you can use your knowledge proof to prove and like verify information in in a private trustless a decentralized way so that's good for blockchains if you know anything about blockchains as well um a good way to think about it is um a good thing about what you can do with a zero knowledge proof you can prove to someone that you know something without revealing extra information right and so that can diff uh be different in different contexts a good way of thinking about it is the game wears Wally that's what the character Wally looks like he's called Waldo in the American version so there's this giant picture of loads of crazy stuff going on in this kind of big map and you've got to find this character called Wally and so if you want to show someone like prove to someone else that you know where Wally is you can show them the map or like the picture and you can just point to the the Wally character but then that person knows where Wally is as well right so then they can go and say to other people look I know where Wally is so the way to think about what you can do with a zero knowledge proof is you get the Wally map you get a a large piece of like white card uh you cut out an exact Wally sized hole in the card and then you lay it over the map so then you can show that to someone and say look there's Wally because you can see the little Wally character but you can't see any of the contextual information around them so you don't if you looked at the map after that then you wouldn't just be able to pick out Wally because you've not seen where he is relative to anything else um so that's kind of a way that you can think of what's your knowledge proofs can do and so there's actually lots of use cases that you can use during large proof for um something that people are talking about a lot is you know using them to to increase scalability and and do Roll-Ups and things for various different l2s and so also the idea of having a ZK VM where you can kind of write computation and prove it using Journal knowledge proofs it's also good for things like private transactions voting identities here identity of the sea uh very important in our digital world right the concept of identity and proving certain things about your identity but they're not revealing all of your information at once um is is something you can do with zero knowledge and just this idea as well of verifying computation right so the this is this is a slide as well we're going to take a look at zero zero knowledge proofs and compare them to some other cryptographic tools that you you might have used and take a look at the kind of um What's called the kind of pro tool tapes I think for how you use them so the uh something you need to to know as well about zero knowledge proof the proofs that Mina uses you can verify in constant time so it's very fast and you don't have to see all the inputs that somebody used to produce the proof so you can choose you can keep inputs private or you can make them public so that's something that's very good for privacy as well if you want to offer your users um privacy and not having to to make all their inputs to to methods public so here you go here's um you've probably used a hash function before so in a hash function you put some data in like as a string and then you get out this other string right and hash functions have a number of properties but the main thing that we're considering here is the fact that if you have some data and then you put it through a hash function you can verify someone else right you can you can give somebody else the data then they can use the hash function to and then so when you get the same string out then you know you've got the same data right so you can verify the integrative data with a hash function similarly with a public key signature you can take some data you can sign it with a private key and then other people can use the public key to verify you know this message or data has been signed by some private key right so then zero knowledge proofs right the way that they work in Mina is you write a computer program so you give people some code to do some computation and then they do this kind of compilation step and they generate this string called the verification key now when it comes to people using your code right so you give them the the code that you've written and they run this thing called the prover function so this is here in the middle prove you have a program that you're running and then you have some public inputs and some private inputs that generates the proof right the ZK proofs that we're talking about all the time so that generates a string that's the proof and then you can run the verification function which uses the proof that you've generated when you ran the computation the public inputs but not the private inputs and the verification key that you created when you kind of built your ZK app right and that comes out as a Boolean so you can verify that a proof is either valid or not valid Okay so hash function you put data into it but now what we're doing is we're saying using this um cryptography you can let someone prove that they've done some computation right that they've run some program so that's how Mino works right we use zero knowledge proofs to uh verify all the computation that happens all the transactions that happen it uses ZK so that's why the banner downstairs says the world's first CK blockchain it's a layer one built entirely using zkps okay and as I said already right zkps are great for privacy and scalability so Mina has a number of these advantages um verifying the state is very quick so it's it's constant time as I said so you can verify the state um and these proofs stay the same size and Mina has a feature as well called recursion where you can kind of use proofs as input to generate new proofs so the actual blocks in the chain are linked together by um having a kind of proof of their state and then that gets kind of put into the next when you when you generate the the state proof for the next block you use the previous state as as a kind of input so in that way you can verify oh the blocks leading up to the current block and it's very fast to verify so that also you may have heard that it's a 22 kilobyte blockchain so you can verify the state of your account so you need the the state proof which is like one kilobyte or so and then there's the metadata but with 22 kilobytes you can verify the state of like your account on the mirror Network [Music] um so and you can kind of you can sync a node um with just the the that small amount of data so that's pretty cool this isn't just stuff that we're we're kind of telling people about though there's people doing work the nil Foundation are working on this thing um this kind of way to take Amino proof and then verify it in the evm so then you can imagine doing a bunch of compute using um Mina you create a proof that you've done on this compute and then you can put that you can verify that in the evm and then take you know make things happen in an evm uh blockchain but do all the compute using Mina so that's going on we can link you to uh that it's still in research phase we also have openmina so this is an actual um blockchain node that runs in a web browser which is pretty cool so then if you want to you know build apps and and you know have users um use your your apps they can spin up a node in a web browser and they don't have to go through some sort of third-party uh service or or you know node provider or something so that's cool um so now that I've told you about ZK proofs and how Amina uses them you're probably wondering how can I build stuff with zero knowledge proofs as well and that's where we come to ZK apps okay so there's kind of uh the smart contract functionality it lets you build what are called what we are calling ZK apps but there are apps that use zero knowledge proofs if you've heard of ethereum if you've done development using using evm the model that that the evm uses is on-chain computation so you verify computation by having all the nodes in the network executing the same code and then they all get the same result right so in the diagram here you've got someone a user using this computer they want to use they call some smart contract method and then all the nodes on the ethereum network process does this um they run the the method and they apply the updates or whatever so you're replicating all that computation amongst all these nodes now Mina is different so ZK apps actually use off-chain computation and then on-chain verification so the way it works is you write some code the user runs your code produces the proof that they've run the code and then they mean a network will um take that proof verify the proof and then apply the State updates that the user wants to do by using the ZK app so that's quite different right so all the code is run client-side and then they're passing this proof in a transaction and then the proof gets verified so it's you know very different to the the evm um kind of model that that I I just explained so there are a number of advantages to using off-chain computation mainly privacy so as I said you can choose which of the inputs that users provide to Smart contracts you can choose to make them public or keep them private so that's good for privacy there's there's no gas fees as well in the way that you think of them usually so the the cost of using um the mini network doesn't scale with computation so you can do as much computation as you want and all you have to pay is the single transaction fee to send the proof to the network so in that way you can do as much compute as you want you just produce this one proof and then you pay a transaction fee for the network so no gas fees that's pretty cool um you can it's there's composability as well so um it allows you to do things you can you can design your apps in a way that is kind of modular but then also you can basically build your own rollups as well so this feature that I mentioned earlier called recursion so you can take a proof and then you can use that to as an input to another proof so there's some cool things you can do with that and I'm going to tell tell you a bit more about it link to another presentation um and then also the idea that because the State proof is small and fast to verify then the idea is that you can kind of verify that in in different places so you can use Mina to do compute and then verify it in in other places or in other blockchains so um just to walk through the kind of process that you need to think about when you're building zika apps um the way that it works is that compile step that I was talking about earlier when you generate the verification key you and you deploy your ZK app you you send this verification key to the network so here there's a box with a key in it that goes to the nodes in the network so this verification key is is public and that's what you use to verify the proof that people generate so then when a user uses your zika app here it's it's um hosted at michaelseekap.com so so they use your ZK app they they do they run the code with some inputs and then they generate this proof then what happens is they send that proof in a transaction and then the nodes on the network use your verification key from earlier and they say whether that proof is valid or invalid so if you have a valid proof there might be some State updates to apply but then if it's invalid the transaction gets rejected so Z caps are built of methods so if you want to build secret apps for the hackathon you're going to be writing methods um and there's a kind of diagram here and and it's saying that methods are have have arguments so so inputs you have smart contract state so you have a very small amount of unchain storage to store a state for your smart contract you have some values from from like the rest of the world so you know as a database or or server or something and so then when you run a method the the outputs are you can kind of apply updates to your smart contract state or you can apply updates to the state um externally as well so that's kind of what goes in and out of methods and so if you want to write methods you're going to need to know snarkyjs so snacky.js is a typescript library so if you want to petition to have it renamed as Nike TS you can argue um with people on GitHub about it so then it's the typescript library for for defining zero knowledge proofs so you can create um oh there's there's the low battery warning you can create uh prove and verify zero knowledge proofs so there's tools that that you already know and love if you are familiar with typescript so we have good integration with Visual Studio code intellisense which is very useful um and you can use tools like npm and just for testing so the idea of snarky.js is to make your life easier and to make it easy for you to build apps with using ZK this is the five-step kind of quick starter um so so all you have to do is an npm install um there's a CLI tool that is designed to make your life easier as well it can help you um setting up building and deploying your project and then we've got some flyers with this information on it as well so come to the booth um and you can get some otherwise this is in the docs as well which I'll link you to so you know the idea is here you can kind of get started install the the tools and deploy zcap in just five steps so if you want to write sorry smart contracts you need to know about field elements that's the kind of the numbers that you use in zero knowledge cryptography there's this concept of using finite fields to do operations so that's the basic you know of data that you need to to use you can store a number almost up to 256 bits and so we have a type it's Nike JS called field and so there's a kind of little example here of how you would um declare this constant sum in a programming language that you're familiar with already you would just use the numbers one and three but it's Nike JS you need to say I'm using the field type so then here that's what's here that's saying make a field give it a value one and then it's got a built-in method which is dot add so and then it's saying add this other New Field that I'm um creating here with a value three so Fields you have to use fields for everything that's just how the ZK cryptography works so we also have other built-in types again to make your license as a developer easier so things like um Markle trees public private keys and signatures things like that so these have built-in methods as well so hopefully you should be able to find types of methods to do what you need to do and if you think one is missing you should build it and enter it for the hackathon this is a quick um this is a the kind of the the basic example smart contract that comes with the CLI tool and so I was just going to walk you through it quickly these um at the top here I think if you can see my mouse this is saying so it's using the state decorator that's saying that you're you're storing this on chain so you get eight fields of storage frizzy cat and so here it's saying we're going to store a number in that state um you declare you kind of create a smart contract by extending the smart contract class you declare some um state that you want to store uh whoops I was trying to uh scroll down so so yeah so you declare the the um what you want to store on chain in the state and then here is some things where uh uh this is setting up the permissions for who who can do what like what and how how to interact with the zika app uh so you can read more about permissions in the docs so this is uh the init method initializes your z cap so here it's just gonna say this um state variable that we've we've declared um we're going to set to one and then there's an update method here that's saying we're going to get that um field from the state we're going to verify that it actually equals the current state and we're going to add 2 to it so then it's saying um add two and then this sorry equals this is this is kind of this method is is then saying we've added two to it and we're going to check that um the new state equals the Old State plus two so this is kind of thinking about what you're approving and then it's saying here we're going to set that new state so when you call this method then it adds to to the state and then next time when you look at the state there'll be you know number plus two there so that's a very basic example that's what a smart contract looks like um I said you earlier that I was going to tell you more about recursion recursion is a very cool feature of snarky death so this example has this card game here um nobody ever mentions it but so I thought I should start pointing out that it's probably the worst card game ever because everyone has exactly the same cards and I think isn't that one of the most powerful hands you can have in poker right so everyone's got like one in a million straight flush or something uh so if you imagine a card game a turn-based game you can um because you can take proofs that you've already created and use them as input for making other proofs you can have a player so player one will run the the kind of game logic and produce a proof that says I have taken my turn in a way that is valid according to the the rules like the logic of the game and they can generate a proof that says that they can pass that to player two and player 2 can verify the proof so they can verify that player one is taking their turn in a way that is valid they can then take their turn and then when they produce a proof that they've taken their turn they can use the proof that player one handed them and so uh then when they produce a new proof player three can check that player two is taking their turn in a valid way but also that player one is uh uh player one has taken their turn uh in a valid way as well so you can kind of Imagine passing around the proofs around the players um add Infinium or until the game ends and then also you notice as well that there's no blockchain in the middle here so you can kind of do this off chain passing proofs around and verifying things without putting things back on the blockchain until you want to so in that way um recursion lets you do a lot of cool things but you have to think about things in a slightly different way um here's a couple of examples of things people have been building on Mina for our ZK ignite program so people are doing l2s to enhance privacy and scalability someone's made a keyless wallet so uh things that use social recovery and Shamir secret sharing so that's pretty cool and someone made bio snarks which is to do with sharing data in the Biotech Industry um and verifying things as well without key while keeping sensitive information private so there's actually a whole list of loads of different projects that people have been building for for our ZK ignite program we can link you to this kind of list and you can look at that and see what kind of things people have been doing and how they've been doing it for some inspiration uh next steps for the hackathon if you want to build stuff come and talk to us at the booth um we'll be there uh to answer questions and talk to you about your ideas the docs have all the information there obviously that's doc.mino protocol.com we have um aziki apps q a channel on our Discord server which is full of people who are really responsive knowledgeable and helpful so if you have questions technical questions you can go on to the Discord server it's discord.gg slash media protocol I think that QR code goes to Discord as well um and yes so you can answer ask your questions on there there's also the each Global Discord server we have like Mina sponsor or sponsor Mina Channel um so you can go on there as well and ask questions about things you're trying to do or you know um book a slot to kind of meet someone at the booth or something and also you can DM me on Twitter blockchainbeard that's really just something that I put in there to try and get more people to follow me so uh thank you for listening and if you have any questions we have about five minutes do we no I've I've got a timer that so five minutes yes five minutes hello no so you don't have to you can you can verify the proof off chain um but if you want to change the state of things on chain then you need to send it to the network and one of the nodes needs to verify the proof that you've brought a z cap any other questions okay you have to wait on how to how the recursion was selected part of a smart contract s other television how you cope with the projects yes so I think uh I will answer that question by saying you should come to speak to us afterwards because we have to finish but we can talk to you more about about how to think about recursion and and how you yeah write the code for it and if anyone else is interested come and speak to us as well or see us at the booth thank you very much everyone foreign [Applause] okay um hey hi everyone um my name is Nick so I'm going to start I have a back-ended one inch so today I want to talk about our latest Innovation it's about an inch Fusion maybe you are familiar with uniswap X right now so we had it before it was mainstream and let's start with some small introduction uh vanish actually was is one of the leading projects on the market avanish was started at lithium New York at the same haircut as we have right now almost like from ethereum Global team at 2019 by two members right now we have several protocols and we have about 2.8 million users actually a bit more and now it's about 3 million users we have like billions of volumes going through us we have we are leading the ex aggregator and not only that aggregator we have multiple other protocols um we have aggregation protocol limit order protocol one inch Fusion protocol and also we recently released Financial developer portal for the developers to make it easier to use apis with no limits and more adjustable limits for them as well and also we do have a non-custodial wallet on IOS and Android so let's recap what is vanish aggregation protocol is basically Valencia aggregation particle allows you to have continuous swap like experience but with the a bit better rate because we are trying to aggregate liquidity across multiple decks as not only a unisfa but across daxes like curve balancer and about 70 more basically every time you're trying to make a swap we are trying to split your initial token Source token like one inch for example in this example to some small small subpaths and actually trying to actually try to pick the best payer token connector token so like let's imagine that we have a one inch token and we need to go to get some dark token in the end but we try to build a path across wrap Bitcoin or like rapt ethereum for example usdc and only after that we go to the die and the logic of that is because we want to minimize the slippage we are trying to aggregate all the pools rates across multiple dexes and find the way where the red is a bit better so is the best strategy if you want to get lower slippage on the markets we have about 220 million volumes during the day actually all the analytics about aggregation protocol and all our protocols is open source you can check this out on General analytics one inch basic.com one inch basically yeah it's quite transparent here we have a little smaller volume but I made this screenshot like at 6am so it's a bit yeah it's a bit smaller um how varnish protocol aggregation protocol Works basically is as a developer it's quite easy to integrate that basically you need to fill some data it's actually for Source token destination token and the source amount of this token we have an API for that actually it's a backend algo that calculate the best path but it's executed on non-casterial Smart contract basically so it's also verified and now details so by about seven companies first you need to make a quote basically you're trying to understand what will be the return amount from Source token to destination token if you are okay with this HR amount you basically call another API handle called Swap and it will return to you the call data that you need to execute with with on-chain transaction to the running aggregation router this is quite simple and that's how you can integrate Financial aggregation protocols okay actually or you can also try right now aggregation protocol on developer portal without no with no limits it will be pretty adjustable it's just it's our latest Innovation so latest API aggregation like latest API for developers so check this out please we also have boundaries for that today okay we talked about the creation protocol I can say that it's one of the best way to sell something on the market price if you'll try to compare something to the decks like to do taxes like binance it's like the best it's like market sell for any token so it's just one Atomic transaction with the best potential path but it's only market sell but what about limit orders when you want to specify some Target price for any token and you just want to wait until it will be executed it's a bit more advanced and we do have a limited other protocol for that that allows you to do a lot of fancy things for example you can it's all it's first it's gasless so for every user you don't need to pay for gas because basically you don't do anything on chain except approves of tokens sometimes also it allows you to do additional callbacks for example you can use post interaction methods to withdraw some liquidity from Ave for example and only after that interact execute this limit order from part of the user um it's one of the most optimized protocol on the market it's open source as well it's also outdated and right now it's a part of aggregation router like contract so uh let's try to understand how it works as well so from one point we have a user basically user do very basic logic it needs to build you just need to understand which token you want to swap you specify the conditions for swap for example I want to sell if one ethereum for 2000 die and like I have some time constraints for example for one week and what you need to do just create this structure and sign it from your private key and send this signed transaction with the structure to manage limit other apis and that's it uh you can do it with our front ends we implemented basic functions there so everyone can try and try that can try that out there okay and another part we have a kind of professional micro Market taker who is trying to fill these transactions this is the entity who is trying to pay for gas on chain and actually this is the entity who can make some profits from that potentially we also integrate this Market taker to our aggregation API as well so every time somebody is trying to swap something they can also execute limit other protocol limit orders as well on the aggregation part anyone actually can participate in that and be like a resolver or taker there but there is an issue that it's a you need to understand how it calculates like the how to calculate the exit price so you need to take care about the gas price that we will need to spend to execute the order yeah um why I'm talking about that is just to understand how we are what we have been talking right now that we have a market makers that basically the users to create something and send it to like to like to the entities and the market takers that trying to execute these orders from like trying to film disorders and get some profits like in this case usually Market Tech is it's like developers it's professional like some companies that doing that and makers basically users who have interface for everything so um this is like main scheme how it works so we have users that signing orders signing sending it off chain and some takers that getting a disorders of chain and executing these orders on chain and there is a verification that everything is correct with the signatures and all the rules on this on chain as well so it's kind of permissionless we don't care where you get this order we only care the like the structure and the data there so that's how a limit order works but there is a small issue that's it's not very comfortable for users because you basically want to sometimes to sell on the market side but we have a lot of issues right now with me for example with attacks like sandwich attacks on multiple blockchains it's also quite expensive and it's but you bet you ask sometimes because of the gas prices so we just questioned us ourselves what if we won't try to solve all of these issues at the same time what we want to sell on the market price but we actually don't care to will be one Atomic transaction we want to have like just the best market price during some small small time interval like five minutes for example and we also don't want to have some issues with me for attacks for the users because it's extremely painful to explain them what is what is that how to be protected from it it's quite hard to be natively protected but we want to make it happen and also it must be gasless because it's one of the best experiences that you can get potentially sometimes so we are trying to build something like that and actually this is a one inch Fusion it's a product that helps you to have the same uni swap like experience or previous experience with aggregation router but it allows you to have gasless execution need protection by default and basically in some cases it's almost better prices that we have on the markets because we you have almost Limitless liquidity there because any resolver can accumulate that just a small example for example you're trying to swap this is actually the real real life transaction uh it's free free for like three thousand ethereum profit theorem to use DT um so it's actually a Dutch auction that we have at the same at unit swap X that allows you to have um during some time interval the price is going down we're starting from the price that is a bit more expensive than on the markets and we are waiting until somebody will be starting to feel it the main point here that there is an open market of competitors they're trying to fill it and the the motivation for them to execute this transaction is that when it's going a bit more closer to the market price they are trying to Arbitrage that and get some profits from the from the Arbitrage and yeah so basically that's the main point of it and because of the open competition not because it's one on chain on chain transaction because it can be multiple limit order transactions that field that will be executed for one order we have a bit better prices and yeah basically that's the main sense of it we also recently tested that V5 11 000 ethereum as well it was also executed better than one on market prices before launching transaction so but this Fusion is very useful for large trades so let's talk a bit about gaza's execution so as I told before like makers basically say do the same as they are doing on limit orders they're just signing some transactions some data that is off chain they don't you don't need to pay for gas except you need to make one small approved one each contract from the token usually most of the tokens support pyramid function so it's also gasless per approved for the contract uh after you do the after you did repair meet or you are made up unapproved you just need to sign this transaction the auction and set it to the back end to the limit of the storage and after that it will be actually shared with the resolvers with the entities they will be fighting for your order trying to fill it and they will be paying for gas so as you can see it's a bit gasless but it's not gas free so actually every user will need to pay a bit in gas but not directly with ethereum but with the gas rates during the execution of the trade so like every year is over we'll be executing this transaction not on the market price but sometimes a bit below because of the gas price then how it works we don't have any magic that makes everything executed for free that's like there may one more that's the case here let's talk about beef protection so it's also not that simple because of course users don't need to think about that right now because we don't have any any unchain activity from the user side but we do have on chain activity on the resolver side on the market taking side so every resolver needs as a professional we do ask him that resolvers on our side like in one Fusion are professionals that actually know how to handle math attacks and in this case they have issue with myth attacks but users don't have any decision so we are trying to focus like to trying to allow professionals to solve these issues not users and it's pretty simple point about limited security basically because we have a price auction it's about like about five minutes it's pretty customizable let's imagine we do have some not very liquid token for example some coin and there are some cases when you want to swap this current another coin if you're trying to do this on some Nexus V1 Atomic transaction it will be pretty high price slippage because let's imagine it's not enough liquidity on this chain but there are some liquidity for example another chain if you have a price auction during like 11 amount like minutes of time some resolver can try to Arbitrage this liquid to bring this liquidity for example from Cross chain and execute this order on better prices that you will have if you'll if you will do a one Atomic transaction this is like the main point of auctions that you can accumulate resources during the price execution you have enough time for that as a resolver that's why we have a bit best the best possible issue like solution for slippage that is like we can imagine right now so the main picture actually looks like that basically users just need to do two things sometimes they need to give a permit or approval to the one instructor contract and sign that off chain order after that it goes to database shared with the resolvers they are fighting for this other and executed using vanish aggregation router as well uh actually it's quite easy to become of an inch resolver we have a pretty long like digitalized way how you can make it or one thing that you need to do is just through register as a resolver on the smart contract side and also you need somebody maybe some entity to stay to be to delegate you some unicorn power actually it's a staked one inch token that allows that will bring you to the top 10 resolvers who will be executing the order from our system so if you want to execute orders of Market takers of users of one inch you just need to get a bit on the top 10 of resolvers if you want to be in top 10 you need somehow to motivate the users to delegate to your pool and their system works like that you basically can motivate them by sending some token right now it's only one inch token to the full Factory and users will have motivation to stake delegate the tokens to your factory and they will get some rewards on that automatically so it's an open competition who will be on the top 10 that's like the main reason why um they will like that's the main point so that's users will delegate to the only entities that have the maximum API and if the mpy changing they will redelegate to other engines here that's why it's always kind of not a very good they they need they are not forced to send reverse but they need to compete with each other for that so that's like an opposition how it works right now there are two options how you can work with vanish Fusion basically the first one trying to integrate it into your app the app or like any D5 app that you that where you need to execute like any swaps uh it's quite simple you just need to have an Fusion SDK uh right now we have it on typescript it has one of the most popular languages in the market right now and there is one more option it's a bit more advanced I'm not sure it's quite useful for the hackathon but it's still pretty profitable as if you want to build some business or doing some Market making it's just become a resolver from each feature Fusion as well so um if you were interested in becoming a resolver you can talk to any Our Community member here we have a large Booth so yeah just talk to us and also if you have any questions to run infusion to integrate it to interject it you can just ask me later um right now we're trying to code um just yeah this is like we have a vanish Network documentation here with SDK I will try to cut a bit I actually made a small Reaper with vanish Fusion 101 you can just scan it basically it's everything what you need to do is there uh what I will try to show some live examples right now like uh right here but uh you will not have enough time you can just launch it on your own only one thing you need there is a Json RPC endpoint there is a default one there but maybe you'll need your own custom endpoint and one more thing you need some ethereum you need a basically private key there if some equivalent needs to execute transaction ethereum chain on any or any other chain basically you can switch between between Network so yeah I'll try to do some live example how it works and just explain how vanish Fusion 101 Works um we'll try to like basically try to emulate the case as a developer trying to integrate when it Fusion to its own app um yeah it's pretty on node.js right now but let's imagine you'll try to use a front-end like react or something else I just don't want to focus on that right now on the user interface part because we have quite not enough time so um we do have a pretty basic structure here I like I will try to make it a bit more a bit more visible one second please um so uh you just need to open index.js file index test file to see the main default picture basically what we do we have here uh we do have uh flow where firstly you can potentially make an approve of source talking to the one inch contract that you want to swap that's the first step so if I will pull through a little bit it will basically just make a user20 approved of Advantage contracts that's the first step that I just automated the second part is more interesting part it's trying to make a quote from using one order SDK basically a quote what will be the return amount for the source amount of tokens and the last part is basically do the swap basic crazy increasing like Fusion order that will be like actually a real transaction it will be off chain but it will spend some resources for me up like from your account and yeah in the end of all we're trying to search for all orders that we do have on this address through actually just just database so this is like the main three things that you need to have checking the approve doing that approved for the specific token also quoting some data and after if you are okay with this data you can execute the Swap and after that you can check the all history of these others this is like Basics that you need as a developer to integrate with an edge Fusion so um if you if you take a look on the config site I'll just just it's just simply PC simple like example I just put everything here uh it's not like production ready code it's just like some ideas brainstorming so we do have here some Hardware tokens I will try to focus on ethereum right now uh so I just picked Network ethereum here I have some hardcore Advantage token amount that I will use for quoting and potentially for swap if we have enough time and yeah I have my private key hardcoded as a ND variable I will not show you my private key but yeah you can just put your own later um so let's try to basically run something I want firstly to run a quote and trying to take a look what will be the return like return from API of the quote uh so for that I just hardcoded some variables for like winning variables to not to do everything at one step let's just do only quote so a proof and swap is false and quote is true let's learn some code so we do have here basically the quote it's the first part and lower we just have a history of all orders on this account like let's take a look on the basically the return like the return amount and the structure that we do have we do have from running GPI for the quote what is important here and how do we can like work with that later so basically it's just Json file and it's quite large but we don't actually need to focus on everything sometimes we need everything but the main things that we need to see here is basically presets presets is actually the hardcoded way ways how the auction Works uh we have price formulas for you so you don't need to calculate it on your own it is possible to use a custom price mode on auction but it's not available quite soon I think and the main point why we didn't do this right now is like yet it's because it's quite hard to manage the risk in this case and the custom preset is quite painful and you can lose some assets there or it will not work as expected in some case you need to be sure that you want to specify this uh like the parameters not as default ones for like for the execution so in most cases it just doesn't you don't need to do this so let's take a look on the presets and basically the main point here is that we executed a quote for swapping 101 inch tokens to some wrapped ethereum and this is like the return amount that I got here it's calculated in way let's try to understand how like what is the real number here I'll just open Google for that so this is the amount that we got from the quote and we can just double check that we have something the same on the front of orphanage for example so let's take a look how the front that works how what will it will return for the same amount of tokens so we will pick a wrapped ethereum and the swap will be from one inch so it's 100 Advantage tokens so the return path is quite the same at the as weak as we have here it's like 0.0178 yeah it's quite the same at Precision just is different here we are not showing all the numbers on the UI right now okay so right now let's imagine that we are okay with this trade and we still want to swap some one-inch tokens um let's try to make an approve so basically as a developer what you need to do is just to understand the two token amount from The Source token amount that's actually the price that you will get the destination of the destination token in the amount of that there are some additional data about that you have you can see the prices like from token that like in USD in two token of that like the like for Pure one token actually and the volume of that in USD as well and we do have a parameter called recommended preset it's basically the you can just use the recommended precell by default it's quite often it's a fast preset for the first pops when you have a small amount it's pretty easy to do fast swaps because the price auction is the longer it takes the harder the price formula works and you need to do something with that uh because it Go the price can go down significantly if it's not a fast preset so let's try to execute this order and during the moment when I will be doing that I will be happy to answer any of your questions so if you have any questions just raise your hand I will be trying to swap at that moment can you do a transaction like really thought another group on the abstract contract so yeah it's quite possible right now it's not possible in the in the interface but the using the our code the source code that is MIT based on the GitHub basically can use Smart contact like not only externally owned account but my contact on account to do execute the swaps it's also it works for aggregation router it works for Fusion because it's basically what is Fusion it's it's a fusion of aggregation router as limit order basically you're just creating a limit order and in limited it's quite adjustable protocol and you can do whatever you want there you can use externally on account non-exterity on account you can actually not only execute limit orders with us Adventure tokens but almost with any entity with any token for example with NFC tokens actually you can Implement what you need to do to make it possible you just need to implement a transfer function for the limit order there are several examples in our documentation in our GitHub I just recommend it to everyone if you want to try limit other aggregation protocol or like a fusion SDK you can just also try to take a look on the tests of smart contracts there there are multiple use cases that sometimes are not public for from user interface but they are already written so you can just use them as a starter for your for like for your for your case for example that he increased the time on the on the Autumn they like faster than this lower one you'll get a better price uh it doesn't work like that because the price constantly going down if you will increase the price then we will try to make a formal more complex because because it will be going down more slower because yeah you have a minimum amount that you will return so the auction works like you'll never go go to zero it's like some between some price intervals but because of the market it's it's kind of predicting how it works if the price goes too much uh down during long amount of time you'll get you will just wait too much and you'll get uh you'll not get enough tokens it can be it can be failed basically like when we start an auction we're trying to understand okay what is the market price right now let's imagine like 2000 ethereum and we are trying to say okay the starting point will be a bit more above of the market price and let's imagine what can happen what is the minimum return amount that you want to get what is the minimum the lowest rate if you are okay with for example it's like 1 950 for like die for ethereum so during this interval you are okay to swap so we have built a price auction like a function with the that is going down to this to this amount to this rate and let's imagine we have a 10 minutes what will happen in this 10 10 minutes is quite hard to predict sometimes the price going down too too fast and if it's below the 900 1950 if you remember 1050 let's die you will just get nothing because it will be not profitable for resolvers to execute execute the transaction so it's not a fact that it's not statement is sometimes it works like that it just can if you wait a bit more it is quite possible that something can grow better but it's not a guarantee that it will happen so like the interval the more you learn the way the more your weight doesn't mean that the price will go to your like to your interval like to do your Target price yeah so the rest will be not definitely better it can be it depends on the amount of money that you have if it's a large amount of money like for example let's say like 100 000 in this case it's much more better to wait a bit more because of the volumes the reason for that is that basically resolvers will need more resources to accommodate uh like like to accumulate to execute this transaction if it's 100 it's quite easy but it's a life it's a large sum they need somehow to Arbitrage that and that's why sometimes when the price like is is the the auction time is a bit longer that's why sometimes the price is better for the watch amounts but it's only worse with flash amounts mostly and there is no any guarantee actually uh sorry our partial Fields possible uh partial fuels are possible with user mods so yeah that's one of the main points for how you can save on gas as a user basically it's of chain transaction for you and its own change transaction for resolver but actually resolver can budge multiple user transactions into one on-chain transactions that be so basically they share the gas price across multiple transactions a bit more optimized there are multiple ways how we optimize that that's why auction is a bit more gas profitable for the users they are also matching others sometimes so it's a actually quite efficient on the it's like economy of scale the more users we will get will have the batteries will be working and the more cheaper it will be working for the users yeah I just want to comment that we just executed the transaction so this is we have as a result of execution executed transaction and we have actually several uh orders in the history before it was one and now it's two transactions we'll try to take a look what happened on this account uh let me if you have any questions just ping me okay so yeah yeah let me show it again so basically yeah I think I can modify this picture later but basically here um everything started from here this part like if the limit orders part is on chain part it's actually that's like the line here all here is on chain because there is always a few transactions using one inch Network to the using agreement orders to contract basically and makers basically users are trying to make a proof to the Limit other like contracts as well this activity happens on chain and everything else the matching they're like accumulating and all the calculation whatever is profitable happens off chain basically what we do on chain is me we're trying to minimize the efficient like to maximize the efficiency of the context trying to do as minimum as possible on chain the minimum you can do is just to verify that is the the verify the trade is okay and just execute the transaction just send the funds that's like the minimum you can do on chain okay I think we can find we can finish thank you for everything yeah I will be open there so for any questions thank you [Applause] I think I think one of one of our things great all right uh thank you so much for everyone being here so my name is Tom and today I'm going to pretty much be talking about mobile first and this workshop and just general overview is around why we should be building on mobile and pretty much a quick example app of how to build a web 3 mobile dap with wallet connect cool uh so just as an introduction for myself my name is Tom I lead devrel um relations at wallet connect and spent several years as a mobile engineer prior to this hence my interest in doing a lot more mobile development at wallet connect cool um so for those who aren't as familiar with wallet connect um the simple way to put it is we're a protocol that enables two parties to connect um and the two parties we essentially have is daps and wallets in this space um and we're encrypted trustless open source and chain agnostic so we started several years ago one single QR code and now we would say you know several hundred wallets power us and many dapps use us onto the code so we really try and facilitate connections between the two parties I.E wallets and daps so that's maybe how you might be knowing us and I might want to just quickly touch on what we've been working on recently and how this kind of relates to our hypothesis and reasoning for mobile cool so just as an introduction so to further extend maybe give you Insight that um you know while the connect is more than just a QR code signing protocol and also a common question we get is is wallet connector wallet the answer is no we're not a wallet we're a wallet infrastructure and adapt infrastructure kind of like as a communication protocol infrastructure and these are the things that we've been busy on recently um so web3 wallet is something that a lot of wallets I guess use under the hood um and most the 300 400 wallets that are out in the space that we power um they're the ones that using that one so this has a lot to do with chain switching and things like that that you might have seen recently um and then web3 wallet modal is kind of the part that we want to talk about today particularly around dapps so every time you might have seen a connect wallet button and a QR code that's kind of the core product that we started with so A lot's been happening in that space and I think more recently you guys have might have seen communication sign to happen within web3 so I did a talk on uh mobile mobile wallets the other day and it's kind of interesting in that we started in 2017 2018 particularly with say a wallet called Toshi wallet also known as coinbase wallet and they were actually doing messaging four years ago they actually kind of stopped that and now it seems like it's kind of opening the floodgates of that so we're also work in the works around web3 inbox so web3 inboxes around push notifications notifications and chat so this is something that these are the product Suites that we've been working across and particularly wanted to focus on web3 model today cool uh so web3 model there's some I guess some Alpha of what's coming up it looks very different to what we have right now um this is the direction we're heading in um so you might be very familiar with connecting with metamask connecting with Mo coinbase and any of your other respective favorite wallets um so this is what web3 model focuses on um and pretty much every wallet you have out there whether it's a cloud-based smart contract based uh web-based mobile based they're all available through web3 model these days and we're going to be extending it further with other features new UI and today I want to particularly talk around how we're going to work on the just do a demo on the light version of why how quick it is to spin up mobile development these days cool uh and just since we're all here for hackathon and to win prizes I think that's all we're here for um of course but to learn so thank you for being here so we have around 20 grand of uh cash prices to give out this week a weekend first one particularly around mobile that's kind of what I'm speaking around and we've got some documentation all across all of this but we've got six grand for web3 mobile if you use react native floodus with the kotlin to spin up adapt I'm going to provide some prizes around that Innovation this is our first time doing this track and six grand around that so if you're interested to work on ZK proofs the ZK snarks and then use wallet connect as a connection through that there are many great ZK evm kind of blockchain systems out there so feel free to use that and another topic that you guys might have seen is 6551 so this is around tokenbound accounts and it really relates to to the wallet space if we talk about wallets right now everyone talks about AAA account abstraction which is great it's another form of onboarding and personally another one that I'm interested in 6551 token bound accounts so the tldr of it is if you generate from tom.eth you can and then you you purchase say a a crypto Punk or whatever then you can that is kind of as generated as a token bound nft Wallet account that you can start to identify yourself as okay this this Punk now gets you know if you think maybe more around loot I think that's a bit more plausible it's kind of like a composable way to build your inventory and identity so really excited about that authentication so this is something uh like really interesting Partners like Instagram and stuff I've used to kind of verify okay I am 0x123 connect sign and authenticate so it's a really simple API and really encourage you to do that and the last one is for those who aren't developers actually here and we're doing a design track of our Cloud app looks a bit Bland can do a lot more Improvement so feel free to drop a figma and trying to recreate like how to do user design flows and so that's mobile innovation of in Cloud and then we have a pool prize of anyone who wants to just work on web3 mode or web-based stuff you'll be in a pool prize for two to 200 bucks or so so that's that and yeah so I kind of wanted to to go around and thesis around mobile um and it actually might work to talk about the wallet dap Paradigm first so uh wallet connect has an extreme pleasure uh to talk to every single wallet out there to talk about to talk to every other dap out there um so yeah every day we get to talk to them we have to understand what they're facing um and I don't know how much you guys have talked to while it's in this ECC week but a lot of them have just been like well it's other problems wallets are the problem towards the Gateway and stuff like that and they're like there are three camps actually around the future of mobile there's strong pessimism of like oh well it's aren't doing enough and innovating fine if you want to take that camp we can stay there there's the other one of there's going to be a super wallet uh this kind of around this thing called the fat fat wallet thesis by a16z a while ago and it's kind of like hey there's going to be a few wallets that are just going to do really well and then unlock Innovation for us and then the third Camp is there might be really Niche wallets out there that are really just specifying on chat nft and all of these things so there probably are many other hypothesis of how personally they don't seeing how wallets have been talked about but the thing is the we also have to focus on the DAP Paradigm is why we're here for the use cases if people are part of my French are going to on while it's not being good enough there also has to be better use cases within the DAP Paradigm particularly on a mobile-friendly environment um so that's kind of what I've particularly seen a lot around FCC more recently is sure there are problems on wallet we're fixing with onboarding AA and all these cool other bolt-on features we also have to start now focusing on the DAP Paradigm it's kind of a chicken and egg problem so here at wallet connect uh we really started on mobile first we figured out a way of how do you connect your browser to your wallet about three four years ago and now we just really want to extend it to like how can we make this even further how can we make this connect wallet Button as seamless as possible how do we make actual better use cases out there so that's currently our take and as to why we're really focused on mobile um as long so alongside like multi-chain and a lot of these other things so that's currently our stance that we really want to help innovate and provide better Dev tooling for both sides of this spectrum right on this wallet and dap paradigm cool um so just before I get into like the demo and the the development of things so you might have seen this as web3 modal and what we do is we're really experimenting a lot more um so this could be considered the full version we're going to be releasing social login emailing and pretty much you can access all of your wallets um and wag me as a as a library ethers and we're making as composable as possible and for the sake of Builders and hackathons it's much easier to use our light version It's kind of just think about the skinnier version that allows you to bring your own Library allows you to bring your own tooling and have it go there so that's just some distinction just to give you more clarity if you do read our documentation cool all right so I this was kind of taken from a previous thing and that I think we really need to this kind of actually is the wallet and dab Paradigm actually onboarding is dat wallets let's just think about the left hand side is more about wallets and the right hand side is dapps right so we really need to start thinking about like cool account abstraction AP MPC uh Web author and all these cool things that are coming out there are great we're getting there we're getting to a better place but like that stuff needs to be fixed for sure but then we have to start thinking about the DAP features and that's where we're trying to bring more tooling into the DAP side of like how do you financially read and write through staking and all of these like really cool ideas that you guys are going to hack on this weekend how do we innovate more on nfts or onboarding in in that same Paradigm so maybe tokenbound accounts namespaces identity you know the ZK identity uh with like sismo and then there's like ens lens dids disco all these cool things uh transaction simulation those are copy paste but multi-chain I think that's also something we've really missed I failed to see many good multi-chain applications either on the wallet or dap side and I think it's because we're still figuring it out and right now with the whole L2 summer or whatever we want to call it l100s however many else layers were going to go down like we really need to focus on this um so this is why we're really trying to encourage the these dap features cool um so yeah this is on the right hand side is a GitHub uh GitHub repo of an example we have that I built out so this is the most relevant thing for the hackathon if you end up wanting to build a react native uh wallet connect modal um so just as an FYI I'm not leaving out any native folks out there there is there is kotlin actually there is uh Aya Swift and then there is a flutter so I'm not trying to leave anyone out there but this is just for the most easiest spoilerplate thing and just as a general thing of like development out there wallet connect we across several sdks we do Unity even um and yeah like uh this is just for react native react native seems to be very popular within the DAP framework and wallet framework so that's just also a heads up if you're willing to bootstrap in that Network so that's just the GitHub repo hopefully that worked um so this is our one-liner um of course it's like uh pretty pretty bland pretty quick there are some polyfills that you need to do and this works for react native CLI but also uh for Expo we're actually thinking a lot more and optimizing on Expo for any react native developers out there as as a mobile developer three years ago Expo wasn't there but now we're really in a place where I can just spin up an application for react native and mobile get it done very quickly so really bullish on Expo and how we've done that so I might quickly show you a demo before I get through all of this code snippet um so I am not going to risk doing a live demo because the Wi-Fi and even though I love Expo development um I think it's just going to take a bit of a bit of time to um compile um so yeah so left hand side some code that I'll go through in a bit so the right hand side is let's just kind of assume this is the simulator so if I go back here it's just some tutorial it says that the state of it is not connected and then we want to go through the connect button so it's just a pressable function very simple can you guys yeah you guys can see it yeah let me zoom in on the code for a bit later um so yeah pretty much just clicking the connect button um this brings up a UI you can bring your bring along your favorite wallets that you use these days probably minimize trust or whatever else that you use pretty much click into it um then I pick trust wallet enter your code whatever has your address 0x6 something redirection and voila so I think if we can get to a state where we're easily figuring out how to do wallet development in a very seamless manner I think that's the goal um and not there are probably more JS web developers than JS mobile developers or even native mobile developers and and that's the short truth but I think what I want to pause and think about is that if in three years we're still using metamask extension as the first onboarding for your grandma or your like child or your friend like we've kind of messed up so I think we want to get to a place where we're trying to push more and kind of ask for like better ways to do handling of mobile and just ranting on and thinking about it there's like better ways that we can even handle keys and do like upclaves and web off and through like face ID and Native account abstraction all these things so like they're really cool things in the mobile space that are happening and I really wish that we moved towards there because once again in three five years if the majority of us are still onboarding through metamask like window.etherium we're kind of messed up so that's my personal take um so yeah that was the connection I believe it kind of restarted just take you through the whole flow again great and then you connected so that's your Xerox address and then I can press the disconnect button and then from then on so this is the boilerplate for those who are in these platforms you can use something like ethers or or uh VM or wag me and there are other native libraries for Swift and kotlin um that you can use to help you think about the use cases so it kind of comes back to this how do we feel build better use cases out there so that we can work with this whole wallet and that Paradigm of things cool so that's that um still keeping it quite short um so going back here so this is just essentially the wrapper of the schema that I wanted to share um essentially you'd be just importing a wallet connect modal just as a UI component project ID so that's through Cloud so that gives you better tracking and measurement and just understanding about your project and then there's dap side um exporting of the function going through it opening up the modal and just injecting some data so what's the name of your dap description URL and redirect so this is something I want to point out for our mobile developers out there or anyone if you don't redirect your app people are going to get pissed off so please do that like um you you need to actually really figure out like you know just doing these schemas is really essential a lot of even the top wallet out there does not do this very well so please handle these kind of things so like you saw when trust quickly redirected back this very important so it's something to take into consideration cool uh this is further extending the code of it um and the most important line is um const open and use wallet connect modal hook so we just made it really simple and we give you the power to think more around the provider and stuff like that so opening function disconnect function is done through the provider is connected as a Boolean address so pretty bare bone stuff that we've given you and really don't want to complicate uh mobile development for anyone um so the the function of handling that's pretty self-explanatory and then we just use the hook um to to open so that's that I'm going to do one quick like run through all of it just in the vs code format so you kind of understand where everything is happening um so yeah so very typical if you understand JS it should be pretty self-explanatory if you haven't done react native project ID um go get it yourself providing the metadata of what you do that's fine here I imported the use wallet connect modal um just through the top hierarchy um here I can I know if that books I don't know if the internet is great but these are the other parameters you have I think I've exposed most of them so this is what we have great um and then all you have to do is wrap it really with this and then you can handle the rest of your app so if you want to navigate and do that do this as the top hierarchy then some very very simple styling so yeah um that's the code there uh I wanted to wrap things up and cool uh yeah so once again just finishing it up um really encourage you to kind of think about when people are talking a lot around wallets daps and all of that there's really this negative camp that I'm really feeling as a sentiment wow while it's on innovating so let's really try um figure out how can we encourage better adapt development as well on mobile so that people can feel more reassured okay these wallets are having actual good use cases so it's a chicken and egg problem but I really encourage you guys to to give mobile a crack if you have the opportunity but if not for the rest of the hackathon feel free to innovate on different different sectors feel free to think about authentication or if you're a designer think about the cloud so I wanted to wrap it up and uh for us at wallet connect we really think the future is built on mobile so thank you and these are some documentations [Applause] foreign [Applause] yeah yeah go for it uh if you want to do uh ZK snarks of token bound accounts built on uh react native go for it yeah yeah qualify for like both prizes yes that would qualify for both prices yeah so if it's Innovative enough and you build say a react native app but it also exposes token bound accounts and this and that uh you could technically enter in the two trucks oh okay yes thank you are we good to start yes okay cool okay cool hi guys I'm Emily I'm the developer advocate for Linea if you guys haven't heard we launched mainnet on Tuesday big round of applause um so I mean this Workshop is not so much about building but more so talking about where to build and why you should choose Linea right um I'm not sure where we sit in terms of the technical background from this group so I'm starting from like Ground Zero um if you glaze over in the beginning that's totally okay but we'll get into something more complex later so anyways what is Linea so Linea will be a type 2 ZK roll-up right now amongst the ZK roll-up space no one is actually type 2 yet I'm going to explain this later but keep in mind that this is what we are so starting off why do we care about l2s right so if you've heard of the blockchain trilemma essentially it's a pick 2 situation between scalability security and decentralization um ethereum basically has chosen to focus on security and decentralization and with like the boom of ethereum you guys have probably experienced high gas costs and transaction times being slow because all of that is like a competing kind of computational cost so what do we do with something called like a layer 2 solution we've moved up to something called the roll-up Centric roadmap uh what that means is starting from a layer one it's basically the underlying foundation and base blockchain that's where consensus happens that we're data stored the history is there um examples Bitcoin ethereum Avalanche Etc once we move into Layer Two this is actually what we care about so layer two's uh work by pulling the execution um computational I guess capacity off of ethereum the important part to clarify here specifically is that Roll-Ups have been the I guess decided solution because it posts that data back to ethereum so if you guys are familiar with like polygon proof of stake so you might have heard you have polygon proof of stake that's what you know that's like an open C Etc versus polygon ZK evm which came out recently polygon proof of stake is a side chain it is not a layer 2 solution all that data is stored within polygon so that's why kind of we've you've seen this pivot towards roll up so because it is a much more secure system to leverage the consensus mechanisms and Community around ethereum uh that like a separate alt one uh alt layer one or a side chain would have um anyways so that's what a roll-up is uh how does it actually work so the anatomy roll-up has well and the anatomy of an optimistic roll-up has kind of this structure of there's an on-chain contract so that's not going to be on your L1 that stores your roll-up box blocks that's where the data is stored it monitors updates the next piece is the off chain VM so this is where the computational uh stuff comes so that's going to be what you hear of the ZK evm which we talk about later and the last piece I I kind of group them up together but operators validators aggregators sequencers you can kind of think of this basically as the entity that takes in all that transactions orders it figure out what is going on and then post that data back um so moving on I'm going to name two key vocabulary words you need to know when thinking about the different types of Roll-Ups right so specifically we have the deposit process so that's moving uh East from L1 to L2 and then the last piece is each from L2 to L1 that's withdrawal so this actually withdrawal is a key difference one of the key differences between optimistic and ZK Roll-Ups so let's actually talk about it so optimistic Roll-Ups you might have heard arbitrim optimism huge tvl they're the first ones to come through right so essentially what they do is they assume transactions are to be valid so to take a step back right like I keep mentioning data availability what the important thing here when we talk about the different types of Roll-Ups is how do we verify that the data we're proving is true right so optimistic rollups came around and we say oh let's just assume it's true basically we're going to have a 7 day challenge period to wait for the community alongside some slashing mechanisms and incentives to essentially say hey this looks fishy let me run a fraud proof if it turns out to be a faulty transaction that will be rolled back right there are workarounds like trusted Bridges but we all know bridges are always hacked so it's not nothing else we knew we need to do this but people got smart I don't want to say people got smarter research took a little bit longer and we got to the point where we have zero knowledge rules so how are they different from optimistic Roll-Ups so essentially they have something called a validity proof so rather than optimistically assuming they just say hey when I post this data back I'm just going to also post a mathematical proof to a separate verifier contract that will verify that it's true or false something I'm just going to mention and I always say this I get a lot of questions about oh how is privacy on Linea that's a common misconception because people think oh ZK private identity Etc that is a common Association right because the property of ZK proofs is that you can prove something without having to reveal the information what it is in the context of a scaling solution is more so hey when we're choosing the different types of mathematical proofs we can use we're going to choose a zero knowledge proof because that's going to reduce the information as much as possible when we post that data back to be verified um so that was kind of the choice examples include Linea ZK sync polygons ekvm scroll and start net uh so I I think there's a lot of different layer tooth um kind of you know optimistic versus ZK but once we get into ZK like what's the difference between all of them why do we care about uh the different kind of pieces uh so the first piece right I keep mentioning about ZK evm so essentially this is a z KVM is the off-chain virtual machine that essentially allows you to execute smart contract transactions in a way that ZK proofs can understand I can't explain how it works but basically you can think of it as you know I'm writing a computer program how do I turn that into like polynomials and math that a mathematical proof can actually run and validate so that's kind of what a ZK evm uh we've been building right and the different that's the differentiator one of the differentiators between all the ZK Roll-Ups so this is kind of where I get into the different types so if you remember that first slide I said will be a type 2z KDM at the highest level Type 4 that's going to be Stark net that's going to be ZK sync they you can write in solidity but it is not 100 by code equivalent what that means is tools you're familiar with truffle hard hat Foundry you might have noticed you need to download a pug plugin not everything is covered so you got to be really I guess um what do you call it cognizant about the functions you write um whether or not it's actually supported by that Network you kind of move further down so type twos essentially are fully evm equivalent so that's I can write in solidity I can write in Viper it's 100 bytecode equivalent so the tools that understand the evm don't need to change at all because there's no difference there so that's our goal that is also the goal of the other type 2 zkevms no one has currently reached that yet but um you know it's on the way people constantly doing research and we're like fully confident and the last piece is fully ethereum equivalent basically this means every part of the ethereum ecosystem I guess kind of structure is used for developers specifically there's not a lot of difference in your developer experience I can talk about about this later if you guys have questions about why it would matter but it's not super important for like a hacker for example so last piece when we talk about like the different types of DK EVMS right the kind of idea is the performance and compatibility trade-off is there like building a ZK EDM is very difficult I think with starknet for example they started off with writing in Cairo right because their assertion was basically evm itself is like very hard to prove so we're going to change parts of it to make it faster and more efficient and things like that I think with the proliferation of type twos basically that thesis has been proven Incorrect and people are constantly like iterating so you can also see something like what starknet now has a new transpiler on top of it that is moving from solidity to Cairo to Cairo VM to post back to ethereum and I think that is just an indicator of why it is important to maintain that kind of network effect of keeping like solidity divs in-house like the ethereum ecosystem has already been growing and stuff like that so anyways kind of like how the approver works at a very high level you can kind of think of it in linear terms in like three different stages or I guess how many stages are here four so the fourth first part is arithmetization so arithmetization is basically that part where we turn the computer program into math so we call this traces um Linea is special because we are the only ZK evm to actually directly arithmetize the ebm what does that mean it means like there's actually slight differences where they have an intermediary VM with the other l2s um but that's that's super cool Tech I don't want to explain other people's like Roll-Ups obviously because I don't work there but the next piece that we do and this is really what sets us apart is something called the inner proof system so it's called Vortex and Arcane so essentially here um I think diving back into why ZK Roll-Ups are really cool specifically mathematical proofs is you can apply mathematical proofs on top of mathematical proofs and do that recursively so you have like this kind of recursive infinite scale and that's kind of where Vortex and Arcane sits right we use something called lattice based hashing which is a really interesting thing that is like plausibly post quantum what that means is quantum attacks don't exist but if they were to we could uh I guess set up our system such that it would be I guess resistant but no one wants to hack a roll-up they're going to hack the nuclear codes right that's how it works but anyways it's optimized for recursion and the last thing is it's really efficient for Hardware acceleration which is kind of something you think about when you think about performance improvements and the last piece is an outer proof so that inner proof actually does not get it small enough to be posted back on ethereum that last piece is what you might commonly hear as like snarks you might hear words like plonk girl 16. that's the last piece it's really cool because you get to basically compress or verify one transaction and one billion transactions in the same amount of time for our ZK circuit libraries I want to do call out we have an award-winning gunnarok circuit Library it's open source it's actually used by different projects it is the fastest ZK evm on mobile phones so when we start proving things on high schoolers phones like yeah no we're there okay so like I guess now hopefully you understand this piece so talk about actually what I think and I think linea's success so far is really proved by it's not the tech it's the ecosystem right so private testnet opened in January I pulled these numbers I think earlier this morning 50 million transactions like wallet addresses deployed contracts you can compare this against like scroll I think was like 46 million um polygons and KVM was maybe like the two to three I do admit there's an element of like having a token versus not having a token definitely drives transactions um but I think there's a lot more to this than like just Farmers right there's a belief in the ecosystem and I speak specifically we opened three days ago so we have 13.3 million tvl uh for that what that means right if you look in the order of I guess you could say um all the Roll-Ups ordered by TBL within three days we've jumped from like zero uh row 20 to I think now we are roll 16 and we are four million away from row 15. um and so there's a lot of growth right um and like why why are people really interested in this right so first thing thing right finality again that that idea of just ZK versus optimistic you have faster finality you have a more secure trust assumption Etc something you might care about is TBL so maybe if you're building you'll start with arbitrim just because there's much more like liquidity to act with for your users right um the last piece I think that's really uh compelling as well as like roadmap when you think about what's next you know we're not just what we are now we are what we are in the future but I'm going to talk specifically about what makes Linea really different and like why we have onboarded so many partners thus far and maybe for developers here who want to actually take your apps past the hackathon why this is important right so specifically it's like if you're building adapt you want to make money right and how do you make money you have users so we are at the same company as metamask we are a default integration so immediately with Linea you have discoverability if you have seamless ux you can think of metamask features in the future being set in the home of Linea right that's a really powerful value proposition when you dive into consensus is a little bit of a mode right so if you guys aren't familiar with bezus so Basu is one of the largest open source ethereum clients so that means in-house we have a very experienced team to do interesting things with those kind of performance Opera operations on like the client side for an L2 so again kind of building on that ecosystem again if you guys are familiar with inferior like immediately we have that kind of scalability that comes with node providers and I think the last piece maybe if you guys are familiar with consensus metamask Etc we do actually have a lot of presence in the web 2 space so when you think about onboarding people outside of like our little click of like Fanatics right who are people going to trust you know JP Morgan is going to trust consensus right and I think that's become a very strong value prop that a lot of like I said the first 140 applications have been really excited about and why I believe and also like I guess why all those people are there so the last piece I guess is not super important um how many of you guys have deployed a smart contract before uh okay so I'm gonna say like majority of the room um so I don't want to actually go through a full demo but basically in order to deploy a smart contract you need a few things so you need eth to make transactions for you hackers there who are choosing to deploy uh you can get uh it through a faucet or you can Bridge it I'm a bit of a linear youth whale so also feel free to ask me I can just send it to you it's only for hackers so anyone watching this like don't send me your like wallet address over Twitter because I'm not going to send you any um anyways uh last piece right like I think the important part is just again you can use whatever you want to use um if you're deploying I think like if you're deploying here on polygon and scrolling whatever like please deploy to all of us because it's the same experience like you want to mask those bounties right um so just kind of an example of what it looks like um I can show you right uh here's my config basically there's Gurley there's Linea wow look let me write this out live coding hopefully this works I'm gonna blame it on the internet if it doesn't anyways uh Linea oh do I need to run here oh I have an extra s where deploys oh does that work nay wow so easy okay um that's about all I have yeah uh this is how you can get in touch with me Linea build this is kind of all of our information this is a QR code to a website about myself that I haven't updated in quite a while um but yeah if you have any other questions about Linea and stuff like that uh feel free to ask me now I don't know how much time we have left but um am I overtime I talk pretty slowly okay cool normally I'm like whoa but like I'm tired we're good we're good on time okay yeah so if anyone has any questions please let me know um I can talk a little bit more about like I guess Linea right now another thing right when I think about l2s in general you might hear a lot of the narrative is like oh we're so easy for developers right but I think it's very much a chicken and egg situation um you want the users for those developers to attract and so like that developer friendly experience is just table Stakes I think that's where what Linea understands we want our Tech to be there we want the experience to be there but what's most important is that when you deploy people want to use you right so we already have something called the ecosystem uh investment Alliance I hate the name it feels like Avengers but anyways but essentially a set of like VCS dedicated to funding linear projects I think separately if you apply for our Bounty there is um like an opportunity to get filled into our accelerator program as well so I think there's just a lot of like interest basically in supporting projects past the hackathon I mean I don't know how many of your students but I don't I don't promote quitting College to build in crypto because I like my degree but you know everyone has their own journey and if you want to build the investment opportunity is there yes um could you mention some key protocols that are available in linear for hackers protocols oh yeah like like oracles or any kind protocols you can liberate from there yeah yeah yeah so I do really uh so if you go to docs.lineia.build oh I forgot to mention this actually um if you deploy if you use like our deploying or our what do you call it infrastructure Partners we will award bonus points I think our thesis right is l2s are supposed to be boring uh in a world where like meta or what do you call it like there's Mass adoption or whatever no one knows what an L2 is right what makes a Dap robust and interesting is kind of the tooling that's built on top of it so for example by economy is offering a bounty here by economy launched on mainnet with us day one um and Catholic transactions are something that's really interesting for like user experience gaming account abstraction Etc so if you want to do like a linear plus by economy Bounty that is an opportunity for you to kind of see what you can build um outside of just like hahaha MPX hard hat run scripts.deploy without the s dot JS Network linear you know no one cares about that I mean we care that it works but like you get what I mean so yeah um so uh oracles so if you guys are does everyone know what an oracle is here yeah okay cool yeah so oracles we have pragma umbrella Redstone if you're used to using chain link chain link is not deployed um on linear but there are other options as well um gelato is really cool it's another option for gasless transactions this is notifications do you have a question oh sorry yeah and so the native token is ether yes the native token is ether so that is like the purpose of a roll-up right everything is like ethereum um yeah oh you have another question stop I don't get answers we have 10 minutes I have 10 minutes yeah so we asked to Until the End five sorry um what is the end gaming in terms of decentralization for sequencers oh and so on yeah oh I had this in a different thing right here oh okay so actually this is something that's really interesting that I think most people don't know um how many of you guys know what multi-prover is multi-prover okay cool the only person who has a question so anyways like oh that's that thing this is actually what I think I think again like I keep positioning Linea as something really cool but actually Lydia's True Value prop I think Is our commitment to collaboration so starting off with like what's important with an L2 right is our road map so we're getting to that type too like number one if we want to say we're type two and commit it and say it publicly we have to be there so that's on their way the next piece is like how do you believe something is secure so uh focusing on open sourcing our staff right now we want to kind of keep it in-house make sure everything's like secure or do all the audits first before like that code is publicly released that is our next stage um and then yes like a roll-up will not exist without decentralization like ultimately the key of why roll-up Swan over side chains is security and if you have a centralized sequencer and know like you can have Bad actors not that I'm a bad actor but you get what I mean um maybe I'll leave and then all the Bad actors will appear but the last piece actually is multi-proofer um so when we talk about just one like proving system what happens right if there's a bug in the prover everyone's like I don't want to say f-u-c-k-e-d right so the multi-prover theory is actually saying hey we have so many diverse implementations of the zkevm and like that's kind of also where like optimistic Roll-Ups have a completely different implementation structure right so if I'm passing those transactions through multiple approvers to reach like a consensus of truthfulness that is a much more secure model than like something like just a single prover right I think it feeds into why you have like multi-clients on ethereum with like bezoo and Geth and like all these different things the diversity is what promotes security so we are very committed to this um not ever I don't want to throw shade so I'm just going to say we are very committed to this so other Roll-Ups if you want to do this with us feel free there are there are it's in the works um yes you have a question what do you mean multiple times or using multiple different implementations I mean I guess it could be slower but I mean ultimately okay yes yes okay I think it would be slower but I mean just like looking at the roll-up space right things are getting faster and faster and faster and it becomes a trade-off of yeah do you care about that versus do you care about like security and I yes so on that point um would this be like a protocol that will change or would it be modular like a user could choose I want multiple approvers or I want a single um we I mean like honestly this is phase four so the actual implementation details haven't been decided it is a very difficult problem to solve and it requires a lot of coordination unfortunately everybody in the space right now is racing to decentralize um well I guess the first part is actually like racing to mainnet and then racing to type two and then racing to decentralization and once all that is figured out then like that kind of conversation about like is it fast enough like Is it feasible even like it is a very difficult problem to solve and those conversations are like happening in the sense of like we want this to happen together but not necessarily like we've already committed engineering time to figuring it out um yes last question right Security Council do you mean who's running the notes uh no no no it's stuff like upgrades and things like that governance as well yeah okay what does that look like right now and where's that going right right so right now everything is under consensus right it's uh decisions are made by our engineering team um but again those that information is public um and like uh what do you call it I don't think any other protocol is at that level yet where governance I'd actually maybe arbitrum's token is what's doing that I don't know I can't speak for others but that that's where we are right now um so we are in Phase zero I don't I don't know if the security Council has been established yet I think it's happening I imagine it will be Bay Zoo metamask everyone in consensus like stakeholders external stakeholders as well uh let me let me rephrase this the decisions being made right now are internal consensus the security Council must include outside actors in order to actually be an effective security Council right so that's where we're at cool don't ask me any more questions because now I'm sweating a lot laughs thank you yeah thank you foreign [Applause] let me know it's all good to start yep awesome thanks hi everyone my name is period and today I'm going to tell you a bit about conduits I'll do a brief overview and then I'll have Lucas uh protocol engineering and the team uh go over a more like the details for any questions you have please uh just raise your hands anytime great um so uh from maker we've always had predictable rates something I don't think we've really pushed as a narrative that much so instead of having variable rates that change on a block by block basis or fixed term rates that we're seeing now coming from other companies like element and sense makers always had governance the defined rates that change uh not that often but they do actually change the nice thing is when they do change it's through a governance process that is fully open and transparent you get to see that process and also once that is voted on there's also time delay so you always know exactly when they'll change and actually what will the new value would be so before you could only access the those rates through megavault or the what we call then cdps uh nowadays we've kind of evolved to be able to offer those rates for by our different users so if you're a borrower nowadays you can go to sparklend say our new Landing Market uh we're able to deposit your crypto collateral and actually get that predictable rate um you can also be a depositor and in that case you'll be depositing your die in the die savings rate um where you'll be actually earning that that yield and we also have a ERC for his 20 4626 representation of the DSR called as die and then finally the one I really do want to talk to you guys today about is the conduits so conduits are a we can call it as like an adapter between maker and the rest of the in of the ecosystem a way for Builders to actually deploy maker Capital directly into the protocols whether they're fully on chain or a mixture of of chain with wheel asset protocols for example so just a live overview of the change of maker rather than just being a single entity or single protocol now we kind of have like two levels we have maker core on the top and then we have sub-dials these sub-dials are the entities um the on-chain entities that will essentially be providing this uh liquidity to your underlying protocol as you can see here on the on the middle layer you we have spark land um we have univ3 LP token as positions uh as well as any other protocol they may want so how do sub-dials actually produce liquidity into the market as you can see in green we have on the left hand side the vat which is the core accounting model from maker this is the old school system that is still pretty much still there um and then we have all this new infrastructure created to be able to support this delegated Capital location we really want to talk about though is the on the on the right uh the actual conduits these are contracts are actually fairly simple um that will they will be able to like standardize the way that maker provides a liquidity to any broker on chain so you can think about as adapters I quite like to think it's very similar to how Unison was developing hooks makers developing conduits so let me show you this is the main interface as you can see it's extremely simple and really the most important thing that you need to really take care about is inheriting this and it as you can see it shows the depositing withdrawal function specifically for the hackathon there's other stuff that we're not really needing to demonstrate effectiveness of your projects including in the different permissions that we have let me show you all the different permissions that we have coming from the rolls Singleton and also from the buffer contract now you can you can have any variety you can plug it into anything pretty much um one of the most complex things you can apply to is wearable assets because you have that off-chain component in that case here's an example interface that basically inherits from the the previous one where you can see that I want to show you really the request funds function uh essentially a way of asking uh the the external entity uh basically saying hey can I please have my money back and then because they they'll do their own off chain stuff and I'm actually basically pay back the money they own um I just want to finish before uh Lucas gets on top and saying conduit Builders are part of this ecosystem it's not just sub-dials and external protocols uh this middle lay in the middle is um the group of builders that we actually care about a lot and we want instant device future building so now I'm just going to bring Lucas up and he's going to walk you through a couple examples um and if you have any questions please raise your hands actually before you do that any questions on the overview well good awesome I guess stay away all right hi everybody my name is Lucas I work as a smart contracts engineer at Phoenix Labs I'm currently working on one of the conduits um so just before I go into that I'm actually just going to bring this up again really quickly so one of the really exciting things about uh maker Dow where we're headed is this introduction of sub-dos um and the ability for them to allocate dye into D5 into real world assets and to expand the supply of dye and earn a yield on it in a really conservative and scalable way and what I find really exciting about this is the introduction of conduits so there's many different ways to deploy dye into the defy ecosystem you can Market make the peg you can add liquidity to a lending Market such as spark you can deploy into real world assets there's many different ways to earn yields and what's really cool about this architecture is that individual developers can develop these conduits themselves and propose them to make our governance and if they are deemed to be scalable safe and reliable they can be integrated into the core maker system so what I'm going to do now is I'm going to bring up some code that I'm currently working on so you can see this is my Ranger conduit which I'll turn off my coverage monitoring for and also bring up the interface so um yeah yeah is this I'll probably do one more actually yeah there you go um okay so what sodeo brought up was the allocator conduit base interface and so this is what matters for any new developer working on a conduit so essentially you have just a deposit and withdraw function in terms of adding funds and removing funds from the conduit and then you have two view functions the maximum amount that you can deposit and the maximum amount that you can withdraw at any given time So within that um the bounds are pretty open anyone who's working on a conduit can develop any kind of strategy that they want as long as it adheres to this interface and it's important to note that it can deal in any asset that you like so a common use case like for example what I'm currently working on is um like usdc is typically what's deployed into real world assets because it's easily convertible to Fiat so um you can deal with multiple assets within a single conduit which is important to note so for my example I'll just open the interface keep it simple so my conduit that I'm currently working on is dealing with real world assets so the key difference there's two sort of approaches that you can take to a conduit you can either take the deposit in and then move it straight into a protocol or strategy or whatever it is a good example of that is a spark conduit so if we want to Mint die move it through a conduit deposit it the deposit function will actually atomically perform the deposit into the sparklend protocol and so the die will just move through the conduit into that external protocol and live there and the positions will be tracked within the conduit um however for real world assets it makes more sense to actually temporarily hold the custody of the funds within the conduit and allow for the arrangers the real world asset entities that are deploying the capital into into treasuries or whatever it is to be able to come in and have a common place where they can just draw funds and allocate them um and what's interesting about the arranger conduit is that it tracks positions for multiple um entities using the same contract so what this means is that for multiple allocated hours they can all use the same conduit and the real world asset arranger that's dealing with this conduit just sees the aggregated available cache to be deployed they can withdraw that deployed into treasuries and then add the funds back as they're requested by each of the individual allocators and they can just come in and take their funds so all of the position tracking all of the current outstanding positions all of the relevant information to easily parse out all these transactions into dashboards or whatever it might be is all going to be available on chain through these condiments which is a huge improvement over the existing real world asset system where a lot of this stuff is is done off chain so that's that's one of the big benefits of using conduits um I'll stop there before I go into my testing Suite to see if anyone has any questions any questions about related to the hackathon building a conduit how to get started sorry can you speak oh there we go just around like some practical stuff working we find your repo and uh those types of things yeah so today you have some links that will be provided I think uh [Music] yeah um no don't worry this is yeah um everything is in the East Low dashboard there you should see a link to an um to basic hackathon bounties and you have like a in-depth description of all the different assets that you might need for conduits as well as the example uh that actually that Lucas is showing now on screen yeah so you can come on in so I want to stress as a like from a hacker's perspective this is genuinely one of the most exciting opportunities to write code that could potentially manage very large sums of funds uh very quickly the maker system won't you know discriminate between any sort of developers as long as there's good code that is well tested and has gone through the proper due diligence process has been proven out has been audited whatever it is it will be considered to be integrated into the core maker system and it's a pretty rare opportunity to come in as a as an external developer and contribute to such a substantial um you know system and which we'll be allocating massive amounts of capital um so if I if I was a hacker in this hackathon I would most definitely be working on conduits because I think they're extremely exciting um so regarding the testing I am working on like production level integration testing currently so I've done more than what's necessary for the hackathon the scope of what we're defining in the hackathon is going to be to deploy a conduit um and then create you can just deploy your own erc20 asset in fact that's what we actually recommend doing um in place of dye or usdc or whatever and um regard like permissioning um we all we want to for the scope of the hackathon eliminate all of that dependency just so that we can focus on the core logic of what is actually happening within the conduit realistically all of that um Access Control logic is going to be relatively similar across all the different conduits so it's not necessarily like Innovative to be implementing that during the hackathon so we want to we want to remove that from the scope and just make sure that um what you guys are working on is what's important which is the the novel deployments of funds so just a really quick example of a test here is uh coming in minting some funds pranking as the operator this is Foundry if you guys are familiar uh approving asserting some balances asserting some State performing a deposit and then making sure that everything is uh being updated both within the asset and the conduit contract state and what I would recommend if you're doing any sort of like protocol like an example is deploying into spark like I would recommend warping through time to demonstrate the accrual of yields through the protocol protocols that have time-based yield components any demonstration that you can prove out that yield is indeed being generated if you're using D5 protocols I think it's something that I'd I'd recommend but real world assets are definitely also on the table so it's really it's really open-ended to whatever you guys want to work on any other questions yes so I think part of the requirement of the hackathon is to deploy to gorley is that is that true oh no it's not okay so because yeah I'm working off of a local Fork of mainnet um that's totally viable if you want to do that in fact we recommend it um if if uh if you want to be testing against you know production deployed contracts I think it's a good idea to Fork mainnet it's a good idea to to get into Foundry if um if you guys haven't gotten into that yet for for testing as well it's really easy to Fork Networks okay I think we're all set unless there's anything else no all right thank you [Applause] 