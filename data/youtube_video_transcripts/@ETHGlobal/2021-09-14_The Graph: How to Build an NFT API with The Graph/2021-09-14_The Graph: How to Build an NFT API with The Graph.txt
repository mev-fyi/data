alrighty hi everybody thank you so much for tuning in for today's workshop with the graph uh we have a presentation on how to build an nft api with the graph today and we have matter who's going to be leading it and yeah if you guys have any questions please save them for the end um he'll try to get to them as soon as he finishes his presentation but if anything happens and we don't get to get to your question we do encourage you guys to contact him through the sponsor the graph channel on discord all right matt earth or is yours all right thank you so much for the intro and i will go ahead and get to sharing my screen all right so yeah today i'm going to be talking and showing you how to build a subgraph and i'm also going to be linking to some workshop materials that you can actually follow along with as well and maybe i'll go ahead and do that so if you want to follow along you can or if you want to maybe do this um you know on your own in the future as well you can okay cool i'm just going to go here and copy a command i'm going to use in just a moment and go back to my slots okay yeah so we're going to be building out a sub graph today and a subgraph is basically an api on top of blockchain data in the traditional tech stack you know we basically can have apis databases and infrastructure that's built for query but really when you think about blockchains uh most of the innovation is done around uh trend rights and transactions per second and optimizing that um so therefore you basically have um you know sometimes years of transactions and data that have been that have been written in a way that is just not very uh queryable so basically what we have had people do in the past to get around this they were building out their own indexing servers so to build out your own indexing server you basically end up taking this uh really great thing that we have uh known as decentralization and centralizing it because you then have a single point of failure you have to maintain it anytime you need something you know changed um you now have another piece of infrastructure that you need to to deal with and again like in the centralized tech stack we typically would have like some api layer that would hit a database and the database is built really optimized for indexing data for you know web or mobile applications or whatever type of application that we're working with um but this kind of like centralized uh i would say this this type of um you know indexing layer it was missing in the web 3 stack and when you think about an indexing layer you could also maybe compare it to something like google so with google we don't have to find a way to go and find all this information ourselves from all these websites google basically crawls all this information stores it in their own servers and they build like a really nice api on top of it for us to use which is the google search box and they also have uh you know other apis that we can interact with so basically the graph aims to solve this by being this indexing layer that sits in between your user interface or your application and a smart contract and you can basically define a smart contract address you can define the functions or the events that you would like to conduct and all of that data will be stored and saved and made queryable and it will also keep up with any future updates as well so let's say you index at some point in time any data that ends up being added or any events that end up happening in the future are also available and you basically deploy once and you're able to then use it to query all of your your data so you now have instead of a centralized single point of failure failure you now have a decentralized network of nodes that are all having this data stored for you and made it made queryable and also done so in a way that is performant because if you say you have a few dozen indexers out there serving your data it will serve up the closest request to where the query is happening so let's say you have someone in south america or you have someone in the united states hitting one of these apis we serve up the most the closest location for an indexer and the way that the network operates is through something called the graph network and the graph network has a few different participants that all kind of work together to make the network secure robust and and operate in a decentralized fashion so we have indexers we have queer we have curators we have uh delegators and we have subgraph developers so indexers basically run the nodes and they are basically running the infrastructure where the subgraph developers are deploying their sub graphs too um we have also curators who basically can signal towards certain subgraphs that they think are high quality and then based on that signal the indexer will choose or not to choose to index that data and make it queryable as well subgraph developers build out these subgraphs for people to query i'm sorry for people to curate and then for the indexers index and then if you're a non-technical person but you want to participate in the network um in the indexing side of things you can be a delegator basically meaning you're going to be backing one of these indexers with grt and then you earn a reward based on the amount of grt that you've uh staked with the delegator and you get a percentage of not only the query feeds but also network rewards which are basically essentially grt tokens that are like inflation that happens every year that are paid to network participants um there's a lot of different applications using the graph i think some of the most notable ones would be applications like unit swap one of my favorites is foundation you have live peer a bunch of different apps and defy and you know all parts of the web3 ecosystem are using the graph when you're querying this data and i think this is relevant for anyone that's a developer how do you actually get this data into your app well we basically are using graphql and once you've deployed a subgraph or an api you get an api endpoint and with that api endpoint you can basically then start hitting your api with whatever queries that you like and the really interesting thing about graphql is that you can basically ask for any of the information that you want and you will only receive that information back to the client as opposed to something like rest where you often are just given a large chunk of data and then you have to basically send extra data across the wire making it a little less optimal a little less performant and then you end up having to destructure or filter that data on the client um so with that being said this is just kind of like an overview of what that looks like on the client let's go ahead and jump into the actual coding part so what i want to do is show you the link to this workshop i kind of shared it in the in the chat but it's github.com3 building subraf and basically what we want to do is build a sub graph from scratch and uh what we're going to be building today is an nft api that queries all of the data that is in foundation i'm sorry actually we're going to be using zora today so zora is a nft marketplace so if i go to zorah.co you'll see that we have you know um nfcs so we want to build out our own api layer that will allow us to index and query for these nfts so to get started you need to install the graph cli so if i type graph you'll see that i have the graph cli installed and you can install using npm install dash g at graph protocol cli and you can find that information in the workshop material or on the graph website and what we want to do is we want to run graph init and this will initialize and scaffold out kind of some boilerplate for us but we can also pass in some flags and that's what i copied to my clipboard a moment ago and this is basically going to set up all of the basic configuration that we need to get started so what we can basically uh pass in the main thing to start here would be the contract address so this is the actual smart contract on etherscan and this is the address and based on that address we're going to be given a certain boilerplate by the graph cli um so we also passing in a couple of other flags because in this in this smart contract there are multiple contracts and we can define which contract that we want to um you know to use so here we're basically saying we want the token contract um we we do not want to deal with like let's say there's other contracts like a marketplace or something like that we're also passing in the index events flag and what this will basically do it will look into the contract it will look at it will find all of the events and we'll and it will automatically create some boilerplate code for us as well so some of that boilerplate that is really useful is basically the uh the event handlers so when we have an event like uh an event in an nft erc 721 contract might be something like a transfer event where someone's minting a token or someone's transferring a token then we will automatically have basically a function defined for us and then finally we're passing in the subgraph studio which is basically one of the two different ways that you can use a graph we have a hosted service which is which is not a decentralized service it was basically the initial version of the graph and then recently in july we launched the decentralized network which is called for development purposes like us before we publish there is called the subgraph studio so that's kind of what all those flags mean so now we can basically hit enter and we're going to be asked for our sub graph name so to get a sub graph name we want to go to the graph.com and we want to go ahead and sign in so if i go to the graph dot com studio i'm gonna go ahead and actually close that and um you know let me go ahead and disconnect here to give you kind of the full experience so like when you hit the graph.com you can basically choose right here to go to studio and studio is basically the development environment that we're going to be like working in where we can scaffold out a new subgraph so i can click connect wallet we can connect with metamask i can choose the address that i want to authenticate with and it looks like it's saying two accounts so let me get rid of that one all right so once we've signed the message we should see whatever um sub-graphs we've already created and i want to go ahead and click create a new subgraph so i'm going to click that and we'll call this zora api and now we have our boilerplate like placeholder i guess you could say actually for us to go ahead and deploy to and this will give us our subgraph name which is going to be zora api and it's also like the slug right here so i can go ahead and copy that to my clipboard and whoops let me try that again there we go um and then it's gonna ask us the directory i can just accept the defaults and then here we see all the different networks that we can deploy to so we can you know do any of these and i'm gonna go ahead and choose mainnet and we already passed in the contract address so it kind of has that already and then the contract name was already passed in so you see that there and this will go ahead and scaffold out that boiler plate for us so what i can do is go ahead and open this up my text editor all right and what we should see is that we have a graphql schema we have a mapping and then i'm waiting for the rest of this to complete and we should also have a subgraph.yml so these are like the three main parts that make up a subgraph we have again our graphql schema which is something we're going to look at in just a moment and it's our data model we have our subgraph.yaml which is our main configuration for our subgraph and then we have our mapping which is something we're going to walk through in just a moment so i think the first thing that's probably important is for us to define our data model and basically what we want to do here is we want to define which entities that we want to store and make queryable so for an nft api i think the most um you know thing that makes the most sense would be the non-fungible token which we could just call token and then also what we can do is since we have the address of the person that owns that token we can also create a user model and then we can have kind of a relationship between tokens and users and we can have even more interesting queries available because we can then do things like i want to get all the tokens owned by this user or i can say i want to get all of the tokens and then i also want to get the user and then maybe we can go another level deep and say tokens user and tokens so you can do all that fairly easily using um using the graph and using graphql so what i want to do is go ahead and declare my schema and here we have two types one like i mentioned is for the token and one is for the user and here we're just basically defining the fields that we want to be made available for us to query so we want token id we want the token content uri we want the token metadata uri and we also want to know the created at time stamp um using all this information we can do all different types of things to query this data we could say things like hey i want to get all of the most recently created tokens and i want to order them by date um i want to order them by id i want to order them or maybe i want to fetch a certain um only tokens by a user id all that stuff and then we also have this user entity and we're able to now do a relational uh i guess create a relationship you could say between the token and the user so we can now have one too many uh relationship essentially in doing that to do that we basically just need to pass in the at derived from directive which is part of something that the graph cli supports and it allows us to kind of you know have this additional you could say helper that is not part of the graphql specification itself so with our token and our user entity we're kind of done there and we can now go to our subgraph.yml and um we passed in like the the address which is already here we passed in the contract which is going to be the token so a lot of this stuff was already filled out for us we don't really have to change that the things that we do want to to change are the entities and these basically are just going to match exactly whatever our data model looks like in our graphql schema so if you remember we had a token and we also had a user so that's all we need to do there whatever data that we want stored is just going to be kind of our entities and the entities end up matching your graphql schema one to one for the most part usually um the the other thing we want to do is we want to deal with our event handlers so i mentioned that um you know we passed in that index events flag which is going to look for any events that are defined and called in the contract itself and based on the abi that that is associated with that contract we have all these event handlers and the two handlers that we're going to be dealing with today are going to be the transfer event and you see that we have this function called handle transfer and then we also have um a token uri updated so we're going to be kind of dealing with those two events and we don't really need these other ones at least for this example purpose so i can go ahead and delete those and this ends up being you know a lot smaller of a code base for us to work with today so now we have our contract address which is the smart contract we have the abi which was fetched from the contract itself and um we have the abi right here by the way it was pulled down by the graph cli so just figure out true that we also have our two entities which again match our graphql schema we have token user and here we have token user and we've defined two event handlers and this is going to be kind of where the code we're about to write lives this is going to be really the only actual code that we have to write and what's going to happen in those event handlers we basically want to write a function that takes some information that is passed into an event so let's say the handle transfer event is fired we're going to have these three arguments passed in we're going to be having the address of the the previous owner the address of the next owner and then the token id so using those three pieces of data that are going to be coming into the function we can do stuff with it so we're going to do stuff like create a new token and then set the address set the previous owner the current owner you know set um the token id and stuff like that and then the only other thing we might want to do is we can actually define a start block and the reason we might do that is because if we deploy this con this sub graph as is it will go to this contract address and it will start indexing every single event since the uh beginning of the network that we're deploying to but since we know like hey this contract was deployed at some point in time maybe let's just start from that um that date we can just go to ether scan find that contract we can go to like the transactions we'll go to the very last transaction and or the very i should call this the first the last page and we just want to copy the the block for from this event when this first transaction happened so i can go here and i can just set the start block as is as that number and this way when we deploy this it will it will just start right there going forward and we'll just ignore everything before that so with that those two things set we can actually now generate some code that we're going to be using for our mappings and to do that basically we can run graph codegen and this is going to look at our graphql schema and it's going to go ahead and generate some boilerplate code for us in this generated folder so like this ran successfully and we can now see that we have schema.ts and we have a generated token.token.ts and we don't really have to like do anything there these are these are like this is just some code that we can use we're not going to actually update that but what that code is it's generated some two types of i would say like functions and things like that and types that we can use one is a set of functions and methods that allow us to talk to the indexer so to talk to the indexer we basically wanted to be dealing with the node that we're going to be saving information to so we can say hey we want to either fetch information from this node or we want to save some data to this node we also are given a bunch of functions that can talk to the smart contract itself as well so let's say that we want to hit the contract and get some other metadata that's there we can do that so we can talk to both the graph node as well as the actual um smart contract using those uh methods and functions and types and stuff so here the the two um handler functions again that we're going to be dealing with are going to be the handle uh token ura updated and handle transfer so those are gonna be like the two functions that we deal with so the first thing that we want to do is go ahead and import some of those helpers that we had earlier so these three imports here are going to be dealing with talking to the actual smart contract itself so we have the token um i would say we're calling it the token contract but just a way for us to like deal with metadata for the token itself we also have a transfer event and a token uri updated event and these are basically just going to define the um the event metadata for us to have type safety um and then the other two things that we have are the user and the token and these are going to be ways for us to interact with the graph node itself which is essentially going to be you know an indexer running a node and us being able to either save data or or read data so with those imports we can now write our two functions so the first thing that we might want to do is to let's do this well let's do the smaller one first actually so we have this function called handle token uri updated and if we look at our handle token uri updated function here you see that we have two arguments we have the previous address here the new address and then the string which is going to be the uri updated data and the only thing that we are actually going to be dealing with is going to be this uh content uri which is going to be the new uri so we don't even need to really um know the the owner or anything like that because we can basically call to the graph node here and just load the token so we're going to say token.load we pass in the token id and then we reset that new token uri field and then we save it so really just three lines of code here this is probably a really simple um probably the most simple event handler that you'll end up dealing with because really like the only thing we care about here is just updating the token uri um field of the token and then the other function that we have is the transfer event and this one's a little bit more complicated because we have to take into consideration that this can be a brand new token that no one has ever like minted before it's like it's being minted at this point in time or this token um already exists and therefore um all we need to do is handle the transferring of the owner so like we have to kind of deal with both of those cases so the first case that we do is we go ahead and try to load the token from the graph node and then we could say okay if this token does not yet exist let's go ahead and create the token so the way that we do that is we say new token we go ahead and set the creator we set the token id and then we also set the created at timestamp which is available on the event dot block.timestamp so this is kind of some metadata that comes in from the actual um event itself um that's not really specific to you know a token it's more like specific to the transaction and then we also want to go ahead and read the token from the uh we're not at this point talking to the graph node we were talking to the graph node here now we're talking to the actual contract itself and we want to fetch the content uri and we want to set that on the token as well by reading it from the smart contract and then we also want to read the metadata uri and set that and at this point we've created a new token we've set the creator the token id to create that timestamp and these two other fields and then we set the current owner because at this point we know that the token exists we've either you know created it or it's been created and now we just want to update the token owner because if the transfer events happen that means ownership has changed and then we just save the token and then here we go ahead and do this like similar logic we check to see if that user has already been created if they have uh not then we go ahead and create that user and you can see like this dot save method anytime you see dot save this is you saving or someone saving some information to the graph node so anytime this happens that means you now have this piece of data it's indexed and you're ready to start querying for it so with that being said we should be done creating our subgraph and we should be able to go ahead and deploy so um what i can do now is i can say graph deploy well actually you know what we first need to graph uh we first need to authenticate actually so let me go ahead back to our subgraph here and you can see that like we have some instructions like right here on the right where we kind of give you an idea like to install the cli um initialize the subgraph and then here is the step that we're at now we want to say graph off and we want to authenticate and allow us to actually deploy this from our machine so i can just say graph alt dash studio passing in oops well that's my key i guess i already just i just basically made that available but yeah um the next thing we want to do is graph deploy so i can say graph deploy dash dash studio and this will go ahead and deploy our our subgraph um and this we try oh i need to um i'm not even in the right folder so let me try that one more time all right so i'm going to copy this graph deploy studio passing in the name of our subgraph and here we can go ahead and define a version label i'll just set the version to like 0.1 and if the deployment is successful you should see like this with no errors or anything like that and then we should be able to go back here and refresh and see that we have our subgraph being indexed and um you see that we kind of like have changed our ui it's changed a lot now we're now seeing that we have a playground we have logs we have our subgroup details still available but we should be able to go ahead and start querying our api so what we might do is just run this query that's available here where we're going to go ahead and get the first five tokens and we're going to get the id the metadata and the content we might also say want to order by creating a timestamp and then order direction would be like descending and this way we can get the most recently created um tokens and if i query a couple of times looks like we can go ahead and maybe just copy one of these so let's go ahead and copy this content uri and check out what this token looks like there we go we see that we have our data coming in and yeah so we have that without working there um the one thing that we didn't really do in this example is dealing with ipfs metadata so one of the most recent apis that i created with the graph that i open source was the board api club api because with the graph you can do stuff like full text search and you can do you know a lot of interesting things like that so what i've done is basically like you know deployed this and i've indexed all of the different traits from this um nft so like the board ape yacht club they have um all these different things like they have eyes background hat mouth clothes so i could say i want to get their hat i want to get their mouth design or the type of mouth that they have clothes whatever and we can get all of that and then i might say okay i want to only query like the apes that have a puppy vest so we can say wear clothes you can say puppy vest or something like that and here we see that we only have those h coming back and then one interesting thing is that we can also do full text search so i might say something like let's see what that query is called i think it's called token search and i can say text is equal to like let's say we're looking for any ape that has like red background or red something could say red and here that we see that we have like this coming back and i'm not sure yeah i don't see the actual red so i'm wondering if there's interest something going on there maybe i can say m1 yeah and this is like the mutinates so yeah you can basically do a full text search um using that and i think one of the things that we we might look for would be just like mutants because like you have the board api club and you have the mutant yacht club and oh i'm not like getting all the fields back that's why i'm not seeing that so yeah so um yeah mutant yacht cub is the collection and i think the reason that um when i did these the other full text search and i wasn't actually seeing that i'm not actually returning all these these fields so like if we if we you know return the eyes and all these other things that i'm guessing that the um you know the results would actually match what we're expecting but yeah so like you can deal with ipfs and the way that this one works is that like when we get that metadata uri we can go ahead and fetch that metadata from ipfs and then we we have like an object that comes back that has like all these different fields and we save those as well it's basically essentially kind of like taking um this mapping that we have here and adding additional fields and i would say the main thing to consider with ipfs right now is that we support ipfs in the hosted service but we don't yet uh support ipfs in the decentralized network for maybe a couple of more months until that update is merged so if you want to build a subgraph using ipfs metadata still you can do it uh without any problem you just have to use the host service so that is uh that's it for me if you want to learn more about the graph please follow us on twitter check out our website check out our docs and you can join our discord and also feel free to reach out to me on twitter i'm david3 and i'd be happy to help thank you okay thank you so much nader for that really amazing workshop and thank you so much to the graph for sponsoring ethonline this year i do encourage you guys to reach out to mater and continue this conversation about the graph in the sponsor the graph discord channel and yeah thank you again mater and everybody have a really great day 