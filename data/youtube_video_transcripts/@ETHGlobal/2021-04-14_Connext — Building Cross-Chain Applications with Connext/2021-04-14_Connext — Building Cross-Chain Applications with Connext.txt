everyone welcome all right welcome to the connex workshop um so today we'll be going over building cross chain application with connex with us today rahu and victoria that may get to your question in the chat as well i will hand this over to them to give a quick intro and kick off the session feel free to ask any question in the chat we'll be getting to them as well awesome thanks a lot catherine uh really good to be here we're really excited uh to be a part of this uh you know this is probably the most relevant hackathon to the stuff that we're doing um so we're happy to be here and support throughout this entire process uh like katharine said i'm rahul i'm one of the co-founders of connext i'm one of the tech leads here so hopefully we'll get through this stuff and answer all the questions and help you guys out so what i have here is this doc that i'll be going through so it's it's kind of a hacker kit and of course we'll share this with with all of you guys after um first of all is an intro to connext so connects we like to think of it as ethereum's cross l2 communication network so what that means is we are not in l2 ourselves but we enable communication between l2 and in the form of like value transfer and liquidity transfer uh eventually things like message passing and things like that um as a brief history of connects we've actually been working on ethereum scaling solutions for a really long time for those of you who are not too familiar with connex we have been building state channels for probably about three years now we lost i'm with their payment solution um sorry can everyone hear me so that's that was weird blip on my thing um so we helped launched launched spank chain's initial like tipping payments based state channel system and we had good results and feedback with that we you know launched production we got a lot of of real world usage and feedback and then that was kind of like our incubation period for how we started getting into state channels uh we pulled that technology out and generalized it into a generalized uh state channel framework um for a while we were doing that and trying to basically build that as a layer too and uh the way state channels went is that kind of became some of the issues with state channels sort of became very apparent when we tried to use it to directly scale ethereum as a layer to uh some of the problems as these are well known with state channels are the liquidity requirements and of you know things like free option problems and things like that that don't really lend well they blend well to a very narrow range of applications um what we found though is this technology works really well for bridging between chains because essentially you can like lock up funds on one chain and you can have liquidity providers who have channels on another chain seamlessly and non-custodially transfer value between them and i say non-custodially because it's a very important part of our technology is that we use the validator set of the actual chain that we're on so currently within bridging technology there there's a couple ways to bridge one of the main ways that people are bridging now is using these things called pos bridges which means these pos bridges have their own validator set and then when you're on one chain you will burn some value or lock it up in a contract essentially these set of validators will validate that that has happened and then they will allow you to mint on another chain so the problem with this of course is that the validator set is different than the validator set of something like ethereum and then you get in these issues where if the stake is less than the amount that's being bridged through then the validators kind of have uh an incentive to collude with each other and uh the way our system works is we kind of bypass all those those issues by relying on the direct security of the layer one itself um so anyway at scaling ethereum what we want to do is we want to really like lean into this this metaphor about cross-chain legos uh ethereum is kind of money legos and we see that cross chain is becoming a thing there's no way around it there's not going to be a single layer two there's not gonna be a single ethereum chain you know as awesome as ethereum is people are gonna build things on other chains uh they may or may not be evm compatible and you know we should kind of embrace that fact rather than try to be like fully you know maximalist i guess on just like one chain one layer twos and other chains exist it's fine as long as we have good ways and tools to build on top of them so some of the things that you can do by using connects of course like i mentioned you can bridge instantly from any evm chain into any other ebm chain eventually we will build support and adapters for non-evm chains but for right now what you can do is evm chains um we have this this uh concept of a withdrawal helper which allows for cross-chain meta transactions so one big issue we've seen with bridging across chains is once you get on a chain you still need money to pay gas on that other chain which if you're not using that other chain or don't care about using that other chain you just uh you still have to get gas for it so we've come up with a way where we use our routers as relayers who can send meta transactions uh one big thing one big thing about layer twos and fragmentation of layer twos in general is it makes the user experience really bad because you know users need to like know which chain they're on they need to like set their metamask for different different chains and stuff i just actually helped victoria with this earlier today and to get set up on matic and it was just so it was it was really like interesting and eye-opening to see a first-time user of this stuff like go through this process of like adding assets when you add an asset on die you're like oh this is my die on matic no it's my die on main net and then all this crazy stuff so really what we want to enable is a user experience where users really don't have to know or care what chain they're interacting with they can just be on whatever chain they're on and then interact with whatever chain they're doing like if they want to do a swap they can do a swap on a different chain and seamlessly bring the value back to the chain that they're starting on um so i won't go into fully the prizes because these are all here but we are offering of course prizes to all our awesome builders and we have collaboration prizes with some really awesome teams like graph and optimism uh our main product that's out right now that you can use right now is this cross chain widget so it's a widget that can be inserted it's a react component that can be basically inserted into any dap and can be uh it allows basically cross chain swaps this is not working so i'm gonna have to go to this direct video link here um basically it will speed this up a little bit so you can see here the widget is getting from matic to mainnet i say i want to send one recipient gets one because it's a swap and then it will just transfer all the way through so this is like a very normal ethereum like interaction i send my funds to this deposit address and then i will receive it on my receiver address at some point very soon so it happens quickly because these transactions happen very quickly so then i have my one usdc available on uh now buying ads because i transferred it from matic so a couple of the apps we're live with we're live this is the bridge i just showed you which is x pollinate so this is a cross chain bridge going between x die polygon and binance smart chain right now we can add support for more chains basically the main limitation is just getting liquidity for those chains uh decentral games is another they have directly integrated our widget to allow for easy onboarding directly in the app so one big thing that we like is that this widget based operation allows apps to directly onboard users from ethereum or any other chain directly onto whatever side chain they're using so they don't have to send users be like oh go through the matic bridge and then come back um another thing is the matic bridge itself has integrated us and space fold is our test net bridge and then off l1 is an interesting thing that i'll drive into early like later but it's basically using the underlying connect technology to do uh cross chain arbitrage so some of the ways that you can use connects you can use the react widget that's the quickest way so you can just drop in a react widget and this will enable cross chain swaps and interactions with withdrawal helpers which we'll get into so it's a simple npm package you just drop it into your app configure the props and we have some examples here of how to use it and then what we've done very recently is we have broken up the widget into functions that can be used like an sdk so you can create a full bespoke cross chain experience using this sdk there's basically four functions that you can run to do the full swap end to end and we have docs and examples here as well um so one big thing that we're trying to push for in this hackathon as well is the withdrawal helpers because we think this enables a lot of like very cool experiences this allows you to build interactions with other contracts on different chains without needing native assets so all you have to do is you write a special helper contract on some chain which you want this will follow some interface and then you deploy it on that chain then when you're actually doing the swap you'll generate call data which you will send to the router and then the router will help you withdraw using that call data um into the chain so like for example one example i have here is a unit swap example so this is a way that you can use a withdrawal helper to actually call a unit swap so that means what you do in theory what you can do with this is you can swap from let's say xdi to matic and then you can run this uniswap helper so that will also do a swap at the end of your cross chain swap like a unit swap swap on top of a cross trade swap so the interface here is is very easy there's just a couple functions that you implement the main function is called execute so what this execute function gets some data passed into it um then it will define some variables so these are some internal variables that are relevant to the uniswap swap itself so the data get gets passed in gets decoded into this swap data then it will actually call the uniswap router so you pass in essentially amounts based on the uniswap interface so amount in is how much you want to swap amount out min is the minimum amount you want to receive the tokens that you're swapping between the path of the tokens the two address that's receiving it and then the router this is the uniswap router not our connects router address and then basically all this does is just call the uniswap interface functions and it's very simple to do that one other example is superfluid so superfluid is a project that's building um like a new token standard for how to swap token to for how to like transfer value uh i won't go into it too much because they're they have a whole project of of their own but you can essentially stream value like gaslessly it's very cool you should look into it more if you have a chance but they do something similar so they just implement the execute function the data that gets passed in gets decoded into specific data for this withdrawal helper contract so they have their super token underlying token essentially what this is doing this is wrapping an erc20 into their special super token so you approve here and then you upgrade to and one really cool thing is the user doesn't need to do any of these approvals because the tokens are owned by this contract while this process is going on and then you upgrade to and then it will um give you back the two here or whoever you want it to be normally would be you then you would end up with these upgraded superfluid tokens as the one who generated the call data then if you want to get a little more fancy and into it you could use this direct browser node integration so we have a concept of a browser node which is basically a browser-based signer for the connects state channels themselves so a little bit of diving into the architecture here the way the browser node works is it uses an iframe to communicate and the reason we're using this iframe is while we're still getting building wallet interac in integrations and you know things like metamask and things like that we need a way for your private keys of your channel signer to be isolated from the dap so that the dap can't steal your private key and steal money so what we do is our browser node injects an iframe which has its own storage and local storage and indexeddb and private key and then that communicates over a json rpc postmessage payload to the dap itself and that allows the dap to communicate with the entire connex network essentially so then if you want to do a direct browser node integration all you do is install the browser node packages and follow this api and what i want to do now is dive into an app that was actually built using the browser node which does cross chain arbitrage between uniswap clones on different chains so this was built by makoto inoue from ethereum name service he did this as a hackathon project because he saw that there was this this issue where there's a bunch of unix swap clones on different chains and they have actually different prices for things so you can uh use that to arbitrage because konex is able to transfer value very quickly between chains you can take advantage of these arbitrage opportunities without having your liquidity parked on the different chains itself um so here's a little diagram about how this whole thing works so bob who is trying to use this system say he's he uses the alph l1 ui to see an arbitrage opportunity uh the only time he actually has to interact with the system is when he does this initial transfer so he will do a transfer to his state channel on the matic polygon network um the then he will call a function to actually get the funds into the state channel then you have a withdrawal helper so i just showed the unit swap withdrawal helper so the uniswap withdrawal helper will exist on matic polygon and bsc which you're doing the arbitrage between in this example so you'll call reconcile deposit which gets the funds into the state channel then you will generate the call data like we saw before in the unit swap helper withdraw the funds back to matic polygon which will then create a swap from usdc to usdt swap will put the funds back into the state channel which then again is able to reconcile the deposit back so now you've essentially swapped your funds on one chain into a state channel then you can do the actual cross chain part so what you do is you do just a simple function which is a conditional transfer function where you set the recipient as the other chain uh this this goes through the router you resolve the transfer which basically reveals the secret the way these transfers work is basically by hash log so hash block locks the funds to the router router locks the funds to the other state channel now router can't access the funds or anything until the funds the secret is revealed on this side router unlocks router unlocks and then the funds are available here on the state channel then you do a similar thing what you did on this side where you generate some data to withdraw swap back and then you do the whole thing where you swap again reconcile deposit back in the channel and then fully back withdraw again back to bob on bsc so now you've transferred funds from here to here and you've done a couple swaps and you have probably made some money um then what i want to do now is kind of dive into a little bit of the code there just to make sure that it's clear on how we actually get these swaps done um the swap function itself this is a react function this code is all available to show and share the first thing you do is you create your providers obviously do all that stuff all the boilerplate stuff get your channels and create them if they need to be created these are basic functions which are in our sdk so everything that says node here is an sdk function so get state channel by participants the participant in this case is the chain id and your counterparty is the router so this is this is hard-coded right now to our router address which is the connects hosted router um if the channel doesn't exist you do a setup so this creates a new channel and then if the same thing with the other side channel so this is the two chain id set it up if it doesn't exist otherwise you're good so now you have both your state channels then you get the balance so if you need to add balance this is the one part where you get the user to interact with it so you create a contract and then you do a token transfer from the user this takes the user's provider and will actually like pop up a meta mask url to actually do this stuff then like i was saying you just call the reconcile deposit function on the from channel then you withdraw with the swap data so this is when you actually call the the get call data function on this this withdraw helper contract with the amount you want to swap a mountain min right now this is just set at one so the swap will never never fail and then the tokens and the path then as you do a withdrawal i mean the reason we call it withdraw here is because it gets the funds from the state channel onto the chain so you're getting the funds out from the state channel onto the chain you're doing a swap using the withdrawal helper and then you're putting the funds back into the state channel so some boilerplate code to do all that like i said so you reconcile the deposit again so what reconcile deposit does is it takes balance that is on chain currently and puts it into your off chain state and then same thing then you do that actual cross chain transfer so the cross chain transfer happens with one function here you create a pre-image since you are the one that is both locking and unlocking the transfer it's okay and you know it is the right way to generate the secret right here within the app that is doing the locking and unlocking so pre-image is the secret lock hash is a hash version of the secret you send the router the secret the locked hash not the secret here using the get condition the conditional transfer function so a recipient is this recipient is the end recipient so this is the forwarded recipient right now this is going to go to the router because this is your channel with the router so recipient is who the router will forward the transfer to on what chain is to chain id and what asset id is to token so then you wait for an event basically you have to wait for yourself to receive the event on the other chain so the router will do its thing and and for the transfer you wait to make sure all that stuff happens we use like an event emitter based pattern to do all this then at the end you resolve transfer on the two-channel side using the pre-image that you created before and now when you do that you have funds on your other chain and then you're able to generate the withdrawal withdrawal helper data here and generate the two-channel swab and do the same withdrawal here again and this will actually withdraw it out to the recipient sorry this will withdraw it back into the state channel and then you would draw it out at the end into this like this is kind of a bit of code to do all this stuff but it all happens very quickly since this is all like off-chain interactions and then at the end you're done and you have successfully completed an arbitrage and hopefully made some money um so that's that um just another bit of information on some of the stuff the resources that we're providing some one another one of our boundaries based on metrics so what we want to do is we want to provide visibility into the connex network so we have a bunch of these routers running within the network and right now these routers are broadcasting data but the data is not being collected and displayed in a good way so we have a bounty out for people to actually make use of this data presented in a really useful way so things like total value locked available liquidity throughout the entire network you know number of transfers so payment volume through the network these are cool like you know d5-ish stats that can be used um basically this happens through a network communication protocol called nas so everybody is talking to each other in the connects network through this this nats messaging protocol so all you really have to do to get the metrics is you have to like start a listener on top of this instantiate it properly and subscribe to a subject that will let you listen for all the router broadcasts so that's one and then basically for the purposes of the hackathon we are hosting a test net router which is going to be available on all these different chains so arbitramatic or lee rinkaby optimism and what we've done is we have actually minted a test token as well so this test token is a mintable token that you can use to test very easily cross chain swaps and the router is already configured to swap between all these different assets um cool so that's about it for how what we're going to do here so i'll go for a couple questions here so who runs the nodes yeah that's a great question um anybody can run a node so the way it works is you can run a node to become part of the network and as a node you are a liquidity provider so you provide your own liquidity and um you have to run the node yourself so it's a little different than something like uniswap where you can provide the liquidity and anybody can provide the liquidity and all of it is aggregated into one pool it's a little more along the lines of something like uh e2 staking where you have to stake the eath and you have to run the node yourself and the staked eep has to be like sitting there on your own private key um there are public ones yeah so this is the main public one that i'm talking about this is the test net one we also have a main main net one and uh you know the the whole idea is that we want to abstract that part out of the developer um so another question say if one of the node doesn't have enough liquidity and i'm trying to transfer an amount more than what the node contains can multiple nodes fulfill my request answer that is it's in progress we have not fully uh got that like we're still kind of in the process of building that part out so right now one router has to fulfill your request and that becomes a problem because the router can in cases run out of liquidity and we have to rebalance it but these are these are problems that we're working on right now um uh did the arbitrage example work or how long did it take for that arbitrage example to process and how successful was it um yeah so makoto did that for a hackathon so it's currently not working right now um it was working so it takes about 30 seconds ish for the whole end to end thing to work depending on the speed of the chains and whatnot but between matic and bsc which are really fast chains things are happening pretty quickly since he built it as a browser-based app it was a little more like latent and had some issues but uh the next step for him to do this properly would be to actually like build it into using a server node and do it all on the back end uh he was able to do some arbs with like smaller amounts of money but you know the their currently like the liquidity uh situation on some of these l2s is not that great so when he tried to like do it with you know a little more substantial money he was kind of hitting slippage issues okay and what's wrong with the current you said that it's currently not working do you know what's not working on it it was there a change it just needs to be updated to our latest stuff like we've we've changed some things on the router side that need to be ported over into the browser side okay thank you uh if it's useful yeah i can i can work with him to try to get it up and running again i think it'll be a good example yeah and of course like yeah on the sponsored chat we'll be there to answer any questions can even like help answer questions about this stuff with your builds yep exactly help hands-on with builds awesome thanks guys um we're getting uh out of time so i will invite everybody to keep asking questions in the sponsored channel uh there rahul and victoria are going to be there and happy to help you um thanks so much i hope for this great presentation and victoria as well uh it was lovely to have you and uh i'll wish you a great rest of the day thank you guys yeah really good uh yeah we'll be hanging around looking at the chat like all day and all night so we're there please yep talk to you guys soon 