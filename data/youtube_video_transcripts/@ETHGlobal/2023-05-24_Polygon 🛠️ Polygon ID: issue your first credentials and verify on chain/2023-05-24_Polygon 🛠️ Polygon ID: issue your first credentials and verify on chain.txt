foreign [Music] my name is Alexander and here's with me my colleague Dima and we are from polygon ID and today we will demo you how to issue your first credential and verify it on chain so and just this let me first start with what's what's polygon ID so polygon ID is a cell soaring identity solution that is leveraging zero knowledge proof technology for ultimate user privacy basically it is scalable it is verifiable on chain and off chain and we're using verifiable credential standards and dads so how how it works in general so we we have basically three parties it's uh identity holder it's a user as it is uh having his credential there is always seizures that is issuing credential so it's it's like a source of trust and verifier it's a party that is requesting something from from the user like some statements about a user based on on credentials that he has and let's see how it works on on example so a user receives credential from from a university let's say that basically it's it's assigned by uh University it's a it's a piece of data in Json LD format and it's digitally signed by the university user receives it in in his identity wallet and stores on on his device it's not on chain it's on his device and then when uh time comes and when um a verifier needs to to get some data uh verifier ask some some questions and for for this we designed a special way of asking questions with zero knowledge proofs uh we are calling it CK query language so where you fire generates a zero uh zkea query and gives it to to user and user then scans it with his identity wallet and accepts what what he needs to to share or to to prove and generate zero knowledge proof that is then sent to the to the verifier and verifier just to verify zero knowledge proof and checks that it's it's valid and so it's basically it yeah on on High level um for for the builders we have um we have mobile application and SDK we have issue node for for the issue side and we have verifier libraries on go link and on JS to to verify zero knowledge proofs and generate uh ZK query requests and also on chain um verifier in in solidity and now to the demo okay just a second I'll prepare for the demo changes there are multin screen okay so essentially I will start with some explanation of the schemas so before you you will start issuing any credential shells you need to build your schema this is actually the data type or like the schema that you will issue for example this can be in this case in this example this is kych credential it has two attributes this is birthday and document type you can build whatever you want maybe it will be in your case passport credential and you will put 5 attributes or it will be I don't know like my ethereum Community member and it will just with one attribute but you are free to build your own query credentials with your structures with your attributes and design for what actually your specific use case will require and you will need you see here we are using the xsd types we're not supporting every types we're supporting just some subset of types because in zero knowledge proofs well you technically cannot use everything but for example we are doing some trick with Selective disclosure where you can use string values and then verify the string values with zero knowledge proofs and with this trick you can use actually any type of values but they will recognize it as a string and you cannot verify and use all the power of zero knowledge uh query language and for example you know chain verifications you always also will be a little bit limited but if you are like okay with to work with integer values and with like numeric data types you are fine and you can just build a lot of use cases so we have a tutorials for this I will not spend too much time for this schema Builder just because right now you need to build it manually in couple of months we're planning to release schema Builder application it will simplify this procedure so you just in the Builder just select your fields that you need and it's just generate a schema for you so it will be not as difficult as it is right now so right now let's go to the issue this is our visual node this open source you can download and run it on your local machine install it on your server or something this is specifically designed it for the issuer actually this is like demo application but this is easier part it will be not like accessed by the users it will be accessed by the issue so you will issue some specific credentials for your community for your users for your I don't want different developers so for your specific uh needs so here you can import schema I will show you example for example in this one and fetch it preview so you see all the fields that is defined at a in the schema some pills are mandatory and they are specific for polygon ID and for verifiable credentials like issuer issuance date expiration date and you have your custom Fields like birthday document type maybe credit score and this is Book bear fields that you specifically will defined so as I have this schema imported a little back and will issue credential okay so we have two options one the credential link so create like credential and send a link to the user so he can download it to his mobile wallet or if we know in advance his identity we can issue this credential directly to his ID but for at the moment I don't have my identity linked to this node so I will use the link Okay so this is a Time until credential will be accessible this number of possibilitions let's say I will put one I select my type and this is a birthday I will put like 1991 first month first day document type 2. and I will create a booming so now we'll generate a QR code for the user so he can download this credential by his wallet I will show my wallet with okay so we just scan the QR code and we can get credential to our form just close this time I usually I should receive the push notification but maybe because of the connectivity share I just need to scan and fetch it I could so you see I have a credential with this birthday and document type on my phone now I can go to the verifier let's start with the website this is off-chain possibility so you can build the created access on your website and then I can ask hey I can ask this query so so this is a code that is hidden in this QR code let me make it a bit bigger so we're asking the specific query to the user wallet so hey do you have this context like credential with this context in your wallet we have this type ksh credential and do you have that birthday field that is less than 2000. so if I manage this criteria we can generate a zero knowledge proof that will prove uh like this request to the verifier so verifier will be sure that all the requirements are met so let's try to do this get a bit smaller so you see we have the request on my phone he's asking if I have three CH credential if the birthday attribute is smaller than 2000 and I can generate a zero knowledge crew okay it takes some some moment so we generate a zero knowledge Groove and send it to the back end so backend can can verify a zero knowledge proof because it's not enough only to verify zero launch groups you need to verify zero knowledge proof and if the required is it match the request that you asked so you mentioned the request and response actually all the criterias and you are verifying okay the it was used like birthday the this birthday is less than 2000 okay so here in token we can show you the token that was sent to the verified you see we have only some meta information and zero knowledge proof so this is a zero knowledge screw that is answering on our operation so as a user I'm not exposing any personal information to the verifier I'm only generating zero knowledge proof with this uh with this answer so the same thing we can do with the smart contract so the smart contract also can be such a verifier that can ask user to generate a proof and prove him some like specific statements so the same requests that we did for the website I can do that for the smart contract and in this case the smart contract will be the same verifier but you can build some business logic inside your smart contract for example you can build the erc20 smart contract which accept only people who are about maybe like 20 years old or like from specific country or not from some other countries like I don't like them China Russia also something something like this it's very based on your like specific requirements for your business logic so here is an example of this smart contract verification never mind okay we'll start decision where is story of the Bruce okay so the question where is story of the proofs actually proof is generated every time when we are answering this request and share it with verifier so where's generated so if this is website it will be on the back end of the verifier if this is smart contract I send the proof to the smart contract then smart contract will be verified and like YouTubes no no they're generated on the flight and every time is sent to the verifier so here we just see and connect to metamask so it's how will it connect is working first we're connecting and then generating zero knowledge proof and then send the transaction with a proof so here add generator proof and solve it stick a loop on the metamask to wait a second okay success so what is the request inside the smart contract is actually the same but we put this in a QR code to give a wallet some explanation right now oops like our wallet is not fully supported everything because that's why we need to provide some additional metadata with this transaction data this address of the smart contract and specific method that you need to call to to share the zero knowledge but inside the smart contract is store it the same request as we had and the same request is verified inside the smart contract so your smart contract can build a business logic and verify zero knowledge proofs and can can like request that different verification spot for the users and based on this again you can build like shielded access maybe some business logic maybe you like give to your community members some additional preferences so what you can do you can build like off chain for your community members Bishop credentials that it they are your community members and then when you will do a token distribution for your community members if they can prove this to the smart contract you will add some I don't like additional value so of the tokens or like distribute some additional preferences in your smart contract also we can build like uh like owner transferring only if I like send a specific zero knowledge proof to the smart contract then you can change the owner of the smart contract so this is query language is flexible you can build your own business logic and just extend the possibility of smart contracts with some additional business logic that will be embedded in this zero knowledge course what's cool about this that your identity in a different smart contracts will be different for example you can reuse different verifications but your identity will be not tracked in a different smart contract the same you can do with it with the same smart contract for example the same verification can be used with a different ethereum address so your identity kind of uh decoupled with us with your ethereum others that's why like you can reuse verification so you can reuse credentials and well uh the sky's the limit of what you can do with uh with query language and uh with this verifications okay um yeah that's it for the presentation we'll now go too deeply in the smart contracts and uh like in the circuits just because we have like very little million at a time uh so maybe you have some questions clarifications yep he said uh do we have a specific type of proofs so our circuits they're kind of generate you don't need to like write your own circuits what you need to do you need to Define only schema for your credentials and you can use this query language with your specific credentials so the type of proofs we have like four different circuits like up with a different type of kind of proven so we have a two type of roofs one is a signature which is well just just a signature and also Mercury proofs so for the miracle 3 proofs credentials must be published Unchained and on chain so this is two type of proofs for them we we have different circuits but query lamwich and the rest of the stuff is genetic so you don't need to to do like anything like to write your own circuits or write your own proofs everything is written and embedded in the libraries and you can just reuse all this functionality technically you can extend this functionality if you need for you know for your use case if you want to write your specific proofs based on the our identity system this is possible all right this is baby jab job signatures used like well we're using baby job job Keys specifically to prove something inside the circuits so this is specific baby job job key that you need but yes it is ISA so fed everything about these three vehicles um you cannot use like ethereum keys for this type of signatures you need to derive like different type of keys this is like there on a different um yeah for but uh this working with ethereum with polygon with any evm compatible chain so and kind of the pluggable system where you can yeah build your use cases so we have actually all the parts of the flow like for the issue for the verifier for the user for the user like for the wallets we have that SD case for the e-shares we have all the libraries gssdk that you can if you want to build your own node you can you can do this for the verifier we have like verification libraries freedom in Goa and JavaScript so discover majority of the cases and again you can write your own issue if you wish uh or if you need for the smart contracts also we have some common smart contracts with some standard interfaces that you need to inherit for like for your specific smart contracts this is like big extending the functionality with zk's set request and set response functions that you can replace or rewrite or build your own specific business logic and verify zero knowledge and verify your specific cases amplify a specific requests that you will do because you can actually in one smart contract you can build embed multiple verifications it should not be just one like I want to know your age maybe I want to know your age also that your Community member maybe if you are like participating in my double activities maybe you are like GitHub contributors and so on but this is specific for the specific implementation so that will be built on top okay so any other questions good so the last thing if you are curious uh we have tutorials on our polygon website well there it's polygon here and double all the things that is all the things that I showed they are available there you can just pause the tutorials and you will have the same result good thank you 