in some dexes we use something called ticks and what a tick is is it's a um it's a way of splitting up the range of prices into a finite set of values so um to allow liquidity providers to choose a finite price range we split the price up into these ticks um and you can imagine it looking something like this every tick is one of these powers so this is take 0 in the middle and what that represents is a price of one point zero zero zero one tick number one is one point zero zero zero one to the power of one and so on and uh that goes off in both directions and so splitting the price up into these ticks instead of having an infinite number of different prices allows us to enable liquidity to provide us to choose the upper and lower bound on where they want to provide liquidity so if you want to provide liquidity from a price of 20 to 50 usdc per uni um you can do these quick logarithmic calculations and these are the two ticks that your liquidity would be provided between so they're equal to 1.0001 to the power of 29 900 and that gives you the price of 20. sounds kind of confusing but lots of this is done in the background and at the end of this presentation i will show you where in our code you can integrate so you don't have to understand all of the complex math that's going on in the background um so actually in the contracts we implement a square root price for various technical reasons i'm not going to go into those technical reasons today but if you want to understand more about why we implement it like that then you can take a look at the units of the three white paper um but for now the understanding of it being a power of 1.0001 is enough to understand the rest of the presentation um so additionally unisoft v3 has these things called free tiers which is essentially um we have three different ports for each token pair so where um in units what v2 and in other decentralized exchanges there is one pool per token pair with a certain fee that goes to liquidity providers unison v3 provides three different features one where the liquidity providers get 0.05 percent one where they get zero point three percent and one where they get one percent and what this allows is for um liquidity providers who are giving liquidity for more volatile and more risky assets they can choose to take a higher percentage fee to sort of support their risk and uh for super stable assets let's say you were providing liquidity for usgc die you can choose to take away smaller fee because you're not really taking on much risk with those assets so that's what this says at the bottom here um so the way we record prices in the contracts is using something called observations um as trades are made on uniswap the contracts record something called observations in an array these observations mean that you can access historical price data on chain um which you can't normally access historical state of a smart contract so recording these observations as time goes on means that in the current block you can access the tick that a pool was in aka the price that the pool was in in a previous point in time so the array looks something like this let's say the observations of a had six i had five um spaces we circle around overwriting previous values so there's always the five most recent prices are stored so if you had an array like this which is observations 13 through to 17 and you wanted to now write observation 18 it gets written in to our poor contract over uh observation 13. so you always have the five most recent observations what is stored in those observations from the tick point of view is something called the tick cumulative so we don't just store what tick i.e what price the poor was at at that moment we actually store something called the tick cumulative at that moment which is essentially the sum of all of the ticks so far in the history of the contract at every point in time um so at time zero the tick was added to it and then at time one the tick gets added to it again and that continues onwards um so if you have the cumulative tick at point n and point n plus 30 so that's 30 seconds apart so you can get those two readings from the observations array the the tick cumulative now let's say and the tick cumulative 30 seconds ago you can subtract one from the other and that then works out to give you the sum of the ticks just between those two points in time and if you then divide by the number of seconds that have passed it gives you the average tick or the average price for that period of time um so you can that's then giving you a more manipulation resistant tick or a more manipulation resistant price because if you just take the current price someone might have quickly done a trade to push it either up or down in their favor whereas this gives you the average price over a period of time of your choosing so that if someone changes the price now the average isn't as affected by that um so the tick isn't actually the price it's just uh as we saw earlier uh it's a power of 1.0001 so we can put our average tick that we calculated on the previous slide into our formula and that gives us the price this all seems probably quite confusing um but there's lots of helper functions to abstract away the maths in the background and um to help you with that so if you look at the uniswap v3 periphery github uh you will find something called the oracle library and there's currently also a contract called the weighted oracle library the two of them are about to be merged but currently both of them exist um and the two of those uh provide you with some helper functions so to get the mean tick over a period of time from a particular unit swap pair or pool you can call the consult function and that will return you the mean tick over that time then to turn that tick into a price or into a quote there's another function in the library where you give it the two tokens you give it the tick and it will output the quote for you so you don't have to understand all of the math that's going on in the background we've implemented that for you there's a number of other helper functions in there including uh methods to help you uh average the tick across different features if that's something that interests you um or you can just choose one feet here pull and purely consult and get quotes at that so these are the these are the functions that should be helping you this week during the hackathon um the v3 periphery github has a load of other helper libraries to help with other things uh on unisport v32 so feel free to browse through all of those and the oracle library and the weighted oracle library will be where you find helper functions for creating an on-chain v3 oracle um so i think now we go to questions yeah if anybody has questions for alice please feel free to drop it in the chat or unmute yourself and ask directly it can be on anything that she covered in the session or maybe something else related to uniswap don't be shy uh hi uh i have a quick question hello hi yes yeah my question is let's just suppose there is a big spike in the price of the uh token at what any point but if i do the query and i see by the oracle i'll get a price which will be much lower than that at that point of time because it's averaged out so in that case the price will require that i get would that be useful it won't be useful because the actual price of the coin or token whatever has gone up but i'm still kind of uh what i'm saying is the price we get from the oracle would be smoothened version of the price versus the reality of what happening now so what we do in that situation or how is that price useful at that point yeah it's a it's a tricky balance to try and get between ensuring you have an up-to-date price and not a stale price which is the situation you're talking about but also trying to make sure that if someone wants to manipulate the price and steal money from a protocol that they can't do that so what um our function allows you to do is you can remember when i said you can pass in a nut you can provide a number of seconds over which you want your time period so if you want a super up-to-date price that is not smoothed out at all you could look at the current price however that's then subject to manipulation by individuals particularly individuals with a lot of money or with a flash loan and um the larger you then make that interval of time the less manipulable it is but also yes the less up to date it stays with the true current price and so that's just a decision that each individual protocol developer has to make how how much manipulation are they willing to uh accept versus how stale are they willing to allow their price to be so you could take an average of the last minute and that means that if someone's manipulated in the last block it won't change so much you could do it over five minutes half an hour a day it really depends on your individual application of how how much risk you're willing to take of someone manipulating the price purposefully versus how stale the price can get and that's just a decision of individual protocols so so you're basically trying to say that we're creating a use case where a more secure use case or kind of something sudden spike occurs you don't want to participate in that kind of euphoric going up or down uh you don't want to you kind of if somebody wants to where to avoid that they can rely on this price course and again as you said that we can define the time horizon so we can go back and forth in terms of how like you said how still the data you want to get uh yeah right yeah and my second question is channeling i think the chain link product also they have their price workload as well how do you different that or i mean is it just another kind of like that or something different some things deep strategic in your implementation yes so the way that uniswap works is it's getting its prices from the uniswap exchange so when individuals are trading different tokens for each other it's the price is all recorded on chain and so we are fetching that price from the actual trades that are happening live on ethereum the chain link article isn't actually uh based on an exchange it's um a certain number of number of pre-approved parties who can submit a price to the oracle and the oracle then looks at all the submissions from the approved parties and averages out the price and people can go and look that up on chain um so uniswops is decentralized in that everyone's trades contribute to the current price and it's just looking at the actual market on chain chain links um chain links is a certain number of pre-approved parties submitting a price that they are fetching realistically from an exchange somewhere but um it's not prices coming directly from that exchange itself um i i have two questions yep yeah oh sorry uh first of all i'm just curious if you have a sense for how much traffic is on v2 versus v3 um yes we have stats on that on our websites you can see graphs of how much volume is done on on unit v3 and universal v2 each day i haven't looked at the the graphs in the last few days but you'll be able to find that on our website and would you expect that whichever one has more traffic would be more accurate or that's not necessarily true because of the way you changed it um so actually with um unison v3 the way that liquidity is provided means that trades cause the price to change less less extremely than they did on unisoft v2 so in general we find we think that uniswap v3 prices are going to be less manipulable even over a smaller smaller amount of liquidity on the protocol just because of how the prices are um because of how how liquidity is provided um the prices are also calculated differently um on unispot v2 it was an arithmetic mean and on unison v3 it's a geometric mean um so if you you're welcome to go and read about the differences between those two types of means but um in general it means that um v3 will probably track the current price slightly more closely but um you can go and if you read about the ins and outs of arithmetic and geometric means there are pros and cons of using each of them sure i'd definitely do that and the second question is uh you mentioned that there was like a circular queue i guess for the historical balances how how big is that kid so each pool is initialized with a queue of just one and anybody can uh submit a transaction that increases the size of the queue um so it starts with just an array of one where it only ever has one observation that continually gets overwritten and obviously that's not very helpful if you want an average price over a period of time because you need two data points to do that um i haven't looked recently at how many observations the major pools have but uh certainly some of them have had those increased by protocols so if a protocol knows that they're going to want the usdc eth price regularly and they're going to want 10 observations they can just quickly send a transaction that increases the size of the age 10 and the poor will forever then write at least 10 until someone increases it further is there any limit on the size of that number i believe yes but it's huge i think it might be 65 000 ish the power of two that's around 65 000. thank you great um and there's also two um a question in the chat from it burns is is there an indexer we could use right now something implemented over the graph for example um there is a uniswap graph um or subgraph sorry that um i'm sure you'll be able to find on the graphs website um that will record historical trades um in general if you want to implement an oracle that's that would be used for implementing on chain so that smart contracts can access the price so the presentation that i've just explained is for on-chain pricing if you want off-chain pricing then yes you can go and find the uniswap v3 sub graph and you'll be able to find prices of transactions from that another question i have is you said that you re record observations of any transactions now there are three different tokens so many permutation combination of uh tokens so are you saying that store all those observations in the chain yes so each pool that people can trade on it is only for two tokens so if you want to trade eth for usdc you would go and find the eth usdc pool that has just ethan usdc inside it for people to trade and that records its own price observations so the observations within that smart contract only record the price for each usdc if you want the price for a different pair of tokens you would go and find the pool relating to that pair and the observations for that pair are in that smart contract does that make sense yes thank you sir sorry i i have a question can i ask yep so who um initializes the pool do you white list the tokens and how does it work uh like the first initialization like how much liquidity one should provide you should one provide both tokens or only ones only one token and can you a bit you know make a short simulation in words of a pool initialization uh so anyone can deploy a new pool for a token pair if it doesn't already exist there's a factory contract that is provided by uniswap and you just say the two tokens that you want and if that contract doesn't already exist it'll give you the option to deploy a new one and you can do that through our interface um it's obviously deployed with no liquidity and whenever you add liquidity you add it at the going price so i believe the first deposit of liquidity you can add at any ratio uh that would quickly get traded of course to the to the current going price and any future anytime anyone adds liquidity to a pool they have to add the liquidity at the current ratio which is the current price so the adding liquidity don't alter the price was there anything else you asked oh no it's uh it's fine i think yeah has anyone else got a question for alice feel free to unmute or drop your question in the chat um i see there is another question yeah how is the price for the first trade defined um it's just defined by the current ratio of the liquidity so if there's one eth in the pool and there's 4000 usdc then the current price is 4000 usdc per eth and that price will change as you make the trade so you'll end up with a slightly different price for your trade but that's how the initial price of your trade is calculated so really the initial trades price is calculated by is set by whoever first adds liquidity to the poor and can i ask you another question sorry so is there like um any uh fully view function uh so view type like solidity view type function which can uh provide the unisof price so without using a enough chain uh quarter or a lens function or something that maybe we can like uh integrate directly on our contracts and because you know it's it's uh it's difficult to access your your storage right to uh to to see like your previous observations uh therefore this makes the things a bit difficult but uh so what's your opinion on that so there is on each pool the current tick is made public um and using the formula that i showed earlier in this presentation this is being recorded so you can come back and reference it um you you would be able to calculate the current price so you could plug the current tick value that the contract provides you do it 1.0001 to the power of that and a square root and you'll get the price um of the pool at that current moment but that is a spot price which should not be relied upon in d5 protocols because it's manipulable someone can quickly do a large trade and alter the price so that they can then use that to their advantage in your protocol the way to get a more resistant price is to um do a time weighted average price over time and you should be able to very easily use this oracle library it exposes everything you need to calculate that price on chain if you call the consult function for the pool that you want to that you want to query and you give it the period of time you want to query it over it'll give you the tick which is the price and that's depending on the amount of time you've provided that is like less manipulation less manipulable than the current price that you would find in the contract and then you can pass that tick into get quote at tick to get the actual current price and you don't have to do any of that math yourself and i would recommend this over just looking at the current take in a pool but this price is reliable or only within two initialized sticks right like if a swap is too big and it crosses the tip it's uh like the actual value that you will get in a swap is more yeah it's not simply know that the price times the the amount yes if you trade i think that's what you're asking if you if you perform a trade you don't get the current going price because of uh slippage um right simply yes anti-crossing also it's a it's a thing right tick crossing is just slippage um when the price changes as you make a trade the the price on chain has to change and the price changing means that the tick might change and if you cross a tick it just quickly removes some liquidity and add some other liquidity to the pool um that tick crossing will be recorded as an observation under certain circumstances i won't go into the exact circumstances that cause an observation but there's certain things that cause that um and those observations are what are looked at when you call the consult function so actually calling the consult function it includes tick crossings it includes when people have added liquidity it looks at all the observations that have occurred instead of just looking at the current tick thanks great um has anyone got any last questions for alice before we close out uh the session for today okay great um thanks so much alice for the great session and for handling all the questions coming in if you want to connect with the uni swap team they are in the sponsor uni swap channel in discord and yeah feel free to drop your questions there if you think of anything else thanks again alice and thanks everyone for joining 