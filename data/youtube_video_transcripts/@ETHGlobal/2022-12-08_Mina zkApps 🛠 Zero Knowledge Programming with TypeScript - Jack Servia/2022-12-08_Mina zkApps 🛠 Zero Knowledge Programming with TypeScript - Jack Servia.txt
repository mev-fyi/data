foreign [Applause] [Music] labs and we incubated uh the Mina protocol which is a layer on blockchain that we're going to be talking about today uh I'm based in Denver Colorado that's my Twitter and I'm a developer relations engineer so um okay I'm just not going to use this I think it doesn't work so okay so what are we gonna go through uh we're gonna talk about snarky JS which is the Smart contract language that we use for mina um we're going to do a simple example of a smart contract that checks if the number you submit uh you know is passing as an argument is is the next value in the Fibonacci sequence then we're going to make this recursive and then finally we're going to talk about the Mina protocol and uh we'll talk about where you can learn more and we'll do questions and answers after you can come grab me I'll stand next to the door for a little bit okay so snarky.js it's a typescript library for defining zero knowledge proofs and it's also the smart contract language for the Amina protocol uh this is what it looks like hopefully it looks like something that you can figure out because it is something that you can figure out uh everything is in typescript so you can keep using the tools you're familiar with uh like npm prettier yes lint vs code and it's very easy to learn uh you can see here the intellisense support is super good so you can just dive into a code base and if you're curious about what something does hover over it and you'll get a pretty good explanation it's also extremely powerful uh this is for two reasons one is kimchi which is our proof system and we have fully trusted setup we have custom constraints for hash functions elliptic curves and encryption this just means that these operations are very efficient the proof size is constant thus the O of one it's recursive meaning that we can verify proofs inside of other proofs and is blockage so we can add new features like Dynamic array access and a couple other things uh really the point of this is just that we've put all the horsepower that we can under the hood here so that's one side and then the other side is is you know what does it actually look like to use this what does the snarky Jazz library look like and um there's a few things that make it really powerful one of the first is we have method chaining uh this makes it very easy for developers to think through their programs in a pretty linear way so you can kind of see here we have an example we've got this value guess we can call the equals method on it pass in zero and then you know we can call the not method and so we're going to take something in this case I guess I think an array of fields and and you know we're going to get a Boolean um out and this is is not red Peg uh this probably seems pretty familiar and that's the point uh we've done our best to make programming in starkeyjs feel a lot like programming in in uh ecosystems you're familiar with already uh also we have structs what should we are exactly what they sound like they provide a layer of abstraction that makes data quite a bit easier to think about um we can see an example here uh we have this struct it has you know an array with public key and string um and it's called by Tuple and then we can uh down here uh you know pass this in as an argument this type and so a fundamental requirement of all zero knowledge proof systems is that the values are ultimately represented as something called a finite field element and um these uh are for the most part like unsigned integers but there's a kind of a couple interesting features uh or things that work differently and so uh structs eventually fundamentally they're all composed out of these field elements but with this abstraction you know we can we can Define things like this that are much easier to work with and so the struct will figure out how to take this information that we know how to work with in a format that makes sense and turn it into this underlying field representation so finally plenty of the stuff that you need is already implemented in starkeyjs so we have all sorts of different types you know these are these structs for groups public Keys private Keys signature scalers Etc efficient hash functions efficient encryption and decryption efficient signatures we have a Merkle trees and uh an API for recursion and more coming all the time so a lot of stuff that you need is just included in the starkeyjs library to begin with okay why did we choose typescript uh because we're ecosystem focused so the idea is that probably some people want to build Crazy cryptographic Primitives that let you do things that seem impossible and that's awesome you should totally build those uh and then there's other people who might want to ship you know user-facing products that make use of these powerful Primitives and the idea is that you'll just be able to you know import uh a library with whatever crazy thing like card card shuffling or you know something that's hard to do and we want to have code reuse that's as high as it is in the JavaScript ecosystem I think that that will kind of allow a whole new type of application to to kind of come forward which is you know applications that have the best product people and the best sort of like cryptographers working together uh to sort of you know open doors uh this is just a rehash we'll go through it because we're going real quick so how does snarky dress work here it is in five sentences uh it's a typescript library all the information is represented in one of these snarky just compatible types um so these are all composed of the field type and you know can be constructed using this struct abstraction um it provides classes and functions that are compatible with this field type or the structure that are composed on them so we have like for example you know if we have a field of value one then we have an ad method on this field type that we can use to add another field to it um okay so Starkey Jess can represent any of the operations that we do this way as this kimchi arithmetization which is basically a math problem that represents the program that we write in Starkey Js then when a user interacts with the snarkyjs program we can use this math problem version of the program to generate a zero and all truth that their interaction was legal how do the SMART contracts work developers write the smart contracts in typescript and they deploy the verification key to the ZK app account so zcap account is just like a contract account on on ethereum I mean it works a little bit differently but it's the same idea so a user generates this verification key for their program and they deploy the verification ghee to Mina and then we have a new smart contract on the menu Network users run the smart contract in their browser and then they generate a zero knowledge proof that their interaction was valid uh when you know when it comes time for people to to uh actually interact with the app once it's deployed so we can kind of see what this looks like we have my cool zika app a user does some stuff with it in the browser they make a transaction and the transaction has a zero knowledge proof and they send it to Mina and if it's valid then everything associated with that transaction gets committed and if it's invalid then it's dropped so if the mean of blockchain can validate the serial knowledge proof then it commits any of the relevant State updates this is kind of what the sunset's looking like we have a smart contract method it takes in some arguments some state from the smart contract and some values from the state of the world so smart contract state is exactly what it sounds like arguments are things that the user provide and values from the world can be things like block height you know um verifiable Randomness that kind of thing and what we get out when we run it is updates to the state and updates updates to the state of the smart contract and updates to the state of the world and a zero knowledge proof and so we pass the serenology font Amina and uh the um if the proof is valid then the state gets updated as as described here which we'll skip through that real quick okay how do zika apps work um so you install your smart contract in your UI repository and then you deploy it and that's all uh it's just typescript so you can publish it however you want to on GitHub or or using npm and then you can just install it you know exactly as you would any any other uh dependency um the the smart contract is is really just a dependency of your front end in this case and you call it just like you would any other Library okay so we'll get on to an example and I'm sorry that I'm going so fast like I said we're way behind time so uh come stop me after if you have any questions I know I'm kind of glossing over some stuff but here's what we'll do we're going to write a smart contract that calculates the next number of the Fibonacci sequence and uh it'll have two pieces of state and minus two and N minus one and um it'll have a it'll have a method update and and so this will let us update n minus two and N minus one but only if we pass in uh the correct number the correct you know next number in the sequence and uh so to write our zika app we're just going to extend this smart contract class um of snarkyjs into you know Fibonacci Sequence and now we have a smart contract and we'll Define some State and so ZK apps can contain uh you know on-chain State and in this case we need you know two pieces of it n minus one and N minus two and they're both of the type field uh we use the state decorator um to to basically tell snarky.js hey uh this is a variable and and you should do all the sort of work to make sure that when a user uh Alters this variable in their um browser then then if if necessary we reflect this change in in the actual blockchain itself uh so only types that are built out of field or or structs that are composer Fields can be used for these State variables and uh I think that's kind of all there is to say about State um we'll come back to it in just a second uh the next thing that we're going to do is we're going to override this deploy method so this deploy method is a method that's run when the smart contract is deployed it's kind of like the Constructor or like if you have like a truffle file it's the the um the JavaScript chunk that that deploys your contract um so in this case we're you know we're going to pass in some things from basically our our deploy tool um and then we're also going to set n minus one and N minus two to their initial values and so we're going to set n minus 2 to a field element of value zero and then minus one to a field element of value one and so now when the smart contract is deployed um we know that these values will be initialized to zero and one respectively finally we're going to define a user callable method uh in this case update and so update will take one uh one one argument uh n of type field and we can make as many methods as we want each one can have its own logic and do as much computation as you'd like um so the methods of the smart contract describe you know how it can be invoked once once the smart contract is actually deployed and um it's worth kind of calling out here that this this value is actually private uh any anything that we pass into to these user-defined methods is private until the point that it gets like mutated and emit emitted in an event or or used to update some sort of on-chain State um so of course the the state of the blockchain is public and the events and stuff are public but the actual execution of this code is not public um you do it yourself in your browser and you only share a zero knowledge proof that says that you did it correctly and then any you know meaningful output of this so in this case this n value is is not going to be uh you know revealed it we pass it in but we are passing it in on our local machine and and so it doesn't it doesn't ever like reach the nodes um so that's a like yeah that's something kind of worth calling out is is that uh you can anything that you pass in is private and along the the course of the execution it remains private until you do something not private with it basically so uh the update method we're going to use this uh get method on uh n minus two and N minus one and this is going to grab these values from the blockchain and then store them in these local variables um so when we when we run this code you know we're going to grab the values from the actual blockchain and put them in our in our local runtime uh and then what we're going to do is we're going to add n minus 2 to n minus 1. in order to get the next number in the Fibonacci sequence and we're going to assert that this new state you know the next number in the Fibonacci sequence is equal to n the value that we pass in and what this assertion statement does is it basically says well first of all if this doesn't hold true stop the execution but second of all um set up the zero knowledge proof in such a way that even if a user could override you know the the air that this throws they will not be able to generate a valid zero knowledge roof there's cryptographically nothing that they can do in order to make a valid zero knowledge proof for um you know invoking this method unless what they pass in does equal new state which also equals you know n minus two added to n minus one finally the last thing that we have to do is we'll set our on-chain state to new values so we're going to basically take our new you know the value that we passed in the next number in the sequence and we're going to set that to n minus 1 and then we're going to move n minus 1 over to n minus 2 and N minus 2 is going to get you know sort of pushed off the end so that's it that's kind of the basic structure of the smart contract we you know uh uh Define state set up our our deployment and then Define the methods that users will be able to call once the smart contract is deployed now we're going to do something extra cool and I'll just blow through this really quickly the point is kind of like uh to understand what's possible just because we have limited time so um what we can do this smart contract as it works right now is the same as an ethereum smart contract a user calls a method they create a transaction they send a transaction they wait for it to be mined and they pay a fee but uh Mina allows you to structure things quite differently using recursive zero knowledge proofs and so instead of writing a smart contract what we do here is we create a ZK program and a ZK program is kind of like a subset of a smart contract it's a provable program it doesn't have the connective tissue for things like um State and and that kind of thing um so it's a provable program but what's really cool is that if we look at these methods we can see um as input we can actually take proofs and the output of sort of running this is also a proof and so we can verify that the proofs that we pass in are valid inside of this proof so we can have a proof that accepts other proofs as arguments and then verifies that these proofs are valid and then also does some other thing and and this is really powerful because you have arbitrary branches and merges and you can do it an infinite number of times so you could do something like use this to prove that you've kept a correct moving average for 100 years or 10 years without uh without having to store all of the the previous data you could use this to do something like make a smart contract that I don't know maybe does like machine learning inferencing or something and has to you know scale horizontally across many machines um and you can do it for simpler more practical things like if you want to build a game you can build a game where one user makes a proof sends it to the other user the user validates their proof and then builds the proof on top of their proof that proves that their move is legal and so you could do something like build a game where users go back and forth peer-to-peer there's no blocks there's no fees and at the end we get a single proof that attests to the fact that the entire game has been played correctly and then we can pass that proof as an input into a mean a spark contract and settle the game that way so this opens the door to all kinds of crazy stuff um mostly probably people who are interested in kind of the scalability aspect so come talk to me about this more after if you're interested um yeah it's pretty simple we can just uh have our our um uh we basically make a type for you know the type of proof that we're going to use and then and then we pass this in you know as an argument in our smart contract and call verify on it okay now let's talk about the media protocol what is Mina it's a layer on blockchain that proves its entire finalized State using recursive zero knowledge proofs so it works kind of like we just described um while other blockchains grow they need all of the information in order to be able to verify any of the information basically Mina does not you just need a zero knowledge proof and the information that you're interested in in order to be able to verify that that information is is valid and so it stays a fixed size 22 kilobytes um is this cool or is it actually useful uh it's it's both it's really cool and it's really useful so the first reason is obviously privacy I think we kind of touched on this a little bit before but ethereum smart contracts uh run on every single node so all the information is is public um you can see what this kind of looks like if we call some method on an ethereum smart contract we send it to every single node and every single node has to has to run this method mini smart contracts run in the browser and so the arguments and intermediate about sorry the arguments and the intermediate values are private by default uh what this means is that you know the user runs this the smart contract themselves uh they don't have to share what that looks like with anybody and then they just take the relevant State updates and the proof and send that on to the mean of blockchain mina simply verifies the proof and updates the state on chain if if you know the proof is valid okay uh what about scalability there's no gas model uh for ZK apps they run off chain and so the amount of computation doesn't affect the transaction cost you can actually do an unlimited amount of computation especially using this recursive proof mechanism um and and then send you know a single transaction that attests to all of this so developers uh yeah can use recursion to build application specific Roll-Ups we kind of touched on this a little bit earlier um what about decentralization okay so as we talked about uh Mina stays 22 kilobytes and so it's actually the the amount of information you need in order to verify that the current state route of mina is valid is 22 kilobytes and so it's possible to validate the entire chain State using just this small zero knowledge proof and what that means in practice is that uh there's no need to rely on trusted third-party node operators like inferior or Alchemy or you know something like that you can run basically a node that only worries about your account but doesn't have any sort of other like security concessions um it's a full node but it's a full node only for your account uh bridging is another thing that we can do kind of differently than than I think a lot of other blockchains uh a smart contract on another chain can Bridge the whole mean estate just by verifying the most recent proof that Mina generates and so what that means is that uh well I guess here's a good example we can write a smart contract on ethereum with a method and the method will take in as an argument the mean estate route you know the root of this Merkle tree and it will also take in the most recent Mina zero knowledge proof and we can pass in the zero you know then any user can call this method pass in the most recent zero knowledge proof and pass in the mean estate route and this ethereum uh contract can check that the the zero knowledge proof is valid and if it is then it can update the state route on ethereum and then when a user wants to use some you know specific information from Mina they can I don't know grab this chunk down here and provide the rest of the Merkle path and then validate validate it against the um the the actual uh State Route that's stored in this in this bridge contract in this case and so this is not just hypothetical the nil Foundation is working on this right now uh with a joint Grant from the ethereum foundation and the Mina Foundation um so yeah you can actually check out a demo we'll have a QR code at the end that um has this demo uh we pass in our you know three relevant pieces of information and uh create a transaction and actually eventually set it through metamask to one of the uh ethereum test Nets I forget which one uh another thing that can work kind of differently is Oracles um this is something that I'm not quite as exposed to but the kind of broad Strokes idea is that users will be able to create proofs um that they've accessed a website through you know this SSL exchange and so um when you you know go to a website right now you have a little lock in your browser and it basically says you know we use some protocol to ensure that I'm talking to the party that I think I'm talking to and they're talking to me and nobody's tampering with anything in the middle but the problem with this is that it's it's an interactive exchange and so it's only compelling to the you know to the two parties involved in it using zero knowledge groups we can take this interactive exchange and make it non-interactive and so what this would end up looking like in practice is a user might be able to do something like go to I don't know a website that publishes the results of soccer games and they could prove I went to the New York Times or whatever website publishes soccer games and I saw that on this page um we had the result of this soccer game uh I'm sorry football game uh published as um you know let's say I don't know uh America lost um let's say that um uh then we can take this information and pass it you know straight into a smart contract we can get a non-interactive proof that we went to this website and that it said that this was true and then we can pass it into uh another smart contract on the blockchain so this opens the door to to kind of people being able to create oracles without having to set up these complicated pools of of like relayers that are gonna like you know I don't know stick some sort of sort of capital and and participate in some kind of like Game Theory thing um you can just cryptographically know that you know this person really did go to this website and the website really did say this thing what else is possible well we actually don't even know everything that's possible yet and that's why we're really excited to be here because um there's plenty of things that we hadn't really thought about six months ago that seem like a good idea and uh like a feasible idea now and that's kind of what we're hoping is that you know everybody at eth India probably has a lot of collective brain power and maybe we can find new things that we can do with Mina that we didn't even know were possible yet we have all this technology and it opens a bunch of unique doors that nobody has really explored yet and with a bunch of people I think we can kind of explore all these Avenues together and maybe find some really cool things that nobody has even thought about doing yet uh we'll skip this and now we'll talk about where can we get more uh so how do you get started it's really simple we have a single developer tool it's called the zika app CLI it's very powerful and it's very easy to use it's just an npn package you can install it and then you can run ZK project uh and then a name let's say hello when you do this it'll create a project for you scaffold it and and also include um an example smart contract and an example test and so you can just you know install the zcap CLI create a project and then start poking around with it and look at the intellisense in vs code and get a sense for what's going on I mean you can even deploy this to like Berkeley QA net or I'm sorry Berkeley test net tonight um uh uh there will be cards next to the door when you leave that have simpler instructions for this so yeah you can get started in like five minutes this way we also have a bunch of tutorials and um other documentation I will have a link for that after um how can you how else can you get involved so you can visit our docs that's probably the easiest way to get started um you can also apply for retroactive grants we have a retroactive grant program um we have also ZK ignite which is a uh I don't know I think I think we'll have more details um at the desk but it's basically a program where we have I think I think we have the next slide talks about it uh and then finally you can you can also build a ZK app which is a good thing to do because the Caps um yeah are all eligible for the prizes here at uh at East India okay so yeah ZK ignites um you can start building zika apps and get rewarded from a pool of 250 000 Mina um with some bonus prizes this is a code you can scan to kind of get signed up and then you know in order to kind of get yourself up to speed on all of this you can also check out the docs at um uh Mina protocol.com um forward slash CK apps just and this is a QR code uh that you can scan really quickly if you're I'll snap back to the other QR code in a second this one has got uh links to the presentation here and some of the things that I talked about in it like for example the nil Foundation Bridge um I think it has links to uh the docs uh some GitHub repositories um some other things so I'll do this one for a second and then I'll flip back to the other one in five four three to one and if you miss it just come stop me after our booth is in the middle kind of right in the between the hallway between like the left section of the room and the right section of the room um and here's the the Zeke ignite cohort zero QR code awesome I'm sorry I went so fast if you have any questions uh come talk to me after I will have way better answers for you then um but uh thank you so much for having me and uh I hope this was interesting 