hello everybody I'm Greg from provable things and we are a or an Oracle or for smart contracts so who here has ever needed the results of a Web API on a smart contract they don't need it for this hack in fact that's a shame dennis is gonna not I'm gonna use him he's a colleague of mine so but that's what we're ideal for we are a as this says a security oriented a data transport layer for decentralized applications to connect with Web API s which is quite a mouthful but it is exactly what we do we connect smart contracts with where API is in a secure fashion and a provable fashion which is where our name comes Tom we used to be known as Oracle eyes we are now known as provable and it kind of fits better cuz everything we do is provable cryptographically for security reasons and for you guys to be able to trust what you're getting into your smart contracts we have been on the main net for for nearly five years now which is crazy this slide is definitely old because we're way over a million queries we're probably nearer to these days we've been adopted by tons of projects we're on all sorts of blockchains including private ones which is cool and we're also in ebooks now which is excellent CEO Tom Savini is in that book right there which is good book if you haven't already got it so we are easy to use which is probably our key feature when it comes to solidity and even this sort of slide makes it look more difficult than it is because that import line at the bottom is pretty much all you need hello to get your contract working with our service and it is literally as simple as importing that API and it's so simple in fact that I can actually show you super easily on the next slide in a single slide which is cool try that with other known Oracle's out there we are integrated with various of the frameworks you guys need and have used to make your city projects with truffle remix open Zeppelin these are all great people and we've tried our best to make everything works super well with them so that it's quick and easy for you guys to get working with the same environments you're used to using so who uses truffle yeah most super-easy so again we actually have a starter kit actually with truffle nowadays which makes it super easy where has it always a truffle box yeah used it da it's nearly gonna be a friend it's really easy you definitely should use it it's over here I'll get but you don't actually need that because you can just unbox it via a truffle which you guys will know if you've used truffle before unbox it go into it install stuff the reason we're stuck in a box is for this step which is the way that our Oracle service can work on your test network because when you're running locally you're running a version like test our PC or ganache as it's now called and that's local how on earth can we interact with that well we do that via the etherion bridge which is a great piece of software and works well but we don't want you guys to have to learn about it if you don't want to so the truffle box does all this for you and bootstraps it up super easy so don't worry about this too much yet if you're gonna use it or full box this is all done for you and once you've pulled the truffle box it is as simple as going into truffles development console running the bridge in a separate terminal next to it and then you can run tests the truffle stock it has a small contract in it with some tests written so that you guys can have a look through as to how you'd arrange that yourselves and how you'd organize tests in a sort of truffle environment with our a theory and bridge your running and our Oracle making actual calls and if you run this test you'll be able to see in the console we've got the bridge running you'll see the service running and you get to see all your results as they come in live which is great fun and super easy for debugging so that easy now this is the main bit of this talk obviously because it's Agathon and you're gonna want to see how to use it and the reason that we claim where the easiest oracle is because the next slide proves it this is a fully working fully compiling contract that is getting an external temperature in fact which here is kind of pointless because we all know it's freezing so we don't need to know the temperature any other than that but this whole contract is gonna ask an external web api for the temperature at a particular longitude and latitude as you can see on there and when it does so it's going to turn it to your smart contract and that's baked in and dead easy and it is that big or small sorry I should say small so if you have a look through this example you'll see the basic format for how our Oracle works or you can see you tend to have two functions one of them which calls for your query and one of them which we call the callback with the double underscores at the bottom there which is how you get the result back into your smart contract and if you look at the get temperature function you'll see the query is super simple there are various other cases for this but this is the simplest URL data source query you can get and you can see we're asking for a URL via the URL bit and then we're passing in the URL there is indeed a rap bit of JSON around it which is just to alert that you want the jason that that API returns passing down to just the main and temp fields but tiny bit of actual complication but the point being when you ask for a web api you're gonna get a huge JSON back most of the time and you're probably not gonna want all of that data so we make it as easy as possible for you to get just the piece of data you want um all of you who's worked in solidity know how expensive it is to store and have anything in solidity so this way means you can get just a tiny bit of data you need without having to store anything else and thus cheapest gas possible once you've made the query in this case you'll see a callback function gets called which you can see the parameters are a query ID and the result the query ID is a unique string given to every query this allows you to be able to track them in your own smart contract it also allows you to do other cool stuff outside of the smart contract whereby other people can view your query and verify your query which is super useful in terms of decentralization and the result obviously is the result you're after which you'll notice is a string in the callback functions we first check that it is indeed the Oracle service calling this contract so you can't have anybody calling it with results which would put your contract in a bad state and in this example I was checking whether we need a jacket in Waterloo but we need a jacket undercoat and extra layers because it's freezing here so this is not so much fun for this one but you get the idea if we go on though we're gonna see more examples that get slightly more complicated via the use of authenticity proofs these proofs are how we as a service allow you to be trusting that the result you get is what you asked for so we don't want you to trust us because this is aetherium you shouldn't be trusting anybody you should be verifying stuff and so we provide cryptographic proofs that what we do is exactly what you asked for and in those proofs you can take those and you can verify them yourselves and there are various different types of proofs and whatnot which I won't go too in depth too but the point being via the proofs you get to decide whom your tryst line ends with so for example if you use a TLS end notary you're trusting Amazon now and so on rather than us which is the way the proofs work the previous example I showed you that have no proof is what you probably do for like a hack today if you just need some quick data in your smart contract something in production we would recommend using authenticity proofs and we say plural because you can use multiple you can decide to decentralize further and further and rely on various different data sources quickly and easily and in a verifiable way so here's one using a proof I've made it orange so it's super easy this one is using the Android proof which is using the t'ee on an Android device a te sorry is a trusted execution environment and what it does is we make your query happen via this trusted execution environment and then provide a proof that that did indeed happen via that trusted execution environment meaning you can check that and have all the days you need to know that what query we made on your behalf was made exactly how you required it in this case the rest of the contract which again notice fits on one slide is super tiny we've got a function and a callback our function this time is an update function it's the URL data source again it's another jason so we're gonna pass this result down and this is from the Krakken api so we're obviously getting a price and it's the eath in Bitcoin price I think so same again we make the query and then the query comes but as a callback we require that the message sender is indeed the Oracle and then we set the result then a difference this time is that your result if you look the callback function has three parameters the third of which is the proof which comes straight as bytes which you can do with as you wish in your smart as you can see in this contract we've done precisely nothing with it so I don't recommend that it would be pointless but you can be storing in a contract you can be verifying in a contract you can do as you wish the point being at this point with a proof you can verify that what you get is what you want it hello do you have a question no that's all done on the backend side for you we provide those services for you so you don't have to worry about that whatsoever and we provide ways for you to verify them as well so it's all good the next example is another proof type which this time it's TLS a notary which as I said oh yeah is ours are based and we're interesting all that and but the key to this slide again one contract fits entirely on one slide through query is that we're actually storing the proof now via IP FS which you can see there and the reason this is good is that some of the proofs depending on the proof type can be large these are cryptographic proofs and they can date they're not a fixed size and it depends also on your query if these are huge you don't want to be storing all those bytes in your smart contract because it costs a lot of gas so instead you can actually store them an IP FS and then what you get returned in your callback function here is the hash instead which I've not terribly cuz I've forgot to put the proof on that one which if I had to put the proof in the callback you would get a hash in ipfs hash away your proof lives and then again all you got to do that's decentralize you've got your hash you can then verify the proof that way or the user can or whomever is that needs to rely on this result same story it's a URL query in fact it's exactly the same as you they're examples in you can see two lines got it done so that is another proof type the final example is a really useful one for any sorts of hacks to do with stuff like this and that's randomness because randomness as you know is very difficult on a deterministic chain as it ought to be so what do we do we go offline for random 'less how do we go offline for under miss you need an Oracle how do we provide that we use a ledger which you all whose got anyone got a ledger anyone use a ledger you've happened up forever that's one one at least another device that has a trusted execution environment inside it so we leverage that and we've written a program put it in there and said hey get us some randomness using the actual on-chip randomness it's true so that randomness none of the problems you'll get of blockchain randomness and this time we're gonna use the ledger proof which unsurprisingly it's the proof type for the ledger that we're using so same thing unfortunately this one can't fit on one slide but it's a good reason for that so I can't show off the size of it this is a fraction bigger but the reason it's bigger is because with the ledger proof you can verify that proof on chain not all of our proof types are verifiable unchanged you to size and various other issues but the ledger proof is one that is verifiable on chain and when it comes to randomness you'll know if you're doing anything sort of gambling that's the randomness is critical and for example you couldn't have randomness into your contract and then have that randomness not be verified cryptographically a later point by which time you may have already paid out a price that would be a disaster so the ledger proof allows you to verify it on chain which means before where you would in your callback function probably pay out a prize for example if it was a lottery let's say now you can actually switch the logic based on whether it's verified or not which is super critical and super important especially when it comes to the randomness so the same story we have a function that calls the data source in this case it's a little bit more complicated because we're asking specifically for a random data source and we've got to give it and say how many bytes are randomness do we want you've got a couple of other parameters ones called delay we've got it as 0 so there's no delay but the point being there which is useful for other contracts as well is that you can have a delay which means that you can say hey here's a query but I want the answer tomorrow now that's super useful because it's impossible to defer a query in that sort of way any other way you can't do it yourself other than by manually doing it whereas this way you can ask the Oracle to defer it for you and it will come back a day later super useful the bytes you can ask for as many number of bytes as you need based on the way it works you can cast those bytes to an int for random numbers and obviously p7 bytes will be a huge number so there's plenty of entropy there if you need and finally in the callback is where we're gonna check first is it the Oracle calling me yes and then we're gonna try and verify the proof at which point there's some maths going on there which you don't need to be familiar with if you don't need but it's basically turning our bytes into a number in a safe way without any bias and if it's verified we will do that math then you can go on for the contracts logic to do something with your randomness otherwise if it's failed prevarication failed handle it which is however you need to do it but the point is now you can handle that inside your smart contract so that's really cool this is basically what I've just said the top half of the slide so it's not much use I'll let you have a quick read the bottom half is more interesting though because it shows that we have more data sources you can ask a WolframAlpha or a stuff fire our Oracle you can do nested queries which is super cool way you can make a query that makes a query to do other stuff so you can start combining data sources and getting really powerful stuff going on you can use encryption in your queries so if you're calling an API that Hut's an API key and you don't want your API key falling into the public hands how do you have that unchain well encrypt it we can deal with that too so super useful and then finally which is one bullet point but you could expound on it for hours is the computation data source which if you're used to solidity is really useful because with the computation data source you can run any computation you like and have the Oracle call to that computation so you can defer computation off chain which means you're no longer bound by the EVM and solidity and all the various gas type situations there in terms of size length of time time amount to compute stuff so on it's a block gas limit etc so the computation data source you could write a computation let's say in Python stick it in a docker and then have the Oracle call to that computation with params from your contract and then get the result back to your contract which as you can see out source is a ton of expensive work if you want it to so that's mega useful there's no example here because it's probably been more complicated but if any of you want something like that and especially for a hack today I'll be hanging around and you can just go and ask it's dead simple it just doesn't fit on one slide so it doesn't look quite as neat as the rest that's why it's not there so that's cool and some of the other stuff we have our verification tools for those various proofs as you've seen some of them are verifiable online so the tool is useless for those but the ones that aren't these open source tools allowing you or your customers to verify proof so that they know the data they're relying on is reliable so that's cool and we have two other quite handy tools which are on our website which the test query and the check query tools which means if you're at a hackathon for example making provable queries you can use these tools to very quickly iterate over your query to check you're getting the right answer so this saves you having to go into solidity having to write your query having to debug a whole bunch of other issues this way you can just write your query and see the result in real time what would you get and once you've got it working on the check on the test query tool you can stick that straight in to solidity and you'll get the right results so that's super cool and importantly on this slide is the number at the bottom so we have tons of credits for you available for anyone who uses the provable Oracle in your contracts there are surprises like everyone else is doing and basically these are main net credits because there is a cost to the service but not if you win this so that's cool so get using it if you need any help I'm around and you can just ask me and there is one final cool new thing that I've got to point out which was announced I think Def Con which is something else we're doing which is this using much of the same technologies but it is the P token which I've been working on personally which is actually a sort of it's the same te stuff that we use on the same Oracle service but if you twist it around and act as if a wallet on another chain is the source of the data for your Oracle and then the TE is the Oracle what you end up with is a decentralized under approvable peg between two different chains which allows for all sorts of cool stuff so it defines this is written here which are quite like and it's a way that we're using our own Oracle to bring all sorts of liquidity from other chains onto aetherium so we have a proof of concept of this which there's a lot of text I'll let you read that I'm not sure on my time for that since I have like two minutes but basically as you can see we're taking two block chains and smashing them together inside one trusted execution environment which trusted execution environment holds both sets of keys and the second sign cross chain transactions in a way that is completely unseeable by humans and totally decentralized and can be run now anyone who has the same te hardware which makes it super cool for a peg like this our proof of concept currently using EOS so on this side you can see there's two chains talking to each other via a trusted execution environment the non eath blockchain our proof of concepts using is yes and the youth blockchain then has what we're calling provable or pious on it which is cool and that describes that this is the front for when it looks like it so if you've got some yes you can just go on our dashboard and you can deposit EOS to the EOS side smart contracts and it will mint P us on the east side of this is just showing you some of the minting x' you can see the circulating supply and the underlying asset which should be in parity except for a few deposit and then look before it's mind on one or two of the other sides but they're on parity most of the time you can actually it's decentralized in the sense that people can submit their own blocks to an enclave to do it as well so you don't need there's no it doesn't rely on anybody running this stuff it realizes totally decentralized anyone could submit eath books or yes blocks to our Enclave and it will process any transactions it finds pertaining to either sides wallet which is super cool and so yeah as you can see this is the one direction where you deposit say yes for our proof of concept trusted execution environment will see that and will sign a equal and opposite transaction on aetherium and then boom you have p us on aetherium and vice versa where you would go to this POS small contractor and burn that token the Enclave we'll see that transaction happen it will sign the equal and opposite one and thus release your EOS to whatever account you've specified so it's super cool and like I said all you have to do is look at it as I said the wallet on one side is the data source and then the execution environment is the Oracle and you see how it's all the same cool tools that we're using just in a new defy sorta way so here's some alt let you have a look at these these slides have been made available to all of you guys via the car remember where I'll figure it out but this is why it's great and there's tons of info on there I'm not going to go through it all in my - one minute of time left but that is just a little example of one of the applications that is cool for Oracle's that's quite an advanced one but hopefully we're gonna see you guys do something with an Oracle that's also is cool any questions I don't either that was cool thank you are you allowed to ask for we're any questions sorry correct well yeah we're similar we do the same thing but we're very different in executions so we've been a sorry well that's that that's what what's funny we could to be an Oracle on their network that'd be no problem with that what they don't have is the authenticity proof so when you go on chain link you would have for a chain link Oracle you would pick one to choose or multiple but the problem each one of those your the interesting each one of those whether they want to provide authenticity proofs I don't think any of them do but you don't have any guarantee that what they're doing is correct if you use more than one you're gonna get some sort of Byzantine fault tolerance thing going on where you can a trust X at or why maybe but most of the times you're gonna be used a single Oracle because of the costs and at that point you just stuck trusting that Oracle even though their network is decentralized so it's like it's a totally different trust model which is really interesting and they work well for different cases so no we do single Oracle with many trust lines so that's the difference so because you can use multiple proofs you can trust these different big name servers like Qualcomm Amazon and so on and Google for the tes that we use like the Android te and you're trusting those guys so you can put like a monetary value on how much you can trust to them so one Oracle with multiple trust lines versus multiple Oracle's with no trust lines except where you decide see the difference yes yeah yeah so where both the both on the scale of decentralization just in totally different ways which is quite interesting we've also been around a lot longer because we've been in the space for ages but anyway any you had a question cool yeah feel free to isolate any else go ahead we are Oracle eyes so it's really confusing we yeah we've rebranded it's super confusing I'm really sorry about that but yeah we are very good so that's it anyone else thanks for all paying attention and occasional laughing at my jokes 