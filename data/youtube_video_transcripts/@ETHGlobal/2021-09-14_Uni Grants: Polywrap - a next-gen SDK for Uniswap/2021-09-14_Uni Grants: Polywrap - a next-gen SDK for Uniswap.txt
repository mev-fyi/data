all right hey everyone uh welcome to uh the uni uh uni grants poly rap workshop uh i'm shawn ahn i am uh from east global you might see me on the server as peep um so i'd really like to warmly welcome uh jordan and kevin from uni grants uh such a pleasure to have them here and i'll hand it uh to you both to take it away hey everybody how's it going uh this is jordan and then also kevin's here as well hey everyone and yeah we're excited to talk to you about um the uh uniswap polywrapper that we built for the uni grand style and so we'll give a quick presentation to describe what is polywrap and and what is this this new thing that we created and then we'll show a quick demo um and a little coding workshop where we walk through how we actually do this awesome hey everyone i'm kevin i'm the developer relations engineer at polywrap and jordan is one of the original developers we're here to show you our project polywrap it's the next generation sdk for web3 and just a note it's formerly known as web3 api so in our code you'll notice that some of the code still uses the old terminology it'll be changed soon which we'll be changing yeah uh so what's the bottleneck with um web3 development today um most web 3 protocols maintain software development kits or sdks in javascript and it allows for integration but the the issue with javascript sdks are that one they're not secure and they're not very composable so say you want to integrate new swap and openc and other uh protocol sdks they're they're all built in there's their different ways and it's hard to compose them and lastly they're not very compatible with enterprise gaming metaverse and iot use cases yeah and the the main reason why they're incompatible with those use cases is because they're language specific so you know good luck using your javascript in like a native game or you know a game written in uh in a game engine like unity or something like that and so we think web 3 deserves a better integration solution and that solution is polar up that polywrap is a containerized protocol that brings web3 anywhere and everywhere so what we describe as the next generation sdk polywrap is has event advantages over traditional sdks because it's more secure we use web assembly inside poly wrappers which are allocated their own virtual memory polywrappers are hyper composable so there will be standards for different poly wrappers that that you can easily use to compose them together and there um since it's web assembly it'll compile it'll be able to run in any web assembly uh environment um yeah and so yeah that includes you know like back-end services for enterprise or you know native mobile applications or iot devices or games and so you know being able to write one sdk that is able to run everywhere and just a very high level overview of the playwrap experience first you'd wrap your protocol meaning you write all your protocol business logic like a union swap swap function in a language that compiles down to web assembly like assembly script next after you write all your protocol business logic you would deploy your poly wrapper into a decentralized hosting service like ipfs and then third other adapt developers can integrate your polywrapper by installing the polywrap client which will be able to fetch all the business logic all at runtime and so currently the polyrub client that we have developed first is the javascript client and we'll be developing more in the future next up we'll be making a native client with rust that that can work in uh all native platforms and next we're showing you our poly app hub which is a ui for all the poly wrappers that are deployed it's like a marketplace where you can explore different business logic that is deployed and test them out in our playground and here's a screenshot of the playground you can test a query and mutation code here um they're written in graphql and you can connect your wallet write the code click run and it'll give you back your results yeah and uh just to stress this is reading and writing uh to and from protocols and a couple months ago we were funded by uni grants to do a case study for the uni polywrapper and uh what we did in this case was we took out we forked the unswap interface and we swapped out all the the unisop javascript sdk and replaced it with the polywrappers um so on the right here you can see the advantages but um imagine being able to use uniswap one day in enterprise apps like paypal or robinhood like with polywrap these use cases are possible yeah and right at the bottom right here there's a url which i'll go ahead and show you in a little bit but you can actually test out the demo for yourself and just an overview of our dow we have some of the top dev shops working on this project dior chain safe consider it done and more and we also have launch partners supporting our project so these launch partners help us you know review our documentation they also get early access to products like the polywrap hub and so on and also at the bottom you can see our different funders awesome uh thank you so much kevin um and i'd love to take you all through a quick demo and so first um let's just start with the demo application for uniswap and so like we were stating it's at this url demo.uniswap.polywrap.io you can go ahead and just use it just as you would normally with the regular uniswap interface um and so here you know we'll go ahead and connect our wallet we'll say we want to swap you know point you know zero one let's say eth for let's say some uni tokens and so what's actually happening in the background here um it happened pretty quickly but what happened is the polywrap client was uh taking these queries um for instance these queries shown over here uh for example best trade exact in and it's sending it or it's it's um executing it on this ens uri and so if you want to actually see the ens domain that the polywrapper lives at um it's right over here it's v2.uniswap.web3api.eth and on the content hash you can see that there's an ipfs hash which points to the polywrap package and so this is the actual package that your app is downloading and running at runtime and you can see these query and mutation webassembly modules they're relatively small and that's why you know it was able to fetch them so quickly and execute you know the best trade exact in uh function call on the webassembly and you know again just to stress the reason why we're using webassembly is because it's more secure and it's also multi-platform and so you can actually use the same code on any device and not just inside the browser um and so this is all cool and dandy but let's actually jump into a workshop where we can show you how to use this and so here we've created a repository let me just pull up this link here it's at polywrap slash workshop or uni workshop this is the url here um and we can go ahead and just step through these readmes and they will basically walk you through creating a custom uniswapped app and then also creating your own polywrapper which uses uniswap inside of it and so let's go ahead and do that um first off if we look at this guy um it links to the presentation you just saw and then additionally it links to our website and you know we since this is like a little bit of a strange concept to wrap your head around we really wanted to make the website as easy to digest as possible so if you're still having a hard time understanding what polyrep is and what its benefits are really recommend just taking a look at the website and starting to read through you know like what our different benefits are and how it all works um and so yeah without further ado let's get going um so we're gonna start with creating the custom uniswap dap and so we're gonna go ahead and start here so here we are in this readme um then uh first off you know we have some prerequisites i'm going to skip over just some of the more boring parts and just get the fun parts um we're going to first go ahead and change our adapt directory we're going to do nvmus whoops to use the right version of node we're going to install some packages and then once we do that we're going to actually start up the application so let's do yarn start and check out what this app looks like and so this is the app before anything has been done to it so none of the uniswap functionality exists there and so what we'll see is we'll just see you know a very simple interface here where we can insert like a text amount we can connect our wallet and then we can select let's say eth we can maybe select ave let's say but you know it's not showing the correct output for us and the swap book uh the the swap button also doesn't work and so if we go through the steps in this readme it'll actually have us hook all this up so let's go ahead and let's go ahead and do that and so first here we're going to be fetching the token output amounts and so here it tells you about in unit swap there's this concept of a token pair we're going to be taking a token pair of two tokens and figuring out what the exchange rate is between those and then calculating what the output amount is uh you know given the given the input amount and so all this sounds complex but you know when it's all wrapped into a nice sdk and it's made as easy to query as polywrap makes it it just becomes this little short code snippet here where we simply just say here let's actually copy this code into our into our file first so we can look at it with some better syntax highlighting um here what we do is we have this function fetch swap output amount and we have the polyrep client and you know as kevin was saying before it's currently named uh web3 api since that was our old name and so just kind of don't mind that and so here we're saying client.query the ens domain which you know there's a little handy tool tip here ens goes to ipfs goes to wasm downloaded and run right inside your application and then we have a query so this is where we actually call the function that's going to be doing our work so this is uh pair output amount we give it our token pair and our input amount and we're good to go and so now if we go back to our application we can see that it's already updated and it's already fetched what the output amount is pretty cool and so let's go ahead and expand upon this functionality and so next up we're going to allow uniswap to swap our erc20s and so we need to give it uh an erc20 token approval to be able to move our tokens around for us and so here um as you guessed it it just comes down to another query we have um a query to the ethereum polywrapper and we're saying call contract view allowance so we're basically figuring out if we need to grant approval so this is approval needed and so let's go ahead and copy this in and first off before we do that let's check out die because i know for a fact i haven't given die approval so it's still saying swap so that's not correct so let's go ahead and go into this approval needed file paste in the code again just to walk through what's happening here we call this view function allowance so so we get the allowance um we then get the result down here which is our allowance um we use this uh this decimal library to parse the the large numbers um and then we just do allowance greater than spending so it's saying that if the allowance in the contract is greater than what the user wants to spend then we um you know already gave it we already gave it approval and so here um if we look now at our application it says approve and so if we go to something that's already approved let's say um whoops like let's say uh unison it just says swap and then again if we go back to die it says approve and if we click this button nothing is happening yet and so that's the next part we'll actually implement the approval logic and so now that we've figured out if approval is needed we can actually approve the token so here we're sending now a a query to the ens uri of our uniswap wrapper and we're calling the approve function and so if we go here go ahead and paste this in um inside of this approve function it's going to actually send out an ethereum transaction and so let's actually see that in the works so here go ahead and click approve sometimes my wallet integration is spotty so you know if you want to fix up the wallet integration please feel free but if you just basically disconnect and reconnect it should fix it and then here it's going to ask us for a approval cool so that's working we're going to reject that because we don't want to wait for that right now all right so then um next up now that we've finished up the approval process let's actually implement the swap and so here um as you can see it's a little bit more code but let's check it out let's let's see what it's doing it may look a little scary but let's see what it's actually doing here um inside of the swap token pair function right here we have our inputs and then we pass them along to the polywrap client and we say client.query and we call this swap function and so the swap function that's pretty straightforward it just takes an uh token in token out and amount and how you want that amount to be treated so we want this to be an input amount so we say exact input you could also say exact output if you wanted this amount to be the amount you get back from the trade um and so here we go ahead and we call the swap function and um you know inside of the unit swap polywrapper it's going to be calling ethereum and executing that transaction so let's check that out um let's switch over to east let's say let's do like point zero one or point one and let's actually purchase some uniswap and we're gonna do this on mainnet and let's see what happens let's go ahead and oh whoa wow okay that's all right you know what it's for the cause um and so now we've submitted our transaction there's no notification set up or anything like that um in the in the like you know official fork there is it's all clean and nice but this was just like a really scrappy lightweight demo um and so here if we check out the transaction that just got sent out we should be able to find an ether scan and there it is oh sweet good timing so we got some uni that's cool so we now have a fully functioning uniswap app um it just kind of took a little bit of copy and pasting it was all kind of set up for us but all of the actual integration with uniswap was pretty straightforward it was just a few calls using the polywrap client and so to recap as you just seen you know integrating web3 protocols into your applications has never been so easy the idea here is that we're trying to make it as easy as web 2 so in the same way as web 2 where you can send let's say a query to twitter's api or to stripes api we want to make that same experience in web3 and you know we want to support write operations as well but without just uh sacrificing decentralization because we don't want to trust a central server and we also don't want to pay for an expensive network to to do the work for us so how do we solve this well we download webassembly and we run it inside of our application that's that's the idea um yeah so there's a few links here and um without spending too much more time oh uh the one last thing i want to say is that this link here actually brings you to the code of the uni swap demo and so if you wanted to see like a fully working fork of the unisop interface using polywrap you can check this repo out here so um what's up next what's up next so we we did the application and so now let's go ahead and do the poly wrapper so here we will create our our own poly wrap that is using uniswap inside of it so again we just have some prerequisites um skip over the boring stuff yada yada let's go ahead and let's change into the uh wrapper folder nvmuse install dependencies and then um what we're going to do first is we're going to write our schemas so over on the left hand side here if you look at the folder structure poly wrap polygraphers all have a pretty similar folder structure they have a manifest file which just defines the structure of the package and then they have you know their actual source files which here we have it separated into mutation and query and so um query we're going to start with this these are our reading operations if we look inside of the schema so the schema is empty and we're going to fill this out and the schema acts as our public interface to our polywrapper and so let's quickly look at what's happening here in this first line we have some magic happening we're actually importing types and queries from the uniswap polywrapper that's living on ens and ipfs and this little into here is a namespace and so this query type for instance so this query type here will be showing up in your schema like this uni underscore query that's what it'll be showing up as and now that we have these imported we want to wrap them in some meaningful way and so what we want to do is we want to make a helper function called fetch token total supply and this is just a wrapper function where you can give it a chain id and an address these are the only two required properties because as you see they have an exclamation point and in in graphql this means that they are required then uh if you have these two then we can go ahead and fetch the token and fetch its total supply and so let's look at what the implementation looks like and so down here for the query implementation let's go ahead and copy this over and check this out it's a pretty simple function um this is actually assembly script so this looks like typescript but it's assembly script and it's going to compile into webassembly and here as you see we are importing the uni underscore query type and we're calling functions on it and so these are you know graphql um graphql functions on the uniswap interface and we're just you know calling them as if they were functions but behind the scenes so behind the scenes it's actually going to do a client.query you know just like we were doing in our app and it's going to give it the you know enslash v2.uniswa it's going to give it the the ens domain and it's going to also give it the query um yeah so that's kind of like the first little bit of magic your polywrapper is querying another polywrapper and then lastly we'll go ahead and we will do the mutation really quickly here because we're running out of some time and so let's check out this schema file here for the mutation schema we're creating another you know kind of helpful wrapper which is simple a swap um and then we have an output type which is swap output and so this is kind of showing that you can define custom types and then inside of our assembly script we're going to go ahead and implement that simple swap function and so here we'll go ahead and paste this in and first thing we do is we fetch the token data we fetch the token data of the output token and the input token and then we perform a swap on both of those um yeah and so now that we've done all this we we have our code implemented let's actually build it and test it and so we're gonna skip this part because we're building it in in this step here so in order to test our polywrappers we actually made something that makes it very easy we made these things called query recipes and so a query recipe is let me just get our test environment set up we iron test environment up our uh query recipe is um it's just a json file it's just very very simple and what this does is you give this query recipe to the um to the polyrep cli and use tell the cli hey execute this recipe script and so the first step in the script is to connect to the api connect to the wrapper at this domain and so it's ens slash testnet because we deployed this wrapper to our test net that's running that we stood up in this step using docker you can actually see it in the background here client test environment and then we connect to our testnet polywrapper and we're going to send this query so fetch token total supply and so here we have a query fetch token total supply and this is the function that we um that we developed uh you know just a few seconds ago in our query module and so as you can see we're filling it out with these variables with this address and you know i am not going to spoil the surprise of what this token actually is let's actually see what this function returns if we run yarn test as you can see it's doing w3 query recipe end to end.json and then the let me make this a little bigger and then the first step is it sends this query so query fetch token total supply gives it an address and then down here with the result it gives you the full token with its um total supply and so here you can see that it is the uniswap token and you know the cool thing about this is that our command line tool did not know anything about uniswap it did not know anything about our wrapper that we developed when it was created but on demand it's able to load up our sdk it's able to run it and then it's able to um you know be able to perform these sub uh queries you know this uh com composable nature of bringing in more and more different polywrappers just kind of showing you like how on demand and composable this can really make web3 development and so yeah um that is the end of that short demo um the last thing i want to you know just quickly show is that if you look inside of your build folder you can see the same files that were uploaded to ipfs and so yeah there's nothing special you know you just stick these files onto centralized storage and your polywrap client can query them and so i think i'm going to stop screen sharing now or you know stop talking at least that's my timer and if there's any questions we would love to to answer them awesome thank you so much for that demo um we would of course love uh if everyone were to just type their questions in the chat and i strongly highly highly recommend everyone to just check out that github repo um link is right now in the chat so yeah definitely check this out build with it play around with it you know learn about it all that jazz any questions and then also just to recap i'll pull up just like the list of benefits of you know why using a polywrap sdk as opposed to let's say a javascript sdk is you know and so if any of these don't make sense or you'd like more information on them just feel free to speak up sounds great and for all of you rust fans out there or those of you who want to develop more using rust do you have rest support coming in very soon yeah definitely and you know two types of rest support the first type will be being able to develop your poly wrappers in rust and then additionally uh being able to have a rus polywrap client so being able to actually execute polywrappers inside of native applications and so this will give way to uh you know any sort of language that supports native bindings so think of you know not just rust but go and c-sharp and all the other languages out there sounds great and uh once again if anyone has any additional questions after this workshop you can always hop into the east global channel um right underneath the uh uni grants uh sponsor channel you can definitely feel free to ask any questions and uh there are definitely a lot of people who are who will be willing to help all right um and i just want to thank everyone for coming uh feel free once again ask any questions if you like and uh thanks as well to uh jordan uh and kevin for the amazing presentation thanks so much for having us yeah thank you thank you 