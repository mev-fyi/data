oh yeah that's perfect thank you so much it's a great help okay cool we can actually start now okay this microphone is it on Okay cool so make sure we use the mic okay yeah okay I think we can kick this off now foreign once our slots come on we'll start our presentation but I'm natter dabbit so what oh yeah thank you part one will be kind of just following along looking at the presentation then we'll break out our laptops and you can follow along the workshop in real time we also just published the repo and the slides and the code on natter's Twitter so you can go grab that now so you can follow along while natter's working on it or you can follow along later I think is slides it seems have connected good yeah great okay um boy I'm on a hard Spanglish because I was in Colombia Jose Colombians developer Advocate developer relations Is Latino America I said I'm going to kind of maybe speak in Spanish in some parts one of my kind of core key mission statements as a developer Advocate is to make sure that computer science education in general is widely accessible to people from all over the world and that means that when you're in a different country with a different language making sure that those people can access education in the same way I did a check here and everyone here speaks English so I'll lean more towards English on that for sure and all of the stuff that's published is in English but it would actually be great for us to potentially translate it so cool we're gonna do a Foundry Workshop a complete introduction to Smart contract development with Foundry so natter is being my emotional support right now but then we're going to switch then he's going to get on and I'll be his emotional support cool so Foundry is a portable fast and modular toolkit for ethereum application development so you might have heard of it but you might have heard of others that fall into the same category in that part of the stack so maybe hard hat maybe truffle um so it falls into the same place it does the same thing where it's tooling around development and we'll talk about exactly what are some of the unique values and the unique propositions that Foundry has and how you can leverage it in your smart contract development so white Foundry like I said there's other competitors if you look here there's oh is it ugly for you guys too yeah okay it's okay it's in the middle so there's hard hat there's truffle there's brownie there's anchor but kind of like what is the unique proposition of Foundry and why are we here talking about Foundry specifically so a few different reasons one is that it lets you write your tests in solidity instead of JavaScript and we say instead of JavaScript because I think at least for both of us before Foundry we were using hard hat and when you're writing your tests there you're writing your tests in JavaScript even though your smart contracts are in solidity so with Foundry it allows you to kind of have just less context switching and less mental overhead of like writing in one language and then testing in a different the next one is that it's really really fast if you've used hard hat or anything else and then you use Foundry you'll be able to feel the difference and tell the difference and it's partially because it's written in rest so it's able to leverage a lot of the Key properties that come with rest and why Russ is gaining so much popularity right now another really cool thing that we're going to go over today in the workshop is an improved developer experience with fuzzing so fuzzing is an automated testing strategy that basically lets you as a developer make sure that you're testing for all possible cases so you know when you write unit tests or maybe functional tests you're checking that an output for a very specific input matches you know what you expect so you're like check that the output equals one check that the output equals two but there's no way that you can manually write tests to handle every possible outcome so that's exactly what fuzzing does is it makes sure that you as a developer are seeing all of the edge cases all of the kind of failed cases that are out there so you can make sure that you're handling those and then so okay one of these are out of pocket out of order so talking about the tools that come with Foundry and what we're going to talk about exactly today are Anvil forage and cast so starting with Anvil Anvil's a local ethereum node similar to what you've already seen in hard hat or ganache where you can spin up your local ethereum node and use it for testing your contracts and interacting over our PC cast is another CLI tool that allows you to interact with the smart contracts this is where you actually like send transactions read data from the network and I just like we're not going to talk too deeply about this next part but I would encourage you guys to check it out in The Foundry book which is linked at the end Cass also has some really cool sub commands that you can use for decoding call data and sending arbitrary messages and a bunch of other things and then this is the one that was in the wrong place oh Forge okay well um I didn't put one in the slides but the other one is forage and that's like what you use to like your your tooling your tooling what do you call it that's kind of one of the main commands that you're going to use yeah like when you do hard hat in it it's it's the the equivalent to that so when you're doing Forge so now we're gonna actually walk through if you want to apply your laptop you can follow along if you want to do this later on your own and just watch you can do that if you want to follow along go to natter's Twitter he just tweeted out the the link to it so you can see it up close so you don't have to squint thank you for that introduction so I'm gonna get off stage and help people if they run into stuff while we're doing it yeah so what we're going to be going over today is an open source GitHub repo that you can obviously follow along with today or if you are watching at home or watching this at any other time and you don't have time to follow along you can do this obviously at another time but I've kind of tried to make this the most concise introductory level Workshop to kind of get all of to me the most important exciting things about Foundry covered in a short amount of time and along with this Workshop I've linked to a couple of really great resources um one of them is The Foundry book and it's a great resource obviously um the other two though or one of them is something that I actually reference almost on a daily basis when I'm writing smart contracts with Foundry and this is something I created called The Foundry cheat sheet and this basically just has like all the copy and paste commands for like the 90 of the work that I do with Foundry so you might want to know how do you send a contract call to an address that's local how do you send a contract call to a live contract how do you do this or that there's a lot of good copy and paste code that you can use here and I believe that we are going to actually merge this into The Foundry book there's already kind of a GitHub issue open there so for right now The Foundry cheats you to separate but it might be part of the book later and then the other is a video tutorial that I've done on getting started with Foundry it's very similar to this Workshop but maybe a little bit more in depth so with that being said the pre the only prerequisite for this Workshop is that you have rust and salt and if you want to see where this actual GitHub repo is it's actually github.com3 I think the um the URL was was actually the slides there so github.com3 the very top Workshop should be there and the things that we're going to be covering today are testing and assertions fuzzing logging running a local node and deploying to that node we're going to be looking at calling contract contract calls directly from your command line to that local node installing and using libraries so in hard hat we can use npm to install like open Zeppelin contracts and stuff like that and with Forge you can actually do the same we're going to look at how to configure the remapping so that your text editor understands where these libraries are but also the development environment knows where those are as well and we're going to also look at some of the more interesting things that you're probably doing on a daily day-to-day basis like mocking users so let's say you want to kind of like run a contract call from one user and then test it out by transferring a token to another user and all that stuff how do you do that well we're going to cover that today and and um that should be I think a really great overview once you go through this then I think at least for me this was everything I needed to to get started building so with that being said Cami kind of gave an introduction around a lot of this overview stuff that I'm going to skip now and we're going to actually go directly to getting the installation done now if you if you don't have rust installed it might take a little time for you to actually do that so you might not be able to follow along but once you have rust installed you're going to be installing a Foundry up and once you have Foundry up installed you can just run this command Foundry up and this will either install Foundry or it will install the latest version of Foundry so before this Workshop I ran Foundry up and broke everything in the workshop because things changed so I had to go back and make some updates but uh the only thing that really changed with the new update was the actual original contract that was scaffolded by Foundry they used to just scaffold out an empty contract now they scaffold out a counter example which is actually much nicer and honestly it's also a good contract to play around with if you're learning so with that being said what we want to do is install Foundry by running this command and running Foundry up like I mentioned and what that's actually going to do it's going to install a couple of different uh libraries or a couple of different tools I would say and gaming already kind of covered those but once you do the installation you're going to have three different CLI commands available to you one is Forge one is cast and one is amble Forge we're going to use to create a new project we're going to use it to do testing and stuff like that cast is actually what you're going to use to then make contract calls against any live contract and it doesn't have to be a contract created by by Foundry actually you can literally just use this cast to interact with any live evm Network which is cool and then amble is what you'll use to spin up a local mode so with that being said we're going to run Forge and knit and this will scaffold out a new project so I'm going to go ahead and open my command line and is that readable for everyone okay cool try to make it big enough so we're going to run Forge init well first of all let me just show you that we're in an empty directory now so fortunate will scaffold out a new a new project and while that's scaffolding out I'm going to open that up in my text editor and we're going to look at the folder structure and we're going to see that we have the SRC directory which holds our main contracts we have our test which holds what our tests obviously and then we have our script which is actually what you're going to use to deploy your contracts and scripting is actually really cool and it's I think it's something that wasn't there when Foundry first came out and then lib is like the node modules but it's for this environment so if you install opens up on contracts it'll go in the lib folder and you can immediately start doing things so if you wanted to run a build you could say Forge build and this is going to compile your contracts and it's going to give you the apis so if you ever use hard hat you know you compile you get your apis and you can use those to make client-side calls or you can use them to deploy and verify your contract on something like etherscan once you run Forge build you're going to have this out directory and this out directory holds your apis um you can also run Forge test and we're going to be actually running back through these commands again with the new code base because we don't really know what that's testing because we haven't even looked at the contract so what I'm going to do is go back to my code base and what I want to do is we're going to instead of using this counter example we're going to do a Hello World which is going to just give us a little bit more room to work with to show some of the functionality that you might not be able to do with just a counter example so in order to do that I'm going to rename this to hello world dot Sol and everything that I'm doing is actually covered in the workshop materials copy and paste directly from here so don't worry if like you know you're not keeping up you can literally just go here and copy and paste so what I've done is I've renamed counter to hello world and this is a very basic hello world contract that I'm going to go ahead and paste here the only functionality that we have is that we have two variables we have a greeting and we have a version when we make a new greeting we're going to increment the version and we're going to have a function that just Returns the greeting so it's about as simple as you can get but it also I think is a good basic starting point you know so the contract is there this isn't on solidity development it's on Foundry development so we're going to actually go now to the test and we're going to spend more time on testing and what we want to do is we're going to go to test folder slash counter.t.soul we're going to rename that to hello world Dot T dot Sol and you're going to notice that in this example contract here that we have a couple of functions and they start with the word test now with Foundry any function that starts with the word test will automatically be tested when you run Forge test it doesn't even have to be in this directory so keep that in mind when you're writing your test if you create a test in the test that doesn't start with tests it won't actually get tested um at least by default so what we want to do is just go ahead and copy this test oops and we're going to walk through the assertions that are being had there all right so we have this the first thing that you might notice that's different is that we have this setup function and this just allows you to create some type of initial variable or whatever that you want to reuse across all of your other tests so it often makes sense to just create a new instance of the contract and then you can just like reuse that instance of the contract so that's kind of what we're doing here we're creating this variable called hello that initializes a new Hello World contract and then we can just now say Hello dot whatever the method of that contract is that we want to to call so the first test that we're going to run is we want to get the value that's returned from the greeting and and make sure that it what we expect what we expect it to be is this because the Constructor takes in that initial argument and we're doing that now that's interesting but I think the most interesting thing to be keeping an eye out for is this assertion assert equals so you have about a dozen different assertions that you can work with and I have a link in the workshop to all those assertions so you can assert equality you can assert things like greater than less than equal to you can search truthiness pretty much anything that you would probably need for assertion so it's a really really basic test here right we're just kind of like making sure the greeting isn't equal to the string that we expect it to be um and then we're going to also do an update and we're going to say the initial um version of the the version is zero I guess you could say we're going to then create a new greeting which should increment that version number to one and then we're going to assert that that is equal to one and also assert that the greeting is equal to hello world so with that being said we can now run Forge test that should work that's that's cool and all but that's not all that interesting let's kind of look at more interesting stuff so now that we have our basic project set up let's dive in to more stuff so I mentioned some of these other assertions we're not going to really be using any of those other ones but here are some of them and here's the link to view more but we want to look at now is fuzzing so fuzzing is cool because we don't actually have to pass in the argument that is expected here fuzzing can actually take care of that for us and therefore you have um also more I would say variation in the types of tests that are run because it will basically automatically inject just different variables there so instead of passing in the variable ourselves we're going to use fuzzing here and we're just gonna we're just gonna Define that there is a variable that should be passed in there and then Foundry will automatically inject that and it'll make it available for us everything else kind of I would say stays the same so now if we run Forge test again it should still work but if I go to maybe change this greeting to something else obviously like Hello World then that should maybe break okay so the greeting that's coming in is some value that we don't know so how do we know how what if we want to know that value we can start logging it out and if you want to log you have about a dozen different logging methods that you can use you can just use a straight up basic log which is just log which is really simple and you can also log integers if you know for sure that there's going to be an integer log string you can do log name String which would be something like console.log passing in the first argument is the string the second argument is the value so let's do some logging so I'm going to go back to test two and what I want to log out is the value that is returned from the Greet method which should just be hello world but you're going to notice when I run this test that nothing is logged out because by default logging isn't enabled you have to actually ask for more verbose logging so what we're going to do is just pass the dash VV and then now we see that we have the logs there so hello world so that's how logging works you just want to pass in the verbosity and I think there's up to four v's and I don't know what that would do but let's see there we go um so I've never really really need that that much honestly but okay so we have some basic stuff going on we're going to dive even even deeper to more interesting stuff and we only have five minutes but I think we have enough time next we want to go ahead and run a local ethereum node so in hard hat we would run npx hard hat node and and Foundry you just type in the word anvil and this spins up a node and here you see that we have 10 different accounts in 10 different private keys so what I want to do now is go ahead and set a an environment variable to one of these product keys and then that way we can start interacting with the network and referencing that private key as an environment variable so to deploy the actual contract to the network we need to run a script and we already have a basic script in our project here under Scripts we want to just rename this to helloworld.soul and we have this run function and then we have this broadcast method on the VM that actually does the deployment and that's kind of where we're going to be doing our work so I'm going to copy this and not a whole lot has changed we still have this empty setup method because we're not really using it um we're doing the vm.broadcast and then after that whatever is called we'll be actually deployed and all we're saying is like we want a new uh hello world contract deployed and then we're passing in the Constructor argument of the string and then from there we should be ready to go so how do you actually run this well we are going to use the forge the forge CLI and we're going to say Forge script we're going to define the location of the script we're going to Define where the RPC is that it's going to be deployed to so if this was like inferior you would set an RPC endpoint but since we're running locally we're going to set the localhost 8545 and then we're going to set the private key as the private key that we stored in our environment variable and then we're going to say broadcast because if you don't say broadcast it doesn't actually deploy that so let's do this without broadcast and I'm going to go ahead and open my terminal and this will basically just give you a simulation of the the deployment so this will just tell you you know whatever information about the deployment like how much gas would be used and stuff like that and then when you're ready to deploy you just run that again and then you just say Dash Dash broadcast and then what you should be given is the contract address and we're going to also be using that so now we've deployed and we see some logging that's happened there in our anvil and you also see the the transaction ID and the contract ID so now that we've deployed our contract what we want to do is store that in an environment variable so I'm going to go ahead and do that well let me just do this so we have two environment variables now we have our contract address and our private key and now we want to call that contract because we want to start reading information from our contract locally so what we can do is say cast call and we're going to pass in the contract address and the method so we have that stored in our environment variable so we can just reference it and then what we want to do is called greet and we know that it's going to return a string and we get hello from Foundry that's what we expected pretty basic stuff but it's pretty cool to be you know calling that from the command line we we want to now send an update to update the greeting so we're going to say cast send we're going to say update greeting we're going to pass in the new greeting and then everything else is the same so if I copy that and then I go back and read the greeting again this should now have my new greeting and there we go we've read the contract we've updated and we've then read the new value so now that we've kind of gone over some of the basics let's look at how to install a new package so one of the most popular packages is open Zeppelin contracts so let's create an erc721 and what we're going to do is just say Forge install open Zeppelin slash opens Upland contracts very similar to like npm install and what I need to do first is make a commit because they don't like that if you have uncommitted code okay so we're installing opens up on contracts and after that's installed it just should just show up in our lib folder right there and we now need to configure our remappings because we need to tell our local environment where to find that code once we try to import it and use it so you can actually run Forge remappings and see already whatever remappings are configured and here you kind of already see them trying to kind of make some assumptions about your environment but we want to set a custom remapping so if you would like to do that you can actually just create a new file called remappings.txt and we will set our remapping for open Zeppelin here and now we can actually just import that directly from open Zeppelin without having to reference the entire path and it looks something like that so we're going to we have maybe three more minutes and we're already over a little bit but we still have just one more thing to cover we want to look at mocking another user which is you know I think one of the more useful things that you could probably like learn here so to do that we're going to be going to make a new ERC 721. sole this is a really basic contract but you see now we're actually importing from open Zeppelin contracts which is pretty cool we're creating an ERC 721 called Devcon panda and we will just have a mint function pretty basic stuff and we are going to also have a test for this because this is going to be the part where we're actually learning something in the test thank you okay so the tests that we have set up for right now is really basic we haven't added any of the um the mocking features yet but what we want to do is simulate another user so we have two users we have NOAA and we have Sophia and what we want to do is like create a token transfer it to another person we want to make sure that only the owner of that token can actually transfer the token so to do that we are going to use the prank method and you can either say prank and prank will be using the next call only to prank that user or you can say start prank and it will do all of the users or all of the calls that come after that until you call stop rank so this will like wrap up the workshop I know we're a little bit over um I'm going to go ahead and create the the function that we're going to be doing here and we have this method where we're going to test a transfer so we want to Mint a new token to NOAA we want to start pranking and simulating us being Noah we want to then transfer to Sophia and then we want to check the owner of that token and then assert that Sophia is indeed the owner and if we run for its tests that should work we want to actually only test this contract and if you would like to do that you can pass in the match contract so now we're only testing that one and to make sure that everything is working good we're going to assert that Bob is the owner when he's not the owner and everything fails which is what we want okay so that that's basically it we're not covering everything you can run Forge coverage which is a pretty cool command to give you test coverage and you can go even that's not working because the test has failed but anyways Forge covers is really nice so that wraps up the workshop I'm sorry we started a couple minutes late I'm sorry we went a couple minutes late over check out the GitHub repo walk through all that stuff a little bit slower if you'd like to learn more thank you foreign over here all right Miranda can you hear me test test can you hear anybody hear me I can see if I go in a presentation about how this goes the resolution should have changed right away then yeah do I want to go into presenter mode is that what I want to do I do need the notes of the bottom I mean if I if I can look at him yeah um so Okay so okay yeah that should be good right yeah I think so yeah we'll see in a sec once it turns on if not and then do I need the audios to check uh if you have audio playing ideas it's her yeah he he thought he had a second ago yeah it's a good time or HDMI audio because we can also just do uh can we just test out YouTube to see if it works sure Randy you want to say something maybe they need to turn up the audio on their end and we already have it maybe you need to set oh wait let me use sound device then yeah okay you can hear the thing yep yeah okay so it's really good we can hear you okay we're just in here we didn't hear when they talked can we try to Miranda say something again hello yeah okay perfect did you hear that yep perfect okay do the slot do the slides down there can you see my slides yeah good all right cool all right hi everyone uh Andrew Foreman I'm with uh Ernst young ey blockchain I'm here talking about Starlight um so basically yeah so I work at ey I work with a lot of our clients that are building smart contract applications any kind of web3 app um govern new governance features things like that uh what I'm not is I'm not a cryptographer I've never taken a cryptography class I don't really understand the math behind zero entrepreneur circuits I know there's a couple of couple out there um so this this what starlight is is really just a huge leap forward in allowing any average daily developer myself included to start to bring you and use privacy features in the construction of their uh DAP in their smart contract so this is very much like if I can do it you can do it to kind of talk uh we do have some of the cryptographers that worked on building the the application on the phone and they'll talk through some of the technical parts of it uh but but definitely want to give you a feel for what this is what we're building here maybe just another important note too is that this is something that we're actively working on at ey it's um pre-alpha release we very much an experimental technology so like we're hoping to launch it soon but um and we went and the reason we're talking about it this weekend is so that you guys can see it you can start to use it give us feedback uh and then we can you know have a more robust launch very shortly so okay so what is Starlight so like I said the big headline here is that any solidity developer can now use the power of zero knowledge proofs in building private features for their dap on chain uh you don't need to understand all kind of all the the sophisticated circuits the elliptical curves anything like that to go then build private features uh for for your data so that's what that's what starlight uh was built to do it's really two things it's one it's a zero knowledge proof for library for writing your solidity code and to a transpiler or we we call a company you know compiler but really it's a transpiler to then read that um that Library file and the the decorators that are they're involved there uh so what you can do is then you take any of your these decorators do is they take any variables mappings arrays that you have in your contract and it allows you to put them into a private state and so then what we you know kind of some of the names you see up here are the kind of the names that we've been using I mean these are kind of like right now just internal names that we're trying that we're trying to experiment with but like when you take your adapt and you run it through this solidity uh this kind of construction that we have around decorators we're calling that a zap or a zero knowledge proof app uh the validity is a is the file type that we use in this zero knowledge proof Library which is in the Starlight Library which I'll get to in a bit and um then zapify is really just the command to run the compiler so like once you understand kind of the some basic Basics around those decorators it's really just three steps write your solidity add these decorators run the compiler and as you can see like we've taken all of that you know trusted setup circuit construction trust assumptions logic off of you as a developer so all you have to do is add this to your solidity code and kind of understand what the logic is going to look like for your users uh and and with and how the state changes get updated okay uh so first first one we said two things right first is the compiler uh so I think I want to say like you know why did you even build a compiler that's kind of like a weird thing to even go and attack we don't see it that that often where where someone wants to go build a compiler uh and so for us this was really um just about scale and getting the more developers access to this this technology uh it was something that I ran into personally on a project so we like worked with the client they wanted to build this private donation platform and what it allowed you to do was take a bunch of different charities make private donations to them so now like a large donor who may not want Their donation to be public could do so privately on change so there's like a big step forward in like more sophisticated more um real world smart contract applications but I worked with like a team of advanced cryptographers we had to go through uh weeks of circuit construction uh they had to explain it to me so that our team could then write it into into solidity code all of that stuff is not scalable when you talk about hundreds and thousands of uh zero knowledge proof based and private privacy enabled applications so to make that all work we started kind of at the compiler level so that you can keep writing your solidity code add these decorators and and run it through this construction so the three steps again we'll say take your your contract and in solidity.soul add decorators you mark what you want to be secret variables arrays mappings anything that can have a private state um then send it through a zapify into the into into our what we're calling this compiler transpiler so then how does that look at runtime because it's kind of um this is like maybe just like also as like a developer education point you know understanding what what's happening to your code as you go in through and deploy it um so what we have here is um the compiler takes that solidity code and uh we have this zolt now this Zol file the solidity file type and what the we're going to do is we're going to first kind of make sure that the syntax and the way your solidity code is written looks right that there's that um you know there's no there's no solidity errors first we're going to run it through the solidity compiler just like as as your code always would uh would be executed then we're going to add back into this this AST tree which we've broken out the decorators that you put into that file and then we're going to run it through our transpiler and so now you've we've done this going through this compiler Loop a second time and what you have is a uh as a little you're a zap that's been compiled and so that's when we would then set up and create the circuits and the state changes that that um that you would need for for that application um so yeah that's kind of what it looks like at the back end you're gonna have one tree that has these three different parts which is The Shield contract this orchestration code and uh then also just you know your basic uh your solidity file structure and I would call that out now because when we get into the more technical parts of the talk uh you're gonna see that breakout again of the orchestration the uh The Shield contract and and the salinity file Okay so like I said all that you need to know as developer is how to use these decorators uh and how to run it through this transpiler and you've got your your facility app ready to go so I want to now jump into the decorators because this is really kind of like the key thing for your anybody that wants to go and use Starlight to understand are these three decorators uh Miranda can you hear me or did you want you want me to take these ones I'm going to try and test talking and see if we can hear you [Music] hello [Music] all right well I'll get i'll get started so uh the first one is is the secret the secret decorator so what secret is is um like think about um any kind of like variable whether you declare it at the global level or a function parameter that you want to remain in a secret or private state so like your basic example here and we can jump to um the code as well is um you know I've got variable a I don't want anybody else to be able to call and see what the what I what I have stored at variable a so I can put a secret in front of that that um that argument and now it can remain private on chain um known and unknown so this is getting a little bit more advanced so then think about this as like um a bank account right so a known would be where I know what's in my bank account I can now update the state of my bank account and and so I would use known for that if I want to add or decrease if I don't know the state of my bank account so let's say I want to change his bank account I don't know what's in his bank account I would use unknown and now I can add to his bank account without knowing the state of it so that's how you would use known and unknown um it really I mean a lot of this comes down to kind of the language of of zkp and um and privacy and cryptography is just like who's creating the commitment who knows the the secret word at any point and who can update the state of that into that um whether it's a variable mapping or an array and so to me this is just like a very nice um distillation of a lot of his zero knowledge proof work happening in the background where for me all I have to understand is how to use these decorators um what they're what they're going to look like and once my code is represented on chain um and and now I can start to kind of bring these features of zero knowledge proof and privacy into my application who can change States who can who who knows things when and who can update them so let's look into an example of that Miranda if you can hear us you want to you can jump in on this one as well you start talking maybe a little maybe it's a little louder you can try that again hello can you hear me yes we hear you fine perfect yes we do okay perfect so we're going from the example is that right correct I can't I can't see the slide sorry okay great so uh we have an example here uh so if we want to zapify something and turn it into a zero knowledge application we start with a smart contract as Andrew talks through so let's do this super simple idea which hopefully some kind of use case um we have a mapping of invoices from an address a person to the amount in the invoice we have uh the owner of the contract is the who this is the one who's going to be paying the invoices and we're focused identification to pay them so you see in red these are where the decorators are so we don't actually need to worry about known and unknown here because we're overwriting State and we're decrementing state so we know that essentially the only people who are going to call these functions are the people who know and own the state and the compiler is clever enough to work that out for you so we don't need no no unknown here but um yeah so this is an example of a kind of input you would be able to put into Starlight and zapify um at the bottom is at just a very high overview of the of the actual application by compiling this we would get a shield contract which would verify the information you put on chain in this example we are not revealing any owners or amounts of these invoices so very little information will go on chain apart from the proofs the proving you've done these computations correctly and the amounts based on whether you're adding a new amount or um whether you're decrementing some amount new orchestration is just the node code and a bunch of other types of uh sort of deployment type things so like Docker npm files that help you deploy and use and bring together digital knowledge of the Unchained parts and the Socrates files the Socrates is the code that we use for ISO energy circuits all right so on the next slide there should be a sort of example flow of this example yep yep so lovely so ideally here so the user wants to add an invoice using the xernege application that they've made with Starlight so number one is the only step that the user has to do all the rest is done in the background and the user is just waiting for the receipt back from the transaction so they want to privately add an invoice to this contract they still need to input an amount so if you remember in the previous slide day we we still need the user to input an amount but then the rest is done in the background so they're cool instead of calling their contract they would call a JavaScript node file and what that would do if you have an old invoice for for this exact owner for you then it would grab that old commitment um if not it would use a dummy commitment which is a bit of an advanced feature but we'll just continue um it would get all these inputs together and create all the things that we need um to keep the step private so in this case in number three we want to wrap the amount uh into a commitment so what we do is we we hash it with lots of other information as well to make sure that it's hidden but it's provably correct and we go through exactly the same computations that we did in the original input contract but instead we do it in the zero and large circuit and we prove that we've done it correctly rather than revealing the inputs that we've used and then once we've done all this in number four we send this proof the new commitments we have so the new commitment representing the new value and the nullifier of an old Commitment if it exists we send that on chain if the contract that we made if that verifies the proof it has a new equipment to a tree so you can prove that it exists later it basically tells the world but mostly our Merkel Tree application that a new commitment has been added and add to nullifiers so that you can't double spend any commitments so all the user had to do was step one and the Starlight generator application has done all the rest so the user has added a completely secret invoice to this application uh yeah that goes through the example yeah great I'm just trying to see if I could switch over to the to the actual repo itself I don't know if we can do that uh I mean here's another example just to bring it up again I mean I think that was a good example that Miranda walked through and I think maybe just like some other examples to throw at you just to you know get you thinking about how you would use these decorators might be something like if I wanted to have a voting contract and I wanted to restrict a number of people that could vote in that contract but I and I wanted to keep uh that those 10 people private I could create a mapping that says here are my 10 voters they're private and uh and so you know you can go and check on chain you wouldn't be able to see who's allowed to vote in my contract and then maybe only I or some admin has special privileges to change the voters uh on on my um in my application um we've you know thought about some other ones like um uh issuing ious or different kinds of like uh Advanced commitments so um and I think this one's like an invoice example um I think that like these are powerful tools and now we can start to think about what are the Privacy features of our users when do they want their their information to be private or some other part of the application be private and then this becomes a way that we that we actually instantiate that feature um I'll flip over to in a second but but we have a a GitHub repo that is public and anybody can can um go and access it I'll put up a slide after this and there'll be a link there to get to it uh there's a lot of good examples there a lot of good test files for you to go through so we definitely want people to go and try out the repos you know take a look at it see if if it makes sense if you have questions you know we're available to to talk through a lot uh any parts of it that you want um and then maybe just to hit on two two kind of learnings that we've had over the last few months working on this repo one building the compiler is really hard like it's a it's uh it's hard to find compiler developers to work on this there's a lot of different test cases that you need to be working for I like wouldn't advise it for your your health to go work on compiler code it's just it's a mess so um you know if anybody's a compiler Dev like come find me uh yeah recruiting dinner um and uh and then I think too like for me the the big the big opportunity and and the big thing that's changing in our space and as ethereum developers evm developers is um is is building privacy into our applications and I think as like these applications become more sophisticated as they start to have more real world applicability and use cases as um our governance systems get more sophisticated that we're going to want to have privacy in these the things that we put on chain for our users um and it's not feasible right now at this point just forever or just assume that everybody's going to go out and understand how a snark works at a very detailed level to to go build that up those applications uh so I really think we need you know tools like this to be able to make the Privacy features that that we want and that'll make the space better uh work and so I think something that'll be a big Focus for myself and our team going forward too is just like helping designers developers product managers think through what are the feature designs they want to build in and how do they start to think about privacy in a more robust way um that's pretty much all on the talk can I switch over to the GitHub I'll just show you guys where it's at here's a link if you want to scan here and uh yeah you just heard from Miranda she she was one of the lead developers Michael Connor down there in the stands also worked on the uh Swati uh Royals uh part of our our r d and uh cryptography team in London and Megan and I are kind of helping us uh develop a relation so to speak all right I don't think we're gonna get the GitHub but yeah come find me after the talk and and we can we can walk through the repo okay thanks everyone [Applause] thank you foreign guys so I saw some of you at the at the booth already um today I'm gonna talk about how Cortez is bringing Linux to the blockchain and I'm going to explain how that's possible and I'm gonna show you a python example of how that works so this is a quick overview of what we are going to do over here so I'm going to talk a little bit about Cortez what it is how long we've been around and I'm gonna do a live comparison between wet 3 web 2 and Cortez development and then I'm gonna actually talk about criticism I'm going to introduce you to roll ups for those who are not familiar with it and then I'm gonna go dive into the code however I want to keep you hooked this is the code we are going to investigate together so this 25 297 line python code that's actually importing uh libraries for from normal python it's actually running on a virtual machine that can act as a roll-up for ethereum for instance this is actual smart contract this one here uh is doing an echo python so whatever you send it you send it back on the blockchain for you is a company that was founded in 2018 these guys have been working a long time trying to bring a risk five I'm going to talk about risk five but a processor a true processor to the blockchain how to make a deterministic so you can do like normal computations and uh and that's why they're calling it the blockchain OS because uh we actually brought the Linux for it so the overall idea I guess you're all familiar with it so I'm just gonna run through it is that ethereum is awesome it's secure it's somewhat since censorship resistant decentralized there's all these good features about ethereum however it becomes it's low it is expensive so adapts are actually fighting for space resource uh inside of of the blocks to actually be processed and it comes with a lot of friction for developers that are just coming to blockchain so you have 30 years of experience it doesn't matter you're gonna start over all over again you know so the idea is what if we can do a complex computations and maintain the main layers security guarantees so here's the the capacity response to that first we use a transparent VM so you are able to actually see the whole code is not a complete somewhat complicated but it's open source uh like the Alaska I was saying compiler stuff is hard but in any case it's open to everybody to investigate it and it is using the risk five like I said so risk 5 is an open harder platform just like open source but for hardware and it comes with a lot of security guarantees already because uh it's being audited by several companies and people it it has been updated uh it keeps getting updated throughout the time so that's nice any person is allowed to build on top of it and it is a platform processor which means you can actually have any kind of OS on on it it's a very robust machine and the only thing that we need to actually adapt is uh to build a deterministic emulator so we made risk five deterministic and because of that we could actually make the emulator for evm as well so whenever you run the computation of chain it is possible to actually run the same computation on ethereum right now in fact one of our acceptance tests is to actually do the the whole risk five acceptance tests on chain so we of course it's a test Network a local test net but we do it on the AVM just to prove that the version that we have on chain is the same exact version that we've developed in C plus so that allows you to have massive computation on as a layer 2. and with that you developed the the whole way this works uh the the idea of to actually have the mass of the competition now become yeah and not a limiter again is to have at local consensus I guess people here are more familiar with app Centric roll-ups so because of that instead of having a lot of computation doing the same work over and over again effectively only having a single machine which is the way the ethereum works you can actually have computational resources dedicated to each application so every application is it is its own Road lab if you use the advertising framework uh finally the most important thing it's actually make it work with the blockchain right so that's where the dispute protocol comes in uh it's not any novelty it's actually being discussed for a long time so here we are using the verification game the overall idea is um you get the whole computation you did of chain let's say it took like 3 000 Cycles CPU Cycles you find exactly where the validators diverge and you only have to execute a single CPU instruction cycle on ethereum which makes validating the whole process really cheap so the um how to say the end result is ethereum becomes a judge so it means that if you have I don't know like four people playing a poker game and one of them win and the other three start to collude against the 1.1 that single honest validator that's all that you need a single honest validator to come to ethereum and complain about the end result and then ethereum is going to judge who is talking who's telling the truth so you guarantee the correct settlement of computation so for those who are not familiar with burlaps the overall idea is you have the main chain it has its own blocks at some point you initiate the process you tell ethereum here's the initial state of my rollup and you go on with your life for a little while of chain doing computations and once you're done or once you want to do a checkpoint because that's the idea of roll up you always check pointing your process you go back to the blockchain and with optimistic relapse you actually have like a seven day window for now like that's their agreed good uh time span for uh disputes so you have a seven day window to actually complain about anything that went wrong on that um block of computation so to speak so how it comes uh how everything got gets together right so before in web 2 you used to have like a some kind of a front end a few apis uh defined by you to be run in a centralized server or a set of centralized servers talking to a set of centralized databases right that's the main web 2 idea so ethereum Camp comes up and say you know you know what like the business logic whatever is most important you can actually decentralize that so if you're a way to to deploy your front end you can use ipfs which is really nice and you communicate with the blockchain doesn't change that too much the overall idea is still you have the same feel as the ethereum you are supposed to have a set of nodes that you communicate with just like what happens with ethereum to have your backhand be the the base of your app uh the main difference is um instead of burden the the developer with all the little things needed to actually communicate back to ethereum we developed these uh each we are calling here HTTP dispatcher it's just an API that encapsulates all the complexities of communicating with the blockchain back so basically what you need is just to communicate with that rest API so there is a definition of that there's three endpoints you get to learn how the endpoints work and now you can develop your solid I'm sorry your smart contract in any language that's the overall idea and I'm gonna show that in Python so how he actually looks like we have the three main pieces of of apis the first one is the Json rpcs just there so that one is still like ethereum so you have a data availability issue right you are suddenly on uh compute on process like on computational disputes but it's still again and chicken situation if you don't have an agreement what was the input input that you had for that process so the idea yes let's keep using ethereum or any other layer one networks to just communicate well we're I don't know our chess moves for instance so you have the Json PC there still to do inputs to the roll ups however you have the graphical API that we developed and the graphql API is mostly so you can check on three things that we have on the curtese machine so over here we have report and notice they are similar but different enough so report is any kind of log that you log within the Cortez machine think of it as a developer a developer debug log so it's not provable it's ephemeral it you cannot do much with that it's just to help you out while you're checking the health of a process or you're developing your dap however the notice is our version of ethereum events with a Twist so right now if a erc20 token says there was a transfer transfer between an amb party of some of them out it's trustworthy enough if you're running this year node however you have no proof that the event actually exists you have to be running the node to trust the event the notice however comes with its own proof so the notice is part of the machine state so if you go back to ethereum and you have to any create other apps and interact with other depths inside ethereum or even on other optimistic rollups you can build upon the idea of having notices so let's say you have a transfer happening inside the ethereum machine it doesn't need to be a direct call you just need to say hey I actually won the game let's say an nft generating situation so in order to win this badge like uh the winner like you have to prove that you won 10 times the game you just collect the 10 notice and you can put it to to be proven on ethereum for instance so that's how it is different from event and voucher the final one is basically a transaction ethereum transaction that is yet to be so whenever your roll up dap wants to communicate back to a Smart contract in solidity for instance it creates a voucher and if the Optimus overlap settles and there is no disputes on that after the seven day window the voucher becomes executable so it becomes actually an ethereum transaction so you as a user could just call it and claim the voucher or you could let the validators on the network do it for you there there is like fees and other stuff going on on that so that's why you have the graphql API because if you want to populate your front end with that kind of information you can access it directly uh calling the node finally we have an ATP rest uh API that works like if call for those who are familiar with ethereum basically is any call that you do to the machine that is not State transitioning so we ensure that this call we always roll back to the initial state of the machine that's the main difference and that um call only can generate reports because that's what I said before right it's something that it's not not provable so the idea is to have quick depth communication you can use it to grab data for your UI and you can use it as a debugging solution as well it's easier to check up on on the state of your machine of your program so now I go back to the python the python example so to this yellow side over here we have a tool on our roll up examples uh repository but basically they're encapsulating um JavaScript code like to how to actually call stuff uh through the Json RPC right just uh it's a helper too and over the blue side I have the actual python daf so we're gonna start sending like a payload with just hello there that it is just a transaction call data nothing special about it and we're gonna start checking what happens on the code so from the beginning you can see that I can use all the support python offers me and I'm gonna start using requests because I want to talk to the API that I just talked about right I want to be able to do HTTP requests I grab from the environment where is the actual URL for the HTTP API within the machine so we we provide you with the environment variable to us for you so you can actually just grab it without Harding hard coding it on your code and here we have the two types of handlers uh I was just talking about but from the api's perspective within the the machine here are the two types if you receive an inspect State kind of a request it means that the whole machine the whole emulator will revert back oh something happened okay now we're back uh so if we revert back to the previous state before the request however if it is Advanced State it's basically telling you you know uh This is Gonna Change the stage so you should do it properly basically and with that it's just a high level you can subscribe and create as many endpoints as you wish it's just like solidity in a sense uh insert the solidity code you basically have the entry point and you do all the switch for the functions right here you have the main Loop so the idea is that this machine halts it doesn't stop it just helps so every time you finish a request processing the request it just halts at the end and wakes up at the next input so this finish over here is actually a kind of like a next so it's actually saying hey I'm ready wake me up whenever you have something so you stop over here so as we begin for the first time in the code you're gonna see that I have like finished status accept and that's what I'm sending to the to the emulator uh beneath it and it's gonna Halt and then when I say hello there you're gonna wake up the code exactly at this line and from here on out we are just gonna process this request so I send an input so it should be an advanced State kind of uh request so we're gonna just pick up the Json data from there actually go to the Handler that is responsible for that so that's the advanced State and at a function at this time I'm just gonna create a notice just the notice with the same data I just received so I get grab the data payload and put it in the notice payload back it's just a simple program in this case and I'm gonna call the API creating a notice that's what that's doing it's not going to hold the machine it's just saying hey here's something that it is an output from this process and I can call it as many times as I wish okay and the result is accept again uh it's all fine so uh I'm just gonna jump over the inspect for a second so I would just add to the status accept and because I I am in a loop I'm gonna end up here to finish again sending the accept status halting the whole machine however if I had a Handler of the type inspect meaning instead of sending an input over there I would actually try to inspect the machine saying hello there you would go to this different Handler you would create just a report just like the notice is not that different when you see the code and it's the same I just finished and whenever I ask for the the helper to list all the new notices that there is there you're gonna see that the machine would return you with the hello there as a payload and that's the overall idea do you guys have questions I guess it's too much yes oh yes so yeah it's still a blockchain environment so in a sense you're not connected to the internet you can have internet at the testing machine when you're first building it so remember the roll ups example thing I was doing like initial state so let's say You're Building your machine building your adap and you need data so I don't know Docker images and npm installs and things you can have that for sure but once you're in the roll up environment you don't have that access anymore make sense go ahead so there is the cost of deployment of the Roll-Ups itself like the set of smart contracts and stuff it's not the high I don't actually have a right figure for you right now but it should be something around for like 50 or something for ethereum right now but just just so you have all the instruction points so to speak on ethereum because this app actually has a a mirror address on ethereum so other apps can communicate uh through it back to the courtesy relapse but in terms of actual cost of running this thing is up to the developer you you say do you want to charge people for using it do you wanna just you and other developers run the notes do you want to incentivize your users to run the nodes it's up to you in the sense Cortez is more like a framework really because it's really app specific you tell the parameters don't you don't like the seven days because you're doing a simple game like if really simple low stakes maybe it's just five hours for for your overlap settlement we know make sense you had a question that everyone is going to be running their own infrastructure like they are setting up I mean it's up to the DAP developer if it is something that makes sense I guess sure but yeah right now we're in the middle right we understand that mostly we're still gonna have like um these service providers running the nodes and people kind of like trusting them yeah any more questions okay thank you [Applause] should I wait until 17 30. okay I think we can start can everybody hear me yeah um in this Workshop we will take a look at how the graph provides critical infrastructure to web3 and you will then learn how you can create your own API that is tailored to your data requirements my name is you can find me on Twitter web free slip chance you can find me in Discord slim chance 16.99 I'm in the eat Global Discord if you need any help with any technical questions and you can also find me upstairs via right by the elevator so stop by our boot if you need any help with your sub graphs so let me first start with the question that everybody asks me why do we need index data the the blockchain is public right but most blockchains are optimized for writing data and not for reading it and you can imagine the blockchain as a big Public Library where every day there comes a new truckload of books and they are not sorted in any way they're just added to the end of the shelves and imagine that you go into this library and you want the list of the books with the most the highest word count if you were to do that using a traditional like RPC or just connecting to a blockchain RPC you will need to check every single book note down the word count and then create your list and this is where the graph comes in as it allows you to Index this data beforehand just taking more practical example a D5 dashboard most of you are familiar with uniswap a decentralized protocol for swapping tokens some of you might also know that there's a dashboard called info.uniswap.org where you can get valuable charts and data about the protocol now if you were to retrieve this data directly from an RPC you will need to do and and a call for every single time there's a trade the price would change so you would need to check the device and to get a chart like this you would need to do millions of calls which would be very resource heavy really expensive so that's why we need to pre-process this data it would also take you an enormous amount of time because you would need to process this in the front end so again index data allows you to have a this data in in real time in your application all of the data that you see on info.unishwap.org is provided by the graph so you might think who needs the index data and we found out that that is everyone we are currently seeing over 64 000 sub graphs have been created on the hosted service and over 640 billion queries have been served by the graph so why are people using the graph well you can create a customized API that is tailored to your data requirements this includes which sorted filter and aggregated data and it allows for fully decentralized and serverless applications if you're that relies on a single centralized server it's just an app the graph currently have two Services the hosted service which is a centralized service run by Edge node one of the core developer teams at the graph it supports 38 different networks mere polygon BNB and 35 more we are currently moving to the decentralized network where we currently support ethereum mainnet but we believe every death believe deserves decentralized open apis to retrieve their data from the blockchain and we are the leveling on that with the current ongoing mips program where we are incentivizing indexes to start indexing other blockchains as well and that is the historic step forward not just for the graph but for the entire web3 ecosystem that relies on us and wants us to provide them truly decentralized open apis and and to dive deeper into why do we need decentralization in in the infrastructure layer well there's no central point of failure you never have to call your back-end engineer at Sunday Sunday morning saying that your server went down it is naturally load balanced the graph is infinitely scalable and it does so seamlessly it is geo-distributed service we currently have indexes on every continent with over 200 indexes that are currently on the graph Network you will never wake up to an email from your service provider saying that your server went down because your service provider have taken a no no crypto sense and most of all well this this number is a little bit outdated now we now have 220 indexes all competing to deliver the highest quality of service to the lowest possible price and this is why I am excited about the graph and I hope also you guys will be excited to use the graph this weekend and going forward so I'm going to stop there and I'm going to ask if you have any questions about the protocol if not we can move on to the next part I'll dive into the subgraph [Music] we will soon learn about set logs which is a blueprint or whatever and how you want the percentage students and they use that to transform the local Canada foreign Olympics before somebody creates like like so we will come come to this pretty soon because consumer greatest of God foreign index that data using small blockchain data from either home using a service provider but you can pause video key is starting their own volcanoes and they take that AI Conformity according to the cell then provide that on the recent ly and they want to do so to received query means from the consumers so is there any civil resistance yeah do not like too deep thank you economics uh the set selection Hardware students so it is not an exactly what it is also doing it in a different yeah yeah it's going to be sorry and thank you so it's not incentivized for indexers to split their stake over multiple nodes unless they're also running the service in multiple geo-distributed locations which at that point well let them because they are just also providing better service to the network yeah so let's dive into I've touched a little bit on what the subgraph is it has three major parts the subgraph manifests here you define your network the contracts you want to or the network you want to index the contracts on that Network the start block because when you when you get the blueprint to the indexer they will start indexing the data from a certain softblock it can be from the Genesis block or from any other block that you specify and what events calls or other triggers to listen for on these contracts schema is where you define the data structure that you want to query and this is where you want to think ahead and make it as close as possible to the data requirements of your application you would have the data structure the entities relations between the entities and so on then where you will spend the most time as a subgraph developer is in the mapping code how you map data from the events that you have sped specified and to the data structure that you also have specified here and you would also do any kind of transformation aggregation of data will happen in the Manifest or in the mappings but that is written in assembly script which is very similar to typescript if you work with that so let's dive into it let's look at how we can create a subgroup in a very short amount of time so this is the graph in the graph you have access to what's called a subgraph studio where you can log in with your metamask I'm already logged in and created a few sub graphs on other workshops if I wanted to create a new one I click create a subgraph I want to create one for mainnet in our case we want to index in this Workshop shop I will show you how to index the basic contract so they bought a yacht club let's call it basic Bogota for example so now you have created this in the subgraph studio in the sub cap Studio you can see some important information like it is currently undeployed it is having a subgroup slug which is the identifier you will use and some of the CLI commands and you also have a deployment key uh that you use to identify yourself so you only you can deploy changes and upgrades to this subgraph what you would you do is you would first install the graph CLI I've already done it on my machine then we you will initialize your your sub graph how let me let me duplicate my screen so it's easier now a cheat code that I like to use is the index events flag this will create a scaffold code that's indexing all the events that it finds in a certain contract it asks us which network or which protocol type that the contract is on it's a sanitarium contract the subgroup slug the directory and then which network set it on and it's a mainnet now the contract address I'll save that maybe I'm not connected to the internet that let me try again there you go so now it's creating a subgraph scaffold Force with scaffold code just give it a second it's a tough time to download things from the internet here I believe that maybe if everybody turns off their phones and their laptops so there we go no we we can add more contact I just won't know here so now we have a um a subgraph in CD basically Bogota so here we can see the three files that I talked about earlier you have the sub gap yaml which defines what to index and in our case we are looking at the base e contract and on mainnet at this address I will add a stop block as well because we don't want to wait around for it to index all the way from the the Genesis block so I'm adding that here we have the schema it is currently pretty sparse it's a simple indexing of all the four events on this contact approval approval for all ownership transfer and transfer and then in the source file you have the the mapping file where you see all of these entities are being stored and this has already been created just by using the index event flag and I recommend using that as a uh as a way to populate your code with some boilerplate uh events and and and entities now we are ready to deploy we can do graph Cogen yes now if you go to back to the studio you can see that you would also authenticate your laptop first or your computer first I've already done that so I can go all the way ahead and and do graph deploy and give it a so now it's uploading all the the subgraph files to ipfs so that indexes can fetch that data and start using the server as a blueprint to then transform raw blockchain data into the open API that is a subgraph but in our case we are just deploying to the studio which is a centralized service and it's a a place to stage and test your sub graphs before deploying it to the Visa Enterprise Network that's deployed let's check it out let's refresh the page and the Sub sub graph is already fully synced already fully populated with data about every single event that has happened on the basic contract so this is pretty cool but what really we can do with subgraphs is then go back in and add aggregated data say you want to find out okay how many how many board Apes have been traded every month or how um what is the total value of oh like what other aggregated data you want to have in in your subgraph you can add that then to the mapping code and then redeploy so for example we can go into the schema and say that we want to Simply like now we have all the transfer events but we don't know when they happen so we could for example have a timestamp and then in the and then to create that um to create the the time stamp uh in the so you can access it from the mapping code you you will run graph code gen again now it's created the type as far as so we can access them in the uh in in the mapping code so now I can could go in in on the handle transfer and and save this in entity Dot you see now it's appearing here timestamp almost so now if I were to redeploy that would that's all that is needed to add that to your subgraph code and and thus you can reiterate and add more functionality to your sub graph is there any questions so far about dividing your subgraph you change something in the upgradable contract you'd have to go and change I higher the graph is pointing to like which contract is pointing to is that correct yeah so the question here is if you are using upgradable contacts and in this case you can use something that is called like Dynamic data sources which is a way to then like change the or add more data sources while the subgraph is in production and that is used for for example upgradable contracts another use case is Factory contacts like say for example unit swap every time a new pair is created you want to create a new data source which is the new pool and in that case you would also use Dynamic data sources it's also called templates somewhere in the documentation so it's but it's uh it would be templates in the Manifest for example but yeah I can give you some documentation after this talk if you want to dive deeper into it foreign [Music] and I want to show you the content code but I will show you how to how you can create a graphql query and then you can use it depending on like how your content application like what language you're using in the content application you can then use that query so if we go back to the graph.com as I mentioned earlier we have a graph explorer that or we have a decentralized network you can find sub graphs that that is on the decentralized network via the graph Explorer we also have the hostess service which has 30 000 open apis that you can query I will show you how to create one of them so let's for example say we want to query the synthetics subgraph for example here you can create a graphql query to test test your query oh it's not a valid query this is some you can save your queries and and use them uh let me instead open the endpoint this takes us to a graphql explorer that allows you to create your own graphql queries using a simple like checkbox type of interface so you can for example find like this the synth holders order by sent and you say you want to have the first first 10. enough the internet is with us we can get a query response so there you have the first 10 cent holders order by send and uh you can uh yeah a bit our places here on the hackerton we have two tracks one is creating a new subgraph so a new open apis as I showed you 10 minutes ago and the auto attack is using an existing sub graph in your application and and here you see it is very very easy to create a sub create a query and the power of using graphql which that you can get exactly what you need so no more than that and no less than that as well you don't need to have this reiteration that you often have to do with SQL where you have to first maybe find the ID of something and then you need to go in go back in and find the fields that you are looking for but here you can get get everything in one query so what determines the speed of that the subgroup is indexed that's a that's a good question it depends uh a lot on on how you write your mapping code so there are some some there are some patterns that you want to avoid when you're writing the subgraph for example you want to avoid doing an excessive amount of eat calls so in a sub graph you can do eight calls at an um at a block and get this the State of the State of the chain at that block and you want to avoid having an excessive amount so you don't want to for example create a loop where you are looping to a lot of entities and for each of them doing a a query to an RPG endpoint so you can do that in in a safeguard but you don't you want to to limit that so each query takes around 100 to 200 milliseconds at a rule of thumb so a few of them doesn't matter but if you are doing a thousand of these and you're doing that every block or every every event every transaction that's going to be costly when it when you are indexing a sub Corp yeah so uh his uh the question was querying a pass block or past range and you can the you can unless you have like deleted a an entity in in the subgraph you can just find it directly here like synth holders will this will also hold all the synth holders uh since this started indexing but there's also a feature called time travel queries that creates the state of a subgraph at an at any block that you specify so say that I want all sent holders at a given block I can get that using time travels create time travel queries so yeah so so here you would have block number and then you would write this for example a block number here so at this state this subgraph started indexing at block 5 million and change so I cannot query block 233 so but any number that I put in that is over this uh 5 million does anyone does everybody see my screen by the way is it yeah so so at that yeah cool and yeah yeah so again we need to um differentiate between the decentralized network where you're paying for queries and the hosted service which is completely free you will pay for query costs so so first of all like with the subgraph that we just created we it's currently on the subgraph studio which is the staging area and that is also free to use once you deploy your subgraph to the mainnet so let me see the the basic Bogota here this is the one I just created this has a development and query URL that you can find here that is completely free to use you can also use the playground to to play around with it but once you want to go into production and use this subguard for the use this API you would go to publish and you would publish on publish it on mainnet and at that point you will also need a API key to create app subgraph and you will pay a query piece and got yeah uh I'm I'm done so yeah we can take that afterwards [Applause] all right guys thank you for for joining I'll get started in just a second all good all good just gave me one minute here if you're looking for super fluid you're in the right place all right all right so we will get going then thanks everybody who who is here uh it's fun to be in Bogota I think I'll be the latam events that I've been to have been great so far by the communities here are excellent um but yeah no I'm excited to get started and talk to you guys through superfluid and also show you some examples of how to actually get started with super fluid uh with code right so let's go through building on superfluid at eth Bogota so what is super fluid for those of you that don't know well it is a protocol that enables something we like to call real-time Finance right so the one big way this manifests itself is through something called money streaming right so super fluid enables these money streams which are digital native programmable cash flows that let you stream money with no Capital lockups in a way that is 100 programmable and on chain so at superflu we like to say that the internet is to information what blockchain is to Value right we believe that we're in the very early Innings here of new forms of finance that will bring this old world of Finance into the age of the internet right and one way this manifests itself is through the way that payments work for things that have to do with time right so Services right so if you think about Services businesses right if you're an employee you're kind of in the services business this is business as well with Services the way these work is that they've flown real time from from a provider to a client right Netflix is something you watch in real time your work is something you provide in real time however the issue is that the payments for that value are disconnected from the way they're actually being provided right so you work through an entire month and you get paid at the end of the month right why shouldn't you be getting paid every second so let's dive into money streaming a little bit more right this thing you're seeing there in the bottom right hand corner of the screen is a live money stream right that's eth being streamed on a test net and you can think of these as as continuous payments right we are used to a world of discrete payments what if we could make them continuous right what if we could create this direct link between the service provision and the value transfer in return for that service and the other thing that's cool about this because it's all on chain it uh completely gets rid of any delays on payment risk or any intermediaries because it's all mediated through blockchains and smart contracts so how is money streaming possible well we we built in an evm compatible smart contract framework to make this happen right and it's made up of three pieces right so we'll get into how the heck this thing here is happening in the bottom right hand corner but it takes some building up to it right so these three pieces are super fluid agreements super tokens and the super fluid host contract which brings everything together so what are agreements well these Agreements are peer-to-peer Financial relationships Financial relationships that are open-ended and Perpetual between two accounts right or potentially more than more than two accounts right when I create an agreement to stream you money what's happening is I send a transaction on chain which agrees to stream you a certain number of tokens per second and that amount of tokens that I'm streaming you per second is actually built directly into the token balance so we'll get into how the token balance is working in just a moment but what's Happening Here is within the constant flow agreement right which is the main agreement that facilitates all this this money streaming you define that flow rate and money begins flowing immediately in real time from you to the receiver right the sender receiver can be smart contracts but it doesn't matter right you're just executing a transaction and money begins flowing in real time so literally this right here these simple lines of code cfav1.create flow receiver token flow rate will open this money stream right it will create this it in the end as a developer it's quite simple but to understand how it works we've got to go a little deeper right so this is all great right you might understand this concept of an agreement yeah I kind of get that but how are you doing this without calling transfer like every millisecond how is that not how this is working and the way we get around this is by building an extension onto the erc20 standard right so we built an extension out of the erc20 that comes with all the stuff you're used to approved transfer from symbol all this stuff but the way balances are calculated will take into consideration all of the agreements you have outstanding for any given token right so within that balance of function on a super token contract there's another call that's made to something called to a function titled real-time balance of which takes into consideration your real-time balance right and your real-time balance is really just an aggregation of all of the money being streamed to you and all the money you're streaming out to give you a kind of single net flow rate so let's dive into these a little bit more right again UFC 20 compatible plugged into the protocol and what's cool about it is they're usable anywhere in web3 right so we know that interoperability is like super important within this industry so for existing erc20s or even native assets like eth avox Matic or other native assets and other chains we've built wrappers right so you can go wrap usdc like actually right now my salary is paid using a wrapped version of usdc called usdcx if you see the X appended to the end of a symbol it just means that it's a super token right it's a wrap version of that existing asset that enables all of the streaming functionality right it's a wrapper super token there's also native super tokens whose supplies 100 streamable so if you know about super fluid you learn about super fluid today and you just had to launch a token you might opt to just deploy it out of the box with all these features so you don't have to wrap anything that's an option too there are several of those out in the wild that have a lot of usage so that's another that's another option but the key thing to keep in mind is this real-time balance right it's an aggregation of all the incoming flows and outgoing flows to create this kind of single number the protocol needs to keep track of to figure out how many tokens you should be sending or receiving every second if anybody else has any questions on that I will stand out there right outside the door and answer as many questions as you guys have just to make sure we really drill that into your heads because I know it can be kind of weird at first but it is critical to understand if you're gonna if you're gonna interact with super fluid okay the final thing here that's important for understanding how the protocol works is this thing called a super fluid host the super fluid host brings this all together it's like the brain of the protocol right so it's made up of some whitelisted agreements again the main one is that constant flow agreement which defines how balances can be changed during using that constant flow formula it also is something you call when you deploy a super token it supports something called batch calls which lets you just batch a bunch of super fluid related operations into a single transaction which is kind of helpful you can do things like open 150 streams and one transaction other crazy stuff like that and then it's also it also serves as a registry for something called a super app right so what is a super app and why is that interesting well the other interesting component of superfood is that it is programmable right you can build contracts that are aware of these streams coming in that have callbacks which can automatically run whenever a contract starts receiving tokens whenever those streams are updated or whenever those streams are deleted right so this opens up all kinds of really interesting connections between smart contracts that forms a really interesting Network that'll show you a visualization of in just a second but to understand these you have to keep in mind that all of these callbacks here this after agreement created thing you see in the bottom right these are called by the superfluid host contract because when you deploy a super app you just register it with that that host contract which is the brain of the protocol right so that the host contract will know hey this contract that is a super app is receiving tokens call this function with your arbitrary logic in it to do something else cool right so again there's lots of super apps deployed right now and they all kind of do different things one big one is called Ricochet exchange which allows people to stream funds into a contract and effectively dollar cost average into different assets right so right now I can go DCA from usdc to eth on polygon and all that's happening in real time right so it's just like this this Loop where you have a contract that's receiving funds and sending funds out and what this looks like when you start stitching things like Ricochet and these other contracts together is this right you get this really crazy network of cash flows where every single green ball there is an account whether it's a smart contractor an eoa and all the connections between them are cash flows right so for you here that are considering building applications on super fluid you have a gigantic network of cash flows to make use of right Point them into new places uh build new things for them to do um and you know we'll try to reward you for it so a quick little aside on the prizes we have 10K in prizes this weekend 3K for the best overall project on super fluid a couple of a few two thousand dollar prizes for various purposes like Define best use of superfood and nfts and then we have this thing we call the pool of Honor which is just a poor prize where if you implement superfluid in some capacity we'll throw you some money just don't do things that I've seen where some of you guys just throw a little git commit there at the end and just add a couple lines I'll actually look all right but just wanted to plug those but all right let's get into the actual building okay uh what do you need to know about before you start actually building on super fluid well you should be made aware of a couple of Dev tools right the first is the super fluid developer console right this makes it really easy to see all these streams etherscan is not quite optimized for this sort of thing yet as you can imagine so we built our own console right makes it easy to manage all this stuff we have a dashboard that lets you create streams and update streams and all this stuff in a no code way if that's your thing and we have an SDK all right so if you like JavaScript you like typescript you don't know solidity the SDK core is your friend right and I'll show you how to use that in just a second so let's let's build okay and I guess you know what before we before we click away I'll go over what we're going to build the first thing we're going to do is we're just going to interact with some really dead simple front-end examples so this is for you you react fans out there you typescript JavaScript fans out there we'll go to our docs I'll show you where to find these we'll create flows update them using JavaScript all right from there we'll actually go through the process of building a super app in a couple of minutes I got a pre-deployed contract here that will receive incoming streams and send all those incoming streams to the owner of the contract and plot twist the contract is also an nft right so if you trade this contract the cash flow follows it right so it's a really interesting primitive to let you tokenize cash flows which can open up really a lot of really interesting applications in my opinion so first thing I'm going to do is go into our Docs where we have a lot of front-end examples all right so let me let me expand this a little bit here all right so in our docs you guys can if you have computers out you can literally go to this right now docs.super fluid.finance and in developers if you go to constant flow agreement it just says CFA front-end examples super easy to find to create a flow what we do is we import the super fluid SDK over here you can kind of drag this over and see it sometimes I'm bad at internet these don't load great we might find an alternative code sandbox this is what we got for now we just set up a simple react app and we have a really dead simple function here where we initialize the SDK using this line Where We call we create this framework object we specify the chain ID you can get this dynamically but I just hardcoded to quarterly uh we create a signer we load the super token contract using this diex dot load we're not diax these await sf.load super token line select it that'll load a super token contract object for us and then we'll create a flow so what we do is we just create a really simple operation object using sf.cfav1.graveflow pass in a few parameters like the flow rate receiver and super token and then we execute that from our signer okay this is hooked up here it's hooked up to an exposed private key right you don't have to oh like have an unlock private key to do this obviously that's not the preferred way for you to do it it's just really easy because we haven't we have an address with a ton of fake tokens in it and we let you just basically demo this in real time so here I have an address I pasted in I've got an amount here which is our flow rate this thing down here will calculate what that flow rate actually is right when you put this number in this is actually in way per second right so it's helpful to have a kind of formula for ux purposes to calculate what this actually is on a per month basis so what I'll do is I'll just click this to create the Stream it should work in just a second all right so we just created a money stream so what I'm going to do is I'm going to plug this address into the console this is the console check it out useful tool if you click home you can see a bunch of streams right on different Networks if I want to click on gwarly I can just paste in the address that I just used to create to send the stream to and we can see that we are receiving some money right so I just created a stream to this address pretty cool right not very much has come in yet that's because it's a pretty small amount right so we created a stream in this you know this in this page we have a few other ways you can do this right so we have at the very bottom a metamask and web3 provider example where you can just use metamask yes question so no one thing you so I'll walk through what I think you mean if you're starting with die and you want to stream money with that die you have to wrap that die to Super token die right so again if you want to if you want simple examples of that again we got more fun examples here uh around let's go to tokens super tokens right we'll walk you through how this works and then we have an example here that's just like the other interactive ones where you can just call the upgrade function to wrap those tokens right that's the only thing you have to do but if you already have those wrapped die in your account no you just call that function and boom you're good make sense cool all right so I won't belabor the point right you can imagine that updating and deleting is very very similar right I won't go into those but that is dead simple creating updating deleting streams in JavaScript right pretty straightforward really easy to integrate with any other projects you're probably working on for a more complex example let's get into this tradable cash flow thing right this super app thing and I have a project up here I'll show you where to find this after I'm done we have this in our our main repo I'll Zoom way in hopefully you guys can see that all right but inside of our examples this is inside of our super examples repo we have this tradable cash flow example here okay so this is going to look exactly the same as it does here as it will in that repo I have to we have two contracts and the first one is called this redirect all contract so with the redirect all contract is is it's a super app which means that it allows us to send money into it and then when we send money into it we can execute arbitrary logic in these callbacks to do something right you could have you that something could be anything you want um but in our case what we're going to do is we're just going to send 100 of the value coming into the contract to the owner all right so we have a bunch of stuff set up in the Constructor right we initialize this CFA library to make it really easy to create streams and solidity I won't go too deeply into that right now but the cliff notes is it makes it so that creating a stream in solidity looks a lot like how it did in JavaScript we register the app right so remember that that host contract has a registry of super apps on it so we need to register it and we need to find the callbacks we do and don't want to use right we have docs on this that explain this in much more detail but in essence there are six callbacks that can run right there's a before agreement created and after agreement created before game it updated after you've been updated and the same for deleted the before will run before the actual logic takes place the after will run after the event takes place okay so we're basically just turning all of the before agreement options into no Ops we're not going to use them right so the only callbacks we're going to use are these after agreement callbacks okay so inside of these right we get a bunch of parameters that the host will call it with and we're going to run a single operation here and that's this update flow operation what's happening in update flow well all we're doing is we're just checking whether or not a stream already exists into the contract and we're handling that situation accordingly right so if there already is a stream coming to the contract and the operation is a delete operation that means we need to not only delete the stream coming into the contract but also delete all the fundings coming out of the contract right the 100 of the inflow should equal 100 of the outflow so we're just basically making sure those match in this function right but again the limits here are your creativity you could you could put whatever you want here right this is just a one example the other function here that's useful is this change receiver function this will run every time the token is transferred so if I want to sell this nft this change receiver function will run which will just change who is receiving the flow right so if I sell it we'll take as a parameter here the new receiver which is going to be the person I sold it to that person's not going to receive 100 of the outflow right simple enough and then inside of this tradable cash flow contract it's an nft it's an ERC 721 it inherits from the redirect all contract and then we use this nice little helpful before token transfer hook you guys can find in the open Zeppelin API Docs and we just call that change receiver function in there so I have a pre-deployed version of this let me go to it in just a second and I got a bunch of scripts so we're going to interact with it really fast before we wrap up so I have some scripts let me let me grab this this contract address so we can go look at it this right here will be our tradable cash flow nft address right we can see I've been playing with it I've been sending streams to it and stuff but if I want to create a stream to this nft contract using a script what I can do is I can just call this create flow script all right and what this is doing is it's basically using the same logic we had in our react app we're creating a flow with the script right so we're just doing this in node instead of the uh react version we just saw a bit ago so if I run this using hard hat create flow .js we're going to create a flow from our signer into the contract on gwarly this should work please internet gods all right yep I think that just worked all right in a couple of seconds as soon as the transaction propagates and stuff we'll go back and see what just happened inside that nft contract but again if you want we can we can go through the the update examples right instead of it being create we're just calling update and instead of same thing instead of Creator update we're calling delete here right the only difference in these functions is that the the delete function doesn't need a flow rate because there is no flow rate we're just deleting okay so let's refresh this again prayers left to the internet God see if it works there we go all right so what we can see let me Zoom way in we can see is my account just created a stream of about 33 tokens per day into the contract right we can see how much has been streamed in and we can see that because again 100 of the flow into the contract is going to go to the owner so if there's basically no net there's no net flow rate for this thing it's just basically coming in and passing it all through to the owner we also have an outflow rate that was automatically created right we didn't create that those callback functions created that so it reacted to that operation for the exact same amount right so that they they match right and that's the idea so that that's end to end a super app contract and all of those JavaScript SDK examples right it should get you started hopefully give you some ideas to wrap things up here I want to walk through like what else you could build right I have a lot of ideas right A lot of people here that are sponsoring will tell you they have lots of ideas that you can you can uh you can you can take and build on but I'll just give you a few right now right one interesting one is a platform for token investing our community would like to see this right streaming money is good for investing tokens right you do have to lock the funds up in a contract at first right but you know money is being sent per second right so it's it's pretty useful to be as you're vesting people invest on a per second basis and actually receive the money second by second the other one is web 3 native subscriptions right so these are all recurring payments right they're money streams there is no canonical yet there are some great teams we love working on it but there is no canonical web3 native uh subscriptions platform that uses money streams yet you can build that another one is a decentralized advertising protocol where you could effectively turn that nft contract I just showed you into like a billboard space right for banner ads and have all the money streamed into it be sent to the owner of the billboard right you can do interesting things in those callbacks like split the funds too if you want um two other ones are around like lending borrowing and lending uh one of them is a lending protocol that you could use streams to amortize loans so what if I could pay off a loan it with a stream right instead of discrete amounts our hypothesis is that doing that would justify a lower interest rate because the lender is getting the money back faster it's more granular and the final one that's really interesting based on that huge Network I showed you is being able to borrow against an incoming money stream right so there's a lot of people receiving salary streams right now right I'm one of them there's many many others what if I could because that's that's a cash flow it's an Unchained cash flow it's proof of payment what if I could borrow against that right and not have to put up any other collateral that would be really interesting and be the kind of thing that I personally would try out right so there are markets here these are things we've thought through a lot if you guys want to build them come up and stay out of booth and I'm happy to help finally like what I want to leave you with is where to start okay like if you leave here and you're curious about super fluid where do I go next all right well the first place is those SDK examples inside of our docs go to our docs constant flow agreement front and examples the second place is our solidity examples repo look up super fluid Finance on GitHub and look for super examples and I'd also recommend YouTube for a lot of tutorials more in-depth stuff and the last thing is a podcast we just launched right so this really doesn't have anything to do directly with super fluid but it is a great resource for technical people like yourself we've interviewed a lot of top devs from maker balance or Uma devra leaders like Austin Griffith about like very technical topics right like their favorite gas optimizations how they ship new features how they manage their engineering teams all this stuff we try to pull it out and give you guys the insights so I'd recommend checking it out devs do something on your favorite podcast platform um but yeah that's the last thing I'll I'll plug I'll leave you with that come see what's up at the booth and thank you for being here appreciate it [Applause] all right thank you [Music] my test with them all right I think we're good to go hello everyone thank you for coming uh I'm Euless from apwine one of the co-founders of AP1 finance and today I'm going to be presenting this workshop and mainly three different points uh you know how what AP1 is how it works and how you can integrate it into your own hackathon project in order to win some prizes so we're going to begin with you know what is AP1 and why did we build it in the first place it all started during the D5 summer of 2020 you know where apis were just crazy three digits and we thought we just saw the opportunity here because there was no way to bet on the loss on the rise of yield so essentially reduce your risk um this is why we came up with a new primitive in D5 called yield tokenization and now yield tokenization is you know mainly the core of AP wine finance and this is what allows you to get your yield in advance or trade yield so yield tokenization allows you to buy sell and hedge your risk in D5 on your yield now how does it work it all begins with you know if if you use some phones on the Ave or you know compound or any yield generating platform you have some interest bearing assets interest-bearing assets is you know you just hold your tokens and it increases in value where it just increases you know yield in your wallet so as an example I've taken you know a die a pretty common asset to to hold in your wallet it just increases in value and this is an interest building token now if you deposit that on AP1 this is the yield tokenization part we're going to split it into two tokens so one of them is going to be the Principal token and this represents the value of your deposit at the time when you deposit so essentially imagine you deposit a hundred a die on AP1 you're going to get 100 PT principal tokens and these principal tokens are always going to represent 100 a die right it's always the same value and now what's interesting is the future your token the second token that you get and this is going to constantly when the a die is generating yield you know from Ave it's going to put this yield not into the principal token but into the future yield token so essentially we're splitting the capital and the future yield and this is what allows us um you know to get this entire Marketplace of future yield going on so you can mint uh PT and fit with your interest bearing tokens and you're never locked in the platform you can always withdraw if you still have the PT and the A40 and then we have the AP1 amm which is a core part of the protocol and the AP1 amm allows you to you know sell this fyt or buy PT or just trade between any of the three assets of ADI ptfrt in order to build your own strategies or get your yield in advance in advance or fix your rate or so on uh our ap1imm is the result of many months of research this is the AP1 ammv1 we have impermanent loss protection mechanism for LPS so if you want to become a liquidity provider on AP1 it's also very easy to do so and maybe we can chat about it after the workshop but in order to get straight into the workshop I'm just going to mention a few strategies here and then we're going to get into what we're going to build today some of the strategies you can build with AP1 include PT trading so this is like equivalent to a fixed rate um essentially buying PT at a discount imagine if you're buying PT at 0.9 so 90 of what it's really worth it means that if you wait till the end of the period for example three months this is what we work with you're going to make a 10 profit because you know for sure you're buying something that is going to be worth more in the future and this is how you fix your rate now without going into too many strategies uh this is what we're going to be doing today today's Workshop is about going back to the future to fix your rate on your yield so we're going to be leveraging the yield tokenization part of AP1 plus the AP1 amm in order to build this strategy so some of the prerequisites and and you know if you have your computer it's great if you don't you can just follow along but it's also very easy to follow with the GitHub repo um so you need yarn node.js and we're going to be starting now with the repository setup [Music] all right it's fine I'll just skip like this um all right this this is going to be a one-handed Workshop which is going to be interesting uh let's go with the repository setup um I'm just gonna get this a little bit higher and we're gonna get clone github.com AP1 Workshop and if we clone this repo and we navigate to it let's open it in code to better see it and you're going to be able to see everything that it contains the first step you're going to want to do is copy the environment file into from the example file to your environment local file so dot app.example2.10 I've set up an API key for you to try please don't use it for anything else it's not going to work all right and then we just want to install all the dependencies so you just want to go with yarn this is going to install all the packages just like npm and while we do this let's take a look uh at how we are going to follow along so first step we're going to do is yarn start node this is going to start a node a fork on mainnet so essentially we're going to be simulating our strategy without actually using money which is which is very useful because if your strategy doesn't work you likely just want to simulate it before so if we do yarn start node this is going to do a local blockchain fork and then we want to open a new tab and every time we want to follow a longer step you can just do yarn step one yarn step two all the way to five so just as an example let's do yarn step one and then we can go look into the code to see what it does so here we can see that that it initializes the SDK and this is the first step that we're gonna take a look at it so first step is the SDK creation very simple just one liner this is going to be a JavaScript Workshop not a solidity Workshop but if you're interested in you know integrating within solidity our contracts we can chat about it it's also very easy to do so First Step SDK is equal to new AP1 SDK you want to put your provider your signer everything that you need the network which is going to be mainnet and that's it a new world opens to you the world of future Guild so this is the first step that we just did the SDK is now initialized and ready to work Second Step so just to explain how this is going to work what we're going to do is first see how we can do the very basic PT trading strategy so buying PT for cheap and waiting till the end and seeing how much APR do we get and the Second Step sit step which is the the real Workshop that we're going to do is go through future yield so essentially tokenizing into ptfit and then swapping our future yield for fixed rate and we're gonna see that this is much more Capital efficient so hang on the first step how do we retrieve all the Futures AP1 supports all the assets that we support all the platforms and so on what we can do is this Futures is equal to SDK dot fetch all future Aggregates very simple you get all the information that you need let's try out and while we do this step so this is going to actually you know run on the on the main Network and we can take a look at what it does uh here so if we go to scripts and then step two get all futures we can see exactly what it does so here fetch future aggregate from address and we just Pat whatever future Vault address we want and if we go back here we can see here the results of all the assets that we support at this time of the fork this was a fork from a few months ago we now support many many assets around two chains and many different platforms but here we have for example and this is going to be the one we are going to look at we have state eth from Lido Finance anybody ever used a staked ease before yeah so you can generate APR you know at five percent six percent depends on you know what you're getting right and this is a period that expires expired rather uh on the 23 of March of 2022. so this is you know an older Fork but the principle stays the same you can try with a newer block number and it's going to work just as well um and then the next step we want to do is compute the APR that we would get if we were to buy the PT for this specific staked future so how do we do this we're going to use the the amm this time because we want a special price right if you want to buy or sell anything you're going to have to go through the apy and amm so price is equal to SDK dot fetch spot price you pass the Vault so this is going to be our stacked East volt and then from N2 these are two different strings so you can put underlying PT or fit very simple and this is what we're going to do right now and see the results so yarn step three and we can take a look at what it does here compute PT APR so here the result is that we get an APR of 35 remember this was before how is that possible the magic of D5 this was you know very close to the launch of apwine so there were still you know many opportunities uh available for Arbitrage there are still many opportunities available um but just keep in mind that this was an older date so essentially at this time you could get 35 by just buying PT and this is a fixed rate so you're you're guaranteed you know hacks aside that you're going to get your your APR so how do we do this we just do compute APR so this is a helper utility method that just you know according to a price and an expiration date you can you can compute how much percentage this is going to give you so for example if you're getting one percent on one month it means you're getting you know 12 per year very simple this is what it does so we are getting a 35 APR this is very very good uh but there's one detail the spot price is never equal to what you're really getting so if you were to buy one million dollars worth of PT you would you would have you know a lot of slippage because the liquidity at this time was much lower so what we need to do is go through the other strategy which is much more Capital efficient by Capital efficient I mean that you can have much bigger volume for the same exact APR or very similar so the efficiency that we get is good but it can be better with lower resources so lower liquidity we can get a same or better result and this is what we're going to do in this new Step we're going to go through not only buying BT with our if but directly staking on Lido Finance so if state if and then deposit that on AP1 so it's going to go like this if stake the if and then tokenize into PT and frt so this is the step we're going to do right now let's do it yarn step four and we can take a look at what it does so essentially we're depositing I I made another utility function here very simple to deposit uh eth on light of Finance so this is going to convert your eth into state eth and then we're going to deposit on our future Vault here and what you get at the end is if you deposit 10 if online to finance you're getting 9.93 PT and 9.93 fyt why is that why not why don't I get exactly 10 PT and 10 f4t the reason for this is that the future already started you know a few days ago so it already generated yield right so you need to account for this but if you were to withdraw everything you would get your exact 10 state to eat back this is because one fyt in this case already has some value so if you add the value of your PT and the value of your future yield it's going to be exactly 10 state eth nice now we're ready for the last step we have our PT our fyt and what we want to do is go from fyt to PT so maximize our fixed rate there are also other strategies you can do for example you could do the other way around you could just um you know swap your PT for fyt which means that um swap your fyt for eth which means that you would get your yield in advance remember fyt is the future yield token if you swap it for eth it means essentially that you're selling your future yield for yield today right and this is where it gets super interesting because you can do so many strategies with it so swapping fyt let's do it SDK dot swap in provide the amm entity and then from fyt to BT provide the amount very simple it's going to do the routing automatically from fit to PT and then eth so you don't need to care about it now let's look at the results yarn step five this is the last step and then we can go with some questions so if we do this it's going to do a lot of computations and simulate everything on the blockchain and final guaranteed APR with this strategy is 34 again this was during the time you can try again with a different block number for example today's block number to see what you would get and it could be interesting you know to do so and simulate by your own or you can just try with real money um so this is what we get the difference with this is that this is much more Capital efficient so lower slippage bigger trades up to 10 times depending on the APR and the you know the apy and the pool that you're yet that you've selected and the composability because you can swap from any of ptfit so it's very interesting to use the amm in that matter right so we just uh basically with a few lines of code you know just five very simple step if you put it all in one file it's going to be even simpler but you know I've kind of split it to make it easier but all of this to say that in a few lines you can have your fixed rate API with a very simple strategy on AP1 so you know if your project if you're still looking for ideas we could brainstorm together but if there is you know anything from Arbitrage training bots leveraging of yield or you know just um there's even some people there who are working on you know lens like social graphs and they have some Capital uh in the project which means that it uses you know Define some way you could use AP1 to not have the capital sit around and do nothing so you could actually put it to work um so this is just one of the ideas that you could leverage ap14 and creative strategies are going to get rewarded for this hackathon we are uh sponsoring with a few prizes let me show you here all right so we have three prizes for AP wine first is the wine connoisseur this is the first prize 5K in apwu and the two other ones the runner-up prices are 2.5 k in APW each um so again if you are still brainstorming we would be super happy to help uh some of you have probably already seen our um stand our booth at East Bogota so please you know anytime during the the weekend please feel feel free to come along uh chat with us and we can brainstorm together to make an amazing project um I feel like you know there are so many ideas possible with different projects so it's up to you to really leverage as as many you know kind of prices as you can uh to get the best out of it all right thank you so much for listening to this Workshop I really appreciate seeing you here um also a note that we are hiring uh front-end developers solidity developers as well so if you're interested you know even at the end of the hackathon uh to talk more with us please reach out we'd be super happy to to chat thank you so much for listening today and good hacking [Applause] any questions so far we have a few minutes for questions um but again there's going to be time during the weekend to answer any of your yes please yeah good point yeah so Huawei P1 works is you start with your a die for example like very simple interest-bearing asset interest bearing asset means that it generates yield over time you deposit that on AP1 and the Primitive that we came up with is the future yield tokenization so it splits this interest bearing token into two tokens if you deposit a hundred dollars your PT is going to be worth exactly a hundred dollars not more not less all the time and because this generates yield all the yield over a hundred dollars is gonna go not in the PT but into the fyt so from the time zero to the time you know one month after all the yield is going to go inside of the fyt so I can exactly no no please um what I meant to say is you can use compound to generate yield and then go on AP1 to tokenize that yield it's very interesting though that you mentioned borrowing with PCS collateral yeah well you could definitely try doing this during the hackathon this is very good first idea definitely something that you know we're looking into but please feel free to try awesome thank you so much for the question any other um question so far yes please yeah yeah that's a very good point uh maybe I can show the interface so so basically all right let me if you go on AP1 you're going to see all the features that we support and what you mean is uh here the the lp apy right so PT for example underlying and then ptfyt right correct yeah oh this one the tvl the market APR okay that's a very good point maybe we can take the few minutes to explain this so the market APR is what you're going to get on AP wine uh if you go into the either the PT strategy so buying PT or into the fyt strategy so selling your future yield so let's look at it at an example uh staked Ave for example if you go on AP1 and you get a fixed rate you're going to get 8.1 percent okay this is this is right now if you sell your future yield and you get it in advance you're going to get 7.82 so essentially it's fixed rate on top BT versus fixed rate plus yield in advance so it's lower right because it's had some discount and then here the lpapy this is going to be the apy that you can get um by providing liquidity on either of those pools so there are two pools on AP1 for for each amm there's you know on uni swap you have two tokens right on balance so you have three tokens and on AP1 we also have three tokens so the PT the underlying and then the fyt so it for example PT die or eth or whatever and fyt there's two pools you can provide to so if you provide to the first one which is PT underlying this is the most stable and like risk-less pool because you you only get exposed to minimal and permanent class uh this is going to give you 0.6 plus 95 uh any rewards of APW if you provide to the ptfit pool which is a little bit more risky but it's also another strategy because you get exposed to the volatility of the yield you get 6.1 percent plus uh this amount in APW I hope that answers your question awesome yes that's an Arbitrage opportunity right now it either means that the liquidity is um is low enough that there might be arbitrary opportunities right now to take because like higher volumes can't you know keep up or it can mean that we're very close to the period being expired so like because there's like only a few days left there's like this Arbitrage opportunity also so if you see anything negative it can also be a hackathon project you know a bot that takes advantage of any arbitrary opportunities on AP1 so that's a very good point so essentially you just um you would just tokenize and then sell your BT it means the PT is above one so there's Arbitrage to be made [Music] yes you need to go on the AP1 amm though yeah but same same concept as a sushi swap or uni soap or anything you're comfortable you know with already using yeah awesome thanks for the question anyone else all right again I just want to mention uh you know thank you guys so much for coming we have the booth uh all week uh all weekend and uh so please feel free even if you're still brainstorming ideas or if you're building on top of AP1 want to get some feedback and inputs uh feel free to reach out to us and we would be super happy to help you guys awesome thank you so much happy hacking again oh right does it work awesome yeah that's perfect hi everyone I'm Kevin from Boba not sure if you have heard about Boba Network yet it's an optimistic wall up that allows you to make off-chain calls within one single Atomic transaction and that's called hybrid compute formally Turing that's what I'm super grateful today that I'm allowed to present you today to give a little bit of backstory of why we started with hybrid compute basically we have all seen the craze last year we have the play to earned games right x infinity and all those uh copycats and comparable um played your own games which unfortunately weren't that sustainable right and we don't have a solution for that unfortunately too but we at Boba believe that it's time for great games right and great games what have all of them in common create your ex right they have a amazing gameplay it's not like you need to wait for some things it's easy it makes fun and you don't play games just to earn money but because it's fun and to maybe even have some additional benefits like Gathering collecting some nfts or whatever all right and that's what hybrid compute for right and before I get too deep into the technicalities um I want to give you a little bit of backstory what's the differentiation between hybrid compute where you can make these off chain calls and regular oracles right because that might be the first thing that you think about when I say you can directly call from your smart contract external API point and do some cool stuff with it right I'm not sure if everyone here ever used chain link Uma optimistic Oracle that's also here today um all of them have amazing Solutions all right don't get me wrong they have their use case they do incredible work with requesting data in a decentralized EQ manner right but when looking at game file do we always need that async fully decentralized way of collecting data into our smart contract right I'm a smart contract developer myself I love decentralization right um so why are we talking about centralization now in the whole blockchain Space we always have that trade-off between scalability security decentralization right and when we go back one step and think about game fire ux is still a great gameplay still the most important aspect in the whole game for space right then almost all web free games incredibly unfortunately fail at this right and we need to change that so in comparison to all these articles that we have now I said different use case where we need to wait several transactions meaning it's hours or even longer depending on the sensitivity of the data um there might be the need at some point that you can actually request data on time right within the same transaction just think about when you play a game you earn a nice little skin like a cool jacket or anything like that and you would like to personalize that in some kind of way right you want that some personal data that you have on your central as backend want to have that within your nft in a autonomous and trustless manner as much as possible right so what you can do now you can have within your smart contract can call your API endpoint in a synchronous way get the data and directly work with it and that actually gives you a whole new possibility or opportunities to build some great new applications right as said different use case than oracles and that's what we are going to do today so basically to give you some understanding how that enchantment works right Boba is asset a layer 2 solution so what we basically did we modified layer 2 gaff and when you basically call that smart contract function that triggers that API call then we intercept that RPC call and replace the original call data with the result of the API API call and save both of them to layer 1 which is in our case ethereum and that enables us to do that in the same transaction so to give you some understanding let me get that to the other screen to give you some understanding before you uh get shocked Away by code um the whole touring landscape which is I said the old name for hybrid compute you will see that now and then on some places because everyone who has ever won a company knows that replacing a name is unfortunately a really difficult task um in China world we have three core components right well actually it's four we have your own smart contract that triggers the API call makes sense right then we have your backhand itself that understands or needs to understand some way uh that needs to understand what kind of information you're sending from your smart contract to the backend because it will be or needs to be API encoded it just can't be plain text or something like that and the same way all the way around if you return data from your backend to the smart contract it also needs to be in an understandable format and now we are coming to two uh order smart contracts that we might need to know or think about and that's on one hand the so-called touring helper or hybrid compute helper as you wish and the touring credit and both of them have a really close interplay one of them the touring helper is a smart contract that every project needs to deploy themselves that contract basically is nothing else than your personal let's say key to your backend let's put it that way and the during credit contract basically keeps track of your touring help on your smart contract but why am I saying this as with every Oracle you need to pay for each transaction right for each API call you need to make a small deposit um in our case it's a prepay so you need to prepay your um if you basically deploy your project you need to prepay the amount of boba tokens that you want to uh Fund in at once all right so that your users can actually trigger those smart contract functions so every time you call your smart contract there will be 0.01 Boba token which is around a few cents currently uh deducted from your prepaid balance and the touring credit contract is deployed by us the Boba team which keeps track of your balance basically and the touring helper contract is some kind of authorization right so that only you only your users or the contracts that you want your custom Smart contract can actually call that endpoint otherwise I could just use your endpoint for free right and you would pay for it that's why we have two smart contracts here but enough Theory sorry for that um I want to show you a little bit um what you see here is really uh quite minimalistic example that I want to implement with you today and what it basically does it calculates the time deletion from based on the special relativity Theory by Albert Einstein sounds complicated right now it's just a basic math formula which would be quite hard to calculate in a smart contract as you can imagine right and that's why I chose that for today if you want to do that with me I have prepared uh a starter Repository that we that I would ask you to clone then we could actually do that basically it's uh on our official organization and it's called hybrid compute underscore tutorial that default branch is already the one that you can use to implement that with me today and um yeah there's basically everything is already set up and we will go through every step that it's actually needed to perform your touring call to give you a first uh insights on what we are talking about at all um I want to show you how does such a API API call actually look like right um the most right let me look here that's a more beautiful example [Music] you can see it here basically it's really just a one-liner right you can actually call your smart contract by calling a method on the so-called touring helper that asset your project needs to deploy it themselves but you don't need to change a single line there it's really just fully prepared already uh ready to deploy a smart contract that you can use you just needed to actually keep track of your balance right um to get back to the Repository to give your asset a little bit of overview we had have said we have a couple of components here right we have our own custom Smart contract that we will Implement today we have our so-called touring helper ready to deploy nothing to change basically copy paste that actually tracks if your smart contract is allowed to call that endpoint to actually be charged for that so it's a white listing and some other you know error handling stuff and whatever but as said you basically just need to know two core functions that will be useful for you on one hand you have the so-called touring random function which gives you a super strong soil random number directly from layer 2 Gap and we have the so-called touring TX function where you can call any endpoint with any call data you want that's where you can actually do your off-chain calculations or call further API apis such as Twitter or whatever and yeah basically that's the Turing helper that's our Custom Contract that we will deploy today and then you will need your own custom backend right that understands the data you're sending to and data that you're returning from in our case we just used uh AWS Lambda function that's already prepared for us I still uploaded it here so that you can actually have a look at it and understand it but basically everything that it does is decode uh the API encoded data and encodes the result as well so nothing super complicated on Magic here but as said that already deployed so if you have cloned that for yourself what you can do now is as always if we Deploy on testnet we will need some kind of testnet tokens right otherwise it's going to be hard to actually deploy anything we have a nice little faucet for that on on our Gateway you can find it if you type on the search bar Gateway rinkerpy dot Boba dot Network and as you can imagine right now that's the faucet basically this faucet itself actually uses hybrid compute itself what it does is it asks you to copy your so-called Boba Tech which is nothing else then the Boba prefix with md5 hash of your public key and post that on Twitter just like I did here if you have that just need to copy the link and can put it in here what this does now if you click on authenticated faucet it actually requests from the smart contract the Twitter API and checks if you have posted that and then sends you step over and if so that's what you would need to follow the workshop today so if we go back to our own project now what I did is to actually give everyone here a little bit of a safe haven if you code that today then I want you to be sure that it actually works right for that very same reason I wrote a simple test that actually checks if you did it right so nothing to be done here but basically what this test does is it returns it checks the event that I'm emitting in the smart contract which we need to do right right now it's undefined Undeclared uh variable and yeah then basically just checks if the value within the event is the one that we are expecting to and yeah small hint not to confuse it too much but basically as you might know solidity smart contracts don't support floating numbers and this formula returns actually a really small number that's why I multiply it on the back end uh the floating number with 1 trillion and here I'm just dividing it back to a value that makes sense so basically what this would do now it calculates how many minutes basically your time is stretched if you almost move at the speed of light right we're very close uh to the speed of light here that's the velocity parameter and then we have the proper time which is the original time that we we as a person actually feel like it is I think everyone here or most people have seen the movie Interstellar not all of it is science fiction the part of it where gravity and uh basically the speed of your aircraft uh stretches the time is true so let's get Hands-On right I have prepared some Setters on top here which you don't necessarily need right as you know you can't provide everything yourself but basically every time when we want to use hybrid compute we need our own custom Turing helper alright that's the contract that we need to deploy ourselves that's the one that we had a look at before right the one with the error codes and with the touring tags function with the touring random function and so on so that's basically just deployed bars I'm just assuming that for now and basically what you need to do is provide that address to the contract so that your custom Smart contract knows where to redirect your call data to the second would be what's your actual backhand right what your actual backhand API URL and that can be anything as you might guess in our case it will be AWS Lambda instance which you can use yourself I already pasted it in the in the tests if you look here it's on top it's here that's already live so basically that's our python file that we see here so to actually make that work now we now have or assume that we have our hybrid compute helper we assume that we know where the information should actually flow to and now we actually need to do three basic steps which could be in theory of one line now but I want to make it simple so the first thing we would need to do is encode our parameters that we want to send to our backend in a way that the smart contract is able to handle so basically what we need to do is we need to create uh a bytes value I'm just calling it right now problems and we basically just encode our two parameters that we get from this function time that those are the 15 minutes that we saw before and the speed that we're moving at so that's the first thing basically we encode the data in an understandable format so the next thing that we need to do is to actually do our synchronous API request so that Works uh in a quite similar way with the Turing TX method that we saw before what we get from the API itself is again a byte value so it's really uh it needs to be in a format again that the smart contract understands so basically get here our bytes memory again I'm calling it USB for now and now that's not best practice and now our so-called hybrid compute helper comes into play and we see now that we have our joint TX entering random function that we can use the touring the X function basically let me see if we see that even here yeah requests that we send the URL that's our HC endpoint in this case just just a regular string and our already encoded parameters the ones above that's it basically that sample line sensor API request to your backend no callback nothing else super simple and the next thing what should I do with bytes now no usage for that I want to have some kind of proper value right you want to have a number I want to have a string whatsoever now it would be great if you know what your backhand returns right otherwise you get some random uh value out of it in our case I know that it's an integer value so what I'm doing now is um defining that the first value of my Tuple is just a number and I decode the rest B value that we just got foreign it's always great to develop onto this place so that should be it right and that result that we get now we just emit the event so that our test can actually read it and check for the accuracy that would be the whole Magic this asset um I hope I didn't confuse it too much right it's always a little bit difficult to go from Silver to 100 but basically this enables you to do a lot of crazy new things all right things that you couldn't do that easily before but everything is possible right now right we have our clothes we can't do everything but we all know we all went to uh through callback Cal in web 2 and it also can exist in web free right asset chain link Uma all oracles are great they have the use case this is a different one so now I'm going to do the most risky part of my presentation I'm trying to run the tests let me let me see if everything works so what these tests now do they basically deploy our touring helper let me show you the deploy the twin helper here I said that's just our prepared contract from before our own smart contract where we actually provide the Turing helper address and our backend URL this case asset AWS Lambda instance and what we need to do now is we need to know basically tattooing helper needs to know which smart contract is actually allowed to call maturing help on my endpoint right for Which smart contract I'm willing to pay for right otherwise I said I could deploy a smart contract and one of you need to pay for it right wouldn't be so cool that's this line basically a white listing to protect your funds when we're talking about funds we also need to basically fund fund the touring credit contract which keeps track over your funds by actually knowing your touring helper contract address because you're doing helper triggers that API call finally and that's why the Turing credit knows from where the call comes from that's what we do here we basically just add some boba tokens to the twin credit contract and the rest is just some basic checking if if we get the correct address back and so on so that's basically it I'm super happy that this works and I hope you learned something maybe you got even some kind of like crazy ideas for the next few days I don't know I would love to know them and yeah okay any questions I'm happy to answer foreign 