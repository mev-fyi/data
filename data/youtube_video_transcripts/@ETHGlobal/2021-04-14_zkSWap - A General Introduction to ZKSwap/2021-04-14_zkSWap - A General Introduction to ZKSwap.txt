seconds yeah well actually fun let me turn on my okay okay great um welcome everyone to the zk swap um and a quick introduction to um zk swap uh taking the session today is howard um yeah and with that i will pass it over to howard to give a quick introduction to himself and share his screen to kick the workshop off all right hello everyone thanks for joining the the workshop i hope you're having fun so far and i eat global hackathon um wait here's to my screen [Music] what's going on yes right yeah you might want to just um put it into full what do you see over there i should be showing you the whole screen um yeah you you you're not sharing like the whole screen i can still see your desktop background and then uh a window open with zk swap wiki yeah yeah that's it that's it but okay okay i think that's it yeah so i can share the and and i'm not sure just like so can you see the slide now uh no i'm still seeing zk swap wiki it's bizarre i'm choosing the whole desktop sure um we can see the slider just maximize your uh browser window uh do you see a slide now [Music] yeah for everyone for coming uh yeah i think like the the whole road up system is moving really fast and the whole um the whole layer to ecosystem is evolving very quickly as well so i really have to apologize for the lack of documentation and probably inaccuracy inaccuracy in the documentation as well so some of this may be a little bit confusing because it is confusing and because the parts are changing so if you guys have any questions you just interrupt me in the middle and i'll try to answer it the best as i can and so i i'm the smart contract engineer at tk swap so i mostly handle the smart contract uh component of ticket swap so there's really quite a bit of stuff i don't really understand myself because i like that i'm not super i'm not actually familiar with how the the zero knowledge proof system works so i just want some basics so i'll try to answer and probably relay some of the questions to the technical team but i'll just try to do my best okay so maybe a little bit of an overview of our project so it is a one of those layer two tokens for protocols it's an am on there too and we launched in february this year and we have about 20 people on our team and so far we have 1.5 billion in tvr and about a billion dollars in liquidity and we do about 150 million in a trillion dollars in a day doing pretty okay uh and we have a payment and we can do liquidity mining on there too and we also have swap there too uh and it's based on ck roll up so it's um the literally it's using validity proof instead of proof and all the all the data necessary is unchained and there's no exit period so pretty much the the property of zk roloff and we've done a lot of optimization on the proofing speed and the data storage requirements so we so far we've managed to get it to about 100 times the the capacity and throughput of their wine ethereum and the the gas cost per transaction is about 1 50th of what it costs on on their one and for users the interaction is pretty much instantaneous because as if you have played around with the male 2 applications before it's really quite a game quite a game changer in terms of the technical challenges we we faced is really having to do with the digital knowledge system uh the the complexity of the second knowledge proving system is directly proportional to the complexity of the application logic and in our system we implemented the a n at the circuit level uh so we had to do a lot of like compression like data compression and try to make the data as small as possible so the circuit's just directly proportional to the size of the input as well so a lot of complexity in the input would also sort of recursively precollate down to the circuit level as well so there's a lot of optimizing optimization opportunities in terms of the design of the data structures um and we've done quite a bit of work on the proof generation itself as well so we had an implementation of a gpu implementation of the planck algorithm and the tps reaches above 100 and we improved the implementation by three times and there's still quite a bit of uh room for improvement as well so we started working on this since last august uh so we're so we haven't finished like all of our optimization ideas yet so i i think the the proof team is saying they probably have another five time improvement that that's possible yeah so we'll see if that happens uh in terms of in terms of uh optimization optimization technique another big area is the aggregation proof where we take instead of generating one proof per per block we combine multiple blocks into the same proof and on chain we could just do one verification for multiple blocks so that saves quite a bit of gas as well and with this improvement we are looking at about 1 400 gas per transaction most of the gas cost is really uh unchanged data and and just verifying the the dk proof so as we as i said a little bit earlier the aggregation proof helps quite a bit and in terms of our roadmap for 2021 we're looking to support a user listing of tokens just probably later this month or next month um so there's a one thing about like token listing as well there are hard limit in the circuit in the circuit as well so i said earlier that data data the data complexity data structure complexity is a big issue so one so one optimized state one optimization technique in the ck rollout system is using token id instead of token addresses so on ethereum you can you can essentially launch infinitely many erg 20 tokens and each of these tokens will have their own address and that's fine but in tk rollup system because the the token ids uh we can only support like 16 bit of token ids so that's a much much lower much much lower uh limit for the number of tokens that's possible on the system and this is really because of the the circuit complexity as we mentioned earlier um yeah and so this corner was still working on like optimization optimization for the proven system but there's still quite a bit of improvement there and we're seeing some bottleneck in the proven system so when we were doing our liquidity mining program our system was was congested just because the proving system couldn't catch up with all the demand and we'll also probably do governance token this this quarter as well and coming up we'll be doing a stable coin swap on there too something like curve on there two as well i will be working with exchanges and businesses in asia and internationally to integrate our our payment system into their wallets uh so we're also providing online services for exchanges exchanges and then going even a little bit further well we'll be working on a general edm on there too but we can have d5 comes up we can have d5 composability uh on our system as well yeah and for the hackathon uh so we'll be looking at probably for the community to build to try their hands on building arbitrage tools so just maybe looking at prices on dj swap and compare the prices on their centralized exchange and try to do arbitrage there i think there's there's quite a bit of arbitrage opportunities and one interesting property of our system is the op tokens even though the liquidity exists on there too we also issue corresponding lp tokens on their one so uh so there's probably some interesting like things you can do with these lp tokens so maybe we use them as collaterals for different lighting products or build derivatives on top of the the vlt tokens so we'll see what's what what sort of ideas the community would have yeah and this is sort of our uh social media as you would expect there's like the twitter dk swap official and also like the telegram group the official telegram group so you have questions and ideas you could probably uh dm on these groups yeah so this is we have a quick overview of our project so if there's any question you can probably take some questions before we move on yeah thanks harold um yeah there was a question from youtube um but i do see that um a representative from zk swap is answering that in the youtube chat as well um i did paste it in the chat channel here okay uh let's see let's see there's the chat uh okay well maybe read a question [Music] so is it not a hundred percent zk relapse and and it is validity it was announced that a separate that a separate hundred percent zk roll ups would be released mid-march but there is no separate product what implement is zk swap currently oh um i i think there are like different different security properties so there's uh they have the data availability problem and there's also the transition let's say the transition security so transition is about doing following the rule of the system and there's no way to cheat so as far as that part is concerned we are fully fully secure and about that and data availability is more about whether uh you could you could recover the system if if we go down so if we just like sort of nuke our servers then there is this there needs to be a way to use unchained data to recover it so right now there are some data we couldn't recover because this data is not unchanged uh but theoretically like these data could be backed up somewhere else and you could use that data to recover so you could put it you could put like a backup um file coin um that you can recover from falcon something like that but in terms of like security and safety of the fund uh there's nothing to worry about it's more about recovery but but coming up the plan is to to launch like to to to provide full recovery as well so that's probably not going to be an issue going forward but we're also considering like different ways to provide the same like cheaper ways to provide the same data availability properties so so so that's something that's still sort of floating around like even in the aqua system at large so that's one area that's still being explored okay cool thank you um another question is where are zk swap servers for l2 computation i'm sorry where how where are zk swap servers for l2 computation aware like who's providing the services is that the question like who's providing the proofs like the proven computation yes okay okay um yeah so right now uh the proofing system is just we are providing the proving computations and it's quite hardware intensive uh so the the decay swap protocol is it's just we have like lots of machines doing the the proving uh [Music] yeah i mean that's pretty much the answer and there's really no way to decentralize this either because uh because the proving needs to be serialized so you can't you can't it doesn't really make sense to have a cluster where you distribute the the zero proving [Music] process process uh otherwise you're really just redoing the proofs across the cluster so um yeah so i'm like i'm not really sure like if there's a way there's a good way to decentralize this this mechanism but but again i mean like that the security of the system doesn't depend on like whether the proving infrastructure itself being centralized or not so it's really more an availability issue than anything else so i'm natalie from ziki swap i would like to jump in for the previous question about the 100 zk roll ups we have actually updated to the full zk roll up version on march 22nd and you can check it on the on our explorer zk swap dot info and all data availability availability is unchained right now okay okay okay okay cool yeah thanks um maybe we just do one more question before you continue and is and that question is do you plan to support zk swap with tokens from multiple evm compatible chains cross-chain bridging is a whole kind of war in itself so like as long as there's erc-20 on there one ethereum like however is created either through a bridge or through some sort of like some sort of say cross chain issuance so there's a lot of d5 protocols going on where they launch like different versions of their own protocol on different evm chains and each chain effectively there are siloed tokens of the same protocol so as long as there are tokens on on ethereum then like we are happy to work with like different different chains as far as like uh as far as like crosstalking different their tools i think that's still like sort of in the air and nobody really knows how it could work there there will probably be bridges between different there too in the future i think there are like projects working on that um so i think it will happen in the future for sure and like we are we also have like evm compatibility planned on on our roadmap so once that happens that i think uh it will be easier to build bridges between different layer tools but so far you really have to go through there one yeah thanks yeah i think you can maybe continue with the uh rest of the session yeah uh so uh so as i said in the beginning like a lot of the documentation is like really quite rough right now because we're just working really hard on the other features uh so there's like some some uh basic basic apis where you can get a list of the supported tokens and like um like account infos and account balance these are all um there too so so like oh all the data queries are pretty straightforward so i'm probably not gonna get into too much details about the about of these like lists of transactions so this is pretty much like the the api that zika swap explorer uses i think these are pretty straightforward so i'm gonna spend more maybe a little bit more time like dissecting the structure of a layer to transaction um and the process of creating a layer to transaction so so there's like one one api one post api for creating and submitting there to their two transactions and it's the same api for for a different operation because i think that the the main operations are like swap swap swapping tokens adding liquidity removing the liquidity and sending and transferring to like recipients and these are all using the same the same restore api and but the transaction structure will be different for it for like all these different operations so uh so so this is like the documentation for the restaurant api and for making transaction so here's a document document that's that sort of walks you through how how a layer two transactions could be constructed so first we start with like uh crossing from layer one to layer two and and this is just a matter of this is a matter of depositing some money and calling coding like the api contract the the contract api methods and depositing some some fund into the decay swap contract then you'll be picked up picked up by the system and i mean a corresponding balance will be created on there too so this is pretty like pretty straightforward layer one operation um yeah so we'll just move on to the interesting part so this is just like typical like ether gs thing you load the dks contract then you load your wallet and then you just call the method like the deposit the rc20 method to deposit the money onto the or2 so that's pretty straightforward it takes about 10 million minutes like everything like 15-20 minutes for this to complete and on layer two uh you the way their tool works the layer two system uses a different set of key pair and uses like different cryptographic primitives then from there one so so we have to generate a private key on the front end and the private key is the private key for layer 2 is generated from from a signature so you actually use the metamask wallet to create a signature and using the signature as the seed for the layer primary key so so so the layer two privacy is deterministically uh generated from their one wallet so this is like the process of how of how you generate that yeah and this is this is you have to you have to register you have to register the the generated private key with the layer 2 system because for every account on layer 2 you are assigned an account id just to and the account id is actually limited uh i think that to about 40 billion accounts so it's not there's like a an opportunity to how many accounts there could be um again for data compression reasons for efficiency data efficiency and circuit efficiency uh yeah so so one so once you generate a key and register with the military system and and then for every operation you make you sign you use the you use the generated layer 2 other key to sign the transaction so here's the code that signs a layer to transaction so so you use you use the primary key generated above and then all the transactions are are actually just concatenated um concatenated bytes so for example the first the first byte would determine the operation that the operation would be like either a transfer swap adding liquidity remove the liquidity so so the first fight is the operation and then for each operation is just necessary a series of bytes of of the data that operation needs and we have some missing documentation here uh because we are still working on like some some parts of it but we have an example of a swap transaction on there too and so so as we said the the transaction is really a sequence of bytes and for the swap for the swap transaction the very first byte is the swap uh operator so it's like the the zero b zero b um type stands for swap and then just a sequence of different different there's a sequence of the necessary parameters like from which from which layer one account to which which which one their to account and then like the token amount and total amount et cetera the chain id this is for security reasons to to prevent replay attack on different possibly different thereto chains and possibly different layer 2 systems on different chains so you could theoretically have a layer 2 system on say binance check but if you even if the layer 2 system doesn't have a chain id that you could possibly replay a layer binaries to a binance chain later to an ethereal chain near to it so the chain ids is there to prevent that happening um yeah so so so this is like a sequence of a sequence of the the precession data necessary and then you concatenate everything into and one byte that you create you create a signature of this this byte then just pass pass in the the whole the whole thing as a json as a json structure to the to the api to the restful api in the previous page yeah and so this is really the data that goes on there too then then be packaged into a layer 2 block then that will be approved will be generated and submitted on their own and verified and there's one extra thing it's really for uh for sort of like usability and security but it's not really relevant to their one so uh so when when you wait wait uh so so we actually generate the layer 2 private key in the in the web application so theoretically we could just user could just click a button and then just send the transaction immediately without having to go through metamask so so this thing here so we actually still sign a message with metamask wallet so this is really just to give a feedback to the user so when the user clicks a button then a metamask request which is a meta mask the metamask wallet will pop a request prompting the user whether a signature should be provided but this signature is really not necessary for the security of the system it's really to provide that experience of user confirming something and the other some possible security um issue is suppose there is an injection uh into the website then then it's possible that the injection just creates like malicious transactions onto layer two and the literature system we don't know any better so so this this message is also a way to double verify that a transaction transaction is both verified by a layer 2 key and and by a layer 1 wallet so this way we can also mitigate the possible risk of an injection attack but this is really not strictly necessary for the layer 2 smart contract and if you go into the smart contract you wouldn't see anything related to related to this signature um yeah that's pretty much what i have to share just jump in sorry um if you go a bit uh up to the json file that you showed yeah how would you go about generating um this whole json file using this like the simplest way possible like what uh extension would use would you use web3.js and um how would you get that yeah there we are preparing an sdk uh so so so before that's ready you just really just kind of like combo together something by yourself but i think we'll have an sdk like quite quite quite soon i don't know in a week or two so when that's ready you just like import the the npn package that you have you can just like use the api that way yeah does that answer the question uh yeah thanks just just like how would you generate the signature then without the sdk you would using the office it's really quite primitive you just use um uh there's the dks think crypto so we use the same cryptography as dk sync right then as i said as i said you concatenate the transaction data into one message one-on-one buffer then you assign it with the chsync crypto cryptography so you can do it just by hand in your script oh okay thanks yeah yeah so if you're doing if you're doing just doing some sort of arbitrage then this is actually pretty straightforward you don't need to wait for the sdk to say do it it's probably i know like dozens of lines of code it's not that bad it's still kind of ugly but it's not that it's not not not too bad yeah great thanks so much howard i really appreciate you taking everyone through that session if any of your questions weren't answered in the chat i will be posting them in the zk swap sponsor channel and the zk flop team will reply uh there but thank you so much and howard if there's anything you'd like to close off with otherwise great thanks howard and thanks everybody for joining hey thanks 