um okay cool right so yeah so I'll be presenting on Kota today I I know the two of you know about Kota do you guys - have you heard of Kota put before no okay so someone told you about it once okay so I'll tell you more about it so Kota is a new cryptocurrency a new layer one protocol and what it does that's special is it swaps out the usual blockchain that gets bigger and bigger for like a zero knowledge proof it puts the whole state transition function of the protocol in a zero knowledge proof so I'll tell you about that today and also we will be running a node and doing some like live coding with it so let's um get started so first thing I want to do is I want to spin up a node and this is something that if we were to do it on like a regular cryptocurrency you know would take a very long time because Kota can really quickly sync with the zero knowledge proof it'll happen pretty quickly you know if like the live demo gods or ever are on our sides we'll be able to live code against it so I just have to pull in the command to run I've already app - get installed the node we just switched to lid p2p which is why there's these fantastic long strings actually start a screen up and then I can do things with that so let's start that up that's running and then over here start up a thing that will listen to the node once the node is running so yeah when the node starts up we'll be able to see on the side here all of like the status of the node let me zoom in a little bit for you also okay there we go okay so right now the nodes connecting to the network and very soon it will have been connected and we'll be able to start working with it but in the meantime let me tell you little bit more about Kota so maybe I should have said earlier on I'm Evan I'm one of the cofounders of oav on labs building Kota moving if we're on two years now so I'm excited we're like actually able to have something running now and it's very exciting so it's a new layer one protocol and we're replacing the blockchain like I said with a recursively updating as your knowledge group so everyone can download the blockchain with us for like maximal full node security even on like a phone or a browser like really quickly with Jessica kilobyte of data and the snark is actually just a constant one kilobyte and this is in deep of throughput so that's great it also has you know pretty easy to develop things with it because like the you know notice so small you can actually import a library that pulls in a full full node you don't worry about in fira or meta mask or any of that stuff you can just like you know pull in a library that is all the work for you you can also buildings with privacy because of ZK snark so we have really good native support for those and it's something you'll be able to build cool things with them so to talk a little bit about why you might care about blockchain size we have talked about blockchain decentralization so we would like it to be that in the optimal case you know that everyone is equal access to cryptocurrency everyone can download a full node they have equal trust access to the network and this is true when you know a blockchain is new and small but the you know block chains go really quickly over size they get really really huge and when that happens individuals can't really download block chains easily anymore they they're just like too big it's like 500 you go by it's a terabyte or whatever it's just not going to happen and this centralized is control in the hands of the shrinking set of entities that can afford to run nodes and then this is bad for both like individuals and like for cryptocurrency in general like you can imagine that like you know even the players that would probably end up running the infrastructure to control these nodes they don't want like the regulatory burden of like having to deal with this they would rather it was really properly decentralized so it's really important we get to a state where everyone can just use cryptocurrency as an individual and you can see this actually impacting the coin and aetherium a lot for Bitcoin you can see like the node count of stayed basically constant since like mid 2017 and you would have expected this to grow you know we want this start to go up into the right of course but that's not the case and for aetherium it's even worse like it's actually going down a lot since I'm in 2017 aetherium is actually gotten a lot harder to run and then a Bitcoin and now it's at the point where like um it takes you know weeks at least to sync in the theory of node it's like not a great state to be if we want people to actually using this stuff in a in a trustless way so why is this the case well we already kind of hinted at it it's because this blockchain is a bunch of transactions in it you have to download all those transactions that kind of sucks it means that like as time goes on more users and devices just get excluded like the last time you could actually download like a Bitcoin owed to your phone was in like 2014 not that anyone was going to do that back then it still would sucked like it sucks today but at least back then it was it was kind of possible and now it's just simply not possible and that's just Bitcoin the theorem and others are like you know at least as bad if you know significantly worse so we already talked about what this problem is so the question now is like we have this transaction thing with the blockchain we have like this decentralisation thing that we care a lot about how can we decouple them so we can still put all these transactions on the chain but it doesn't challenge decentralization how can we do this and you know from the beginning that's something about snarks is the answer let me tell you a little bit about snark so that you we can I can properly explain how that connects back here so what is a snark it's a succinct non interactive argument of knowledge so really what it is is a small succinct proof for statements of the form there exists and moreover I know some data such as some property on the data holds this is a very general statement and we'll see you later how it actually connects back Dakota what you should know about snarks is they've only really recently reached practical performance they've existed theoretically for a very long time now but now they're actually practical and we've been writing some tools to make them even more practical so then you can you know write smart code like regular like a regular program so you can like write large programs and you can actually check and like no they're going to work and we have a library for that snarky that's all open source check it out you can write snark programs just like writing functions and yeah so how does this apply so we have these snarks and what we do is instead of a big block chain on that you have the big download we have the network recursively update a recursive zero knowledge proof of the blockchain and so that's a one kilobyte proof that's really fast to share in check and really when you have the snark it's an equivalent computation to downloading and checking the whole blockchain it's the same computation just now instead of doing it all yourself you can look at the snark and know that if you had done it you'll get the same result which is great and connecting that back that's to even before you can imagine that the data now is the whole blockchain and the statement we want of the property one will have to hold on it is that the predecessor is valid or it's the Genesis this is where the recursion comes in it's basically saying that if you were to look at all the history back to like the Genesis block it's all valid and if you had downloaded the blockchain it would be all valid so you don't actually do that now you can just look at those equation arc which is great the recursion also means it's really efficient to update the new proof can be like recursively built off of the predecessor so you can take the predecessor chain that has a proof already for it and the transition function and the new proof and you can say that the new proof is the existing proof of the predecessor being correct since the Genesis and the state transition function being valid to the new state on so because of that you have to do one step every time you add a block it's very efficient to do that or at least efficient enough we can do so with snarks which is great so great so we have we're in this world now where you can get the z key snark for the protocol state trustless li in about a kilobyte and you can get the account states and there miracle paths with an additional about three kilobytes per account which means that if you want to use coda you need about a kilobyte for the protocol state and three kilobytes per account you need you can get a bunch of account that's still extremely cheap and bandwidth efficient so you can get access from phones and browsers trustless lis no inferior meta mask this also means that everyone can have easy equal access and this is true even at scale so because it's always one kilobyte you can increase the throughput a lot they just kind of fold into the little Z key smart so you can have high throughput and you can have like easy accessibility right so what does this mean for like developer experience well it means that now you can import a full node directly into your program including on websites without you know a third party or a browser extension in the middle the library can connect directly to a gasa mat over something like WebRTC and then the you know the program is really connecting to the device from the user's device itself it's not like going through any middlemen which is awesome it's also cool because um you know you can actually leverage snarks with this thing so you can build privacy using app leveraging applications that actually connect back to real users of just cool so today's test net we have is like a working succinct blockchain we have like a graph QL API with this and you can easily install it with a brew and Mac OS and on Linux with app get really easy to get started and we have like a community I'll be talking about later it's using this stuff and so yeah let's talk now about the network I'm gonna live code something using like the graph QL API so let's see so we are in a state called ketchup right now so we were in bootstrap before it now we're in ketchup and soon we'll be synched hopefully ketchup is when it's if you have like a node right now you still have to download the full current state of like the ledger so you don't need any the history that's accounted for by the snark but to do consensus you still need to have like the cult the full current ledger that's what's happening right now with it is downloading that so that will be done soon so I'm pretty sure we can just get started coding stuff and we'll we will be good for that to be ready by the time we actually want to run something let me just pull something up here so that I know what I am doing and let's get started writing some code so I have another terminal over here where I'm going to make a new file called get balanced ojs and over here we'll check back in this in a second you can see like I have these tabs out at the bottom or make a new tab and what I'm going to do is I am going to run node over here so we can run to it on this side and we can read our code on this side and hopefully all works so let's console that log something just to like make sure that everything is kind of the same it is great okay let's get started so on like I mentioned we're going to use graph QL to like talk to a coder node and what we're going to do is we're going to get the most recent block and now we're going to do is get the balance of whoever created that so what's cool about graph QL is it gives you a lot more structure to work with than just like a basic REST API and to show you just a little bit of that on line before we just jump into the code you can see some of those features working um if I go to developers here and click graph QL API you can see some schema Doc's that shows like all the different data structures cuz in graph QL you're downloading actual like data structures that are structured instead of just like random strings and the first thing to do is get a block will get the most recent block and I also want to show you this is not public yet but we have also a really cool test suite for playing with graph QL it just comes out of the box of the graph QL and you can like just kind of click oh yeah like I kind of want like the first block and then like I wanted to see like the state hash of that block or something you can see what the query would look like and you can also over here see what it would look like to actually put that into code we're gonna be using react Apollo it's basically gonna look like this which is like pretty cool I realize it's way too small I'm gonna make this bigger but you can see basically like this is a cool tool for like playing with queries and like building things let's go back here let me see how big I have to make this for it to make sense maybe that way is this good for people okay great so let's begin so the first thing I have to do is we're using a node program so I have to like import a whole bunch of things so GQ l equals require graph UL - tag this is gonna be way of like writing graph 12 queries really succinctly and they're really clean right we're gonna use something called Apollo which is a library for you for building with graph QL oh and then we also are going to need this fetch thing which is just going to let our Apollo client know how to talk to the server because the server is going to work over HTTP and then we need to I have another thing so we can actually tell Apollo where to look for this HTTP link link link and then we also need an in-memory cache so that on Apollo has a place to cache things Apollo demands that we provide this and I Mary now let's do that they part we check to see if I made any typos I did not excellent or at least none that I crashed anything so now we need the address of the proto server so this just lives on each and local host on a you know a port by default lives on 3085 so I've scrapped QL so it just lives there which is nice and now we can actually make our client that'll be used to make the queries so there is a little bit of setup but after this you're in a really great world where you can just like use this magic query thing that has awesome syntax so we need to create that HTTP link we talked about a second ago and we need to tell it of those two things I mentioned earlier URI where to find the server and also the fetch command which is you know how it's actually going to get from this address and then we do that last thing I mentioned the in-memory cache welcome feel free to delusion we're just in the middle of live coding on Kota like a short demo of using graft well with a node right so I was just checking to see if I had made any typos when I was reading this and of course I did this is also like you know interactive sessions so if anyone can find the bug faster than me like please point it out and yes let's see cannot read property by no that's a fun one the heck is that about let's see ah I need you I was missing a new that would do it and everyone anyone knows bind is how JavaScript makes the word this work so there was clearly some this magic going on inside Apollo that uh didn't like that I didn't put the word new ok so let's do it let's get the most recent block it's time so first we need to run a query and the way that this works is we get to use that query tag thing I mentioned earlier for graph QL so I used GQ well and now that we put the back tech we're in like this magical query land where everything's gonna be really clean syntax so we wanted a query we want some blocks we want the data about those blocks in fact we want the first block so this is really cool in graph QL you can just like tell it I want the first of something if it's an array so that's really nice and we only care about the Creator like I said we're gonna try to get the balance of creative the block there's a bunch of other fields we could access but the only one we care about right now is the Creator we don't have to ask for more data if we don't need it which is nice and now we need to this is a promise so we need to do the promise syntax stuff so let's just get the results and we'll do something with that in a second and we also need to do something if there's an error which is dot catch so if there's an error we will console.log the air great so what do we want to do with their results what we want to do is we're just going to print out who that creator was and we're going to move on to the next step so let's do counsel a log clock producers I probably need to do this don't I public key is a public key and let's get the public key the public key equals res data locks nodes a zero dot Creator cool so if we run this things should work but let's sanity check that our node actually started up before this it did excellent okay so it says synced now because everything is running and we're connected to the network again this would take a very long time if you wanted to sync a full node on Bitcoin or etherium it only took a few minutes because Kota has a zero knowledge proof which backs up all the history you mean connect to the network as a full node if you if you want to access a theorem in a trustless way then you have to download a full node to your computer which is what in fear is really doing behind the scenes and this is something that's gonna be a few hundred gigabytes it's gonna take like a few weeks yes but query a local node that is like a full node connected to Kota that can sink quickly because of the zero knowledge proof support and now wearing another program that's going to talk to that local node someday um when you don't have to like download the full database anymore you'll just be able to do like you know my thon now and so Java import Koda or whatever and you just be like coated out start and that would do the whole full node connecting process for you we're not quite there yet but you can see like the parts are coming together to make that happen yes so okay so we synched we wrote some code now we get to see if the code is bug free and everything actually works so I'm gonna run the program and as expected it did not work because it's not concentrate its clients we couldn't we should have figured that okay great so now we try it and it worked okay great so we have this long public key awesome so this is the public key of whoever created the most recent block and we can move to the next step and I can show you some more graph QL magic when we have to actually get how much balance they have on the ledger so next step so we have this Creator person and what do we want to do we want to do a new query right we don't need a new query we want that query to get the balance of this person's account so how do we do this so we have to inject somehow into our query the public key of whoever created you know that the blocks from the Creator from the last time so let's do it so there's a thing called variables and we can just create a variable we can tell it that pub key now has the value of creator okay and we can refer to this later so then we do the query thing again again we type gql and that gives us like that magical tag syntax we saw earlier we imported above and then we could do a query so what will our query be well we want a wallet and in particular we want a wallet whose public key is pub key umm so again this is kind of a magic graph QL thing you would imagine that usually you would like you know drop this in a different way but there's these filters on graph key well just like how we could do like the games getting the first block like we did up there we can also just get just the wall that has this public key that's great and we just want the balance and they're smoking from the balance we have so we just want the total balance keep it simple that so now we have another result to process let's console.log it so lock producers um balance and it's residue Dawnstar total cool so now if we try this we'll see what happens again but we should see their balance if I hadn't made a typo what's the typo this is the type of okay great so now let's try it and this should work did not work because something terrible happens what happened ah we did not return we needed to return something somewhere I think right okay yeah yeah so um is that right where do we console log the block producer's balance or their public key i i i realize also like i order of these is just completely wrong like this the public key okay so what do we do we queried for their public key this should go up here right this is where we actually wanted to print that out okay and then we need to return the public key so it's available in the next block and then we this should all work now it's sync it's it was all wrong so sorry find it's what you said but I just like realize what it was and I was like like the whole thing is out of order I can just like try that we'll see if it works oh yeah okay cool works now yes so cool we know that their balance now is 1683 that was their public key and you can see like there's like some neat stuff you can do with graph QL it's like a little better than just having to you know query a REST API or something it makes real easy to use cool so what have we done so far we wrote some code we looked at coda we synchronized really quickly to the blockchain let me just tell you a little bit more about where we're at as like a community and like what we're building now and stuff so you know we're up to we're a team of like 27 at Oakland Labs building coda we have like weekly competitions to stake and snark and like build on the network we've got a hundred people so far that are contributing like technically that are like actually running nodes and stuff properly and like getting points and these weekly challenges um so if you're interested like you can join on our website it's just like you know coda protocol comm there's like a banner up here where you can like go here and we have like a leaderboard and there's like a really lively community on discord and these weekly challenges it could be fun so yeah I have a link to that in the next page a link to our discord um you can follow our progress on Twitter the website if you want to see more about graph goooo one of our community members about the block Explorer using this so like pretty easy to build big things you can check that out here and we also have an echo about we've written internally with um Oh camel and reason which is like a cool combination of like graph QL and like really nice functional syntax you want to check that out also yes so that's my talk on coda that's it thank you let me know if you any questions yeah there were a couple cool projects so on the as you can see if we're still pretty early in the testing phase so the project was like create a cool visualization on coda so one person one group made like a pure map that showed like all the peers over the world and like indicated reach pure like whether they were being nefarious or not on the network so you could see like I think there was someone in like Oregon or something when they did it that was like no that was like big and read on it because like they were like trying to do an attack or they you know they probably just like how they network misconfigured or something really and then there was another group that started making like a staking Explorer for Kota so this would be a way of seeing as a Staker like who is controlling the network like what would my impact be if I did this or that like um maybe moving towards like a calculator for like you know here's kind of my profitability is like in the network as well as like um just a general display of like statically which transactions are going on in the network and stuff so early on that but like some cool like initial stuff I think that it'll be a combination of like people writing things that are like for privacy which would be really exciting like hopefully people um building applications which can prove to the user like guarantees about how they're interacting with the users data and performing computations on behalf of the user which I think will be really exciting for like you know like we live in a world where things are pretty adversarial right now with like tech companies trying to get whatever they can it would be nice if there's actually guarantees about the program's you were using the other thing with snarks is just you know like kind of writing code that like everyone in the never doesn't have to rerun all the time once you write code with coda once we have that support you know it'll just kind of run once which is cool you won't have to everyone to rerun it all the time 