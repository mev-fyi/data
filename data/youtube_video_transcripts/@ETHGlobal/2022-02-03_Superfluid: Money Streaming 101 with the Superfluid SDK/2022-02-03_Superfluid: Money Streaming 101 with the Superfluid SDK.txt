all right so welcome to the workshop on money streaming 101 with superfluid sda so we have sam here who will be leading the workshop he'll take questions at the end towards the end of the session and sam i'll let you take the lead all right thank you so much guys it's great to be here and obviously it's it's always fun for me to talk to super fluid and and see lots of people joining these workshops so what we'll do today is i'll go through a quick presentation on what superfluid is kind of from a high level perspective how it works i'll go through a couple of very practical examples in our docs which use our sdk and then at the end we'll open up some time for questions so feel free to leave questions in the chat and we will get to as many of them as we possibly can at the end so let me pull up our presentation here and share my screen all right my assumption is you guys can see my screen uh feel free to jump in and let me know if you can't okay so what we're going to do is we're going to talk through what superfluid is at first and then we'll get into some of those practical examples like i said so superfluid is a protocol for digital native programmable cash flows so you can stream money without having to lock up capital and then do really interesting things with programmability around those cash flows um though the first thing that we like to kind of talk about every time we bring up super fluid in an environment like this is that one of the premises we have for what like blockchains are and why they're important is that you know we make the analogy to the internet being um something to information that blockchain is to value right and in the case of superfluid you know we we notice that services in real life flow in real time from provider to client if i'm working for you on a you know on an hourly basis i'm providing that service in real time and we believe that payments should work in the same way so this this kind of leads us into money streaming so continuous payments are frictionless open-ended connections between two accounts so if i want to send you money for providing services so in the case of let's say i wanted i wanted to pay you in a stream for a subscription or to be an employee in my company instead of having to pay you every two weeks in these lump sum discrete transactions we allow you to pay service we like we allow you to pay for services in real time on a second by second basis so what happens is we take that lump sum amount divide it up amongst the number of seconds um between now and the like let's say the end of the month and you receive a little bit on a second by second basis right so the money is flowing in real time and we think that this you know allows there to be this interesting direct link between the time you're providing the service and the money you're receiving in exchange um and the cool thing about this is that it's all on chain and we can use these on-chain agreements to do other really interesting things right there's there's no unpayment risk right friend who's our ceo who does some of these presentations sometimes often talks about when he did consulting in previous roles he'd go three four five months without getting paid sometimes with superfluid when you put the agreement on chain you have way less on payment risk right so in terms of the overall protocol itself like i said these are unchained open-ended agreements um and the way you know kind of behind the scenes that we're achieving this is we're calculating the balance of each user every single second um so from a high-level point of view i'll get i'll get into the architecture a bit more have a few interesting aspects of the protocol one of them is super tokens the other is super agreements and then the the thing that kind of holds it all together is like the brain of the protocol is the superfluid host contract which does a lot of other interesting things for us again i mentioned a bit earlier that these aren't these aren't only just on-chain agreements for money streaming they're also programmable so you can do things like create super apps which you can send money into and then upon the receipt upon receiving that money you can then redirect these funds into interesting places and do really cool things with them um so we have lots of super app examples in our docs and in our repo you're welcome to take a look at those and understand how to use them but today i'll briefly go through one aspect of super apps and then just get into the sdk stuff so on this hackathon right um we have four thousand dollars in bounties um two thousand for the best overall project both on superfluid 1000 for the best financial innovation using superfluid 1000 for the most futuristic project which when we put that that prize out we usually get something very interesting so i'm excited to see what's submitted for that one and just to be eligible you have to use superfluid in some way right you have to either create a super app or just use our sdk and just interact with our code base in some fashion so getting into interacting with the protocol um we'll talk through some high-level architecture bits and then we'll get into the sdk so i mentioned that there are three things on the back end that are important to understand when working with superfluid one of them is the superfluid host contract which acts as the brain it's its interface is isuperfluid.soul if you're interested you can check it out in our repo the second thing are agreements so we have two main agreements right now one of them is the constant flow agreement and the other is the instant distribution agreement i won't dive too deeply into the instant distribution agreement today but it's it's worth checking out because it allows you to distribute funds on a one-off basis to lots of users without having to pay an incremental gas costs for each new user you're going to send funds to but today we're going to specifically discuss the constant flow agreement because that's what facilitates all of the money streaming that you're probably familiar with and finally the third kind of type of contract you'll be interacting with are super token contracts so things like die x which is super token die ethex which is a super token version of eth um native super tokens as well we might talk through a bit but that's the third thing to keep in mind right super token contracts you can see all of this stuff visually if you go to the super fluid dashboard you can go there at app.superfluid.finance and play around with your own money streams using no code at all if you'd like we'll also use it to walk through some of the sdk things in in just a second if you're looking for more information like on the developer side you can also use the superfluid developer console and you can get much more in-depth like developer information here right you can write custom subgraph queries you can see a lot of the stream data and you can you can even save like addresses in an address book um and manage them that way as well so again we have a couple developer resources you're welcome to check out here the first is app.superfluid.finance for the no code version and then you can check out the superfluid console at uh i believe it's console that's superfluid.finance um here and if i'm wrong there either fran or yahoo is on the call can clarify in the chat okay so getting deeper lower level right we started very high level we're progressively getting deeper and deeper one thing to keep in mind is that in order to use superfluid you need to have some balance of super tokens in your wallet so super tokens are basically an extension onto the erc777 standard we have we have more much more functionality than your c777s but one thing to keep in mind there is that we inherit a lot of the basic erc20 stuff right so sending tokens via transfer all of these things you can do them all with super tokens and one big key cornerstone of d5 more broadly is interoperability right so we want to make sure that existing tokens that have been just deployed as erc20s can also be used in superfluid so we've deployed a kind of wrapper contract which will allow you to wrap existing erc20 assets as super tokens using what we call the upgrade function and you can then unwrap them using a downgrade function so you can very simply call upgrade which will then mint you super tokens in a one-to-one corresponds with how many how many tokens you like to wrap so if you call upgrade with five die you can get five super token dimented to you in return and then if you want to ever just redeem that super token die for the underlying asset you can very easily hit downgrade burn those super tokens and get your underlying erc20s back out of that contract when it comes to interacting with the agreements themselves right to create a money stream this is kind of the the flow that's happening in solidity so you need to like at the most bare bones level in solidity you need to pass arguments to a function on the superfluid.soul contract to open a flow and what you'd pass into that call agreement function is the address of the agreement you're going to interact with and then also the an encoded transaction object which specifies what you want to do with your money stream for example right so if you wanted to pass in some kind of create flow operation here you could do that and then the protocol will open up your stream from you into whoever you defined the receiver to be right so again very low level we're not going to need to go that low level in our example but i just wanted to mention it and then to kind of round out some of the lower level things here the final thing to mention is super apps one more time i mentioned that the cool thing about super apps is programmability the thing that enables a lot of the programmability within super apps are these things called super app callbacks again i will refer you to our docs look at look look for the super apps section of our docs you get much more information on this but the key thing to note is that if i send funds into a super app there are effectively listeners that you can define on the super app which can do things upon receiving those funds and you can do a lot of very interesting and uh um you know like like just overall cool things with them so it's worth checking out okay so that's an overview of the protocol some of the lower level bits let's go into our docs and walk through a couple of examples using our sdk which will allow you to open up money streams and like just a few lines of code so we will shut down this presentation for now and uh head over to our docs alrighty i'll take a brief look at the chat here looks like we got some questions coming in which is great y'all thank you for answering questions it's amazing we'll come back to those in just a bit but here i am in our docs let me zoom in because that's one of the most common requests i get here when showing things like this is to zoom in so if you if you go to our docs you can reach them at docs.superfluid.finance we have this interactive tutorial section which is really helpful for getting started with the protocol even if you're just a beginner or coming from a javascript or even typescript background if you're a little more advanced on the front end we have a few sections the first of which is going to help you initialize the sdk right so just basic set of things depending on what environment you're looking to use whether you want to use something in a node module or something on the front end we have information for you here that will help you set this up but for the sake of brevity i'll just go into this money streaming section here so we walk through that kind of advanced workflow in solidity of how you'd open a stream that way this makes it much simpler right so we have this code sandbox here that i'll open up let me move zoom around just a bit here so we have this create createflow.js component which is rendered here over to the side what i have here is an extremely simple react app with an unlocked address that has a lot of tests and fake super tokens set is the signer and then i have the framework initialize and i'm i'm running operations here so let's walk through this kind of step by step right if i want to create a very simple flow using our sdk the first thing i need to do is well i want i need to download the sdk from npm right you can find it on npm just by searching super fluid finance and sdk core will pop up you're looking for sdk core which you can see right here let me zoom in a bit more all right close this as well i'm using some react bootstrap things just for formatting and you'll also need ethers which is going to be important so i have a function up here which is going to execute and create create our flow for us and this is happening and basically because i'm using an unlocked account we're doing this in kind of the way you use this on kind of like a back end or node module but you could use a meta mask or wallet provider instead if you want to so in this example what i'm doing is i am initializing the framework here using this framework.create pattern i'm defining the network name and then i'm passing in the provider which is just you know a provider that i've created with ether is using an rpc url i got from alchemy and then i initialized the signer here so we have the signer and i initialize the sounder by calling sf.createsigner in this case i am passing in a private key and then also the provider quick disclaimer don't do this in your own applications where you uh just paste the private key in here at the very least you know have it as an environment variable obviously so you don't push it to github accidentally so that's that's worth mentioning here i'm defining the address of the die x token which we'll be using with diax is just super token dot and then here i have a little try catch pattern that's going to allow me to create a flow so here what we're doing is we're calling we're creating this this uh createflow operation variable and calling sf.cfav1.createflow we're passing in the flowrate which is just the amount of tokens per second i want to send we're passing in the address of the recipient and we're passing in the the diax token address and then to actually send this transaction and broadcast it to the network you can call createflowoperation.exec and pass in the signer that we defined up here so we don't have it we don't actually have to put the sender here you might see some examples where there is a sender defined with a sender address that's not 100 necessary because the the signer is actually going to be like the sender is going to be implicit in this signer here right we know because we already have the private key who's the message.sender on this call and because we know that the protocol knows that you're opening up the stream from that address to the recipient here so let's put this together so if i enter an ethereum if i enter in an ethereum address let me grab one here from my metamask all right copy that and if i enter in a flow rate in way per second we can see here actually we'll calculate the amount per month for you based on what you're sending per second in this case i'm going to send 25 dive per month if i send this much per second i'll open up the console and i'll click to create the stream all right so our stream was created for this example i also console log some other things up here but we can go in and view our stream in the superfluid dashboard so if i do that we can see here i have the dashboard and we can see right here if i zoom in a bit more a flow is just open to this address so we can see this here this was just created we have some information about the stream which is awesome great so now what i can do is i can also go back and i can update this flow and delete it so i can actually just do this directly from the docs if i want to so in this case let's call update flow directly here and we'll pass in a new flow rate so let's change this up a little bit you got to enter a number there if you try not to enter a number you'll get an error like me all right let's change this up now we're gonna we're gonna lower the flow rate so that we're sending only five dollars per month okay i'm gonna click to update all right fantastic our stream was updated here if i open up this sandbox now we'll take a look at how things differ with the update flow and basically it looks exactly the same right except all you have to do is you have to make sure that this flow already exists and that the flow rate you pass in here is different right if you don't do that you'll receive an error and if i go back into the superfluid dashboard zoom gets out of my way you'll see here that this was now changed if i refresh we'll come back to that in just a second we'll go back and we'll see the flow has changed then we'll delete it from here but to delete a flow again the pattern is the same where i'm creating this delete flow operation first and then i'm broadcasting it to the network except in the case of deleting a flow i will pass in the sender address and i'll pass in the recipient and then just a super token i don't need a flow rate if i'm deleting because there's no flow rate needed right so if we go back here we can see that our flow rate was changed it's now five dollars per month so we did that effectively so finally in this section what i will do is delete our stream so let me paste our in our address all right so our stream was deleted there we go okay so now what you just saw there is how to create update and delete streams right that that's that's enough to build out simple subscription applications or interact with with superfluid directly inside of your application um again if you like to do this in in a way with that includes maybe like a metamask wallet we have examples of how to initialize that in our mpm page here in the readme um and if you have any specific questions on that feel free to reach out to me directly i can give you example code that will help you get started with that too but what i'd encourage you to do if you're curious about how this works is to come to our docs um play around with this also play around with the using super token section if you'd like play around with batching transactions which is also a super cool feature we didn't have time to discuss and then if you'd like to you can also check out the instant distribution section which will make use of that instant distribution agreement we didn't have time to talk to um and yeah there's plenty here for you guys to dive into i'm just you know you we're at a kind of like a hard time limit here so i don't have time to go through it all so i'll pause there we can go through some questions and yeah take it from there i hope that was helpful alrighty so it looks like we have some questions okay is there any demo about how to see stats on your stream like you have in your dash how can i show them moving in my app great question um so we we have some examples let me reshare just so i have i'm not just clicking around so you guys can't see it um we have this getting data section which will make it easy to use the sdk to get to run queries basically with a superfluid subgraph and then also just use the agreements to get information as well so you can run something like sf.cfav1.gitflow to get information about a particular user's streams but we do have like i know you mentioned it sounds like you're interested in this constantly moving section we have an example inside of our repo if you look inside of the let's go to our repo here if you look inside of this example in our example section so if you go to the protocol model repo examples sdk redux react typescript we have an example here that uses our little more advanced sdk i didn't go through today where you can create a flowing balance so i'm just going to paste this in here because this might be helpful for you there you go yeah thank you yeah absolutely notice you're using coven does all of the behavior your demo you demoed also exists on mumbai yep it's completely chain agnostic you just need to change the rpc url you're using um if you want to use the sdk in the same exact way i did so for example inside of config.js here you'll see in the sandbox i have a specific link from alchemy that is you know specific to coven you could change this to a mumbai rpc url if you want and then just change the name to mumbai here when you initialize the framework so yep chain agnostic completely okay with this api is it possible to connect a smart contract to an nft that would be sold multiple times and iteratively built upon but could open up a royalty stream that pays each contributor uh yes i would say you probably would need to use what we call a super app for this let me send you an example as well that might be really helpful actually i'll go to our docs for this one inside of our docs go to this super app remix example and you'll probably get some inspiration here what what this does is it i mean you can see here on the screen it will take in incoming streams run logic and then send outgoing streams you could probably have some kind of accounting inside the contract that checks how often it's been maybe i think you can do this i think you can check how often it's been transferred and enable the app to send streams to multiple different users inside of these callbacks here so again i would check out that remix example i think that might help all right any other questions that i didn't have time to get to here uh looks like yao was able to answer a few can an address only open one stream to another address yes so if you're like let's say i want to open up an address to or open up a stream to yao i can't open up multiple streams to you out with the same token right i would need to update the flow rate to do that instead obviously there are certain situations where you might want to for like administrative purposes have multiple different flows going from one account to another um maybe within an app or something like that what i would suggest doing is having some kind of architecture that it that just has accounting that calculates how much money in total should be sent from one address to another um and i think that can that can solve your problem if you have any specific use cases you're trying to to send multiple flows from one user to another four let me know and i can send you some examples and because i thought about this a few times as well i should be able to help what would the data field distinguish the separation for such hmm i am not 100 sure what you mean by that but there is a field that you probably can see and we're kind of running long time so this might have to be our last question but there is a field here that i commented out called user data that i didn't have time to talk to user data allows you to pass in any arbitrary data that can be used within a super app callback right so let's say i want to pass in a user data field to an incoming stream that i'm sending to a super app you can decode whatever that is and have access to that in the super app so there's a really good example we have in our docs as well inside of this section i'll paste this in here about an nft billboard where let me scroll all the way down and let me copy this link where here what you do is you create a stream into a billboard entity and you pass in a message as user data and whatever the most recent message is passed in here will be displayed on the nft billboard as a message so you're encoding a string and that string is then visible on the nft itself it's honestly pretty cool i think it unlocks a lot of use cases and it's pretty underutilized so if you have an interesting use case with user data i would love to see it i'll paste this in here all right i'm going to take one more question um one more question before we have to wrap do you have a demo using metamask login to accept incoming subscription streams actually yes i just worked on one specifically this morning that's a code sandbox that i can that i can send you i tell you what if you louise save your padilla if you reach out to me on discord sam f superfluid i will send you that directly because i'm also going to put that in our docs likely later today or tomorrow as well so you guys have that there but hit me up on discord and i'll send you that directly it's just a little bit of a work in progress that's all okay i'll pause there um it was a great workshop and uh we're just a bit overtime so we can follow up over the discord channel and hopefully to hopefully you'll see everybody at the opening ceremony that's coming up and yeah thanks again yeah i'm excited thanks so much for having me i appreciate it thank you all for joining this is a lot of fun 