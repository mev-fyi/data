super-quick yeah it goes directly to YouTube which is perfect because we don't have to like save it to our computer then upload it all the servers are just in it that's probably in the same server even the same data center just stays there but yeah it's for the reck'n dey's up yep awesome alright again sorry for the delay anybody who's watching this live on YouTube and those in the soon call but we'll get started welcome everybody to the sacrifice workshop today we have Alan and David they're with the protocol labs team they work on some specific things within that part of the ecosystem middle they'll talk about that before I pass or just after I pass it over to them but before that happens let's see if there's any logistics for hack FS today is Wednesday midweek in in week 2 everybody should have had their check-ins their first check-ins already you've been putting cohort channels in the slack if you aren't familiar with what that is or you were surprised to find yet another channel that's the way we keep track of teams and projects that they're working on so we have a way to track chunks of hackers and their teams and the progress that people have been making throughout the week so that's what cohorts are for if you haven't already go to your hacker dashboard and that's where you'll actually be inputting your weekly check-ins and then that ends up in our back-end so make sure you're putting in both places both your core channel and your hacker dashboard we have a couple more events there's a I think two office hours tomorrow with some of the sponsor teams I would check that out in the hackathon schedule channel and you probably all have received several calendar invites so if you haven't check your spam maybe it's going there hopefully not I think that's about it all the logistics stuff I had to cover for a cough s it's been great this this week is a little bit more relaxed than week zero and and week one so I know Andrew and I are happy but we're glad to be continuing to provide workshops and running these sessions for everybody and we can turn it over to Alan and David do you want to give a insure to yourself and what you're going to be talking about of course thank you so much hi everyone really excited to be here if you are looking for some redness you are in the right place welcome to the the Ren workshop where you will learn how to harness the power of true advisable retinas for a great good and fun with friends so my name is the V or David whatever you prefer I'm a research engineer protocol labs working on the research group resilient networks Lab Rats up for short I've been with Pro collapse for five years now and when I joined I joined to work specifically on the ipfs project and the lead p2p project that you might have heard about or maybe even used like a 12 weeks ago I joined this new project the dierent project to take it from a research experiment to a production service and you will learn more about it Alan tended to give us a quick introduction about yourself as oh the thing I've been working for protocol apps around I guess three years now before that I was I had my own business with my friend and we were building crazy things for entrepreneurs that have little amounts of money but also organizing like events and meetups and things in London UK IOT stuff and other application things began when I joined Pro collapse I was mainly in like a GUI team and then I kind of transitioned to doing JSI PFS and leading that for a while and now and now I'm just guns for hire on whatever project and now I'm working on D rounders to be safe that's me all right thank you so yeah like deer an is a distributed random this weekend that offers you verifiable and predictable and and biased random numbers as the service so it's kind of like unique in its kind but like before I could really go into like the details of DRM like stuck with a quick motivation and like understand why randomness is important and so realness as a tunnel of use cases in our kind of like all kinds of applications that we use in all kinds of like businesses that we rely on things from lotteries election event audits control trials even in the protocols that we use from like the ability to choose random peers for our gossiping protocols the random the ability to have random numbers that can get used for cryptographic protocols and much more however despite this being such a useful thing in a use thing the reality is that historically having pure and secure randomness is incredibly hard and the fact that we have used less than secure and earnest in the past has led to many attacks many scams that like were able to be possible just because the randomness was not secure that i collette to either stealing money or even just like taking services down additionally well we are in a hack efest the curiam ipfs and Falcone hackathon you might know that I could reminisce is really critical for blockchains and so all kinds of cryptographic protocols used in block chains from fake replication with routability verifiable computation proof of stake require randomness and despite it being such a requirement there there still isn't a one-size-fits-all solution for a readiness that is also unviable and available most protocols most proof of say protocols attempt to solve it but a big cost by adding our complexity and brittleness to the protocol and often the way that it gets done it gets so integrated with a lottery use case on the blockchain itself that it's not really usable by the applications that are riding on top most of the solutions that exist today by took years to produce but they still are they still have yet to stand the test of time so they haven't been battle tested enough and in like the randomness that gets used in this protocol is for the random leader election which is a hard problem you might be familiar with some solutions that get using different block chains from proof-of-work which is probably the most widely used one but as we know it's extremely expensive computationally and financially and also the economies of scale typically forced like some degree of centralization on the network then there's Unchained randomness that gets often used for proof of State protocols however from from what we can gather like most of the variations out there are actually still viable by agents such as miners so they are not 100% sick here one thing that is very promising is verified via wave functions and so a verified the length function is just a function that executes for a period of time in that you are able to prove that they function executed for that period of time not more not less and that is going to be very useful because we can combine that with a zero like a zk stack a circuit in which we can have something that is completely a blackbox opaque that generates randomness at every epoch that everyone can verify however the theory is being developed right now the research has been developed there is nothing there is nothing that exists in practice despite a lot of R&D and we believe like it's coming but it's still possibly like two to five years away if not more and the reason why this bike because it's probably so hard and because existing solutions are either brittle or expensive or not ready yet there is a reason why protocols such as Jim two and five point and moving to separate chains to get their randomness sources and so in addition to that we actually believe per collapse in the DRM team that we as as Internet users as Internet builders we need a relevant service in the same way that we have a name service like DNS some way that we have a time service I can PKI and certificate transparency we also need to offer a core service of internet that offers a secure run on the source and so this is where we actually entered ear end because DRN is an advisable randomized randomness beacon that is tested audited and ready to use so all this DLN work the simplified version there's a lot of like dark magic happening underneath the hood but like a simplified version is a different network is composed by two or more gear end nodes and ideally these nodes are independent and then the network itself is assembled in two parts or phases there is the setup phase where there is a distributed key generation ceremony this is where before they've been generating any randomness nodes get together and they agree on a threshold parameter so the threshold parameter is the number of nodes that need to be online in order to generate randomness so imagine like the network of 10 if you set up a threshold 7 then as long as seven nodes are up you can generate random s and then you also agree on the period like the airport so if you are going to generate the randomness valid every 30 seconds if every 35 every minute until once they agree on these values they generate their own key material and they create their signature so that they can verify other node signatures and complete the distributed key generation phase then it goes into the second phase and this is the final phase where randomness can be generated forever and so in a in a relevance generated regeneration phase we basically add every epoch every node will generate a partial signature using their key material and once there is a threshold of nodes that collects enough partial signatures from from other nodes they can smash them together and create a seco signature that then gets broadcasted to the world and it's where we that single signature that nodes will verify that it was indeed generated by the partners from the network so it's verifiable and verify and will get the regulars by ashing the signature so the randomness will be the ash of this signature and this is just a typical BLS signature that you might have heard about if you want to understand like the guts and the math like that happen inside the ER and the dark magic there's a very interesting talk on protocol ABS research websites you also have the link here down below where nickel as the outer of the end actually goes into the detail of all these works so if you are into that definitely check it out with this construction what we get is a network that is the centralized we're like the nodes are operated by different entities and there is no central point of failure because one node can fail as long as we have a threshold of nodes then African continue to operate it's unpredictable because the randomness is like multiple partial signatures coalesce together so only when you have always partial signatures you actually can see the value so no nodes can actually predict what is in X value because it will need to code with the other nodes and it's advisable so even if there is a node that is malicious and cannot attack the other notes to get their key material there is no way that the randomness would change what they can could do in that scenario would be just like to predict the future but in that case there is a way to do a reshoring session where the key material gets rotated and then it's verifiable like clients can verify that the reminisce came from exactly the network way that trusts that was generative at the precise moment that they wanted and they therefore can use it for their application if you are interested on understanding all these works underneath and what is the threat model we actually we have all these information available right now we know are better websites where you can understand what is the threat model and why we are able to make the claim that that these properties are there well this is the runs the protocol and the project but then there is deal and the network and you might have heard about the leak of entropy so the League of entropy is the first incarnation of a dealer network that is operate by these multiple partners and this the week of entropy and an amazing launch with companies like called fair could ask a security c40 pfl university chile and for collabs joining to ever network that can then generate reminisce that could be used by other projects and apparently my screenshot is still loading thanks google slides but but no worries you'll see it on Alan's part I was just like showing fresher than this there the next point is really the network keeps growing so the network becomes more and more secure as more partners join and so we went from the previous partners I already talked about to eco DCL chain safe travel emerald onion it truly MPSP cello and many more are joining as as we speak and additionally now that this network is moving from a research experiment to a production service we actually are getting the first production user which you might have heard about it it's called foul coin so foul coin is going to be the first production user of the deer and protocol and the League of entropy service and in final coin decided to do that so that Akira's is cure and then the bias will run on a source for the random redirection problem then up there that exists or the randomly there election challenge that exists inside the file coin protocol and so we have been getting the D run project ready for this big user and for this big launch and so we've been working to get the version 1.0 ready and and i'm really happy to share with you all about it has been launched this month actually like last week so when you solve it on your using the latest version version 1 of 0 and like what got included with version 1.0 is that we have real the network from like a single layer to a 3 layer so now we have like three layers where the first one is just like the D run node connect me to all the different notes and they are protected like there is no one from outside internet that can connect to them and this is where the runner mask once the randomness is generated it gets pushed to the distribution layer and distribution layer are multiple Syrians like welfare CDN called France and even I qui pue to Pierre pub/sub relays so that we have multiple transports to get the randomness to clients depending on their geographic location and network conditions and so on and additionally there is a client network which in addition to just acting as clients pulling the randomness from the network they can also help each other by being pub/sub relays and so like a client can also share the reminisce broadcaster reminisce to other notes we deployed a network observatory so this is a way for us to measure the quality of service that Duran is offering to the network and we have multiple probes all over the world that are always taking samples and measuring what is the latency from Random randomness being generated to run unless being received and one thing that we are really happy about is that we managed to get a 400 millisecond delivery boost to the nodes in China thanks to the way p2p pub/sub realized so we managed to get a 400 millisecond speed boosts in comparison to the popular CD ends we also have network monitoring so we are now monitoring all the nodes and I drove the startup it's a nose page that you can check to see our live the network is there is a new documentation website right now it's available on parathion top valve we are sharing like we this group with the RFS group we have involved into the world yet so please just know that when when you tweet about it and what you can expect is that there will be a League of entropy main net upgrade coming really soon and so these upgrades to be very clear is that there has been a leak of entropy - running for more than a year now we launched a league of entropy test left to test all these latest features and we are going to do the actual launch of the upgrade very very soon nevertheless don't despair you can actually use the League of entropy test at just fine it's literally a replica of the main net anyway so you can use the test net to build your applications while you are in the hack a test Agathon so now with all this let's get into the middle of this workshop which is actually the fun demos and hands-on material that Alan is going to Orchestra thank you and I can see questions so far go ahead Alan Thank You Debbie okay so are you ready okay you ready I'm sure okay now you know a little bit about what dierent is we're going to use the go and j/s clients to get hold of some of that box fresh random goodness from the divan nodes that eventually run and so today what we're going to do is mostly get randomness from the json HTTP api but we're also gonna try and get a live feed of randomness using lib he pops up if we have time so this is a workshop so you can try and code along with me there's a lot to cover so I'll go in reasonably fast but don't worry if you get lost or can't follow him quick enough it's fine to just watch and take it in I will publish or give the walkthrough the recipe that I'm using and for all the work that we're doing at the end of the workshop so you are welcome to just watch that's fine too alright so let's get on with it let's let's get some information about the chain of randomness and we use the go client for this and so just to explain about the chain of randomness dieren produces this chain of randomness and each new beacon points back to the previous beacon and so when I talk about getting hold of the chain information the kind of information that's useful to us is the the period the period between beacons so every so often becomes a randomness beacons are generated and and admitted and so knowing the time between them is useful also the Genesis time the time that the chain actually started and with the period and the Genesis we can then say well this the next randomness Deacon is expected to be generated at this point in time so that's useful too and then the public key is interesting chain information because that actually allowed us to to verify that the randomness beacons that we'd get hold of valid and and good alright let's let's get going I'm going to share my screen now so good you should see the diamond website here and so this is like Pete said it's at Peter do you rent love at the moment it will be available at the end of soon if you head on over to the developer section you will see there are documents documentation for the to client libraries that we're going to be using today and also for the there's just HTTP API it's super it's super simple there's only three endpoints so the documentation for that as well but we're going to use the client libraries today to get hold of that randomness which is fun so let's start let's get coding first of all what I'm going to do is make a new directory for this I'm for this you'll need go installed if you don't have it already if you if you don't have it already then probably now is not the time to go and install it but maybe wait till the j/s part and then you can do that but if you do have go install it then make a new directory in York and you'll go you'll go path - if you're anything like me it's up a default path go folder in my home directory so I'm just going to create a new directory and I'm just gonna open up in my favorite editor so here it is cool and first thing we need to do is I'm gonna move this over here I'm gonna make this all a little bit bigger see you all can see crazy now um go mod in it let's just create a new new game or two and then after we've done that what we're gonna need to do is get the dear and dependency using go get okay / do you do you read all right so this is this is actually the whole of deer and but it has the client as well what we need to do next is create a main code file here and once we've done that we'll a package made at the top because that's what you need we're gonna import import this dear and dependency that we just installed so that's what I just types here but we're actually going to import the client which is a client and and that is that is that the main client we're mostly going to be using the HTTP client there's multiple different clients it works over to your PC and as I said earlier lit p2p we're going to use HTTP mostly today the these comments don't shouldn't be that all right so next up if you're following along we need we're gonna have a constant we're gonna have our chained hash I've got my handy notes of the chained hash all right so chained hash let me explain about chained hash the chained hash uniquely identifies the randomness chain so it's the hash of the public key the Genesis time and the period that I was talking about and what it does is we pass it to the client and the client will actually ask for the chain info and then you use that hash or hash that chain so and compare against the hash that we give it and that allows the client to verify that it's talking to the correct round in this chain that we expect to be talking to so it's really useful and that the information that it gets it it will also get the public key and it can use that to verify the beacons that emitted from deer and next up we need some URLs with HTTP endpoints that with our HTTP client is going to contacts today we're going to use just three URLs of League events so protocol outs of part of League of entropy and we have a test net running at the moment with free endpoints in various different regions so we need a just gonna have URLs and that's a slice of string for now and I have those URLs written here here we go so these are the URLs that HTTP client is going to connect to just three of them there's one in the US there's one in the EU cool right once we've got these URLs all right that's let's start actually let's try and instantiate a client so we need main main function and what the first one we're going to do is convert that chain hash that we've got as a string into a slice of bytes it's the chain hash is actually hex encoded so we just need to use a hex key code decode string we're going to decode that chain hash there we go so my editor would have imported encoding / hex for me which is super useful tico string and then we're going to instantiate a client for this we're going to use client wrap it takes an array of clients and then a bunch of options we're going to use the HTTP for URLs helper function and that takes an array of URLs and creates a number of clients as many clients as the URLs you passed it so I'm going to pass it that you those URLs can parse it that chain hash and then I'm also going to trying to use with we've chainage okay now let me explain this just a little bit more um so what client up wrap does is it creates a single diamond client from a set of concrete transport specific clients and what it does is it adds failover validation and caching and so this array of slice of clients that we pass it in here can be of the same type like in this instance we've got multiple HTTP clients but there could be different types of clients like there could be G RPC times that it could be pub sub client the p2p pub sub clients and the idea being that if one doesn't respond then it will fail over to a different one but also it periodically speedtest these clients so it so it will ask the fastest client each time for the information so if I'm if I'm actually my server that might where we run running this is kind of in the US and it's likely to be using this end point most of time but it will test these other ones too periodically to ensure that thing I'm not faster so so that's what client wrap does it it's it's it's that's what it's doing um we've chained hash so this is this is passing in that chain edge the media we had up there we can if we want to do we could use in securely securely I don't recommend you use this unless you're in development because um it disables this check that the client has to ensure that it's talking to the correct randomness change so we're not going to do that to that we need a match the idea is like you either pass the chain hash or all of the chain information and in under normal circumstances and it's easier to have the chain nationa is to have a kind of file or some sort of place to store all of that chain information all right so once we've got a client we've instantiated it then we can just use the info endpoint to grab hold of the infant the chain information we're just gonna use the background context we're going to assign that to info ignored errors in all this and hope that everything works first time so hopefully they're okay for me and then we're just going to print out a bunch of all of this chain information that's that's them that's interesting so we're gonna print out the public key public we're going to print out needs a few of these I'm gonna print out the Genesis time the period and the chained hash so this time as I said the Genesis time is the time at which the chain actually started so and that is so that's expressed in seconds and so what I'm gonna do is convert this into a time so that when it gets printed out it's gonna print out nicely for us period as I said is the is the time between beacons this comes back as a duration so we can just print this out and it will come out nicely nice human readable and then chain hash which is going to we're gonna print this out because we should be able to compare it with the chain actually got up here and they should be the same so chain hash when it comes back to us is a it's just a slice of bytes and we're just going to encode it encode it to a string in hex did you and without hash okay so if I if I save that stuff then it will have imported context format and time got rid of all of the the red stuff this is why is it not I might go more yes yes we know okay and so in theory I should just be able to run this now okay great so we can see here that we've got the public key we've got the Genesis time this for there's 25th of May yes change with me and the period for the test net is every 25 seconds so every 20 25 seconds we'll get a new beacon generated the chained hash 8 for B 2 2 it will be 2 2 is exactly what we expected so everything is working correctly all right that's fun but that's no there's no randomness here this is just information let's get some randomness what we can do is use client dot get that takes a context like like all of the functions that in the client and we're going to what we're going to do the second program etre is the round of enough rounds start at 1 if you specify zero then you'll get the latest round so you don't need to know what the latest round is you can just say get me the latest one and it will give you that so I'm going to assign that result to a variable I mean or the error again and then we're gonna print out that randomness we're going to print out the round number that is latest don't round function and we're going to print out the actual randomness that we received as well and we're going to encode this is again just a slice of bytes so we're just gonna use hex top and coat and Kirk string again to make this reasonably readable okay so that's how you get random so here you get the latest random value from from Deer and if I run this yeah so the latest round we're on round 175,000 581 and the round this is is is all of this all of these bits and bytes they're cool all right so how do I get a specific round well it's kind of obvious we can get an old round by just specifying the round number in the call to get so if I get one two three four five which we have done already and we'll print that one out save that run it I should now see the latest round has incremented by a couple it was more than 25 seconds since I last to run this and the old round 1 2 3 4 5 is this value of random hooray all right it works that's how you can see randomness now that's kind of interesting but what's even more interesting is getting a live feed of randomness as it occurs so let's do that all right so um we can use watch because the client has a watch function and we can use that in a four range loop so I can I can use four round equals range C dot watch that's cool context of background yeah so every time a new randomness value was generated it will be it will be assigned to that variable there and I'm gonna print it out just like I did for these other ones around you around and this is I cook this round here brand cool so then we've got and then what I'm gonna do is I'm just gonna put when we're done okay so now I should be able to run this and we should get sure what that is but here we go a new round so 586 is this round 5x7 just got generated and so that when I watch I should get the current round straightaway and then when the next round is emitted then I should get that round and so in 25 seconds because we know the period between rounds is 25 seconds I should get a new round appearing here you should note that watch is kind of best effort there's the possibility that it will the channel that it returns will close and and so if you really care about continuing to watch you should reopen that watch if it happens to close but in an ideal round world that will just continue to to watch for new randomness and an output set as it happens so here we go we've got five five eight seven not sure what these are but I'm going to ignore them for now over a five eight nine that's good and so if you'll notice we never get to done because watch never never closes we know we've not finished it so typically in gold you'll use context to cancel things and so we can cancel I'll watch when we don't want to do it anymore by using a that's just use a timeout context with timeout so what we do is after say 30 seconds we'll stop watching context of background we use the fat as the parent and then we can use time time dot second times yes thirty seconds I said thirty seconds in my okay so and then instead of using the background context we use this new context that we've got and then so basically we should see after 30 seconds we should see done printed and so we get the current round the latest round we should see another round because we've got 30 seconds to work with we might if if we were really quick we might not even quick enough that we might see another round we might not even what that's how you cancel that watch if you just bear with me a few moments you should see this cancel and then okay done will be printed all right cool that's the go client fun times with the JavaScript client okay so this is this is gonna be fun possibly more fun for this you'd need you need an index.html file and in that fire oh I just before start we have Docs for a J's client as well and they are like I said in a developer section under J s it's written using es modules so it's all fun times new stuff that works in Dino and node and and on the web so we're going to just use a HTML file for the purposes of this its HTML okay so I just tells it that it's a HTML file and we need a script tag with type equal to module and then from there we need to import export file import client and HTTP client just like we did and go and that comes from or any-any CDN you want really of course it's on gesture liver so good a place as any I guess forgetting it so this works this is cool and we need that chain hash again so I'm just gonna steal it from over here some of the syntax is pleasingly similar did you chain a screen you also need the URL subscribe the URLs put them in here that's that's a constant Wow in JavaScript this is just an array yeah we go around so goes your ass got back chain hash and then and then what we need we need a main function so I'm gonna make em and then doesn't matter these I'm just gonna call it there but in this in this in this main function we're going to instantiate the client just like we did in go and we use a wait client dot we're gonna use rap again so this is the you'll notice that the API is very similar with capitals in different places we've capital letters then go on at the start of the words and so HTTP HTTP proof for URLs ID URLs we can use that train hash and we're going to pass in that chain managed as well to the client okay okay so I'm not going to get the info because it's a similar thing you can call info on the client um so let's just get the latest one again it is two equals a weight on C dot get and we don't need to pass any parameters you can pass it zero here but it's JavaScript so it doesn't matter it's filthy so it'll just get the latest if you don't pass it at a particular round number we're gonna login Alps round my typing is getting worse it gets fun isn't it okay latest Thor around look at that latest round and we're gonna log out the randomness as well they get and in theory I should be able to just run this thing go open-open index there we go okay I should see a blank screen as I am expecting but in the console I should see logged out the latest round 175 602 I should see the latest randomness so that's all working in JavaScript test well hooray with pleasingly similar syntax we can get the old one as well let's do that it's fun old one two three four five let's do it got an old round one two three four five and so in theory say that this all around seven three five six one four if we get back over here and have a look at our go up assembly 5f 624 okay they're getting the same information from the same same chain so stuff is working we can watch in JavaScript as well I'm not sure if I said that but watch in in HTTP in there for the HTTP clients it's actually not a real extreme as so for the G RPC clients is an actual stream open connection this remains open but in HTTP it's actually a HTTP client calculates when the next round is meant to be available and then makes HTTP requests when it's available and then yields it essentially alright so we can use so in a similar way we can use for a wait watch okay so is when you watch it returns an async iterable and then we can use that in a for await loop and to do something very similar to what was happening what was happening around new randomness round round okay there we go so that's the current the current rounds and the next round is just come through it'll works hooray and what's kind of cool is that the rounds that in jeaious the rent when the rounds come through and the client verifies them that's done that's done using the code that is written in the go in the go client it it uses wasm is compiled to Adam and and it's downloaded and verified using the wisdom in the browser it's nice and fast a previous iteration of the client was was doing that verification in around the second mount was it in between 80 and 100 milliseconds so that's that's much better than it was gray and cool that's the J's client all right now the most fun bit this is getting more fun as time goes on all right check this so with with them we've done some some getting randomness using KS but let's get some randomness and use it in a web application how do we even use this all right so this is our web application this is our dice roller is its chosen by a fair dice for all it's guaranteed to be random when we roll it sort of does a roll for about five seconds and ends up on four when we roll we roll again it does the same thing so we need to fix this because it's just a four roller and as Dan showed in his slides if you're familiar with the xkcd then you will be laughing at this already cool so let's fix this up let's go back to let's go to a different project dice roller now I'm just gonna start serving this let's look here okay so this what is this so this is the code this is the HTML code behind the page that I just showed you there's there's some style you don't need to worry about but it's essentially it's essentially div with the dice value on it there's a button that says wrong that's cool and then there's this little script which we're going to start with main door chairs and all this script does is obviously gets hold of that dice element gets hold of that roll button and then the answer listen a click event mr. on that button and it disables the button stops people from pressing the button that so they for us take once it starts the roll so you don't we're not gonna look this this this magic miss starts the dice rolling so all it does is it takes the dice element and it puts random numbers in the dice so it looks like it's rolling whilst we get our random value and whilst that's rolling we set a timeout for five seconds and then we stopped that roll with the value 4 so that's what's happening every time I was pressing the button just then and then I'm disabling under sailing the button so we're gonna fix this so that it works in using dieren jets and so for that we need those we need I need the stuff I had out before it's correct that so so I need I need this chain hash and the URLs that I was using I'm just gonna add them in at the top okay and then I'm going to import and instantiate the client as I was previously I just need that import again import it and client here we go is the client oh yeah that we're gonna put it in here instantiate it when we cool mein there we go so now we've got a client that we can use oh he's make this one a sinc function and so instead of instead of this stuff we're going to keep that remove attribute we're not gonna stop the dice rolling at the number four so we're just gonna remove that bit but after we set the dice rolling what we're going to do is we're gonna figure out what the next random number is going to be so we can do that by next random number equals we can use round at so this is client func this is a function than the client that's available in GIS and an NGO but you give it a time and it gives you a round number back so further it for right now the network around is going to calculate what the round number is what is the randomness value that has the round number if the redness value that has been generated and we're going to +1 onto that because we actually want the next round that hasn't yet been generated and then what we can do is we can say round equals get that next round and what the interesting thing that happens here is that when you ask the HTTP endpoints for the next round you can't ask for future future rounds but you can ask for the next one it'll block until that rounds available so it won't return until that round has been generated so I can await on this illness get next round and then once once it comes in I need to convert that randomness by date which has been a big long string of hex encoded data into a number for our dice right to nominee calls we use big uns cuz that's fun right we're gonna say that it's some sort of hex here and the randomness and then we what we're gonna do is we're going to mold that like 20 because we've got a 20-sided dice so we want so we want a value that is that is in that range of 0 to 20 right once 20 essentially but this will get a give us in a range of like 0 to 19 so we're gonna add 1 to that and so we need if I wanted to use mod and plus then I have to tell Java scripts that these are big numbers and I can put n after them for that and then I'm gonna once of once I've done that also converted the randomness for deer and into a number that can be using my dice I'm just gonna come to string on it base 10 and then and then I can use my current role stop pass it this number instead of 4 and that should in theory although I haven't demoed this so we'll see if actually really the run-through and distant okay and so I started this up on localhost 8080 so it should be here if if there's no errors in there a week yes it's true okay here we go so okay I think I think that's okay let's try again ah get out the way okay that looks like it might might have worked so should be able to now roll the dice and it should oh yes I'm getting six hooray all right that it's super red and I should be there's always there's always a chance that it it lands on four so rolling it again so the interesting thing is it can take up to 25 seconds to roll the dice now so and that's an interesting you just around nine but now we have unbiased scible verifiable randomness driving our dice no one can interfere with our dice rolling and you can use this when you need to roll a dice with some board game or something so super simplified use case you get the idea right okay hooray all right so um how much time we got left okay not not very long at all if we go over a couple minutes that's all right okay cool in which case I'm just going to expect the next bit is Limpy to be pops up and getting randomness off the lip YouTube network I'm gonna explain why you might want to do that and then I'll just I've shown you I got a pre-canned already done I wouldn't have to actually code it in front of your eyes and think that I can show you so I'll I'll do that and then if you wanna if you want to explain it and and if you want to use it then that will hopefully save a little bit of time cool okay so the next bit is kind of watching for around immiscibility TP pops up and so using lip PTV pops up as a transport is that means of mitigating risk if you if you rely on receiving the randomness of deep and generates then different you using different transports with the client gives you an alternative means of getting hold of that randomness and so and that might be and because it's more reliable but it might also be a little bit faster if you used it transport so and for example like you might you might find whilst your dear and client is running the Oh SP books HTTP traffic to a particular URL so maybe a different transport can then service your request maybe I don't maybe DNS Goes Down and or is like sabotage and pointed to like a rogue few round machine I mean that's kind of ok because if you if you get pointed at someone and they're generating random values then you won't be able to because of the client verifies the random values and and it they'll be thrown away essentially but other other transports will be able to satisfy the the requirements so so that's good and I think David already said but we've observed that actually receiving randomness over its me pub/sub is faster than over HTTP in China I'm due to the over-the-head that the fire ants and so that's fun um so anyway let's let's there to get on with it let me show you this recent recent one here we go so I got this cool this is similar to what you saw already in the go in the go client I'm this fit is new so previously we had let me show you show you just here but I've basically deleted this stuff now I've deleted that stuff and added I did this stuff I've also added this listening address so this is a listening address that the p2p can listen on but the most important thing is these relay addresses so these are the p2p nodes the League of entropy on that protocol Labs are running that you can connect to weave Lippe two piece pops up and listen for randomness cool so what I've done it why I haven't deleted this because wouldn't what I've what I'm trying to do is prove that this works entirely over pub/sub and so we're gonna create a client or we create a new client we create one client and then we create another one this new client and that has no ability to talk over any other transport other than putter and so the thing the reason why this is a little bit weird is because with pub/sub you can only receive new randomness like there's no way to ask the pub sub network for a chain info there's no way to ask for that so what we're doing is we're getting hold of the chain information from the HTTP client first and instead of parsing the chain of hash we're gonna pass the chain info to the client which means that it doesn't need to then go and get that chain info so that it can verify that it's talking to the correct chain and so like verifying pub/sub messages or randomness beacons that come over pups up it is extra important because I'm over pups up over the pizza pier pops up the randomness beacons can come from anyone like they're not coming direct from D round servers or D amount relays so so so that's kind of good so here we go so we've done a little bit admin here there's a lip e to P package in endear and which allows you to which has some helper functions for constructing arias loading public keys and private key sorry creating them but essentially the interesting bit is got G client would call it G client so they were importing client from the p2p it's G's for gossip because that's the flavor of pub/sub that is implemented here and we're using some create a new client we're just using pub/sub and then we're watching for a randomness yeah so as I said before the interesting bit about about this puffs of client is that it has no facility to get the info it also can't you can't ask it for any round like you can't say it give me round number one because it can only give you back stuff that it receives there's seen before has been published to it so you can ask it so you can call C client don't get for any round that you've seen before because it might be in the cache with them but as it is here you can only watch for stuff essentially but typically what you do is you'd add this this as a in combination with a HTTP client so you could go and get the info and it will fail over to http or vice versa if maybe you know the random mystery it doesn't come through pups all the times little confirmation see people it work it out for you essentially anyway so that's the explanation every event from abadeer takes a lot longer if I just typed it out as well in theory I should just be able to run this main don't go and this client which operates only on over the p2p pub/sub should then start receiving so we shouldn't worry too much about one of these include temporary yeah this is fine because what it's trying to do is it's the optimizing the optimizing client that we're using is speed testing the old clients it gets and it's speed testing to pub/sub plan which as i just told you we can't get you can't get any old random value and as for the speed test it tries to get the first round from the chain and we haven't seen that over pubstomp yet okay so what happened to it okay so we've got a new round and we still got our context with time out so it timed out after 30 seconds but this worked there's got this got the rounds on seven five six four five over Olympia's because up exclusively there was no other way for it to get that round from anywhere else so so i'm super happy and that is essentially all I have to tell you about the deer and client and I hope you enjoyed it as much as I did have I can take your questions now if we have any time if anyone wants to say that was amazing great stuff I have questions many thank you so first how is the the the period I I guess it is network-based because you know the centralized time or getting a tough customer time source is already a big problem so how does this period come so you give if you get a time step to get an absolute time how do you come to that and what is the variation in that I can take the other one so that is because the randomness comes from a small number of nodes which are the newer notes and they are all synchronized by just using standard ntp and so the nodes themselves will generate a partial signature at every epoch and like so that the pockets define when there is a different ceremony to say that the network and so if it's 30 seconds and they all agree they're like at every 30 seconds they generate a partial signature and and so when they all generate the partial signature and that partial signatures get assembled then that trellis gets broadcast but but it so the way to think about it is like you have a small core of protected nodes that are with their clocks synchronized because it is simpler to have a small group like synchronized and like try to synchronize the whole world right and so you are able to rely on that clock time but like when it gets to the client like that time stamp that you see on the client you can measure the discrepancy between the the previous round and the the what you just received and so you receive a round you measure from here I should be receiving on the round in 30 seconds and if there is some delay there when you receive it you can either give that to the latency between the dear unknown Network distribution network the client or yeah might be some other issue in the middle your question I'm an artist let me ask high level question so it is a permission that work yeah with the set up ceremony if there is some leak it's unsecure yeah like if there if there enough notes like if well let's define insecure so in order for someone to gain a privilege such as being able to predict the future they would have to compromise enough nodes and that enough is N equals the threshold right so if the threshold is 7 over network of 10 and you have to compromise self with a small permission network they could collude to do it's different operators we differently straight interest we have friends geographic locations yeah well you are very fine that you trust when you accept when you accept that we go of entropy you are trust on your partner's right okay yeah yeah okay it's interesting because it's a very hard problem and usually that the problem is with this kind of times and all kinds of synchronization is a communication overhead and this is why proof-of-work is so strong because it solves the communication overhead because you don't have to communicate to come through to consensus yeah so it's K is better in the number of notes of course it's it's energy intensive you said that notifiable delayed functions are out two or three years I'm I'm very interested in that because it's kind like a group of work which is not paralyse able but it's serialized proof of work so you cannot compete so it would probably solve the energy problem why do you think it's 2 or 5 years out what to say odd on the problem that's a great question and so I'm actually not the vdf researcher I got that information from the team that is like doing research and vdf so that's what they gave me ok ok thank you great great great initiative great project I love it I said one other question because if you have if you have reliable decentralized randomness that would solve many problems in consensus space systems and but what I don't understand how can it solve the problem if you have a separate chain that let's say they have some kind of they have solved the civil problem and they have a permission set of verifiers and they want to use randomness to let's say it's select the leader of the next block then if they would still have to rely on an external source for the reminisce with tear end and this is I think a problem within any kind of a consensus system that is no weight forward so you're saying it like even after using the ER end they still need to rely in an external source or like the run being there's a low source in the first place yeah you know look look at any any any any blockchain like a serum or whatever they they cannot rely on any external information to come to their consensus record because external information is unreliable in the sense that you might not be able to connect to the network the DNS might be spoofed or whatever yeah yeah yeah and so yeah you're right into like one of the effect vectors is that like if the network is down if there is an outage like there there there are depending on the construction of the blockchain that is using the randomness it could either help or could either wade through some like uncertain behavior into the way that we approach these like Falcone actually has in its protocol ways to be able to make progress even if there is a Duran outage but then the the premise is a like the end by being a distributed network run by multiple parties where you only the threshold of parties for then the right for the network to have liveness and because these parties are running your dealer knows in different infrastructure right so it we have people like running in private clouds in by public clouds in other at the center's like there's like all sorts of diversity in terms like geographical location connectivity infrastructure hardware by there's like so much diversity that like in order for an outage to be complete like a complete blackout is essentially you are attacking the whole internet right because now we have to take down all of these other centers at the same time you have to like compromise these organizations out at the same time and so like it's just like like increases the cost of the attack very high right and so I guess that that separate change that want to rely on on some kind of distributed or decentralized mandamus could integrate a diamond into that project directly I think that would be yeah yeah until the way like this how how many can be in the set of you said it's a small core how big can be the set of notes that come to consensus about the randomness you can be as big as we want of course when we reach to a big number then like who we like if we worked over a thousand notes or like a million notes to be part of it then like we have another scalability problem within this small group but but right now we are already over 13 notes and like we seek to increase that number and so the more nodes we are the more secure the network is but also as the move as we increase the number of nodes we also increase the threshold we have a way to kind of like project what is the best threshold for network size and and typically it's like anything between more than alpha and below 3/4 of the network so they're like you have a network that is both secure that is like a very high cost to attack but also there is a very high probability of having wideness and like if you have like some kind of like some safe assumptions such as if you assume that like between 10 to 20% of the network you never doubt in general anytime because all kinds of like services anyway and then if you take into account and then if there is an attacker trying to compromise nodes like how many nodes you have left that could be the thresholds that the network has aliveness and the other thing is in the case of events that like someone compromises the network for some reason I'd say that that is a very rich malicious actor that order does a lot of friends in a lot of companies from different countries from different industry sectors right in is able like there is always a way I can I keep the network arts for that reason there's always a way to see which notes stopped generating the partial signatures and do a reshare or even a huge ceremony to kick those notes out to demolish that are behaving incorrectly and so there's like just it's kind of like better safe than sorry make sure that like ever network as diverse as possible and I like a very like tight monitoring but like in the case of a potential attack like the equivalent to fraud detection like monitor like some weird behavior and and and like exclude the weird behaving nodes or of the network okay and so what is the position of the of the of the clock that you get basically so are you off by if I if I connect to one of the nodes and get get the randomness beacon am I you know do I have a margin of error off second two seconds five seconds midnight from generation to actually receiving it and I don't know how the time is fixed to anything because there is no absolute time in the sense of yeah so like from our monitoring so a queries think that we call the network Observatory where we have just interval probes yeah multiple geographical regions that are just like receiving the randomness and see how fast they get the randomness from from the multiple distribution real distribution network endpoints and so like it went be between like 500 milliseconds and 1.2 seconds right so the slowest would be receiving the runners like 102 seconds after but like if you think about it because the randomness catching it in every 30 seconds it means that like every nails if everyone gets the the way this number between 500 milliseconds and 1/2 seconds everyone see was like 29 seconds so I closer to the 90 seconds with the value already cashed in there now right and so it gives you like a lot of time for everyone to receive the randomness and ensure that everyone has received the randomness before the next round it's produced who who said that but basically which entity in the network sets the the final time of a randomness beacon some leader node or it don't like to think that like we are all independent in a zoom zoom right into every 30 seconds I will generate a partial signature like and then when there is one of us and I know I'll send a copy to each one of you right like when one of us as enough pieces and enough is equal to threshold is has a schism together he pushes to the distribution network and it's like when others receive it and he writes the time no I'm not sure if maybe I don't understand just the question yeah this there is a time associated with the random and mass beacon and to say okay I collect all the signatures it's fine i'm not-- i have all the signatures that are enough to come to a decision yeah and then III write in the time and and and send it out or do the where's the time fixed ICS here I got you guys generic you are asking if the time is a time there is like when the partial signature is created or when the partial signatures plural are assembled that's a good question I don't know if it fresh in my memory Hector or our do you actually know right now out of all your otherwise like we can always check no I don't think there's like a time stamp that gets saved anywhere for when something is ready there is a time that when it should be when it's makes its way generated and then there is like the time between that and the actual thing being ready and available to the network yeah yeah and because like there is a period right until independent of like wherever your clock is synchronized to like you can always ask because given at the epoch is fixed like 30 seconds well in planet Earth is 30 seconds for everyone when we have multi interplanetary randomness that will be different but like as soon as I start receiving randomness I can then predict when I should be receiving the next one right and so this is where like we see these discrepancies in and yeah well but but I'm also happy to follow more on this question because I see that you ask a couple of time so maybe there's something more that we can just demonstrate ok if you can think is on the on the slack on the ok thanks ok so something about DVF's but I keep mentioning cornstalk yeah like there was a question where up in here in chat just like for the record yes when you are using cryptographic codes definitely make sure that gets audited like you should not just stop things from the internet and just trust it because if you download some client library that was manipulated by someone the best that we can do is make a color vailable so that you can check it out like audited and then we can a and like when we publish it to CDN we can provide the ash so that when you download the code your browser can verify the integrity that the code that you don't know that is actually the one that we produced and this is like one of the techniques using like the web slash chess world for the girl world we have signed commits so you can always I give clone and I build your own or just like import the the library and then I build it yourself to make sure that like we you have the right thing definitely always be extra careful when when importing anything that has to do some quick traffic verification because if there is someone that is able to mess with your code then virtually before you yeah you can do the same thing with gas as well you just you so for a lot of applications you bundle up that with your application code so yeah like it doesn't have to come from a CDN yeah that's convenient all right I don't see more questions or people and I added one more is there a way for an attacker to affect liveness if he belongs to run and and attackers make sure that the CLI or render the consumer may not be able to question so you're saying or rather than attacking the the source attacked the destination so Eclipse Eclipse the receiving node and so if you have the power to like oh did I get the question right yeah so if you have the power to eclipse entirely let's say like you have the power to like completely on the internet of my home like you will effectively have the power to like isolate me from the rest of the network and that said we we are making it extremely hard because let's say that I am in a network that has blocked cloud fair I can still go to confront or I haven't mean the network just just block DNS as a whole I can still usually PvP a subset that doesn't rely on DNS to fetch the randomness right and so we have multiple transports to deliver the reminisce and and so it is incredibly hard of course if someone cuts the cable that offers internet to your to your location where your machine is then well you have all troubles as well I keep some just ear and it goes off it's later Internet I hope did I answer your question yeah I think that that probably covers it it looks like will has actually been in the YouTube chat answering a bunch of questions so that's great so we could probably wrap up there if there are no last-minute questions if anybody's still unsure about things or has additional insights that they're looking for you can definitely connect with David and Alan in the slack they'll be available and probably all of the channels thank you both for presenting Alan when you went through I could feel your excitement at the correct results it's always nice when it works the first time so congrats on that and thank you for giving an excellent workshop and this is perfect because we have it recorded and it'll go directly onto the eath global YouTube like I mentioned at the start I think we can probably wrap it up there Andrew we'll see everybody in slack and their office hours tomorrow and as well be hack feedback session on Friday thank you thank you thank you so much for us thing is script yeah thank you 