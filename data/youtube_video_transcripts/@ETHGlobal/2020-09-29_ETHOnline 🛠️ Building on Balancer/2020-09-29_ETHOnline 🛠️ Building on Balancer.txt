waiting to confirm stream yep looks like the stream is good all right welcome everybody to the second day of week zero uh sessions workshops brainstorming [Music] events today we're starting off with balancer which if you're not familiar is a protocol that launched this year on ethereum and we have john from the team with us today he's going to be walking us through what the protocol is how you can use it in your hack and uh some of the prizes that they will be offering for eath online so i will let john start his presentation and just before that we will just hit some quick logistics things um if you haven't staked yet for the event please make sure to do that before the kickoff on friday this is the way that we make sure people are engaged and um you know committing to finish out the event by submitting a project of course you do get your stake back at the end once you submit so don't worry about you know losing a significant amount of money as well as if you have any teammates who you plan to have join your team they must apply individually so again do that before the kickoff uh on friday ideally uh tomorrow or thursday i think that's it for logistics i will let jon start cool thank you and thanks everyone for joining uh my name's john and i'm a software developer at balancer and the plan today is just to give you a quick overview of what balancer is what it can do and then do a bit of a demo of how we can use one of our latest kind of features which is uh smart pools so bouncer is a protocol for programmable liquidity and you can think of it as a generalized amm or market maker and the building blocks of the protocol is bouncer pools and the pools are smart contracts that hold two or more tokens and every token has its own weight to represent and a proportion of the total pool um the feature of the pool is it is continuously and automatically rebalanced at no cost to the liquidity providers so you can think of it as a portfolio or an index fund and it's highly configurable and very flexible so you can have up to eight tokens per pool uh you can configure the fees to be whatever you like and you can configure the token weights to represent what you like one concept that you should be aware of when you're building is the idea of controlled versus finalized pools and all pools when they are created are initially controlled and this just means that you can think of it as like a private pool the pool tokens can be reconfigured the weights can be reconfigured to swap v could be configured and at this stage only the creator of the pool can add liquidity and any controlled pool can then be made finalized or public and it's a one-way action and it basically locks all the parameters and it allows at that point anyone to add or remove liquidity uh there's different categories of users who interact with balancer pools so if we take an example pool the first user is a liquidity provider who provides liquidity to the pools in the form of tokens and they earn passive income from trading fees and in return their portfolio is all rebalanced and all the rebalancing itself is basically done through economic incentives and if you imagine if there's uh if the tokens are out of balance there's a profit to be made and an arbitrage air will seek to claim that profit so they'll basically buy your token and sell it on another exchange and in the process of doing that they rebalance your portfolio and you earn the fee from the trader alternatively there's also retail traders and traders who want to exchange tokens the balancer protocol provides access to all the liquidity through the pools uh so you can go to something like the balancer exchange to make a basic real retail trade or through aggregators and in return they get low slippage and favorable rates and finally other smart contracts here seeking liquidity can interact with the protocol so the there may be many pools and bouncers that contain a token pair that you're interested in for example if you were to swap west to die it's very likely that there are many pools that contain both wealth and die and there needs to be some way of aggregating that liquidity for the user so we have the concept of the smart order router or the sor which is an off chain library available on npm and it basically finds the best orders across all the pools and provides the best price for a swap it returns a list of swap uh pools and swap amounts that you can then execute yourself and that'll bring you to the most efficient trade and we're going to take a look at that in a bit and finally just introduce the concept of the smart pools it's something that we've recently released um smart pools are pools that are controlled by smart contracts instead of an externally owned account the benefit of smart pools is that it allows liquidity providers to provide their liquidity to the pool but it also has flexible parameters that the liquidity providers can see and be aware of this opens up many novel use cases so it's probably a very good thing for you guys to look up for your projects for example you can have varia you could have um changing weights of the pools over times and you can have change in swap fees so you could have the concept of like surge pricing if things are very busy you can up the uh the exchange fee and things like that it's a very large and open area to build on and just recently we've actually released a configurable rights pool which is a reference implementation for smart pools and also has a user interface which can be used to easily set the parameters that you can change at create time and we're going to take a look at that now so let's close this so what i want to do is uh we're going to create a smart pool with the crp template using the user interface and then we're going to write some scripts to just change some parameters programmatically and this will demonstrate how you can interact with a smart pool using your code and then we're gonna use sor to find available swaps and then finally we'll make a trade on a balancer pool directly so the first thing that we want to do is we can go to the configurable rights pool which is a reference implementation it's uh open source and available on our github it's been fully audited now uh it's got documentation within the readme and within our own documents and this initial section here is where it shows you what rights we've uh included as part of this reference implementation so just to give a quick overview and you can read more about it in the docs uh it allows you to pause swap and change swap fees change weights remove or add tokens create white lists for lps change the cap or the pool and you can remove all the tokens the first thing we're going to do is actually clone this repo because we're going to actually compile the smart contracts and use some of the abs to interact so if we just change yeah okay we're just going to wait for that to install and while we do we're just going to set up a separate directory to write some scripts to interact i'm just going to yarn in it to set up the project i'm just going to add a couple of libraries that i'm going to use to start with i'm just going to write it in typescript um it should be easy to take this kind of example and add it into any of your front end code or any kind of node package we're going to use ethers to interact with the kovan testnet everything that we've got at the moment is deployed on kovan as well as mainnet which makes it nice for testing and i'm going to be using an environment variable just to include some keys and things so the just add these okay so we can see here this is a configurable rights pool that i downloaded from get and we've got the contracts we've got a full range of tests which is a good place to go and look at how you can interact with different um functions and what i'm going to do to start with is i'm just going to build this it could pay a lot so that i could get access to the contracts so the first thing i'm actually gonna do is i'm gonna deploy a brand new erc20 onto covant and the reason i'm doing this is just to show that um at the moment this erc20 won't be included in any of the test pools on kovan so it helps demonstrate so at the moment all i'm doing is just going to copy over our environment very well so yeah i've got a environment variable uh environment file that's got my inferior key to access the network and we're just importing ethers i'm going to copy the token artifact from the compiled contracts here which is just a test erc 20 that we use and that'll give me access to its api and then all i'm doing is using ethers to get provider connect my covan wallet instantiate the token contract i'm going to deploy let's just call it d token and we're deploying let alone finally i'm internet for my address so if i go ahead okay so this is going to be the address of our new token this is my test account it will probably take a little while to search okay we can see here that it's been deployed and i've got now a thousand of the token um so the next thing i'm going to do is i'm going to set up the and separate script to use the smart order rear so i'm just going to create a new file here called sqr and the first thing you want to do is pull in the sor library itself which is at answer labs forward slash xlr this is fully documented as well and i'll point you to our documentation after and i'm gonna add the big number library because we're interacting in a way format so i'm just going to copy some code over and we've deployed a bunch of test tokens on kovan that again are fully documented in the documentation and they also have faucets so you can actually claim some of the tokens which again makes it easier for testing you'll find that a lot of these tokens are already included in bouncer pools on koban which makes it nice for tests and swaps and things like that and for this demo i'm actually going to use i'm going to set up a swap between wealth and my custom token i'm just going to set my token out address to the address of the token that we got i'm just gonna run the script so the first thing we're going to do is we're going to use the sor and we're going to use a function called get pools tokens and we're going to call it for token and token and what this actually does in the background is it uses the sub graph to find all the balancer pools that have both of these tokens within them which are at the moment should be no pools because we haven't actually deployed any pools with that token um just to point you to the sub graph we've got a full subgraph for covan on main that and there's a whole bunch of useful um data that you can pull there we use it across our front ends and it's extremely useful and you could probably build a lot of interesting things with that data and so we're just gonna access the pools and because we expect it to be zero at the moment we're just gonna do that i'll change once we deploy our smart pool this will say okay so if we run that we'll just confirm that we can see what we expect okay so we can see here that there has been no pools retrieved and we're going to change that now so to change that let me show you our this is our we have we already have a deployed uh pool management interface which is what people use at the moment to create pools uh to manage their liquidity things like that this is a a better version of the pool management interface that includes smart wheels and it's very close to release and this is a kind of test version that you guys can probably have access to if we go to the smart pool section oh sorry create a pool we're gonna choose smart pool and here's where i can add the assets that i want or the tokens i want within my pool so at the moment i'm going to choose wealth and i'm going to choose the token address because it's not been whitelisted yet because it's just been created i need to enter the actual address it comes up with the same and and here's where i can set the weights so the weights like i said previously are fully configurable if you want a 50 50 pool you can just put equal weights or if you are like more kind of bullish on wealth or you want more exposure you can make a 90 10 pool and we'll just make it 50 50 and just to add a initial amount so when i'm first interacting with the pool with a new token i need to give an allowance so i need to unlock my token and it's probably a good time to point out that for our front end in the pools everything goes through the maker ds proxy and this is a a way of us making it more gas efficient for users because it allows the token allowances to persist across all the pools so instead of having to set your allowance for every single pool you do it once on your ds proxy which is um deployed when you very first interact with the pool's interface once you've approved one token on one pool it is then available across all the pools again the swap fee is configurable so we'll make it quite a high spot school 35 and the smart pool itself will have its own symbol so we can set that to let's just call it the and here's where you can set what rights you want to be made flexible and once these are made flexible as part of this then it will be ongoing so for this one i think we'll do pause swap and change copy change that yeah we'll do common lps and then all we have to do is hit create it gives you a warning to check that your balances that you've imported are going to be correct and then hit continue so in the background the user interface is going to call the configurable rights pool factory which we've made available on both mainnet and testnet and it's basically creating a new configurable rights smart contract specifically for us and well it does that also deploys a balancer pool that it is in control of and while it does that it pools the balances that we have set here from our account and inputs them into the smart pool so we saw that the notifications said that that had been created so if we just go into smart pools just need to refresh it while we wait for the subgraph to catch up okay i'm hoping this is just a sub graphic sheet okay while we wait for that we'll just continue a bit with the sor library hmm ah okay finally sorry uh so we can see here that's been created uh we can see that's our token address which was the a7e so what's shown here is this is the smart pool itself and we can see it it's just showing us what the weights are what the balances are and once you open up that for other people to have liquidity the pool balances will change over time but it'll always show your balance and your percentage so at the moment because i'm the only liquidity provider it's got 100 percent share so we could go to the right section which then shows the rights that we set on create time and this is publicly available for everyone so it gives people confidence that the smart pool that they're interacting with is safe and they know what can be changed and the controller address is the smart the crp contract that was created from the factory when we created the new smart pool and the smart go controller here is uh my ds proxy address which which is basically me and you can interact with the factories directly without going through the ds proxy and in that case you would be the controller you're externally on the account and within settings we can see the rights that we set and can then be changed at any point and we can even change the controller itself so if we go back to our sor contract now there has been a new pool and we can rerun the sor and this time we can see instead of returning no pools it's actually found pools and so we're just going to build on that to see what the swaps would be recommended so first thing we want to do is we want to use the sor parse pool data function and we pass in the list of pools that was returned along with the and that's going to parse the pool data into the uh the correct format for the rest of the sr to use which is the way balance uh the sub graph is storing everything in known in ether balance so it's just converting it away and then we can use that to get the source swaps using the so our smart order function and this is basically the function that's going to take most of the trade data and return what we want so we're passing the format data the next parameter is uh swap type so we've got two different kinds of swaps we've got swap exact in and swap exactly a swap exact end trade is when i say i want to send one with the sor will make sure i spend only one weapon i'll return the maximum amount of my token out that it can a swap exact date would be the opposite so i could say i want 10 of my token and it will tell me how much of the wealth i need to input to make that swap next one is the input amount so we're just going to say 0.01 in wave format this parameter is the number of pools that we want to make a swap so in an ideal world we would trade against every single pool that had wealth in my token but the more pools you interact with the more gas it's going to cost so there's a balance and we probably recommend between three and four pools at the moment and this final parameter is called the cost of the output token it's another bit of information that can be given to the sor to make it more efficient gas wise and you can check out the documentation for a bit more detail on that but for now we're just going to set that to zero so that'll return the swaps and we're just going to use another helper function to format that format we take the output of that which is the source box max un which is the max price that we're willing to pay and the minimum amount amount out which we're just going to set to zero and then finally we can use another helper function just to make things easier which is calculate total output and that just takes the swaps and the pool data and what this one does is for every swap that the sor recommends it's going to calculate uh the amount out from that swap and just sum them all so that we know exactly what we're getting out now we can see what it turns here okay so if we run this again so we can see that it's returned one swap which is what we would expect and there's only one pool available if there was more pools it would return a maximum of four because that's what we set and each swap has its own information so it's got the pool address that you want to trade against uh and this pool address is the actual balancer pool that contains the tokens it's got the token in parameter which is the amount of tokens that you want to put in for that pool it's got the token out grammar which is the uh price the sorry the minimum amount out and then the max price so we can just take a quick look at this address so if we go to the contract we can see here that it's a balancer pool and that's the code for the balancer pool that you can find on the github and we can actually read the contract so it's worth just showing you here and these are the current these are the tokens that we've inputted earlier and this is the controller which reflects on the controller here okay so the next thing we want to show you is um how we can interact with the smart contract and change some of the settings using the script which is again something that you guys could do using a front end or even like a kind of cron job or something to change swap fees change token weights things like that so we're just gonna make another quick script controller okay in this script we're actually going to toggle the swaps off and that should make it no longer public which means that there should no longer be trades against it so it's a way of basically switching off your balancer pool or your smart pool um so to do that we're going to take the actual configurable rights pool from the compiled contract and we also need for this demo we're going to use the ds proxy because the pool was created using the interface we need to interact with it via the ds proxy if you're doing this directly then you don't need to go through the proxy at all we're going to use the same basic setup using ethers to access it and the first thing that's going to be different is we're going to get a controller and this has to match the controller from [Music] here so this is the actual address of the configurable rates controller address and we're going to use the crp artifact wbi so this is the configurable rights pool and the provider to start with we're going to just make sure that we can read that contract and see that the public swap set is what we expect it to be which at the moment should be true because it's switched it's toggled on the other thing we're going to create for is the owner of the configurable h pool itself which we can do get controller function this should match our user proxy address which we saw earlier if we just take a very quick look at the configurable rights pool itself you can look this is the contract here we can see it's got this is public swap so this is the first function that we're calling uh these are all detailed with the the documentation as well okay so let's just make sure we can run that for now okay so we can see that the public swap is returning tree as we expected and we can see that the controller is the same address so that's a good sanity check and what we're going to do now is we're actually going to turn that off so we're going to set the um public swap to false so to do that we're just going to use a bit of a non-direct method which is using the ds proxy so we have our um proxy actions address that we use and we've got the abi colon and working interface and we to use the proxy we actually need to encode the data for the function so we're going to use include function d and function we're using a set public swap and we're going to change it to false and then we're calling that against the controller address and then we just need to do the actual proxy itself we can call the execute function on the proxy which is what's going to actually call the code just wait for the function and then we're going to just check that it has been set to false as we expect let's just open the dx hash so that we know it's doing something okay so now if we run this we should actually interact this time okay so we can see that the tx hash here has set as false and just as our reader look confirmed as false but just to double check what we can do is come back to the smart pool user interface just refresh this and go back to the settings and we can see here that this has changed to pause so instead you use an interface to swap it we've just used it programmatically and you can access all the configurable rights so you can set a different swap fee you can change your tokens you can do all that using uh your own project and then just to demonstrate that again with the sor this should now mean that it sees no more uh swaps available so because it's been paused the subgraph doesn't count that or we're looking for pools that have got public swap set to true so when we call that sr helper function it's returning no pools so the final thing is going to show is an actual swap so i'm going to toggle this back on using interface confirm that okay just need to wait for the subgraph again and then we're going to just build on our s to our contract to actually interact with the bouncer pool and swap it so we saw previously that the sor swaps was returning the pool address we're gonna take in our normal provider with the wallet and this time we need a pool artifact so we're gonna interact with the balancer pool so we're going to take the compiled b pool copy that over grab its api and the first thing that we're going to use is from the swaps output which hopefully we can see here we're going to take the very first swap because we know there's only one and we're going to take its pool attribute which is the address of the balancer pool that we want to interact with we're going to use that to access the box reader just set up the contract and we'll connect to that using the wallet and then we need to braille the token because we're swapping directly with the pool there's been no pre-approvals so what we need to actually do is approve our wealth and the balancer pool to take our west so we're going to use we saw earlier later [Music] let's just do log just here for approval x equals wait that's going to be the cool address and for the moment we'll just give it the max approval wait once that approvals through then it means we can interact with bouncer pool uh if you're ever coming up against strange reverts or errors in your code i would say always double check that your approvals are correct it's definitely one of the number one problems that people come up against because they just forget to do it especially when they're just using code instead of an interface and then we're going to use the bouncer pool function swap exact amount in so if we take a quick look at the documentation here if i can get around this drop down within the smart contract section under the api core bpools it lists all the functions that you can interact with the balancer pool so we've got swap exact mount and swap exactly out which is similar to what the sorr we explained earlier you can join and exit the pool by providing liquidity you can join and swap at the same time and then there's a bunch of functions you can call to get spot price things like that uh if you click on any of these for example swap to make you get more details so there's loads of documentation so the first parameter is the token end which is going to be width and then we can use the output from the sor to get the token in parameter which is going to be the amount of wealth we are input into the swap token out and we use the token so if you were doing this with a a swap that had many pools or more pools than just one you would basically do this on a loop and you would just call you just do this for every single swap that the syr returns and it's a really efficient way of making a good swap and then let's just dx hash okay so hopefully this will execute the trade so the first thing we're seeing is it's going to prove hopefully this goes through and this will show us our tx hash okay so we can see that that's already going through and if we just take a look it's coming from my account it's interacting with the balancer pool uh it's taken the 0.01 wealth and it swapped it for the d token and it's outperiod.00867 which you can see on the output of the sor is exactly the amount that we expected it so i hope that's given a kind of quick whirlwind uh introduction to some of the things that we can do with the bouncer protocol especially with their new um smart controllers and i just wanted to show you a bunch of resources that you can go to um for the smart pool itself and the configurable rights pool in particular there's a lot of detail in the documentation under the smart contracts and there's also a whole section on smart pool templates um and that's giving you some ideas and actually some pointers to some smart pools that have already been used so for things like liquidity bootstrapping protocol uh ample forester using it to change the supply things like that it could give you inspiration uh further down we've got our actual hackathon section which is a good place to start it's got some introduction and a quick intro material that'll if you've never dealt with balancer before there's a really good place to start it's also got a link to our discord which is a good place to come there's a lot of community interaction people willing to help with questions as well as like the core desert there and we've got the hacking and testing section which will give you details about all the deployed contracts on cova and the sub graph and we've got our exchange up under pool management up which are both available in koga and on main net um and that's a good place if you would you get started hacking uh just a quick bit of information about what we're looking for when we're judging uh definitely worth the read and then finally some ideas that the team have kind of come up with that we think would be interesting to see and that we'd also maybe give you some um food for thought for coming up with your own ideas uh so any questions hopefully that helped wow super that was really really in depth cool i'm sure some people are gonna go back through and uh and re-watch it to just get all the detail no no no it was really good um this would be a good resource for anybody does anybody have any questions i see jacob has his hand up hello mute uh hi thanks um question on sort of just generally understanding the adjusting of weights in smart pools do you think that could be used to avoid um impermanent loss like if you hooked it up to a price feed and dynamically adjusted the weights in the pool is that a way to potentially avoid those type of losses um i think it would it definitely changes the spot price and that's one thing that changing the weights does do so if you go uh to the blog i don't know if you've seen our blog it's actually linked in this hackathon um on the front page there's been some examples written there by like our cto about the liquidity bootstrapping protocol which is kind of similar so as over time they adjust the weights and the price gets forced down i don't think i feel confident enough to say that it would get rid of a permanent loss because a lot of people would say that i don't know if that's ever possible but uh i mean if you could do it it'd be great to see and it would definitely make an interesting experiment if nothing else uh what happens to the tokens that exist in the pool when you tweak the weights so say i mean maybe as an easy example you have a fifty percent uh die fifty percent each and you switch it to 80 20. now there's all this existing liquidity that's balanced at 5050 does then that gets swapped to become 80 20 or yeah i think you definitely go and have a read of the of that section in particular the documentation there's two different types of functions that you could use to change the weights there's a continual adjustment which would be used in the lbp pool uh which you have to set like a start block and an end block and it can only change the weights very gradually and that leaves the token balances the same so it's slowly changing the weights and slowly changing the price but you can also call us kind of straight weight swap but when you call that it does actually maintain the spot price so it will either subtract or add tokens from your balance and it's basically so that you can't be changing this the spot price when people have provided their liquidity otherwise you could screw people over so it's just to give people confidence in that itself you could do that yourself on like a private pool but other people wouldn't be able to provide liquidity can you have a private pool controlled by a contract a private pool yeah i mean i think that is basically what the smart contract is uh ours is just the the idea of the configurable rights pool is to have like a reference implementation and the trade-off between like a smart pool and uh the flexibility is trust so the the more you make it flexible the less likely people are to trust it and the less likely they are to provide any liquidity so the idea between the crp is to basically give people trust that this is an audited pool they can see what's fully configurable and they can trust to put their liquidity in there but yeah you can make it as flexible as you great thanks anyone else um let me just check youtube uh al hume says the documentation is really good by the way okay that's good yeah they were definitely um open to uh feedback or even pull requests and if anybody sees anything missing or if anybody thinks something could be added please let us know and we'll get updated because we want to make it as good as possible and that goes for everything like readmes things like that tests things like that so please let us know did you cover the specific prizes you're offering uh no i can't remember the deals for them off the top of my head i know we've got three different prizes i can't remember the values i think it's first second third yeah i'm just gonna pull up the prizes page or you can just if anybody has questions on prizes uh just go to the balancer sponsor channel yeah i'm sure the team will be able to answer the questions there all right well thank you again john like i said this was really really great um walk through of code and how people can actually use it so i'm sure hackers both in this session and then watching the recording are uh really find this helpful great thanks very much guys you everybody else for showing up and sticking around um a little bit later we do have the team formation session at 2 30 eastern so in 40 minutes if you're signed up for that or you haven't signed up and you're still looking for a team please make sure to attend if for some reason you haven't gotten a calendar invite just reach out to any of the team members and they'll give you the zoom link and then there are two more tutorials workshops later today there is the intro to reach which is a programming language and text style which is a tool for interacting with filecoin and ipfs so if you're interested in working with either of those protocols please make sure to rsvp and show up because they're going to be pretty awesome and then again more content tomorrow more content thursday and then the kickoff is friday starting at 11 so really packed week but we are looking forward to anything and everything um right we'll hopefully see you in 40 minutes if not at some of the later sessions today tomorrow or thursday thank you again john have a good day everybody's excited to see what you build bye thanks 