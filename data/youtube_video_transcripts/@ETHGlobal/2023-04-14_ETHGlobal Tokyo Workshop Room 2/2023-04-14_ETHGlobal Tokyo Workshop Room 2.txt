hey is this okay I don't know if is this better can you hear me if I don't speak into the microphone that's a good point I'm going to talk into the microphone for the audio quality oh just just checking is everyone here for the talk about Mina protocol and snarky JS Workshop room two because okay just because I know that sometimes people get the wrong rooms also so we've still got a couple of minutes um oh I don't have a time I'm going to timer on my phone that's stopwatch it's all right just I'll just keep a general eye on it and also I brought this prop with me this is some of the swag we have actual recursive bags so it's a bag inside another bag if anyone wants one I've got one here and we've got more at the booth so I I said this joke to one guy earlier and he gave me a a kind of laugh out of pity and then he said to me the thing about recursive humor is it's very repetitive so he actually made a much better joke than I did I don't even know if he uh if he meant it or not but I I enjoyed it I suppose I'll do a quick show of hands just now as well how many people here know what a zero knowledge proof is that's a good amount okay cool and how many people have done some sort of um zero knowledge programming before with uh me either snarky JS or or some other you know tool or language okay cool that's good to see so we're almost ready to get started what should I do as well like do I need to wait for a kind of signal it's is it like on the dot half past or do I wait for like a signal like we're live okay to start yeah okay thank you arigato um just start my timer as well konnichiwa everyone my name is Angus and I'm going to be talking today about Mina protocol and snarky JS so there's a quick introductory slide here as I said before my name is Angus madement and I am working doing developer relations for the Mina Foundation um I live in Edinburgh in Scotland and my Twitter is at blockchainbeard so you can follow me on there I also have a poll going for all participants of East Tokyo it's about how you um add people when you're kind of exchanging telegram information so I'd be really grateful if everyone votes in that poll I've put a prediction for what I think their outcome will be as a sha256 hash and I'll reveal it when the poll closes at the end of the day on Sunday so there's a funny picture of me as well blending into the uh the background of the sign in momina hoodie I've actually got the trackies on today but no hoodie because it's too hot so the structure of the talk today I'll first of all introduce uh like the Mina protocol and give you a quick intro as as to what like uh zero knowledge proofs are I'll talk a bit about ZK apps the kind of applications that you you can build on top of amino protocol bit of a deeper dive into snarky JS which is the typescript library that you can use to build zero knowledge proof-based applications and then I'm going to tell you about a program that we have got going at the moment called ZK ignite and also the next steps for how you can get started building stuff so the first section what is Mina Mina is an L1 blockchain that's built from the ground up using zero knowledge proofs and so to give a general introduction about what zero knowledge proofs are it allows you to verify information in a private trustless and decentralized way so that has a number of of useful properties that allow you to do things like create ZK Roll-Ups and ZK EVMS of which you know you might hear about from other uh people here at the conference you can do private transactions and keep data more private or or hidden in some way you it's good for for doing private voting it's got a lot of applications when it comes to Identity as well which is obviously an important aspect of like web3 and also you can can verify large amounts of computation uh efficiently so a zero knowledge proof effectively says that you can prove that a program has run in a valid way and that the output is valid um you can prove that efficiently so the it's it's it's fast to to verify the proof and you can do that without seeing all of the inputs necessarily you can do that just by using what we call the the constraints so that gives you options to give your users more privacy and security by keeping their information private and also has implications for for verifying things and scalability as well so just to give you an idea these are kind of like the the function prototypes or kind of declarations for some cryptographic Primitives that you might be familiar with a hash function you put a string into the hash function which is H there and you get out the hash which is also a string so you can tell that two pieces of data are the same if they have the same output from the hash function right there's public key signatures so you have assign function so you take a private key you can sign a message with the sine function and that will give you an output of a signature right and then you can verify that signature using the corresponding public key right and so you put that signature the message and the public key into the verification function and you get out you know either this has been signed by that private key or it hasn't right so then you can tell if a private key has signed you know like a message or a transaction with a zero knowledge proof right the way to think about it is there's a compilation step so you compile your program and then that gives you so you have some code you compile it and that gives you the verification key which is a string the key the verification key or index that's a string then you have a proving function you so you have the program you run the program with some inputs right you use the proving function to then generate the proof the proof is a string as well right and so then when you did the compilation step you get the verification key you use the proving function to create the proof then you can verify you take the proof you take the public inputs but not the private inputs and you use the verification key that create you created at compilation time you run the verification function and that gives you the Boolean the the the proof is valid or it's not so now what we're doing is you can verify computation not just that something has been signed but you can verify that a program is run correctly and you can keep some of the inputs private or hidden so you only need some of these inputs the public inputs so that kind of gives you an idea of how it's different to these other these the the zero knowledge proofs are different to other cryptographic Primitives and I'm going to talk a little bit now about Mina protocol which is as I said earlier a layer one blockchain that is built entirely using zero knowledge proofs now as I said before zero Lodge proofs you can verify efficiently and so Mina is a succinct blockchain it's been built using zero knowledge proofs so that it's very efficient to verify the state of the blockchain so that means that you can verify the state and and run a like a light node on a variety of different Hardware including a mobile phone so that's what that diagram on the left is saying it works using um recursive ZK snacks so because of like proofs to kind of Link the the states of the blockchain together and to to move it on that's what this diagram in the middle is signifying and so that's what keeps it lightweight as well the fact that these proofs can can be recursive you can prove the last proof you can kind of chain them together and the proof stays the same size it's a constant size and it's fast to verify and also it's interoperable in the sense that because you have this lightweight proof that you can quickly verify you can use Mina as a kind of ZK layer and then take the state of Mina and kind of verify it in other environments including for example ethereum to have it function as a kind of ZK layer for other blockchains or environments so this isn't just stuff that we're kind of uh postulating on there's actually a grant been given jointly by the Mina foundation and the ethereum foundation to this other foundation called the nil foundation and they're building um in evm Mino State verification so so in in the future when this is um ready to go you'll be able to verify the Mina state in an evm smart contract which is pretty cool because then you can do whatever you want Amina verify any VM and then you know do stuff on the evm chain I'll take questions at the end but thank you Jonathan um we also have the open Mina web nodes so basically you can run this this node in a web browser so when I was referring earlier to those that diagram where it says you can run a node on your phone you can actually spin up an arena network node in the web browser right so you could in theory submit transactions directly through the web browser without having to go to like a third-party RPC provider so coming on to to like what you can do with Mina the hackathon right is you can build apps on top of mina that use zero knowledge proofs we call them ZK apps and so just to introduce the concept to think about the concept of ZK apps ethereum uses on-chain computation so you write your code in solidity and then you put the actual code onto the blockchain and then all the nodes in the blockchain network when you say you want to to run a function in your smart contract they all run the code that they have on the blockchain and so it's verified by the fact that everyone does the computation right and gets the same result all the nodes on the network on Mina the ZK apps use off-chain computation with on-chain verification right so you do a bunch of com compute off chain and then you generate this proof that I was talking about earlier and then that gets verified by the network so this has a number of advantages one you can keep things you can give your users more more privacy by keeping uh inputs to the function private there's no gas fees in Mina so you don't pay for computation you just pay for the block space you do all the computation you want you generate a proof and then you put that proof in a transaction all you pay is the transaction fee there's composability using snarky JS our typescript library so you can kind of program your own ZK apps to to fit your use case and there's scalability through rolling up rolling things up with with this recursion that I'm talking about so the fact that you can use proofs to generate further proofs means that you can kind of roll things up and collapse them all down into to single proofs that kind of verify everything that you've done and also the interoperability thing through the blockchain being lightweight and quick to verify the state of so to explain that in slightly more depth just the process of it just to kind of help you get a mental model of what's going on when you do the compilation step that I was talking about you so you write some code that's going to be your ZK app and then you compile the code and that produces the verification key and so then you'd send a transaction to the meaner Network that creates a ZK app account so an account for your ZK app and that verification key is stored in that ZK app account right so now you have a ZK app that is is associated with this verification key that's on the network right now on the left hand side of this diagram this is your ZK app so you serve the ZK app to a user in a web browser for example right they run the ZK app with some data inputs that they put in to the the web browser when they run the app that's the program bit that we got out of the compilation thing that I was describing earlier so they run the program and it generates the zero knowledge proof so they generate the proof and they include that zero knowledge proof in a transaction the transaction gets sent to the amino Network and the meaner Network uses the verification key that you sent when you deployed the ZK app right and then it uses the verification key with that verification function with your proof and that then says whether this proof that you've generated is valid or invalid if it's invalid then the transaction is denied doesn't go through so that's kind of roughly how the the verification happens when you deploy you put the verification key on the network and then the network nodes basically check your proof against that key when you use the ZK app and create the proof so ZK apps are composed of methods right and methods you can think of as like functions uh in other smart contracts so there's this diagram on the right basically you have inputs and outputs to these methods right you can have arguments that go into the method you can have there's a very small amount of like on-chain state that you can manipulate and it says here are some values from the state of the world so that's you know another database that you have on your website or or some other thing that you can kind of control or change and then that's the input to the method that the method runs and then as a as a result of the kind of logic in it you can make updates to the state of the smart contract or you can make updates to some other thing based on something that happens in your method and so if you want to learn how to to write methods we need to go into snarkyjs Nike JS is the typescript library that you can use to define create and verify zero knowledge proofs so it's giving you as a developer the flexibility to build applications that use zero knowledge proofs without having to be a cryptographer or kind of a high highly capable functional programmer who can understand dsls in or camel I mean if you are into that sort of thing you should definitely still come and talk to us because you know it's all kind of under the hood but snarky JS is basically giving you the typescript interface that a lot of developers are more used to so here's some some logos that you might recognize so we have basically uh familiar tooling that you'll be used to we've got good intellisense support in Visual Studio which makes it the developer Journey a bit easier um and you can write all your tests in JavaScript using jest so this is five steps to show you how easy it is to get started the first one is to install the ZK app CLI tool which is yeah it's a CLI tool that kind of helps you with with building as in you know compiling uh configuring and deploying your ZK apps then it's one simple command ZK project creates your new project directory and actually has a demo kind of smart contract in there already the fourth step is to configure it with our kind of test net information there's also a step here where you need to go to the faucet if the force it's giving you any any trouble you can kind of come to the booth or message me or tweet at me and I can give you some some test let me know because I've managed to secure a supply of it especially for this weekend and then all you do is ZK deploy Berkeley and then you know that's it you've deployed your zika app so to program in snarky.js you also need to understand that we use field elements so these are elements of a a finite field which we use because that's how the cryptography Works in snarky.js it can store quite a large number up to almost 256 bits so it's a built-in type in snarky JS and it has built-in methods as well so uh down here you can see an example where you declare a constant called sum and then you make it out of two new Fields one of which is doing the dot add method to another New Field which is three so that'll that that sum will end up being four but it'll be a field element right which is what you need to use if you want to do things in snorky.js there's also some other built-in types uh including some crypto stuff so you've got public and private keys and signatures um and also like there's the there's a miracle tree implementation that you can use for things and these all have built-in methods on them as well so if you want to find out more about that it's all in the docs or you can use it uh intellisense if you use Visual Studio code that will tell you you know what the methods are so this is kind of an example smart contract that just to give you an idea of of what it looks like I thought I was going to have a kind of pointer that I could use so I'll try and point and I can actually refer to the lines so in line 12 you've got this state right kind of uh variable called num so you have a very small amount of on on chain kind of State Storage and then what what this uh is doing is this method down here on line 22 is saying we set the initial state to one which is a field remember because we're using field elements and then the update method on line 26 is saying check you know get the current state check that that is actually equal to the current state so you're kind of putting it into the proof that this is the state that you got and it's equal to the variable that you have and then it's saying add to to the current state so then this is the kind of this the demo smart contract that you get so it'll just every time you call update it'll update the state variable by by two so that's what snarky JS looks like also this is a the Mina colored theme that someone made for visual studio like the syntax highlighting so it's if you want to get hold of that I think we can maybe link you up to it but I'm not entirely sure uh so next steps recursion we've been talking a lot about recursion obviously making some bad jokes with the bag within a bag but one of the really powerful aspects one of the powerful features of snarky.js is that you can um you can do infinite recursion right so you can use proofs as input to other proofs so you can kind of roll proofs up into a single proof to verify that several things have happened with intermediary kind of proof stages so this is a diagram here of kind of oh here's a snark and then you put that into the next snore I can kind of the the proof stays a constant size the whole time so you can kind of infinitely roll up these proofs right and so an example that I was I'll take you through is in the case of a card game if you're player one you take your turn according to the the rules of the game you produce a proof that you've done a valid move you've passed that proof to player two player two can verify the proof they can verify that player one has taken a valid turn then they can make their turn they can pass the proof to player three player three can then verify that player 2 has taken a valid turn as well right and so in that way you can kind of go through as many hands of the game as many rounds as you want and then you can do it all off chain and then when you have the end proof that's kind of the end state of the game you can then put that onto the blockchain to show these three players have played 20 rounds of this game okay and so this is something that's quite interesting a lot of the time when people talk about Roll-Ups they're talking about batching transactions together right but no with Mina and Nike JS you can start to think about rolling proofs up together right and that opens up quite a lot of different kind of ideas and use cases so that's something recursion is something that that is really quite um exciting about about snarky JS and we'll open up new different ideas so here is the prize pool for Etho hackathon first prize eight thousand seconds six thousand third prize four thousand dollars and there's a two thousand dollar pool for kind of runners-up who don't get the top three but still submit a project that's built with snarky.js there's also this program called ZK ignite which I mentioned earlier it's a sort of cohort based grants program so you submit a proposal there's some voting and if you get funded you get funding for your project and also you kind of go through the process with a bunch of other projects so it's a kind of cohort like that and you get Hands-On support and kind of training and kind of community type things going on and so there's a new cohort starting on the 24th of May you can scan this QR code to get more information and one more QR code this is like the hackathon starter kit it's got a link to the documentation and also a couple other things so please come and talk to to us after this Workshop as well or at the booth which is in there I'm not going to try and describe where it is we've got a big minor sign behind our table though and so that is the end of the presentation thank you very much for being here we've got about eight minutes left for questions so [Applause] I'll take this question down here first so there's a verification keeper app for ZK app yes that means there's a trusted setup per app like uh that's that's a good question reference stream there is not a trusted setup per ah and so it's because the the proof system that we use it's called kimchi and it uses something that's like bulletproofs that uses the inner product argument to avoid the need for trusted setups don't ask me to explain it more than that because I don't know all the math but it's it's kind of the inner product argument um way of of it's kind of like a it's something that has has I don't want to call it a worker I need it I'm not sure the correct terminology but basically there isn't a need for trusted setups because they use this inner product argument methodology so so the the this verification key what is it it's a string it's an input to to each proof of the app so when when we're talking about the network the the verification key when you deploy your ZK app the verification key gets stored on the network and then the miner Network uses the verification key to verify the proofs so that the verification key and the proof going to the verification function and then outcomes proof is valid proof isn't in a Boolean does does use some prolonged light setup clunk light it's so the it says the the docs say the proof system is planck-ish right and also there's the meaner book which is a load of documentation about the proof system which has a lot of math and a lot of cryptography which I can point you to which will have all the answers that you're looking for thank you I'm sure so you you mentioned when you deploy a ZK app you store the verification key on chain and there's also some a very small amount of state that is on chain that is accessible to each of these DK apps is that correct yes how is the blockchain fixed size with that state I'm assuming there's not an upper limit to the number of zika apps that can be deployed on on chain so how can you store verification key on a fixed size blockchain without increasing the size the only limit to the amount of ZK apps that we'll have on chain is the imagination of developers like all of you also the blockchain isn't a fixed size in the sense that so the state proof stays a fixed size which you can verify the whole state of the blockchain from but obviously there's there's other things which kind of make up the blockchain right and that goes into how the mirror network works in the kind of different roles and entities that there are there's different kinds of nodes right that have different storage requirements but the fixed size thing so you may have seen this before as well it's a number of kilobytes the fixed size thing is the the size it takes to verify the state of one account and that includes the kind of the the overall State proof for the latest Block in an amino blockchain so this the state proof is what's fixed size it's not the state yes okay and so the but to verify the state of a single account it's a fixed size per account so and I think so then I think it would be if you wanted to run a node with the whole state of every account I think it would be n accounts times that number but I'm not sure on that gotcha I'm mainly dealing with the the ZK app stuff so but I'm sure we can we can get someone to to go in depth on the on the Node stuff with you if you like awesome thank you there's a question over here thank you it was nice presentation could you tell more about the vision of um ziki apps ecosystem what types of products you want to have on it like device some games or whatever that is a very good question so we've just run the first cohort of that ZK ignite program and the kinds of zika apps that were funded by a kind of Council of electors who were kind of community members the kind of things are getting funded are L2 Roll-Ups that do kind of batch things together transactions or um other other kind of bits and pieces But but so we've seen a couple of roll-up Solutions we've seen data availability Solutions so at the moment there's still quite a lot of infrastructure and tooling being built there is one thing was really cool actually it's a kind of verification app for people who get kind of different colored belts in martial arts and you can kind of check who has given whom each belt and things like that so that one was quite interesting I think when it comes to things like defy we because the computation model is different to evm quite a lot of the things that we think about um in defy it's not really defined how to do it on Mina yet so that presents to you an opportunity I think it's but also a challenge so you know you kind of need to figure out a different way to do things on Mina but then if you do figure it out you'll be the first person to do it so that's why it's both a challenge and an opportunity I think um but but we really are just getting started with ZK apps um so it's it's a good time to get in early thank you one last quick question and you can ask me questions outside as well I was just wondering where the proving actually gets done is it in the user's browser or is it somewhere else it's in the browser so yeah so I think we have like enough time to do this answer so you run a ZK app in the browser and what that is doing is running the program and then producing the proof and that's the proving right so you run the program you produce the proof in the browser and then the verification happens in the network okay I'll ask later about timing though does that have substantial lag or is it pretty quick or yes you're right that is a question for for more death later there's a lot of asterisks attached to that so thank you very much everyone though bye-bye to everyone on the internet [Applause] thank you hello okay oh um mirror oh cool awesome um okay uh hey everyone so um we are from Taiko my name's Dave I work on developer experience and this is brecht our big brain um uh so yeah Welcome to our our Workshop we're going to be talking about uh Tycho which is uh ethereum equivalent ZK roll up and uh we'll be giving a little bit of like a workshop on building a Dap as well uh give an overview of the bounties that we have and then also like give some insights onto like some cool things that you can build um yep so yeah like I said uh we'll just go over the bounties talk a little bit about Tycho ideas and then uh code base walkthrough um yeah so these are the different bounties that we have we have over 20 000 uh dollars in Bounty prizes that you can uh win so um we have best apps it's just like a smart contract adapt that you can develop uh infrastructure improvements some some interesting MAV stuff ZK Zone uh where you can work on some uh interesting ZK stuff uh protocol economics this would be like a kind of a no code Bounty and if you're if you're interested in like economics and like uh kind of dynamic systems I guess this would be a fun one um ethereum public goods um we find this one particularly exciting if you can do something that's just uh better for the whole space that would be really great and finally just a fun Bounty uh where you just can do whatever you want or think is interesting all right so um uh what is Tycho um so basically um like I said it's an ethereum equivalent ZK roll-up and if you look at this graph here you can see uh we have a few uh these two axes of like decentralized and centralized and ethereum equivalent and one that diverges from ethereum equivalence a bit more um and we're at the extremes of both of these axes where we're fully decentralized in terms of like proposing blocks and also proving blocks and then also we're ethereum equivalent in the sense that we don't make any changes to like the ethereum stack even more like peripheral things uh we essentially uh don't really change anything to make it easier to generate proofs um yeah another word for this is a type 1 zkevm if you're familiar with it um it's also L1 sequenced um if you're familiar with Justin Drake he made like a post about something called a based roll up which is using the L1 to do the sequencing so when you propose blocks um to create the Taiko chain we just rely on ethereum to do the sequencing um we're fully open source and MIT licensed it's a community project I think we have like uh 30 contributors on our uh mono repository on GitHub um and I think we have like over like 50 000 members on our Discord so we really like try to keep everything open and let everybody just you know help contribute we really like that um and yeah as I said fully permissionless block proposing improving the only reason I said permissionless here instead of decentralized is because um um because in regards to proving maybe the decentralization doesn't matter as much as it being permissionless um but I won't go into too much length about that now um Okay cool so next I'll just give like a run through of like how what the stages look like for the chain right like as as the chain is is moving on like what are the kind of steps that happen so yeah first you see here we have like these users um of the roll-up and they submit uh transactions to the the mempool and everyone is able to run a node right you can just go to our GitHub repo and you can spin up a Docker image and run a node so they're all running this node it's a fork of uh uh of Geth which is execution client and um basically those nodes can run as a block proposer it's just like a environment variable you can enable it and then after uh your proposer you just look through the transactions in the mempool and you can propose a block to um the contract that we have deployed on L1 um and yeah basically um at the time a block is proposed I think I kind of show this in the next slide we can already like build the roll up State like right after we've posted that transaction data um and that's because like um we have a really well-defined validity rules that we derive from the ethereum yellow paper um and and we do those validity checks to be able to compute the next state for the roll-up so you don't have to wait for a proof or anything like that at the at the moment a block is proposed the chain can progress um so yeah that's how we kind of derive the roll-up state um yeah so in terms of proving blocks you see here I have like these three colors like blue is like proposed and you can just like keep proposing blocks and sequence and then um in green uh you can see um is is when um you can prove a block right and really what that is is just proving one uh state to it to another state it's like proving that transition um but the reason why there's also this verified state is because it's assuming that the state transition um that you're proving is like has a valid parent or a verified parent so um the first block the Genesis block is already implied to be um to be valid because it's the first one so um it's only when all of the parent blocks have also been proven that we can consider a block is verified um yeah so you propose blocks people go around um and also this this block proving it can be done in parallel yeah yeah exactly that's that's a good question like so the next slide is like boom yellow yeah so yeah exactly um okay cool that was a great question um okay yeah so you can do all this in parallel and then like at the moment that they're all proven uh to Genesis they're all verified um okay now I'm gonna give it to brecht and he's gonna talk a little bit about like um some things to think about as they relate to our bounties um so yeah hey everyone um so yeah I'm going to go over the bounties like pretty quickly that's like there's like a lot of details that you could could go into but um but yeah that's like yeah there's like quite a lot of bounties oh suspicious all right I'm a bit smaller yes so yeah there's like a lot of like different bounties and okay to go into detail for all of them would be like uh quite difficult so I'm gonna be like pretty quickly describe uh some of the bounties uh give some extra detail but if you're interested in in them like yeah please contact team members and they will give you some more information afterwards um so yeah one of the first one is kind of like infrastructure improvements where it's kind of like the goal is to just like improve the usability of our chain and so there's a couple of possible uh tasks you can work on um one is for example the nft bridge so we created an RC 20 uh token Bridge ourselves and then eat Bridge ourselves um so you could depend on that as like a a sample of your NFC bridge but yeah our bridging is kind of like very flexible so you can basically write your own bridging smartcraft just by depending on like this L1 Black Block hash that we bring available to L2 and so our RS 20 implementation is like one of them that you could use but basically you can do whatever you want to to make this bridge and the other one is also like bridging related so currently we use markup position 3 check in in our smart contracts and the yeah the the positive thing about that is kind of like yeah we also like a type 1 equivalence and so this makes sure that we can actually reuse a lot of code that other Bridges already used to do that but the downside is that it's quite expensive because the Merkel Patricia 3 proof is like quite big and also the verification costs in the smart contact is also like pretty significant and so we we can try to optimize that by instead of doing it in a smart contract we just wrapped the Mercury micro Patricia to the check in in a CK circuit and then we just have to verify this circuit plus a small proof and so we kind of like balanced out the the proof size uh like the data size compared to like the the computational costs and on R2 the competition cost is kind of less significant than the data cost um yeah and the other two ones as kind of like more uh UI related um so one of them is like yeah we have like a L2 block Explorer and currently it doesn't like add some of the ziki stuff to it so for example it doesn't show you if kind of like a block is proven if it's verified and so it would be great if users can actually um yeah see that as well on the black explorer um another one is like yeah we we want as many people as possible to be able to run the proposal uh it's it's kind of like necessary for like the decentralization of our block production is also necessary for some of the centralization of our uh proving um so yeah it's it's important that it's as easy as possible for everybody to run a note if they want to uh the only one is kind of like the general like block like protocol proposing improvements and so here the goal is mainly to improve the efficiency of proposing blocks um and so yeah one of the first tasks is kind of like improving the block proposing cost estimation um so the difference is like we we really try to be as much as possible to like like it here but the difference between L2 and L2 and L1 and nl2 is that proposing a block on L1 is completely free it doesn't matter like how much data it costs like how big a Blog is in terms of like data and things like that and for now too this doesn't matter because we actually have to publish the data on the L1 and the costs for some of these resources that we use on ethereum is also like time dependent um and so that's kind of like one of the more challenging things it's kind of like okay proposers want to put blocks on rl2 but uh yeah they still want to make a profit and so they have to have like a good strategy to do that and so for example transaction data needs to be included on ethereum for us and so that that takes data on the L1 blockchain that cause gas and so that needs to be taken account if they want to be profitable and the one thing is also like what they've uh mentioned is like we have like a base sequencer and so we kind of like depend on the L1 to do our sequencing um but yeah if we have like no extra mechanism on top of that that means like money proposes which submit blocks at the same time and that would mean that many transactions would actually fail and like waste gas because like yeah many blocks with like many proposals would submit the same block and they would include the same transactions and obviously that would be like very in uh like an inefficient um so the way that we can improve that is to include flashbots which allows us to the proposes to say like okay include my block only when it's like successful and then all other blocks will not be included but that's great because yeah they don't want to be included they have another one uh but another Pro browser is faster than that is kind of like more exotic so one of the things is that Taiko protocol allows is kind of like this shared sequencers because the our current protocol is kind of like already falter and tolerant so that means that a shared three controller does not need to have like the full State available of all the l2s because it's okay for us for a sequencer to include the transaction this is actually invalid um so the protocol is skip over it it's kind of like inefficient so you want to avoid it but we can fully support that out of the box and the other one is also like a similar to that uh so for the base sequencer we kind of like want to use flashbots to include like for the browsers to include in the in our L2 blockchain the other one is like yeah if we have an L2 then there's also like math to be exploited on the L2 um so being able to also have like this map boost availability uh on the L2 is like a very useful for proposals to make money uh and like optimize for that um and the last one I'm going to talk about is like the protocol and economics um so yeah the goal here is that the economics need to be like simple and and robust and so like there's like two main fees that need to be paid one is if a proposal submits a block then he needs to buy uh block space it's similar to like uh the ethereum uh eip1559 the other one is that if you create a block the there's also like an extra zero knowledge proof generation costs as a suit associated with it and so that's the the two main fees that need to be paid and for the for the EIP 1559 on the proposed side it's very similar to like the ethereum one but there's like a couple of differences for example instead of like having a fixed block time uh there's like no fix bugs on R2 and also like it depends like the L1 mechanism depends on like this uh variable block size uh which we also don't want to support because it's uh less efficient um and like the final one is like the the proof proof um so the proof is generally paid by the proposal um but it doesn't have to it kind of like depends on the mechanism there um so yeah there's some some ideas on yeah how the proof of peak could be paid um so one of them is kind of like a race uh where like the first that's submitted is actually gets a reward and for the the auction based is kind of like depending on how much the approval wants to pay and uh how long the proof generation costs uh like takes uh well we will not and the final one is also like an interesting one where the proof like a proof of stake mechanism where the the uh sorry where the it kind of like depends on how much each prover gets like thank you sticks or something like that and so then we can just uh use like statistics to give some of the uh the uh like depending on how much it sticked we can actually assign blocks to them but yeah that's it okay cool um yeah a lot of fun stuff there um oh crap uh all right we're good um all right so yeah the next one is just going to be like me uh using uh open source tool that I made which is called dap slaps so basically the idea is that you can just uh in one click bootstrap your dap um and I know there's a few variants of these but I tried to make it uh fairly unique so um in this in this in the technology that's used like it uses svelte it's a mono repo configured with Foundry um and uses a lot of like kind of the latest tooling to give a really frictionless uh developer experience and uh yeah basically the idea is like just want to help so that you don't have to waste too much time like trying to like build your dap and just get uh get moving on like writing smart contracts or doing something like more fun um so yeah you can scan this QR code if you want to check it out but aside from that I'm basically just going to like you know emulate what you would be if you're using this tool and like just set up a dab with it um yeah so let's see here okay so uh this is the repo um this is the button um yes you just connect your GitHub I'll just call this blah blah blah blah blah um so yeah it'll deploy it like on versel um and the only thing that you need is this like one environment variable which is like a web 3 modal project ID um I'm gonna get one online I think it's uh let's see here I think wallet connect cloud okay all right yeah so you just create a new project here um and then it'll give you like an API key um I'll just copy this and I'll add this and then okay technically two clicks I guess all right this might be like a little awkward silence just because uh it needs to like build um I don't think it'll take too long though let's see if it uh um see if it cloned the repo at least on my profile oh there we go Okay so all right as I'm waiting for this to build I'll just like clone the repo and then like maybe we can see it locally um so you can just like follow these steps they should be like very fairly clear in the readme um yeah so I'll just go through this um maybe increase my font size okay so just cloning this and then what are the next steps um yeah it doesn't like clone the sub modules so you have to like uh do this one Forge install um see here oops so CD into the directory uh do this Forge install um if you need to install Foundry there's like a link to it here it's like fairly simple it's I think it's just like a curl command um and then yeah you can just run this setup script um and this will just install the node packages and also install the forge dependencies um okay so next step would be like generating this uh bip 39 mnemonic and you don't have to do this but I just kind of recommend this if you're hacking because you might want like multiple accounts like multiple addresses so and you don't want to like use like your main one so you can just create like a bib39 mnemonic and uh use that and basically you can use this as an input if you're not familiar with Foundry you can run like a local ethereum node and you can just send in the bip39 mnemonic that you generate here and it'll just bootstrap the network with these accounts and give them all like a bunch of eth um so yeah I'll just create that um and then we'll set that in the environment file there's a single environment file um we'll just put this here okay Source the environment file and then I think that's it yeah okay so I have I have three Windows here uh the reason for that is because uh we'll use one window to start the local Anvil chain we'll do another one just to like I don't know um do random terminal stuff and then the last one will just be like running the front end of the app um is this done yet okay cool so this is done so like I said you literally just need to do that like two clicks I guess and then um you can go and like um it'll be deployed so you'll just have a fully functioning dap that you can use um this doesn't use like any like weird it's like very minimal like I don't didn't put like any CSS or anything like that it's like a single file you can just rip it out and just use HTML and it's like it's just very minimal um so yeah um this is the this is the DAP but we'll get back to working on it locally um okay so I sourced the environment file now I'll just follow these three steps for these three Windows I'll start the local Anvil change with the bip39 mnemonic and you can see here that like it gives you all of these um accounts that you can use along with their private keys so you can just like take any of these uh these private keys and you can just like import them into metamask um so that you can like use it in your application um I guess I'll just do that as well okay cool I don't know why it says Supply youth but um all right so I started the local Anvil chain that's good now we can interact with that uh the second thing I'll do is like I'll run this script it's a deployment script just to deploy like a kind of a dummy smart contract uh to that local Anvil chain and also it uses like wag me to generate all of the uh the types so it's like fully type safe when you like interact with the contracts um [Music] values required for four qrl or okay so it's probably because I need to go in here yeah I didn't Source my environment file so I think that was the issue um okay cool yeah so this is just compiling the dummy smart contract I'll go through the folder structure too so you can like kind of see but this just um compiled and deployed the contract I think we should have gotten a receipt yeah this is like a transaction receipt here um Okay cool so now we'll just start like the front end of the of the application um I think it's pnpmf F all right we can visit it on localhost um yeah this is the application and let's see does this work okay cool so it says like I'll just show what the the contract looks like so basically like I said it's a mono repo like one of the folders has all the foundry configuration the other folder is a spelled front end um so in the contracts folder like we can look at the contract I just deployed it just said like Hello World here and the cool thing that like this has integrated is like if I update this um actually yeah if I update this and then I redeploy the contract right um it'll just like update uh the contract address which is used by the front end and like now you can see here's like the new message right so like hopefully this can give you like really rapid development you'll need to like change contract addresses or anything like that um it'll just like update all like reactively um okay so also I want to show here um okay yeah so like I said there's this Source contract folder there's obviously like a test folder if you want to like run write unit tests while you're hacking but that would be kind of weird um there's this um uh this is the deployment script you can see here there's where it's deriving that mnemonic um yeah creates a smart contract um this broadcast uh folder has some uh like metadata from doing the the deployment um okay cool yeah so this is just like you can just like interact with a contract here um yeah so it's pretty simple it's just it's just a dumb like uh dumb uh smart contract I don't have enough Supply youth okay um but yeah I'll show one other thing really quick I guess I only have four minutes here and I want to be able to answer questions too so like uh we we have one page where uh we integrate the Taiko signal service so Brett talked about that a little bit uh it's really because our protocol is like ethereum equivalent and we just use like uh Merkel Patricia tree for the state like we can just send arbitrary messages using Merkel proofs and the signal service is a contract that we like exposed where you can uh do that miracle-proof verification easily so if you want to do that thing like build the nft bridge or do some something related to cross-chain messaging then you can just use this as an example on how to interact with the signal service um okay cool um so let's go back to the slides um yeah so yeah big thanks to everyone for like coming here and like listening uh uh I think this is I think uh Taiko is going to be like a really interesting thing if you don't have too many ideas for the hackathon uh we actually have like 20 people here uh in Tokyo which is pretty crazy and I know that we're all like really willing to just talk about anything so if you don't like know what you want to build like it's like there's a whole playground of things you can do like whether it's like economics building adapt like doing something that's like not even really web 3 related and writing some scripts to run a node like I think we'd all be down just like stop by our booth like we'd love to talk to you about anything and help you build um yeah so I guess now like uh does anyone have any questions my RuneScape username it's a Dr Super Fresh [Laughter] so for a block proposers for Taiko is it just like first come first serve for whatever hits the smart contract first on the L1 yeah anyone can propose blocks at any time but it's up to the L1 to decide like how those are included or when they're included they decide to like pick up that proposed block up to like the L1 validator or like the whoever's proposing that all one block exactly exactly yeah it makes sense yeah what do you view as the most important trade-offs to optimize for economically in the system Brad do you want to go for that one maybe a better like what maybe like what are the most challenging things you've encountered so far well we we kind of like want to narrow the problem down as much as possible so what we do is not change anything to the ethereum protocol itself uh but we yeah instead we have to really optimize our circuits and our general knowledge proof generation as much as possible because yeah if it's too long then transaction costs would go up which would obviously be a bad thing um so the trade-off here is kind of like you treat in some of the efficiency for like a full compatibility full equivalent and so it's even easier for developers to develop on but then we have to do our job to yeah make it as efficient as possible okay great thanks you have questions on the Block finality is that instant we have to wait for confirmation it's instant as in when the block is proposed and it's included in ethereum Block uh the it's fine last um so that means that the the transactional order is fixed uh everybody knows what the pre-state and the post date will be uh it's just like that the the information like the post state of that block is simply not known yet by smart contracts but anybody that's running a note and is just looking at the data as it comes in in the roll up smart contract you can execute those transactions know the boosts it so they know exactly what the state is and once it's in the smart contract that means that it cannot be changed anymore so once it's there it's fully finalized cannot be changed everybody knows the state except smart contracts and smart contracts that's why we need the Xeon launch book um so zero knowledge proof is there because we also want to let smart attacks know what the latest post it is without having this markup itself execute all those transactions so I guess in in practice we don't have to wait for any confirmation then no no you don't have to so it is it's just for it's just for bridging where like a smart context needs to know what the L2 state is otherwise everybody else knows directly when the block is proposed what the what the latest state is sorry another question do you do you support or we have plans to support a privacy programming feature as in Leo or you know not not on our layer too so if you want privacy you'll have to run it as an L3 on orator yeah thanks everyone [Applause] yes all right awesome let's start GM uh I'm flywheel this is Miguel and we're gonna talk about world coin today um so in case you haven't heard about us World coin the shiny orb uh and World ID the identity protocol that we're building um it we're gonna start with a little bit of the story um so obviously uh the world is changing very fast uh we now have uh some amazing stuff coming in uh AI robotics uh you name it right uh and it's becoming a little bit more of a problem of what is actually human and what are actually Bots online right uh we're starting to see how intelligence is really no longer a discriminator online um and these sort of problems start to come up right um particularly um in the exciting world of AI and with all of this advancements um it's getting really hard to know what's real out there uh how do we make sure that um value is fairly distributed uh and that we're prioritizing humans right um so all of this comes to personhood why did a person who go away about personhood uh I'm sorry about that animation uh all right it's not a demo if something doesn't fail right uh but personhood um so this is what it's all about um world ID uh well we're gonna talk about you today is about personhood and distinguishing real humans in the digital space um so World coin uh this is the goal of world coin build our largest network of real humans and we're doing this by giving away the ownership so um we are launching the worldcoin token uh which will be distributed uh to every human on the planet just for uh being humans and we're doing this because uh we can do personhood verification and ensure that a single person can only claim their share ones um and of course you run into the issue very quickly how do you know who is a real and unique person right uh we've all seen this before civil attacks uh quite easy to um replicate yourself and make it look like you're a hundred people um and kind of like game the system so we this is uh the problem we started to solve and that we're now um offering uh in an open protocol for anyone to be able to leverage um for worldcoin we want to do this in a fully private inclusive and uh robust way so what does this mean is we want everyone to be able to have access to this we want all data to be uh private super serving and capped in the ownership of users and we wanted to scale Beyond a billion people so we explored a lot of options um all of this uh turn out to be invisible I mean email or phone I think we can all create right now a thousand of them very quickly um IDs is a lot of uh people turns out don't have IDs uh you'll run into a lot of issues with um the different types of IDs forgeries all of this uh web of trust is actually a great solution once you have a trusted seal seed of um uh humans but then how how do you bootstrap this um and then that leaves biometrics So within the realm of Biometrics of course there's several options right uh and these are just uh uh some of the options that we explored um but again we ran into different issues you know fingerprints uh it's easy to spoof uh remember here we're trying to demonstrate that you're a unique person uh not that you are you so when you're for instance using your fingerprint to get into your office you are just demonstrating that your fingerprint Belongs to You whereas here you know I could very easily like make a little cut in my finger and now I'm a different person um face is doesn't have enough entropy to recognize uh Beyond like uh billions of humans uh DNA is um very intrusive very logistically complicated uh not a good option so that's uh that leaves Iris and that is how the orb operates uh through the entropy of the eye Iris um then next problem is all right uh we know that we can use Iris to recognize a billion humans how do we get the entropy of the iris and then again we have we went through different options and I mean the tldr here is phone uh sensors are very um very varied and most of them don't have the the resolution that's needed to to extract the entropy to distinguish a billion people and even then you get into issues with uh trusted Hardware right like how do we make sure that you're not um using a rooted phone that's feeding false data and that's why we ended up building custom Hardware which is the ORF yeah this this was a little bit of a long time to build but here here's the output um this little guy here um as you can see we we went through quite a few prototypes uh all the way to this is where we are today and a little bit of a sneak peek just for you guys if we're we're gonna be tomorrow um this is already uh we are in test phases for this uh this newer version uh the the whole idea is uh this um these ores are um uh produced to be in untrusted environments and very easy to operate so that you know anyone can uh comment to the verification and walk away with their verified World ID um the ORF those these three things it makes sure you're a real alive person uh make sure that you're not doing anything fraudulent like for instance that uh it's not like two people standing uh close together uh Prosthetics uh you're not wearing glasses or things like that that would um interfere with the entropy of your iris it checks that you're unique and it verifies your world ID and this is your world ID um so World ID you can think of it as a digital passport uh that lives in your phone is completely self-custodial uh World ID is based out of uh uh keeper that is created on your phone only lives there and uh it's very uh the public key is what um gets inserted on chain once your identity is verified um so beyond personhood uh because your world idea already recognizes you as a unique human more more credentials can eventually be attached than issued uh within within your world ID protocol right so today we are supporting the ORF verification um and we are launching a beta for phone verification so kind of like the two ends of the proof of personhood Spectrum but the protocol is completely um decentralized and agnostic so we ambition very soon other credentials will start to show up and and issued by different um different different parties um the world ID protocol so these are these are the guiding principles for the world ID protocol first and foremost is privacy first it's not like uh uh privacies and afterthought is if we start with privacy and we'll talk about a little bit more uh about privacy in a second it's completely decentralized the source of Truth is on chain it's a smart contract and that's it um permissionless and all of it is all of it is open source um the um the hardware of the orb is already open source as well uh you can already check it online and we'll continue to open source uh the software and everything else because um that's what it's all about uh um so how can you use World ID there's two way there's two ways to use World ID you can use it as a signing mechanism signing with worldcoin very easy or we have an advanced version that lets you do what we call Anonymous actions so sign in very simple you know you add a button in your in your app in your website sign in with worldcoin and the user authenticates using their word lady the the benefits that you get is you get this credential on How likely the person authenticating is to be a human because they've either verified on the North or they have phone verification right so um as more signals get added then this this can become a continuous spectrum and let you verify the different levels so if you're building I just heard an idea about a dispatcher and that that prevents civil attacks and Bots yeah you could do something like well if you're or verified will give you 100 transactions an hour but if you only have phone we'll give you five if you have nothing we'll give you zero right it's kind of like it can be thought more of a spectrum as uh more than binary Anonymous actions is for a little bit more enhanced privacy use cases for signing with worldcoin the the person verifying will always give the app the same identifier to make sure that you know you're the same person uh authenticating for anonymous actions you can actually generate different identifiers for each of the actions that the user is executing so a good example of this is boarding right so say you're building a boating platform you want each proposal to be voted only once per person but you don't want to be able to link boats of the same person across proposals so if I vote Yes to proposal a and no to proposal B you we never want to be able to link those votes together so what we can do is each of these proposals can be separate actions and therefore like privacy preserved across all of this is accomplished because whenever you're using World ID you do so with zero knowledge proofs and the serial knowledge cryptography is what um is one of the biggest privacy components of the entire protocol you cannot use uh the the world ID credentials without going through the zero knowledge uh proofs which make it impossible to track users across applications or to um kind of like break the Privacy there um yep you're good I'll leave you with Miguel to show you a cool demo yes so first of all I'm just going to speed through this because this is basically the fallback if the internet breaks but we're hoping that you'll will be able to actually demo these in real time but as Paul was saying um the really cool thing about wallaby is that it works on same and it can also work um often if you need to we have an API it still goes insane either way but the really cool thing about this is that if you're completely new to web3 which I think some people here might be or also developers that are not really that into crypto you can still get the full privacy guarantees that Vulcan provides without any of that and it's also really really easy to integrate I'm going to show you that now so first of all I'm going to go really fast here because we're a little short on time but everything that I'm saying here if you go to docs.walker.org we have an excellent documentation that you can look into it will explain how to do everything I will like jump across it right now but yeah basically anything that you miss it's going to be in there and there'll be a link at the Indian presentation as well and a QR code and everything so the demo that we had the screenshot here is teddypt I feel like at this point anyone knows it this is not the official sativity it's a clone that we made just to Showcase how easy it is to integrate along with wilcoin so in this case we are using uh auth0 which is a platform that allows you to provide authentication services and it's actually the same one that open AI chooses and the really cool thing about all of these is that it took zero lines of code to get this to integrate with Vulcan because signing with welcome uses the same standard that signing with Google signing with Twitter signing with apple uses meaning that if you have any kind of package or library that supports any of those like passport uh Super Bass alt zero any kind of code that connects with those you can probably really easily make it work with working as well and so the way that this works is the user will click continue with wallcoin then that loads up a QR code and then on the user's phone they would go to the wallcoin app here and then they just click the little cure at the top and scan the QR code um now you don't need to actually get scanned to download the app you can use the phone signal that Paulo mentioned if you don't want to get scanned for any reason and if you cannot get a hold of us also for like the stadium environment kind of like the test net you don't need any of these at all you can just go right ahead but I will get this pop-up on my phone um and as I click verify it will generate the signal it's proofing my phone send it over to the computer and then uh I will be on um logged in and in this demo basically we just like add a little human mode as a joke again this is not a real sativity but again signing with vulcoin zero lines of code to implement you can obviously do it with code but you don't need to which is the really cool thing for a slightly more complex example and basically um we have Anonymous actions and as Paula mentioned Anonymous actions are more usually for insane use case or use cases where you don't really want to persist I know who this user is and more want to let them do well Anonymous actions so for example let's say that you're making something like I don't know curious cat or any of these platforms that allow you to like ask questions anonymously or both on a proposed anonymously you still want to prevent spam or prevent people voting twice but you don't want to kind of like break the anonymous thing you still want to be able to like have these people ask questions or both without revealing who they are and so if you did sign in with worldcoin sure you would not know you would not know who the expression is but you would know oh this person who I don't know who that is just like did these five things and as they do more and more things you would maybe be able to start learning some things about them like who your friends are or what kind of proposals interest them Anonymous actions cannot let you reduce the anonymity pool to a single action and what that means is if I have a platform I could make Anonymous action for its proposal and So within a single proposal when someone is submitted about icann on trainer often figure out has this person bought it here yet which is kind of what you want um but when you are doing something like a different proposal if you're running a different proposal someone votes and you have no way of knowing these two votes from different proposals come to the same person it's Anonymous so there's no way of knowing um as an example of uh how these might look like we have this lens integration that we made a while ago that basically lets you mark your lens profile as belonging to a human and ideally this would help reduce spam or maybe be taken into account when they do machine learning and if we go to the repository for that and the smart contract and I'll try to keep this very simple so people that are not into solidity don't get scared um basically the way that this works is we have a function here verify and this will get the profile ID this is like the arbitrary argument that I am passing let me make this a little bigger uh the arbitrary argument that I'm passing and then these three arguments that Vulcan yes gives you and again this is on the documentation we have a starter kit which with everything that you need to get started here and so basically the first thing we're doing is we're calling the verify proof metal insane and this will just say is this proof that the user has gave me valid if it's not the transaction reverts nothing has happened your code doesn't execute so you don't need to worry any of that after it works here's where you would usually say like okay has the user done this before in this case we don't want to make it so that you can only do this once what we want to make sure is you have only verified your profile once so if you have already verified a different profile we will first um unverify it and then verify the new one in this case we're using the this ID in this Anonymous ID that you get from the anonymous action instead of just like by taking true or false has they done it before more to um store the idea that they have refiled and reverted so it's more of like an advanced use case um on the website side um we have this Library called um idkit and it's basically it's a JavaScript library we add react components but if you're using view spelled something else you can still integrate with it and basically just gives you a component here where you can pass an app ID that you get from our developer portal we give you a QR for that in a second and an action which is like a text description or whatever action like voting and proposal whatever or claim nft Tokyo and then just an also sex unsuccess callback and basically what this will do is we'll open a model with a QR like you saw me do before and then when the user completes that you will get your serialized proof on this result part and this is the part that you need to send to your backend or yours my contract for verification whatever you are and again I'm going to reiterate this because on previous hackathon some people usually just like console.lock the proof and get it done you actually do need to verify this like someone could just like inspect element saying some stuff and actually get your proof that is not valid so you do need to verify it ideally not on the front end so again if you have a smart contract that's the place to do it if you don't have a server an API somewhere verify there very important otherwise it's not civil assistance uh and yeah basically you as I said as I mentioned before have all of the things that you might need here if you have any questions you can go find us in the booth we also have a little like utp4 powered chatbot here that you can use uh so if I were like how do I verify proofs on Thane it will give you the answer and the correct basis so if you just like have a short question you could do that or if you have television as everyone does these days and you have the plugins beta you could also use that to ask the same thing and it will have access to your logs so again trust humans more we have a Discord Channel we have a on these Global Discord and that will actually answer all the questions there we have a booth over there it has like a nice purple shade so you can find it really easily you can also come find me really easily I feel like but yeah you get you get the idea again yep before my computer dies and so as I said uh before this actually has a lot of really cool use cases the main ones that we have highlighted are both in our two resistance you know but for airdrops to teacher you know like the unquote Terrace Landing uh nfts in general consumer incentives I mean this is a hackathon you probably have a lot of ideas but you can use it for almost anything and yeah we as I said before the docs that have everything also have a list of suggested use cases that you may want to use for inspiration uh we have 20K in prices I'm not going to read through that you guys know how to read and it's also on the website and on the key on the starting kickoff that we're going to do later but basically like choose whatever suits you best and yeah uh as I mentioned before we have a developer portal that you can use uh that's the QR code if you don't manage to get it here come to the boot later we'll give it to you it's fine um but yeah this is like this unlocks the developer portal that you need to use to in order to integrate it to have like a nice image so next to your demo in the app all of the cool things I'm going to wait for like another second for everyone to take a photo um yeah otherwise again come to our booth we'll give you the QR code and yeah all of the resources that I mentioned and even more that I didn't mentioned like starter kits more ideas all example products that we have code for frontium back-end are at walker.org slash is toky23 so really easy to remember URL go there you have a note here an ocean page with everything you will ever need again any other questions that you may have come to us on our booth ask AI whatever you want and also it's like a little thing if you want to see a demo of the anonymous actions you can just like come by your booth and ask us about uh worldly and we'll just like give you the page to claim a nice NFD using Anonymous actions so you you do need to like get on board with your in order to do this again we're like demoing the thing but if you want to get a nice nft and try out the experience feel free to do it yeah that's that's about it this is already it solves the whole civil system issue that we've been worrying about for so long that is becoming more important even now with AI also a really nice Anonymous identity solution for anything that you may want regarding privacy and yeah it's here and feel free to use it now I hope you have a good time do you have time for questions yeah so anyone have any questions hey guys it's not well thanks so much uh just a quick question okay now it works um what's the typical proof generation time and proof verification time just out of Interest so verification time on the on teen is whatever it takes to mind a block because that's what our transactions take on ethereum well this is polygon but well transactions taking polygons so I would say like a few seconds I don't know the average block time but like I don't think it's more than two seconds uh proof generation it's usually not the uh issue at all the issue especially in hackathons is how much does it take to send it over because Wi-Fi uh but like definitely less than five seconds usually less than two it's pretty fast it also depends slightly on the phone that you use you have like a very very old uh Android phone specifically they can take like maybe five seconds or so but like we've seen that in general like the blocker is more sending the data over more than generally in the proof because you just like doing math on your phone foreign so I only need to verify myself once either with the orb or the mobile and then it will be with you forever yeah basically the way that it works is you verify yourself once then you have the key forever um if you have the phone verification and you want to get your you have to go to the orb uh the phone is more of like uh what we call weak civil assistance because I mean it's not that hard to have multiple phone numbers I have to but it's like harder to get like a hundred or a thousand or like multiple thousands so this is why uh on apps recommend to like are like tears and kind of like give less access to the phone and more to the oracles your easier is to prevent spam well I mean spammers can get phone numbers but they can probably not get large quantities of them so it's more of like this orb is not everyone in the world yet like there's one in my city there may not be one on yours so it's more of like a temporary thing where it still gets you integrated with all coin makes it really easy to support both and then ideally at some point as we have more signals you have like a more complete picture of like how human this person is or like how human do we know this person is ideally every person is human but yeah you get it uh but yeah basically you verify yourself once either with the orb or the phone number you have the proof and the key forever if you want to kind of like update your verification as in like you have phone and you want to like go to an orb you can do that but you don't need to like have an urban home and scan yourself every day basically sorry just last question so everything of my personhood will be on chain as my word ID what's the likelihood of I mean what's the worst case that someone had it how easy it is right the your personhood is not really insane what is happening with the orb or the phone number is your phone you know it's a private key which is like separate from your wallet private key and this key will be used to kind of like sign these proofs of personhood so basically uh on chain there is it's like kind of like the equivalent of the public key of this property that you have uh so in really there's like nothing on saying of like your personhood in a way same for the phone numbers the phone numbers are hashed and likes um and you just like store the public key the phone numbers are not given to the apps or put on chain and so basically the way that we've done it the worst case that could really happen is if you somehow manage to like export your private key and give it to people um which is not supporting the app yet but at some point maybe we'll let you export your wallet private Keys then at that point that person could like generate proofs and then by that point we will have a way to for you to go back to an orb invalidate that can generate a new one but basically there's no risk of like you even even doxing yourself so it is pretty secure yep thank you so much hope you have fun [Applause] foreign hey guys uh do you hear me um sorry for the small delay um so uh today um it's kind of actually it's a long workshop and I'm not sure I can handle everything in 30 minutes but I will try uh at least I'll try to explain what the Spanish fusion and why it's so like what's what is the hype about on infusion and how it works under the hood but let's make some small recap for this one inch firstly so basically one inch is a it started as a hackathon project at ethereum New York at 2019 by almost five and a Half Men right now we have about 200 people uh we have a lot of metrics we have billions of volumes of dollars on multiple chains uh we actually are one of the largest deck segregator on the market we also have multiple other protocols like limit order protocol we do have a niche wallet actually it's a list of protocols and you can take a look on some of them here and one of the most popular one right now is limit order protocol Advantage Fusion uh also we do have a niche Pro that is probably for institutionals that provides kyc and ml policies so let's make some intro about what is one inch aggregation product obviously maybe you heard that Financial is Dex aggregator and actually it's true we do have API for aggregation information on that access how basically that works let's imagine that you want to make a swap on the unit swap and in this case let's imagine that you want to swap for example 100 ethereum to some amount of die and what will be the problem that you will have potentially that if you will use uniswap they actually use specific price like pools liquid easy pulls to make the transaction like like to make a swap and of course you will have some price slippage what is the best like idea how you can have the like potentially the best lowest possible slippage in this case you need to have multiple pools and try to split your 100 ethereum amount to some small parts uh it can be it will rise how small it is but it we it must be like that small that the price slippage in each pool where you will try to make a swap will be almost zero and you need to do all of that inside one transaction so basically it's how varnish Works under the hood as of an inch Dex aggregator product we basically split oh yeah if you want to spar for example die to one inch we split amount of dye to some small subparse and split this subpars to another sub parts and try to Route all these and emulate all of that logic through multiple liquidity pools for almost each Decks that have existed on ethereum chain for example on a binosmart chain and trying to find the best option to get the max return and have the lowest gas for the user that's like pretty basic right now and most the guys aware of it but I just want to remind that how it works and the main feature here is that it happens atomically so for example if somewhere price goes wrong we have some designed minimum amount that you will need to get if you are not okay with that the whole transaction will be reverted so basically you are protected from any Edge case that can happen during this swap uh but the main problem here is that if it's a one Atomic transaction and in some cases for example if it's some coin and you some sometimes everyone needs to swap some coins in this case uh if you have a lot of them you can have a really bad big slippage it doesn't matter how much the access you use because liquidity for some coins can exist for example only on sex or on other chains and if you are doing that atomically that means that it's impossible to aggregate all of that liquidity in one Atomic swap you need to wait a bit for the for make to make it in this case uh the limit other protocol can help you what is the limit other protocol it's quite the same as basic limit orders on any attacks but it's completely decentralized so basically you just sign a specific structure that you agree that our smart contract can withdraw the tokens from your account and fill it with uh by using specific function and get some tokens instead basically make a swap and anyone can use this function and they just need to provide specific instruction from your from your site it's a signature and data which contract they need which which token they need to withdraw basically limit order protocol allows to make a gasless transactions on your own site I mean you can make a gasless swap for example in this case you can just need a proof for example for the die to the Limit order contract and make it like a and make a limit order for example to sell die for ethereum and anyone can actually fill this transaction on behalf of your like user and in this case basically not user is paying the gas but Market actually Market maker architecture is paying the gas uh it's a cool feature but the problem here is that it's specifically very specific price condition here it's fixed so that basically means that if price goes wrong you can wait for like four hours or four weeks to get a good price to make this order executed if people try to say in their tax determines it's quite it's like market sell there is no market sell here it's only limit order and you need to wait there is no any guarantee that it will be executed even if the price will be the same as the market price for example what if you want to make something on the market price but we want to make it like limit order is it possible in the defy and actually that's what the question what we have and right now we can say that it's possible it's actually sorry actually it's the solution what we make with the vanish Fusion we want to make something like market price sell at the same time it must be like Atomic it means it must be limit order Inspire it must be gasless it must be protected by from Mev attacks all at once and that's what is Fusion actually it's a fusion of multiple protocols at one age how it works basically it's auction you try to say that I am okay to sell specific amount of die and the rate is going down and down and all of that is actually one limit order and um what it allows to anyone to for example to the resolver to the party who will try to fill your order it allows to aggregate liquidity during that moment so basically it's killed you killed multiple issues at the same time firstly you try to actually to have a market cell feature so you feel yourself some tokens without any you don't care it will be it will be all the fields there is a guarantee that it will be filled it's hyper this high probability that will be filled at the same time the suppressive should be a bit lower because you don't need to make it atomic um and for for this case we actually use price auctions and this is like example of the curve for the price auction for the rates where the rate is going down during the time it's basically it looks like Dutch auction actually um the main the main feature is that all of that logic is quite simple for the user and there is almost no difference for the user when you try to use vanish Fusion it's quite the same as just make and chain transaction but it's off-chain transaction is basically signing a specific limit order on the side of the user and that's it but there are like there are some additional features here uh the first one of course is the gasless execution what I mean is that as a use as a limit orders is of chain transaction and uh also we you basically just send some data to the sum database that's it and anyone can access to this signature to your data in this database and execute transaction on your site um regardless execution doesn't mean that you don't pay gas fee at all this gasless trend fee is just included in the rate of the fusion order and basically it's it's still a bit more efficient that we will try to pay on your own because uh in in the fusion protocol there is a specific gas optimizations basically that means that when somebody try to pay for your transaction for the exit like to fill the transaction it the user the real error can execute multiple transactions at the same time it will be one on chain transaction but multiple Fusion transactions and one transaction it can save a lot of like like gas a lot of efficient gas for example and one will have when the volume is a large it can be like 10 times more efficient for example than just paying on your own for that so that's basically how actually how actually any Fusion orders are working right now any of chain orders are working they just so the order is going through to the blockchain through your layers through some Market taker who is doing that it's quite the same for the limit order for the fusion uh let's try to make it more complicated why we have a view of protection uh by default here because there is no any blockchain communication on the side of the user there is not any option how somebody can steal your data or execute it on your own but that it doesn't mean that there is no there is no meat protection for the resolvers but the risks in this case are much lower than for the user because when resolvers are trying to feel disorder they have risks that somebody can execute a bit more efficient and they can they can Arbitrage resource resolvers on their own but the price difference here is not that critical and it's more a case of the resource how they can try to find the way how to protect from the myth so the risks are lower for the users a bit higher for the resolvers and what about like liquidity liquidity feature that basically actually we can aggregate all the liquidity across multiple chains uh during some auction time so for example in case of any resolver you don't we don't have any design how you need to aggregate or how you need to fill the the each user order you just have a time for that and it's not it's not like first you can't be forced to execute any order as a resolver so basically it's open market and each issue is over just you can aggregate liquidity from any any point for in case of our coins for example how it can work we basically Need Just For example any sheet card that's existing on the ethereum and existing on the polygon and all liquidities on the polygon you can see that there is a pretty good interesting order on the ethereum side and there is no any liquidity to execute it right now any resolver can take some time and withdraw this liquidity for example from the polygon chain to the ethereum and after that it can be executed on the ethereum site it will be impossible to do the same logic for example on aggregation protocol because it must be Atomic and it must be instantly and in this case uh that's the instant profits for all the parties it just makes the markets more efficient because users can get more tokens in this case and resolvers can get some profits from that case as well there is some slippage for the user because of the price auction the days goes down but this spread is not that high because it's pretty open market and it's very easy to get it to become a vanish resolver right now so um right now let's let's take a look on some PCS example about like price auction I just want to say that we do have right now as more Dynamic formula for each pair on one on one each front end so it depends on which token you are selling and which token you are buying the price firmware can differ and for example on ethereum dire rate if you'll try to just like to say that in the beginning when you're trying to make uh another price auction the price is going down not that fast we are allowing like resolvers to like instantly feel the solder but if you see that during some like amount of time like one minute nobody feel it that basically means that price is really very bad and nobody will feel and we can growing make it a bit faster going down making this period a bit more like a bit more extreme um if it's still okay if it's still okay that means that the market is changing rapidly and we still we need to stop working like this and try to say to have this the same stable formula so basically it's a lot of logic and the price formula under the under the way how you can execute the auction it's another way how you can make the markets more efficient for the in it also depends on the pair and the liquidity of the pair uh we also do take care of all of that and it's another like opportunity how you can for example design something or propose your own price formula for specific Pairs and make it more efficient I just want to mention that um the whole picture actually looks like that if you'll try to understand funny Fusion is that market maker is basically users they just need to sign another send it to the network of the one inch of an execution after that on each Network you get through this order as a fusion order and share this Fusion order across resolvers right now there are top 10 results that can execute any order instantly and if you want to participate or become a resolver there is a documentation on our website how you can do this basically the entry barrier for any resolver is quite low it's about 100 vanish tokens and if you want to participate it's just like less than 60 dollars so basically any resolver can feel limit like like actually it's limit order so any absorber can feel this limit order for one inch a smart contract this that is open source and one is filled a limit order is executed and send funds to the maker so basically to the user so the logic is of chain along chain at the same time there are some questions what is one distribution is it of chain logic or is it on chain logic it's it's a geek hybrid it's not it's sometimes off chain in some cases in other cases it's on chain but basically uh it's quite the same as a limit order protocol but more advanced with more additional rules over limit order if you want to try to understand it let's like take talk a bit how to you can work with the vanish Fusion basically uh there are two options how you can integrate and work on the planet Fusion the first one actually can integrate Financial Fusion to your app let's imagine you have a wallet or any app that needs to have a functionality to swap any token to any other token in this case it's pretty simple we do have a vanish Fusion SDK and in this case you just it's in JavaScript we have a brass version as well and if you want you can just like use it yeah there is a pretty easy example here I will show you one second uh how it works so basically in this case you can use for example node.js application to make to make a fusion order so we have on each Fusion SDK you just it's open source and it's quite transparent it's not that hard to install it uh in this case you just need a node you need a private key you need the micro address of your like of the user who will be creating like a limit order and what you need to do is basically have a web free node and our SDK you just install our SDK setup our SDK with our Network our URL of of storage of limit order of fusion orders and web free provider and basically you just need to create a little place an order where you specify a from token address which token you are trying to swap to token addresses that you are trying to set like to buy and amounts in from token address so it's like only for like four parameters for the function it's quite simple and in that case I don't have enough a frame right now to execute this function but basically it's just one function it's not a lot of issue to make it work um so it's the simplest way how it can work with any Fusion order and also it's gasless so basically I just want to add what we will try to use for example to run SDK or only Fusion SDK it can be not working because you still need to make a proof of the of the from token amount to the fusion contract if you don't make an approve you need to use permit function in this case it's more complicated if you want to come if you want to combine permits and make a play in my confusion order but it's possible of course we do support permits an effusion protocol but in this example you need to make a proof before you're trying to make a swap so there's the one example how you can use Spanish Fusion orders and the second one actually is to become a resolver if you want to become a resolver in one inch like ecosystem there are three like there is a multiple steps what you need to do basically the first one you need to have some on each token staked uh you need to apply as a resolver and use like basically all of that is basically decentralized but if you want to be on the on the front and side on the vanish like like front-end inclined there are multiple additional steps that requires us to connect with you to chat with you so if you have if we have a website like we have a website form where we specify all the data what you need to do to become a resolver but basically it in the end it will end up with a chart with our team that helps you to integrate and to become a resolver on our site to make some compliance checks and the same at the same time but if you don't if you want to become completely decentralized you can potentially you can do this you can still do this like that's the main point about Advantage Fusion that is right now the network is much more decentralized and we can't stop you to become a resolver because it's mostly on the smart contract site um how I just want to explain a bit more how resolver Works how the logic under the resolver works and for that in this case I need to open Vonage let me give me one second please so um let's take a look at our delegate uh like delegate tab Advantage front end one second so right now we have multiple resolvers and what is it um only top 10 resolvers in this list can be allowed to fill transactions and what does it mean like all of them are competing for your transaction each in each one each Fusion order can be filled not atomically but by parts so basically when you create a swap multiple resolvers can fill the same transaction it's their own competition between them who will be the first one who will feel all of that so they need to take care on their own how it's happening each Financial Fusion resolver can basically share some profits from the with the user in this case for example if you're owner of the vanish talkers tokens you can delegate manage tokens and to the any resolver and allow resolver to be on the top and fill the vanish Fusion others and get some profits so this scheme it looks like pretty the same as careforce as a curve staking and but there is one small small difference here that basically one Fusion resolver is not obligatory sharing the sharing the profits with the user there is no direct scheme here well but if your execution is always will try to refuse to share the profits you can just Angela gate from this part and delegate another resolver so basically on large volumes it will works on the markets like it will be a marketing competition and any resolver is obligatory to get some profits to share profits with the user if it will be lower than expected from the user site you can just try to use another one so as you can see like uh right now we have about eight working open sources like open resolvers that and the market share right now is much more lower in terms of vanish lapse result is always it's only about two miles that we are working right now and we have like pretty good results right now I just want to add that we also support not only ethereum chain right now we do support binance smart chain and a polygon chain and we have plans to support all networks that we have on the front-end side so it's about 11 10 networks uh so it will be ziki sync as well um the on the option how you can participate as a user for example you just need to stake one inch tokens and I just want to mention when you stake manage tokens you lock your tokens for specific amount of time you can lock it for example for two years in that case you can't withdraw it for two years but you have pretty good amount of Delegation of delegated tokens that means that you will have higher APR and higher profits from the resolver when we will stake it so it's up to you how much amounts you want to stake and for how long you want to stake it you can always unstake it before this locked period but in this case you will have some fee and for example if you lock your tokens for two years and you want to unstake it to the next transaction you will lose like 99 of the total total transaction in the in the fee in this case all the fees going to the vanish Tower so it's pretty transparent [Music] if you have any questions I'm pretty happy to answer that so um I just want to show again our career cards how you can participate as a resolver and how you can create Fusion orders using one each Fusion order SDK we do have additional instructions how we can use Fusion on our documentation website so basically this link is going to our documentation website so thank you okay so if a if a third-party partner wants to integrate Fusion to let's say you know a major centralized Exchange it has to be can they you know they they also have a DEX aggregator does it have to be a separate button or can it be somehow fused between fusion mode and the you know the the they have the sort of the Legacy swap mode right so how would that work out if if it will be a summon another ex aggregator it will be quite hard to aggregated if they have only on chain functionality I mean like in case of vanish for example trying to integrate another one inch in this case it's almost impossible because one inch needs to integrate only the access Fusion is not a Dax and in the case of another deck segregator it requires to make of chain logic and in but they need only one Atomic transaction so it's not quite possible ah yes then it's like a different different interface and they need to explain the user that this transaction can be filled not atomically but by some steps there is like an auction here um just to this one uh how would you get historical um trade data like the trades from historical stuff basically uh each Fusion order is a in the Enterprise is just on chain transaction so basically if you will try to feel the like if you want to get the date you can just index the the you know you can use analytics for their data or you can just go to the other scan and see all the vanish resolver like others that are executed on the from like on the vanish Fusion contract that's the one option that you can do the second one we do have right now like a database like API where there is a storage of all others you can fetch data there but I do recommend that the best option is actually to index data from the nodes directly or actually use do analytics for example to fetch all limit like Fusion orders we do have a general analytics dashboard for the fusion and we do have like they're all the requests all the see like it's quite transparent there how it's happening so all the analysis about oh fusionics actually required open source and transparent supposed to live partially filled orders yes like the main logic here is that it's yeah it works like that uh right now there is one more like a edge case that potentially later the fusion order can be filled not like not for the not fully they can be some small amount that will be not filled right now but right now it's handled like in the in the case that in in most cases right now it's not very profitable to fill order by small some by small steps so usually like usually it's obvious they just feel it atomically in multiple like in one step or two steps later with large amounts it can be a small issue with the some small amounts that is not executed it's the same as for example one inch limit orders have it is the same issue like you can trade you can make a limit order for 100 000 ethereum and 0.0.1 ethereum will be not executed in the end of all because it's just more expensive to spend on gas then execute this limit order actors in the overall transaction are paying for for the transaction basically it's only a resolver that is paying for the transaction and in the case of resolve its own its responsibility of the resolver to calculate the like how profitable generalization will be for the resolver so and because the price is going is going down that basically means that for example let's let's imagine that currently ethereum price is like two thousand dollars I want to make a fusion order to sell ethereum like for like two thousand dollars let's imagine I make a disfusion order uh but nobody wants to execute this transaction because the gas price is like 20 dollars for example let's take it let's wait like 10 seconds the price right now is not two thousand dollars it's like 1099 9999 in this case for example it's profitable and somebody will come and fill this fill this order so the price is going rapidly down and during the moment when the market price is a bit like is a bit lower than the real price somebody will catch and execute disorder it's quite the same I think as as front running or not front running but as Arbitrage Bots are working on the market they're just trying to compete to find the way how they can execute or like optimize the market in order to even from there is a period of when the there is an auction of course it can be canceled but if you want to cancel it it can it must be on chain transaction so that's the like the pain Point here that if you try to cancel it there's no guarantee that it will not it will be canceled instantly you need to worry that the return transaction will be executed so yeah it's quite painful issue here but of course it can be canceled by the amount of time but for example in some cases it's very edge cases but sometimes it happens when the market is going like not in your position against you all the fusion order can be like not executed at all uh in this case yeah it's just time constrained when this this Fusion order is executed all of that is actually on like off-chain data that you're assigning for so basically you can see all the details how this Fusion order will will be executed there is no any like something that is not of chain or not signed not like not in the like permissionless way basically very many incentive programs for becoming a resolver right now there are multiple like actually one incentive program to become a launch resolver uh that basically means that we share some Unleashed tokens managed our sharing Financial tokens to resolvers to help them to like to reduce their costs on building the infrastructure uh there are some details on the vanish website for that so yeah there are multiple incentives incentives from each team to help to build resolver on your own and there are like right now it's pretty high volumes on the vanish Fusion order so I do highly recommend to try take a look on it yeah I think yeah so I think we can end up this thank you so much [Applause] next time okay cool hi I am Emily I am the developer advocate for Linea a ZK roll up and here I'm gonna give a crash course on L2 so it's going to be high level but also low level and we'll see where we fall in terms of how much you understand what I'm saying um so I'm just gonna go ahead and get started there's a lot of information to cover um so first off from the start what are l2s if you guys aren't familiar basically um hopefully you've heard of these blockchain trilemma why is ethereum like it's a pick two situation right we have decentralization we have scalability and security we need to choose three what has happened is we've chosen as a community to focus on decentralization and security but we don't have that scalability access right so what that means is we are going to be pricing out users because of high transaction costs and slow transaction finality what does that mean Layer Two to the rescue so layer twos are specifically the scaling solution for ethereum what what that means is we are decreasing congestion by pulling off the execution layer from ethereum and then creating that data and posting it back when I say posting it back I mean specifically this concept called Data availability so basically what data availability is is the guarantee that all this data is going to be published to ethereum so this is what powers trustlessness right so one common misconception is how many guys are like familiar with like polygon proof of stake right how many of you guys think polygon is a Layer Two okay actually nobody that's great um but like I think that is a common succession right they have their own consensus mechanisms they have their own like security flaws basically layer twos right now data availability is the key to defining the difference so that's something to think about um kind of an image of like we all love visuals so just to kind of show you what that looks like right is ethereum is uh the monolithic version is taking care of execution settlement consensus data availability it's doing a lot of stuff like I said again Linea or like Roll-Ups in general pull off the execution layer ethereum is handling settlement and consensus data availability how does it do this here's another really fancy visual um basically there are various ways to do layer twos the kind of willing winning solution for it is Roll-Ups so when a roll-up it's pretty self-explanatory definitely what it does is it rolls up all these transactions together and then takes that and then posts it to ethereum once but how does it do this right so when we talk specifically about Roll-Ups there are two types ZK Roll-Ups and optimistic Roll-Ups how they differ specifically on the proof verification part so the proof verification is basically telling you how do I know a theory like how am I proving that this data I'm proving uh posting is correct right um so now we're gonna dive into oh actually I forgot about this slide to further explain Roll-Ups um it's composed of a few parts so we have the on-chain contract so you're gonna have a roll-up contract on ethereum that basically does the storage monitor States tracks deposits the second piece is the off-chain VM so this is where that execution is happening and the third piece is you guys have might have heard of like operators validators aggregators sequencers that's a lot of words but you can basically think of them as the people who aggregate transactions and then post that on um specifically when I talk about sequencer that is a little bit of a second separate concept they are the ones who have like the authority of actually posting it um next okay so now I'm actually going to talk about optimistic versus ZK um so optimistic rollups basically um do uh prove verification by basically not proving verification what does that mean so they're optimistic because they assume that everything is valid um in order for it to be invalid somebody has to send in a fraud proof they say hey wait that doesn't look exactly right let's run a fraud proof If it is if it proves that it's correct then it'll post if it proves that it's incorrect then obviously that transaction is rolled back what that means specifically is this concept of a challenge period right so in order for a fraud proof to be submitted or like that transaction data to be posted we have to wait seven days basically to give time for fraud proofs to be submitted um there are workarounds for this so something you might have heard of with regards to optimistic roll up specifically is something like a liquidity pool um so that's basically kind of a separate entity that says like we'll actually just verify it all for you um if you want to post it and withdraw your eth immediately um from the L1 we can do that for you the only issue here is like that doesn't really address the issue of like nfts the other piece is that is another like kind of hackable element if you care so liquidity pools is something you might hear as a solution for the challenge period of an optimistic roll-up I don't think it's foolproof and that's why we're going to go into ZK Roll-Ups so ZK Roll-Ups essentially basically instead of waiting for a fraud proof to be submitted we um I guess Pro actively submit something called a validity proof so what that looks like specifically if you go back to this side right here the proof verification is done via a zero knowledge proof so if you guys have heard of zero knowledge proofs it basically means proving the correctness of a statement without revealing the statement itself I want to step in here again in case um you guys are a little I have heard a common misconception with ZK roll up specifically I think when people think about ZK they think about scale uh privacy a lot and they're like oh all this is um but there's a difference between a privacy solution and a scaling solution so ZK proofs are using we're using it specifically to like keep the data small make that faster that's for scaling that's not the same thing as a ZK proof for like obscuring your information so those are two separate things we are a scaling solution so I want to point that out the other piece about ZK proofs that makes it really cool specifically is we think about your you can there's a concept of like recursive ZK proofs so essentially with a ZK proof you can have like this information and you can actually put a ZK proof on top of that and make it smaller and you can put a ZK proof on top of that and make it smaller right so there is like what you could call like infinite scaling that is uh enabled by a ZK roll up versus an optimistic roll up so when we talk about ZK Roll-Ups we want to dive in a little deeper so there's this concept of the ZK evm and so basically like this is executing um I guess solidity or like evm byte code and what does that mean specifically so vitalik put out this article um of four different types of zke EVMS so when you think about the roll-up space you might have heard a lot of things like there's like Stark net um what else is there in the ZK sorry ZK sync I'm part of Linea polygons EK VM scroll there is a lot how do they differ from each other is specifically in the ZK evm portion so at the highest level we have type four so Type 4 is language equivalent it is not bytecode equivalent so basically what that means is you will be writing in solidity but that will compile into something that is not readable by the evm like the ethereum virtual machine as we move further uh down I guess further down in number further up this um I guess table we have type 2 evm equivalency so that's basically it is language equivalent so that means you can write like solidity everything is going to be directly portable from ethereum to the layer 2. and it is also bytecode equivalent um the difference here specifically um is you can think of like pulling uh being farther away from the evm I guess um is a bet that you know evm uh I guess inherently is not super compatible with proof like ZK proofs so performance is not as easily achievable whereas type twos and then type ones which are fully ethereum equivalent then you're thinking about like the easier it is to interact with the ethereum ecosystem the easier it is to have the network effects of all the tooling that's already been created around it um like everything you know that has already been built around ethereum works out of the box right and so that's the really strong point this is kind of like a that's the win versus I guess a type four um and I'm not going to read everything on this slide but it's just kind of the graphical representation of what I was talking about versus compatibility and performance um so type four uh the least amount of compatibility or it's on the side Type 4 but the highest amount of performance as you go up that's that cool so now that we kind of have a basic overview of how evolved that works what it means what is linear specifically um so just fast facts Linea is the product of four years of research and development at consensus it's actually pretty interesting when we first started we were thinking about um I guess Payment Solutions like Anonymous Payment Solutions uh the idea that ZK proofs could be applied to scale was actually just kind of no one thought it was possible so we're doing a lot of ZK proof research and then through that research we realized actually scaling Solutions are possible with ZK proofs and so that's kind of how Linea first got started the other piece like I said uh we are on the way to type 2 ZK evm equivalency or type 2 Z ke evm which is evm equivalent right now we are at type 3 you can think of that as more of a transitionary stage when we get to mainnet the goal is to be type 2. um the other piece is we are powered by an award-winning prover so when you think about like the technical um I guess underpinnings of how Linea works we want an award that's pretty cool and the second piece is we actually are very new as compared to the other ZK Roll-Ups that exist in the space so you might think like uh I think polygon recently came out with mainnet we actually just opened public test net March 28th so that was like three weeks ago I think or less than three weeks but in that little amount of time we have like a lot of activity right so I pulled this this morning we have over five and a half million transactions uh 560 000 wallet addresses a lot of deployed contracts I just guess for comparison um I think polygon might have like less than a million transactions right now there are different reasons for that I can get into later but there's been a lot of activity there's a lot of real big assignment excitement like why exactly is that like why are people so excited about Linea so I'm going to dive into this portion of like how do you choose where to build um well the first is there's a lot right like I mentioned I was naming all these eks there's actually more than this there's more optimistic Roll-Ups things are developing how do you choose when I think about what I build and why I care about a roll up there are a few factors that I'm considering right so I think the first thing that people consider is like the reason I'm choosing a roll-up is because I care about finality and gas fees right so speed of the roll up how cheap it is stuff like that but the next piece is you want to think about liquidity right so how much like liquidity is on that protocol so if you're focusing on building like a D5 dap for example you want to think about how much transaction volume you can get from there evm compatibility slash equivalents so this is where I was talking specifically on like whether or not you want to leverage the network effects so specifically with like Linea for example um because we are evm equivalent nothing changed in terms of when we're bringing on Partner dapps literally all they did was just redeploy right because nothing had to be changed if their code is written in solidity it should work on Linea the other piece is users so when we are thinking about building a Dap You obviously want people to use it so how many people are actually building or like I guess in transacting on that L2 the other piece is security so I think this is kind of where the reason people might focus on optimistic Roll-Ups versus ZK Roll-Ups optimistic Roll-Ups have been around for a while so you could say they are battle tested to an extent ZK Roll-Ups are a very new technology are there going to be bugs probably we've only been around for like three weeks um the public test netwise but but you know something to think about I don't think um I I think this will be a solved problem but um we'll see and then the second piece is future proof so I think this is kind of where I'm talking about where do you think the future of this um roll up will go um you know like is that evm equivalency super important is it going to be able to be fast enough um the other piece is like is that ecosystem just going to be supported in the long term um other things to think about so I mean like I said I think for the most part DK roll ups have won against optimistic Roll-Ups I spelled optimistic incorrectly ignore that but yeah um I think specifically when I talk about the differences between the ZK roll-up on the linear side um The Vortex is our prover technology so when I talked about how you know you might think about a Type 4 being able to be more performant more easily our assertion is like actually our proofer Tech is gonna be fast enough you have a confused face maybe that's not true but like that's our bet no but anyways what does that mean exactly so this is kind of like the a high level of what it looks like so I'm going to name these important parts I can't explain them uh directly but basically we have arithmetization so you can think of arithmetization as taking like all that okay proof can actually prove it um the inner proof system is kind of where that proving is happening Arcane and Vortex is basically our Tech to recursively make that proof smaller and smaller and smaller so that when we submit it to that verification contract on ethereum it is as small as possible so it is faster and cheaper um that's my understanding of this if anything is incorrect I will let you guys know when I talk to our researchers um but yeah so this is also just like another slide of what that looks like it's very complicated but basically what you can see is the language equivalency versus the by code equivalency and how that compares to ethereum um so that's kind of all of them but they're all really good in smart projects so I'm not here to say one is better than the other um but specifically why Linea um like I said so I think we have the basics of a roll-up right cheaper faster secured by ethereum when we talk about ZK versus optimistics we don't have that challenge period um zero switching costs so that's when I was talking about being able to take advantage of the existing ethereum tooling system um something I want to speak to specifically um and I think this is kind of in line with how future proof you think it is with Linea the Linea girly or Linea is a default Network on metamask so right now when you deploy to other networks right now you have to go through the ux of like hitting add Network manually finding that RPC information adding it all there user ux is gonna be smoother we live in the same company as metamask so there is a partnership in that sense of we're very close to like the most popular wallet in ethereum or in web3 but yeah um that's that the other piece I want to know as well I think there is a lot of what you call it people like to fight between l2s I don't think that's necessarily true so something we are exploring is something called the multiprover theory so like I said before like things might have bugs right so at the end of the day like we're sending it through approver if that prover has a bug in it that's problematic right so what the multi-prover is saying is we're actually going to send it to multiple approvers so scroll linear polygons like people were talking to if there is a consensus on this is true we've verified it in three different ways so that is a lot more secure than for example if Linea was the only L2 that existed in the space and so this is what I say when like you know we're competitors but actually it's very important that we collaborate so yeah that's kind of the future the other piece to this too um I guess a sneak peek right we are in L2 but we are thinking about like building l3s in the future that could be anything from more specific like app chains um to again doing that recursive proof so that it is faster um the definition of an L3 is actually still in flux which is pretty interesting so keep an eye on the space um but yeah so actually what does it look to build on Linea I think the Wi-Fi is really bad so I'm not going to do this live but the first thing you need to do is actually get linear eth let's see if I can access if it'll go oh okay I guess so yeah I mean basically what happens is you're going to need to bridge eth from Gurley test net over to Linea so this is kind of um I hope you guys know how to use a bridge but you can just think of it like this and then send it over um if this is not working like I think it will work you can come to me I have 2 000 Linea eats so I'm happy to share but definitely like try out our Bridge um but yeah so the first thing you need to do is get linear yeast to actually transact the next piece is going to be choosing where you build your smart contracts so I have an example specifically for truffle Foundry and hard hat but because it is evm equivalent by code equivalent you should be able to use Like Remix brownie um I don't know what other people have used but like wherever you build that's where you choose so specifically uh with truffle so to actually I can I can probably do this uh let's try this so um let's do a truffle a knit project oh I'm in a project already whoops okay truffle and knit project code project and I don't have any demo code in here actually so pretend I opened this and then whoa I added all this stuff amazing wow what does that look like to actually deploy so to deploy and I'm going to show you what this looks like actually oh I already opened it uh so here's truffle dashboard running if we go to truffle dashboard specifically you can choose what chain to deploy on on metamask uh uh I chose Linea if you wanted to play in Girly mainnet Etc you can do this all here I'm choosing to use dashboard because I don't want to expose my private key to you and then you can just do a truffle migrate Network dashboard uh and if the internet works something should show up I don't know if it will so I'm just going to show you this is what it looks like um it actually sends in the transaction you just hit approve and then it happens uh with hard hat actually you can also use the dashboard you would just fit it in here and then deploy uh with npx like hard hat Dash deploy RPC like truffle dashboard with Linea specifically this is our RPC endpoint rpc.early.lineia.build we are permissionless public test net right now so that's how you would do it have any of you guys actually deployed a contract before oh actually most of you haven't damn I'm just saying stuff as if you understand yeah um okay I will briefly touch on contract deployment so essentially you have various tools so like I said truffle Foundry hard hat that help you manage the deployment process so that's going to be writing it and then giving you the opportunity to deploy to a network configure what those networks look like so if you want to deploy to multiple networks that would be part of like a configuration that you add to your truffle hard hat or Foundry project the other piece is like it offers testing functionality specifically when you choose where to deploy that's kind of where this network configuration comes into play if you guys have deployed a contract before what it looks like is this URL will just be replaced with like early test net will be replaced with mainnet will be replaced with polygon what we're saying here is actually just needs to be rpc.gurly.lineia.build it's exactly the same you don't have to change any solidity code so that's when I'm talking about stuff like starknet for example they are building in Cairo so you will have to write a different language and then do it differently but with Linea you can do this [Laughter] yeah okay cool um and so Foundry is kind of how you use that too I would be Pro to explain all of that so anyways talking about how you can use Linea in your project so basically we have a very open-ended uh Bounty basically all you need to do is Deploy on linear so whatever smartcraft contract You're Building um just go and change this address to linea.build show us the actual deployed contract on the Explorer like the block Explorer and then that's all the proof you need to actually and then one more thing um put keep calm and love Tokyo on your GitHub repo so that we know you actually read these instructions but um otherwise yeah it's super simple I highly recommend doing it um basically whatever you build should be able to be deployed on Linea so yeah um this is kind of information I have quick starts on actually the full deployment process of like how you set up a project and then actually write a contract and then deploy I'm sorry I just assumed everyone was already a smart contract developer that was like very bad of me but um hopefully you guys will try it out and that's all I have to say cool uh does anyone have any questions yes more of a general question about LT is not specific about linear on the roadmap for ethereum for essentially a vitalik's whole like vision is to bring everything onto l2s and whatnot and the first step was that all the Roll-Ups are being stored in the call data and that the first step would be actually making the call data size larger I'm still trying to wrap my head around as to how increasing the size of the call data translates into directly the throughput like the TPS increasing if you know about that that actually surprises me too that he would want to expand the call data I don't know I have three very good friends who are like the experts in the room do you guys have any idea if not I can write down your question and then take it back to my team call data can be treated as a data availability space and by expanding call data you this was like the simplest way without any any more complex Solutions on ethereum to just give more space for storing the the proofs you are sending the proofs through the call data instead of storing them in the storage on ethereum you were just passing them in call data because it didn't really need to store them on storage but instead now for the 4844 on ethereum you providing additional space for data storage that is outside of State outside of call data so instead of creating that in the transactions you created only separate transaction type so so it's like continuation of the same thought process if like give more call data but instead you're providing like this specialized blob transactions that only have call data and only care about that but they are quite big and they have different rules of propagation so this is coming potentially in uh most likely in Cancun extension in few months in ethereum thank you very much cool so that's my presentation let me know if you're building on Linea I can help you with solidity development I can't help you with call data explanations but uh that's where I am okay have a good hackathon [Applause] foreign okay um cool hi uh nice to meet all of you I was the person sorry this is hello um yeah I was the person singing on the ground outside so nice to see all of you here um my name is Sarah nice to meet all of you if we have not met at the booth yet um I need deaf experience for Falcon Virtual Machine as part of protocol labs and I'm here to talk about the Falcon Virtual Machine and how that can help you with programmatic storage for your smart contracts so yeah let's get into it cool um just to get a show of hands before I start um how many of you are familiar with falcoin okay great and those familiar with ipfs and Falcon Virtual Machine okay I guess I'm here for a reason great um and then okay one last question just because I always am interested to know this um how many of you think ipfs and are not clear on how ipfs and Falcon are different anyone or everyone's super clear cool okay I will talk about it briefly because I real honestly I joined protocol labs and then it took me like two months to realize that ipfs and Falcon are not the same thing so if anyone thinks that I'm here to help to clarify and so that will help you to build easier for your projects cool so um oh yes and if you are interested to watch us uh me and my other colleague talk and experiment and code live every single Thursday you can follow us on Twitch we try out different Integrations and sometimes we fail and sometimes we succeed but yeah you if you want to watch a train wreck you can always join that cool all right so um I kind of get started to set the context um for the Falcon master plan so if you're thinking what is popcorn virtual machine which it seems like some of you are new to um that's great because we initially started we've been around for about seven years when we started it was a decentralized network and so that is falcoin as its own so the difference here between Falcon and ipfs uh Juan Beni our CEO actually founded ipfs at the beginning and that was a peer-to-peer Network which means that when you store stuff you're not paying anyone your that also means that your data if your node is not being maintained could disappear over time so we then decided to come up with the Falcon Network which is a blockchain whereas ipf is not a blockchain where you can store data and incentivize storage providers to store your data for the amount of time that you wanted to be stored for so that is Falcon and that's how it's different from ipfs these two are used together a lot so you we would usually store on Falcon and then we would pin it to ipfs so that you get quicker retrievals as opposed to on the Falcon Network you will need to then unseal your data cryptographically and that takes some time and also takes a lot of power which you can do eventually when you want to retrieve back your whole set of data but we recommend that you use ipfs for faster retrievals so these are how the two work together and then and then we moved on to step two where we started onboarding a lot of the data outside of the committed capacity that we had on the Falcon Network so I think today we are at I think it's like 30 expabytes which is just a lot a lot of data and so I think someone came by the booth and asked me how much data would it take to crash the Falcon Network the answer was kind of not enough um it's honestly kind of hard to crash but we have a lot of space right now and so you can always upload data to that and now we're at step three where we thought you know we have a bunch of data how do we then emulate what web2 has as an AWS server for example where you have data and then you have computation on top of that and you can run it as a full server so that's what we really want to bring with the Falcon Virtual Machine um and I'll talk a little bit about how we can enable you to write logic around the storage itself it relates to what VPS uh not VPS yeah I wouldn't say it's I wouldn't say it's private yeah it's pretty open yeah cool so um so I clarified a little bit of that earlier on and to be clear fvm is a layer one and then Layer Two is where all of you are at for the hackathon so I I know it's two days uh we've been in hackathons we've seen and Mentor a lot I know it's a rush so I want to get right into it and do a demo as well so you can see what you want to use in the next few hours and tomorrow as well so Layer Two is where a lot of the solutions and projects are going to be building on top of what you'll be doing essentially with the fvm is you will be building um you would be building your smart contracts um so we are fully sorry let me take a step back um what the fvm allows you to do fundamentally without us talking about the ethereum compatibility first is that it allows you to write logic around the stored data on the network so every single piece of data that's stored is part of a storage deal and every storage deal has like some metadata with it so it'll tell you like what size of file is in there how long is it being stored for et cetera Etc what the fbm does is it computes over that metadata so it allows you to move around your data without actually having to open up the whole piece which takes more time and costs you more money so it should be pretty cheap for you to be able to move your data around so that's fundamentally what it does right so now why I say we are here today is so this over here is the fvm on top of a falcon node so every single node in the Falcon Network can run an instance of the fvm you can also run multiple instances of it on a note and then on top of that we have two three classes of actors that run on top of the fvm we have the first class which is built-in actors and these are think of actors like smart contracts these are built into the Falcon Network you aren't able to touch them these are system actors that we have built for you to function with the protocol and then you have the second class which is user-defined wasm actors which are we consider fvm native so this will we run Watson time under the hood this will allow you to use different Frameworks that you're more familiar with like go webassembly so on assemble sorry assembly script so we have these sdks as well but then for the ethereum community we're like that's a really really big community and we should be able to provide tooling for them as well so we've created foreign runtimes and we also have built it in a way that we are VM agnostic so today we are evm compatible in the future we also have the infrastructure to allow us to be compatible with other VMS so Solana is something that we're looking at next we need to tighten a polygon story a little bit more I will answer any polygon questions later on um but yes as of now we are fully ethereum compatible so any tooling that you're familiar with like hard hat Foundry truffle you can use with the EV with the fevm and so you wouldn't actually see the fvm a lot of it is on the back end all you'll see is your solidity code and your contracts and you just need to understand how our contracts work and how you import that into your stack yeah so pretty pretty easy to use the clear definition here is that you will eventually deploy to the filecoin network and not to the ethereum network or to the polygon Network for example which I know for some of you is is a choice for you to make but I just want to make it very clear that you'll be deploying to the filecoin network if you choose to use the fevm yeah that could change in the future and we're hoping to to bring some more interoperability but as of now um it will be to the Falcon Network cool so we'll get right into it on how to use fvm in your project um there are two main ways that I think you can use as part um as part of the hackathon today so the first way would be the client contract the client contract is a solidity contract that we've written it basically allows you to store data programmatically onto the Falcon network using solidity so I'll run through a demo and show you how you can use it these are some of the tools that we're using hard hat metamask the hyperspace testnet which is a test net that we own it's a stable test net and it it emulates our mainnet so if you've used it there and it works it should work fine on the mainnet as well we have a specially created filecoin.so Library by our partners on decks and so what it allows you to do is that you can use a solidity command solidity methods to then interact with the filecoin protocol setup that you'll need if you want to build it out later on npm node.js hard hat and then I think the new component here is connecting your wallet to the hyperspace testnet and getting some test fill to use as part of your project um so yeah we'll go through the demo what we'll do for the demo is one I'll show you how to connect your wallet it's super easy um we'll get some funds from the faucet and then we'll deploy the contract we will then prepare the data and um just for you those of you who are new to the Falcon Network any piece of data that gets stored there has to be converted to a new format called a car file it is basically like a deck and it will yeah it will be a new kind of format that you need to use in order to store that piece of data I can explain more specifics in it as we get into the demo but if you're just using it as part of the hackathon you don't have to get too deep into it but I'll take you through step step by step and then we will emit the storage deal proposal and then we'll check the transaction on the Block Explorer to ensure that that has been deployed cool so we will get into them the demo itself so I'm just going to use a Bare Bones terminal here I hope that's okay with everyone there is a really easy tutorial to that will bring you through this hold on so if you have come by the booth we have a QR code there it brings you to the hackathon cheat sheet and in the cheat sheet itself it will bring you to a hard hat starter kit that is the main Flagship starter kit that will get all of you started on what you need to build um I will show you and once you get to the Head starter kit it's actually pretty easy to get it going we have most of the steps in there it's super easy to follow um so yeah I'm just going to show this to you first and then walk you through it and we'll try it out on the terminal so this is the hard hat kit um it takes you step by step really quickly to show you how to clone it get you know what you need to then up save your private key I will be using a test private key if you steal my private key or just get a bunch of test fill which is fine but don't do it because I need it for demos and then I'll show we'll test it out to show you how you can get your address and I'm going to talk a little bit about what an address means when you look at it as a ox address versus a file coin address and how we've actually had an address manager that helps to convert that and then we'll deploy the basic deal client contract itself and I can talk a little bit more about these examples but the rest of the contracts in the repo are actually more example contracts more than anything else just to prove that you can mint an erc20 token and so on um and then we'll interact with the contract to then deploy a dummy jpeg and then we will see the proposal get emitted and check whether that transaction has gone through okay and one step before we do the hot we get right into the terminal itself I'm gonna show you how you can connect your wallet so where is my browser cool all right so easy hit the chain list dot org um search include um make sure to search include test Nets key in hyperspace I have already connected my wallet but then it yeah here you go so then it should pop out over here and if you click at The Meta mask it will get it connected to your metamask so once you have it connected I'm gonna let y'all take a photo here once you have it connected you can head over to the full set and all these resources again are in the hackathon cheat sheet that I will share the QR code for later on and you can always hit by the booth and get the QR code if you haven't had time to get it cool so all you have to do is see as I mentioned all you ever see is your ethereum tooling you'll just copy your metamask address it's an ox address not a filecoin address and you will answer a very complex set of questions over here you know honestly these tests are getting harder and harder um okay honestly it's okay they just want to make demos harder for all of us wait is that a where was that is that a camera no okay sorry um Can Depot contracts cannot answer oh there's a they are black and white okay we're over here that's all right okay cool teamwork teamwork we got it um and then you send and typically it takes about 30 seconds to an uh to a minute um the reason for that is that our hyperspace test net which simulates our main net runs in this thing called a box and so every single Epoch is about 30 seconds for a new block to come in so that's usually the wait time that you will take I would say give or take another 30 seconds so we usually wait up to a minute but of course I already have some test fill in there but just to manage expectations so yeah every single time you press send you'll get about five tests fill if you want to run a miner and you want a lot of test fill uh you can always DM me on slack and we'll get you a whole bunch so you don't have to keep answering those questions um to get your test filled cool so that will get your wallet set up so then after that we can hit straight into the terminal to get it deployed so you'll head over here um very easily you would just clone the whole repo yep done pretty quickly and then as I mentioned you will export your private key please please please do not um use your real private key or you know um deploy it if it's your real private key here and then I have my private key copied out over here but again I mentioned this is not a real account so nothing for you there if you want to hack it um okay so then now we have my private key in there so let's test it out let's see if we'll get our address so yarn get a dress cool so we do have my address over here and this will be the address that you saw from the metamask account but then over here you also see an F4 address what that actually means is um so we are ethereum compatible and we want you to see the ox address but in the Falcon Network we have an address manager that converts it to an F4 address so if you see an FR address and orx address they are the same thing with a lot of our tooling we've made sure that you can key in your Ox address or your F4 address and you'll get the vice versa version of it so it should be pretty easy to use it don't get confused whichever one you you prefer to work with just use that cool so now we make sure that the address is there what we're going to do is we're going to deploy all the contracts in here so as I mentioned earlier on we have a few test contracts in there so if you head over to the contracts folder we have a few examples for you we have basic solidity examples which is just a simple coin just making sure that you can do it urc20 we have a quick start on our documentation page that will show you how to Mint an erc20 token on remix so super easy to use you can just follow steps over here I'm not going to go through that um but yeah you can then run you can mend your token so if you if you want to Mint it as part of your project you are able to do that as well um where was I right and then the other one which is uh would say pretty interesting is the Dual here falcoin API examples um I have one example over here so if you want to see how you can import the Falcon solidity Library you could just use this contract to just check if it works but honestly it doesn't really do much we also have a Dior re water contract which is an off-chain version of the client contract which is the main recommended flow of how you can store data so this deal with water contract over here is actually an initial way that we thought we could store data what we do is that we put money we put a bounty into an escrow and then we incentivize a bounty hunter to come and pick up your data and then do the usual more manual method of running a note and proposing it to a storage provider on the network getting the deal ID for you and returning you the deal ID to then unlock the Bounty within the smart contract it's a bit of a roundabout way that was the initial way but we can see it working for certain use cases so for example if you have a designated storage provider that you want to work with or you have a dow and you want to designate one person to be in charge of making sure that these storage deals go through you could use this method as well although obviously not a streamlined but it is an option for you um so that will be over there and then what I'm going to demo is the Dual client so this is the Dual client contract um this is this will allow you to basically um be able to take any jpeg or any piece of data from your from whatever your dab takes data in from and then be able to deal with the whole deal proposal process for you and return your deal ID that should all be accomplished within anywhere 15 minutes to a half an hour and you should get your deal ID back again because this is decentralized we are working off a network of storage providers that can choose when they want to accept so it is dependent on them on how quickly they accept but we have incentives incentives for them to accept it much quicker on the mainnet on the test net however you'll get it really quickly in like five to ten minutes because we have dummy miners over there that will accept your deal regardless yeah if you want to run a local net yeah I have a few options for that I can show you how to do it um if you run it locally you will basically run your own Miner and then your own node and you run it within your own environment so yes it will be much faster because you can just accept your own deal what oh um for the hackathon you could run it on your local net yeah you could you could do that if you want to yeah yeah we have a Docker image that we just created two days ago that lets you run a load it's actually in the cheat sheet you could spin up a Lotus image and a minor yourself yeah so should be pretty easy for you um so before I get into the deal um client I'm just going to explain really briefly on what happens so we're gonna prepare the data first I have some dummy data that I prepared over here um again these resources are all in the cheat sheet but we'll usually go to the data Depot first as I mentioned in my step by step we are going to we are going to prepare the data so while we prepare the data I'm going to spend some it takes about a minute so I'm going to deploy all the contracts first so I'm just going to go yarn Hardware deploy it's going to deploy all the different contracts in there so we'll let it run in the background in the meantime we're going to prepare this so let's say you want to upload a new file it's actually really easy you could just head over here whatever files that I have um foreign cool yeah we'll just use the FM logo so if you hit this if you put this in over here I think because I uploaded it previously okay I guess I'll upload a photo myself right and so yeah I actually I was actually uploaded so now I have three files that I've uploaded and for every single file that I have over here there's actually a really easy interface for you to um have and these will be more useful like you will see why you need all these fields later on um these different fields are parameters that you have to include in your deal proposal to then emit your storage deal proposal to the network for your storage providers to accept so we make it much easier for you usually we have a CLI you can also use the CLI method if you prefer I just find this a lot easier to read and explain yeah so you have full ID your file name you have a usually have a PC ID I think that's still being computed so I'm just going to use one that exists right now um yeah you have a PC ID a payload CID these are all fields that you need to key in and we have a really easy way for you to see what you need to include so we've written it over here so if I copy this and I add it to a file how do I make this larger oh my God [Music] cool um so yeah this is the template that we have for you so all the fields that you saw earlier on you can just input them based on what you have like the con the contract address that you've deployed which is deploying now in the background and I will include that in a second and then you have like the pcid peace size start Epoch and Epoch as I mentioned appbox are like the blocks that run um tip over here I would recommend that you set an Epoch that's about 5 000 Xbox ahead of the current apple and you can check the current Epoch based on our blog Explorers so we have a really good blog Explorer Explorer over here called Phil Fox we have about seven block explorers in total that support fvm um Phil Fox is one of them and also one of the most used um so you can always go here and see for that make sure you're on a hyperspace Network you're not the main net Network um that you're actually looking at the right box and then you can see what block height is at I would suggest your start Epoch and end up are about 5 000 a hit so I would usually put like two five eight nine seven one and then my end airport would be another 5 000 on top of that which would be sorry my math is not great but 270 right around there so you can use a box because if you put it too soon you're gonna miss the time when you're actually emitting your deal and you're gonna miss the airport and your deal proposal will not go through if you put it too far ahead you're just gonna wait forever until the epoch is hit and the audio proposal goes through uh goes through so that is the most recommended 30 seconds so yeah let's check if our contracts have deployed okay we're down to the last one which is great that would be the deal client so once that is deployed I will have the contract address and then I can input it into the into that template I just showed you and that would be the hard hat task that we want to run in the terminal so once I have the contract address I'll input it in there I will input all the other fields from the jpeg file that I uploaded and then I can copy and paste that whole heart task and key in here under my terminal and run it and once I run it I should have the Dual proposal successfully emitted and then we're not going to wait here because then there'll be the end of my talk but it'll take about 15 minutes for your deal ID to come through it and I'll show you how you can use the blog Explorer to then find your dual ID based on the proposal that you admitted okay cool um it has now deployed so as I mentioned I'm going to take this okay so I have I have one that I filled out earlier on um I'm just going to increase the font size cool so I'm going to change out this contract address over here and I have really fill in all the other fields um which is you know just take a while so I prepared it in advance so I have the whole higher task over here and then I head back to my terminal and I just need to drop this in over here and it's making a deal proposal um the last time I did it I think it took me like 30 seconds or so 30 to 40. um but while we're waiting for that to happen I'm gonna show you that to how you can check whether your contract has been deployed so you can always take all the contract addresses that that have been deployed over here so I'm just going to copy the Dual client and I'm just going to search on the Block Explorer and yeah it should show you pretty instantly that your deal is already submitted successfully to the network yep and if you're actually doing this on mainnet uh we definitely suggest that you verify any contract that you deploy um really important to do verification over there and I think Phil Fox and one other Explorer which is Barracks has now implemented contract verifiers in as part of their blog Explorer so that should be pretty easy for you cool so while we wait for this I'm gonna talk through briefly the next option um I know we're almost at time but I just want to erase this other thing so um I'm gonna bear in mind that if you use this method you probably have to you what you will do is to import the entire dual client into part of your stack and run it as part of your debt um if you prefer to not have to deal with a whole lot of that and you just want to use um a storage helper which deals with a lot of the ideal proposal filling in all the blanks preparing the data etc etc you can just use Lighthouse Lighthouse is one of our partners and they've built a storage helper on top of fvm um the cool thing about Lighthouse is that they also provide the additional option of access control so they have a really easy to use SDK that also provides encryption for the data that you want to submit so depending on the project that you're trying to build if you need access control you can also use Lighthouse storage this is also in the cheat sheet so it would be easy for you to um click on hooray okay so event emitter proposal ID is out there right now floating in hyperspace how you would check whether your deal ID has come in or not is you would head to the block Explorer again you will head over to deal list and this piece is not I I admit it's not the most intuitive but it's a stop Gap solution for now and it will work you would just need to key in your address and then constantly check because I actually submitted a deal earlier on but then constantly check whether your do ID has come in or not so I usually refresh it after about 15 minutes just to see my uid has come in based on my address and then I'd be able to refer to that deal ID as part of my dab yeah again not the most intuitive we are working right now on improving improving um the workflow and being able to automatically notify the client once your dual ID has come in but as of now not available just yet okay so that was mostly the demo um I have very little time left I'm gonna try to just cover um how you can use fvm um if you are wondering sounds cool I mean what can I do with fvm and storage we have a really long list of ideas at rfs.fvm.dev you can look through those those are all storage focused Solutions with fvm that you can build also once again we have ten thousand dollars for our price there are a few key categories over here programmable storage markets so anything that will improve the data economy um in this case meaning file coins so if you're thinking of Perpetual storage is really interesting to us so how do you get storage deals to keep renewing and if they have any issue with them automatically repair them on the back end if you're interested in that data dial is a very cool topic that is agnostic to filecoin alone but we think it can be used in a much larger way you know what dials are and now you think of data dial so if you have a very important data set that you want to gather a dial around like for example for decentralized science we see a lot of cool projects that are actually building already on fvm so I'm just going to show you guys one because I thought this was really vehicle um but yeah this team Bureau they actually built a decentralized science app on fvm it's a data dial basically and then everyone just uploads their scientific papers and then the dial will help them is incent their members are incentivized to help to review these papers and then post their reviews um in the dial and everything the reviews and the papers themselves are stored on the filecoin so just just seating some ideas over here um and compute over data also a really big piece fvm can be used to orchestrate all these jobs for off-chain computation we have a very efficient and good compute over data framework called Pacquiao my teammate Irina she's around at the booth she's over there can't miss her um but yeah talk to her if you want to figure out how you can use fvm and compute over data the cool thing is that you know again with decentralized science you could then take the large data sets and do computation of chain and then return the result to your debt so yeah we kind of want to see more of that and then lastly in front tooling so if you want to build any cool tools that will help to if you want to figure out how to automatically send a deal ID back to the client and fix my demo um I would mostly welcome that I will award your price if you can do it but yeah some tooling ideas as well and then we have a wildcat category so anything cool that you can come up with please surprise us yeah and then lastly I do want to touch on that if you're building beyond the hackathon and you want to keep building we actually have a lot in uh we have all these Integrations that are already launched in the past month with fvm that are compatible with fvm so we have containers for setup we have cross chain messaging and cross chain token bridging we have oracles with teller um access control I just mentioned with Lighthouse and Medusa as well we have some D5 Solutions on liquid staking and Sushi swap is coming in really really soon as a DEX we also have Network analytics apis if you want to use it as part of your project decentralized compute and these are all resources that you can find in the hackathon cheat sheet they are not only on mainnet they are also on hyperspace and I have the contract addresses on there and the cheat sheet so if you want to use them um just hit in there and use it as well but yeah I just want to let you guys know that you know there are many other Integrations that you can build your project out with yep and as a judge and with my other judges um these are the things that we're looking for we're looking for storing files with the fbm client contract that we just showed storing files with a storage helper like Lighthouse it could be either or um and then making sure that your project is deployed to hyperspace testnet we do want to make sure that you're using storage well or at least as part of your debt and not just deploying your contract with no storage components or nothing to do with fvm or Falcon onto the hyperspace test net um just want to put it out there um so that you don't waste your time deploying the hyperspace but that's what we're looking out for and any Innovative and creative uses of storage so yeah you link QR code this is at the booth as well um the hackathon cheat sheet is in there as well as our docs the rvest fvm.dev and upcoming hackathons and grants that you can access so yeah that was a lot um I am around for questions but I don't want to pick up the next talk so thank you everyone [Applause] cool foreign thank you are we good to go awesome hey everyone thank you so much for coming to this session I'm going to really quickly show you how to bootstrap and deploy your dap on polygon ZK evm but first of all gmgm or as we've switched to zmzm since we're kind of like in this ZK Universe I'm Steph I'm a developer relations engineer at polygon Labs I'm also oceans 404 on Twitter um and a fun fact about me is I got started in web 3 because of hackathons just like this so I'm super passionate about building things and helping you all build things and one of the things I struggled with when I was doing hackathons is like building really quickly so the goal of this session is to show you how to use polygon ZK evm really fast so how to bootstrap something quickly so that you can focus more on your business logic and the hacks and the real world problems you're trying to solve and less on like oh how do I connect my wallet or what is specific about ZK evm but that said I will go over a few zkevm things but first I just want to highlight our four different prize categories for Builders so we have four categories the first one is the best cross chain or x-chain hack with polygon DK evm so we want to see you connect to either ethereum or polygon POS or some of the other l2s and use that data in an interesting way whether you're connecting it for governance or like having mints based on owning tokens on another chain something like that next is 5000 for polygon ID verified credentials so Implement identity in a interesting way next we've got the best public good with account abstraction and I don't know if you notice but account abstraction has kind of been a theme at eth Global Tokyo this this uh year and we're really excited to see all of the different account extraction hacks so if you did that on polygon you'd be eligible for three different bounties so you could triple up if you did a really great hack highly recommend that and then the last one is our polygon build in public pool prize so if you Deploy on any of our chains you're eligible to split this prize with however many people also deploy so really encourage you to deploy any type of dap because we want to see what you're building but we had a really exciting announcement on the 27th of March and that is that we launched polygon zkevm mainnet beta so it's on the mainnet you can deploy dapps to it you can test it out we've had our test net for about six months and over 70 000 developers have developed smart contracts and it's started to be battle tested so excited to see you develop on polygon ZK evm this hackathon why polygon ZK evm we think it's the next chapter of ethereum scaling it's exciting for developers because you can use all the same tools and Technologies you're already used to whether that's building with hard hat or remix or Foundry they all work out of the box you can use solidity uh the same way you would for polygon POS or ethereum and it just works pretty seamlessly the only thing that I have to call out is that we don't support four pre-compile opcodes so if you're building something with those those aren't supported but for the most part everything should work seamlessly which is great for Developers so the first half of zkevm is DK zero knowledge and I like to explain this with an example did anyone play where's Waldo as a kid those books where you look for Waldo I know I did um so Waldo is somewhere in this picture and I could prove to you that I knew where he was without telling you exactly where he was and I could do that by highlighting where he is in the picture and covering it with a big piece of paper so on this picture on the left there's a big purple piece of paper in front of the actual Waldo puzzle and so you can see that I know where he is but you don't know exactly where I've positioned this piece of paper so that's kind of like a ZK proof where I'm proving to you I know where Waldo is without giving you the information to show you where he is so you don't know exactly where he is but you know that I know and I kind of like took this example from a cool wired video where a computer scientist explained ZK with five levels of difficulty for a little to a little girl he has like a penguins and puffins example um but when this is kind of done in the real world it's done with cryptography which is complex math to prove a statement or like a batch of transactions in this case is valid without actually needing to have all of the data there um so this is really great because it can be secure and private but that's not actually the focus of ZK evm it's more for increasing the throughput of ethereum and adding kind of like to the efficiency so ZK proofs help you prove that you know something without revealing any additional data about what that thing is so that's the first half of ZK roll up or ZK evm so we know what ZK is now the other half is what is a roll-up so a roll-up is a layer 2 scaling solution it's where you take a big batch of transactions and you do something interesting with them and you just post a small amount of data on the L1 which is ethereum in the case of a ZK roll-up you're taking a big batch of transactions from polygon ZK evm and instead of having all that data on ethereum you just have one single ZK validity proof that says okay all of the state changes that changed on zkevm are valid and we can just have that posted on ethereum which drastically decreases the amount of data there and increases the throughput and adds to lower cost transactions for each of those batch transactions because there's only one thing that's finally posted on ethereum and that's that proof so why polygon zkevm first of all it's great to inherit ethereum's battle-tested security that proof is being posted on ethereum and ethereum has been running successfully for years and years we trust it we love it for defy that's awesome second reason is achieving true evm equivalence and when we have that the things that function on ethereum also function on ZK evm so you don't have to change functions or anything it the code works the same way third reason is it's fast and performant and then the fourth reason is lower cost transactions than if you were operating just on ethereum some of the industry use cases and things that we're really excited to see you all build are things in the defy and traditional Finance space when you're transferring value you want high levels of security right because you don't want somebody to be able to change that transaction so for finance we highly suggest ckevm also for supply chain infrastructure projects Healthcare all of that you need high levels of trust so Z polygon ZK ebm is the right choice when you're figuring out what chain to use there so to get started building the first thing you need to do is bridge over some eth so on the test net that'll be Gorly eth and then on the main net it'll be just like real eat that you would use on ethereum so you'll use wallet.polygon.technology and you'll bridge over those tokens so that you can use them on zkebm and then once you do that you can operate on this chain pretty much the same way you would with ethereum and I'm going to show you how to pretty quickly build adapt um I I worked on what create web 3D app and added a polygon zke evm Network the other day with my friend Vito and the Alchemy team so I'm just going to show you how to use this tool to pretty quickly create your own dap and deploy to polygon ZK evm so like I said this is a tool that was created by the Alchemy Team all I did yesterday was add support for polygon ZK ebm here are some of the other chains that are already supported so ethereum and polygon were already supported arbitrum and optimism and the cool thing about this is you can get started pretty much as easily as you can with create react app if anybody's ever used that so I love this tool because it bootstraps a front end and helps you create like the smart contracts that you would need for anything you're doing so I'm just going to open a command line tab so all you have to do is run npx and then create web3dap at latest and this will just start that package creating a web 3D app so it's beginning to bootstrap and it's just asking me for some details about my project so I'm just going to create a simple nft project because I think we're all familiar with nfts just so that you can understand how this tool works so I'm going to call it um Tokyo nft so then you can either choose to create a full stacked app or use a template I'm going to just choose the full stacked app so you can see the full workflow you choose your chain so I'll choose polygon zkevm and you can choose your development environment I'm going to use hard hat and the beautiful thing about zkevm is that it works with hard hat Foundry remix all the things that you're already used to building with do I want to create a smart contract yes and then since we're just going to do some nfts today I'll choose ERC 721 but as you can see you could use this if you were doing something interesting with tokenomics you could do like an erc20 you can also do I believe a governance contract if you were doing something with dows um and then name for your contract let's just call it uh cherry blossoms and symbol CBS I guess or just CB uh that works okay so now it's asking me to toggle some features if you've ever used open zeppelins wizard I think I spelled that completely wrong if you've ever used the contracts wizard from open Zeppelin it's using this same API where you can pick whatever token you want and add features so we're just doing this from the command line so I would like my nfts just to Auto increment and also have URI storage so Auto increment just um oh wait I'm not done selecting so Auto increment just bumps up the ID every time we mint an nft and then URI storage means that we can create our own like metadata for the nft whether that's image title whatever we want there so you could also add any of these other features if you wanted to but since this is going to be a pretty simple demo I'm not going to do that um I'm done selecting features next it's just asking me if I already have an Alchemy account which I do alchemy allows you to have RPC URLs so I have a bunch here um I created this key a day ago so I'm just going to reuse it and I'll delete it after this demo so no one will be able to grab my key and know it but I'm just going to paste it back into the command line and now it's creating this full dap boilerplate for me so it's going to give me all of the dependencies that I need for this and it'll have a front end and a back end so it'll create this hard hat repo for me and I'll basically have the shell of everything I need to do so all I have to do next is like my business logic and a tiny bit of front end which in a hackathon setting is great right because you don't have to figure out oh shoot how do I add wallet connect to Rainbow wallet or anything like that it just is already there so all you do is focus on whatever you're actually hacking on which I love the other really cool thing that Alchemy has is some component libraries so let's just check those docs really quick so you can see what's available if I was hacking this weekend I'd probably use a combination of the component libraries and then something like material UI or chakra to have a bunch of components so I so that you don't worry about all the styling but the components that are available out of the box for Alchemy are some things that include like an nft mentor and I believe also a erc20 claim so those are both great for really quick bootstrapping okay we're almost there with the bootstrapping and this is installing all dependencies so once it's done really all I'll have to do is run like npx hard hat compile and I'll have everything I need to deploy my smart contract come on Wi-Fi this is what I get for doing a live demo okay awesome so as you can see there's two more things to do add your private key in the dot EnV file and then run the application so I'm just going to copy over an EnV file that I have already uh and I'll just add it to so this is just copying it into my backend folder because I don't want to show you all my EnV file but now I've got that and I can just run the front end command to bootstrap our front end so I'll copy this in it is running on localhost let me just open this up in Chrome and this is what we have out of the box from Alchemy like I said this is the bootstrap site and we have a connect wallet button I'm just going to use metamask you can see I'm already connected to the zkevm testnet and that was all done for me didn't have to do a thing which is pretty awesome I don't know if you've had to do this from scratch ever but it can be painful so this is great and then the last thing I'm going to do is just deploy my smart contract so this was the front end repo that was generated I'll just show you the folder structure here so we've got a backend folder and also a front-end folder the front-end folder is just a next app that looks like this the backend folder is really similar to a hard hat repo if you've used hard hat before um and all of the commands are the same as well so let's just CD into back end and then the hard hat command is npx hard hat compile and what this is doing is it's taking the contract that we bootstrapped from the command line if you remember I called it cherry blossoms I had this as the um the short name for it and you can see that we've bootstrapped this with the URI storage access control that counters everything that we asked for in the command line so it was pretty simple there um I ran hard hat compile and I've got all of those solidity files successfully compiled and let me just double check the command for actually deploying in my package Json it looks like it is npm run deploy test net so that's just going to run the deploy script that was also created when this was bootstrapped and just to show you this is our hard hat config that was also created for us in the networks object you can see we've got polygon ZK evm mainnet and also the test net and those both have our Alchemy keys that we added so I'm just going to run that and PM and this will just start to deploy to polygon ZK evm testnet and we should be able to see the result of this in the test net Explorer so we've got a test net in mainnet Explorer they look very similar to etherscan if you've used those before they're just at zkevm.polyscan.com and you can switch between mainnet and testnet in the Explorer let's see what the contract address was so cherry blossoms our nft project was deployed here to this address and yep it was deployed about 31 seconds ago so the only other thing we have to do now is hook up the front end you can do that using those really nice components that Alchemy provides so I'm just going to pull up the components really quick so I can reference those as we add them to the front end okay so back in CW 3D which is just create web3dap checking out the components so you can either use collection display uh Creator Mentor or Gallery I'm just going to look at Mentor so we can mint the nfts from the front end really quickly it's asking me to create two files one of them is an nft mentor and the other one is just some styling I'll show you what that code looks like they've got really nice copy paste abilities here I don't trust my copy paste so I'm just gonna grab them from my finder where I pasted them earlier today so I'm just going to put nft Mentor inside of front-end components and then the styling can just go in the Styles folder here and then the only other thing we have to do is actually import these so we'll just add these to the page components Pages index okay I'm just importing those two components to the front end um and then it looks like this takes a few props so it's asking for the contract address and then also the let's see if I save this that'll format it a little easier for us to look at okay so first thing we need is the contract address we know that from our command line this was where we deployed about a minute ago so just adding that here and then for the token URI I'm just going to upload it really quickly to nft storage uh I created one of these a little bit earlier as well it's just going to look like this typically a token has a title and then a description and an image since this is cherry blossoms I'm just going to use an image I took two days ago at one of the gardens here just some beautiful cherry blossoms I thought I missed the season but luckily got one more Tree in so this one was waiting for me uh but let me just go to nft storage this is a place where you can upload to ipfs really quickly there's also like an API so you can do it programmatically but today I'm just going to upload uh where is it let's see desktop Tokyo hackathon so just uploading the token URI here it'll spit out an ipfs um link and I'll just add that to the front end so let's see is it this one nope okay we'll just use that one for now back in the index I'm going to change the token URI and then the very last thing is the contract ABI this is what gives our front end all of the knowledge about like what the contract actually looks like so I'll just grab this from the back end in where was it artifacts build info and then no artifacts build info and contract so I'll just copy this contract into the front end and inside of nft mentor where am I putting this sorry I'm just moving this file out and we'll just reference ABI from this file inside of index so import contract from all right if all went well in this live demo we'll see a updated let's see where did it go I'm hoping to see a minting site looks like it's loaded oh oh here it is okay so I'm gonna mint now we could improve the CSS obviously but this is the the general mentor gas seems to be weirdly very high but we won't worry about that quite yet and I'll go back to the contract and let's see if we got that minted successfully so we should see one new transaction that is a mint whew here it is let's check it out nothing ever works for me the first time so I'm kind of impressed with this so hopefully we'll see the nft minted to this address and that will be our create uh not create react app create what create web3 dap demo on polygon ZK evm so if I can do this in 30 minutes you all can definitely do this uh within the two-day hackathon but come on Wi-Fi let's go we'll see okay um I'm gonna go back to the presentation there's just one more slide and it is a QR code to the docs and then if you need any docs this weekend these is this is where all of them are for polygon ID ZK evm POS our prizes everything uh but I'm Steph and I'll be at the polygon Booth all weekend so if you need encouragement if you need help come say hi and I'm happy to help with anything you need as you're hacking whether it's polygon or anything else love to talk about web3 but let's go back and see if this actually loaded and worked please please we might just have to assume it did because I don't know if the Wi-Fi is loving me right now but hopefully we've got an nft of a cherry blossom thank you so much I'll just let it load until our next presenter comes Oh yay we've got it yay 