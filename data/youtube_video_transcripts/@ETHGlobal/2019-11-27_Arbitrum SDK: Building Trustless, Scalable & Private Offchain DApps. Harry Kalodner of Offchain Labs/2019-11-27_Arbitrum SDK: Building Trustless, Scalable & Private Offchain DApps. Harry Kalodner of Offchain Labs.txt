yeah so I'm gonna talk about the orbitrim SDK so arbitral is layer to scaling platform that my company off-tune Labs is building to enhance the scalability of aetherium and kind of the the fundamental goal is just to unlock unlock the power of DAPs to make it the etherium has a lot of limitations in place in terms of kind of what's feasible to actually do on the blockchain in terms of expense in terms of capacity from a lot of perspectives and the goal is basically to get around those limitations and unlock a lot of cool potential so why why does the theorem itself not work well kind of fundamentally it's a network where every single miner has to execute every single contract and so you can't really adding there's no way to really scale it up adding more nodes doesn't help because they all have to do the same work you have to have kind of a limited capacity because everybody has to be able to verify everything and that leads to a need to have gas costs and gas limits and so imposing kind of significant transaction fees on users which are kind of a significant significant adoption barrier and kind of rule out a lot of applications where users wouldn't want to pay kind of a significant fee when the when the network gets more usage and and reaches capacity which kind of happens when some random company is doing a token giveaway and suddenly gas fees go through the roof which is not good if you have a legitimate application and additionally all conduct code and data is public and so fundamentally kind of if your application if for if your application you don't like the idea of everybody in the world being able to see everything that you're doing um then you have a tough time using a totally public smart contract platform and so our Bertram I think gets around a lot of these limitations and it does it without sacrificing security at all which is really great because we can kind of keep the same major advantages that aetherium has while just removing disadvantages and so Bertrand provides away rather than doing rather than having all of your contract execution on chain you can instead have the scripts run off chain while still having security and I'll talk a little bit about how we do that and later this afternoon or my co-founder Ed Felten is going to be giving a technical talk about our Bertram that will go into a lot more detail of how we accomplish that but kind of fundamentally what it comes down to is rather than executing all your code on the blockchain directly on a theory and what you want to do is you want to execute most of the time off chain because most of the time people are happy and people will agree but when there's a dispute you want to be able to settle it on chain and you want to be able to do so efficiently and that's essentially what our Bertram accomplishes and we do it in a way that you can just use your existing solidity contracts there's nothing really new to learn there are a few tools that you have to use but fundamentally kind of one of our goals is to essentially have as low a learning curve as possible there are a lot of layer two solutions out there and fundamentally a lot of them are pretty hard to figure out how to use and so making adoption easy is is really valuable and so are Bertram does this through kind of a combination of pretty reasonable tools so we have a sophisticated protocol that essentially makes sure that you can run your contract off chain securely we have incentive mechanisms in place to make sure that the parties to your contract actually operate the way they should and we have a custom virtual machine architecture that is optimized for this off chain context since essentially running a contract off chain it's pretty different than running it on chain and the things you care about are different and we've got them optimized a lot for that so kind of the fundamental concept that arbitrary uses to make things fast is this idea of validators and so when you spawn a contract for Arbitron you specify a list of validators for it and they are the only ones who have to run this contract and the really cool thing that are betrothed is if any single one of these people are honest then it'll run correctly which is kind of nuts I mean essentially kind of normal systems you require kind of 2/3 of people to be honest or at best half of people to be honest in terms of kind of for aetherium or for Bitcoin if kind of most of the hash pay if more than 50% of the hash powers malicious your systems totally broken whereas with arbitral you only need kind of a single one of these validators to operate correctly along with having the etherium blockchain itself operating correctly of course but providing a lot of scaling on top of that and so essentially what the validators do is most of the time they just unanimously agree as to what the next step is and they run the execution locally and they're the only ones who have to and 99.99% of the time they're all friends and they're gonna kind of and nobody's gonna cheat and everybody's gonna be friendly and you're gonna be able to execute instantly off chain and your transactions are gonna be final immediately so you don't need to wait for the two or three minutes or whatever it is where your transaction is is pending waiting confirmations on etherium which is kind of a horrible user experience and instead you get kind of that security instantly so where we are today so there's a public alpha of our Bertram that's usable today it's a system of kind of smart contracts along with nude software that runs alongside aetherium and on top of aetherium in order to enhance it we support running existing solidity contracts on Arbitron which means that kind of the learning curve is very low and those contracts can contend to receive either a Thor any other or any token which means that you can kind of that this off chain solution is still interoperable with all of the great on Theon chain things so a little bit about kind of what our Bertram looks like from a technical perspective so essentially kind of the process of using our Bertram is reasonably straightforward so you start with a solidity smart contracts and you compile it down into into a virtual machine just by kind of running running the compiler and the main way we support this right now is just as a plug into truffle you then distribute this machine to all of the validators they make a call to a non chain smart contract in order to create this this virtual machine or this contract and then they just function offline passing messages between each other and so the blockchain is involved in that it's kind of tracking the metadata for this contract but everything else happens happens efficiently and securely off chain so that's essentially what what the deployment side of things look like and the other side of things then is the front end so how does how do you how do you actually write applications that talk to these that talk to Ann Arbor term contract it soft chain it's not a regular contract on the blockchain how weird is the experience of building on it well it turns out it's actually really easy that kind of fundamentally an awesome thing about how aetherium tech has developed is that all of our front-end interfaces so web 3 and ethers being the main JavaScript ones and then there being kind of others and other languages are super pluggable and so essentially what we give you is we give you an arbitral provider package that just plugs into your existing front-end and kind of instantly ports it to two instead working in a with a off chain orbitrim contract so just to give you an idea I think yeah just to give you an idea of how how easy this is I'm gonna walk through just kind of a quick example of how this porting process looks so I'm just gonna start out on on our developer QuickStart which provides instructions for getting all this stuff set up and I'm gonna start with just an existing solidity tap with an existing front-end that's just kind of totally standard unmodified and I'm gonna walk through the process of modifying it and so let's do that I'm gonna make sure everything is nice and big so we'll show up and the goal of this is basically just to demonstrate this stuff is is totally user is totally easy to use that that you know the bar the bar to taking advantage of these of these advances is very low so I've already gone through the setup I'm not gonna walk through that here cuz because installation and dependencies and stuff is boring but it's all laid out there but I'm gonna start with our reporting God so we support any truffle based product projects any front-end using web 3 or ethers and kind of as long as your as long as your DAP has kind of some sort of reasonable build system which kind of basically everybody does if you're doing anything that is has any complexity whatsoever and so I'm going to demonstrate this out on a on just like a fun little connect for application so betting on and playing Connect four on the box chain it's a horrible idea don't actually do this because other people will just use bots and you'll always lose oh but it makes a really fun example and it works well if you're playing with friends who you trust not to uh not to cheat it looks cool so it's a fun little demo so to start out the first thing we need to do is we need to work on that back-end component we need to make sure it actually compiles and so the thing to do there I'm gonna open up here is the code for our connect forward app and the first thing to do is actually get it hooked into truffle so normally with truffle you didn't you deploy on a chest net or you deploy on main net or you deploy and ganache and so what we're adding in is to deploy on Arbitron and so I am just going to copy and paste this somewhat ugly blob of code from our developer QuickStart which I can just immediately post into my truffle config and slot that in and then all I need to do - oh and then the next thing I need to do is I actually this sorry I'm jumping around a little this depends on this ARB provider package that we provide and so I'm going to add that as an import and I am going to add that dependency which is um yeah it's actually it should be picking it up locally I'm just going to skip that step because I don't actually need to use it because I already pre pre compiled this stuff interesting so essentially the first step in any job I'm gonna go through these instructions it will work but essentially the first step is to plug into and compile with truffle and so the kind of the fundamental idea there is we provide this kind of arbitrary at work back end and then all you need to do is run truffle migrate I mean instead of specifying kind of production or test net you instead specify that it should deploy on orbitrim and essentially what that does is it pops out this lovely file which is contract audio and so essentially what that is is is kind of rather than the truffle migrate actually deploying on a network it just pops out this little file which is like this is your contract and so this is the thing that needs to be distributed to all of the validators and so essentially kind of once you have once you have created that the back end is all set and now you just need to deploy so for the purposes of our alpha we've made the deployment super automated because when you're in alpha and you're testing it's nice to have everything automated in one click and so we provide this tool arm deploy and essentially what that does is it launches docker it launches in docker a local ganache instance to run a blockchain it launches however many validators you specify so here I say to specify to launch three validators for your block for your application and we specify the contract file that we're using and so you've kind of fed it kind of the only to the only two parameters that matter are how many validators and what you're and what the code they're gonna be running and you run our deploy and that launches everything that one should work well and a lot of flashing text goes by this essentially goes through the process of deploying our Bertram which involves kind of compiling all the components launching them locally it does essentially everything that you would otherwise kind of do amongst multiple multiple computers and it also does kind of the deployment of the kind of on chain orbitrim contracts which once were live on test net will just already be there for you but this essentially provides you a totally self-contained environment to work within which is great for testing where you just want kind of a one-click setup that will launch your DAP without you needing to do any work so that is the kind of that is the back end component and that is kind of from my slide what we've done just to recap is that and I didn't do this live but I've compiled it with truffle to output an AVM program I've launched the validators and the eath bridge which is our on chain contract which actually manages your which manages your off chain orbitrim contracts and tracks metadata for it and all of these parties are now in communication and are running our contract so the next step and I think just for ease I am going to actually just grab my my modified version and so the next thing to do is we want to modify the front-end to get it working and so that's very easy so essentially kind of if you have an existing tap and in this case we're gonna you we're gonna use web 3 it will have it will have code which will set up the web 3 provider and so that it'll set up essentially whatever your connection is to the blockchain and so a lot of times if you're setting it up to work with meta masks then it'll grab the provider object from meta mask and kind of the big thing that we change with our Bertram is that we add this ARB provider and so instead of directly creating a web 3 provider you instead pass essentially your connection to the etherium blockchain into this second layer provider so much like our Bertram is kind of a layer 2 solution on top of etherium the way we communicate with the blockchain is essentially by wrapping what you would normally do with the blockchain inside of kind of our higher level provider which has the ability to do a lot of kind of what you want to do off chain and that is it and so essentially kind of the the only changes we've had to make are we used we modified the truffle network that we're deploying to in order to produce our compiled contract we modified the web through provider on the front end in order to talk to our validator rather than to talk to the etherion box chain and you and I used ARB deploy in order to spawn validators for this contract and that's essentially the entirety of the modifications necessary so then we will see if this works or not this should be fun so I just essentially launched a web server for my DAP and this is just running kind of the code modified in these very simple ways if we go to it so we're gonna start out this is kind of I'm running it locally but I'm just running with kind of a normal metamath instance that's connected to ganache running on my machine and the codes been modified to use the correct provider and so the goal here is essentially that it will not look any different than if you were using a normal contract and that's really the dream of layer two is to kind of have the experience be kind of exactly the same as if you were as if you were kind of using standard aetherium and so I can kind of use I can I can make transactions when there are transactions that are involving payment they're made on chain and so those look fairly standard but the trick is once I start actually playing the game I'm no longer going to be making any on chain transactions these are going to be completely off chain and so if you see here I'm not actually gonna pay at all I'm just signing something and so there are no fees whatsoever and so I signed this message and it accomplishes essentially what would be accomplished in kind of a normal etherium contract on chain without touching the blockchain at all and it does it without any decrease in security and with next to no modifications to your DAP and that's kind of the magic of arbitral and and this is kind of the the entirety of the changes that I made and I and I was just playing around at this last night so this is the entire diff it might be a little hard to read but essentially so we have the modification to truffle we had a couple dependencies and we add that provider and that's it and then you're up and running and you have an infinitely better experience than using aetherium directly in terms of latency in terms of costs and in terms of kind of capacity and complexity of what you can do in your contracts yeah yeah so that's I think about what I have prepared this is all live and totally usable the we're kind of have our alpha two out we should be on test net in in a couple months and then live on main net hopefully some point early early next year it works pretty well and yeah there's an API prize also so if you're if you're interested you should definitely try it out there's a lot of cool stuff you can build on it so yeah thanks for listening and and I think of a couple minutes if there any questions right so I mean essentially the idea is that and kind of what it comes down to is transactions that involve sending or receiving money still need to be on chain but any transaction that kind of just mutates the state of your contract internally which like in the example of a game would be kind of all of the moves in the game or if there's a contract where like trading if you know people deposit their money and first and then they can do kind of arbitrary trading kind of within the contracts and all of that can be completely gasless all of that can just be kind of sent off chain but with the same security of an on chain transaction um yes somewhat um so the big and on our developer website we have like a section which is kind of thing solidity things we don't support the main thing of which is kind of direct synchronous calls so this is kind of an interesting thing like you can't if you're operating in an off chain context you can't directly call into an on chain contract and have a execute immediately so that's essentially the main restriction so if you have kind of a DAP that is made up of a bundle of contracts they can be launched together and communicate synchronously no problem so it's kind of the issue essentially comes up with with integrations with other gaps we're we're working on a number of solutions fundamentally it comes down to you can make calls to them and receive calls but you can't actually have the result immediately so it's doable but it's definitely kind of in on the research side of things really right yeah no it's a good question um and and I'll give a short answer and then my co-founder ed fountains giving a talk at I want to say too but you should check your calendar if you're interested and he'll dig much more into the details the the fundamental problem so there is no fully general solution so essentially the biggest thing that we can provide is that a single as long as a single validator is still running people can make calls to your contract and so you don't need kind of everybody to participate fundamentally if your contract is coded that it can't like that there it can't make progress like you know if you're waiting for a move then you need to you know have a timeout or something but kind of the best we can do and it really is a big thing is make it so that even if all the other validators disappear you could still you can still make so you can still make calls to the contract you could still execute whatever function you want and it'll execute correctly so that's kind of where we where we fall on that Oh totally yeah oh that's kind of the the the beauty of our mushroom is this is this kind of what we call the any trust assumption that only a single validator needs to be operating correctly for the protocol to remain secure and so as long as kind of there is someone who's not compromised the protocol continues to work it slows down a little but all yours your entire contract still remains off chain the cost still stay low it can't make it can't execute quite as fast but everything keeps working even in that case like as long as not as long as you don't have a hundred percent of the validators of your contract compromised and essentially kind of the way that's accomplished is that there are two ways to make progress and I didn't go into this too much but I mean I have a lot of time so that kind of there's a there's a unanimous way and there's a non unanimous way so the unanimous way is is very akin to state channels for anybody familiar with those where essentially all of everybody agrees they can just sign an update and say hey this happened if any single validator is honest then that won't be malicious that will just execute correctly so the interesting question is is what do you you know if you don't want to assume and you don't want to rely on just having kind of on having everybody be available then you need some other way to make progress and essentially the way that that works in arbitral is a single one of the validators essentially proposes an update and any other validator can challenge it and so kind of there's a definition of what's corrects and arbitral provides a really efficient mechanism for resolving disputes essentially over whether that proposed update is is correct or not and that kind of that's what that's how you get this kind of like magic of you don't actually need to trust that that kind of many people are honest yeah I'm happy to talk about it offline I will convince you it makes sense awesome cool so yeah I will give it up to the next talk thanks for listening 