great um cool thanks for your patience everyone and thanks for joining us on um saturday for this session um alan from protocol labs has joined us today um to introduce the interplanetary timelessness ipfs and filecoin for the nft long haul and yeah i'm going to pass it over to alan to introduce himself and yeah get the session started hello everyone let me just share the things uh okay um hi okay so this uh i am alan as you just learned uh this is ipfs and filecoin uh for the nft long haul i'm an engineer at proscale labs um and i'm pretty new to nfts as i um i guess we kind of all are really um but when i found out about them and i started getting interested i was super stoked to see that ipfs was being used to store loads of them so for example if i just head on over to to this this nft site here and i look at pretty much any nft i can do a little bit of um spelunking in the uh ethereum ethereum blockchain um like this there we go i don't even have a contract and look it's an ipfs hash wow that's awesome and so i can just bring that up and then that's cool that's super rad that's really awesome um so i was super um uh super excited to see that um and uh yeah very happy so um as i was learning about nfts um i kind of came to realize um or we talked a few different um nft uh nft application builders and things um but i came to realize that the developers that are actually enabling nft creators um so like apps like foundation like super rare uh like zora um they really cared about users being able to access their data like if they were ever to just disappear from a planet so if they would go away they don't want they don't want all of that stuff to go away because um because it's important it's uh it's entities it's things that people have bought and they don't want that data to just disappear so i i confess uh really fits this bill and can solve um solve that particular problem so it's not really surprising that um it's it's being used but um in case you're new to ipfs let me let me just explain okay um i chose this uh particular nfc at complete random i think it's some um a picture of like some mountains or something uh generated um but like if you put some data on an ipfs node um first of all you get a cid a content identifier and that's that uh fk string there and that's a hash of the of the content and content when you put it in ipfs is immutable so it can it can never be changed so that cid will always refer to that content so that's super useful if you're going to put that data on a blockchain because it means that uh when you when you next request that cid you're kind of guaranteed that the the content is exactly what was put there by the creator um so that's really good as opposed to like a url where um where the the things like uh things happen with urls like domains expire like uh people uh update uh content uh for behind the url to be something different so you might have a picture of a cat and it might become a picture of a dog later people might have like a google drive that they've that they've set up and they're paying for and they don't pay for it anymore and then the link goes dead and uh so then you have to get that updated somehow and like you don't have to worry about that with cids because they are addressing content they're not addressing a location on the internet so so that's that um now so how does that work well if someone someone else requests that data so they ask for that particular cid then they'll receive it um and now two nodes in the only ipfs network can serve that particular content and that's that's super cool um so it would happen like this someone else comes along and it requests that cid and then both of those nodes are able to process that request that's that's cool so he gets it as well um and so the awesome thing about this is that this original node that had the content it can go away it can just leave the network um and uh and it's gone and uh and later will still be retrievable from the other two nodes so someone else new comes along and they are asking for the same cid other people still have it so that is awesome um there's two caveats to that caveat number one is um if all of the nodes that have that content go away then then then that content will no longer be available on the network so uh people come and go uh if if this if it's a a node running on a laptop then uh that laptop could be closed people could leave the coffee shop go home and then reopen that laptop later but the interim period between leaving the coffee shop and coming home if no one else on the network has that content then and someone else wants it then they're not going to be able to retrieve it so that's how not uh ipfs uh first goes in that respect and so the second caveat is garbage collection and so depending on your um your garbage collection configuration that might run on an ipfs node at like a particular time um when you're configured storage um when you're configured repo storage limit is hit so if you if you retrieve or put too much stuff in it then and it reaches that limit then it will start to garbage collect and reclaim that space um or it can be run manually so you can run it from the command line um and or you can run it uh it's like an api call as well if you want um so really you need to tell ipfs that the content you have is not actually garbage um so the idea that this super rare nft is not trash uh it should be kept and so in ipfs that's referred to as pinning which is kind of a weird weird thing to kind of um come across and uh and understand if you're new to ipfs but that's what we've got so that's that's what we have um and if you don't pin the data then it will be eventually be garbage collected um so it means that even if content is super popular on the network loads of nodes have it um then it can still eventually leave the network if all of those nodes happen to garbage collect or leave the network so it's this permanent problem that we have um and so these two these two caveats are why developers generally use a kind of third party storage like pinata like textile like um fleeq to store their content because they deal with these two caveats by having nodes that stay online and they also pin content so that it doesn't get garbage collected from their nodes so they deal with that for you there's always going to be a node or at least one node with that content so so there we go um so nft dot storage so this this is a new thing it's a it's a kind of private beta it's a it's a present to all of the uh all of you nft hack participants and it's a place where you can store all your nft data uh safe in the knowledge that it'll be there tomorrow um and it's hopefully goes some way to addressing that permanence problem um and so yes it's uh it's free um and for some gigabytes uh for as long as we can as long as we can keep it free um and uh and the whole idea about this is it should be easy we have a kind of simple js api client we have a simple uh http api we've got a api schema that you could generate clients from potentially so we're not just restricted to js you could use it in other languages as well and eventually we're hoping to maybe add uh remote pinning service api if you if you're familiar with ipfs you might be familiar with that as well um so that you can use it if you're using ipfs in your uh in your apps then you you will be able to put stuff in ipfs and have it uh sent to nft.storage without using a client so um so there we go um so how does how does nft storage work well you upload your nft data to dot nft.storage like that and nfd dot storage will store that data on um on ipfs nodes that it knows about and it will obviously pin them there so it stays available in these nodes are publicly available nodes data is pinned so it won't be garbage collected um okay so so far so good uh but what is different from your uh kind of regular opinion service like pinata well um behind the scenes um nft.storage is um is negotiating deals to store your data with miners on the file coin network and um and the filecoin network incentivizes miners uh to store data and they get they get paid to store data and they also typically get paid when data is retrieved as well so um it ideally this is kind of a really profitable experience for them um so they have strong incentives to store data and continue storing data as well but they also if they if they fail to continue to store data then there's heavy penalties so there's they're really um they're really incentivized to not lose the data um so that's file coin um but why is that good well um if nft.storage goes away uh and every ipfs peer who ever fetched the content went away um then these miners will still have the content uh and so you can think of miners as just another set of peers we've really strong incentives to continue storing the data like this is the addressing this whole permanent problem and the fact that we don't want this expensive nft thing that i've thought to just disappear forever uh which would suck so uh this is nft storage um all right now let's uh let's do some demoing here comes some live coding i'm gonna stop my share here and um uh try and share my whole screen instead of just one just one thing here okay let's go over here uh i need a new terminal window so this is a demo of the um the js client for you guys i'm just going to create a directory i'm going to call it x for example and the first thing we need to do is do a i'm just going to npm in it in here yes looks good okay let's open this up in code whoops go nope just one [Music] what's happened there oh i'm already in that directory okay here we go okay so first up um i'm going to show the nft storage client and we're going to try just running it in node.js and we're going to try and upload some content uh to nft.storage and then we'll have a look and inspect it on ipfs so let's uh let's quickly do that um so i need to install the client uh is that is that big enough for everyone let's see dot storage here it comes cool let's create a new file i'm kind of showing you this because it should be really easy it is pretty easy to do i'm just going to import the nf50 storage so this is the class from the nfc dot storage package that i just installed one thing i need to do is just tell tell node that this is an es modules project module there we go i'm just going to create a function a main function uh and we'll just call that immediately uh but in here what we're going to do is uh create a new instance of the client there we go and all i need to do is provide it with a token so this is an api key that we get from the website uh so uh what i'm going to do is uh head on over to the browser here we go let's just close up these other windows uh so this is the website um but once you've logged in i'm already logged in you should see a manage api keys and files here in my api keys i have no ipi keys i'm going to create a new one quickly i'm going to call this x so it matches up with my example um here we go uh so what i'll do is after this demo i'm going to delete this key so don't try to steal it but you know what it's free so you can create your own account anyway so you don't even need to steal it um so i got my api key what i do is i just head back over to my project and add that in there there we are and uh to to store data on nft storage um we need some we need some content first don't we so uh let's create some content i'm just gonna put a uh if this will work sometimes my emoji keyboard doesn't appear which is really annoying uh and so i'm gonna use a uh okay star eyes emoji because this is going to be super rad um uh and so what we'll do is we'll use the client.store blob method oh one thing i didn't say is that this module also exports blob for use in node.js because it's not supported natively so we'll import that here um and we've got our content um and if i want to store a blob then i just need to give it a blob so this is how you create a blob from a string and what that does is that will store the blob and it will give me back a cid a content identifier for that content so i need to await this because it's an async thing and all i do is i will log out that cid but what i'm going to do is actually i'm going to put in a um a gateway url here so i can just click on this from the console and and see it in in the browser there we go so gateways um protocol run a couple of ipfs gateways um ipfs gateways are for um for extracting data out of the ipfs network from the old world and to ipfs the old world is the current internet that you use the http internet that you are using every day and and so these gateways allow you access to the peer-to-peer ipfs world via a particular centralized point which is uh not great for the decentralized future that we live in but um but in terms of like seeing things in browsers is super useful uh so uh there are this this is one of uh many um public ipfs gateways and any public ibfs gateway that is uh providing access to the ipfs network you should be able to use any one of them to extract the cid so there's no need to tie it to a particular particular gateway necessarily because you should be able to access it from any of them and so if i um if i have a look over here there's a list of public ipfs oh yeah gateway checker that's it good i'm glad that came up i can completely forgotten the url um this is a list of loads of different ipfs gateways that exist it's just doing some status checks on them to show uh show you but like there's the dweb.link one and the ipfs.io1 which is sir with uh yeah i referenced the io so these are the ones that pl run um there's there's like a cloudflare one i think somewhere uh there's a pinata one there like so there's lots of public gateways that you could use um and they all provide access to the ipfs network so all right enough talking let's run the code uh so if i've written this right then i should be able to just node index uh i need to save it first of course hooray all right and then so i get this link so i've got it's given me back a cid for the content that i stored i should be able to click on this link and then that should load up uh the so this is retrieve that data from the oh what's going on here uh yeah this has retrieved the data from oh cool i've changed my search engine somehow okay uh never mind it's fine um and we can see the emoji let's make it bigger hooray we've got star eyes awesome um so that yeah it should be super easy yeah uh and the other or cool thing about this um about this this client is that you can use it in the browser as well so if i create a index.html file uh give it a yeah give it a doctype so we don't get any quirks modes or anything like that i'm going to use a module script um i should be able to copy and paste this code directly in the in the browser and sorry in this html file we don't need blob because browsers have blob already um what we can't do is use like npm modules but we can use uh like a cdn that provides access to http uh to it's because i'm typing http uh to access to npm modules um so we can use for instance uh skypack and um really that should be all i need to do let's try and open it in the default browser i should see nothing in the browser but if i open up the console then i should see this link link uh logged out and this is the same this is the same as before so let's just um just to prove that this this kind of is is working let's use um never works when i need it to um i'm gonna use a uh like a sun um let's use a sun instead um because you know like to be where's my thing go here we go uh so let's try again ah here we go okay so this is a different cid when i click on it the gateway should load it up and there's a sun hooray okay sun sunshine okay um cool what else can we do um we can store multiple files uh we so this is called like a store directory and so i'm gonna get rid of this um store directory here um i'm to get rid of the blob i'm just going to put that down there install directory um and we'll add a file input here multiple attribute because we're gonna select multiple files uh we need a button uh upload do the upload uh and instead of a main function here what we're gonna have is a dot group query selector and we're going to get a hold of the button and when it's clicked what we're going to do click async you can event and then stuff stuff goes in here i don't need that anymore so when the button is clicked what we're going to do is uh first of all let's make this a bit bigger um first of all we're going to get hold of the the file input so equals input sorry uh and um cool so the file input has a f files property uh this is a file list the um the store directory um api call takes an iterable of files so you can pass it like an array file list is iterable has there are files in it so we're just going to take whatever files that we've selected here stored them in a directory we're going to log out the cid so let's try it out okay so this is my gift folder where i keep all my awesome gifts i'm going to use this room guardian and hello this is dog picture here upload those two i should see nothing here but in my console i should see a new cd if i click on this then when ipfs loads it at the gateway we've got we've got a directory this is a directory listing that ibfs is generating for us and it has these two pictures in it so hello yes this is dog um we've got these two pictures and uh this is really useful um even if you've got just one um far file that you want to upload and to put it in a directory because you then retain the file name in the um in the in the url um and that's useful for when people want to like um right click and save save image ads because they get a file name with the extension and then their computer can open that particular file with the correct application etc etc um so uh yeah that's that's super useful okay there we are so what else what else would we want to do um well uh we might want to get the status of of our particular cid so we can use the pass it the cid and wait i've realized i'm just writing this completely backwards and i wouldn't normally write code like that but we use the client status it's just the way i'm explaining it um we're going to log it out as well we want we might want to query the status of a cid because we want to inspect um like how how big that file is it tells us the size of what of all of the files that we've uploaded um but it also tells us information about the deals that are being made in filecoin so we can have a look and see if anyone any file query miners are currently storing our cid um but it also has information about the pin status um so uh yeah it means that which means that um has it been pinned on ipfs node yet and for all of our all uploads it should already have um when we implement the remote pinning service api then um it's not uh it's async so you'll submit something and later it will be pinned and you'd want to check the status in that case so let's uh let's just have a look see see how that works okay i'm going to choose some i'm going to use uh what should i use uh this one have you seen the dog that's a good one um one from the bottom all right couple uploads there we go let's have a look yeah here we are okay it's cool so then we've just logged out the um the uploaded stuff we've got cid we've got a created date we've got the file sizes size and bytes of all the stuff we've got a d a pin pin object here uh which just has which is the interesting part here is the status pinned uh which should be pinned for uploading using the client already so you don't really have to worry about that this one deals this is the file called deal status and this will take a while it take because a making deals with file coin uh minus takes a while they have to receive the data they have to then um do a process called ceiling uh then record it on chain so it takes it takes a little bit of time um but also it will take a bit of time because what we're doing behind the scenes is batching up data and when we've got enough that's when we submit um submit a uh a uh a deal to uh far coin miners and there might be uh more than one uh deal that we try and make so that we have it on multiple miners uh but also because uh we've got some experimental code we're running some experiments behind the scenes for for fun but also uh for research um and so there might be deals made with uh miners that are running on test nets which is which is super cool so um so let's have a quick look at what you might expect to see if i just open up this sample json that i prepared earlier where are we did it open up anyway i'll call xcode no no thank you let's just open that with something that might not take a year to load up okay uh so this is it's gonna be an array of deals and the order of the array is important they are the the most recent ones will the the order is the order in which they were uh created um so this is one that has just literally just been uh been created and uh and it's queued it's getting in it's getting ready to be uh put into a uh into a deal uh for a minor that it's being batched together uh and so this batch root cid that's like i said we're batching all these together and then that will become its own um its own dag uh and we will have a cid associated as well um what else we've got here so we've got miner this is the address the uh the address of miner here we've got like i said this is not mainnet like this one just below it's this is this is nerpernet so this is uh this is a test net and this is why the address begins with t and not f because it's test um pcid here for this one this one so this one status the status is the interesting stuff this is being proposed this is like it's all been batched together and we're talking to the miner about a deal we're negotiating it right now uh pcid is um so this is when um when data has been uploaded uh there's this process that miners go through called ceiling and the data becomes a piece which is a car it's not a motorized vehicle it is a content archive and then and that's what gets what gets stored um so this is the cid of that um that piece this one the deal has been accepted um so we are um we are uploading data uh it is being sealed uh and it hasn't yet been recorded on on chain this last one has failed so this is like in between uh in between being active and uh and accepted uh it could fail um for whatever reason so there we go we've got another one right here which is active so this is one that has has succeeded and finished this is the id of the deal which has been recorded on chain the deal activation so this is this would this is actually an epoch but it's been transformed into a um a date time you can obviously back back form back transform anyway uh deal expiration is when that deal uh will end um and obviously last chance i don't know if i talked about that but that's just a date stamp of when when things last changed the minor the network the piece and the uh the status so that's deals in the response for an ftd storage um and uh i think that's all i needed to cover uh with your um [Music] uh yeah go and check out nft.storage um if you are using if you're if you making minting nfts in your hacks then um then please feel free to make use of it it will it will help us because actually like i said like i alluded to there are experiments going on it's helping us realize like what the what um kind of deal flows look like and how how we can streamline them and make it better for the uh nft community um so we're trying to try to figure that stuff out we're also trying to figure out uh the stories of like how to retrieve from file coin how could to retrieve data from file coin via ipfs and things like that um so and if if you use this service then you're really helping us to make uh ipfs and filecoin a lot better in the future uh but also for particular um in particular for uh nft community and the types of data that are being stored here uh the metadata the storage size and and also things like that good information that we can use um going forward uh so thank you very much for listening um and uh go and use nfd storage go and go and have fun uh let me know what you think uh i i'll be hanging out in the there's a sponsored vertical labs um channel um so if you have any problems or whatever um thanks for listening great thanks alan um yeah that was a really interesting session that you took us through um yeah there's uh just two questions one of them from youtube so i'll just read it out to you real quick is um i guess it is planned but could you give us a hint on how it follows until it is sold in zora how sorry can you repeat that i guess it is planned but could you give us a hint on how it follows until it is sold in zorah oh okay so um so i can i i i'm not super um familiar with the process of like minting nfts i've read some tutorials and things like that so i kind of get what what's going on uh in general there's a really there's a uh there's a kind of uh let me show you on the here we go the nft storage site let me share my screen again okay we tried to put together oh can you see that did i do any sharing no i didn't so yeah here we go you're sharing your screen okay so um we tried to put together like a kind of typical uh sort of flow thing where you as someone who is minting nfts in some way this is kind of nft.storage is just a small part of that minting process where you've got this problem of like i've got some something an nft like typically artwork or something that i need that needs to be minted um and it needs to be stored somewhere and normally uh like it's exorbitantly expensive to store uh data on on-chain so there's this whole like off-chain storage and and this is what nfc storage is trying to solve um and so you'd have you'd have your artwork um you want you need it stored somewhere and this is where nft storage comes in is that you upload it here and then you when you get back the the hash that's when that's the that's the thing that you can use in your minting process that it you will put in the data that will be stored on chain so exactly that there are ways and means of of doing that and it it really changes depending on um on on provided like um and it's especially if you're if you're doing your own hack where you're minting nfts it's kind of up to you how you want to uh to store uh the data there are certain standards that are not uh not like global at the moment i think for storing for like metadata formats and things um but yeah there's no like this is exactly how it works uh uh way but this is a small part of part of it you get your cid and then you can use that in your metadata in your mint nft that makes it on chain hopefully that answers it a little bit um i think we just got time for one more question and then we'll close up and that is is it possible to have the hash of what we store too uh so i guess cid is essentially a hash it's not quite the same as uh as your your usual hash because it's the cid from ipfs is a cid of a of the root of a tree of um it's called a dagger directed acyclic clock graph um and and so the cid is the the cid of a root node of a bigger tree so it's not it's not the hash of all of it but it's it's it's it's as good as um a hash um yeah i guess if you wanted a hash of the data then you could you could do that yourself uh before you upload it to nft storage you can get the hash of that data because you'll have it already cool thanks um thanks so much alan that was a really great session and thanks for sharing some of your saturday with us there is one or two questions in the zoom chat that i'm going to copy paste over into the sponsor protocol labs channel and yeah alan will answer those questions in the discord channel so just keep eyes there if your question hasn't been answered um during the session uh yeah cool thanks alan um have a nice afternoon or morning everybody and we'll see you at the other 