we have hardik here from learnweb3dow and who's going to do a workshop on build a completely unchained dial with automatic proposal execution um zoom questions will go into the zoom chat so if you have any questions definitely feel free to send it in there antarctic will answer them all at the end of the workshop the workshop is an hour long and it also is recorded and streamed live to youtube um for you to refer back to it anytime after the workshop ends and with that being said um i'll pass the mic off to heartache perfect thank you anna um hey everyone um so we're gonna learn how to build an on-chain dao with automatic proposal execution and actually like what does all that mean um so a little bit about me i'm hardik um fun fact i have no first name legally um i'm the co-founder of learn web 3 dao a huge decentralized identity maxi i currently work at three box labs the creators of ceramic network and x dapper so today we're gonna spend some time roughly in three sections so i'm gonna do about five minutes on trying to explain why we're doing what we're doing um spend most of the time actually coding out the contracts and then i want to hopefully leave 10 to 15 minutes for questions and answers at the end so what is what is a dao i imagine a lot of people it might be your first hackathon so just to give you a quick overview adao is a decentralized autonomous organization essentially they are community-led entities that have no central authorities and ideally they're supposed to be like fully autonomous fully transparent but it's not exactly the reality we live in today um and the reason for that is um so maker dao and moloch are two very prevalent examples of on chained owls where um proposals happen on chain voting happens on chain everything is on the ethereum blockchain for you to look at but mostly all other dows uh are off chain right and this means that like tools like snapshot or tally you go there and you do you vote on snapshot instead of on chain um and what this ends up doing is like so often does have some pros i'm not saying they're bad there are pros right you can get voting without gas so you don't have to pay gas just to vote on a proposal so potentially you get more voters if you have an off chain dow and it's also very easy to take part in them right you just open snapshot you connect your wallet and then it's a single interface for like 100 different dows the cons are um off chain voting does mean that proposals don't automatically get executed even if they pass so you have to rely on like the project team with like a multisig wallet maybe to actually execute the proposal after it has passed and recently um there have been a couple of cases as of late where a proposal which passed on snapshot didn't actually get executed because the team didn't like it even if they actually did pass on snapshot and it's off-chain you need someone you need the team or the multisig to execute it so like you can't really do anything and that goes against the ideal vision for what a dow is supposed to be so on chain dials also come with their pros and cons right they're not a silver bullet so you don't need trust you don't need to trust a team to execute the proposals and everything is verifiable and transparent on chain which is arguably better than on ipfs but the cons are it costs gas to do votes and um general purpose now where proposals can end up executing arbitrary transactions require some like specialized interfaces on the development side to properly construct those proposals in an easy-to-use way so today we are going to build an on-chain down i know it's going to cost gas to vote but we're going to focus on the trust problem and it's going to be relatively simple though so we have an nft collection we'll call it crypto devs nft um we'll create the crypto devs dao and the way it will work is every person who owns the nft uh can choose to be a member in the dao and the dao has some eth that it controls and then it can buy and sell other nfts from a secondary marketplace so something like openc um so members can create proposals hey i want to buy this or i want to buy that and the dao is doing the purchase so voting happens and the dao either does a purchase or it sells something and the idea is to like maximize profit right um so specifically for this tutorial i we don't have enough time to do every single thing here um so what i want you to do if you're following this live um here's a github link so go to github.com slash learn web3 dao slash dao hacks dash workshop so there's a github link where i have set up uh some boilerplate code so the nft code is already there um actually i'm gonna walk you through it right now but yeah clone this repo if you're following along if you're gonna do this later feel free to pause here and get started so let's switch over to vs code so i have the repo cloned and let's just quickly take a look at what's all in there so in the contracts folder this is a hard hat repo in the contracts folder there are three contracts so the first is a super simple nft collection it just inherits erc 721 from open zaplin and you can set like some max number of nfts that can be in circulation and you can just mint as many as you want for free right if it was a real nft collection there'd be like more complex logic here but for the purposes of this demo this will work it's a very simple nft contract and then we kind of have a fake nft marketplace i've added a bunch of comments so if you're following along or doing this after the uh you're doing this with the recorded video you can go through it and kind of understand what's going on but um integrating with openc can take a while plus we're also going to test this locally so the fake nft marketplace is like a simple sort of dummy secondary marketplace for nfts where you can buy any nft you want for 0.01 zero point zero zero one if and sell any nft you want for zero zero two each so you're always going to be in profit great job um and then we have like a few functions like a function we purchase function to sell and a function to check if something is available for sale along with all of this i have set up some boilerplate code that we will be using uh we did we will not have time to do this live so there is a deployment script with hardhat that is going to deploy your nft contract deploy the marketplace contract and then deploy the dow contract we are about to code right now um and lastly i created a bunch of tasks so if you aren't familiar with hard hat tasks um tasks are essentially like commands you can run on your terminal to do all sorts of cool things with hardhat in this case we are going to call smart contract functions on our contracts through the terminal so there's a decent amount of documentation here to understand what's going on also if you just do npx hard hat help oops if you just do npx hard hat help in your terminal um it will give you a list of all the tasks um all the tasks that exist and what they are used for so don't we are not going to code any of this life this is all part of the boilerplate what we are going to code is the actual dow contract so the dow contract is pretty empty it's absolutely empty the only thing this file has it has a couple of interfaces so an interface is a way to kind of like talk to a different smart contract um so we have an interface for the nft marketplace and we have an interface for the crypto devs nft collection and we are going to like use some functions from there so let's get started um what do we actually need so for the dao the first thing we kind of need is um well we need a way we need a way for people to become a member of the dao and simultaneously we need a way for people to leave the dow and then we want something to create a proposal in the dao and then vote yes or no on a given proposal and um something to like execute a proposal right so we're kind of going to go step by step um let's start off with the first thing um so first of all we need to kind of get access to the other two smart contracts um for like to check membership and things like that i'm going to instantiate a couple of um like i'm going to instantiate the nfts uh sorry the interfaces so we'll have a fake nft marketplace interface and we'll have a cryptodeps nfp interface right and i'm just going to initialize them in a constructor so we'll have a constructor that will take a couple of addresses which are for these so address nft contract and address marketplace contract and we will mark this as payable just so when we are deploying the contract we can fund it uh with some ease and all this is going to do is just set up nf uh cryptodevs nfp equals i cryptodevs nft at the end of the contract and nft marketplace equals i fake nfp marketplace marketplace contract so this just sets up these two contracts so we can call functions on them later and these are the addresses we're going to be calling the functions at now um now so we have a couple of kind of objects in this code right we have members and members need some information attached with them we have proposals then each proposal can either be a proposal to buy an nft or a proposal to sell an nft and lastly each vote can either be a yes vote or a no vote okay so i'm just going to set up some data structures to kind of group all of this information together so let's do a proposal type enum first so a proposal can either be buy or sell right and then similarly a vote can either be yay or nay so yes well all right no vote um then for each proposal we're going to create a struct for proposals there's a few different things we want to track right first thing we want to track is the nft token id the token to buy or sell from the fake marketplace all right what is this proposal for then we will keep a deadline so how long does voting go on right yeah it's like a timestamp and then we want to track the number of yes votes we want to track the number of no votes um we want to track whether or not this proposal has already been executed and finally well we want to track the type of this proposal so is this to buy the nft token id or is this to sell the nft token id and then lastly we just want a mapping of everyone who has voted on this proposal so you cannot work multiple times so we'll just keep track of that in a address to boolean voters mapping so we'll set this to true after somebody has voted and how are we going to kind of actually let's start by defining the member struct right so what does a member need well we probably want to keep track of the time they joined the dao they became a member but how do we decide like how much voting power someone has right so in this example uh this is relatively simple so what we're going to ask them to do is imagine i have like five crypto devon ft's what i can do i'll just send two of mine to the dao right and that will act as my membership in the dao so now i have two votes because i locked up two of my nfts and as long as they're locked up i'm a member and i can quit at any point and take my nfts back and take my share of the profit back whatever the dow made um so let's just keep track of all the locked up nfps so this is essentially an array of token ids for the crypto devs nfp that are locked up by this member all right um and lastly a few more things so we need a way to keep track of all the proposals right so we'll have a mapping from id to proposal so this is all the proposals that currently exist proposal id to proposal and then we will map members so for each address what is their member information and this is all the members of the dao um and then we will keep track lastly of the total number of proposals that have create been created in the dow and the total voting power of this style which is basically how many nfps are locked up across all members all right so a lot of structures created let's actually start by writing some actual functions all right so um let's see um oh let me just do one more thing so we'll add a modifier called member only because most of our functions should only be called my members and we can just do a require that members message.sender so this the person calling the transaction must have at least one nft locked up otherwise your word with not a member and then you run the rest of the code all right so let's start off by i'm going to leave the membership portion to the end because that is a we're going to do something fancy with it um and i guess simultaneously we'll do the quick part at the end let's start off by having some code to create a proposal in the dao all right so function create proposal what do we need we really need two things from the user um we need the nft token id that the proposal is for and we need a proposal type is this to buy it from the marketplace or is it to sell it on the marketplace so we'll take in two arguments four token id and a proposal type proposal type and this will be a external function and member only and it will return the newly created id of the the id of the newly created proposal so um we have to check a couple of things right if we're if the proposal type is to buy something uh we have to make sure it's actually for sale so we can require on the nfp marketplace that um sorry my autocomplete is being weird but you can we can require on the nft marketplace that this token id is actually available for sale otherwise we throw an error nft not for sale so this proposal is kind of useless otherwise if it's a proposal to sell something we need to make sure that we are the owner of it like the dao must have that nft before it can go sell it so we can check the owner of this token id must be equal to this contract's address otherwise not owned we'll throw with an error all right so we've done that um so now to actually create a proposal so when we start off the num proposals will be at zero right that's the default value of units and solidity and the mapping this will be empty right no proposals have been created yet so let's just assign 0 as like the first id so let's load up the proposal struct at num proposals which when you call it for the first time will be zero and then you set some values you set all the values that we care about so nfp token id is for token id and deadline will automatically set the voting deadline for purposes of the demo to only two minutes from the creation time in real life this would probably be like multiple days or multiple weeks at least um and then we set the type of the proposal which will be whatever the person passed in and then we increment the number of proposals to make sure the next one gets executed uh gets created properly and lastly we have to return the proposal id of the one we just created right so we just incremented it for the next one so the one we just created will be num proposals minus one so we return this id um so basically all we're really doing is creating a struct and storing it in the mapping which has some information about the proposal then the second thing once you have a proposal you want to be able to vote on a proposal so we create a function vote on proposal you in 256. oops i'm sorry i'm just checking chat i should have posted the link here before um sorry about that um there's the github link in the zoom chat now so vote on proposal for that we also need we need a proposal id right and we need to know what kind of vote it is is it a yes vote or is it a no vote and this will also be an external member only function and we want to check for a few different things here we want to check the proposal is currently active which means the deadline hasn't passed yet and we want to check that the person voting hasn't already voted in the past right so we load up the uh proposal from our mapping so this proposal id and then we check a couple of things so first we check that the proposal.deadline must be greater than the current block.timestamp otherwise it's an inactive proposal and we want to also check that the voters so if you remember the proposal struck had a mapping of voters to booleans uh so this address must not have already voted um otherwise we throw with an error already voted now that we've done this we can safely say so we'll mark this address as having voted now right and then we'll check the voting power this person has so if i have two nfts locked up in the dow i have two votes that is my voting power so my voting power is basically equal to my membership struct dot the number of locked up nfps i have so the length of the locked up nfps array and lastly depending on if my uh vote was a yay vote um then i increment the proposal.yay votes um by my voting power oops uh voting power otherwise i increment the nay votes by my voting power right so so we load a proposal we check that it's active we check that you haven't already voted we mark you as having voted now and then we increment either yes votes or no votes depending on your voting power and what you voted for right so the flow is kind of like somebody creates a proposal other people come and vote and then eventually the deadline like will hit the deadline and the proposal is no longer active so we need a way for someone to execute a proposal right and the difference here is while you still need someone to execute the proposal you still need someone to make that transaction um any of the members can do it first of all and the owner like i specifically if i deploy this contract i can't stop it right unlike like snapshot or something um if i was um oops yeah so for example um if i was uh on snapshot i could stop a proposal from actually being executed by just not executing it but um here any member can call it and if the proposal has passed we will automatically do the required function calls and anyone can do it and i don't have any power over them so to execute a proposal all we need is a proposal id and any member can call it whenever they want right so similarly we load the proposal from our mapping and this time we check the opposite so we check that the proposal's deadline has passed it's over now and it's no longer under voting um so it must be less than or equal to current block timestamp otherwise we give an error that this is an active proposal um and we must ensure that the proposal has not already been executed right um cool once we do this uh we can mark the proposal executed as true and then um so we're going to check a few different so we're going to use a very simple sort of 51 forum if more people voted yes then people wouldn't know we'll just pass the proposal um you might want to do in the real life you might want to do a little more complicated sort of quorum techniques where you must require a certain number of members must have voted and maybe it's like 66 percent instead of 50 51 but um i'm just going to do something very simple all i will check for is if proposal.yes votes is greater than proposal.net votes then we'll do stuff with it now depending on what the proposal was either you're buying something or you're selling something right so if the proposal was of a type to buy an nft from the marketplace then we call a certain function on the marketplace else we call a different function on the marketplace so if you are buying something um we can get the purchase price of that um nft uh by doing like nifty purchase prices this is just really this is just reading this value if you're actually integrating with openc for example um this will be different for every nft of course but we're keeping it simple it's just a mock um so we get the purchase price so this is how much eat we have to send and we must make sure that the contract actually has this much each to send it right so it must have at least greater than or equal to this much ease to buy it otherwise you just don't have enough funds um and if you do that then we can just do nftmarketplace.purchase and we'll send it some eve so we'll send it the purchase price worth of ease and the purchase function needs a token id um that you want to buy so that token id is proposal about nft token id that we saved when we created the proposal so this is what happens if the proposal was to buy an nft any any member can call this function and it will just automatically buy it from the marketplace right if it was a proposal to sell um then we need to make sure that we are actually um oops i don't think i added that here actually um so in the fake nfp marketplace oh yes um this is an oversight um so the fake nft marketplace should actually have a function called owner off and i did this when i was completing the tutorial yesterday um let me just add that function real quick so the marketplace we're going to add a quick function which given a token id returns the current owner of that token id right and when you are looking to sell something we need to ensure that um well we actually did ensure that the dow owns that nft because we check it when we created the proposal so the dow must own that nft so now we can just do nftmarketplace.cell and we will um cell needs a token id as well and this will send us some eth in exchange for our token so proposal dot nft token id right cool so this is it for the execute proposal function let's take a quick walk through it again so once a proposal's deadline has passed any member of the dao can choose to call this function right and what it will do is if if the proposal passed if the number of yes votes was more than the number of no votes um depending on whether it was a buy proposal or a sell proposal we execute the required commands to buy or sell the nft from the marketplace right make sense cool now let's let's talk about becoming a member this is going to be this is a little interesting right so there are two ways you could do this right either you first ask the user uh if you guys are familiar with like the approval flow in erc 20s and erc 721 um you first need to get the user to approve your contract to like transfer nfts from their account and then maybe you have like a function called join dao or whatever that then transfers the nft into its own account right that's one way to do it um i don't like it because it requires two transactions um we can actually do something a little better um which is let's take a look at what actually happens in erc 721 right so this is our nfp contract and if you go a little further down into erc 721 you will see there exists a function called safe transfer from right and what safe transfer from will do is if you're sending to a contract um if you're sending to a contract it will check that the contract is actually capable of receiving an nft right because if you're sending to a contract that doesn't know how to deal with erc721 nfts that nft is lost forever and the way we do this um the way we actually like check for this is it's just magical right it's it's literally just magical so we shall have a function that is called um so we we will need to create a function called on erc721 received in our contract which wants to accept erc721s and as long as this function returns a specific magic value okay i know it's weird but this function needs to return a very specific set of four bytes and the idea is if the developer of the contract went through the trouble of creating this function making it return the exact four bytes then they probably have some way to deal with erc721s this is not a guarantee you could very well implement this function but not have a way to do anything with 720 months and then that nfd is still lost forever but that is kind of the trust assumption when 721 uses safe transfer from so all it's going to do is it's going to check if you're transferring your nft to a contract it's going to call this on erc721 received function and it's going to check that it returned four bytes that match this magic value otherwise it's going to fail the transaction saying this contract is not set up to deal with nfps now why am i talking about this i'm talking about this because we can actually do some cool stuff with this we're going to implement this function and we are going to return the magic value but as part of that we're also going to make that person a member of the dao so they don't need to do anything special they don't need to call a function to join the dao they just transfer the nft to the dow contract and they automatically become a member of the dao all right the way you do this is let's just uh so open zeppelin has an interface we want to use so i'm going to open open zeppelin contracts token erc 721 and they have an interface called ierc721 receiver dot sol which is what we were just looking at right now this thing and we want our dao to um implement this interface so crypto devs dial is a 721 receiver and then we can have that function so we're going to create a function that will be called by safe transfer from so when a user transfers decrypted snft to this address this function will be called by the nft contract and it takes four parameters it takes an operator address it takes a from address it takes a token id the one that was transferred and it takes some bytes data that we don't care about right now we actually also don't care about the operator so you can just remove the variable name so it doesn't give you unused variable warnings and we will override this function from the interface and it does still need to return those four magic values for it to succeed so the way you get those four magic values it's the selector of this function if you don't know what a selector is it's like the first four bytes of the hash of this function signature you can read more about it in the ethereum documentations so that is the magic four bytes we need to return um but other than that our cool stuff so the first thing we need to do is since this is a public function we don't want anyone to just call it right you can you don't want someone to just go to ether scan and call this function and pretend like they're a member of the tao so we do want to check that the token you're claiming you sort of sent this nft for is coming from um is like part of this uh dow now right um so you actually did transfer that nft out right and and declare oops sorry not an underscore over there right and then you also want to track that you're not just calling it like somebody isn't just calling it for a second time right if i transfer token id 0 and i become a member token id 0 is now owned by this contract right but then if you go to ether scan and call this function with token id 0 this require statement will pass because it's going to be like oh yes i own token id 0. but it needs to kind of know that it is coming from like it is a new transfer right we're just going to create a quick mapping so mapping a few in 256 to boolean of and this is just going to track whether um token a certain token id has already been locked up or not right so we check that this contract is the address uh sorry this address is now the owner of the nft that was transferred and we also need to check that um token locked up for this token id is currently false so this is being transferred for the first time otherwise already remember or not really already member but um already uh already used for membership i guess um and then what we're going to do is just load the member load the member from storage so we have the prom address as the person who sent this nfd out and then we check that if member dot locked up nfts dot length is zero so if this is the first time they're becoming a member we set their joined at timestamp to the current timestamp and this is going to be important we um we'll get to that and then we are going to increase the total voting power this contract has so the total number of locked up nfps this contract has um by one and we are going to add um this token id to their locked up nfps um all right right and then we're just going to return the magic four bytes beautiful cool and now for the last main function which is quit how do you quit the dow and we're gonna hurry through this a little bit we're running out of time so we'll have a function quit and any member can call it right and what it's going to do it's going to load up the member from the mapping and it is going to check and this is where the join date comes in handy we are going to check that the member you must have been a member of the dao for like a minimum period of time before you leave so for purposes of this demo i'm going to set it to five minutes but you can set it to something different um and this is done so that like somebody doesn't just join the dow doesn't do anything and just quits and walks away with like um i don't know some share of the profit because we are quoting a very simple contract where we don't check their activity so their share of the profit will be equivalent to the basically their voting power divided by the current voting power multiplied by however much each is owned by the dow at the moment right so basically the balance of the dao multiplied by how many um uh what was the voting power of this specific member which is how many nfts they locked up divided by the total voting power of the contract and then you can update the total voting power to get rid of however much votes they had and we can send them their money we can send message.sender their share and then we can send them all their nfps back so we loop over locked up nfps and we transfer them all out so on the cryptodesign ft contract we call save transfer from and it goes from us to message.sender to that specific token id and we don't care about data and then um we remove them from the members list so they're no longer a member after they quit all right that's it for all the functions the only couple of things i do want to add is i want to add a receive and call by function so people can just send each to the dow and help fund the treasury if they want to um you don't have to do this but in for testing it's nice because if you if your dow runs out of money you can just send it some more money all right so these functions they just act as like gadge all let me grab your eth ease kind of functions all right we have we've basically completed the dow contract um i'm going to start showing this off and i'm going to use the hard hat tasks that i created to kind of walk you through the flow and see it actually working right so let me open up my terminal i hope you can read this first thing you want to do i created a deployment script but we need a local hard hat node for it to work so on first tab i'm just going to start a local hardhat node you do that by typing npx hardhat node and i will open a different tab in my terminal zoom in a little bit fix these eyes um and this should be somewhere in all right so i have my local hard hat node running over here right um what i'm going to do i'm going to deploy these contracts oops to deploy these contracts oops this is not supposed to say roxton sorry i need to fix the package.json real quick the script should be running on localhost not on roxton all right npm run deploy i'm going to deploy on the local hard hat node we have and it's going to deploy all the three contracts right the nft contract the marketplace contract and the dow contract and we're going to keep track oops uh par c 0.05 um where is this error oh right makes sense i messed that up give me one second [Music] i am on my second monitor so just one second [Music] all right and then picking up the marketplace.deploy all right you know live demos always go like this um i am fixing this on my other monitor i missed having a constructor i need a payable constructor in the marketplace so the marketplace has some funds for when we sell it nfts and i missed adding that um once we have that i just do npm run deploy again sorry about and cool all right we're at 12 45 i have 15 more minutes i'm gonna try to wrap up the demo in five leave 10 minutes for questions um all right compiled all right there we go so the nft contract has been deployed to this address marketplace has been deployed to this address and crypto devs dial to this address i am going to keep track of these three things so i just copy pasted all these addresses on my vs code and let's start off so we have a bunch of hard hat tasks right first thing we want to do let me just show you that they work so one of the commands is getting my youth balance so this is the each balance of my account and on a local node it's probably like almost ten 000 east minus some gas i paid for these deployments um and my nfp balance from the crypto devs nft contract so i will give it the nfp contract address as a parameter along with the local host network and i should currently have zero nfts i don't have any crypto nfps right now so the first thing we want to do is we want to actually get some nfps right so we're going to do npx hard hat mint free nft um give it the nft contract and the local host network and these are all tasks that are in the boilerplate you can look at them all they are doing is calling the respective functions on the contracts uh just to make it a little easier to like test our things without going through ether scan or deploying to a test net which was behaving very slow yesterday ether scan was going down yesterday when i was building this tutorial but okay we minted two nfts and if i get my balance now it should say um i have yep i have two crypto devnfts perfect all right and what i'm going to try to do i'm going to try to create a proposal um in the dao and this will fail because i'm not yet a member of the dao because i didn't send it my nfts but if i try to create it we should see the error that i am not a member yep reverted with error not a member so what i'm going to do i'm going to transfer over my nfts to the dow all right so send nft to dao i have all the addresses and stuff filled in um so i have two tokens token id1 and token82 i'm going to send both of them so i send over the first one and you can see in your local hardhat node like as these transactions are happening right all the functions that are being called so i sent over token81 i'm going to send over token82 and i should have a voting power of two votes all right perfect and if i get my own nft balance now it should be zero we're very close to the time load i'm going to rush through the last part but you can run it on your own i have zero nfts now the dow has my nfts i am going to create a proposal to buy some nft with a token id of 10 from the fake marketplace right and we'll have two minutes to vote on this so you create the proposal to buy and i am a member now because i send it my nfps it successfully created the buy proposal and get proposal let's see what it created all right so i have until 1251 do vote on it it's not yet executed zero yes vote zero no vote so far and this is to purchase token id 10 from the marketplace i'm going to do vote yes on proposal proposal id 0. and since i have two nfts locked up it should give me two votes so i get the proposal again let's see perfect you see there are two yes votes now all right and um i have about two minutes left for this still um perfect so essentially once this uh timer ends once the deadline of this passes um what i can do is i can do execute proposal for proposal id 0. this will currently fail because the deadline hasn't passed yet um there you go so it says active proposal but i can execute it it will make the marketplace transaction and the dow should have less each than it started off with um i don't think i showed this to you but in the deployment script when we deploy the dow i initially fund it with 0.05 eth from my test account so it can have some money to buy and sell nfps um so it's going to have less than proposal is executed all right so it's 1251. let's see how long we're on the seconds and all right there we go so successfully executed proposal zero right and now if we check the dao is balance it should be just like it should be like 0.04 sorry 0.0049 because each nft costs 001 um and we have an nft we brought from a different marketplace right and then you can do kind of similar things i'm not going to go through all of them just in respect of time but you can create a proposal to sell the nft back at a later point maybe the price has gone up so you want to sell back oops not took an id0 token id10 that's what we bought um and yeah you can create the sell proposal vote on it anyone can come and execute it the dow would have made some profit by that point and then once you're ready to leave um i'm going to show you what my current ethernet balances are so currently i have zero crypto divides and i have like a very specific uh balance so like nine nine nine nine something oops get each balance at zero crypt of nfts at the moment and 999 point super long string um is right but if i do quit say quit the dow i'm done um i'm going to get back like so i'm sure of the profit and this is actually oh see yeah i haven't matched my minimum membership period which is five minutes we'll come back to this but yeah any questions i want to pause here for some questions while we wait for this deadline to exceed and i also want to thank everyone who came so end of presentation any questions please post them in zoom chat i'm looking at it right now and i hope you enjoyed this tutorial um if you want more if you're starting out in web 3 you want to learn from a to z join learn web3 it's a completely free dev focused education platform and you'll be building alongside 25 000 other people so i hope to see you there happy to answer any questions there as well after the workshop is over um but yeah i'm going to scroll up to see if there were any questions i missed earlier so christian asked do we need to check we own the nft again when executing the proposal before we sell you could do that um i think it would be fine to do that but also um i mean i just didn't do it for simplicity i think it's partly an oversight it was 3 a.m when i was writing this you could add that just to be safe but either way the marketplace will fail that transaction anyway if you don't own the nft you're trying to sell so it has the same effect and muhammad asks uh i have one question in the execute proposal function why not use an internal function that automatically executes when a deadline is reached instead of an external member only function so the reason we do that is because how do you know the deadline has reached right let's say i voted on something and i was the last voter on that proposal and two hours later the deadline has crossed um somebody at some point needs to make a transaction to like where it will perform the check oh the deadline has passed so let me go ahead and execute it now um an alternative to this if you want to be fancy you can use chain link keepers and automate this process a little bit so chain link keepers can keep track of all the proposals if deadlines have passed um and then execute them automatically so that's one way cool vg asks can you commit and push the code you have written so it's all already on github actually so if you go on the dao hacks workshop i asked you to clone from main but if you actually check there is a second branch on github called completed which is all the code i just showed you um pretty much and this has this is like everything we just wrote uh on the completed brand so you can take a look at it um if you're going to be referencing this later during the hackathon what is the best way to reach me if you have questions um discord probably so if you i'm super active on the learn web3 discord that's easy way to reach me actually yeah that's probably the best way luis asks how would you integrate superfluid to this example to stream out the profits to the members um intuitively i feel like superfluid should be able to do this somehow i have not personally worked with superfluid or used it unfortunately so i don't have a better answer for you there i'm sorry um when you say automated tasks or functions we achieve link for a dao do you have any ideas of what that could be i mean so chain link has this thing called chain link keepers they just came out with this and it's essentially a way to kind of automate some transaction calls so the keepers will check some state on your contract or like try to meet some condition and if the condition is met they're going to perform the contract call automatically like for you like in a decentralized way so things like maybe like maybe you want to execute the proposal automatically the second the deadline passes you can technically use the keeper network for this um so the keeper network can check oh has this passed yet has this passed yet um oh it's passed now so let me just execute it and the keeper network can do this in a decentralized way and you fund this by having some chain link tokens locked up on your um sort of chain link uh i don't know what they call it to pay for uh this upkeep yes it is like on chain cron jobs basically that's right except you need to pay with chain link tokens um great and then right before we wrap up the time should have passed now so i'm just going to quit the dow and show you that it actually works um so all right so it successfully quit the dao now if you check i previously owned zero crypto devnfts right because they were locked up in the dow if i do get nft balance again it should show me two i should have gotten both my nfps back there we go and if i look at my earth balance now i should have gotten oops why did i write nfk npx hard hat hard hat get if balance and i should have just slightly more than the last one so previously i had 99999.89 whatever and now i have 99999.94 whatever so i made some money i was the only member so i got 100 of the dollars treasury back um and that's also kind of the reason why you want a minimum membership here you don't want people to just join and instantly leave and walk away with like a share um you can do some more advanced logic there but we have to be respectful of the time um amazing i think we're at time um again hit me up on discord if you have any further questions i'll be active in the lw3 discord um and thank you thank you everyone for joining thank you so much on to you thank you so much hardik for that workshop it was super informative i know everyone really enjoyed it you got a lot of good feedback um so yeah really thank you for taking the time to do this for dao hacks um and heartache i also added you to the dao hacks discord so um you can interact with any of the dow hacks hackers there as well and that goes for the rest of you um you can also not only can you join the um the sorry um the learn web 3 dao discord but also if you you can also interact with heartache on the youth global discord yes i will be checking that for at least all of today and tomorrow nice awesome and with that being said we have a couple more workshops today our next workshop is in half an hour with ipfs so looking forward to seeing you all there as well and i hope you all have a great weekend um and i can't wait to see your projects perfect see you guys all the best for the hackathon everyone have fun building bye bye 