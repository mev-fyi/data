essentially fast off chain progress that's what we want we want to be able to execute not on aetherium but with the security of etherion that's that's the fundamental goal and the way our Bertram does this is through a process of using dispute resolution and so instead of just kind of running all the execution on chain we instead make claims about execution and then support efficiently a way to kind of challenge and derive whether or not that claim was true so that in the happy case you don't need to run anything on chain and even in the worst case you only need to run a very small amount of computation on Jane in order to ensure the correctness of a very large amount of computation off chain and that's kind of the really cool thing orbitrim provides which gives us this these off chain contracts that actually have the security of etherium which is where the magic is there's no kind of separate consensus it's all just reduces to two to etherium security and my favorite part of this my favorite part of this is that we support just deploying your existing solidity contracts into layer two a lot of layer two systems there are kind of you need to learn some new framework and new tooling and align a lot of new complexity there so this is true of stink channels if you're familiar with that this is true of optimistic roll-up in familiar with that but but we have kind of this this magic which is don't write anything new just take your existing contracts and go and so how do we do this I went into a little bit fundamentally we use a combination of techniques no fancy cryptography involved which is really nice because it means it can actually be fast so we do all of this with just a combination of protocol design incentives and this custom virtual machine architecture that essentially just makes sure that we can we can run all of this all of this kind of back-and-forth dispute efficiently on chain and so what are the important things to know about arbitrament can I use this well there's really only one kind of important role and that's this idea of validators so in a theory of them you have all of the miners running your contract which is why it's so slow instead for our Bertram each orbitrim contracts has a set of validators who are the people who are actually running the code for your contracts and the really cool thing that Arbitron provides is this any trust guarantee which is that any single validator can ensure that the contract will run correctly and compare that to something like kind of if you compare that to other scaling solutions so for instance side chains that use something like a Byzantine fault tolerant essentially a separate consensus mechanism where you need two thirds of the validators to be honest which is kind of a huge assumption and and it's very easy to worry well wait a second what it what if they're not as friendly they can just steal all of my money here allowing anybody to ensure the correctness is really key so so what do we have this validators we have this idea of kind of dispute resolution so so what actually one of the validators do how does this work so first of all the validators have are incentivized to to not fight to act honestly and so in the happy case most of the time parties aren't malicious and what we want the first thing we want to do is be really fast when nobody's acting maliciously under normal conditions and so we can have a set of validators for instance that most of the time they're all going to be up and available and they can just unanimously sign off and say hey we agree this is this is the correct state this is the correct next update and the system will accept the state immediately so there's no there's no challenging there's no disputes because everybody set up in advance that we all agree um if you don't have that then you go into this fallback system that I described earlier where one validator has to say well I assert that the new state will be X and somebody else can challenge um so I'm not gonna go into the details of how all this works right now I'm just giving you a little bit my co-founder ed Felten is going to be giving a talk tomorrow afternoon where we go into more of the technical details more of what I want to talk about today is like how the hell do you actually like make use of this stuff a lot of a lot of kind of the weirder more technical layer-2 solutions building on top of aetherium are pretty are pretty tough to use and one thing that's really important to me is to build a solution that that's actually kind of accessible to developers that people can actually use so what do we have today first of all like what's actually out of what I'm talking about what's what's out there what's usable so we have a public alpha that's been out since around June and that's all open source on github anybody can check it out URLs at the bottom we have the ability to support solidity contracts so you can easily compile a take an existing gap and port it onto our Bertram and I'm going to walk through quickly if we have time which we should like what that process looks like because it's really simple which is nice these contracts can send and receive tokens and so they can kind of interact with with the regular on chain contracts and so you can have this layer to scaling and this extra this extra speed boost for your contracts um while still being on aetherium and having the advantages of being on fear IAM so a little bit about like what where what what the parts are of the system what's the code like what what am I actually saying you should use so they're really kind of and and how it is how does your contract involved so they're really kind of two halves of the story there's the half about kind of what the validators are doing what your what your kind of your your smart contract is doing and then there's this the half which is your front end so you're writing a front end it needs to in your user is interacting with it it's interacting with your contract what does that look like so I'm just gonna do kind of a quick overview of those chunks so first of all we start with a solidity contract we run it through the are between compiler which transforms it into this kind of weird magical Arbor from program and then we deploy it you the set of validators the program is distributed to all of them and they post on chain with essentially a commitment to this contract so they say hey we have this company we want to create this contract here is a hash of it we're not even repair we're barely making doing anything on change just the small transaction to commit to say essentially we all agree what kobu Bronner on we're not reviewing what it is but we all agree that this is the same code and then these validator start asserting so they're in the happy case they're all unanimously asserting together we're not even on the blockchain but we're getting finality we're getting security and it all works and so then what does the front end side looks like so now we're talking about the user so kind of the standard for aetherium is you're using web 3 maybe you're using ethers j/s if you don't any aetherium development and web clients kind of you're using one of these libraries and they talk to the etherium blockchain well we don't want to change that experience we just want to move it over into layer 2 and so what we do is we have a custom client called the arbitrament provider which essentially bridges the gap between between your front end and aetherium and what that means in practice is you can take an existing front-end plug in five new lines of code and suddenly that's a front-end to an arbitrary act with no further changes and so just really to emphasize this is this is kind of quite a small amount of work and you'll see how much in a second and yeah all of this is live all of this is usable there are a couple different demo applications that are that are on the github that are that are easy to deploy they're very simple they're just to demonstrate essentially what what the different components are and how they work and hopefully we will see some even cooler stuff built on it during the hackathon so that is that and now I want to take a little time and just walk quickly through what it actually looks like to to deploy your app to take an existing application and poured it onto our bure phone so let's see I'm gonna make this big and hope is that big enough to read all right there is there is nothing worse than having way too small text on a slide actually let's make that even bigger for the hell of it so what do you do you want to actually start using our Bertram you want to deploy on it what does this look like concretely so we're gonna start with it we're gonna use a truffle based project if you've done any aetherium development that's kind of the de facto standard right now there are few competitors that are up and coming and will support all of them but right now it's truffle you have some sort of front end and you want to start it and this is all just a regular aetherium tap and now you're like okay I want to use this magic layer to stuff I want to have way more scalability for my software without compromising security at all without a separate blockchain without a separate consensus without some weird cryptography just a few clicks and suddenly have have this further level of scaling and so what does that look like well first we need to connect first we need to actually deploy our contracts to the orbitrim back-end so we add a few lines we add the arbitral network to our truck to truffle so we're normally with truffle you deploy on on Rothstein you deploy on main net you deploy on ganache so we're just adding kind of a new deployment target for your code and so all of the all of the rest of of your truffle project is the same all we're doing is changing the network and and that is it and that will essentially kind of take take your arbitrary solidity contract and prepare it to be run in layer two and so you can do this with contracts that you have today and and it goes super smoothly with a couple restrictions that are that are that are listed on this website if you want to go into detail so that's the back end that's done we have our kind of test client which is let me just yeah so you run truffle migrate you select the network and it produces this contract at a OH file which is your are Bertram contract so now that you've designed that that's essentially ready to be launched you're now ready to create a VM and for the purposes of kind of the current state of the alpha there's just a magic command to do that for you and so what this command here will do is it will on your computer launch the ball launch an entirely fresh block cheney's in ganache launch well and here we say three validators who are all independently running and talking to each other and it'll set them all up with your contract on Io so it's just gonna be kind of a one-click for four in the in the current alpha to set up everything and and that's all so now you have an entire orbitrim contract running off chain all set up on your on your computer so that's that's that's the backend side next up you have this existing front-end and you want to port it so you are for example using using web 3j s and so somewhere in your code you have a block of text that looks something like that it like connects trusts could have made a mask if that's around if not it does some fall backs it looks for kind of whatever your provider is if you've done any blockchain programming then you you you've seen you've seen code like this in your front end where the browser app may be it may be it falls back to and Fira it's looking for a connection to a theory em and so but now we need it to not talk to aetherium now we want to port it over but this entirely different back-end and the trick is we can do that extremely simply so all we need to do is we build this new arbor to provider and we say well in this first segment here we have a connection to an R between validator we also pass a connection to aetherium because we need both of these because our Bertram is in a separate network it's just part of a theory I'm running on top and so the provider needs to talk to both so we swap that in instead of web 3 being a direct connection to aetherium it's now a connection that goes through arbitral and we're done and and that is the entirety of the process for deploying in layer 2 and just to emphasize the the cool thing here is that this this is accessible this is something that can be applied to two new contracts that this is not what we want to see is we want to see that the layer 2 layer 2 scaling is not only accessible to companies with like large research teams who invest and spend months tan in building this stuff we want this to be tools that are accessible to people today or within the next couple months when we're ready for for full / full deployment um and and that is kind of the the trick is to make the experience as similar as possible to your existing aetherium developer experience you don't need to learn anything new you can use all your existing tools um but your contract is running in this totally new setting entirely seamlessly so yeah so that that's kind of the that's the developer experience um and we hope that that was kind of interesting it's layer 2 is like a whole new world into the etherium space there's been development in this sector for for a couple years now and and this is kind of we're we're nearing a moment where some of this stuff actually becomes usable and it's gonna be necessary because aetherium doesn't scale and so within the next kind of if there's ever going to be adoption of smart contracts then this stuff is critically necessary right now daps get excited when they get in the kind of thousands of users is a huge win but when you look at kind of standard applications that's nothing and when you have things like crypto kitties for instance as like the typical example of like you have an aetherium daffy that actually starts to get adoption um suddenly the entire chain grinds to a halt and so having these solutions are kind of fundamental to being able to actually produce produced apps that will really kind of survive adoption so yeah that is my schpeel I'm happy to answer any questions or let you guys you know get to hacking or get to sleep so thanks [Applause] yeah absolutely yes um so if your so so I I will give my like my view of essentially the relationship between layer two and aetherium 2.0 so number one Atheneum 2.0 is not going to be like generally usable for at least the next couple years and we need a solution before then um number two is that neither the sort of techniques that I described or aetherium 2.0 alone um can actually scale enough for let's say global adoption um and so even in the long term fundamentally both solutions are needed um this is only made better by a faster layer one um and fundamentally the promise of layer two is that no matter how fast your layer 1 is your layer 2 will always be better because fundamentally it's an enhancement layer um and so it will always be necessary the slightly more technical answer to that is that we and many other people in the layer 2 community are extremely excited about etherium 2.0 phase 1 um because it does this magic thing which is it suddenly says that the etherium blockchain can guarantee that massive amounts of data something like last I heard it was like 10 megabytes per second of data is available unknown to all of your users and you can do some amazing layer 2 scaling based off of that and so we are all extremely excited because it'll only make all of these solutions better 