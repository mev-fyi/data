hello hi new york how are you going um good to see everyone here hopefully you're all in an empire state of mind um ready for this hackathon it's like packed out here so i'm super psyched to be here i'm ali i'm a file coin developer advocate um or i work at the farcoin foundation so and yes the accent is australian for those of you wondering uh but tonight i want to give you a brief intro into ipfs and far coin and then i'm going to dive into the mechanics of making an nft contract and why ipfs and filecoin are so necessary particularly if you're not storing that metadata on chain and why that sometimes gets really prohibitive as well so this is a little project i've made it's a multi-chain multi-contract personalized nft collection uh so just built on solidity contracts i've used both an erc 721 and an erc 1155 contract and i'll dive into why they're different a bit later and with a react front end and some dev tools around this so hard hat morales for node provision and specifically nft.storage to um store our nft metadata so firstly i just wanted to clear up some confusion that's maybe maybe out there around a few names you've probably heard floating around the web3 ecosystem uh and share how these fit together so protocol labs firstly is an open source research and development lab it's building protocols tools and services to improve the internet and we really believe in this concept at the moment actually we're running funding the common uh funding the commons here in new york as well in parallel with this so we're really aiming to build tools and services that help radically improve and drive breakthroughs in computing and like move humanity forward and for the common good as well so some really big goals there um two ipfs and filecoin are two of the projects that were originally incubated by protocol labs and they now operate as their own separate but complementary projects within the ecosystem are still sharing the same vision but let's jump into firstly uh cue the star wars music here interplanetary file system so this isn't just a meme name though because it's a distributed peer-to-peer network for files and folders ipfs was designed to be able to work even when you're between planets so let's say you signed up for the mars colony program and you're now living happily on mars maybe it takes you an hour or so to request a file from earth that you need but if someone else on mars already has that file then you can then they can just serve that content to you instantly with ipfs so maybe you're thinking this is just a fancy name for a peer-to-peer protocol or network now but there's real gravity get it in what it does because ipfs is distributed by design it has no central authority servers it's designed to be offline first for resilience and it uses specifically a really unique and upgradable standard for addressing content and this is the unique part of ipfs because rather than using methods that we might be familiar with the storing and accessing content so location parts we go to the web we type in a http url and that location serves us up a piece of content from some specific centralized server so this is called location addressing um and we're never really sure what content we're gonna get for that location that we go to so uh with ipfs instead we generate a content id so each and i'll just jump to this one for a second so each piece of content actually has its own uh cryptographic uh hash function so it's like a unique fingerprint for each piece of content and this is kind of wild or at least it was to me when i first started looking into ipfs and it's because it's such a mind shift from the web to way of doing things that we're like really accustomed to at the moment and it's super elegant for its simplicity because this really opens up the web to fully massively distributed storage systems and that's important right you can always if you can always verify what content you're getting back you really don't have to care where that content comes from so that's really like the key part of learning ipfs the fact that it's not just a peer-to-peer protocol but it also has this content addressing system so it makes the web work peer-to-peer and by the way um that's a bit weird my speaker notes have stopped but anyway that's all right uh so ipfs is not just uh for uh web3 either so it also works with web2 it's a protocol not a blockchain so it's used in things like uh flickr is has been using it some of our amazing uh colleagues here in the web 3 are also using it so i know ballast is built on top of it live peers built on top of ipfs audios as well to name a few so the problem with ipfs in the wild though is like you can run your own nodes but as soon as you shut your laptop that content that you've stored on your own node is no longer really retrievable by anyone else and let's be honest not everyone wants to run their own uh content nodes um the other way you can maybe ask someone else to store your content for you but unless they really like that data or they really like you for some reason or whatever it is um that content may become unretrievable after a while and we've all seen this with kind of torrent insistence we're less popular piece of data just stop being retrievable or available basically so a third way to do it is you could pay a pinning service to pin that content on the net for you but if we start doing this we're kind of opening up to these centralization issues that we already have in the web today and we really kind of want to avoid centralizing um our data pinning services by using pinning so despite maybe um you know what the really annoying anyway despite what the community uh you know the community's general altruism or wanting to do this you know eventually content can become like unretrievable so this is where filecoin comes into the system really so far coin is storage designed for web3 from the ground up it's a distributed storage network um it uses crypto economic uh market levels to incentivize the storage of data so it uses two main consensus mechanisms to do this the first is proof of replication this ensures that providers are actually storing your data and keeping it safe when you first upload it and the second one is proof of space time so all of our storage providers and there's like over 4 000 storage providers globally at the moment all of them put filecoin up as collateral and they have to prove daily that they're holding a subset of the data that you've uh asked for them to store and if they don't do that their file coin is slashed and because like running a data center is quite expensive plus the amount of file coin to do it is also expensive they we're really uh decentralizing having bad actors in the system as well so the second thing is that far coin runs on market deals um so if you store your if you want to store data on the network you can firstly decide how many storage providers you want to store that with for resilience and redundancy and then secondly you can decide how long you want that content to be stored so it's really your data and it's your choice you can decide if you want to store that for six months or you want to perpetually store it using something like smart contracts for 500 years and just like keep doing that so the too long didn't read basically is that ipfs and filecoin are great complements so ipfs is great for that content addressing verifiability of content coming from anywhere and for fast retrievable uh fast and flexible retrieval and far coin is really that persistence and verifiability of that uh data storage layer um but what's this got to do with nfts you might be wondering um well if we dig into the anatomy of an nft contract and this is the erc 721 standard the original nft contract um and this is the open zeppelin one so you could build an erc 721 from scratch if you wanted to but most people i think would use this template it's been audited it's community tested this is probably where you'd start in developing an nft um so this is a contract from open zeppelin like i said it's been ordered and community tested um and here's the api for it here's the basic functions that come with this erc 721 and here's an example straight off the open zeppelin website uh that shows this implementation of erc 721 in solidity uh the ethereum language um so this contract basically creates a grain item here um as an nft an erc 721 and the function that mints that nft or stores it on the blockchain is called award item in this uh in this scenario in this uh code here anyway uh so and it takes two parameters the first is the address of the player so i assume that's who they're awarding this nft to the player and the second one is a string and a token yuri what is this token yuri well it turns out that this token yuri is basically just a jason file it's an object that has a few descriptors of what this nft is and it's really what you'll view on the web as an nft so you can see here it's got a name a description an image and say some other attributes like strength or whatever you want to add to this game item for example now the problem with this contract is that this image has a location address it's got a https address and even open zeppelin itself says you'll notice that this item's information is included in the metadata but that information isn't on chain so a game developer could change the underlying metadata changing the rules of the game um and there's been some famous examples of this happening because they're using location addressing rather than like ensuring immutability and non-fungibility of the nft with uh content addressing so one of them is this like a rugs contract uh here someone created a full nft line it's sold out it was it was really famous uh and then they uh swapped out all the token uries all the metadata for actual rugs it was a legit it was you know a rug pull basically so pretty funny that one uh you know in retrospect uh the other one was this f bubbles one i won't swear but uh they basically use their nft collection to then advertise their next nft collection so they change whatever this um bubble said to advertise their next collection which you know really if you're buying an nft you want it to be non-fungible or at least operate how you understood it to operate in the first place and this is where you can really come into trouble uh with you know http addressing in nfts so you need firstly if you're not storing your metadata on chain which let's be honest you can get very expensive especially if you're storing this on the ethereum main net and you know particularly for large files as well if you want audio if you want video if you want 3d objects as part of your nfts which you may well want to do with um for example metaverses or gaming examples then you know this gets really prohibitively expensive to store on chain so secondly you want to keep a fixed address for that content that ensures immutability now you can code in like mutability your contracts and there's actually we've got a whole tutorial on how you would go about that in the right way as well but that's beside the point for now but we want to ensure that this non-fungible token stays non-fungible so that's where the ipfs content addressing protocol comes into its own with nfts so these cids on ipfs guarantees immutable content referencing and the third thing is you really need storage that's persistent and reliable you want these nfts to last forever right not just like the next five minutes and then never be retrievable again so this is where filecoin comes into play as the decentralized storage guarantees uh for that you know nft metadata luckily though you don't have to go around and like create the whole ipfs thing and then cr store it on like eight different storage providers and make storage deals with those storage providers instead uh we've created a public good called nft.storage and this is designed for devs who want free multi-generational decentralized storage uh it firstly you are you know create this nft storage metadata it will create a cid ipfs cid for you it will then make deals with at least eight storage providers to store that far coin content and it will auto renew those deals in perpetuity the best thing about it is it's completely free it's a public good so there's no cost to using nft dot storage it's actually used by open c and magic eden as well we're storing about 45 million i think it is at current rates uh nfts on nft.storage so it's really like a standard it's not just great swag but it is that too um so project demo i'll see if i can hopefully change my screen which looks like that's not what i meant to do awesome uh so this is the project that i've kind of made uh you can see i can just type in my name and it's kind of a customized personalized nft now i'm doing this on the rinkby chain at the moment but it also deploys to polygon or binance chain and that's uh via morales so i'm using morales nodes to enable me to like deploy to multiple eighth compatible uh chains with this now at the moment it says it's saving nft metadata to nft.storage and i just want to show you the mechanism behind that as well if i can find it which hopefully i can all right yeah not that one not that one let's try this one so this is creating the nft metadata this is my function that creates the nft metadata with nft.storage it's just really as easy as like importing that mpm library that node library into my react con uh front end basically into my react front end uh and i create the client the same way you do with anything with an api key and then i use awaitclient.store you can see here the json that is going to be my metadata so i've got a name i've got a description i've got an image and i'm just like um encrypting that on my front end so i don't get any injections but it's just an ipfs image basically uh and then i'm you know storing whatever other attributes i want to with it so it's really as simple as calling a function like this uh to create your nft metadata and let me just go back to oops it looks like it's actually minting it's asking my wallet to mint i just want to go back here quickly because if i have a look here um i've actually created an ipfs image link i think my internet's a bit slow so my image isn't showing up but you can see here like it creates i don't know if you can actually see the url but it's got a https and then it's got a cid which is like this big long uh letters and numbers here and then it goes dot dot ipfs.nft.storage dot link and slash the name of this image which hopefully will come up soon but but um so this is our gateway so ipfs by default doesn't actually work straight with uh http which makes sense right they're two different protocols so ipfs needs to go through a http gateway to be seen on regular web browsers now luckily for us browsers like brave and opera do this by default so i can just type in ipfs and then the cid and brave will automatically route that through a http gateway for me but other browsers don't do this by default and that's where you'd need to add on this gateway for it so things like chrome wouldn't do that by default don't know why that's not coming up let's not worry about it so basically after i've created my nft metadata it will return an ipfs um cid for me which i'm pretty sure it does let me just type in metadata instead there we go we've got too many console looks anyway so this is what gets returned from nft nft.storage hopefully you can kind of see that so basically ipn ipnft a url and then that data that i stored with it so attributes description image and the name of my nft um so i'm taking that uh ipfs url basically and then i'm sending that because this is actually a json object which i can verify by putting this into brave browser as well which also may not come up there's an example from earlier that so that's that's there's one i did earlier like the cakes no anyway so this should come up there we go so this comes up as the json object here and i just type that straight in ipfs and then the rcid into the brave browser and it automatically shows you the json object that i put into that that's kind of just an aside now if i do click mint that's what i will send as my ipfs uri to my contract sure so now i can click mint oh look there we go my image has finally showed up thank you it does work it's true uh so now my nft is minting and it's basically just calling that uh mint my nft function in the erc 721 contract or 1155 contract taking that ipfs uri and sending it through i think maybe i'm just about at time here so i won't linger too long on this you can actually go and are we still no what are we seeing up there it looks like sorry guys looks like my screens are showing the wrong thing so just try and fix that that's better all right so uh you can actually go and mint your own fnft um at new york sorry nft i've only got it on test.net but you can go and meet your own or whatever chain you like um just go to f new york file coin nft on the bitly link there and you can go and mint your own you've got some test snap um what else have i got all right there are more dev tools than just storing nft metadata obviously to ipfs and filecoin some of the easy ones if you want to get to know ipfs you can install our ipfs desktop or ipfs companion for browsers and play around with ipfs and how it works that way we also have ipfs http and go client libraries so you can go and have a look at those and use use them in your projects as well fleek hosting is another cool one uh so fleek actually deploys your your static websites on ipfs and then stores that to filecoin and it's as easy as using say netlify or versel which you might be used to in the web 2 world uh and taking your site from github and then deploying it through fleek instead which actually is on ipfs and filecoin so actually making your daps your decentralized apps more decentralized instead of using a centralized website sorry uh cicd you could use flake so another cool project is web3.storage so this is for any content that isn't just nft metadata so files folders text whatever else you might want to archive and store web3 storage is the right place to go for that another one i'll mention is textile powergate so this is a bit more advanced it's a docker container wrapped around an ipfs and filecoin nodes and it gives you more granularity around how you want to access storage deals or access lib peer-to-peer which is another thing in our ecosystem or access ipfs they also have some experimental bridges to other chains as well and the other thing they do have is something called threaddb so a lot of people come to web3 and they're looking for a relational database now that's not an easy thing to achieve in web3 in distributed storage but there are people working on it and one of those projects is thread db another one of those projects that's working on a relational database is orbit db so you can try that out uh if you want to get in the weeds and and work on something relational database have a go at orbitdb or threaddb there's also heaps more tools out there using ipfs or filecoin or making them easy for you to use i should say so ceramic is also using ipfs and filecoin and that's a decentralized identity based solution for social id portability lighthouse.storage as well also makes it super easy to use ipfs and filecoin and another project in our ecosystem if you're looking for our random numbers is dram.love so check that out if you're looking for random numbers um so some further resources as well here's that guide to mutable nfts that i was talking about earlier so that's on nftschool.dev there's also more like really short tutorials that you can go through on proto.school and get an idea of how that works there's obviously the docs always look at the docs right and then our youtube channel as well and after this hackathon if you do submit a project you can go and apply for one of our grants if you want to keep building on your project that's probably some of our further resources get in touch of course all our get in touch things um be involved you're already involved because you're all here right so congratulations on that and i've also got finally just want to show you some project ideas so these are some of the cool projects that are actually building on ipfs and filecoin so i did mention live pier and audience earlier uh huddle i won if anyone's seen the like zoom like web 3 version though huddle ones also building on ipfs um and like i said openc is using nft.storage there's a couple of cool projects at the top there that are from 8th amsterdam that well i really liked so tetris they were creating a whole tetris game basically and saving each piece as an ipfs cid and then reconstructing that and making an nft out of that game so i felt like that was like a really clever use as well um you know of things to do but there's so many more things you could do with this um so you could create a video streamer uh you could create a youtube rapper with ipfs which you know might be kind of current at the moment uh distributed metaverse there's heaps of project ideas and past winners on our hackathons.filecoin.io site so if you want to get some inspiration go and check out that site and otherwise uh thank you everyone appreciate your attention and i'll be around all weekend so if you want to ask us questions come by the booth [Applause] come on hi guys my name is jack and i do developer relations at owen labs which is the company that incubated the amino protocol and uh today i'm here to talk to you guys about the amina protocol and zk apps um for people who don't know the mina protocol is a layer run blockchain uh that is kind of built with zero knowledge proofs at the center and so this impacts both the way that the blockchain itself works in terms of consensus and stuff and also the way that developers uh you know build applications for the blockchain and so we'll kind of get into that in a minute um yeah so hopefully by the end of this presentation you have kind of a sense for what mina is and also a sense for how you might go about building an application on mina and why you might want to do so um so here's kind of our run of the day uh we'll talk about mina nzk apps architecture uh then starkey js which is the typescript library that we use to write zero knowledge proofs for mena um we'll go through a hello world example and then i'll direct you to places where you can learn more and we'll do a quick questions and answers um so the kind of first we'll start with mina mina probably you've seen the marketing uh our uh marketing is full of this idea that we're we're 22 kilobytes other blockchains grow because you have to remember the entire history of transactions in order to be able to to kind of verify a recent final state um mino works differently because it uses recursive zero knowledge proofs to to basically uh prove that all of the previous transactions are valid and then prove that all of the new transactions are valid inside of a zero knowledge proof that can then be you know put inside of another zero knowledge proof and so on and so on and then so this is useful because the zero knowledge proofs are fixed size uh they they always stay uh uh well the zero knowledge proof and a couple of other things total to 22 kilobytes um and this is useful for some things like bridging uh we'll touch on this in a minute um but it's it's also kind of uh just a good thing to keep in mind as we go towards uh um how you build applications using mina and and and why you might want to um because the the benefit of mina is not just that it's very small but but also that it uh it enables a huge amount of things that you couldn't do on on a more traditional blockchain um so uh yeah amina is succinct it's small uh uses recursive zk snarks to compress the blockchain into a single zk snark uh and and this uh proof system that we use is called kimchi um it it has uh some some kind of qualities um uh plonk and and uh and halo 2. um and then some things that are kind of all its own um uh it's trustless uh it's recursive um and uh it's pretty efficient it has some some cool custom gates to let you do some some useful things really really efficiently um and so you know uh how does an ethereum d app work well uh you tell ethereum what you would like it to do and it does this on your behalf and the result of that is that anything that you want to do on ethereum is going to be public and if you want to to kind of make it private you have to really think a lot about how you're going to do that so so um there are ways to obfuscate the public data but it's usually not simple um and and it it's pretty constricting in terms of uh what kind of applications people have developed over the last you know five years um mina zk apps work significantly different uh the computation actually happens off chain um and so uh you you write your smart contract in in starkey js our typescript library that i'll get to in a second um and and the user just runs it like they would run a code that's a part of like a web app like google drive um and and so you know how do you keep this uh secure how do you you know guarantee that users aren't um doing things that they're not allowed to do and that's what we use our zero knowledge proofs for so um when you interact with mina what you're doing is running the code yourself you're running your transaction uh on your own computer and then you're generating a proof and and the the relevant state updates which can be nothing uh you cannot update the state at all or you can update the state depending on uh you know kind of if that's something that's useful to you or not um the advantage of this is that it's uh scalable in the sense that there's no gas model you can just the only thing that the amino blockchain is doing is is verifying your proof and and that's the same amount of work every time and it's the same size oh cool okay um yes that's the same amount of work and it's it's the same size and so um this means that uh every transaction um well every zk app transaction costs uh basically the same amount it varies based on uh you know market demand uh and congestion but it uh there's no like gas model and so you can do a little bit of computation and that will cost the same amount as doing a huge amount of computation the the only limiting factor is how long you want to sort of wait for your computer to do things on its end it also is private because you don't have to send any of your information to ethereum this makes it really uh kind of easy to see that if you do all the computation on your computer and you send a very small zero knowledge proof and you've done a lot of computation well there's no way to commit to all this computation inside of this tiny zero knowledge proof and so you have privacy by default um and and then you can you know uh kind of open things up as much as you want to so you can you can start with a level of privacy that is sort of so extreme that it's uh it basically makes the applications useless and then and then you can go all the way to this place where you just make everything public um and so you can pick any anywhere in the middle on that on that kind of slider whatever fits your your use case well um and then yeah i think i kind of touched on this but the off chain execution is basically unlimited it's only limited by the the uh kind of computer hardware that you have that's generating the proof and the amount of time you're willing to wait um so you know what is this useful for so uh here's kind of an example of uh something that mena can do that is is kind of unique and so this would be to to prove that i have more than five thousand dollars in my bank account um without revealing the exact amount or any identifiable information about me and so um you know this is useful because you might want to to kind of just use one quality of a piece of data without having to give that data to uh everybody and in the case of a blockchain you know the entire world and so um you can uh you know define a smart contract that will go through your financial data uh and and prove that you have more than five thousand dollars um uh and and not disclose uh the exact amount of money that you have it's you can write a program that will basically like only throw true if if uh if you have more than five thousand dollars and and you don't have to um to to uh run that computer on i'm sorry you don't have to run that program on um on somebody else's computer in order to to prove that it's it's ran correctly um so something else that's interesting uh but about kind of mina and it's succinct quality is that you can actually bridge mean a state to other chains uh much easier than you can um in other blockchains where the the the total size of the chain grows significantly over time um and and if you're interested in that you know come talk to me at our booth we'll be here uh the next two or three days um so zk app is is what we call these uh you know decentralized applications that use zero knowledge proofs um and uh this word kind of includes uh the smart contract and the ui and and this is cool because uh as i said the the uh smart contract is written in typescript now which means that you can actually just you know write it in typescript publish it as an npm package and then import it into your front end and and just deploy uh basically your your front end um so a snarky js contract uh is compiled into basically two artifacts um the code itself remains and this is like you actually run the code that the the contract developer writes directly um when you use snarky.js but in order to uh constrain this code and make sure it's executing correctly we use um uh approver function which is uh uh something that runs locally uh does the computation and then generates the zero knowledge proof that it ran in the correct way and um and a verification key which is a is a sort of like a commitment to the state of the the code um at the time that you you publish it to the blockchain so this this is how you ensure that nobody's uh changing uh you know what the code does it's kind of how you identify it um and when you deploy the verification key to the the amino blockchain it creates something called a zk apps account which is uh it's it's just like a normal mena account except for that the way that you can interact with it is now determined by uh whether you can create a valid proof um and then you would include that with your transaction in order to uh um uh kind of uh just like in order to be able to interact with the the the account at all you have to have a valid proof and so you can set the account up in such a way that you'll only be able to generate a valid proof in the event that you'd you know meet some specific spec qualification that would be basically what you have programmed the code to do um so yeah you can see here's i guess a demonstration of that you send a transaction and it it updates the verification key for one of these accounts and then you have a smart contract on mina and you can't send the transaction uh without a valid proof and you can send the transaction with a valid proof and so every zk app is compiled into a program which has um the input arguments uh and the on-chain values um so these would be the values that you know you're taking either from users or from the current chain state and then outputs which will be a list of updates to perform and a list of preconditions related to the on-chain state um and so uh when you run the smart contract uh if you run it correctly uh you can get a valid uh verification key and i'm sorry uh proving key and you can send that to um uh the mena blockchain along with the state uh transitions that you want to to take place and uh as long as the the zero knowledge proof is valid uh mina will will update these states um okay so kind of getting into snarky.js a bit more stunky jess is written using typescript it's a typescript library and you import it just like you would uh any other typescript library in practice it feels a bit like react to use it feels kind of like a framework for for defining zero knowledge proofs it's very easy to use um and it fits in nicely with uh existing tooling which is really nice because uh kind of like a part of our vision for snarky jess is we're really ecosystem focused we want to make it so that people can write code that other people will use that way if you have somebody who's you know really good at cryptography they can write a library and if you have somebody who's sort of uh more entrepreneurial they can they can use this library to make an application um and and uh i think yeah javascript and kind of the ecosystem around it has really um kind of led the way there in terms of how do you get a bunch of people sharing as much code as possible um so uh we have our our developer tooling is called the zk app cli and you can just npm install g the zk app cli and um zk project name and and you'll have a a project ready to go it'll scaffold everything and set up testing linting all the stuff you need to deploy to the chain um uh it's very straightforward to use um and uh yeah you can you can clone it now um so yeah zk apps are written in typescript using snarky.js we use existing open technologies it runs in the browser and node.js um you can use existing javascript and typescript libraries and tools we kind of touched on this um you won't be able to import like a an uh like a i don't know like a javascript cryptography library or something because it won't uh be sort of it's it's a bit like how you can't import like uh jquery stuff into a react project um it kind of has to speak the same language but you you can still use a lot of the stuff that you'd want to um you have uh really really good vs code support intellisense and copilot uh work that's cool um and so okay what do you uh what kind of like data type do we use when we uh program these zero knowledge smart contracts uh we use something called a field and this is an element of a finite field which is kind of like a math idea um that's not super important to get way into uh for most practical purposes it'll end up feeling a lot like a uh 256 but uh it's a it's a little bit smaller um so it's it's basically an unsigned integer with some added caveats which are that you can overflow and division works a little bit differently but we have to use this data type because it's what makes the zero knowledge proof possible um yeah so we have went through this it's the field type in stock ejs and then in addition to this on top of this field type we've implemented some of the other types that you might like like booleans unsigned integers actually we have signed integers and we have something called circuit value which you can use to kind of describe even more specific data types that you might want functions are just normal typescript functions we use a decorator in order to kind of tell snarky.js that hey this is something that's going to be called by a user and data are also normal typescript classes so you can see um oh sorry uh yeah we just have a function here pretty simple uh the the only thing that's interesting is that instead of using the javascript infix operator that would be like the plus sign you know x space plus space one we have to call this uh add method and and this is because snarky gs needs to um keep track of what we're doing and and we need to be working with this field type so you know javascript doesn't have a field type and so we have to you know call this method in order to be able to do addition or multiplication on this field type um other than that it's it's it's pretty pretty much what you would expect though um so yeah we'll walk through a hello world example really quickly and then probably have some time for questions um so we'll write a smart contract with a single state variable named x um and it will have a method update that will let us replace x only with its square and we can only update it if we control a secret admin private key um so this is kind of like uh yeah this is how you uh you know gate who's allowed to to call specific things it's sort of a more general model than like probably people are used to with ethereum um so if x is equal to three and we call update um you know nine with our secret key then then this should work um and then if we call update you know 81 this should work and and uh if we call you know um three to nine that works but uh nine to seventy five uh this won't work um so to write a smart contract we just extend this uh smart contract uh class in starkey js um so we're making a smart contract called hello world and uh zk apps can can uh they they can by default they're associated with um eight uh field elements that are stored on chain and so we don't have a lot of on-chain storage by default because we expect that people will use these uh field elements to store commitments to off chain storage or storage on ipfs you know uh you can put the data kind of anywhere you want you just need to store a commitment to the the um to the data on chain uh and so we use this uh state uh field decorator to to basically say um we're making this variable x uh and and we want this to exist um on chain as as a field type um so we could replace like field with bool or something else and that would work as well um and uh yeah override deploy to configure the smart contract that's not super important uh in this case initializing this state oh i see so um yeah we're we're um in this case this deploy method is the method that's used to you know put the smart contract on chain um and we're you know calling this dot x set to three so we're going to take this uh state here um x and and we're gonna set it to three uh as the contract is deployed um and then we also have this uh party set value this self update delegate admin private key so this is a method uh basically we're ensuring that the person who calls this contract will have the the private key um a smart contract can contain multiple methods each will have its own logic so uh here we've got you know this method decorator in front of update means that update will be callable by users and it takes in uh you know a field element uh called squared and and then also a a private key called admin and so these describe how people can interact with it uh once it's deployed and so in this case you know we'll take x we'll get it from the on chain storage we'll store it in the variable x we'll square it using you know the square method um and then we'll assert that it's equal to uh it's square um and then we'll set x on chain to squared so uh if you were to pass in an x that wasn't the square of uh the prior x this assertion would just fail and it would be impossible to generate a valid zero knowledge proof um so uh finally we'll take this um admin private key uh and we'll actually convert it to a public key so this is a totally constrained method so we can pass in a public key directly into a method that we're calling because it all happens on our on our local machine and then we can compute the public key from that and then in order to make sure that that only the the uh person who owns the associated private key can call it we just use this this account delegate assert equals admin admin private key and so this basically means you know make sure that the person who's calling this is is uh using the the uh private key is i'm sorry the public key associated with um with the private key that we pass in um and so what happens under the code when we run update nine with our secret key uh we run some code in the method with some arguments and the result is that uh um x goes from from three to nine um and so that's kind of like what changes on on chain um and then for our our preconditions we're we're just uh changing um we're making sure that the admin secret key is associated with the um admin public key and then that uh the person calling it has the admin public key um so yeah this is kind of what these contracts end up looking like we define a bunch of state up at the top um then we deploy then we define a deploy method so this is what you use to deploy the contract and then we have methods that are callable by users which are preceded by this method decorator if you're interested in learning more uh you should scan the qr code because it's cool and it's full of good information um and yeah i'll give everybody a second and then we can uh yeah open it up to questions oh it's not working that's not awesome okay uh yeah go by the booth and scan the qr code on the banner sorry about that um i must have broke that at the last second um so uh here's the information that wasn't from the qr code so we have a discord with a channel called zk app developers this is a great place to get information if you're interested in uh learning about you know zero knowledge applications and and and starting to develop them yourself um and then we're also on on twitter and and we have our github repositories um and of course the the main thing is the docs uh if you just search minadocs in google you'll get our docs and we have tutorials and and and some explanations of uh kind of what's going on and how to get your head around it so that's it i think does anybody have any questions yeah um okay so the question is you know we're talking about computation on chain and off chain um and where does your knowledge come into this what what can the approver hide from the verifier um and so i got that okay cool so um yeah how this ends up working is uh basically when you when you create the zero knowledge proof and you send it to the chain that that proof really just says i did some computation correctly it doesn't really disclose anything about the computation uh and then you can kind of choose what you would like to disclose about the computation um and so uh if you have something like a let's say that you have a um i don't know let's say that you want to prove that you have the private key associated with like an ethereum account um you couldn't do this on uh another blockchain very easily with without i mean you could sign something actually sorry that's a bad example um so okay let's the better example is a sudoku so let's say that you have like a sudoku and we've committed to like the puzzle on chain and we want to prove that we've solved the sudoku but we can't send the solution of the sudoku to the chain because then it would disclose you know what the solution of the sudoku was and then people wouldn't be able to use our cool sudoku app to get an nft by proving that they have the the right solution um so in this case what you would do is is you would uh prove that you did the correct computation to figure out that uh you know the sudoku is valid um but you wouldn't actually disclose what sudoku you input and so this way you can prove i've solved the sudoku but you you don't have to tell the chain how you solve the sudoku and that way you know this uh game can stay fun long term because after one person solves it it's not solved for everybody yeah the so the question is is the verification sort of a claim that something is true as opposed to uh i did all this computation and i'm showing it um and so yeah the the the proof is basically a claim that you did the computation correctly without having to show it so you can kind of think of it almost like um like uh imagine that like doing the computation correctly gets you like the digest um to uh you know some chunk of data and and uh when you when you do the computation correctly you can kind of like figure out what like one of these like good pre images is that that is basically the zero knowledge proof and then if you do the computation you know incorrectly then you would just have to guess over and over and over again in order to find like a fake zero knowledge proof basically um yeah yep um so the there's kind of like three parts so we have like a plankish arithmetization scheme um with some cool custom gates and then we have um uh we use like the inner inner product argument um that uh halo uh two and and bulletproofs use um and then we have something called pickles and pickles is kind of the like thing that wraps this whole proof system that allows us to do recursion well and it informs the design of some of the other parts of the proof system too but really the the um what it's doing is it's basically uh you kind of have like two proof systems and one proof system is um able to generate proofs that are easily verifiable in the other proof system and the other proof system is able to generate proofs that are easily verifiable in the first proof system and so what happens is you generate a proof and it's verified in in this other proof system and then this proof generates a proof which is then verified in the first system again [Music] yeah no um so uh kimchi does not kimchi is our proof system um i don't know there might be some way to to make something like that possible but it's not um uh it's it's not like uh it it's not something that like intuitively makes sense or is like would be an improvement uh given our situation yeah so um yeah so snarky jess is calling something called snarky which is a ocamo library that's basically um working with stuff is at a pretty low level underneath that um yeah and so come to the booth and we can talk a bit more about that and uh yeah i might even have to probably somebody on the crypto team i mean i'm sorry owen knows better than i do oh yeah we'll be here all night all day all night all the days all the nights oh yeah cool i don't think this i don't know there might be more questions but i think i'm out of time so uh yeah thanks guys [Applause] you 