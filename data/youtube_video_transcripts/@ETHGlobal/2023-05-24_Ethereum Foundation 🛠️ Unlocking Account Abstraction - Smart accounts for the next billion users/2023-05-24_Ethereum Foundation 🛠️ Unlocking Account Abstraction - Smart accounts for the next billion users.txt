foreign [Music] work with the ethereum foundation on erc4327 account abstraction and this lecture is how what is account abstraction what we are abstracting what is it good for so it's going to be an overview and then some a deep dive an example of how to use trampoline which is a sample project for building on account abstraction so first of all before we talk what we abstract let's think what is an account so we have an account account has an address this is the address you hold tokens and nfts and whatever it is an authentication mechanism you have your private key these 12 words that you copy all over to all the to the different wallet applications that you need to protect Etc a once you create a transaction you execute the transaction that is send the transaction to some specific destination and of course you have to pay some gas to the network which is basically the security mechanism that makes sure that nobody sends too many transactions and try to perform a denial service on the network and all of these is defined by the ethereum protocol this is the ethereum protocol for accounts so we come to abstract all of this so what we abstract and how uh the account the account becomes a contract so the address is the contract address the the smart account address it keep still the same address hold to token and everything you need the authentic communication the authentication mechanism is a we abstracted by it is a method on this contract there is a method we'll see it later we called it a validate user user operation is our term for a transaction so the account is asked do you accept this transaction do you accept these signatures do you accept this what what you like this specific method you call it can decide what it accepted what not usually basically it's the signature but it can be more than that execution again it's a method it's a method called on the account but it is fully abstracted in that it can decide not only what the method is named but also what it does yes it can execute on a target with the data but it can do other things it can do validation of the Target and the data if it likes it can do executable for batch like a single user operation that a can you please be quiet to move outside thank you so it can be a batch of multiple transactions if you like or a combination of both and then we abstract the the Gas payment each transactional user operation has to pay for its execution but we abstract it to a contract it could be that the account itself pays for the user operation but it is possible to delegate it to an external contract we call this contract a paymaster it pays for all the transactions and it can decide what logic it performs to pay basic examples uh for that it can be a sponsoring paymaster something that a contract that would like you to use this system without paying for gas someone else pays for it of course it could be a token paymaster it that doesn't pay for itself but it takes your token and makes you pay the system with token um and there are other options now all of these with erc4337 we've done without uh modifying the existing protocol so it is live on mainnet and many many other networks and test Networks uh what use cases we have for account obstruction this is a very short list and there are very many other examples a for authentication it can be as simple as a gaming with gaming you don't want to accept each transaction you make it's annoying you won't maybe do it once so for gaming you could create with account obstruction we don't have it but you can create with account obstruction an account that supports session Keys you approve once and then a transaction that are targeted at specific contract at a specific time frame will be accepted automatically so you wouldn't care to have this key in your browser for example On The Other Extreme think of a corporate account a corporate account has the people who can say in out salaries the people who can send the amounts over a larger values or the legal department which is not allowed to make any transfer but allowed to vote on some doubt I don't know the contract can decide what it likes to do and again the system doesn't the account abstraction framework doesn't Define what your account do you the developer decide what features you want in your account this is what we abstract regarding payment I already described this to a scenario sponsoring for onboarding and pay with tokens other possibilities exist uh in the recovery since the account is a verifying itself it means that it is no longer bound to a specific a private key or something so you could have some sophisticated recovery mechanism the First vocabulary mechanism the simplest one is a change key you know something you can't do you can't change your private key with account abstraction you could start you can start with the browser use your browser metamask like a key to protect it and later on after you gain some money you don't want to lose your address so okay you will change the key and now your signer will be I don't know Ledger it is the same account you didn't change the account if you take out your metamask on a metamask a normal metamask you take out the private key and put it into a ledger you didn't increase your security it was exposed it was written on some paper it is not secured anymore so you have to move assets to a different address with account Obsession you don't have to you can even change the implementation of your account you start with a simple account later on you want to switch to a glossy safe based account obstruction go ahead just fine there are many other examples we had a very long lecture back in the Bogota and the others I I there was also several hackathon projects some of which won prizes in the previous hackathons so you can look at them too okay let's dive a bit deeper what is account obstruction what the components we have the first layer are contracts the first component is our account is our account contract a smart account contract it's the contract that represents the account the next entity is the entry points since we didn't change the framework they didn't change the protocol we added a Singleton contract we call entry point all the traffic go through it through it and it runs the protocol runs the validation make sure that your account can't be a griffed and can be nobody can perform any operation on your account without your permission it will sit in a moment and and the last transaction user operation may contain a paymaster a paymaster the contract that is willing to pay for this specific transaction a user operation user operation is the name we have for transaction we could name it a a transaction account abstraction transaction it is named user operation but basically it's a transaction different fields but it is a transaction a bundler a bundler is the component that put the transaction on chain if you think of a normal transaction you have the nodes or the block Builders or the miners the pending which take transaction and put them on chain with account abstraction we name this component the bundler because it bundles multiple user operation a there is some confusion about this component but basically it is a node just like a block Builder that supports account obstruction uh lastly we can see the mempool a account of suction or erc4367 try to use the exact same model security model of a ethereum and that is transaction going to a public mempool and then nodes pick them up to put them on chain in order to censorship resistant so we copy the same mechanism so we have a mempool obviously it's a mempool of user operation a lot of transactions uh let's see the life cycle of user operation how it goes and compare it with a normal transaction the green one with this is this is a wallet a software wallet IMS user want to create a transaction it could be an Android device it can be a browser extension I don't care using wallet connect or whatever so it creates a user operation these are just few of the fields of it there are 10 of them a little bit more than a normal transaction it creates a user operation a just like the normal Wallet create a transaction a and then after filling the user operation it sent them a into the mempool through an RPC node again just like normal transaction except that this is the user operation a bundler picks up user operations from this Maple that it decides that are worthy enough for him they pay enough that it wants to put them on chain if you think of a block Builder a block builder takes a transaction and performs a very simple validation you check the signature he checks say that it the user the the nonce is the next non-store including the balance is enough very very simply a check a bundler performs a view call into our entry point in order to validate the user operation before putting it on chain it performs a simulation of the transaction it calls the entry point a simulation function which in turn calls the two methods in the account itself it's called the validate user app which would revert if it is wrong with the signature phase or some other filter wrong and then it asks the paymaster again validate permaster user up do you agree to pay if there is a paymaster otherwise it is the account to pay this is the validation the transaction is okay now it's ready to put it on chain so it creates the execution phase it creates a transaction and put it on chain usually within a bundle of multiple user operation but it can be a bundle of one operation it calls the method called handle Ops handle Ops first perform the validation it's not enough to do it off chain of course it repeats the validation it validates indeed on chain that the account agreed that this is a valid transaction it payments agreed to paid and after validation it performed the execution it executes the user operation and gives the paymaster some time to do cleanup very useful if you are a token pain Master because during validation you charge the user for the max token needed and in the post-op you refund it with the access of the tokens you didn't use this way the user will have to pay and it can't get away without paying this is a flow transaction again this is basically repeating what I said about comparing a an account with a an account eoa account in a Content section account secured instead of by protocol it's secured by code validates we can do whatever validation we like it's not only accept or reject a single transaction a memory pool quite similar for different entities and the block Builder instead of Performing this protocol specific code it it runs the validation code one level deeper I want to create an account I have to implement a method this is the only method I actually need to implement for an account which is defined by the protocol validate user operation I get as an input the user operation itself I get the hash of the user operation it's a hash on all the fields but since it used in the protocol there is no need for the account if it needs this hash to calculate it again so we pass it in and how much this user pressing the max possible cost of this user version how much the account needs to pay what the account has to do with it it has to validate that is called from the entry point this is very important it is about to send money to this address so you don't want to pay anyone it has to validate this user operation someone told me it's a misnomer it's not validate signature it's validate user operation you validate the entire user operation and finally it pays the amount it made this is the code of the base account accounts usually will inherit so that because usually it validate is the only function they need to override if you looked at previous talks I gave there was also another check of the nonce because we did let the past abstracted nons and let each account do its own nonce management but we found out that it does cause problems uh to some actually nothing on chain it will cause problem to block explorers with in some other tools that might want to look at the blockchain so we decided to uh not let's abstract the nonsense and nonsense are handled and managed by the entry point itself still the account has to manage a to validate its own signature this is the validation of our sample simple account simple account is an account that attempts to mimic an AOA it performs the same signature check so it a it uses a open Zeppelin to add the ethereum signed message prefix to the hash and validate that the signature is a valid over that one thing you notice that I need to reverse it returns an error in case of a signature failed it could revert but there are many reasons for a validation to fail like signature could be of a wrong length one type some other validations you would like to check here but for a signature validation check with the return value the reason we added here against is a ux because a ux issue because you want to be able and I can't want to be able to uh to the estimate gas or to do a the equivalent of the if call with the user operation and you don't want to be able to do it before signing so if you would if you would revert then some of the checks will not be able to be checked so what we did is that the account returns zero if everything is okay in return an error saying okay this signature is failed and during a gas estimation for example we ignore this signature check and of course on chain we check that the return value is valid zero um the execution uh this is again the execution of a simple account again it can only be called from an entry point uh obviously you want to make sure that execution is done only if you validate it and the entry point assures the account that only after calling validation it would call execution this way the account this is the only check it needs that the sender is the entry point and there's also the basic implementation of a batch and someone will say that the execute batch doesn't pass value and they can go ahead create your own execute batch this is not part of the protocol an account needs to have some execution methods we don't mandate what they are the validation is the only thing that the protocol the of the with the end from Define you can put whatever method that to call and you can call other methods like method in the account itself you don't have to go through execute and call your account if you can support other methods um sorry this is the logic of the account I'm now going into a paymaster what a payment has to do again the paymaster has his validation function the the base pay Master again wraps it just to make sure that it is called only from the entry point a if there is a pay Master the paymaster will pay able to transaction the user who will be told you're paying zero you don't need to pay anything and the paymaster will pay as I said it will be called first uh to validate and after the uh operation is completed the payment is called again with the actual gas cost that was used it the actual name is the actual gas cost except the post-op we are unable to calculate how much if you want to create a token paymaster and you want to pay for this post operation uh we are unable to estimate how much gas it will take a contract a paymaster has to have its own constant how much to charge for this poster uh now I will go over a trampoline trampoline is a browser extension we created it inspired by Tallyho or by a metamask it is not based on their code and it is used to create a an account there are many several projects were already created the using this in previous hackathon and yes we would like to have to see projects that go with the account obstruction I'm sure that the first thing people want to say yes I will create an account but yes there are many of them try to think or don't approach me with it try to summary innovate something new not only create yet another account but add something on top of that uh there are many examples we can show as I said of what account can do we want to see as something new but this is a template of how you can create an account so the account uh the sample is built first you have the account API it's a wrapper contract that it's a wrapper a JavaScript code you will see around the API you need to implement a foray or a for your contract account and then there are three UI components uh react a component that you you can use one of them is the onboarding component that is called once when you create an account the other is a react component that is executed every time you do a crazy transaction and the third is a component when the account attempt to do a sign a so first of all okay I have an account API what is an account API this is a wrapper you you have to implement if you create a contract and we created a simple account we created a simple account API which gives JavaScript functions for each of the uh a JavaScript function in order for the account to be able to work with it the first function is a a get init code get init code is the Constructor code if you like that is called to create this a account it's a call to a contract and what data to pass to it usually this data contains the signer information to create this account uh this the factory contract is Unchained and this is data to create it the second method is how to call the nons usually accounts have a get nodes function the simple account has a get nones function this is the JavaScript function to call it we need it of course to pull the field fill the fields in the next transaction and the third one is the encode execute as I said the execution method we call by default we use the name execute but again it's a default it's not defined by the protocol you can have a different method and it will work with the nurses say if the a different signature everything is okay it doesn't have to be anything specific it should contain the target the call data and the gas if you like doing batching any kind if you like and lastly of course a sign it's the method that is called in order to sign the transaction which should pop up something to the user to sign or if you do it silently it can also be done boarding component is a react component with a single method that it react callback onboarding complete it returns some context I didn't show it before when you create this simple account it gets this onboarding context so onboarding can ask the user for some information and use it to create the account and when you send a transaction when the user calls send transaction then a we call the transaction component you display the transaction and then calls the it should call the uncomplete transaction which in turn called the simple account API to use that information to create a the user operation out of it now I want to show how it looks so okay first I have this extension here one we actually make it ready with this last three years the this is the the trampoline a contract on GitHub I cloned it here now just I will start it uh actually it's already compiled I think I can load it from a previously compiled so I go into extension I need I need to disable metamask it doesn't work in partly with metamask this one I loaded earlier so reload it I will go into this project the project compiles this is the trampoline projects we're going to the build a Reloaded as a component and now it will ask me to create an account this is a sample page we started and then create an account a if you like to encrypt the local data it's possible metamask does it and ask you for a password yes you can use it but if you create an account that saves all the private key elsewhere and then you don't need to I wanted to demonstrate I don't have it right here the web will send an implementation that use web authentication that is the authentication API inside the Chrome or on Android devices but I'm unable to demonstrate it right now sorry so this we created here you we pop up a customizer component you whatever you want to put in front of it it created a simple account created the account by creating an account I mean it created the private key it's everything in memory it created the The Constructor code how to call it and I have an address but it's not deployed and it doesn't have any so I will send from my own account some if to it yeah hey [Music] um why does it say fail that's new um so this is okay I'm sending some if to this account now if you you can click on the deploy and then it will ask for transfer fund soon it will notice that I transfer and found it they can deploy contract but okay I find I don't want to deploy it I want to create a transaction directly with this account even before it is deployed um so here I open etherscan this is a nice contract a sample from open Zeppelin actually it's the old sample they have the greater sample and I will use it as an application I will connect my browser extension to it it says a metamask it man it means whatever account you have deployed a it will pop up the the ux the connection weeks of our account okay now I'm connecting them can call this set greeting function and they send a transaction again it pop-ups a dummy component the basic sample doesn't do anything in it so now it estimate the gas that it will take and we see the transaction that will be sent to the accounts if you want to this page again it's fully customizable in the code you can put whatever you like like custom Logic for paymaster if you add one I'm sending this transaction s a moment until Supply will agree to accept it so simple is faster than girly yes okay we it completed this our transaction if we look at it we see the transaction from an address it is some bundler uh and they it is sent to our entry point if you go to a greeter and look at this transaction of course we will not see anything we didn't call it directly it is called the as an internal function uh and our accounts if we now go to our accounts if I look at my account now it is deployed uh it paid for its transaction and if I go to etherscan I can see it a the contract itself this is this is the contract code it is the it was deployed by this it it paid for its deployment deployed and they executed on chain uh one thing I found some if you want to look at the transaction itself is very nice and detailed to understand how transaction goes on chain foreign no this is not it it's the wrong transaction foreign foreign we can see the method that called the validations here it creates this it creates the center this is the code that runs the factory that creates the sender and the it calls the account validation this is the account called the entry point to pay for itself and the the account called this the gritter function and change the greeting message even the the log inside it and finally the bundler that they pay for this transaction and you get refunded eh okay this is the account now a yes building all this is not a sole project of us there are many where are they there are many projects that they did a lot of work to help several bundlers out there right now I think this one is using candidate bundler or stack up I'm not sure Alchemy also created the bundle several companies created wallets or toolkits say toolkit that can allow an application to deploy accounts on chain to create initial account to let an old boarding deployment so that you can deploy an account even before you install a wallet um okay so that's it if you have any questions I'll be able to answer fifth question here if you want any help and you can contact me later yes the validation is the value that user let's say you want to create an account with a different signature scheme so instead of a or multi-sync you want to check two signatures so the place to check is the validate user the validate user app takes the signature field and decide that it's not a single signature it's two signatures to verify one very phase two this is what you do in a contract now in the ux you need to pop up the user whatever it needs to collect those two signatures and and put them into the signature field when when okay when the ux ask you to sign you perform a different logic what it has to be done in order to send it a transaction so you change the contract and you change the ux to match it uh okay I'll repeat the question you want to add the rule I don't want to be able to send more than 500 his from a usdc so a what you what you need to do is they probably create a different execution method because you Pro okay in the execution method you can limit that you don't want to call the usdca account with a more with the value more than something usually this is not what you want you want to be able to to let the user decide I want to transfer this from the to limit this specific token for this specific value but so okay oh you have a logic on chain to do it so I'd create a method like a transfer a transfer will limit something it checks the and it performs this let me check and during this is during execution validation will make first a check the what is the method that is called right now validation accept any method because there is a single one execute a validation can check that the method seek you are now calling is called limited if it's called The Limited validation to enforce this limit your right is a sample that is better to be added to a to the demo to write it a yeah we can talk after and it's something that a nice to be added into the presentation any more questions yes how the guys compared with a normal wallet and execution okay it's more expensive of course we are calling an account we're doing a gas calculation on chain uh so roughly it's a 30 or 40 000 K gas of added the overhead uh on mainnet yes you might say it is expensive and uh on side chains on a on l2s there are ways to get the guys a lower okay we're creating a bundle some of the overhead of accounts is a split between a different user operations within the same bundle for example there is a 20 21 000 stipend that you have to pay this is for the entire bundle not for each user operation yes there is an overhead for each user operation uh if you compare it to AI if you compare it to eoa if you compare it to other smart contracts you might call okay let's say I'm calling ignosis safe it will be slightly cheaper yes we have an extra overhead it is not only a smart account it also has some overalls of gas and the goal with the eoc4367 is not staying as a contract but at some point to be able to add it into the framework to add it into the network to enshrine it into the protocol to be part of the protocol one of the benefits then will be reduced gas costs reduce overheads foreign because one of the use case again theoretical one it's not implemented yet is that on l2s there is a it's possible to a there is a gap between the how much you pay for CPU and how much you pay for call data most of the cost on l2s is for call data for putting the data on chain so idea if you could compress a bundle to put less data on chain even if it costs you more gas to process it still be beneficial so the most not cost effective most expensive component in a transaction that you can't compress is a signature because all the rest of the data you can compress but signature you can't we have 32 bytes that you can't compress if you are doing what is called Signature aggregation you can have a single signature for an entire batch and we did some calculation there is the BLS wallet who has done it not on top of account obstruction erc437 but they are planning to add its support see Zach here so uh it will be able for turn while you use bundle is larger than I don't know five ten you will actually reduce the gas cost when running on L2 the gas cost for the client so this is something that will be able to be done on a l2's okay no okay thank you thank you very much 