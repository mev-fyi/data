[Music] [Applause] [Music] and our next speaker is hari and ari is going to be talking about all the new features in the latest update for solidity so we'll just give it a second for uh everything to work out on the av side and already whenever you're ready uh turn on your camera and we'll get the slide uh started from our end here we go hello can you hear me val yes everything is good um i know we're doing the slides on on on our end so just give me one more second to pull that up and now we can sure make that work i'm sorry this one is on my end i i can go present it but i'm trying to see if i can actually make it a presentation full screen mode but let's see if that works there we go okay so just say next whenever uh great yeah so i'll say next whenever i want to move okay great so my talk is about two important abstractions and solidity and as you might already know the 080 version was a very important release for us because it introduced a major feature that is safe map by default but since then we have followed up with two other major features that we believe has a similar potential i'm not going to say what the two features are right now but rather i want to slowly introduce a problem and then try to convince you why we implemented this feature and how you can solve certain problems elegantly using our new features so next so let's dive straight into our toy problem okay suppose you want to write a smart contract that sells some object the object has a price and there is a limited quantity of the object available and the problem is extremely simple the problem is that a user wants to buy some quantity of the object and you want to compute the total price so next the solution the very first solution for this is the following so you write a function which is total price that takes two unsigned integers here quantity and price and then you multiply it it's very simple and perfectly valid code but what is the problem here the problem is that you can notice that the price and quantity are supposed to be two different things for example you are not supposed to assign a price to a quantity or vice versa but in our code we can because both of them are unsigned integers so from a type safety perspective we can do much better so in our example the type only represents the underlying data presentation and note how the data should be interpreted so to repeat we would like to have two different types for quantity and price but we already have a solution for this in the language let's look at another solution so next the solution number two is just using structs so we have two structs here quantity and price they both have a single element and now you can write the same function but the arguments are not structs instead of elementary value type so the code is much more type safe than the previous one and you can no longer assign quantity to price or vice versa that would be a type error but now this has some other problems so stocks are a wonderful abstraction but it comes with the cost i will actually explain the cost in detail in a bit but let's just say that it's not as efficient as the first example so note that a struct is a reference type what this means is that it is a pointer towards a value in call data memory or storage so in this example it is in memory so you can see it clearly because we you have to explicitly specified you can see quantity memory q q and price memory p so remember that i mentioned this is not as efficient so let's forget about the problem for a bit and talk about something more fundamental so next so we will briefly talk about the difference between stack and memory in the ethereum virtual machine so a stack is simply a data structure the ethereum version machine is a stack based machine which means that you mainly do operations using a stack speaking of operations the main operation in a stack is to push a value to the top of the stack and then there are a bunch of operations that allows you to rearrange the stack as well as doing various computations so for example if you have two elements on the stack you can add them by using the add or code and what that does is what that does is that the two elements will be removed and replaced by the result and let's now talk about memory so memory is a temporary location in the ethereum virtual machine where you can store things and read them later the main take away from this description should be that stack is much more fundamental than memory so it's important because there is often this misconception that all values and solidity are stored in memory that is not true in solidity you have to explicitly say memory when you need to store or read something to and from memory so for example local variables are stored in stack and not memory because often they don't have a number specifier so if we go back to the first example the values are actually stored in stack and in the second example the values are stored in memory but this still doesn't explain why one is more efficient than the other in terms of chaos let's now try to see why that is true next so as i said before the most fundamental operation that you can do with the stack is putting a value in it so you can do this with the push operation [Music] the operations is very cheap and only costs three gas so if you consume the value for example uh when you want to add it with something already something that is already in the stack you don't need to pay anything extra for consuming it you only pay for the addition so consuming doesn't have an extra cost as long as the element is at the right location but if it's not at the right location in the stack you can use some stack operations to move it to the right location before consuming it and each of these stack operations would typically cost three gas but in our best case scenario the cost for putting something in stack is just three gas and we hope that the value of value is at the right place so that we don't have to do any more operations to move it around now let's see how to do the same things with memory so if you want to put a value in memory you do it using the operation m store so m store of a b will store the value b at the location starting from a so remember that all operations have to go through the stack so to do m store of a comma b you have to first put the values a and b in the stack so you have to start with b and then a so we have already discussed the cost for doing this so to put b in stack it costs three gas it is a push operation similarly to put a in stack it costs three gas and now the m-store inspection has the cost three which is fixed and at least another three which can depending it's which can vary depending on how big air gets so the more memory you use it can get more and more expensive after a certain point so in total you have to pay at least 12 gas for this operation [Music] and similarly if you want to read a value from memory you do this using the operation m load m load of a again you need to start by putting the value in stack which cause three gas and afterwards the m lord inspection which cost three gas so that is a total of six gas so as you can see here test to write and read from memory you need to spend at least 18 guys whereas this can be done with just three gears in stack so stack operations can be around six times cheaper than memory so can you go back to slides great now i hope that answers my statement not efficient now let's go to the real solution so what if solidity had a way to create an abstraction but without having to pay an additional cost for it abstractions are amazing but we don't want to pay more guests for it so let me introduce you to user defined value types so it is what we call as a zero cost abstraction it can be used starting from version 0 8 9 which was released exactly 9 days before so it allows you to create an alias type while having additional type safety the syntax looks like type u is v where u is the name of the new type and v is an elementary value type that means we can be an address a u in a an indeed etc so how do we solve the same problem using user defined value types so next so here is an example on how to write a contract to fig solve the toy problem so here you define a new type quantity and price you you see the syntax type quantity is you went and type prices you went note that these types are distinct and therefore you cannot just assign one to another that would be a type error so this example also introduces how we allow conversions to and from the underlying type which is by using the function wrap and unwrap so quantity dot unwrap can be used to convert from quantity to uint and quantity dot drag can be used to convert from u into quantity this can of course be generalized so if you replace u and to u with eight every word then wrap and unwrap will correspondingly change so next a very important thing to note about this is that the types are fully backwards compatible what does that even mean so what this means is that even when you have to implement a contract that needs to follow a standard which was written a long time ago you can still use the user defined value types to interface with it or rewrite it for example to uh the erc20 standard requires the type for the amount of token to be you in 256 but you can define a new type with the name decimal 18 which is a zero cost abstraction over you win 256 and you can replace you in 256 with decimal 80 whenever you think wherever you think that's more appropriate and it will be completely backwards compatible so here i have two examples of interfaces and how and uh they are supposed to represent some of the subset of the erc20 standard and both of them would work exactly the same but in my opinion the first one is much more clearer because it makes it clear that the value is supposed to actually represent a number with 18 decimals which is the case for most tokens whereas in the second case it's not obvious what value is supposed to represent in terms of decimals so effectively the feature allows you to write code that is much more clearer and easy to read so next so there are of course some open questions about how we improve this feature and one of them is about defining operators so user defined value types does not have any operators right now but we would like to have them in the future so as you can see in this example which is again about a token and how we have a type that represents a value in 18 decimals so the type decimal 18. so we need a syntax to create the operator plus equal to because if you look at the function mint you have the line balance of user plus equal to value but we don't have a plus equal to right now but we would like to have them you can participate in the discussion uh where we propose this feature by going to the links we would like we would love to hear your opinion on this i will leave a link to my slides later if you want to check out the links so now that we have solved our first problem let's forget about it and talk about a completely new problem so the new problem is also very simple uh next so the new problem is the following so how can we tell a user why a transaction failed so suppose you have a simple contract that can only be used by the owner so typically so it's typical to have a modifier that checks the sender and rewards of the center is not the same as the owner you can see the contract here where you have a immutable variable owner which would be set to the message or center during the contract initialization and then you have a modifier only owner which would check if the message or center is same as the owner which was saved during the constructor and if it's not the same the transaction would reward for example if you look at the withdrawal function it can only be called by called if the modifier only owner is true so i have a comment here which i said don't do this but this is a typical this is very typical in smart contracts and why did i say this so that's mainly because this is a very large reward string it's 40 bytes it's more than 40 bytes and large reward string add to higher deploy cost for the contract as well as higher gas cores for reverting transactions deploy cost here can be especially important if your contract is getting near the contact size limit but what if we had a way to create a high level error object next and that is exactly what customers do so it was introduced in the version 0.84 and syntax is very similar to how we do how we define events so you can see the error only honor and also notice how we use nat spec commands to describe it if you listen to the talk about source verification by franci that happened just before you will see some of our goals about how we want to use nat spec commands to improve the user experience for contracts contract interactions so instead of a required statement you replace it by an if followed by reward only order [Music] next so here is a short summary of the before and after in the first example that's how you do it classically using a string and in the second example we have a contract we use customers and the second example is better because it has lower cost for rewarding transactions as well as cheaper contract deploy cost or smaller byte code and next so let's get to the next level of our reward messages sometimes the reward reason sometimes you want the reverse reason to have more information than a very simple static string in the past if you wanted to convey a structured message back to the user you would have to do something like the following the context is that we have a token like contract and if we have a call to the transfer function and if there is insufficient balance we want to revert and tell that to the user of course we can always reward with saying okay in sufficient balance but we want to do more than that so if you really want to have a proper error message you could do something that looks like this so what we have here is a function you went to str that converts a integer to string and then you concatenate all these things on chain i think i have a bug here but yeah whatever it doesn't matter so first of all this you into string conversion is uh where uh doing it on chain is paying more gas than you're supposed to do i mean it's just unfortunately expensive so when i mean expensive it's not as expensive as a storage read or storage right but it's completely unnecessary in my opinion things don't really belong in smart contracts so you should try to really minimize them and the second reason is that whenever you have a function call in solidity each argument has to be evaluated first i mean so if you have f of a b and if a and b are function call you have to evaluate a and b before you evaluate f so in this case a b i dot encode pack is a function call and that means that even if the condition for require is true the reward string has to be still evaluated so this means that you're just wasting gas for every single call even if even if the call is completely correct so next so let's see how to solve the same problem by using customers so here is an example that combines you know multiple things from this talk the first thing is the user defined value type decimal id so we have a token again and we have a we have an error insufficient balance so remember that i told you that customers are similar to events you can have arguments so here you have a reward with the address of the user the current balance and how much is required for the transaction to succeed it looks very similar to how you emit an event so this is a much cheaper and much more idiomatic approach to having much more structured error than using strings so next so customers is a feature it's a compiler feature but it wouldn't be complete without tooling support so several of the popular tools actually support customers and we are hoping to see better support so currently block explorers like etherscan doesn't automatically decode customers and we hope this is something that would be supported in the near future but all these like all these like tools do support it so next so that's pretty much my talk my name is hari and i hope i was able to convince you why these two major features that is user defined value types and customers are useful and also why we need them i would love to see smart contracts using these features and i hope i was able to influence you you can find my slides in the following link i can now answer some questions you can also find my contact in the link if you want to follow up and if you want to reach out to the compiler team you can find the details in the link so questions that was a great talk um just kind of sourcing everybody i'm just looking at all the chats to see if there are more questions i think overall people are just excited about the the the gas efficiencies here of course um this is kind of the most obvious uh thing that you can highlight along with those idiomatic extractions um so if anybody has quite um we're just getting comments that people are loving this um so uh richie if you have any questions for ray we can ask that too um maybe just a more future forward-looking question will be uh what are some of these other abstractions that you're thinking about in the back burner or possible next releases like what does that look like and and sort of how do you think about the future of the language yeah so one something that we wanted to do was uh having some support for fixed point types and we think that used to define value types is like the first step towards it so right now our uh thinking process is that we don't want like proper fixed point types in solidity because there is uh there is no single way to implement it if you look at the implementation there are like multiple implementation and each one has their own advantages and disadvantages so if something lands in the compiler it has to be you know somewhat uh the implementation but there is no other implementation so we think it's something that libraries should do and we think we want to better support it by using uh user defined value types and that's why operators would like with the next step in user-defined value types uh improvements and i think that would unlock a much more abstract code much unlock that would let you write much more abstract code and also safer also efficient code yeah that's the number one priority right now gotcha um in terms of i mean you kind of talked about some of the integrations that are still like on track to be actually on there from like the libraries to etherscan what have you um what is it that they should keep in mind as you think about integrating it or is there any obviously i feel like you address that there's no backwards and compatibility uh oh sorry there's no incompatibility here as people think about it it is equivalent it's just a high level obstruction but uh for developers on this side looking to just quickly switch over to these attract types um give me any advice or comments on what they should keep in mind uh not really i think it's fairly straightforward to like switch and be purposefully designed uh to keep it simple and if you have comments uh if you're using the feature and want to see some changes we are always open for comments so the way we implement features is by starting with like a minimal version that will like do most of the things and we would slowly add more features to make it stronger so if you have you know comments feel free to reach out to us as a matter of fact the feature used to define weather types was uh greatly influenced by one of our user feedback so it your feedback really matters and it would like influence the language awesome and uh the way people can get involved is it or what is the official resource so you can find all our information in soliditylang.org but you can also uh come to our guitar chat look at open issues in our github channel or in the metrics channel as well but the goal to go to a link is soliditylang.org awesome well um i couple people were asking for a link to the slides we just posted that so uh that also has a link at the end of uh the presentation so thank you so much hari uh for that amazing intro for the demo of what's new and uh hope you have a good rest of the weekend thanks bye all right with that we are ready for our next talk [Music] [Applause] [Music] 