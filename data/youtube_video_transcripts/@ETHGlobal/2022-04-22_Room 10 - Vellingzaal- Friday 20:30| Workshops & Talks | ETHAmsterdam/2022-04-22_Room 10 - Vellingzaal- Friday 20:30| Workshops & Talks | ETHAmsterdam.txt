foreign thank you is [Music] b [Music] yep okay sure foreign already thank you [Music] party [Music] okay oh [Music] my yes i am um [Music] [Music] okay bye yeah i think we are shortly ready to start so i would just love to welcome everyone who is here today who is joining us from the stream as well and uh today we'll be talking about introduction to ipfs and filecoin and how they shape the future of web3 there'll be multiple topics we're covering during the sessions so at the end of it i will also give some time to answer all the questions so feel free to stay tuned and we'll be here also during the hackathon so let us know about all your questions and ideas about building projects during the hack to start with uh there are multiple projects which we have inside the protocol labs myself i'm a startup operator at protocol labs but we work as a community of people and organizations that are building better future through the technology there's protocol apps which is open source r d organization there is a file coin foundation which is a steward of file coin community which is aspiring to put the power of humanity most important information back into the hands of everyone and there are also multiple core solutions such as ipfs which is a peer peer-to-peer protocol that making web upgradable resilient and more open you can think of it as a peer-to-peer version of an http and there is a file coin which is a decentralized storage network to store humanity's most important information you can also think about it as an airbnb for storage and those are multiple components which come together in one place to be the web free layer foundation for the data storage and much much more so we'll go through a agenda today which first will be the core concepts of ipfs and filecoin then i will tell you more about the tools of web3 which will be particularly handy for you during the hackathon to build straight away on top of ipfs and filecoin i'll also highlight you the possibilities of webfree right now to give you a bit more ideas of what is possible what could be done and maybe that will be helpful for some of you to brainstorm your ideas further and there will be also some learning resources and discussion q a in the end so starting with the concepts of ipfs and filecoin i will not go into too much details what exactly web3 is but trust me that we are on somewhere transitioning from web2 to web3 where web2 was read and write so you could write an information on the internet and you can read it from and now we're transferring to web3 which is read write and trust and uh trust here is being an operative thing where you can verify some information on the internet directly without having a prior knowledge to it it also being supported by a bunch of underlying primitives and technology that builds up verifiability directly in web free moreover web free stack is for web free stack verifiable data is essential for a truly distributed system this image is already quite outdated but because the web 3 is exploding like hell and there are more and more projects appearing each and every second but at the same time uh the file storage is still a core fundamental piece of it moreover uh you can place now now us not only in file storage as it is with ipfs and filecoin but you can also definitely move us to the cold storage solutions and uh with soon updates of the file coin where we're developing smart contracts and filecoin virtual machine you could also easily place us to the layer one blockchains with smart logic and smart contracts so once again we are some way in transition between web 2 and web3 where web 2 is being decentralized solution where the data knowledge and information is being kept at the centralized points and we barely have the ownership of that data which is being centralized it's a critical point to the human development and that's why we at protocol labs believe that that this distribution of the knowledge and distribution of the power should be safeguarded and the knowledge should be open and in the hands of people but at the moment data information knowledge is not publicly open and publicly owned and there are a few companies which you familiar which is google amazon apple which are being the silos of the data and limiting uh the ownership of that and if some of this solution fails due to the system being centralized it fails all together and you basically lose access to your knowledge what you can do instead instead of having a centralized solution where you have single points of failure when where your data is monetized by the data monoliths you can have a decentralized or even better distributed system where the users have the power to manage their data where the users power the service themselves and at the same time the infrastructure which is being developed in a peer-to-peer manner it's also been censorship resistant you it ensures the privacy of your data you can self-verify all the content which you're having in the web and the data is being non-siloed meaning that at any point of time you can discover the information that you're really interested in without any limitations and i will tell you in the next 15 minutes or in the next half an hour what is ipfs and filecoin and how they contribute to this vision of distributed decentralized web-free internet and how to build on top of those protocols to make sure that you're really going to the future in the web free and moreover i will tell you that uh files and folders is not a boring thing so first of all ipfs is an interplanetary file system which where uh files and systems is of the file system is obviously files and folders you are familiar with them already you work with computers all the time so there's just the same thing while interdis interplanetary thing is way way more interesting imagine that you have to send uh imagine at some point we reach mars and we'll have to send information from master earth if we maintain these centralized solutions to for any call or any update or to watch a video you'll have to make a call from mars to earth and from earth to mars backwards and this will at least for one call take you an hour so that's not very scalable solution when your teams think about expanding to other planets or generally just expanding your network and that's where ipfs is coming handy into the place uh because of distributed solution in the first place it allows you to download the files not from the central place somewhere on earth but rather have if someone has it already cached on the mars you can directly retrieve it from them therefore connecting and creating a network of peer-to-peer data exchange where everyone can cache and store the data and it's available not from only one source but from multiple sources creating this resilient and distributed solution that can scale across the planet and that's where resilient and offline first solutions such as apfs is coming very very handy to develop a network which is independent of centralized solutions moreover in order to achieve so it's very very complex if you try to address the data as you commonly do it in web 2. for example if you go if you're looking for a book and your friend tells you oh you can find this book in the library on the second floor on the third bookshelf and on the third row from the top then you and it will be the second book from the right when you come to this place and get the book suddenly you realize that it's the same book that which was in your backpack but you just didn't know that it was there and you didn't know that you were referring to this book exactly the same thing is happening right now with computers or web 2 way of addressing information where in order to find the file you actually go to the location of it instead of that or it's actually happening the same in the browser where to find an object in the internet you go to an http domain you go to the path to the index of it and then you find the file there very very weird way to structure finding information and why not instead to actually look for information itself so instead of going to the library to a certain place you just tell a person which book to find and essentially you are looking for a content and not for the address where it's located and that's where ipfs brings the most value because it allows you to address the content by what it is instead of where it is you essentially replace a folder or a file location with a content id which is a unique fingerprint which allows you to discover the object's internet regardless of their location and i will tell you more how the ipfs works specifically for example you have a content which is hello world text document sorry and uh you encrypt you create a cryptographic hash function out of it which is a sha 256 standard algorithm and you create a content identifier for that so once you created a content identifier this is a unique fingerprint which points to exact content of the file which you created so the same content will always resolve in the same cid and content cad can be reproduced anytime from the original content so imagine that it's independent of who creates the cid rather it's always a computer which is dependent on the file you upload so if you have the same content any computer in the world or any solution will create you the same cid therefore you can easily discover the object by what it is rather than by where it is and it also adds us this trust function of the web3 where once you received an object from the ipfs or from any other solution you can validate through the cid if the content you received matching the original cad you requested if something is flawed then you'll have a different cad and then you know that it's not the content you are looking for the best part of it is that content is not only files itself folders could be the same content and essentially a folder is a special kind of a file which lists other files inside of it so all the core principles which apply to the uh files in ipfs work the same way in the work the same way in the folder structure so you can also use files and folders in ipfs without any limitations and to give you a brief idea of how exactly it works here's a small diagram where we have four objects in the bottom and each of it has produced its unique cid so you can always trace an object by a cid each and every and these images are grouped into two folders first one containing the third three first three and you see by different colors there is a fingerprint so these are different cids in the on the first place then all these two folders are then connected in one folder and you get the root cad of the first initial folder so when you have the root cad you can discover which objects and files are inside of it and which uh cads continuously are inside of it and that's what exactly merkel daggers or merkle direct acrylic graph which is a graphs data structure and where each node is content addressed by itself so cags and ipfs allows you to not only address the files but also the structures in the direct acrylic graphs and the beauty of it it allows you to really duplicate the internet in a sense that imagine there is a case where a new folder is created but the content of this folder is based on already existing solutions in ipfs and on already uploaded content so here for example i create a new folder which contains two right images and even though i create a new folder with a new list apparently it gives me the cads of the previously added objects because again cads are referring to the object content and not to the where they are located therefore we get the ability to duplicate the amount of files we store and essentially instead of storing hundreds and thousands of meme on memes on the internet you can just store five redundantly and always point to the same objects instead of just storing them again and again and again this also gives us verifiability if some of the contents inside the folders change then the new cid will be as a result and therefore you can always trace whether the data which is served to you is reliably what you have requested in order for these to work in the network in a peer-to-peer network there is also some functionalities which needed for you to have as a network so first of all the network of ipfs is a swarm of peers where peer is a node in a peer-to-peer system in order for the system to work there are many many peers across the world which are serving parts of the content therefore if something changes or something happens to any of the peers this whole system still became resilient and you you can just retrace the content or find the content on any other peer that is available and still online so in order for the system to work you have uh you need to impose several requirements on the peer-to-peer system therefore each and every node in the network must be discoverable so you have to be able to discover where the node is located and which content contains and it must be rootable so you need to be able to any node to have a trace for other peer-to-peer uh nodes so that at any point of time you can discover both the content and where it is located and that's where a distributed hash table uh functionality which is available in ibfs is coming very handy imagine distributed hash table as something like a phone book where you have a name of a person and a phone number of a person but instead of having just a phone book by yourself you are sharing it with your friends or your peers so you maintain it jointly and you all adding new names and new numbers to it and that's exactly how the distributed hash table works in ipfs so there is a group of peers or group of nodes which are maintaining the same distributed hash table and adding the content to it on upon uploading to a specific peer or note and it's maintained by multiple peers but only a small number of peers so you never have a distributed hash table of the whole ipfs because it will be a tremendous size and very hard to maintain rather if the content is not served in this particular dht or distributed hash table the peer itself can refer and ask neighborhood peers if you if they have content in their dht tables and it's very fast and very simple to trace whether there is a content available on ipfs network in general and in which particular dhc table it is located because all the dhts contain the cids of the content in a manner that they are discoverable and in manner that they are grouped together by similarity of the cad compared to the content and that's where it's becoming really easy to manage and operate the whole network because every peer can add rows to the dht table declare the appear id and provide specific cids based on how they connect to the peer id and how they are available through the network moreover peers can query the dht to find peer id which is providing the uh which content id so making every note available to trace and reach any content in the internet and that being a self-serve system where it's also independent of protocol apps or development solutions where you can it's an open protocol on the first place so whenever you have this solution it's available for you at any point of time regardless of limitations or centralization which i talked to you beforehand the the very nice piece about it is that once you have all these concepts ready and technically working which they are already for quite some years uh you need to start thinking how to build a network out of that and how to serve the content which you particularly have or your own uh through the network so it's available to you over time and uh you it's available to you whenever you need it so there are multiple ways of using ipfs in general uh you say though you need to understand that if there is no nodes there is no retrievability so you need to think about who actually runs the notes in peer-to-peer network so obviously first of all you can run your own node and store all your content just on it so but then it's becoming the same single point of failure and if something happens with your content then it's basically lost then you can also run your own network of nodes but at the same time it comes at the cost of infrastructure running and the team to manage it you can also pay pinion services that's available already right now on the network such as pinata temporal infure and many more but this is a payment solution so you have to pay someone in order for them to provide you the content from peer-to-peer network and at the same time you may just hope that content becomes popular enough and that you can that other nodes will be in it instead of on your behalf just for free and that's that system where you have to rely on a solution or on someone's good will to pimp your data in order to be able to retrieve it sounds reliable and decentralized for you for me personally not and that's exactly where we can talk about file coin and how filecoin incentivizes persistence and verifiability of storage on web3 filecoin is a solution which allows you to make a deal with a storage provider which we have more than 4000 at the moment with more than 18 exabytes of storage capacity already available on the network and it allows you to create a deal where a storage provider confirms that he has your data for the duration of the deal and at the same time it's available and we can prove uh verifiably prove that he stores your data continuously through the whole duration of the deal the duration of the deal and the provider has to run cryptographic proofs on the data which he stores for you every 24 hours so we're making 100 sure that the data is available and the beauty of it is that it's also being replicated multiple times or sort redundantly on the network so that even if something happens with one single storage provider it's always available to you regardless of what an additional benefit or the way we designed it uh to actually serve the multi-purpose is that it also utilizes the same cad solutions as i just described you into inside of the ipfs so essentially you can have your ipfsc id being stored and verified over a file coin deal and it's stored redundantly multiple times so that's how you achieve this decentralized verifiability storage on webfree for your lifetime of your project your lifetime of solution and just long term having preserving your knowledge which is essential for human development and that's where you can also run multiple times the dealing on the file coin that's where you see if you first receive the fundamental reliability or resilience of the structure the beauty of it that you can also run it in parallel with cloud or with any other solution because we are essentially agnostic to what are the other solutions uh you are using to store the data you can also backup it with the cloud you can use it different solutions from different storage providers but it doesn't stop you or we do not lock you specifically on file coin for you to retrieve your data and that's where i would say that ipfs is really loving file coin and they really designed to work well together where ipfs is designed for the fast and flexible retrieval where the gate weights local nodes and browsers are available the beauty is that right now we are also natively supported by multiple browsers the brave is already fully supporting it and running an own ipfs node on the background for you so you can directly watch in the browser all the content from ipfs and there are multiple more browsers that are coming soon with the implementation of ipfs reading where whether they're using just a gateway for ipfs or they're directly installing the nodes the more are coming from firefox and then uh we're also working on implementing it into the chromium so all chromium-based devices will be also natively able to read ipfs uh cads and content inside of it also in on top of the ipfs there is a file coin which provides you these needed persistence and verifiability of the data on chain and reliable storage of the data for the duration of your content or duration of the lifetime of the deal which you have made on top of ipfs and filecoin and that's where we can slowly transition to the tools of webfree where you can i will give you in the next uh 10 minutes or the details how you can build on top of ipfs and how filecoin and how to easily kickstart your project during this hackathon so that there is no problems in building your own nodes and finding the solution that you need to develop on top of ibfs and filecoin so the very first and very very easy to use solution is nft.storage where uh it's completely a free solution to store your nfts with simply two two lines of code you can register on the nfc the search website you can get your api keys and when and whenever you make a call with an api uh your data will be stored on ipfs and filecoin and it will be pinned redundantly five times across the network the beauty of it that cads are again completely uh computed locally so there is no dependency on any of the storage solutions which you are using and at the same time you can still discover it over the traditional ipfs network so all the content could be stored and served on the web directly through nft storage also the beauty of it is that from protocol apps perspective we are treating nft.storage as a public good therefore it's designed to be completely free for use for any nfts we preserve the nfts as a common knowledge and we believe that that's the way how to build the web free so that people really have the access to the data they create at any point of time also if you even think about but what's the incurring cost maybe we'll run it for price later on and then charge everyone because they're uh locked to the system uh apparently we are also at least 100 times cheaper than avs and cloud solutions so it's run on behalf of uh protocol apps and whatever happens to the solution it still could be pinned on your local nodes and be available and retrievable at any point of time when you want to scale your solution not just for nfts but for any kind of storage that's where the web3.storage is coming the most handy it's provide it's the solution for general ipfs and file coin storage and it provides you a simple and familiar interface also with only two lines of code to implement to store it uh reliably on ipfs and filecoin and it provides you one terabyte of data for free so you can use very simple javascript or go client implementations and it has an http api for remote pinning service and a web interface to upload your data or to retrieve your data on your browsing solutions when you're also thinking about developing your uh websites that's where flick hosting is coming into place it's flic.co and it allows you to build your websites on top of ipfs and filecoin and store them directly into ipfs network which uh makes you independent of any cloud storage provider and it's reliably accessible through the peer-to-peer network as well it is very easily built on top of github repositories so you can just connect it uh set up your build settings and it will be deployed directly onto a pfs and backed with the file coin solution so just a simple and amazing tool to run your solutions on top of a really decentralized network and be ready for web free whenever you're building your project there's also an advanced solutions or additional solutions where developers who have uh powergate uh if they want to have a powerful ways to connect and extend protocols such as ipfs file coin and lip b2p it provides you the opportunity to have a docker container wrapped around ipfs node and filecoin node and it gives you the flexibility of staging storing and retrieving data and have the default configuration for the miner selection and one more topic which i want to cover in this presentation and which is the more and more upcoming and important effort of filecoin in particular is filecoin green it provides you now the opportunity to measure the energy which is used by storing your data and our whole effort of protocol apps and ipfs and filecoin in particular is to build the reliability on the web where you can specifically verify that uh the data is being stored in sustainable way and it's uh provable that uh the sustainability aspect is not faked or is not uh just a number on the on the dashboard but rather it's something which is uh cryptographically or verifiably proved that the solution is totally green it also provides you the consensus mechanism that uh is used by filecoin which requires each node to prove that resources contributes to the network therefore you can easily calculate uh the amount of the energy which is being used to store your data and then later on scale it to more projects on the green aspect of the sustainability of the blockchain i think that is one of the interesting topics to work also on in the scope of the hackathons because the green aspect was not that [Music] in the raiders of developers for quite some time right now but we have seen more and more the problems or the general sustainability issues on the world around and i think as vitalik was mentioned it's really a matter and great effort to build the sustainability of the blockchains in the first place making sure that the tools which we're building are scalable to the future also from the sustainable perspective and that's where i'm coming to the amazing possibilities of webfree or what to build right now how to build it and generally it's an amazing network which we are running and the ecosystem which accounts for many many people building on top of ipfs and filecoin it's quite an outdated uh view already but there are all types of uh solutions from flick from orbit from technical solutions there are also many many teams that are building on top of ipfs and filecoin from other chains their practical technical implementations and i encourage you to look through the hackathons.file.io website where most of the hackathon participants from the past year were listing their price projects so you have all the access and all the knowledge which we maintain across our ecosystem so you can have your kickoff of the project for the hackathon for if amsterdam as soon as possible and build on top of reliable solutions rather than developing something new from scratch also there is a list of projects i really like in particular uh which were using ipfs and filecoin first of all we are also backing up the internet archive which contains the most important human data right now we are also collaborating with starling lab which preserves which creates a framework for data integrity and preserves uh testimonials of the holocaust survivors that's where we're also looking to contribute to their public goods and creative commons they're an effort joined together with ethereum foundation and ethereum networks where we're collaborating on funding retroactive public goods funding and generally finding solution for the public goods to be reliable and accessible topic over the web free as well there are also nice practical applications such as audios which is a new version of music tool where you can listen music podcasts and everything there is live peer solution which gives you the opportunity to do video streaming and nft meeting of the videos straight away with their development we also have an amazing projects with [Music] teams or organizations outside of the web free for example we're developing the new york city open data with file coin and ipfs and if you're familiar for with openc or wearable or you're generally interested with nft's topic then you i can also highlight that in the back end of openc they're also storing all the nft content through ipfs and filecoin so in order to summarize that webfree is essentially a decentralized web where the blockchain is a fundamental layer which allows you to make uh verifiability on chain and provides you the independency of a centralized state rather than and ensuring that the content is being available it's been linked and been resilient to the future proof solutions and applications and just to sum it up apparently the best way to predict the future is to create it so i really encourage you to do all the best on this hackathon having an amazing uh 36 hours of hack uh build your projects build it on top of ipfs and filecoin let us know if you have any questions about how to build us will be available on the booth we'll be also giving a talk tomorrow uh our ceo juan manuff will be providing a talk on uh public goods and crypto economics so there is a lot a lot of opportunities and once you join the ecosystem they are more than just building on top of ipfs and filecoin we are also running a huge grant program so for us and for you hackathon is just the first step you can scale further with our grant application with our micro grants development grams and then launching further your project with pre-seed seed rounding and startup as a part of an awesome community and last but not least i will also highlight for you some learning resources there are discord and slack available and specifically for this hackathon i believe we are running through the eve global uh discord but feel free also to join our discordant slack from ipfs and filecoin you can find uh it at file file coin dot io dot slash slack and uh you'll have all the answers there we are working as a public company so everything is available from our development directly on slack you can reach any of our team members on slack and that's where we believe that working open source is not only building up so open source solutions but actually leaving open source making sure that we are collaborating instead of hiding information and where everyone can contribute to the skill of the greater good and a greater ecosystem with that being said i would just encourage and say good luck to you all on developing your hackathon projects it's definitely an amazing time and i was a hacker myself a few years ago i love this time and i'm will be here together with my team to support all your questions and making sure that uh an experience for you to build on top of ipfs filecoin and any other solution from protocol apps is an amazing experience and you want to stay with our ecosystem further thank you a lot and that would be it from my side and i guess we are running greatly in time so we have at least 10 minutes for the questions but i'll also be happy to stay further and answer all your questions afterwards so who want to be the first yes yeah that's a very good question oh yeah uh so the question was if uh the content on the ipfs and file coin is public or you can somehow encrypt the information first or what what are the solutions to work with the private data essentially so ipfs and filecoin is deliberately an open network so all your content which is stored for ipfs and filecoin is public you are completely right that you can first encrypt the information and then [Music] decrypt it when you download it but it will still be available on the public network as a peer-to-peer uh storage solution uh i would say that there are some teams who are working on encrypting the solution on encrypting protocols on top of ipfs and filecoin but you are more than welcome to develop your own i think that's a hot topic right now and if you're working with some private data it's very interesting to also think where which parts of data is actually sensitive and should be private because quite often it's only a small fraction of the actual content you want to store which is private and you can split it and still store most of the content in a completely open system there was one more question yes please well whenever we speak about public goods first of all like foundational human knowledge is very important topic i believe the like the content about learning about uh just general education is this something which should be preserved and should be available regardless of the pay walls regardless of proprietary information that's something which all the society should build on top of there's also public goods which could be the data sets which provides you the knowledge on for example medical data sets or something which you can build on top of in order to create a more resilient and more efficiently working system at the same time public goods could be some uh i mean uh there is common projects which we are building from retroactive public goods funding with ethereum foundation where it's also being a focus of ensuring that the developments which are happening in the public goods field is uh being well funded and receiving sufficient support from the teams and at the same time apparently just storing the data for someone could be already a public good whenever the information which is being stored is socially valuable or uh just generally valuable as a human knowledge does that answer your question yeah thank you are there any other questions potentially uh yes so uh if we are speaking about web applications like hosting the website through flic.co i uh i believe they are also hosting it on uh their own notes so you get quite uh good retrieval speeds though yes you have definitely keep in mind uh on the real retrieval speeds of the data uh ipfs file coin is now uh not always as fast as the traditional solutions though we are right now building the super hot cdn solutions where in one two months it will be production scale ready and the same speed as the cdn on of the traditional cloud so that's the feature we are also aware of and we are developing uh towards making it uh large-scale and available as a retrieval uh storage market but that's uh a topic which we're also discovering right now but there is already like you can already build on top of ipfs and filecoin and get proper user experience though it takes us an additional time to make sure it's all fluent and available then you know you need an additional note there i mean firefight eventually will have will incentivize that with the extra crypto economics where you have a market for retrieval notes and then basically anybody could be a retriever at which point you have an extremely atomized like cdn that's yeah more distributed than any other cdn could ever be right because anybody is victory perfect any other questions uh then what does it mean for me to run an ipf let's say if i want fast ritual speech yeah that's exactly how it works so if you are for example if you're sitting in the same room and someone from the room already have your content he can directly serve it to you instead of going to a centralized node and download and uploading it directly so that's the beauty of it where the more peers are serving the same content the faster the retrieval you will get and if you are working from the same network that's the ideal case where the peer can just directly streamline you the content which is which he has and that's where the more knows the better is the approach but at the same time uh having this retroability speed is also dependent on like the size of content and some of the delays which may occur on like peer-to-peer networks which are like which are traditional to it what is it internally is it object storage unix file storage uh can you elaborate a little bit more on the question how exactly the file is stored inside the inside the node you know is it like object storage or they use some technologies like i don't know how hdfs stores the files yeah so it's a it's a file distribution so it's uh any object could be uploaded independent of a file format and will be served from the node to the node uh not all the nodes will contain the file fully so some of the nodes will be only serving it as like transmission nodes so they do not need to store your file directly but they will be only transmitting through them because essentially there is uh connectivity could happen through each and every node on the network any other questions yes please more technical questions so as far as i understand the way the cid hashing function works on images so it divides the image up into separate chunks yes will change essentially if you change any pixel of the content you'll always receive a different cd i think that's a very interesting corner case and i would love to know if you explore that further during your hackathon but i would assume that if the content or if the file size also changes then it will also affect the final cid because essentially you'll store it in a different format than it was originally so the idea of the cid encryption is that every unique content creates its own unique cid and in down scaling i believe you still change in the back in the background of the file how it's been recorded so it doesn't take your image directly in a sense it takes the way machine explains it and then transcodes it into a function yeah any other questions if not i would love to thank you all for your attention it was an amazing time and uh pinning service i would use directly web free dot storage or nft storage they also pin the content on your behalf so it will be pinned five times redundantly and available for the filecoin deal for the filecoin network and it's also free to use yeah then thank you all and have an amazing hack [Applause] of [Music] so [Music] lovely it will be right here [Music] [Music] [Music] [Music] foreign [Music] foreign [Music] [Music] [Music] do [Music] [Music] so [Music] [Music] so [Music] [Music] [Music] [Music] [Music] do [Music] so [Music] [Music] um i will give this yeah um um um is is um um where it's amazing to see how people combine different projects different solutions thanks so much yes yeah just let me know can i use that instead yeah i prefer that yeah okay let's test this is yes yeah it's just okay yes do let's just this this this everyone how you doing my name is rohat i'm a developer advocate over at polygon um so i decided to do this workshop a little bit differently this is the only slide you will see that's it everything else is code is that cool i said screw it we don't need slides we just need code you guys are hackers you guys are developers this is what we're going to do so thank you for coming to my talk this is all about taking a web 2 browser game and turning it into a player in game we're into something real simple how many people have played rock paper scissors ever in your entire life all right so so you're aware of the mechanics of rock paper scissors cool awesome so let me just make sure my code is what i wanted to be okay so we got this rock paper scissors game here just a simple react application nothing big nothing's going on all right if you want me to hit rock please put up a rock scissors put up a peace sign uh paper put up a uh hand all right see two papers paper scissor rock it looks like all right looks like rock wins all right hit rock nobody wins come on guys all right one more time rock paper scissors paper paper paper scissors okay all right paper again or paper ah we lost okay whatever so nothing huge going on there right it's just it's a simple rock paper scissors game this is what the code looks like real quick i'll show you right now components i call this component web 2 game so it's just this gigantic switch case with a bunch of if statements you know if paper rock whatever somebody wins and i'm just like putting a bunch of things in state this is probably not an optimized version of this code very you know crappy version of it but it gets the point across right um we have a rock paper scissors game exists in the browser now what if we wanted to add some elements of you know web web 3 into this so i'm opening this up i call this the web 2.5 game called web 2.5 because all we're doing here we're slapping the web connect uh wallet connect function onto this nothing huge going on i have this uh handle wallet connect function you know pulling the ethereum object out of the window what does that mean as long as i've got a browser you know chrome extension like metamask or something like that i'll have the ethereum object i can pull that out the window as long as that all is good i am just doing a couple you know boilerplate stuff of taking the web3 provider from ethers requesting access to the user's account and getting their address so let's update that let's remove the web2 game from in here and add the web 2.5 game wrong thing okay come on doing this with one hand is like wrong thing okay cool so now we got this wallet connect right hit connect wallet great metamask pops up next connect wonderful all it took was two lines of code right now we slapped a wallet uh sign in with wallet can anyone tell me what's wrong with this just shout it out exactly it's not inclusive because not everyone uses metamask people have mobile wallets people have hardware wallets if i wanted to go beyond this and make sure that i'm actually being inclusive and you know bringing people in i think there was a workshop earlier on wallet connect definitely recommend using that instead but for the purposes of this i'm just kind of you know looking at one use case particularly for uh you know an injected wallet but we always want to make sure we're being as exclusive inclusive as possible to many different types of people so for now all i'm doing is just i'm saving this address in the state nothing big again just works the same still a web 2 game right how would i turn this into a web 3 game let's take a look at some smart contract code so this is a very very very simple um smart contract there's not a lot going on here um but just to kind of visualize what's going on um what i'm what i want to accomplish here is that i want to take this rock paper scissors game i want people to wager some amount of medic on the polygon network and um you know if they lose they draw they lose that medic and uh if they win they take the entire amount of matic that's in the pot for themselves right so a little bit of a gambling rock paper scissors implementation of a game right um so how does how does this work so i've got the contract the game i've got a you know a private string that is going to take care of who's the one who the winner is actually i don't think i'm using this but whatever um this u unsigned integer which is the balance which is going to keep track of how much money is actually in here i've got a few functions first is this receive money function is just to send some money over to the contract now i mean this public for one reason uh i just want to make sure that you know if at any point in time i decided to like put this smart contract onto the blockchain or whatever um i can load it up with money you know in case if i need somebody to load it up with money so like people can actually earn some stuff instead of like winning nothing you know so just making making that a little bit easier using this payable function uh solidity has uh payments baked in natively you don't need to import any other smart contracts anything everything is like accessible with this payable um modifier so all i'm doing is taking uh this balance up here this public balance and updating it with this message.value where do i get message.value from whenever somebody uses their wallet their um you know metamask or anything like that i can extract the value of whatever amount of money they've wagered or put in there and keep track of that value with this this message.value super useful to know in solidity now i'm doing this get balance function i this this might be redundant but just to like kind of give you an uh an idea of how something like this would work it's just a very plain kind of function tells you the current balance of you know the amount of money that's on this contract right nothing useful now now we get to the fun part this play function so literally all i'm doing i'm still allowing my front end to decide who the winner is you know and um you know if they won if that's true then i'm going to take the address of the person who is you know interacting with the contract so that is available through me again through this message object and announce the message.value message.sender which is going to give me the address of whoever is um you know interacting with this contract right now i'm going to take that and i'm just going to transfer some money to them whatever the current balance is and give them that money if they won they didn't win i'm just going to call the receive money function up here and they lose the matic that they wagered right so nothing nothing too uh over detailed um a couple things wrong with this um so this is one thing i learned from a talk uh i once listened to is when you're building um anything you're building a sas product you're building a smart contract whatever your first version of it it's probably not going to be the best version of it you just want to get something working right this works it it does in theory what you need it to do you can extract money from someone if they win you can give them some money um originally i was thinking about like doing the whole game engine on chain which would have taken me more than 20 minutes i didn't do it uh but so what what what i would would do if i wanted to make this completely unchained now in javascript i'm able to like go into an array and just like you know sort of randomly pick out some value like rock paper scissors for the opponent value in solidity you cannot uh do anything randomly you can do pseudo random you know numbers there's a different methods but there's no actual way to do truly random uh randomization or random number generation inside of solidity if you wanted to do that there are some um tools out there like chain link will give you a verifiably random kind of like generated number things like that but you know that has to happen off-chain somewhere you know so just to kind of emulate that as i just like you know what let's let javascript kind of handle that part but if you were to actually go into production with something like this and you want like real random number generation definitely recommend looking at chain link i do not work for chain link they did not endorse this at all i just like their product um i just want to make that clear so so we so we've got this let let's deploy this you know um i've got this here if i'm deploying from remix i go here compile looks like there's no problems i'm gonna copy this abi code real quick uh just put drop that in here it's abi.json why that's important i will talk about in just a second uh but that's that's there um and let's go ahead and deploy this injected web 3. uh cool this is my test matic i don't have this much mavic i wish i did but let's deploy this hit deploy my metamask pops up and we'll confirm this and uh this is being deployed onto the uh polygon mumbai network so it's one of our test networks for any time you want to you know test out your smart contracts um putting things out there how many people have uh just worked with solidity in general worked on the ethereum blockchain cool a bunch of you okay um doing things on the ethereum blockchain and on the polybond blockchain exactly the same every tool that you learn every um you know if you use hard hat foundry if you use uh truffle use a remix all of that maps one to one it just takes one line of usually one line of like configuration if you're using hard hat or truffle or something like that all you do is just like change the rpc endpoint from like you know the ethereum endpoint over to a polygon mumbai network or polygon main net if that's what you want but you know at the end of the day everything is evm compatible everything you learned stays the same and again just maps one to one that's why it's like we've been really focusing on a good developer experience we don't want you to learn anything new just to use another blockchain everything maps one to one you'll also so this this is specifically um using our proof of stake blockchain which many people know as a side chain that is not the only product that we have out today in a few a few other days we actually launched a few other things like polygon edge there's a lot of work that the hermes team is doing as well and there's a whole suite of products that you can use to like build on top of ethereum uh but yeah today we're just focusing on our proof of stake blockchain so that is out let me see where that is okay it's that in here contract deployment let's view on block explorer so this is a tesla transaction great it was a success you know everything's everything looks good um let's let's actually look at take a look at this deployed contract so these are some of the functionalities that i could just like test you know before i actually put it into my front end but um hit balance right now says zero right so let's so i made that remember made that receive money um you know public just so i can put some money in here um let's go ahead and put three matic in here so um if you've if you've done any sort of deployment or work on solidity before you'll know that like the smallest um unit inside of solidity as we're in reference to ether is whey works the same way on polygon blockchain smallest unit of matic is also away which is like 1 to the 18 0 power or something like that so 3matic that converts over to this much way let's copy that value and drop it in here okay so let me just do three one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen six and seven eighteen okay that's good enough okay so let's hit receive money awesome i'm putting three three matic onto this contract confirm and you'll see like gas fees are like very negligible confirm that's pending let's actually go ahead and look at this contract itself how do i get to the contract there it is contract so this is the deployed contract on polygon scan right now deployed about three minutes ago let's just make sure this went through looks like it was successful i'm gonna hit balance yep three um to the 18th power way a little bit small hard to see but um hopefully it gets the point across right um there's three matic inside of this contract yeah there it is three matic cool so now we've confirmed that on this contract there's three matic that somebody could potentially win if they win this rock paper scissors game let's see how we put that into our front end so there's going to be a full stack application built with the polygon black chain in like five minutes guys so we go over to this web3 game.js that i have here uh that uses this other component called soliditygameengine.js i'm very bad at naming things which i'm sure the rest of you are too we're all developers right um so have this how do i actually go and interact with this contract right so i have this old contract here let me just delete that delete that and copy this contract address just so making sure you know we're going to that same contract remember um i saved some api code from before i'm importing that from api what is the api what does this do uh traditionally in web2 development i guess for lack of better terms uh the way you would interact with an api would be through like an http request fetch axios something like that right when you're interacting with the blockchain from a front end like react rather than doing something like you know using a fetch request this api code this gigantic json file essentially acts like a map for javascript to like parse through and understand how to interact with the blockchain so this abi code corresponds to uh the compiled byte code from solidity so in order for the ethereum virtual machine to actually read your smart smart contract data that is all compiled to bytecode which is like a machine code and that is the actual code that is deployed onto the blockchain not your syllogic code your solidity code is at a very high level it needs to be compiled down so this json file is just a map it just it just tells javascript okay this is a function i can use this is some sort of state this is some sort of input that a function needs etc right and you'll notice in here there's like inputs to find balance to get the balance um etc you know all the stuff that we wrote in this like nice mapped out format so that's that's cool that's great so now we come back to our solidity game engine again i'm bringing in the ethers library once i have the ethers library in here again just some boilerplate code of just like making sure i'm connected to the contract uh the contract um to connection requires the contract address which is what i had before it requires the api and it requires the signer the signer is simply just again that address that we had before now now i need to make an actual transaction right the transaction with the blockchain to either you know check if this person is the winner or not so i've hardcoded this to just always be one matic we're just always going to be one matic just keep it simple for the purposes of this you know demonstration and i have this piece of state up here player is winner my default is set to false and down here again with my very very poorly written rock paper scissors game uh what what i'm doing here is you know i'm setting if i set the winner to be the opponent i'm setting players to false transacting the game etc and if you win if winning is true then transacting game will you know update to be true so you either win somatic or you lose some medic so now let's go ahead and update the game we're moving on from web 2.5 and let's do web3 okay so i've got my react up let's hit connect wallet all right all right now i want to win some matic so you're gonna need to help me rock paper scissors let's go always rock all right he said it first though so i'm i'mma go with rock all right so this is on you if i lose money though all right so let's hit rock no you lost me some money all right so hit confirm um you know we just lost one matic this is fine exactly yes you could do that you know oh [Laughter] you know if we were um you know doing making sure that this like actually worked properly we'd we'd do that on chain you know um which in this case you would reach for a tool like chain link or something like that to do like the random number generation here we're just you know trusting our players to do the right thing all right let's play again uh let's try to try to win this time oh crap okay rock paper scissors anyone okay he did say it first all right we're doing a rock again yes all right so i'm going to hit confirm um i had 494 meter right it's pending see if this works do i speed it up no yeah that's test nightmaric yeah okay cool it updated i won some money so cool that's a very very basic implementation of you know play to earn mechanics uh set to a browser game right started off with a simple rock paper scissors game we connected everything to a smart contract um you know it's not the the most you know complex application but um it's really just to give you an idea of like how you can start incorporating these plate iron mechanics this is just like a simple kind of like gambling rock paper scissors game but you know this is kind of the basis of like what games like x infinity you know defy kingdoms are kind of like built on you take the little fundamentals and building blocks put these together make it a little bit more complex you know test your code unlike me um and always test your code and you know put that onto the blockchain and you've got to play to earn game um you know play to earn is something that is getting pretty big you know right now um it's all the rage all you know all the vc funding is trying to find its way into later and all that so you know if that's something i'm pretty sure it's one of the tracks as well for polygon so if you want to you know win some money from us something you could build um cool i'd like to you know open this up to questions um any questions about the code any questions about any implementation polygon in general um love to open it up to you guys anything you have questions uh can we get mike yeah i think he's gonna give the mic great thank you uh question was is this code open source or anywhere can i look at this uh maybe i want to build something similar yep so this will be open source uh by later tonight um so i will just post this up again uh you can follow me on twitter hot codes i will tweet this out um but i will also put this in the discord for in like the polygon sponsor channel as well so both places by later tonight we'll have that up there yeah so uh i'm i'm somewhat new to polygon um i think basically how it works right it's like layer two and then uh all the like the transactions get get put into blockchain like in a bunch that's why they have that's how they can have like fast transactions and stuff right yes so we're um so this specific implementation is using our polygon uh proof of stake slide chain um so rather than doing like proof of work computations which is going to take more computing power it's going to take a little bit more time to do proof of stake algorithms allow for much quicker transactions so a lot of that is built on you know that side of things to get you that you know like better ux so um i mean polygon offers uh pretty cheap cheap fees and fast transactions yep so does uh solana what's like the trade-offs um i couldn't intelligently speak about solana so i i i will say you know if you know if you're already used to building on top of ethereum building on top of like anything evm um the advantage here might be like you don't have to learn anything new like with solana you have to pick up rust to you know build smart contracts so if you already know solidity if you've already been you know developing on an evm blockchain um you know just for for developer experience you know i go with polygon yeah um how like do you know if uh if polygon are going to be affected by the merge like any anything like yeah i think um we're actually very happy about the merge um while we're you know this the proof of stake blockchain will still be a thing uh will still be available there's a whole suite of like kind of products that we're building and putting out you know a combination of like zk roll-ups optimistic roll-ups as well as just like different tools for just like building on top of ethereum our whole thing is just like making ethereum scalable um so you know whatever ethereum does to make that easier for us is just even better you know um this this implementation of like putting this on the polygon proof of stake blockchain is just like one way you can interact with the polygon ecosystem at large this is only one of our products so you know maybe there's a future where you know our other tools would be more popular because post merge is probably you know stuff that you'd want to use anyone else do you have a question no um trying to think it's about about solar never is a tool favorable game that exists that's called the gen coin flip and what it is it's like you bet an amount at what you want and if you lose you lose this amount and if you win you double your amount you are winning with a small fee that this uh countries contract in solar is keeping for themselves right yeah yeah so it exists for solar and something like this yeah i mean i've already implemented it but i don't know if this contract is open on it yeah i mean this is um sort of like a very similar implementation you know it's your you know you're wagering some money um i could add some more to like add some fees if i wanted you know on top of that as well um i can code that into like the balance and things like that um but you know this is going to be more like a basic sort of like you know implementation but um i i don't think you need much to add very much more code on top of this to actually get you know to the end to you know what you were describing there um the basic functionalities there you know wagering sending money things like that um probably just be like doing a few things like you know keeping track of fees and things like that but what they have on top is like uh an nft collection that's the revenue from the from the from the percentage where they are keeping it goes to the nfts the wallets of the nfts nice yes yeah yeah i mean those those are definitely different functionalities you can add on top of stuff like that that's awesome i mean you know for this that's really for the proof of state blockchain cheap and fast um but our other you know solutions would also like you know leverage the ethereum security um level of security that we have there um so yeah um i think we're are we out of time yeah so yeah i mean the selling points for the proof of stake blockchain is there but um you know if you want to leverage the full security of ethereum and everything like that you would reach for something like zika roll-ups optimistic roll-ups some of those other products so it depends on your use case for what you need thank you for you know coming by to this workshop really appreciate y'all thank you for the questions and yeah i will post the code later on tonight thank you [Applause] so so [Music] [Music] do do do [Music] do [Music] [Music] [Music] do so [Music] [Music] [Music] [Music] [Music] [Music] do [Music] [Music] [Music] [Music] do so [Music] [Music] do [Music] [Music] do do [Music] [Music] [Music] [Music] do [Music] do [Music] do do [Music] do do do [Music] [Music] [Music] do do so foreign [Music] [Music] is yes okay it will be at the end of the turn nice yes yeah of course nice yes okay do you want to keep this mic here guys okay yes no okay okay what is not working okay we'll set the full screen huh do huh so oh so welcome everybody for coming to this talk we are talking about uh baby three my name is tabit this is my player michael yeah we are going to learn more about the other protocol a new feature of 53 yeah first of all what is basically is a decentralized protocol a liquidity market that allows users to supply cryptocurrency provides liquidity to the protocol and had some gel about it it is also a other reactor that is the borrowers that can draw liquidity from the protocol ua but putting a collateral first they can use the collateral in a supportive market like ether die and also there is a another actor is the regulators that take care of their healthy making their people healthy they basically litigate positions basically paying back the death of borrowers that have risky positions or they are near under quality city um well they will adjust the ibv3 like one month ago it has received a lot of uh well it was well said by the community and basically we got the branch market that is now with around four billions of liquidity located at the protocol and by the using liquidity incentives by the avalanche project and also we have the outer markets that are with a with a liberty around between 5 million and 40 millions with organic growth with the projects in six networks see different networks and yeah we also have more markets like the ama market and now miguel will talk about the the new features about of of hawaii iii um thanks david so yeah the third iteration of the other protocol builds upon the foundational elements of the abbe protocol which are instant liquidity the a tokens different interest rate strategies and so on and so forth when with new groundbreaking features that expands from the increased capital efficiency to unenhanced decentralization so yeah let's dig into the some of the new features of this third iteration of the protocol first in terms of capital efficiency we have portals so yeah given the fact that we live in a multi-chain a multi-role world having a way to migrate tokens from one chain to another in a seamless way is more and more important these days while the previous iteration of the protocol the version 2 was deployed on multiple networks with meaningful tbl is true that there was no way to have all the supply assets flowing seamlessly from between chains so this is the point of portals portals is a new feature of the core contracts of the version 3 of the protocol that allows to allows the supply assets to flow seamlessly between chains so in high level it leverages the unique design of the a tokens so wireless that bridges are able to take a tokens from the users in one chain and bin amind those a tokens into another chain so first we will need breaches that plug into the portals this kind of bridges will be named as ports once they are kind of registered in the system they will need to to call a couple of functions new functions that are in the in the in the pull contract these functions are mint and backed and backed and backed the first one allows the bridge to mint and backed a tokens which means that these all these a tokens don't have the underlying assets with them and then they will need to use the the other function which is called back and back which allows to back those a tokens that were already already minted so portals essentially allows these bridges to supply assets in other firm manner so when a user wants to move their ia tokens from the source network to the destination network first the bridges will take the tokens from the user in the in the source network then instantly mint brand new a tokens in the destination network and redirect it to the user and once the underlying assets the real liquidity has been moved through the bridge could be the canonical bridge of the chain or whatever bridge in the in the ecosystem uh then they will be able to back those already fresh new minted a tokens with the underlying so at the end the destination network will have all the a tokens with the corresponding underlying assets so as you can imagine this feature is really interesting because it allows the users to move the eight tokens from one chain to another without losing a penny of a dollar and without the need of and winning the position which is really really cool also the efficiency mode this tries to increase the the utilization of the capital that is sitting in the in the protocol because as you already know there is a lot of assets and capitals that are are currently sitting even in the protocol so this is mainly cause because the the risk parameters there is parameters in the system there is one of the risk parameters in the system which is called the collateral factor the collateral factor determines how much of an asset a user can borrow using an asset as collateral so having a 75 collateral factor on die means that a user can borrow up to 75 die with 100 dies collateral so if the protocol is able to increase this collateral factor they will be able to increase the borrowing power of the users and thus increase the capital efficiency of the protocol which is really good so as you can imagine it's not so deep on the the the collateral factor of the assets in the previous iterations of the protocol were a bit conservative because all the assets has its own characteristics its nature and even price different price volatility so as you can imagine it's not the same having a user borrowing usbc against if than having the user borrowing usbc against die the later position is less risky for the user and also for the protocol so this is because mainly because both assets are stable coins and also because those prices are those assets are correlated in price so that's the main point of the efficiency mode what if we are able to group the assets in categories with the same characteristics same nature or the same price volatility so is we can increase the borrowing power of the users in that cases so in the protocol v3 there are high efficiency modes categories we have the stablecoins category with usdc dye usdt or even the the europeans also we could have um btc variants or it is if variants and let's see what's that's coming from the community in the future it's going to be interesting so when a user enters e-mode in one of these categories let's say for example stable coins the user will be able to enjoy a hybrid wind power using stable coins as collateral but they will only be able to borrow stable coins so they still can supply other assets and even use them as collateral but only with stable coins they will only be able to maximize their borrowing power so right now users in a stable con emote they enjoys a 97 percent of collateral factor which is really good because they can borrow up to 97 die with 100 dioscollatera so these features will bring a wave of new use cases and new tools in the ecosystem like for example high yield high gel farming strategies high leverage tokenized positions and also diversify risk market risk because you now can split your assets in in categories so yeah it's going to be nice now more on the risk and security side first we have the supply and borrow caps this security measure is pretty intuitive because this security measure allows the community to set hard caps on the supply on the amount of the supply assets and the borrowing assets so in this way the protocol can control and modulate the exposure to certain assets in some way supply and borrow caps together with isolation mode is a good combination and interesting combination to modulate the exposure as i said but also to list assets in a more secure way so until now usage assets when are listed in the protocol allows the users to use that assets as collateral and borrow any kind of assets in the protocol so theoretically we could have we could have a user borrowing the whole capital of the of the market using one single asset as collateral which is far from ideal because that would mean that the protocol is completely exposed to that certain asset so isolation mode which is inspired by the maker dao i don't know if you know it but in maker dial you have different balls and you can on these balls has some a particular asset for each and they also have the adapt ceiling so you cannot mean more than the filling using that specific bolt and that is specific collateral so installation mode works in a pretty similar way users in in the community can list assets in isolation mode and users using this asset as collateral which is isolated they only will be able to borrow up to a certain limit of assets so for example in this case we have the token 2 which is listed in isolation mode with a dev ceiling of 10 million and that would mean that users can use that that token too as collateral but only they will only be able to borrow up to 10 million dollars worth of assets in stable coins so as i said this is an interesting way to moderate exposure and also list assets in a in a more secure way and yeah all of you can imagine having a new asset into the protocol first listed as in installation mode then keep on going with supply and borrow caps finally maybe without any other security measures at all which is good also the price oracle sentinel yeah this oracle is uh is really specific for layer 2s because and gives increases the experience of the users in those in those networks and this price oracle sentinel allows to handle eventual downtime of the sequencer as you may already know the sequencer are the entities that are in charge of submitting and settling transactions in the network so if the sequencer goes down then the network essentially stops working so during this downtime we could have price variations and these price variations could affect the users positions in some way so if when the sequencer goes up and the network starts working again these users could have these positions affected since all the price variations come into play at once so in order to mitigate this scenario the protocol introduces a grease period which is a duration of time that the users are able to fix their positions in order to don't get liquidated in some way yeah the centralization in the third version of the protocol there were also some improvements in terms of the centralization and in the previous iteration we already have some a permissioning system where [Music] all the rules were specified with their responsibilities but in this version this permission system is more fine-grained and more sophisticated and also there are some new roles in the system that brings new ways of doing things let's say so we have the risk admins and also the listing asset admins there is the risk admins is a specific role of the system that has the ability to change the risk parameters of the reserves without the need of a governance boat these risk audience could be daos or any other entity or even automated agents that react to a specific events or metrics and change the risk parameters accordingly they can change the risk parameters or also the interest rate strategies of the research as well and also we could have the we have the listing admins which are which has the ability to list assets without the need of going to a governance proposal which is also interesting because we could have some new strategies of listing assets and this is a kind of a way of delegating the governance of the community of the protocol to some other entity out there so one of the discussions that have been in the in the community forum is the the permissionless listing so what if the a community of users are able to decide which asset which asset they want to list so they can stake some a part of this of these assets in the protocol and use this this assets as a backstop in case that is that something happens so yeah really cool also as you can imagine there is a bunch of new features in this uh third iteration of the of the protocol some of them are more user-facing features some of them are more in the technical side but yeah for example it's good to mention the repayment with eight tokens so now this increases also the experience of the users as you can imagine and users now are able to repay the the their debt with eight tokens so they need so if a user has a debt of 100 usc they can provide usdc to repay the debt this as i said increases the user experience but also helps the protocol just in case the underlying assets gets locked in the other pool contracts for for some for some reason also the there are the intro there is the introduction of the permit function and the eip712 to the credit delegation function and also the introduction of a simplified version of the flashlight function with a reduction of 20 percent of gas costs this is only in the case that the user wants to to flash along one asset instead of an of a set of assets and yeah there is many many more but in general the code was reorganized and also optimized so there has been a reduction of 10 or 15 percent of gas consumption across the world across the world so which is really nice um yeah that's pretty much all right yeah we created some tools to help you to build on top of ave this one is the same box that is tools allows you to to integrate or to fork a network that has a b3d project with a simple command and it spins a hard cut node to the cell market it's also it also allows you to faucet the the assets that are listed in that market within an easy way and also it allows you to connect the diabetes open source frontend to this local sandbox or this local hardhand loan yeah in this way integrators can wield safely at the top of markets in production a local localhost that is much faster to develop the only independence that you need is a node.js you can find the the repo the qr code and also github.com yeah we also have some npm packages with a smart contracts and also some utilities some helper factors that helped you to develop a new front-end front-end for away or different dashboards that you need the auditors contained all the helpers to interact with the protocol and also contains all the math related with the with the with the protocols so it's quite nice you don't need to rebuild the wheels well as always you can check the code the different repositories um yeah right now here at the hackathon we have the the prices and yeah we are working for the most innovative integration yeah you can see the list of the devices um yeah it's it's on some resources like the developer docs so they're quite complete and it contains all the definitions all the contacts link you can request for proposals maybe you have an interesting idea to build on top of a community member and here you can request a grant to develop that tv and execute that idea here next sunday we have so yeah here is a bonus code that you can use is hosted by the vegan style and that's it if you have more questions feel free to ask us okay so that's it thanks everyone for coming as you have one question okay of course the sense that when you deploy a new version of a you know central of that uh might be introduced like security risks so is that the case with this deployment or uh was more like an overall yeah so i'm wondering if uh exploring a new version of the protocol introduces security risks yeah i mean like any other protocol if you deploy any version you need to take into account how the upgrade is gonna be of course if you are using some kind of proxy pattern like avidas you need to take into account the storage layout and you know keeping things retro-compatible maybe wherever so you need to take also things into account in in that way yeah sure are running at the same time yeah now they are running at the same time there is also some discussions in the forum to upgrade the contracts of the b2 market to b3 and that's going to be a challenge that's going to be a real challenge because yeah exactly so it needs to be backwards compatible also take into account all the functions all the storage slide out and this kind of things so yeah any more questions nice guys thank you so much for coming reach us out if you want to talk about ave or any hackathon idea or just about ibb3 or what's going on on other companies thanks for coming [Applause] many thank you that's something so yes so so honeydew so so um okay is so users [Music] so so i know so uh [Music] so so [Music] [Music] do do do do do [Music] do [Music] [Music] [Music] do do do do do sure do three test do [Music] do do yeah no problem hello hello everyone my name is nick i'm from one inch network and today i want to talk a bit about our api and our limit orders api as well so let's start from one inch i just want to repeat a bit what we are doing and what is our value proposition so basically uh vanity is a dex aggregator so we aggregate multiple daxes when we want to swap a coil into other coin so we have much more liquidity than any other decks and also we have algorithm called pathfinder so actually we build specific uh the app that allows you to swap quite any other coin based on the path that we calculated and it's pretty good path so you get much more coins return amount than using any other decks or any other decks or a dexagreater the aggregator as well it's like a small example uh for example let's i have for example i want to swap 500k ethereum to die we see a lot of money thus it's just a demo so basically you can see the path here so we just allow you to it's just one transaction so you can swap through multiple pools in multiple decks and all of that will be atomic and the return amount will be the largest one compared to guinness fab for example and basically the also thing is that you can access our api that allows you to integrate all the liquidity of our decks to your app it's available via document our documentation i already opened this one and i just want to show you one of the most more important two quotes that you need to handles that you need to use if you want to integrate a like just a router api uh the first quote the first is called quote you can see uh that there is a network chain id here you can pass any chain id that we support right now we support multiple networks uh all of them are supported right now and we are working on all other ibm chains right now as well um so basically the first the first handle is quote uh this head allows you to just find the best vote for the specific pair of coins and for the specific amounts so it's more for preview for your wallet for example to show the code for user and let's dive into some specific uh query params here um the most important one and the most there are only three params that you require to pass here so it's just uh from token address it can be any token error c20 token and also you need to talk an address as well uh you can pass any any of it but you need to pay attention that some of them can be not so don't have so much liquidity than other one so just just keep it in mind and also you need uh from amount as well you need to pass from a row from a mount as well to this handle and basically it will work uh let's let's just try to pass default params so that's the response like from one from ethereum to one inch so you can see uh two token amount from takitana amount and also you can see the protocols that we are using for this swap and also estimated gas that you need for this transaction in future let's talk more about additional quality perhaps that we have uh its protocols uh basically there are about 70 protocols uh on ethereum chain and if you want to specify specific uh daxes that you need for swap sometimes it's very useful you can just pass them via this handle by default we support all of them another param is fee we support referral fee so you need to pass its percents few percents that will be returned to the referral address uh of the wallet of the of the provider referral so it can be from zero to three percent and by default it's zero um also we have a gas limit i think it's pretty pretty obvious what is it and actually depends on the gas limit we can be we can we can have different roads uh optimizing for low gas limits for example if you user don't have enough ethereum or native coin for swap also we have uh connector tokens per am basically uh if by default we have our own list of connector tokens is the most liquid tokens on the market right now but in some cases uh connected tokens is tokens like this one during the road path for example during swapping ethereum to die my conductor tokens are usdt and usdc here uh so basically uh we're trying to handle it on our own but in some cases um when we are talking about specific coins with smaller liquidity it's much more better to provide specific connector tokens for specific pools so you can have much more better return amount the maximum maximum amount of it is five and also we have complexity level complexity level for the path uh basically let's talk about example here current complexity level here is just two so the swap goes through usdc to die and after that it goes to the so it goes to the die yeah um it it can be up to free uh it also you need to pay attention that depends on the complexity level uh the gas will be much more high with the higher complexity level if you pass zero it will be just direct swap through specific pool let's talk about main road parts and the parts params so it's much more easier to explain it on the picture so basically uh parts it's uh this stuff it's uh usdc for example usdt part and dipart and it's minor parts and parts it's uh parts inside the main part for example here it's sushi swap units for part by percentage so you can pass all of these params for api sometimes it's very important to pass specific amount of them for the optimism for the gas optimization for example and also gas price is pretty obvious but if you want to estimate your transaction with another gas price you can pass it and you will build a road basing on this on the gas price that you need but i recommend to use fast so uh let's continue with swap so for example firstly you show user your return amount for the specific token and right now you need to swap to implement a swap for this user uh basically when you will execute swap handle you will get not you will get not only the price you will get the call data that you need to pass to your transaction for the one inch router and so user can execute it and make a swap um basically we have a bit more required parameters here let's talk about additional ones that we can see here uh the first one is from address amount token address and from back in address are pretty the same as for quote so from address is the the address of the user who will be calling the advantage contract sometimes it can be another contract and there are additional things that you need to pay attention when you are using another another contract for the one inch swap it's all it's also possible but just pay some additional attention about it and one of the most important params is slippage it's also like percentage of amount of the price how much it can be dropped uh it's important to pay attention that on the most liquid part mostly to liquid coins you don't need to put very high slippage parameter but sometimes if you will pass very small slippage parameter as well transaction can be failed uh so sometimes uh the best this will be like something like one percent a user also can pick uh this parameter so basically it's important to give give user an option to change slippers for him but pay attention how users change changes during the swap also we have protocols which are the same also we have destination receiver so basically you can swap coins and get another destination receiver address for swapping we also have a reference address it's very important to pay attention about this when you are providing fee must be the same fee percent as for as product quote so if you have a referral address you can create this one you will get an additional profit from positive slippage during the swap if user will have positive slippages actually so also we have one interesting parameter it's called disable estimate it's very important to use it when you are trying to build something with another contract on one each when the when the router will will be called through another contract sometimes it's useful to say to pass disable estimate true so we will not check the that trend that transaction can be executed right now so you can change it a bit later and run it a bit later if you need it we also support permit so if you're talking uh if the token supports e2 2612 you can use permit signature and pass it here so it will be instant swap if during one transaction with alone we've approved um i also want to talk about allow partial field parameter sometimes during swaps some of the paths are outdated and the rate will can be changed dramatically but there are some cases when you want to swap at with this rate at least some per amount that you have for example in this case let it be like 60 of the path will be successful and 30 of this path will be unsuccessful it will be the prices will be up they outdated but you still want to get a t until at least 60 percent with the rate that you have right now uh in this case you can turn allow partial field uh to to true and after that we finish vanished rotor will roll transaction in that way that the transaction can be filled just partially so uh all other options all other queries we already discussed uh before in other another handle um so we also have much more information about how to integrate vanish api to the your app so i definitely recommend you to take a look at our documentation and also i want to add something about our limit orders basically vanish supports not only swap direct swaps instant direct swaps but allows you to use limit orders the main difference here is that limit order is not executed instantly we don't have we don't support black market sell but it's pretty the same vibe and pretty the same logic as uh classical limit order so you can specify specify the speed the price and the rate for the tokens that you need do you want to sell and you also can set up expiration for your order and the most awesome about it is that actually you will not pay for the gas for this transaction uh you will be their transaction will be filled automatically and the market taker will pay for the gas so for users it's free and for market takers it's uh actually not free that's how it works also actually when you make creating creating a order you don't pay for gas because we don't send this order structure to the smart contract it's just stored on the layer like another layer another network and anyone can get this order we just need to sign it so when you send you can actually execute this order via smart contract and fill an amount on a taker site that's the point how it works so because of that actually um anyone anyone can execute it at any time if it's okay for this person to pay for the gas and uh that the person is okay with the return amount that person will get we also have a lot of additional features of a limit order that i want to share basically one inch limit order is not only limit order you can build a lot of additional logic over it there are three main points firstly it's conditional conditional execution for example you you can specify additional params and it's called pyramid uh and for example sometimes it's very important it's okay for you to swap because some oracle price of the another asset is uh like is okay for you and sometimes oracle price of this asset is not okay for you and depends on the price you are okay with swap with executing this folder or not so basically you can add additional params uh for your order uh so the price will be changing and the order will be valid or valid during time a default example is expiration you could pass you can add expiration uh for your order and if you're okay that it will be executed like in 10 years or like in 10 seconds only you could make it on limit order very fast also we have uh like arbitrary price discovery i will tell a bit more about it when i will show you the structure of limit order and also we have a custom callback during execution it's very awesome thing uh for example uh you can we use this function before fonts will be transferred to the taker address and during this fallback you can implement for example you can for example farm tokens on some protocol before during creating payment order for the maker and after the moment when order will be filled um you can actually use these tokens and claim them and stake them from the farming pool and use them in agreement order as a liquidity yeah so let's take a look at the order structure so i just want to pay attention to some specific params most of them are pretty obvious the most important that i want to start is predicate it's like the third one on the last predicate actually allows you to it's a structure that allows you to set up some rules for your order as i already said for example expiration time we also support permit by default on the v2 limit orders so you can just make gusless you don't need to approve token for the one inch limit order contract by separate transaction if you if this token supports permits we also have interaction interaction is a function that allows you is it you need to pass data here that will be called before transfer from a function that will be called during uh other execution uh so let's talk more about uh order execution um if you want to execute order you need to like actually use a field order function um so basically uh most important is about is signal share and you also need to verify that this order is correct and it's to estimate it before executing it on the smart contract also i want to talk about predicates right now a bit more we have basic predicates on vanish on financial limit order that you can combine between each other for example you can add multiple params during using function add we use by default some of these functions some of this predicates for example we use nons one important thing about nons is that each time user create a transaction in you you create a limit order we use nons because for example if user wants to cancel all limit orders instantly you can just adjust nons on his account on user account and after that all limit orders that have nons less than current nons will be invalidated so let's talk more about get maker and can taker amount basically get maker can take your amount it's a functions that give you a rate for swap for the order and you can the was this awesome that you can actually build uh your additional functions you know your this interface implement this interface on a data smart contract and use these functions to have more adjustable price during your limit order execution for example depends how much it will be swapped you can actually use any formula for it it's very important it can be useful for nft for example uh so actually using our limit orders you can build nfc market and it's just like small example how this make get maker amount get they care about functions uh i implemented by default and how they are called so i also want to add a bit more about how they are called on our smart contract basically just arbitrary static call uh it's so it's secured let's talk a bit more about maker address uh sometimes you want to use additional smart contract as a maker address so like a smart contract is a creator of this order of this order and if you are using smart contract address as a maker address you need to implement additional function it's called israelite signature and this signature is this function is called before on the check when we fill other there are two parameters here it's orders limit order hash and also a field called signature but basically it can be any data that you need to validate this order on your smart on the smart contract site so just don't think about it about this as signature only signature can be any data and let's talk about it interaction it's a final function that's called before transfer from during limit order execution and it's that's how actually you can implement this function so you just need to implement function called notify field order and with these parameters that you can see here it's a message center basic parameters actually message sender make your asset taker asset making the amount and also interaction data and actually interaction data can be any data so that you can so you need just to parse this data on your own contract and specify like the length of this data so it can be any data that you need for your logic you can know a bit more about uh limit orders as well we have a good documentation and we also all this stuff is open sourced uh it's open on the github so it we are happy to answer all your questions and i hope that you get a bit more information about our api and limit order thank you if you have you will have any questions i will be nearby uh also you can come to one inch stands uh we'll we'll try to be there all the time um you can also contact us on the telegram or ask for ethereum global team if you have any questions as well bye so so few uh so um so um yes so um um so thank you very much you 