hi there that's nice and loud wake up how many people are actually just here working for change safe and alright great well then I will be speaking directly to this camera instead of everyone in the room but thanks for being here to be the body's in the foreground so hi my name is Billy I'm gonna be talking about IBC and FTS and the cosmos SDK do you like acronyms this is the place to be I'm gonna begin with a little bit of the evolution of blockchain which I hope you're all familiar with if you ever had the unpleasurable something in early days basically the only option was forking Bitcoin you could basically tweak some of the parameters but not really do a lot else because the code base is so difficult to use and this sort of birth the first wave of coins like coin kind of being a star player there next we had the birth of the amazing etherion virtual machine you were able to actually deploy your application logic to a turing-complete computation space instead of having to ploy your own blockchain yourself if you're into core of the security thanks to the lovely IRC 20 we had the second wave of Czech coins so cosmos sort of proposes a third architecture which in a way goes back to the first one let us take care of the really difficult parts of building a blockchain consensus algorithms and networking so you can focus on the part they actually care about which is the application model we hope to foster the third great wave of chip coins how do we do this one of the ways you do this is by implementing tender mint which is kind of the golden standard of proof of stake its business tune fault-tolerant it's well tested battle-tested it's securing over five billion dollars worth of coins at this point but we kind of want you to not have to worry about it the second thing is IBC so one of the great benefits of working with the theorem is that you have this shared state you can have this composability these sort of building blocks of defy and all the sorts of stuff your code is running right here but it can reach over and access and do something this other code which maybe does something else this is really lovely and if you're building application-specific blockchains you're sort of locked into your own zone you can do exactly what you want to but within your own space so how do you get the benefit of all of this composability you have IBC IBC is essentially a blockchain version of tcp/ip in which you're sending transactions from one blockchain to another blockchain with proof that it really came from that blockchain and the recipient blockchain can either ignore it or it can say oh yeah I was maybe expecting a call from this other one I'm gonna let it do something like transfer tokens or trigger some function inside of it why would you want an application-specific blockchain well I mentioned briefly but one of the reasons is specialization so instead of trying to cram every single functionality into a tool which will no longer fit into your pocket you might just have a toenail clipper meant for horses it does one thing and it does one thing very well you're also self sovereign so you don't have a bunch of neighbors who are all complying about what your blockchain is doing and they wanted to do something else you can think of for example what happened with the Dow when you have a bunch of users like oh my blockchain didn't do what I wanted it to do do it I mean not what I say you have a bunch of other users are like no code is law that's the whole point of this thing they couldn't come to an agreement and so there was a fork and if your blockchain is only doing a very one specific thing it's it's much more likely that you're your user base your entire network security is going to agree on exactly what it should be doing and how it should be doing so you have the ability to kind of control those upgrades and and make those upgrades more attune to exactly for what it's being used for instead of trying to appease a massive number of people at the same time so if all works out we hope to see something like a Internet of blockchains where you have theory I'm over here doing sort of composability shared state maybe defy all sorts of great things at aetherium is great you have Bitcoin doing it's orange coin thing you have finance chain you have the Aragon chain which is recently announced you could maybe you have the cryptokeys chain or polkadot or tezo's all using IBC to be able to send transactions between each other and talk to each other this sort of opens up a lot more specifc use cases of block chains and I think it really mimics the way the internet works you know we don't all use one big computer we use a bunch of different computers who have their own choices about operating systems their own choices about code their own choices about resources and they use CCP to talk to each other underneath specific conditions so the way we hope to make this really easiest by building a developer kit called the cosmos SDK I mentioned early it sort of takes care of the hard part the networking and consensus so that you can focus on the app it's modular modules can kind of be thought of like contracts inside of the theorem way of thinking each module would have kind of tightly coupled logic and storage modules might interact with each other this a might contract might interact with each other and they can be reused across chains so similar to the open zeppelin libraries you know you'd be able to instantiate modules on your chain that somebody else uses to avoid having to do everything from scratch each module has messages so instead of having function calls like an solidity you can think of them as messages which change state there's also queries which read state but just terminology wise messages are included in transactions they modify state and they kind of get routed to different modules and they get routed via these handlers so when a module receives a message it gets handled the handler is where you have some sort of like logic if you're familiar with react and view you have like these reducers and actions and things like this this is where all the sort of logic takes place in the action part and you have the keeper where the state is actually managed and that's the sort of reducer or the mutation like and reactor view these also contain getters and setters so that you're going to be able to read information out of it same way you do with the query er and shared state can take place across modules so if I have an NF t module but I also have a defy module I can read certain aspects of NF T's and modify them etc the general flow is messages handlers keepers this is sort of if you're gonna be dealing with the SDK great to know here's some examples of some message types regarding NF T's so instead of having transfer function you'd have a transfer message type sender recipient denomination ID edit mint burn they get handled so it's basically just a big switch statement it points it to the function that needs to actually handle it here's that handler up close the mint and you can see that it modifies this K keeper object and that's where the state actually gets modified here you can see that there's some sanity checks making sure that it hasn't been minted before but this is a module that already exists so if you wanted to use NF T's and use those basic functionalities you could just import this use it the same way as open Zeppelin has NF T's enabled and inside of the handler is where you might want to modify and add your own sort of logic the same way with open Zeppelin's you would maybe rewrite the transfer function and say it can only be transferred so many blocks or I don't know whatever your app does so we're kind of hoping again for this internet blockchain in the big missing piece is IB C so I just quickly want to point D components of I BC are these packets so first there's a little dance of handshakes between two different chains and once that's been established there's a channel and each channel has different ports and those ports basically route different types of messages so here's a packet for transferring a 10ft and depending on whether or not you're sending that packet or receiving that packet different things are gonna happen you can imagine if you're sending it you're going to lock up that NFT and put it into an escrow account basically an imaginary person account they hold it there and the only way that they're gonna let go of it is if they receive a corresponding IBC message the other way around which is okay this nft went over and to the larger ecosystem maybe it was on a NFT marketplace chain maybe it was used as collateral inside some other thing eventually it's coming back to the origin chain and it gets unlocked from that escrow account you can imagine on the other side of that you're the recipient say you're by Nance chain you receive this IBC message it says some chain exists you either know what it is already or you just at least know it by a channel ID because you've had some handshake between this entity it says there's an entity on the other side you believe it because there's a proof that at least that chain exists so the user gets to decide does this chain exist do I care about this chain is this just a spam chain or is this chain actually the  achates chain the standard in the protocol or agnostic Tyvek they don't care if it's a imaginary chain or not they know that there's a header to something that exists so it comes up to the users like oh yes this is the header for that chain I can confirm that the NFT which was sent over is actually this crypto Kitty which is now on the finance chain we bought or sold and then it can be moved around in the bynars chain but it's essentially an IOU for the crypto Kitty on the original chain can actually get transferred to another chain and another chain take as many hops as you want you could backtrack all the way to the origin or just keep it over there so one of the sort of scenarios of that that I think are kind of exciting is the idea of wrapped Bitcoin you could imagine bitcoins getting sort of transferred via IBC into a larger ecosystem and then as the Bitcoin chain becomes unsecured after the 21 million it maybe gets shut down but all the sort of meme space of Bitcoin can live on on a more secure blockchain that doesn't require the same incentives so on the left there's an SDK tutorial link there's two different tutorials for onboarding the SDK if you want to build these sorts of things on the right is an example app that uses the NFT and if you're interested in using the new sample of the ibc implementation come talk to me because it's scary waters and I want to make sure that you have all these systems to make that happen any questions who's excited about the third wave of coins cool thanks you guys very much 