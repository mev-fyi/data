welcome to using flashbots to mint nfts on ethereum part one my name is scott bigelow and i am a co-founder of flashbots a service that has been running on the ethereum network for about a year which has improved the way that bot operators and miners communicate while improving the overall health of the ethereum network in this talk we will be discussing what flashbots is why you should use flashbots to mint nfts and we will build a typescript-based bot live that will mint nfts on ethereum using flashbots we will not be covering what an nft is or how you mint them so if this is something that you would like to get more familiarity with i will leave some links in the video description i recommend checking them out before popping back to this video in part two we will be extracting mev or maximally extractable value by minting nfts with flashbots what i mean by that is in this video we will be creating a transaction using flashbots which will send some amount of eth to an nft minting contract and so long as we land the transaction at the right time while this nft minting contract is is open for for new mints this contract will send us an nft back at the end of this transaction we will be down one eighth and up one nft and it is up to us to determine whether this this trade was worth it in part two we will add another component here which is a third-party service called artbotter.io artbotter is a system that allows users that are interested in an upcoming nft drop to place an order ahead of time that allows anyone else to fill that order and receive the eth that the user has staked this allows us to create a small little arbitrage here where we can buy an nft during the time which this nft minting is open effectively sell this nft to a user who has staked eth waiting for someone else to come along and buy the nft on their behalf and in doing so we will receive their eth that the contract was holding at the end of this transaction we will not have an nft we will have flipped this nft for more than we bought it for we will have 0.1 eth extra at the end of this transaction when we talk about extractable value we are talking about transactions which are intrinsically valuable that anyone can run on the ethereum network but if you are the one to do so you end up with more assets at the end than when you started so what is flashbots the best way to understand flashbots is to compare it to the standard ethereum transaction propagation mechanisms in this diagram this here is a signed ethereum transaction from an account that has eth to use as gas this could be created say by metamask it could be created by your hardware wallet but somehow you have created this transaction and you give it to the ethereum network either via infiera or your local node and this transaction will sit there and bounce around the ethereum network being copied from node to node to node until eventually it finds its way to a mining system that is waiting to create a block with many of these transactions that it is discovered in the same way and eventually these will become part of a block and they will be confirmed so this is not how the flashbot system gets transactions into blocks instead of operating on a single transaction flashbots operates on a bundle of transactions this is many transactions that are indicated in a very specific order to be included atomically instead of giving these transactions to the ethereum propagation system there is a flashbots relay which is a hosted service that can receive these bundles it will perform some lightweight inspection on the bundles to make sure that they are valid and profitable enough to be of interest to miners and it will send them along directly into these miners mempools waiting for the next block to get created and then they will appear all of the sudden not having been seen in the pending pool previously so why would you use flashbots to mint nfts many of the nft minting systems have restrictions in them preventing smart contracts from participating in these sales in part two one of the things we wanted to do was to mint an nft before selling it and we would like to do that in the exact same block we do not want to be stuck holding this nft while somebody else filled this order we really would like to buy and sell in the exact same block and not maintain any price exposure using bundled execution we can have multiple things happen in the same block even as the components we're acting with do not allow contract interactions we also get pre-confirmation privacy by sending transactions directly to these miners and avoiding this pending pool or dark forest we don't give our competitors a chance to see what we're doing until it's too late when it appears in a block we also get revert protection one of the agreements that flashbots enabled miners have is that if a transaction that you submit reverts when it executes on chain it won't be included by the miner it will be discarded and the next transaction will be selected instead this is a set of transactions from an nft drop of something called 8-bit token and these here are the newest transactions and these are the oldest this is either scan which sorts backwards in in some cases and we can see here that these users were able to successfully mint one of these tokens and later transactions were not able to do so right here in this in this one block is the cutoff point for when this nft sold out all of these users not only did they not get an nft they still had to pay the transaction fees associated that that caused their transaction to reverse so they are out really two things at once okay now that we've covered what flashbots is and why you would use flashboss to miss nfts let's jump into building a typescript based bot that will mint nfts using flashbots to do so we are going to be doing using the gorly ethereum test network i have two contracts here that i have previously deployed uh one of them is called waste gas and we're going to be using this one first as a demonstration to make sure that we have the flashbots library working and can submit real transactions to the network this waste gas is a very simple contract that simply receives any transaction sent to it and uses all of the gas available one of the things the flashbots relay confirms before sending the bundle to the miner is that a bundle uses enough gas to be interesting to the miner there is a amount of gas if you use less than the relay will give you an error saying please use more gas this is not something that's actually extracting value so this contract really just bypasses that check let's create a flashbots searcher or bot which targets waste gas and lands real transactions on the gorly network okay here i have a skeleton typescript project i have no code and no interesting libraries installed here i have some of the important typescript bits here but nothing related to ethereum has been added to this project yet so one of the first things that we want to do when we are working with ethereum is to install an ethereum library my favorite library here is the ethers.js library it's a nice modern library with well-defined typescript interfaces but because the flashbots relay is not an ethereum service it has different api endpoints that aren't covered by ethers.js with proper typing and friendly return types so we have our own bundle provider this is a flashbots plugin to the ethers system that allows you to communicate with the flashbots relay in a a developer friendly way okay and now we have these two dependencies installed this is all we're going to need from dependencies so let's go ahead and start coding let's pop open a typescript file index let's just make sure we have typescript working here so say hello so let's say ts node which is a a quick little tool that will run typescript for you without requiring it to be compiled first we say hello i also have an ide run button here which does the same thing uh the only difference being that when i run via my environment i have a environment variable already loaded up that has a private key for gourley that we'll be using okay so let's start um let's start coding well we're going to be talking to ethereum so one of the first things we're going to need is we're going to need a ethereum provider which is an interface that ethers gives you that allows you to communicate with an ethereum endpoint we'll say our ethereum provider equals fiera we're going to be using the in the furious system to talk to gourley and i happen to know that network id 5 is the network for corley add import here and i like to make this thing a little more friendly so let's go ahead and say this is our chain id we'll be using that later in our transaction and let's say uh how about provider dot get block number just make sure everything is working this is an asynchronous javascript function and we can't add in a weight here because we are not in an asynchronous function so we can just wrap this into a method and say great so now that we have this in a asynchronous method we can do this and let's actually make sure we output it right let's go ahead and write this to the uh terminal so i'm running this which will cause us to reach out to inferior get the block number printed so the inferior portion of this is working now let's make this just a little bit fancier let's go ahead and grab every single block that comes in whenever there's a new block i want to call a function that prints the block number so get rid of this one and now instead of printing it once i'm going to run this thing uh we're going to connect to infira and every time a new block comes in we are going to run this function which will just output block number okay great so that's it these are gorilla blocks okay now let's start interfacing with flashbots to do that we're going to need to instantiate that flashbots bundle provider that we installed earlier the way you do that is there is a flashbots bundle provider there is a create static factory method that returns to us an object that we can use to send bundles the arguments here are the generic provider because the flashbots relay doesn't actually have any requests you can ask it you can't say estimate gas you can't get a nonce you need to give the flashbots button provider a real ethereum provider that can allow it to help you build your bundles by asking questions of the ethereum network auth signer is the way that flashbots does user authentication you get to make up your own user effectively creating your own wallet so we can just say let's just create a random wallet this is used to kind of establish a reputation with flashbots to they can recognize when you send a lot of profitable bundles and if you are a consistent re-layer of profitable bundles for the miner they can prioritize traffic based on that and the last thing is the connection string this is the flashbots relay to connect to and i just recently read the docs so i know that this is relaygorly.flashbots.net and let's go ahead and just dump this into a constant i'll call this flashbots and points great okay so now we need to this is an async so i'm going to await this and we'll say flashbots provider equals this so now we have our flashbots provider object one of the unusual things about the way that you send transactions to flashbots is that instead of sending a transaction once into the pending pool and waiting for it to be included by a miner you must resend a flashbots bundle for every single block that you want it to be included this allows you to effectively cancel a transaction by just not sending it anymore you can you don't need to try to replace this with a transaction at the same knots you can just say you know what whenever this process dies that bundle should no longer be included because it isn't targeting any of the blocks all the blocks i was targeting have passed we need to start sending a bundle every single block that's why we set up this provider on block so we're going to say let's take this this flashbots provider we want to send a bundle well these bundles are multiple transactions so we have an array here the array wants us to specify transactions we'll be we'll come back to this but let's kind of get this this function call basically happy and it also wants a target block number right it wants to know which block would you like these transactions to be included in well we know what the block number is this is the current block number let's just always try to land our transactions in the next block so whenever we discover a new block we try to land whatever bundle we come up with here in the very next block and this is going to happen for every single block whether we land or not so let's start building the transaction details that will create a bundle of transactions that will get sent along via the flashbots relay we do this by submitting a transaction description along with a signing wallet so we have new wallet and this comes from provider.m dot i called it wallet private key this is the environment fire a variable uh sorry and this is process.n um so this is the environment variable i mentioned that is being included when i run this process uh let's go ahead and extract this into a variable like we do all of our things call this the wallet perfect an environment variable is something that might be present when this thing runs or it might not be and so actually if we run this let's go ahead and try to run this we're going to get a failure this is going to get upset because what it's saying is hey you know this this environment variable here wallet private key this could be undefined or it could be a string if you presented it and you are passing it to something that is not expecting an undefined value so by running logic here so let's say wallet private key if it equals undefined then console.wall console.error uh please provide wallet private key and we'll do a process dot exit here now when we run this typescript has recognized that we have taken care of the scenario in which uh see there's a different area we'll fix this but um it is recognized that this can no longer be undefined because if it was we would have exited this is one of the really nice things about using typescript um and uh the error here right we should give it a provider as well this allows us to run uh estimates later in uh when in the flashbots provider send bundle process okay so now that we've got all this intermediary work done let's start building the transaction that we would like flashbots to send to the gorly network miners so we can start asking for the kind of things we need to provide so a chain id we already have that it's five type we're gonna use a type 2 transaction which is eip1559 transaction we're going to use a value of well we're just wasting gas right so we're going to say how about value of zero expects a big number what else do we have to uh to add how about uh gas limits well we know we need to waste at more than 42 000 gas 50 000 it's kind of a nice round number data we don't really need to provide any data 0x is the way that you say null and let's start dealing with gas price uh we need to say well what is our base fee what is our max base fee that we're willing to pay efp1559 has made this actually a lot simpler when you're trying to do demo transactions so we just need to provide kind of a reasonable number here i don't even need to go look up what the right market value is here because it'll just select whatever is reasonable so this here is the way that you say gray so this is you know 10 to the ninth is a quay and let's say how many guy are we willing to pay how about we're going to pay three gwei for our base fee and we are willing to pay for our priority fee um actually you know what we're going to reuse this let's go ahead and take this and let's turn this into a constant because this is the the way we just reuse that in our our next thing it's a quay we'll say how about we're willing to pay this much for our priority fee and the last thing we have here is two right this is the the destination of our transaction let's pop over here to our waste gas copy that address pop over here let's say two is going to be this right this is uh this is the specifying the waste gas contract address uh we're going to waste 50 000 gas but we're going to do so by sending a bundle to flashbacks this is not going to be sent along to the standard pending pool i think we have everything here we need to run let's go ahead and click it now not every miner on the gorilla network is a flashbots miner and so there is going to be several blocks that that go by here where we don't get included because if the gorilla miner that mines that block is in flashbots it will not have received this transaction it has no chance of including it but we do have a girly enabled miner so when it's that miners turn so long as we get this transaction to them in time we will see that this contract here has an inbound transaction okay there we go we have our transaction that did not show pending and all of a sudden showed up in a block if we take a look at the transaction details here we can see that this transaction has all the details that we specified in our transaction description on sendbundle we have our destination we have the the various gas prices we configured here's the 50 000 gas and true to form the waste gas contract wasted all of our gas for us ensuring that this became a valid bundle in the eyes of the flashbots relay but wasting gas isn't really what we came here to do we came here to buy nfts and so i set up a contract here called fake mentor this is already deployed on the growing network as well let's take a look at that and this is a very very paired down implementation of what the contracts on mainnet look like for minting nfts this is a fake erc 721 contract which is the you know the standard usually used for nfts um and we you know we deploy this ourselves our our own fake nft ish contract but this contract itself here is the fake art minter contract which has a function in it which requires you to send some bit of if in this case 0.03 and we will if you do so mint an nft directly into your account we'll admit a message and then the owner of this contract of the fake art mentor me will receive the 0.03 if that you sent in order to buy this nft so what we need to do is take the example that we just created and instead of calling 0x or no no call data we need to call this mint function so let's pop over here so let's really just change this system to target the mint function of a different contract uh well one of the most obvious changes we'll need to make is we're targeting a new contract just grab copy this address paste it um fifty thousand gas is almost certainly not going to be enough to to do all the things that this needs to do with minting the 721 and forwarding the eth but one of the really nice things about this flashbots provider is that this gas limit here is really an override you don't need to provide it and if you delete that attribute the flashbots provider will recognize that there is no gas limit provided and perform an estimate gas in order to populate that at the last minute before signing your transaction and sending it along to the flashbots relay the rest of these transactions look good except for well value right we decided that you needed 0.03 to cause that function to succeed onto the mint um so let's actually make sure we're sending that that value along well how do we say 0.03 we can say well how about well 10 to the power of 18 is uh is an ether right so let's go ahead and make this a uh a constant ether all right so we have our guayana ether here um but right we don't want to spend send a full ether right that's too much we need to say well how about an ether divided by a hundred mole three this is how you say 0.03 you could also say big number.from and pass it a string but this is uh this is a nice elegant way to to pass value and be able to change it easily later the last bit of information that is needed here is data this is the call data that is passed to the contract that needs to make sure that mint is the function that we are invoking there are there's a lot of ways to come up with what this call data is ethers itself has some really nice utilities around abi parsing but we're going to skip all that and do the really really easy way we are going to say connect to web3 we'll choose metamask yeah etherscan has access to our web3 object we'll go to mint we can say well this is the the amount of ether to include in it if there was other parameters you would you would have text boxes for them here and we'll say write okay we have our meta mask pop-up here and all this is is garbage all that we really care about for this is the data tab here under hex data ether scan and metamask have already done the the abi parsing that was necessary in order to figure out that this is the call data that you use to call the mint function so we can just copy this pop back we'll reject it right we didn't want to actually do this via meta mask uh we'll come over here and paste this and this should be good to go we now have changed our little demo here to target a different contract and just like before we are you know every single block sending this transaction to the next block target okay i'm hitting run here let's pop back over and look for inbound transactions to this contract okay so there we go our transaction appeared out of nowhere it was not pending and appeared suddenly in this block and again if we go look at the transaction details we see all the details that we specified the gas limit right we didn't type in this number but the bundle provider was able to estimate that this was the amount of gas required and populated it without us doing anything we have all you know the same gas fees as before etherscan is able to say like oh well this is this is the mint function that you called reversing it from the data that we passed and here we can see this is our our nft mint right we were able to actually get you know token id6 of this fake nft contract and you know here's the 0.03 eth right here um right so so this is the way that you can target arbitrary contract functions uh using meta mask simply to extract the data that you need for the call data which is really that missing part and i'm sure you're thinking that uh well you know you're not really trying to mint these fake tokens you're trying to mint uh you know some some other token you're interested in let's take a look at a couple others and see how we might have used a similar system to mint those nfts this is a production token called 8-bit it was the same one that i showed before where it sold out there was those failures within that same block and just as before we can go to contract right contract and you might need to do a little bit of digging here but it's pretty obvious we're talking about the mint bit uh you know this required some amount of eth you might need to uh you know either find the the value required for uh fermenting either as a read let's see let's do it here uh read contract attribute many times they'll have that the price here perfect right this is the price and in here they want it as ether i happen to know this is just you know .08888 you might need to convert this value from way into ether to work it here but honestly this doesn't really matter what we're trying to do is just get the call data from this this is a good example here because you can mint a different number of tokens depending on the call data you pass so let's say that you and your flashbots wanted to bin three but we can say right here after connecting the metamask don't forget that you can say three here pop over the data this data is a lot longer right so we have here the function signature and then there's the three but it's going to be really important that you kind of you copy this entire thing uh before coming back you know and and pasting it along here with the correct um destination of the minting contract how about another one this is the the board apes yacht club go to write contract and here we go mint ape again you can figure out some amount of ether you might need to read it either from the contract source code or from here here we have eight price perfect we can say number of tokens how about seven let's get greedy again connect your web3 provider got it seven this transaction of course isn't going to succeed the uh you know board apes is not open for minting but we can still use this as a good example again here we are we're getting that hex value this is one way that you can look at a contract and use a system like flashbots to figure out what that contract needs called on it and instead of doing so with metamask you can instead bring that data into flashbots and have flashbots do it on the backend and get all those benefits that we've previously discussed so let's just walk through a couple of quick things we might want to add to this well this is sendbundle which is a function that returns a promise of a very useful object for submitting bundles so let's go ahead and say i would like my let's say bundle submit response uh and of course this also needs to be an async function since this is a callback so we have this submit response here and this does not throw when it has an error this returns uh an error as a kind of a more standard response type that is not fatal so one of the things we need to do before we start interacting with a submit response is make sure that it is not an error response so you can just say you know if error in bundle submit response then we'll just say let's go ahead and log the error message so it's going to be bundle submitresponse.error.message and we'll just return so that way we know when something bad is happening but it's not something that we need to handle right now but since we've done so we now know that bundle submit response is not an error object it is a a successful response object we can have we can call this wait function which is a promise that we'll wait until the block we have targeted um hits and it will tell us about what happened were we included or not uh i'll also simulate this is a very very important function that allows us to even before the target block has come to ask the flashbots relay to simulate what would happen if this if this was included which can tell us if our overall bundle is working properly so i'll go ahead and just console log this and i'll hit run we're going to submit this bundle but before that block even comes we have asked the relay to tell us about what happened specifically uh what the coinbase diff is right this is what we are incentivizing the miner with by what we are willing to pay the coin base uh so this can tell us you know whether this thing reverted this will tell us um you know if this thing had a evm response it would tell us what that evm response if there was an error we would see that here so if you're having problems landing a transaction this gives you a chance to see it because you don't see it on chain the same way that you see when you actually land a transaction and figure out what's going on this is the alternative to that and it's free you don't need to pay any of these revert fees to to get this data you might also want to put something here like a a gas price getter so we have here what the the max fee per gas is and max priority fee and these are static if you are trying to get into an nft air drop that could be a very competitive thing this might be a great place to call some sort of a function like you know get reasonable gas price that looks at you know what were people paying in the very last block to get into this nft and can i copy those values and add five percent on top of that because many of these gas stations that will tell you what a reasonable gas price to use aren't expecting these massive gas price changes that occur within just a few blocks while these nft drops are happening and you might need to you know create your own gas price oracle that is more targeted to these sudden changes in gas price if you're interested in learning more about flashbots i invite you to check out docs.flashbots.net where we keep a lot of up-to-date and useful information about how to interact with flashbots we have a lot of concepts we haven't covered we didn't cover how bundles are priced so that we can select one bundle over the other coinbase transfers paying feeds without using gas rpc endpoints where you can learn how to interact with the endpoint yourself if you didn't want to use the the flashbots bundle provider we have the search reputation system where we created that random wallet that we didn't use there's a bunch of information here about you know why you might use that and how to take advantage of it 1559 examples we have other libraries if you wanted to use say you know go we have a python library we also have our github if you're interested in more example searchers to to base your work on and our discord is a very active place especially for searchers or you know people who are writing bots there is a channel there called searchers with a lot of really helpful people helping others get their bots up and running and sharing strategies for how to extract that you know that 0.1 eth from ethereum okay and that's it so don't forget to subscribe to get notified when part 2 comes out where we learn how to turn 1 8 into 1.18 i'll see you then 