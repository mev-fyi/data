hello my name is Scott Bigelow and I'd like to talk to you today about front running in aetherium and specifically I'd like to show you what it's like to be a victim of being front runner I've been working in the ethereum ecosystem since about 2017 and in the last year I've started working full-time as a solidity auditor and I'm currently working with the etherium foundation providing free quick checks for well-known security issues to projects that are deploying on aetherium now this offering of free security checks is called spot check and if you have an etherion project that is nearing main net released my information is listed on the slide you can reach out to me via email or I'll have some more contact information in the video description and while providing this feedback to projects there's been a couple of front-running based issues that I found and reported and the the project developers ended up fixing these issues but in the conversations around them I always got the sense that there was a hint of disbelief that what we were talking about was a bit theoretical in nature and that it wasn't until the project had many many users and thousands of beats stored in it that front running would ever become a serious issue and what I would like to demonstrate today is that front running is an issue that impacts all projects of all sizes and nobody is safe because of a lot of the software out there being you know very intelligent about the way that it operates it doesn't even need to understand that much about the way that your system works to exploit it so in this talk I'd like to talk a bit about what front-running is and then we're going to just jump into writing and deploying a simple contract from remix we're going to seed this contract with a small amount of eath and we're gonna actually get front run we are going to waste a little bit of beef for what I hope is a valuable or at least entertaining learning experience so what is front running one of the answers I have for this revolves around crypto kitties this is a project started back in can run around to 2017 and it's a project that allows you to have these non fungible tokens that represent these these crypto kitties and they have these genetics in them and that's that's not really an important part for this but what is important is the birthing process the process by which somebody takes to crypto kitties that they own or have access to and submit a transaction to the blockchain that says hey I would like to take these two kitties and I want to make a new one out of their attributes and this is a non chained process that it takes these attributes and merges them into a new one but this process isn't instantaneous this process has a cool down and actually requires two different transactions one transaction here two to signal the intent of the owner to create a new kitty from these two some period of time has to elapsed this could be minutes this could be hours or even days and then finally on the other side a Kitty pops out but there needs to be a transaction right here right nothing happens on the theory and without a transaction and this is actually a time-sensitive one we're after the kitty is eligible eligible to be born and it needs about an hour after that to be born or else the process kind of falls apart there's an element of randomness in its creation and that that randomness is only available for about an hour and so if you were interested in birthing crypto kitties because there is a small amount of eath to be gained in doing so let's walk through that process let's say that you decide that you want to be the person who sends this transaction that actually takes somebody else's intent to create a crypto Kitty and actually makes one so this is the crypto Kitty's contract and this is you and you're having a great day and you're looking for a new aetherium project you thought make a little bit of eath on the side so you fire up your development environment and you figure out how to comb through the crypto kiddies event logs to figure out when crypto kitties are ready to be born and your software sits there and waits for the right moment and finally fires transactions when the time is just right and so let's say that some time is elapsed the software works and it decides that Kitty number 72 is ready to be born now and it goes ahead and forwards along you know some fairly significant amount of gas to accomplish this birthing process and the cryptic a contract verifies that this is indeed like when this Kitty was born and this is an active Kitty and nobody's tried to birth it before and it sends the reward back to the user currently this reward is 0.01 six teeth and it utilizes the gas provided in this transaction to to birth this new crypto Kitty and the user is you know pretty happy about this because depending on the gas prices that are that are active at that moment you know they could end up with a decent little profit here the problem however is that this isn't the only person on a theory there's somebody else and this person has wrote a different bit of software and this software doesn't really know anything about crypto kitties it doesn't know anything about cat genetics and knows nothing but what it does know about is the etherium pending queue because when this person calls this birthing function on the crypto Kitty's contract this isn't an instantaneous process this is a transaction that is submitted to a pending queue and it could be sitting this pending queue for a few seconds it could be there for a minute or two you know even if you pick a fairly competitive gas price it could still take you know some you know non-trivial amount of time before this pending transaction becomes confirmed by the etherium network and during that time this transaction is available to everyone and some software trolls through these transactions looking at each one of them to see that if they instead run this transaction instead of the sender if they would personally benefit from it and so what is it what it would do is come through and say hey you know what if I were to do this birth katieb number 72 transaction instead of this person I would be the one that receives this 0.01 60 it's able to emulate what would happen if they did this before it actually submits the transaction to the chain so they decide that it would be beneficial for them to do so so they copied the entirety of this birth KT 72 transaction with the destination with the call data everything it doesn't even know what it's doing all it knows is the if it does so it is rewarding so it sends this copied transaction with a slightly higher gas price here they select at 11 here they select at 10 and in doing so they're likely to end up in a block that is earlier in the blockchain or if it even lands on the same block higher in the transaction order and so by the time crypto kiddies contract processes this transaction it will say yeah thank you thank you for birthing this kiddie number 72 here's your 0.016 eath reward and since that cat was already born by the time this transaction over here comes along the one that actually did all the work to figure out when this kiddie was ready to be born submitting that first transaction that becomes a fail because only only one kiddie is going to be rewarded you can't you can't have two births of the same kitty and so that makes this person really angry of course because not only have they missed out on this 0.016 'if they did all of the work to figure out when this crypto kitty was ready to be born and their reward for this is a negative 0.0003 eath if they were paying Tanguay because even transactions that fail cost some amount of gas it's not going to be that full 200 but it's also not nothing and also 10 really isn't even the current gas price we're currently looking at gas prices closer to 30 40 or even 50 right now so these losses can really accumulate in the meantime this person is benefitting significantly from somebody else's work so let's go ahead and create a contract that is susceptible to the same style of front-running and and see if we can actually catch it happening in the wild we're going to be using remix which is a a solidity I think they actually support Viper now but it is a an online aetherium development environment that allows you to write a theory am confident raise deploy it to various you know either test or main net a theory on block chains and actually company or deploy it interact with it read values off of it it's a really useful tool and so we're going to be creating a vulnerable contract inside of this side of this environment so let's go ahead and create a contract in this contract it's we be called front run mean that's all we're going to specify which version of solidity we want to use and we're gonna call this contract of course front run me now the way this contract is going to work is that during construction we are going to pass in a cache of 256 hash that only we know the answer to we're going to have a value that when hashed spits out this value and so we're going to verify later that if you know this secret value we'll verbal forward you all eat the distort in this contract so we're gonna have to store permanently this bites 32 value and we're gonna call this secret hash constructor which is going to take an argument of a secret hash and we're going to just go ahead and set it to storage value so we can specify this at deployment time and it'll just end up in this variable here also I mentioned we want it to be seating this with some small amount of beef to incentivize front-running so we're going to make this constructor payable as we create the contract we can actually forward value to it the other function you want to create is just a take function so this is one where somebody can submit a I made a mistake here this would be by 32 so anybody can submit a a string of bytes actually we will make this a string just for ease of interaction and anybody can interact with it and if you an in this function if the hash of the secret you pass in matches this hash then we'll go ahead and send you all the e that is available on this contract so we'll say if the hash it's just a way to kind of convert a string into to these bytes so if the hash of what you pass in equals the hash that we stored during construction we'll go ahead and send you all dthe mr. sender so whoever called this will go ahead and transfer you the balance that's good let's go ahead and see if this thing compiles so we have a just a licensing warning here newer solidity is complain about this it's not fatal but it's nice to not have any warnings just in case of warnings do pop up you don't ignore them great so here we have a contract that that looks like it compiles there's one more function I'd like to add and that is just I'd like to admit some logs on success and failure so we have a success event we have a fail that's and if you are on the success path we'll go ahead and emit a success event log and if you did not match this correctly we'll go ahead and emit a fail great so before we sit before we ship this to ethereal maintenance let's go ahead and run this in on a test aetherium Network and remix provides one of these just built in right away and there's a JavaScript VM gives you a bunch of accounts that have like 108th on them and all runs right in the browser it's super convenient but in order to to do this we're going to need to come up with these secret hash and this secret so they kind of have this you know this private public value so here's an online hash generator and let's just start slapping some keys here right there just typing in a bunch of random values it doesn't really matter all we need to make sure is that nobody else is likely to be able to guess that this is the value that hashes to this hash some ones like to just grab stuff here just to make it look super random so this is a pretty randomized string and this value here I'll just actually I'll just say the value here too so it's really obvious what we're doing so that's becomes part of the actual string itself we have this string here hashes to this value so we're going to copy the hatch and we'll go ahead and say I made the constructor payable I'm going to go ahead and include one ether and 0ex paste so this is the hash from that tab and we'll say we had before deploy so here we have a deployment of this front run me contract I look at the secret hash it matches what we paste it in here you'll also notice that we've been deducted one either from the value we typed in here so we're sitting at about 99 a third if we just put in the wrong value here and say take you'll see that we have we hit the fail event and we were not credited any eath whereas if we go over here copy the value that went into the creation of this hash and passed this value in instead we get success and not only that where we had about 99 eighth before we'd have almost a hundred 'if now back in the job and the JavaScript via so this contract did actually send us back the eath that we initially seeded it with okay so let's go ahead and do the rest of this let's actually ship this thing to aetherium main net and let's watch the swatch ourselves give front-run okay so I have a a real main that theorem account here and it's been seeded with a small amount of ETS we have one ether on aetherium a net here and we have we're resetting 0.035 that should be enough to incentivize front-running also again I'm going to need to recompile we can just go ahead and deploy the contract that we had before we're gonna use the exact same values we had before this is that 0 X 8 7 1 0 X 8 7 1 great let's go ahead and deploy this gas prices fairly high today so let's let's do this I should be good let me check real quick oh that's a good value okay so we're going to be confirming this transaction paying a decent amount in the deployment fee all right so all those like that transaction was able to mine successfully we can see that transaction here so there's that 0.035 ether that we see that this transaction with and now let's go ahead and try to using our secret that only we know pass in the value - it's actually withdraw ether from this contract again we can verify that that secret hash truly did get set in that storage location and here is this take again passed with the the value that course that when hashed corresponds to the hash that was stored stored in the storage of that contract let's go ahead and do need make this fast right because you know we'll make sure that these other people have plenty of time to see this but I very much doubt that's gonna be a problem so go ahead and make this I don't know how about 33 33 quite but in doing so we're going to be publishing this contract to the pending queue and divulging this answer that at this moment only we know but everyone is about to know it all right you can see this data this is the encoding of of that that string let's go for it all right so now that we've sent this pending transaction into the wild we can go ahead and take a look at it and we'll see that this transaction is indeed still pending this is our source account this is the contract and this is where we have specified the input that enables us to withdraw that 0.035 let's see they're still pending however if you go to the contract itself you can see this contract has already been drained even though our attempt to train it has it is still waiting to process if we go ahead and look at our events that we added which made it a little bit easier to spot when these withdrawals were happening we can see that there is already even without our transaction having landed three attempts to take this 0.035 ether from this contract so let's go ahead and and pop these ones open so we have one two three let's see what happened here so here we have the winner because there actually was a transfer here of 0.035 ether we can see that this is not the contract address that we deployed but they ended up calling their own contract which called the action which called the one we deployed via an internal transaction we don't see the gas price they paid for this was pretty hefty it was 122 guei they ended up paying 0.01 in transaction fees in order to grab this 0.035 let's see the other transactions here okay well that we see why this person paid this 122 way it's because they were out bidding someone else who was trying to front run our transaction as well so we see this you know for for 303 let's again see it over here for for 305 right so this person was outbid by you know point zero zero zero zero zero two way they landed higher so here we have these are all frontrunners but even amongst themselves they themselves are front running each other so this person paid a hundred twenty two way but they did not land properly even though they had the right answer there was no ether left to send and they ended up paying sixty cents even though they ended up with nothing in the end and the last one is somebody who did call the contract directly this is that contracts an actual address and again they just failed they submitted forty-three and these all landed in the same block you see this they landed in one two eight one two eight one two eights so they all landed like very very very shortly after that transaction hit the pending pool but again because of this gas price in the transaction ordering within that block this one over here that paid just very slightly more than the other one was the one who ended up walking with this 0.035 then remember like this is the contract here right this is not a verified contract this is not a contract that anybody has ever seen before nobody probably even understands well what it's actually doing all they knew was that when they copied this transaction that that I sent here that is still pending they knew that when they copied what I was trying to do they would end up receiving point zero three five eighth and so they took that opportunity and this deceit has been effectively you know stolen from us yep so that's it that's what I wanted to show you here today is that front running on main net is a is a real thing that happens at you know fairly small values and with projects that's that these front runners don't even understand how they work they look at these like black boxes that they can extract value from so yeah don't ever think that front running won't impact you because your project isn't well known yet it can happen when a project is as well-known as these bites that have nobody's ever seen before with a hash that nobody has ever seen before so thanks let me know what you think of the video is up maybe the next video we can talk about ways that you can combat front-running or I was considering talking a bit about how quickly divulging a private key on github or accidentally in various ways end up with transaction that steal that ether from you so yeah lemon don't you think the ones you'd like to see next and I'll talk to you later 